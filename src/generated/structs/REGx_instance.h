/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/IEE__IEE_RT1170_REGATTR_MD.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * Region Registers
 */
struct [[gnu::packed]] REGx_instance
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        160; /*!< REGx_instance's size in bytes. */

    /* Fields. */
    uint32_t
        REGATTR; /*!< (read-write) IEE Region REGION Attribute Register. */
    const uint32_t reserved_padding0 = {};
    uint32_t REGPO; /*!< (read-write) IEE Region REGION Page Offset Register */
    static constexpr std::size_t reserved_padding1_length = 13;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    static constexpr std::size_t REGKEY1__length = 8;
    uint32_t REGKEY1_[REGKEY1__length]; /*!< (read-write) IEE Region REGION Key
                                           1 Register */
    static constexpr std::size_t reserved_padding2_length = 8;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    static constexpr std::size_t REGKEY2__length = 8;
    uint32_t REGKEY2_[REGKEY2__length]; /*!< (read-write) IEE Region REGION Key
                                           2 Register */

    /* Methods. */

    /**
     * Get REGATTR's BYP bit.
     *
     * AES Bypass.
     */
    inline bool get_REGATTR_BYP()
    {
        return REGATTR & (1u << 7u);
    }

    /**
     * Set REGATTR's BYP bit.
     *
     * AES Bypass.
     */
    inline void set_REGATTR_BYP()
    {
        REGATTR |= 1u << 7u;
    }

    /**
     * Clear REGATTR's BYP bit.
     *
     * AES Bypass.
     */
    inline void clear_REGATTR_BYP()
    {
        REGATTR &= ~(1u << 7u);
    }

    /**
     * Toggle REGATTR's BYP bit.
     *
     * AES Bypass.
     */
    inline void toggle_REGATTR_BYP()
    {
        REGATTR ^= 1u << 7u;
    }

    /**
     * Get REGATTR's MD field.
     *
     * AES Mode.
     */
    inline IEE__IEE_RT1170_REGATTR_MD get_REGATTR_MD()
    {
        return IEE__IEE_RT1170_REGATTR_MD((REGATTR >> 4u) & 0b111u);
    }

    /**
     * Set REGATTR's MD field.
     *
     * AES Mode.
     */
    inline void set_REGATTR_MD(IEE__IEE_RT1170_REGATTR_MD value)
    {
        uint32_t curr = REGATTR;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        REGATTR = curr;
    }

    /**
     * Get REGATTR's KS bit.
     *
     * AES key size.
     */
    inline bool get_REGATTR_KS()
    {
        return REGATTR & (1u << 0u);
    }

    /**
     * Set REGATTR's KS bit.
     *
     * AES key size.
     */
    inline void set_REGATTR_KS()
    {
        REGATTR |= 1u << 0u;
    }

    /**
     * Clear REGATTR's KS bit.
     *
     * AES key size.
     */
    inline void clear_REGATTR_KS()
    {
        REGATTR &= ~(1u << 0u);
    }

    /**
     * Toggle REGATTR's KS bit.
     *
     * AES key size.
     */
    inline void toggle_REGATTR_KS()
    {
        REGATTR ^= 1u << 0u;
    }

    /**
     * Get all of REGATTR's bit fields.
     *
     * (read-write) IEE Region REGION Attribute Register.
     */
    inline void get_REGATTR(bool &BYP, IEE__IEE_RT1170_REGATTR_MD &MD,
                            bool &KS)
    {
        uint32_t curr = REGATTR;

        BYP = curr & (1u << 7u);
        MD = IEE__IEE_RT1170_REGATTR_MD((curr >> 4u) & 0b111u);
        KS = curr & (1u << 0u);
    }

    /**
     * Set all of REGATTR's bit fields.
     *
     * (read-write) IEE Region REGION Attribute Register.
     */
    inline void set_REGATTR(bool BYP, IEE__IEE_RT1170_REGATTR_MD MD, bool KS)
    {
        uint32_t curr = REGATTR;

        curr &= ~(0b1u << 7u);
        curr |= (BYP & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(MD) & 0b111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (KS & 0b1u) << 0u;

        REGATTR = curr;
    }

    /**
     * Get REGPO's PGOFF field.
     *
     * This field represents a 4Kb page offset
     */
    inline uint32_t get_REGPO_PGOFF()
    {
        return (REGPO >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set REGPO's PGOFF field.
     *
     * This field represents a 4Kb page offset
     */
    inline void set_REGPO_PGOFF(uint32_t value)
    {
        uint32_t curr = REGPO;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        REGPO = curr;
    }

    /**
     * Set REGKEY1_'s KEY1 field.
     *
     * Key 1.
     */
    inline void set_REGKEY1__KEY1(std::size_t index, uint32_t value)
    {
        uint32_t curr = REGKEY1_[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REGKEY1_[index] = curr;
    }

    /**
     * Set REGKEY2_'s KEY2 field.
     *
     * Key 2.
     */
    inline void set_REGKEY2__KEY2(std::size_t index, uint32_t value)
    {
        uint32_t curr = REGKEY2_[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REGKEY2_[index] = curr;
    }
};

static_assert(sizeof(REGx_instance) == REGx_instance::size);

}; // namespace MIMXRT1176::CM7
