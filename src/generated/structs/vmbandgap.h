/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * no description available
 */
struct [[gnu::packed]] vmbandgap
{
    /* Constant attributes. */
    static constexpr std::size_t size = 96; /*!< vmbandgap's size in bytes. */

    /* Fields. */
    uint32_t CTRL0;     /*!< (read-write) Analog Control Register CTRL0 */
    uint32_t CTRL0_SET; /*!< (read-write) Analog Control Register CTRL0 */
    uint32_t CTRL0_CLR; /*!< (read-write) Analog Control Register CTRL0 */
    uint32_t CTRL0_TOG; /*!< (read-write) Analog Control Register CTRL0 */
    static constexpr std::size_t reserved_padding0_length = 16;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t STAT0;     /*!< (read-write) Analog Status Register STAT0 */
    uint32_t STAT0_SET; /*!< (read-write) Analog Status Register STAT0 */
    uint32_t STAT0_CLR; /*!< (read-write) Analog Status Register STAT0 */
    uint32_t STAT0_TOG; /*!< (read-write) Analog Status Register STAT0 */

    /* Methods. */

    /**
     * Get CTRL0's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline bool get_CTRL0_REFTOP_SELFBIASOFF() volatile
    {
        return CTRL0 & (1u << 4u);
    }

    /**
     * Set CTRL0's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void set_CTRL0_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0 |= 1u << 4u;
    }

    /**
     * Clear CTRL0's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void clear_CTRL0_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL0's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void toggle_CTRL0_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0 ^= 1u << 4u;
    }

    /**
     * Get CTRL0's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline bool get_CTRL0_REFTOP_LOWPOWER() volatile
    {
        return CTRL0 & (1u << 3u);
    }

    /**
     * Set CTRL0's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void set_CTRL0_REFTOP_LOWPOWER() volatile
    {
        CTRL0 |= 1u << 3u;
    }

    /**
     * Clear CTRL0's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void clear_CTRL0_REFTOP_LOWPOWER() volatile
    {
        CTRL0 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL0's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void toggle_CTRL0_REFTOP_LOWPOWER() volatile
    {
        CTRL0 ^= 1u << 3u;
    }

    /**
     * Get CTRL0's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline bool get_CTRL0_REFTOP_PWDVBGUP() volatile
    {
        return CTRL0 & (1u << 2u);
    }

    /**
     * Set CTRL0's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void set_CTRL0_REFTOP_PWDVBGUP() volatile
    {
        CTRL0 |= 1u << 2u;
    }

    /**
     * Clear CTRL0's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void clear_CTRL0_REFTOP_PWDVBGUP() volatile
    {
        CTRL0 &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL0's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void toggle_CTRL0_REFTOP_PWDVBGUP() volatile
    {
        CTRL0 ^= 1u << 2u;
    }

    /**
     * Get CTRL0's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline bool get_CTRL0_REFTOP_LINREGREF_PWD() volatile
    {
        return CTRL0 & (1u << 1u);
    }

    /**
     * Set CTRL0's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void set_CTRL0_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0 |= 1u << 1u;
    }

    /**
     * Clear CTRL0's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void clear_CTRL0_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0 &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL0's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void toggle_CTRL0_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0 ^= 1u << 1u;
    }

    /**
     * Get CTRL0's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline bool get_CTRL0_REFTOP_PWD() volatile
    {
        return CTRL0 & (1u << 0u);
    }

    /**
     * Set CTRL0's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void set_CTRL0_REFTOP_PWD() volatile
    {
        CTRL0 |= 1u << 0u;
    }

    /**
     * Clear CTRL0's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void clear_CTRL0_REFTOP_PWD() volatile
    {
        CTRL0 &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL0's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void toggle_CTRL0_REFTOP_PWD() volatile
    {
        CTRL0 ^= 1u << 0u;
    }

    /**
     * Get all of CTRL0's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void get_CTRL0(bool &REFTOP_SELFBIASOFF, bool &REFTOP_LOWPOWER,
                          bool &REFTOP_PWDVBGUP, bool &REFTOP_LINREGREF_PWD,
                          bool &REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0;

        REFTOP_SELFBIASOFF = curr & (1u << 4u);
        REFTOP_LOWPOWER = curr & (1u << 3u);
        REFTOP_PWDVBGUP = curr & (1u << 2u);
        REFTOP_LINREGREF_PWD = curr & (1u << 1u);
        REFTOP_PWD = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL0's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void set_CTRL0(bool REFTOP_SELFBIASOFF, bool REFTOP_LOWPOWER,
                          bool REFTOP_PWDVBGUP, bool REFTOP_LINREGREF_PWD,
                          bool REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b1u << 4u);
        curr |= (REFTOP_SELFBIASOFF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (REFTOP_LOWPOWER & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REFTOP_PWDVBGUP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REFTOP_LINREGREF_PWD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REFTOP_PWD & 0b1u) << 0u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0_SET's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline bool get_CTRL0_SET_REFTOP_SELFBIASOFF() volatile
    {
        return CTRL0_SET & (1u << 4u);
    }

    /**
     * Set CTRL0_SET's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void set_CTRL0_SET_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_SET |= 1u << 4u;
    }

    /**
     * Clear CTRL0_SET's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void clear_CTRL0_SET_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_SET &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL0_SET's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void toggle_CTRL0_SET_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_SET ^= 1u << 4u;
    }

    /**
     * Get CTRL0_SET's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline bool get_CTRL0_SET_REFTOP_LOWPOWER() volatile
    {
        return CTRL0_SET & (1u << 3u);
    }

    /**
     * Set CTRL0_SET's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void set_CTRL0_SET_REFTOP_LOWPOWER() volatile
    {
        CTRL0_SET |= 1u << 3u;
    }

    /**
     * Clear CTRL0_SET's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void clear_CTRL0_SET_REFTOP_LOWPOWER() volatile
    {
        CTRL0_SET &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL0_SET's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void toggle_CTRL0_SET_REFTOP_LOWPOWER() volatile
    {
        CTRL0_SET ^= 1u << 3u;
    }

    /**
     * Get CTRL0_SET's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline bool get_CTRL0_SET_REFTOP_PWDVBGUP() volatile
    {
        return CTRL0_SET & (1u << 2u);
    }

    /**
     * Set CTRL0_SET's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void set_CTRL0_SET_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_SET |= 1u << 2u;
    }

    /**
     * Clear CTRL0_SET's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void clear_CTRL0_SET_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_SET &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL0_SET's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void toggle_CTRL0_SET_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_SET ^= 1u << 2u;
    }

    /**
     * Get CTRL0_SET's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline bool get_CTRL0_SET_REFTOP_LINREGREF_PWD() volatile
    {
        return CTRL0_SET & (1u << 1u);
    }

    /**
     * Set CTRL0_SET's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void set_CTRL0_SET_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_SET |= 1u << 1u;
    }

    /**
     * Clear CTRL0_SET's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void clear_CTRL0_SET_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_SET &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL0_SET's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void toggle_CTRL0_SET_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_SET ^= 1u << 1u;
    }

    /**
     * Get CTRL0_SET's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline bool get_CTRL0_SET_REFTOP_PWD() volatile
    {
        return CTRL0_SET & (1u << 0u);
    }

    /**
     * Set CTRL0_SET's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void set_CTRL0_SET_REFTOP_PWD() volatile
    {
        CTRL0_SET |= 1u << 0u;
    }

    /**
     * Clear CTRL0_SET's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void clear_CTRL0_SET_REFTOP_PWD() volatile
    {
        CTRL0_SET &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL0_SET's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void toggle_CTRL0_SET_REFTOP_PWD() volatile
    {
        CTRL0_SET ^= 1u << 0u;
    }

    /**
     * Get all of CTRL0_SET's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void get_CTRL0_SET(bool &REFTOP_SELFBIASOFF, bool &REFTOP_LOWPOWER,
                              bool &REFTOP_PWDVBGUP,
                              bool &REFTOP_LINREGREF_PWD,
                              bool &REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0_SET;

        REFTOP_SELFBIASOFF = curr & (1u << 4u);
        REFTOP_LOWPOWER = curr & (1u << 3u);
        REFTOP_PWDVBGUP = curr & (1u << 2u);
        REFTOP_LINREGREF_PWD = curr & (1u << 1u);
        REFTOP_PWD = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL0_SET's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void set_CTRL0_SET(bool REFTOP_SELFBIASOFF, bool REFTOP_LOWPOWER,
                              bool REFTOP_PWDVBGUP, bool REFTOP_LINREGREF_PWD,
                              bool REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0_SET;

        curr &= ~(0b1u << 4u);
        curr |= (REFTOP_SELFBIASOFF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (REFTOP_LOWPOWER & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REFTOP_PWDVBGUP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REFTOP_LINREGREF_PWD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REFTOP_PWD & 0b1u) << 0u;

        CTRL0_SET = curr;
    }

    /**
     * Get CTRL0_CLR's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline bool get_CTRL0_CLR_REFTOP_SELFBIASOFF() volatile
    {
        return CTRL0_CLR & (1u << 4u);
    }

    /**
     * Set CTRL0_CLR's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void set_CTRL0_CLR_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_CLR |= 1u << 4u;
    }

    /**
     * Clear CTRL0_CLR's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void clear_CTRL0_CLR_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL0_CLR's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void toggle_CTRL0_CLR_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_CLR ^= 1u << 4u;
    }

    /**
     * Get CTRL0_CLR's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline bool get_CTRL0_CLR_REFTOP_LOWPOWER() volatile
    {
        return CTRL0_CLR & (1u << 3u);
    }

    /**
     * Set CTRL0_CLR's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void set_CTRL0_CLR_REFTOP_LOWPOWER() volatile
    {
        CTRL0_CLR |= 1u << 3u;
    }

    /**
     * Clear CTRL0_CLR's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void clear_CTRL0_CLR_REFTOP_LOWPOWER() volatile
    {
        CTRL0_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL0_CLR's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void toggle_CTRL0_CLR_REFTOP_LOWPOWER() volatile
    {
        CTRL0_CLR ^= 1u << 3u;
    }

    /**
     * Get CTRL0_CLR's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline bool get_CTRL0_CLR_REFTOP_PWDVBGUP() volatile
    {
        return CTRL0_CLR & (1u << 2u);
    }

    /**
     * Set CTRL0_CLR's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void set_CTRL0_CLR_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_CLR |= 1u << 2u;
    }

    /**
     * Clear CTRL0_CLR's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void clear_CTRL0_CLR_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL0_CLR's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void toggle_CTRL0_CLR_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_CLR ^= 1u << 2u;
    }

    /**
     * Get CTRL0_CLR's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline bool get_CTRL0_CLR_REFTOP_LINREGREF_PWD() volatile
    {
        return CTRL0_CLR & (1u << 1u);
    }

    /**
     * Set CTRL0_CLR's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void set_CTRL0_CLR_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_CLR |= 1u << 1u;
    }

    /**
     * Clear CTRL0_CLR's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void clear_CTRL0_CLR_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL0_CLR's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void toggle_CTRL0_CLR_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_CLR ^= 1u << 1u;
    }

    /**
     * Get CTRL0_CLR's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline bool get_CTRL0_CLR_REFTOP_PWD() volatile
    {
        return CTRL0_CLR & (1u << 0u);
    }

    /**
     * Set CTRL0_CLR's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void set_CTRL0_CLR_REFTOP_PWD() volatile
    {
        CTRL0_CLR |= 1u << 0u;
    }

    /**
     * Clear CTRL0_CLR's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void clear_CTRL0_CLR_REFTOP_PWD() volatile
    {
        CTRL0_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL0_CLR's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void toggle_CTRL0_CLR_REFTOP_PWD() volatile
    {
        CTRL0_CLR ^= 1u << 0u;
    }

    /**
     * Get all of CTRL0_CLR's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void get_CTRL0_CLR(bool &REFTOP_SELFBIASOFF, bool &REFTOP_LOWPOWER,
                              bool &REFTOP_PWDVBGUP,
                              bool &REFTOP_LINREGREF_PWD,
                              bool &REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0_CLR;

        REFTOP_SELFBIASOFF = curr & (1u << 4u);
        REFTOP_LOWPOWER = curr & (1u << 3u);
        REFTOP_PWDVBGUP = curr & (1u << 2u);
        REFTOP_LINREGREF_PWD = curr & (1u << 1u);
        REFTOP_PWD = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL0_CLR's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void set_CTRL0_CLR(bool REFTOP_SELFBIASOFF, bool REFTOP_LOWPOWER,
                              bool REFTOP_PWDVBGUP, bool REFTOP_LINREGREF_PWD,
                              bool REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0_CLR;

        curr &= ~(0b1u << 4u);
        curr |= (REFTOP_SELFBIASOFF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (REFTOP_LOWPOWER & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REFTOP_PWDVBGUP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REFTOP_LINREGREF_PWD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REFTOP_PWD & 0b1u) << 0u;

        CTRL0_CLR = curr;
    }

    /**
     * Get CTRL0_TOG's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline bool get_CTRL0_TOG_REFTOP_SELFBIASOFF() volatile
    {
        return CTRL0_TOG & (1u << 4u);
    }

    /**
     * Set CTRL0_TOG's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void set_CTRL0_TOG_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_TOG |= 1u << 4u;
    }

    /**
     * Clear CTRL0_TOG's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void clear_CTRL0_TOG_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL0_TOG's REFTOP_SELFBIASOFF bit.
     *
     * bandgap self-bias control bit
     */
    inline void toggle_CTRL0_TOG_REFTOP_SELFBIASOFF() volatile
    {
        CTRL0_TOG ^= 1u << 4u;
    }

    /**
     * Get CTRL0_TOG's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline bool get_CTRL0_TOG_REFTOP_LOWPOWER() volatile
    {
        return CTRL0_TOG & (1u << 3u);
    }

    /**
     * Set CTRL0_TOG's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void set_CTRL0_TOG_REFTOP_LOWPOWER() volatile
    {
        CTRL0_TOG |= 1u << 3u;
    }

    /**
     * Clear CTRL0_TOG's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void clear_CTRL0_TOG_REFTOP_LOWPOWER() volatile
    {
        CTRL0_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL0_TOG's REFTOP_LOWPOWER bit.
     *
     * Low-power control bit
     */
    inline void toggle_CTRL0_TOG_REFTOP_LOWPOWER() volatile
    {
        CTRL0_TOG ^= 1u << 3u;
    }

    /**
     * Get CTRL0_TOG's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline bool get_CTRL0_TOG_REFTOP_PWDVBGUP() volatile
    {
        return CTRL0_TOG & (1u << 2u);
    }

    /**
     * Set CTRL0_TOG's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void set_CTRL0_TOG_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_TOG |= 1u << 2u;
    }

    /**
     * Clear CTRL0_TOG's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void clear_CTRL0_TOG_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL0_TOG's REFTOP_PWDVBGUP bit.
     *
     * Power-down VBGUP detector in bandgap
     */
    inline void toggle_CTRL0_TOG_REFTOP_PWDVBGUP() volatile
    {
        CTRL0_TOG ^= 1u << 2u;
    }

    /**
     * Get CTRL0_TOG's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline bool get_CTRL0_TOG_REFTOP_LINREGREF_PWD() volatile
    {
        return CTRL0_TOG & (1u << 1u);
    }

    /**
     * Set CTRL0_TOG's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void set_CTRL0_TOG_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_TOG |= 1u << 1u;
    }

    /**
     * Clear CTRL0_TOG's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void clear_CTRL0_TOG_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL0_TOG's REFTOP_LINREGREF_PWD bit.
     *
     * Power-down for bandgap voltage-reference buffer
     */
    inline void toggle_CTRL0_TOG_REFTOP_LINREGREF_PWD() volatile
    {
        CTRL0_TOG ^= 1u << 1u;
    }

    /**
     * Get CTRL0_TOG's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline bool get_CTRL0_TOG_REFTOP_PWD() volatile
    {
        return CTRL0_TOG & (1u << 0u);
    }

    /**
     * Set CTRL0_TOG's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void set_CTRL0_TOG_REFTOP_PWD() volatile
    {
        CTRL0_TOG |= 1u << 0u;
    }

    /**
     * Clear CTRL0_TOG's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void clear_CTRL0_TOG_REFTOP_PWD() volatile
    {
        CTRL0_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL0_TOG's REFTOP_PWD bit.
     *
     * Master power-down for bandgap module
     */
    inline void toggle_CTRL0_TOG_REFTOP_PWD() volatile
    {
        CTRL0_TOG ^= 1u << 0u;
    }

    /**
     * Get all of CTRL0_TOG's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void get_CTRL0_TOG(bool &REFTOP_SELFBIASOFF, bool &REFTOP_LOWPOWER,
                              bool &REFTOP_PWDVBGUP,
                              bool &REFTOP_LINREGREF_PWD,
                              bool &REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0_TOG;

        REFTOP_SELFBIASOFF = curr & (1u << 4u);
        REFTOP_LOWPOWER = curr & (1u << 3u);
        REFTOP_PWDVBGUP = curr & (1u << 2u);
        REFTOP_LINREGREF_PWD = curr & (1u << 1u);
        REFTOP_PWD = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL0_TOG's bit fields.
     *
     * (read-write) Analog Control Register CTRL0
     */
    inline void set_CTRL0_TOG(bool REFTOP_SELFBIASOFF, bool REFTOP_LOWPOWER,
                              bool REFTOP_PWDVBGUP, bool REFTOP_LINREGREF_PWD,
                              bool REFTOP_PWD) volatile
    {
        uint32_t curr = CTRL0_TOG;

        curr &= ~(0b1u << 4u);
        curr |= (REFTOP_SELFBIASOFF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (REFTOP_LOWPOWER & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REFTOP_PWDVBGUP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REFTOP_LINREGREF_PWD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REFTOP_PWD & 0b1u) << 0u;

        CTRL0_TOG = curr;
    }

    /**
     * Get STAT0's VDD3_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_VDD3_PORB() volatile
    {
        return STAT0 & (1u << 3u);
    }

    /**
     * Get STAT0's VDD2_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_VDD2_PORB() volatile
    {
        return STAT0 & (1u << 2u);
    }

    /**
     * Get STAT0's VDD1_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_VDD1_PORB() volatile
    {
        return STAT0 & (1u << 1u);
    }

    /**
     * Get STAT0's REFTOP_VBGUP bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_REFTOP_VBGUP() volatile
    {
        return STAT0 & (1u << 0u);
    }

    /**
     * Get all of STAT0's bit fields.
     *
     * (read-write) Analog Status Register STAT0
     */
    inline void get_STAT0(bool &VDD3_PORB, bool &VDD2_PORB, bool &VDD1_PORB,
                          bool &REFTOP_VBGUP) volatile
    {
        uint32_t curr = STAT0;

        VDD3_PORB = curr & (1u << 3u);
        VDD2_PORB = curr & (1u << 2u);
        VDD1_PORB = curr & (1u << 1u);
        REFTOP_VBGUP = curr & (1u << 0u);
    }

    /**
     * Get STAT0_SET's VDD3_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_SET_VDD3_PORB() volatile
    {
        return STAT0_SET & (1u << 3u);
    }

    /**
     * Get STAT0_SET's VDD2_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_SET_VDD2_PORB() volatile
    {
        return STAT0_SET & (1u << 2u);
    }

    /**
     * Get STAT0_SET's VDD1_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_SET_VDD1_PORB() volatile
    {
        return STAT0_SET & (1u << 1u);
    }

    /**
     * Get STAT0_SET's REFTOP_VBGUP bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_SET_REFTOP_VBGUP() volatile
    {
        return STAT0_SET & (1u << 0u);
    }

    /**
     * Get all of STAT0_SET's bit fields.
     *
     * (read-write) Analog Status Register STAT0
     */
    inline void get_STAT0_SET(bool &VDD3_PORB, bool &VDD2_PORB,
                              bool &VDD1_PORB, bool &REFTOP_VBGUP) volatile
    {
        uint32_t curr = STAT0_SET;

        VDD3_PORB = curr & (1u << 3u);
        VDD2_PORB = curr & (1u << 2u);
        VDD1_PORB = curr & (1u << 1u);
        REFTOP_VBGUP = curr & (1u << 0u);
    }

    /**
     * Get STAT0_CLR's VDD3_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_CLR_VDD3_PORB() volatile
    {
        return STAT0_CLR & (1u << 3u);
    }

    /**
     * Get STAT0_CLR's VDD2_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_CLR_VDD2_PORB() volatile
    {
        return STAT0_CLR & (1u << 2u);
    }

    /**
     * Get STAT0_CLR's VDD1_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_CLR_VDD1_PORB() volatile
    {
        return STAT0_CLR & (1u << 1u);
    }

    /**
     * Get STAT0_CLR's REFTOP_VBGUP bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_CLR_REFTOP_VBGUP() volatile
    {
        return STAT0_CLR & (1u << 0u);
    }

    /**
     * Get all of STAT0_CLR's bit fields.
     *
     * (read-write) Analog Status Register STAT0
     */
    inline void get_STAT0_CLR(bool &VDD3_PORB, bool &VDD2_PORB,
                              bool &VDD1_PORB, bool &REFTOP_VBGUP) volatile
    {
        uint32_t curr = STAT0_CLR;

        VDD3_PORB = curr & (1u << 3u);
        VDD2_PORB = curr & (1u << 2u);
        VDD1_PORB = curr & (1u << 1u);
        REFTOP_VBGUP = curr & (1u << 0u);
    }

    /**
     * Get STAT0_TOG's VDD3_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_TOG_VDD3_PORB() volatile
    {
        return STAT0_TOG & (1u << 3u);
    }

    /**
     * Get STAT0_TOG's VDD2_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_TOG_VDD2_PORB() volatile
    {
        return STAT0_TOG & (1u << 2u);
    }

    /**
     * Get STAT0_TOG's VDD1_PORB bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_TOG_VDD1_PORB() volatile
    {
        return STAT0_TOG & (1u << 1u);
    }

    /**
     * Get STAT0_TOG's REFTOP_VBGUP bit.
     *
     * Brief description here
     */
    inline bool get_STAT0_TOG_REFTOP_VBGUP() volatile
    {
        return STAT0_TOG & (1u << 0u);
    }

    /**
     * Get all of STAT0_TOG's bit fields.
     *
     * (read-write) Analog Status Register STAT0
     */
    inline void get_STAT0_TOG(bool &VDD3_PORB, bool &VDD2_PORB,
                              bool &VDD1_PORB, bool &REFTOP_VBGUP) volatile
    {
        uint32_t curr = STAT0_TOG;

        VDD3_PORB = curr & (1u << 3u);
        VDD2_PORB = curr & (1u << 2u);
        VDD1_PORB = curr & (1u << 1u);
        REFTOP_VBGUP = curr & (1u << 0u);
    }
};

static_assert(sizeof(vmbandgap) == vmbandgap::size);

static volatile vmbandgap *const VMBANDGAP = reinterpret_cast<vmbandgap *>(0);

}; // namespace MIMXRT1176::CM7
