/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * MX6RT_ANADIG_REGISTER
 */
struct [[gnu::packed]] anadig_ldo_snvs
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        1332; /*!< anadig_ldo_snvs's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 324;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t PMU_LDO_LPSR_ANA; /*!< (read-write) PMU_LDO_LPSR_ANA_REGISTER */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t
        PMU_LDO_LPSR_DIG_2; /*!< (read-write) PMU_LDO_LPSR_DIG_2_REGISTER */
    static constexpr std::size_t reserved_padding2_length = 3;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t PMU_LDO_LPSR_DIG; /*!< (read-write) PMU_LDO_LPSR_DIG_REGISTER */

    /* Methods. */

    /**
     * Get PMU_LDO_LPSR_ANA's PULL_DOWN_20UA_EN bit.
     *
     * pull_down_20ua_en
     */
    inline bool get_PMU_LDO_LPSR_ANA_PULL_DOWN_20UA_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 20u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's PULL_DOWN_20UA_EN bit.
     *
     * pull_down_20ua_en
     */
    inline void set_PMU_LDO_LPSR_ANA_PULL_DOWN_20UA_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 20u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's PULL_DOWN_20UA_EN bit.
     *
     * pull_down_20ua_en
     */
    inline void clear_PMU_LDO_LPSR_ANA_PULL_DOWN_20UA_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 20u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's PULL_DOWN_20UA_EN bit.
     *
     * pull_down_20ua_en
     */
    inline void toggle_PMU_LDO_LPSR_ANA_PULL_DOWN_20UA_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 20u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's TRACK_MODE_EN bit.
     *
     * Track Mode Enable
     */
    inline bool get_PMU_LDO_LPSR_ANA_TRACK_MODE_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 19u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's TRACK_MODE_EN bit.
     *
     * Track Mode Enable
     */
    inline void set_PMU_LDO_LPSR_ANA_TRACK_MODE_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 19u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's TRACK_MODE_EN bit.
     *
     * Track Mode Enable
     */
    inline void clear_PMU_LDO_LPSR_ANA_TRACK_MODE_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 19u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's TRACK_MODE_EN bit.
     *
     * Track Mode Enable
     */
    inline void toggle_PMU_LDO_LPSR_ANA_TRACK_MODE_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 19u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's ALWAYS_4MA_PULLDOWN_EN bit.
     *
     * always_4ma_pulldown_en
     */
    inline bool get_PMU_LDO_LPSR_ANA_ALWAYS_4MA_PULLDOWN_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 8u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's ALWAYS_4MA_PULLDOWN_EN bit.
     *
     * always_4ma_pulldown_en
     */
    inline void set_PMU_LDO_LPSR_ANA_ALWAYS_4MA_PULLDOWN_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 8u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's ALWAYS_4MA_PULLDOWN_EN bit.
     *
     * always_4ma_pulldown_en
     */
    inline void clear_PMU_LDO_LPSR_ANA_ALWAYS_4MA_PULLDOWN_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 8u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's ALWAYS_4MA_PULLDOWN_EN bit.
     *
     * always_4ma_pulldown_en
     */
    inline void toggle_PMU_LDO_LPSR_ANA_ALWAYS_4MA_PULLDOWN_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 8u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's STANDBY_EN bit.
     *
     * standby_en
     */
    inline bool get_PMU_LDO_LPSR_ANA_STANDBY_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 6u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's STANDBY_EN bit.
     *
     * standby_en
     */
    inline void set_PMU_LDO_LPSR_ANA_STANDBY_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 6u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's STANDBY_EN bit.
     *
     * standby_en
     */
    inline void clear_PMU_LDO_LPSR_ANA_STANDBY_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 6u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's STANDBY_EN bit.
     *
     * standby_en
     */
    inline void toggle_PMU_LDO_LPSR_ANA_STANDBY_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 6u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's BYPASS_MODE_EN bit.
     *
     * bypass_mode_en
     */
    inline bool get_PMU_LDO_LPSR_ANA_BYPASS_MODE_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 5u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's BYPASS_MODE_EN bit.
     *
     * bypass_mode_en
     */
    inline void set_PMU_LDO_LPSR_ANA_BYPASS_MODE_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 5u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's BYPASS_MODE_EN bit.
     *
     * bypass_mode_en
     */
    inline void clear_PMU_LDO_LPSR_ANA_BYPASS_MODE_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 5u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's BYPASS_MODE_EN bit.
     *
     * bypass_mode_en
     */
    inline void toggle_PMU_LDO_LPSR_ANA_BYPASS_MODE_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 5u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's LPSR_ANA_CONTROL_MODE bit.
     *
     * LPSR_ANA_CONTROL_MODE
     */
    inline bool get_PMU_LDO_LPSR_ANA_LPSR_ANA_CONTROL_MODE() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 4u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's LPSR_ANA_CONTROL_MODE bit.
     *
     * LPSR_ANA_CONTROL_MODE
     */
    inline void set_PMU_LDO_LPSR_ANA_LPSR_ANA_CONTROL_MODE() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 4u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's LPSR_ANA_CONTROL_MODE bit.
     *
     * LPSR_ANA_CONTROL_MODE
     */
    inline void clear_PMU_LDO_LPSR_ANA_LPSR_ANA_CONTROL_MODE() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 4u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's LPSR_ANA_CONTROL_MODE bit.
     *
     * LPSR_ANA_CONTROL_MODE
     */
    inline void toggle_PMU_LDO_LPSR_ANA_LPSR_ANA_CONTROL_MODE() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 4u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's PULL_DOWN_2MA_EN bit.
     *
     * pull_down_2ma_en
     */
    inline bool get_PMU_LDO_LPSR_ANA_PULL_DOWN_2MA_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 3u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's PULL_DOWN_2MA_EN bit.
     *
     * pull_down_2ma_en
     */
    inline void set_PMU_LDO_LPSR_ANA_PULL_DOWN_2MA_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 3u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's PULL_DOWN_2MA_EN bit.
     *
     * pull_down_2ma_en
     */
    inline void clear_PMU_LDO_LPSR_ANA_PULL_DOWN_2MA_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 3u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's PULL_DOWN_2MA_EN bit.
     *
     * pull_down_2ma_en
     */
    inline void toggle_PMU_LDO_LPSR_ANA_PULL_DOWN_2MA_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 3u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's REG_DISABLE bit.
     *
     * reg_disable
     */
    inline bool get_PMU_LDO_LPSR_ANA_REG_DISABLE() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 2u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's REG_DISABLE bit.
     *
     * reg_disable
     */
    inline void set_PMU_LDO_LPSR_ANA_REG_DISABLE() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 2u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's REG_DISABLE bit.
     *
     * reg_disable
     */
    inline void clear_PMU_LDO_LPSR_ANA_REG_DISABLE() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 2u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's REG_DISABLE bit.
     *
     * reg_disable
     */
    inline void toggle_PMU_LDO_LPSR_ANA_REG_DISABLE() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 2u;
    }

    /**
     * Get PMU_LDO_LPSR_ANA's REG_LP_EN bit.
     *
     * reg_lp_en
     */
    inline bool get_PMU_LDO_LPSR_ANA_REG_LP_EN() volatile
    {
        return PMU_LDO_LPSR_ANA & (1u << 0u);
    }

    /**
     * Set PMU_LDO_LPSR_ANA's REG_LP_EN bit.
     *
     * reg_lp_en
     */
    inline void set_PMU_LDO_LPSR_ANA_REG_LP_EN() volatile
    {
        PMU_LDO_LPSR_ANA |= 1u << 0u;
    }

    /**
     * Clear PMU_LDO_LPSR_ANA's REG_LP_EN bit.
     *
     * reg_lp_en
     */
    inline void clear_PMU_LDO_LPSR_ANA_REG_LP_EN() volatile
    {
        PMU_LDO_LPSR_ANA &= ~(1u << 0u);
    }

    /**
     * Toggle PMU_LDO_LPSR_ANA's REG_LP_EN bit.
     *
     * reg_lp_en
     */
    inline void toggle_PMU_LDO_LPSR_ANA_REG_LP_EN() volatile
    {
        PMU_LDO_LPSR_ANA ^= 1u << 0u;
    }

    /**
     * Get all of PMU_LDO_LPSR_ANA's bit fields.
     *
     * (read-write) PMU_LDO_LPSR_ANA_REGISTER
     */
    inline void get_PMU_LDO_LPSR_ANA(bool &PULL_DOWN_20UA_EN,
                                     bool &TRACK_MODE_EN,
                                     bool &ALWAYS_4MA_PULLDOWN_EN,
                                     bool &STANDBY_EN, bool &BYPASS_MODE_EN,
                                     bool &LPSR_ANA_CONTROL_MODE,
                                     bool &PULL_DOWN_2MA_EN, bool &REG_DISABLE,
                                     bool &REG_LP_EN) volatile
    {
        uint32_t curr = PMU_LDO_LPSR_ANA;

        PULL_DOWN_20UA_EN = curr & (1u << 20u);
        TRACK_MODE_EN = curr & (1u << 19u);
        ALWAYS_4MA_PULLDOWN_EN = curr & (1u << 8u);
        STANDBY_EN = curr & (1u << 6u);
        BYPASS_MODE_EN = curr & (1u << 5u);
        LPSR_ANA_CONTROL_MODE = curr & (1u << 4u);
        PULL_DOWN_2MA_EN = curr & (1u << 3u);
        REG_DISABLE = curr & (1u << 2u);
        REG_LP_EN = curr & (1u << 0u);
    }

    /**
     * Set all of PMU_LDO_LPSR_ANA's bit fields.
     *
     * (read-write) PMU_LDO_LPSR_ANA_REGISTER
     */
    inline void set_PMU_LDO_LPSR_ANA(bool PULL_DOWN_20UA_EN,
                                     bool TRACK_MODE_EN,
                                     bool ALWAYS_4MA_PULLDOWN_EN,
                                     bool STANDBY_EN, bool BYPASS_MODE_EN,
                                     bool LPSR_ANA_CONTROL_MODE,
                                     bool PULL_DOWN_2MA_EN, bool REG_DISABLE,
                                     bool REG_LP_EN) volatile
    {
        uint32_t curr = PMU_LDO_LPSR_ANA;

        curr &= ~(0b1u << 20u);
        curr |= (PULL_DOWN_20UA_EN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (TRACK_MODE_EN & 0b1u) << 19u;
        curr &= ~(0b1u << 8u);
        curr |= (ALWAYS_4MA_PULLDOWN_EN & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (STANDBY_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BYPASS_MODE_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (LPSR_ANA_CONTROL_MODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PULL_DOWN_2MA_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (REG_DISABLE & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (REG_LP_EN & 0b1u) << 0u;

        PMU_LDO_LPSR_ANA = curr;
    }

    /**
     * Get PMU_LDO_LPSR_DIG_2's VOLTAGE_STEP_INC field.
     *
     * voltage_step_inc
     */
    inline uint8_t get_PMU_LDO_LPSR_DIG_2_VOLTAGE_STEP_INC() volatile
    {
        return (PMU_LDO_LPSR_DIG_2 >> 0u) & 0b11u;
    }

    /**
     * Set PMU_LDO_LPSR_DIG_2's VOLTAGE_STEP_INC field.
     *
     * voltage_step_inc
     */
    inline void set_PMU_LDO_LPSR_DIG_2_VOLTAGE_STEP_INC(uint8_t value) volatile
    {
        uint32_t curr = PMU_LDO_LPSR_DIG_2;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        PMU_LDO_LPSR_DIG_2 = curr;
    }

    /**
     * Get PMU_LDO_LPSR_DIG's VOLTAGE_SELECT field.
     *
     * VOLTAGE_SELECT
     */
    inline ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT
    get_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT() volatile
    {
        return ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT(
            (PMU_LDO_LPSR_DIG >> 20u) & 0b11111u);
    }

    /**
     * Set PMU_LDO_LPSR_DIG's VOLTAGE_SELECT field.
     *
     * VOLTAGE_SELECT
     */
    inline void set_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT(
        ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT value) volatile
    {
        uint32_t curr = PMU_LDO_LPSR_DIG;

        curr &= ~(0b11111u << 20u);
        curr |= (std::to_underlying(value) & 0b11111u) << 20u;

        PMU_LDO_LPSR_DIG = curr;
    }

    /**
     * Get PMU_LDO_LPSR_DIG's BYPASS_MODE bit.
     *
     * bypass_mode
     */
    inline bool get_PMU_LDO_LPSR_DIG_BYPASS_MODE() volatile
    {
        return PMU_LDO_LPSR_DIG & (1u << 18u);
    }

    /**
     * Set PMU_LDO_LPSR_DIG's BYPASS_MODE bit.
     *
     * bypass_mode
     */
    inline void set_PMU_LDO_LPSR_DIG_BYPASS_MODE() volatile
    {
        PMU_LDO_LPSR_DIG |= 1u << 18u;
    }

    /**
     * Clear PMU_LDO_LPSR_DIG's BYPASS_MODE bit.
     *
     * bypass_mode
     */
    inline void clear_PMU_LDO_LPSR_DIG_BYPASS_MODE() volatile
    {
        PMU_LDO_LPSR_DIG &= ~(1u << 18u);
    }

    /**
     * Toggle PMU_LDO_LPSR_DIG's BYPASS_MODE bit.
     *
     * bypass_mode
     */
    inline void toggle_PMU_LDO_LPSR_DIG_BYPASS_MODE() volatile
    {
        PMU_LDO_LPSR_DIG ^= 1u << 18u;
    }

    /**
     * Get PMU_LDO_LPSR_DIG's TRACKING_MODE bit.
     *
     * tracking_mode
     */
    inline bool get_PMU_LDO_LPSR_DIG_TRACKING_MODE() volatile
    {
        return PMU_LDO_LPSR_DIG & (1u << 17u);
    }

    /**
     * Set PMU_LDO_LPSR_DIG's TRACKING_MODE bit.
     *
     * tracking_mode
     */
    inline void set_PMU_LDO_LPSR_DIG_TRACKING_MODE() volatile
    {
        PMU_LDO_LPSR_DIG |= 1u << 17u;
    }

    /**
     * Clear PMU_LDO_LPSR_DIG's TRACKING_MODE bit.
     *
     * tracking_mode
     */
    inline void clear_PMU_LDO_LPSR_DIG_TRACKING_MODE() volatile
    {
        PMU_LDO_LPSR_DIG &= ~(1u << 17u);
    }

    /**
     * Toggle PMU_LDO_LPSR_DIG's TRACKING_MODE bit.
     *
     * tracking_mode
     */
    inline void toggle_PMU_LDO_LPSR_DIG_TRACKING_MODE() volatile
    {
        PMU_LDO_LPSR_DIG ^= 1u << 17u;
    }

    /**
     * Get PMU_LDO_LPSR_DIG's STANDBY_EN bit.
     *
     * standby_en
     */
    inline bool get_PMU_LDO_LPSR_DIG_STANDBY_EN() volatile
    {
        return PMU_LDO_LPSR_DIG & (1u << 6u);
    }

    /**
     * Set PMU_LDO_LPSR_DIG's STANDBY_EN bit.
     *
     * standby_en
     */
    inline void set_PMU_LDO_LPSR_DIG_STANDBY_EN() volatile
    {
        PMU_LDO_LPSR_DIG |= 1u << 6u;
    }

    /**
     * Clear PMU_LDO_LPSR_DIG's STANDBY_EN bit.
     *
     * standby_en
     */
    inline void clear_PMU_LDO_LPSR_DIG_STANDBY_EN() volatile
    {
        PMU_LDO_LPSR_DIG &= ~(1u << 6u);
    }

    /**
     * Toggle PMU_LDO_LPSR_DIG's STANDBY_EN bit.
     *
     * standby_en
     */
    inline void toggle_PMU_LDO_LPSR_DIG_STANDBY_EN() volatile
    {
        PMU_LDO_LPSR_DIG ^= 1u << 6u;
    }

    /**
     * Get PMU_LDO_LPSR_DIG's LPSR_DIG_CONTROL_MODE bit.
     *
     * LPSR_DIG_CONTROL_MODE
     */
    inline bool get_PMU_LDO_LPSR_DIG_LPSR_DIG_CONTROL_MODE() volatile
    {
        return PMU_LDO_LPSR_DIG & (1u << 5u);
    }

    /**
     * Set PMU_LDO_LPSR_DIG's LPSR_DIG_CONTROL_MODE bit.
     *
     * LPSR_DIG_CONTROL_MODE
     */
    inline void set_PMU_LDO_LPSR_DIG_LPSR_DIG_CONTROL_MODE() volatile
    {
        PMU_LDO_LPSR_DIG |= 1u << 5u;
    }

    /**
     * Clear PMU_LDO_LPSR_DIG's LPSR_DIG_CONTROL_MODE bit.
     *
     * LPSR_DIG_CONTROL_MODE
     */
    inline void clear_PMU_LDO_LPSR_DIG_LPSR_DIG_CONTROL_MODE() volatile
    {
        PMU_LDO_LPSR_DIG &= ~(1u << 5u);
    }

    /**
     * Toggle PMU_LDO_LPSR_DIG's LPSR_DIG_CONTROL_MODE bit.
     *
     * LPSR_DIG_CONTROL_MODE
     */
    inline void toggle_PMU_LDO_LPSR_DIG_LPSR_DIG_CONTROL_MODE() volatile
    {
        PMU_LDO_LPSR_DIG ^= 1u << 5u;
    }

    /**
     * Get PMU_LDO_LPSR_DIG's REG_EN bit.
     *
     * ENABLE_ILIMIT
     */
    inline bool get_PMU_LDO_LPSR_DIG_REG_EN() volatile
    {
        return PMU_LDO_LPSR_DIG & (1u << 2u);
    }

    /**
     * Set PMU_LDO_LPSR_DIG's REG_EN bit.
     *
     * ENABLE_ILIMIT
     */
    inline void set_PMU_LDO_LPSR_DIG_REG_EN() volatile
    {
        PMU_LDO_LPSR_DIG |= 1u << 2u;
    }

    /**
     * Clear PMU_LDO_LPSR_DIG's REG_EN bit.
     *
     * ENABLE_ILIMIT
     */
    inline void clear_PMU_LDO_LPSR_DIG_REG_EN() volatile
    {
        PMU_LDO_LPSR_DIG &= ~(1u << 2u);
    }

    /**
     * Toggle PMU_LDO_LPSR_DIG's REG_EN bit.
     *
     * ENABLE_ILIMIT
     */
    inline void toggle_PMU_LDO_LPSR_DIG_REG_EN() volatile
    {
        PMU_LDO_LPSR_DIG ^= 1u << 2u;
    }

    /**
     * Get all of PMU_LDO_LPSR_DIG's bit fields.
     *
     * (read-write) PMU_LDO_LPSR_DIG_REGISTER
     */
    inline void get_PMU_LDO_LPSR_DIG(
        ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT &VOLTAGE_SELECT,
        bool &BYPASS_MODE, bool &TRACKING_MODE, bool &STANDBY_EN,
        bool &LPSR_DIG_CONTROL_MODE, bool &REG_EN) volatile
    {
        uint32_t curr = PMU_LDO_LPSR_DIG;

        VOLTAGE_SELECT = ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT(
            (curr >> 20u) & 0b11111u);
        BYPASS_MODE = curr & (1u << 18u);
        TRACKING_MODE = curr & (1u << 17u);
        STANDBY_EN = curr & (1u << 6u);
        LPSR_DIG_CONTROL_MODE = curr & (1u << 5u);
        REG_EN = curr & (1u << 2u);
    }

    /**
     * Set all of PMU_LDO_LPSR_DIG's bit fields.
     *
     * (read-write) PMU_LDO_LPSR_DIG_REGISTER
     */
    inline void set_PMU_LDO_LPSR_DIG(
        ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT VOLTAGE_SELECT,
        bool BYPASS_MODE, bool TRACKING_MODE, bool STANDBY_EN,
        bool LPSR_DIG_CONTROL_MODE, bool REG_EN) volatile
    {
        uint32_t curr = PMU_LDO_LPSR_DIG;

        curr &= ~(0b11111u << 20u);
        curr |= (std::to_underlying(VOLTAGE_SELECT) & 0b11111u) << 20u;
        curr &= ~(0b1u << 18u);
        curr |= (BYPASS_MODE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (TRACKING_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 6u);
        curr |= (STANDBY_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LPSR_DIG_CONTROL_MODE & 0b1u) << 5u;
        curr &= ~(0b1u << 2u);
        curr |= (REG_EN & 0b1u) << 2u;

        PMU_LDO_LPSR_DIG = curr;
    }
};

static_assert(sizeof(anadig_ldo_snvs) == anadig_ldo_snvs::size);

static volatile anadig_ldo_snvs *const ANADIG_LDO_SNVS =
    reinterpret_cast<anadig_ldo_snvs *>(0x40C84000);

}; // namespace MIMXRT1176::CM7
