/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/CAN1_ESR1_FLTCONF.h"
#include "../enums/CAN1_FDCTRL_MBDSR0.h"
#include "../enums/CAN1_FDCTRL_MBDSR1.h"
#include "../enums/CAN1_MCR_IDAM.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * CAN
 */
struct [[gnu::packed]] can1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 3084; /*!< can1's size in bytes. */

    /* Fields. */
    uint32_t MCR;   /*!< (read-write) Module Configuration register */
    uint32_t CTRL1; /*!< (read-write) Control 1 register */
    uint32_t TIMER; /*!< (read-write) Free Running Timer */
    const uint32_t reserved_padding0 = {};
    uint32_t RXMGMASK; /*!< (read-write) Rx Mailboxes Global Mask register */
    uint32_t RX14MASK; /*!< (read-write) Rx 14 Mask register */
    uint32_t RX15MASK; /*!< (read-write) Rx 15 Mask register */
    uint32_t ECR;      /*!< (read-write) Error Counter */
    uint32_t ESR1;     /*!< (read-write) Error and Status 1 register */
    uint32_t IMASK2;   /*!< (read-write) Interrupt Masks 2 register */
    uint32_t IMASK1;   /*!< (read-write) Interrupt Masks 1 register */
    uint32_t IFLAG2;   /*!< (read-write) Interrupt Flags 2 register */
    uint32_t IFLAG1;   /*!< (read-write) Interrupt Flags 1 register */
    uint32_t CTRL2;    /*!< (read-write) Control 2 register */
    uint32_t ESR2;     /*!< (read-write) Error and Status 2 register */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CRCR;     /*!< (read-write) CRC register */
    uint32_t RXFGMASK; /*!< (read-write) Rx FIFO Global Mask register */
    uint32_t RXFIR;    /*!< (read-write) Rx FIFO Information register */
    uint32_t CBT;      /*!< (read-write) CAN Bit Timing register */
    static constexpr std::size_t reserved_padding2_length = 11;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t CS0; /*!< (read-write) Message Buffer 0 CS Register */
    static constexpr std::size_t reserved_padding3_length = 511;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    static constexpr std::size_t RXIMR_length = 64;
    uint32_t
        RXIMR[RXIMR_length]; /*!< (read-write) Rx Individual Mask registers */
    static constexpr std::size_t reserved_padding4_length = 88;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t MECR;   /*!< (read-write) Memory Error Control register */
    uint32_t ERRIAR; /*!< (read-write) Error Injection Address register */
    uint32_t
        ERRIDPR; /*!< (read-write) Error Injection Data Pattern register */
    uint32_t
        ERRIPPR; /*!< (read-write) Error Injection Parity Pattern register */
    uint32_t RERRAR;   /*!< (read-write) Error Report Address register */
    uint32_t RERRDR;   /*!< (read-write) Error Report Data register */
    uint32_t RERRSYNR; /*!< (read-write) Error Report Syndrome register */
    uint32_t ERRSR;    /*!< (read-write) Error Status register */
    static constexpr std::size_t reserved_padding5_length = 64;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t FDCTRL; /*!< (read-write) CAN FD Control register */
    uint32_t FDCBT;  /*!< (read-write) CAN FD Bit Timing register */
    uint32_t FDCRC;  /*!< (read-write) CAN FD CRC register */

    /* Methods. */

    /**
     * Get MCR's MDIS bit.
     *
     * Module Disable
     */
    inline bool get_MCR_MDIS() volatile
    {
        return MCR & (1u << 31u);
    }

    /**
     * Set MCR's MDIS bit.
     *
     * Module Disable
     */
    inline void set_MCR_MDIS() volatile
    {
        MCR |= 1u << 31u;
    }

    /**
     * Clear MCR's MDIS bit.
     *
     * Module Disable
     */
    inline void clear_MCR_MDIS() volatile
    {
        MCR &= ~(1u << 31u);
    }

    /**
     * Toggle MCR's MDIS bit.
     *
     * Module Disable
     */
    inline void toggle_MCR_MDIS() volatile
    {
        MCR ^= 1u << 31u;
    }

    /**
     * Get MCR's FRZ bit.
     *
     * Freeze Enable
     */
    inline bool get_MCR_FRZ() volatile
    {
        return MCR & (1u << 30u);
    }

    /**
     * Set MCR's FRZ bit.
     *
     * Freeze Enable
     */
    inline void set_MCR_FRZ() volatile
    {
        MCR |= 1u << 30u;
    }

    /**
     * Clear MCR's FRZ bit.
     *
     * Freeze Enable
     */
    inline void clear_MCR_FRZ() volatile
    {
        MCR &= ~(1u << 30u);
    }

    /**
     * Toggle MCR's FRZ bit.
     *
     * Freeze Enable
     */
    inline void toggle_MCR_FRZ() volatile
    {
        MCR ^= 1u << 30u;
    }

    /**
     * Get MCR's RFEN bit.
     *
     * Rx FIFO Enable
     */
    inline bool get_MCR_RFEN() volatile
    {
        return MCR & (1u << 29u);
    }

    /**
     * Set MCR's RFEN bit.
     *
     * Rx FIFO Enable
     */
    inline void set_MCR_RFEN() volatile
    {
        MCR |= 1u << 29u;
    }

    /**
     * Clear MCR's RFEN bit.
     *
     * Rx FIFO Enable
     */
    inline void clear_MCR_RFEN() volatile
    {
        MCR &= ~(1u << 29u);
    }

    /**
     * Toggle MCR's RFEN bit.
     *
     * Rx FIFO Enable
     */
    inline void toggle_MCR_RFEN() volatile
    {
        MCR ^= 1u << 29u;
    }

    /**
     * Get MCR's HALT bit.
     *
     * Halt FlexCAN
     */
    inline bool get_MCR_HALT() volatile
    {
        return MCR & (1u << 28u);
    }

    /**
     * Set MCR's HALT bit.
     *
     * Halt FlexCAN
     */
    inline void set_MCR_HALT() volatile
    {
        MCR |= 1u << 28u;
    }

    /**
     * Clear MCR's HALT bit.
     *
     * Halt FlexCAN
     */
    inline void clear_MCR_HALT() volatile
    {
        MCR &= ~(1u << 28u);
    }

    /**
     * Toggle MCR's HALT bit.
     *
     * Halt FlexCAN
     */
    inline void toggle_MCR_HALT() volatile
    {
        MCR ^= 1u << 28u;
    }

    /**
     * Get MCR's NOTRDY bit.
     *
     * FlexCAN Not Ready
     */
    inline bool get_MCR_NOTRDY() volatile
    {
        return MCR & (1u << 27u);
    }

    /**
     * Get MCR's WAKMSK bit.
     *
     * Wake Up Interrupt Mask
     */
    inline bool get_MCR_WAKMSK() volatile
    {
        return MCR & (1u << 26u);
    }

    /**
     * Set MCR's WAKMSK bit.
     *
     * Wake Up Interrupt Mask
     */
    inline void set_MCR_WAKMSK() volatile
    {
        MCR |= 1u << 26u;
    }

    /**
     * Clear MCR's WAKMSK bit.
     *
     * Wake Up Interrupt Mask
     */
    inline void clear_MCR_WAKMSK() volatile
    {
        MCR &= ~(1u << 26u);
    }

    /**
     * Toggle MCR's WAKMSK bit.
     *
     * Wake Up Interrupt Mask
     */
    inline void toggle_MCR_WAKMSK() volatile
    {
        MCR ^= 1u << 26u;
    }

    /**
     * Get MCR's SOFTRST bit.
     *
     * Soft Reset
     */
    inline bool get_MCR_SOFTRST() volatile
    {
        return MCR & (1u << 25u);
    }

    /**
     * Set MCR's SOFTRST bit.
     *
     * Soft Reset
     */
    inline void set_MCR_SOFTRST() volatile
    {
        MCR |= 1u << 25u;
    }

    /**
     * Clear MCR's SOFTRST bit.
     *
     * Soft Reset
     */
    inline void clear_MCR_SOFTRST() volatile
    {
        MCR &= ~(1u << 25u);
    }

    /**
     * Toggle MCR's SOFTRST bit.
     *
     * Soft Reset
     */
    inline void toggle_MCR_SOFTRST() volatile
    {
        MCR ^= 1u << 25u;
    }

    /**
     * Get MCR's FRZACK bit.
     *
     * Freeze Mode Acknowledge
     */
    inline bool get_MCR_FRZACK() volatile
    {
        return MCR & (1u << 24u);
    }

    /**
     * Get MCR's SUPV bit.
     *
     * Supervisor Mode
     */
    inline bool get_MCR_SUPV() volatile
    {
        return MCR & (1u << 23u);
    }

    /**
     * Set MCR's SUPV bit.
     *
     * Supervisor Mode
     */
    inline void set_MCR_SUPV() volatile
    {
        MCR |= 1u << 23u;
    }

    /**
     * Clear MCR's SUPV bit.
     *
     * Supervisor Mode
     */
    inline void clear_MCR_SUPV() volatile
    {
        MCR &= ~(1u << 23u);
    }

    /**
     * Toggle MCR's SUPV bit.
     *
     * Supervisor Mode
     */
    inline void toggle_MCR_SUPV() volatile
    {
        MCR ^= 1u << 23u;
    }

    /**
     * Get MCR's SLFWAK bit.
     *
     * Self Wake Up
     */
    inline bool get_MCR_SLFWAK() volatile
    {
        return MCR & (1u << 22u);
    }

    /**
     * Set MCR's SLFWAK bit.
     *
     * Self Wake Up
     */
    inline void set_MCR_SLFWAK() volatile
    {
        MCR |= 1u << 22u;
    }

    /**
     * Clear MCR's SLFWAK bit.
     *
     * Self Wake Up
     */
    inline void clear_MCR_SLFWAK() volatile
    {
        MCR &= ~(1u << 22u);
    }

    /**
     * Toggle MCR's SLFWAK bit.
     *
     * Self Wake Up
     */
    inline void toggle_MCR_SLFWAK() volatile
    {
        MCR ^= 1u << 22u;
    }

    /**
     * Get MCR's WRNEN bit.
     *
     * Warning Interrupt Enable
     */
    inline bool get_MCR_WRNEN() volatile
    {
        return MCR & (1u << 21u);
    }

    /**
     * Set MCR's WRNEN bit.
     *
     * Warning Interrupt Enable
     */
    inline void set_MCR_WRNEN() volatile
    {
        MCR |= 1u << 21u;
    }

    /**
     * Clear MCR's WRNEN bit.
     *
     * Warning Interrupt Enable
     */
    inline void clear_MCR_WRNEN() volatile
    {
        MCR &= ~(1u << 21u);
    }

    /**
     * Toggle MCR's WRNEN bit.
     *
     * Warning Interrupt Enable
     */
    inline void toggle_MCR_WRNEN() volatile
    {
        MCR ^= 1u << 21u;
    }

    /**
     * Get MCR's LPMACK bit.
     *
     * Low-Power Mode Acknowledge
     */
    inline bool get_MCR_LPMACK() volatile
    {
        return MCR & (1u << 20u);
    }

    /**
     * Get MCR's WAKSRC bit.
     *
     * Wake Up Source
     */
    inline bool get_MCR_WAKSRC() volatile
    {
        return MCR & (1u << 19u);
    }

    /**
     * Set MCR's WAKSRC bit.
     *
     * Wake Up Source
     */
    inline void set_MCR_WAKSRC() volatile
    {
        MCR |= 1u << 19u;
    }

    /**
     * Clear MCR's WAKSRC bit.
     *
     * Wake Up Source
     */
    inline void clear_MCR_WAKSRC() volatile
    {
        MCR &= ~(1u << 19u);
    }

    /**
     * Toggle MCR's WAKSRC bit.
     *
     * Wake Up Source
     */
    inline void toggle_MCR_WAKSRC() volatile
    {
        MCR ^= 1u << 19u;
    }

    /**
     * Get MCR's DOZE bit.
     *
     * Doze Mode Enable
     */
    inline bool get_MCR_DOZE() volatile
    {
        return MCR & (1u << 18u);
    }

    /**
     * Set MCR's DOZE bit.
     *
     * Doze Mode Enable
     */
    inline void set_MCR_DOZE() volatile
    {
        MCR |= 1u << 18u;
    }

    /**
     * Clear MCR's DOZE bit.
     *
     * Doze Mode Enable
     */
    inline void clear_MCR_DOZE() volatile
    {
        MCR &= ~(1u << 18u);
    }

    /**
     * Toggle MCR's DOZE bit.
     *
     * Doze Mode Enable
     */
    inline void toggle_MCR_DOZE() volatile
    {
        MCR ^= 1u << 18u;
    }

    /**
     * Get MCR's SRXDIS bit.
     *
     * Self Reception Disable
     */
    inline bool get_MCR_SRXDIS() volatile
    {
        return MCR & (1u << 17u);
    }

    /**
     * Set MCR's SRXDIS bit.
     *
     * Self Reception Disable
     */
    inline void set_MCR_SRXDIS() volatile
    {
        MCR |= 1u << 17u;
    }

    /**
     * Clear MCR's SRXDIS bit.
     *
     * Self Reception Disable
     */
    inline void clear_MCR_SRXDIS() volatile
    {
        MCR &= ~(1u << 17u);
    }

    /**
     * Toggle MCR's SRXDIS bit.
     *
     * Self Reception Disable
     */
    inline void toggle_MCR_SRXDIS() volatile
    {
        MCR ^= 1u << 17u;
    }

    /**
     * Get MCR's IRMQ bit.
     *
     * Individual Rx Masking And Queue Enable
     */
    inline bool get_MCR_IRMQ() volatile
    {
        return MCR & (1u << 16u);
    }

    /**
     * Set MCR's IRMQ bit.
     *
     * Individual Rx Masking And Queue Enable
     */
    inline void set_MCR_IRMQ() volatile
    {
        MCR |= 1u << 16u;
    }

    /**
     * Clear MCR's IRMQ bit.
     *
     * Individual Rx Masking And Queue Enable
     */
    inline void clear_MCR_IRMQ() volatile
    {
        MCR &= ~(1u << 16u);
    }

    /**
     * Toggle MCR's IRMQ bit.
     *
     * Individual Rx Masking And Queue Enable
     */
    inline void toggle_MCR_IRMQ() volatile
    {
        MCR ^= 1u << 16u;
    }

    /**
     * Get MCR's DMA bit.
     *
     * DMA Enable
     */
    inline bool get_MCR_DMA() volatile
    {
        return MCR & (1u << 15u);
    }

    /**
     * Set MCR's DMA bit.
     *
     * DMA Enable
     */
    inline void set_MCR_DMA() volatile
    {
        MCR |= 1u << 15u;
    }

    /**
     * Clear MCR's DMA bit.
     *
     * DMA Enable
     */
    inline void clear_MCR_DMA() volatile
    {
        MCR &= ~(1u << 15u);
    }

    /**
     * Toggle MCR's DMA bit.
     *
     * DMA Enable
     */
    inline void toggle_MCR_DMA() volatile
    {
        MCR ^= 1u << 15u;
    }

    /**
     * Get MCR's LPRIOEN bit.
     *
     * Local Priority Enable
     */
    inline bool get_MCR_LPRIOEN() volatile
    {
        return MCR & (1u << 13u);
    }

    /**
     * Set MCR's LPRIOEN bit.
     *
     * Local Priority Enable
     */
    inline void set_MCR_LPRIOEN() volatile
    {
        MCR |= 1u << 13u;
    }

    /**
     * Clear MCR's LPRIOEN bit.
     *
     * Local Priority Enable
     */
    inline void clear_MCR_LPRIOEN() volatile
    {
        MCR &= ~(1u << 13u);
    }

    /**
     * Toggle MCR's LPRIOEN bit.
     *
     * Local Priority Enable
     */
    inline void toggle_MCR_LPRIOEN() volatile
    {
        MCR ^= 1u << 13u;
    }

    /**
     * Get MCR's AEN bit.
     *
     * Abort Enable
     */
    inline bool get_MCR_AEN() volatile
    {
        return MCR & (1u << 12u);
    }

    /**
     * Set MCR's AEN bit.
     *
     * Abort Enable
     */
    inline void set_MCR_AEN() volatile
    {
        MCR |= 1u << 12u;
    }

    /**
     * Clear MCR's AEN bit.
     *
     * Abort Enable
     */
    inline void clear_MCR_AEN() volatile
    {
        MCR &= ~(1u << 12u);
    }

    /**
     * Toggle MCR's AEN bit.
     *
     * Abort Enable
     */
    inline void toggle_MCR_AEN() volatile
    {
        MCR ^= 1u << 12u;
    }

    /**
     * Get MCR's FDEN bit.
     *
     * CAN FD operation enable
     */
    inline bool get_MCR_FDEN() volatile
    {
        return MCR & (1u << 11u);
    }

    /**
     * Set MCR's FDEN bit.
     *
     * CAN FD operation enable
     */
    inline void set_MCR_FDEN() volatile
    {
        MCR |= 1u << 11u;
    }

    /**
     * Clear MCR's FDEN bit.
     *
     * CAN FD operation enable
     */
    inline void clear_MCR_FDEN() volatile
    {
        MCR &= ~(1u << 11u);
    }

    /**
     * Toggle MCR's FDEN bit.
     *
     * CAN FD operation enable
     */
    inline void toggle_MCR_FDEN() volatile
    {
        MCR ^= 1u << 11u;
    }

    /**
     * Get MCR's IDAM field.
     *
     * ID Acceptance Mode
     */
    inline CAN1_MCR_IDAM get_MCR_IDAM() volatile
    {
        return CAN1_MCR_IDAM((MCR >> 8u) & 0b11u);
    }

    /**
     * Set MCR's IDAM field.
     *
     * ID Acceptance Mode
     */
    inline void set_MCR_IDAM(CAN1_MCR_IDAM value) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        MCR = curr;
    }

    /**
     * Get MCR's MAXMB field.
     *
     * Number Of The Last Message Buffer
     */
    inline uint8_t get_MCR_MAXMB() volatile
    {
        return (MCR >> 0u) & 0b1111111u;
    }

    /**
     * Set MCR's MAXMB field.
     *
     * Number Of The Last Message Buffer
     */
    inline void set_MCR_MAXMB(uint8_t value) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        MCR = curr;
    }

    /**
     * Get all of MCR's bit fields.
     *
     * (read-write) Module Configuration register
     */
    inline void get_MCR(bool &MDIS, bool &FRZ, bool &RFEN, bool &HALT,
                        bool &NOTRDY, bool &WAKMSK, bool &SOFTRST,
                        bool &FRZACK, bool &SUPV, bool &SLFWAK, bool &WRNEN,
                        bool &LPMACK, bool &WAKSRC, bool &DOZE, bool &SRXDIS,
                        bool &IRMQ, bool &DMA, bool &LPRIOEN, bool &AEN,
                        bool &FDEN, CAN1_MCR_IDAM &IDAM,
                        uint8_t &MAXMB) volatile
    {
        uint32_t curr = MCR;

        MDIS = curr & (1u << 31u);
        FRZ = curr & (1u << 30u);
        RFEN = curr & (1u << 29u);
        HALT = curr & (1u << 28u);
        NOTRDY = curr & (1u << 27u);
        WAKMSK = curr & (1u << 26u);
        SOFTRST = curr & (1u << 25u);
        FRZACK = curr & (1u << 24u);
        SUPV = curr & (1u << 23u);
        SLFWAK = curr & (1u << 22u);
        WRNEN = curr & (1u << 21u);
        LPMACK = curr & (1u << 20u);
        WAKSRC = curr & (1u << 19u);
        DOZE = curr & (1u << 18u);
        SRXDIS = curr & (1u << 17u);
        IRMQ = curr & (1u << 16u);
        DMA = curr & (1u << 15u);
        LPRIOEN = curr & (1u << 13u);
        AEN = curr & (1u << 12u);
        FDEN = curr & (1u << 11u);
        IDAM = CAN1_MCR_IDAM((curr >> 8u) & 0b11u);
        MAXMB = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of MCR's bit fields.
     *
     * (read-write) Module Configuration register
     */
    inline void set_MCR(bool MDIS, bool FRZ, bool RFEN, bool HALT, bool WAKMSK,
                        bool SOFTRST, bool SUPV, bool SLFWAK, bool WRNEN,
                        bool WAKSRC, bool DOZE, bool SRXDIS, bool IRMQ,
                        bool DMA, bool LPRIOEN, bool AEN, bool FDEN,
                        CAN1_MCR_IDAM IDAM, uint8_t MAXMB) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b1u << 31u);
        curr |= (MDIS & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (FRZ & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (RFEN & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (HALT & 0b1u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (WAKMSK & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (SOFTRST & 0b1u) << 25u;
        curr &= ~(0b1u << 23u);
        curr |= (SUPV & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (SLFWAK & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (WRNEN & 0b1u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (WAKSRC & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (DOZE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (SRXDIS & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (IRMQ & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (DMA & 0b1u) << 15u;
        curr &= ~(0b1u << 13u);
        curr |= (LPRIOEN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (AEN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (FDEN & 0b1u) << 11u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(IDAM) & 0b11u) << 8u;
        curr &= ~(0b1111111u << 0u);
        curr |= (MAXMB & 0b1111111u) << 0u;

        MCR = curr;
    }

    /**
     * Get CTRL1's PRESDIV field.
     *
     * Prescaler Division Factor
     */
    inline uint8_t get_CTRL1_PRESDIV() volatile
    {
        return (CTRL1 >> 24u) & 0b11111111u;
    }

    /**
     * Set CTRL1's PRESDIV field.
     *
     * Prescaler Division Factor
     */
    inline void set_CTRL1_PRESDIV(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's RJW field.
     *
     * Resync Jump Width
     */
    inline uint8_t get_CTRL1_RJW() volatile
    {
        return (CTRL1 >> 22u) & 0b11u;
    }

    /**
     * Set CTRL1's RJW field.
     *
     * Resync Jump Width
     */
    inline void set_CTRL1_RJW(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's PSEG1 field.
     *
     * Phase Segment 1
     */
    inline uint8_t get_CTRL1_PSEG1() volatile
    {
        return (CTRL1 >> 19u) & 0b111u;
    }

    /**
     * Set CTRL1's PSEG1 field.
     *
     * Phase Segment 1
     */
    inline void set_CTRL1_PSEG1(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's PSEG2 field.
     *
     * Phase Segment 2
     */
    inline uint8_t get_CTRL1_PSEG2() volatile
    {
        return (CTRL1 >> 16u) & 0b111u;
    }

    /**
     * Set CTRL1's PSEG2 field.
     *
     * Phase Segment 2
     */
    inline void set_CTRL1_PSEG2(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's BOFFMSK bit.
     *
     * Bus Off Interrupt Mask
     */
    inline bool get_CTRL1_BOFFMSK() volatile
    {
        return CTRL1 & (1u << 15u);
    }

    /**
     * Set CTRL1's BOFFMSK bit.
     *
     * Bus Off Interrupt Mask
     */
    inline void set_CTRL1_BOFFMSK() volatile
    {
        CTRL1 |= 1u << 15u;
    }

    /**
     * Clear CTRL1's BOFFMSK bit.
     *
     * Bus Off Interrupt Mask
     */
    inline void clear_CTRL1_BOFFMSK() volatile
    {
        CTRL1 &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL1's BOFFMSK bit.
     *
     * Bus Off Interrupt Mask
     */
    inline void toggle_CTRL1_BOFFMSK() volatile
    {
        CTRL1 ^= 1u << 15u;
    }

    /**
     * Get CTRL1's ERRMSK bit.
     *
     * Error Interrupt Mask
     */
    inline bool get_CTRL1_ERRMSK() volatile
    {
        return CTRL1 & (1u << 14u);
    }

    /**
     * Set CTRL1's ERRMSK bit.
     *
     * Error Interrupt Mask
     */
    inline void set_CTRL1_ERRMSK() volatile
    {
        CTRL1 |= 1u << 14u;
    }

    /**
     * Clear CTRL1's ERRMSK bit.
     *
     * Error Interrupt Mask
     */
    inline void clear_CTRL1_ERRMSK() volatile
    {
        CTRL1 &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL1's ERRMSK bit.
     *
     * Error Interrupt Mask
     */
    inline void toggle_CTRL1_ERRMSK() volatile
    {
        CTRL1 ^= 1u << 14u;
    }

    /**
     * Get CTRL1's CLKSRC bit.
     *
     * CAN Engine Clock Source
     */
    inline bool get_CTRL1_CLKSRC() volatile
    {
        return CTRL1 & (1u << 13u);
    }

    /**
     * Set CTRL1's CLKSRC bit.
     *
     * CAN Engine Clock Source
     */
    inline void set_CTRL1_CLKSRC() volatile
    {
        CTRL1 |= 1u << 13u;
    }

    /**
     * Clear CTRL1's CLKSRC bit.
     *
     * CAN Engine Clock Source
     */
    inline void clear_CTRL1_CLKSRC() volatile
    {
        CTRL1 &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL1's CLKSRC bit.
     *
     * CAN Engine Clock Source
     */
    inline void toggle_CTRL1_CLKSRC() volatile
    {
        CTRL1 ^= 1u << 13u;
    }

    /**
     * Get CTRL1's LPB bit.
     *
     * Loop Back Mode
     */
    inline bool get_CTRL1_LPB() volatile
    {
        return CTRL1 & (1u << 12u);
    }

    /**
     * Set CTRL1's LPB bit.
     *
     * Loop Back Mode
     */
    inline void set_CTRL1_LPB() volatile
    {
        CTRL1 |= 1u << 12u;
    }

    /**
     * Clear CTRL1's LPB bit.
     *
     * Loop Back Mode
     */
    inline void clear_CTRL1_LPB() volatile
    {
        CTRL1 &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL1's LPB bit.
     *
     * Loop Back Mode
     */
    inline void toggle_CTRL1_LPB() volatile
    {
        CTRL1 ^= 1u << 12u;
    }

    /**
     * Get CTRL1's TWRNMSK bit.
     *
     * Tx Warning Interrupt Mask
     */
    inline bool get_CTRL1_TWRNMSK() volatile
    {
        return CTRL1 & (1u << 11u);
    }

    /**
     * Set CTRL1's TWRNMSK bit.
     *
     * Tx Warning Interrupt Mask
     */
    inline void set_CTRL1_TWRNMSK() volatile
    {
        CTRL1 |= 1u << 11u;
    }

    /**
     * Clear CTRL1's TWRNMSK bit.
     *
     * Tx Warning Interrupt Mask
     */
    inline void clear_CTRL1_TWRNMSK() volatile
    {
        CTRL1 &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL1's TWRNMSK bit.
     *
     * Tx Warning Interrupt Mask
     */
    inline void toggle_CTRL1_TWRNMSK() volatile
    {
        CTRL1 ^= 1u << 11u;
    }

    /**
     * Get CTRL1's RWRNMSK bit.
     *
     * Rx Warning Interrupt Mask
     */
    inline bool get_CTRL1_RWRNMSK() volatile
    {
        return CTRL1 & (1u << 10u);
    }

    /**
     * Set CTRL1's RWRNMSK bit.
     *
     * Rx Warning Interrupt Mask
     */
    inline void set_CTRL1_RWRNMSK() volatile
    {
        CTRL1 |= 1u << 10u;
    }

    /**
     * Clear CTRL1's RWRNMSK bit.
     *
     * Rx Warning Interrupt Mask
     */
    inline void clear_CTRL1_RWRNMSK() volatile
    {
        CTRL1 &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL1's RWRNMSK bit.
     *
     * Rx Warning Interrupt Mask
     */
    inline void toggle_CTRL1_RWRNMSK() volatile
    {
        CTRL1 ^= 1u << 10u;
    }

    /**
     * Get CTRL1's SMP bit.
     *
     * CAN Bit Sampling
     */
    inline bool get_CTRL1_SMP() volatile
    {
        return CTRL1 & (1u << 7u);
    }

    /**
     * Set CTRL1's SMP bit.
     *
     * CAN Bit Sampling
     */
    inline void set_CTRL1_SMP() volatile
    {
        CTRL1 |= 1u << 7u;
    }

    /**
     * Clear CTRL1's SMP bit.
     *
     * CAN Bit Sampling
     */
    inline void clear_CTRL1_SMP() volatile
    {
        CTRL1 &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL1's SMP bit.
     *
     * CAN Bit Sampling
     */
    inline void toggle_CTRL1_SMP() volatile
    {
        CTRL1 ^= 1u << 7u;
    }

    /**
     * Get CTRL1's BOFFREC bit.
     *
     * Bus Off Recovery
     */
    inline bool get_CTRL1_BOFFREC() volatile
    {
        return CTRL1 & (1u << 6u);
    }

    /**
     * Set CTRL1's BOFFREC bit.
     *
     * Bus Off Recovery
     */
    inline void set_CTRL1_BOFFREC() volatile
    {
        CTRL1 |= 1u << 6u;
    }

    /**
     * Clear CTRL1's BOFFREC bit.
     *
     * Bus Off Recovery
     */
    inline void clear_CTRL1_BOFFREC() volatile
    {
        CTRL1 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL1's BOFFREC bit.
     *
     * Bus Off Recovery
     */
    inline void toggle_CTRL1_BOFFREC() volatile
    {
        CTRL1 ^= 1u << 6u;
    }

    /**
     * Get CTRL1's TSYN bit.
     *
     * Timer Sync
     */
    inline bool get_CTRL1_TSYN() volatile
    {
        return CTRL1 & (1u << 5u);
    }

    /**
     * Set CTRL1's TSYN bit.
     *
     * Timer Sync
     */
    inline void set_CTRL1_TSYN() volatile
    {
        CTRL1 |= 1u << 5u;
    }

    /**
     * Clear CTRL1's TSYN bit.
     *
     * Timer Sync
     */
    inline void clear_CTRL1_TSYN() volatile
    {
        CTRL1 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL1's TSYN bit.
     *
     * Timer Sync
     */
    inline void toggle_CTRL1_TSYN() volatile
    {
        CTRL1 ^= 1u << 5u;
    }

    /**
     * Get CTRL1's LBUF bit.
     *
     * Lowest Buffer Transmitted First
     */
    inline bool get_CTRL1_LBUF() volatile
    {
        return CTRL1 & (1u << 4u);
    }

    /**
     * Set CTRL1's LBUF bit.
     *
     * Lowest Buffer Transmitted First
     */
    inline void set_CTRL1_LBUF() volatile
    {
        CTRL1 |= 1u << 4u;
    }

    /**
     * Clear CTRL1's LBUF bit.
     *
     * Lowest Buffer Transmitted First
     */
    inline void clear_CTRL1_LBUF() volatile
    {
        CTRL1 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL1's LBUF bit.
     *
     * Lowest Buffer Transmitted First
     */
    inline void toggle_CTRL1_LBUF() volatile
    {
        CTRL1 ^= 1u << 4u;
    }

    /**
     * Get CTRL1's LOM bit.
     *
     * Listen-Only Mode
     */
    inline bool get_CTRL1_LOM() volatile
    {
        return CTRL1 & (1u << 3u);
    }

    /**
     * Set CTRL1's LOM bit.
     *
     * Listen-Only Mode
     */
    inline void set_CTRL1_LOM() volatile
    {
        CTRL1 |= 1u << 3u;
    }

    /**
     * Clear CTRL1's LOM bit.
     *
     * Listen-Only Mode
     */
    inline void clear_CTRL1_LOM() volatile
    {
        CTRL1 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL1's LOM bit.
     *
     * Listen-Only Mode
     */
    inline void toggle_CTRL1_LOM() volatile
    {
        CTRL1 ^= 1u << 3u;
    }

    /**
     * Get CTRL1's PROPSEG field.
     *
     * Propagation Segment
     */
    inline uint8_t get_CTRL1_PROPSEG() volatile
    {
        return (CTRL1 >> 0u) & 0b111u;
    }

    /**
     * Set CTRL1's PROPSEG field.
     *
     * Propagation Segment
     */
    inline void set_CTRL1_PROPSEG(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get all of CTRL1's bit fields.
     *
     * (read-write) Control 1 register
     */
    inline void get_CTRL1(uint8_t &PRESDIV, uint8_t &RJW, uint8_t &PSEG1,
                          uint8_t &PSEG2, bool &BOFFMSK, bool &ERRMSK,
                          bool &CLKSRC, bool &LPB, bool &TWRNMSK,
                          bool &RWRNMSK, bool &SMP, bool &BOFFREC, bool &TSYN,
                          bool &LBUF, bool &LOM, uint8_t &PROPSEG) volatile
    {
        uint32_t curr = CTRL1;

        PRESDIV = (curr >> 24u) & 0b11111111u;
        RJW = (curr >> 22u) & 0b11u;
        PSEG1 = (curr >> 19u) & 0b111u;
        PSEG2 = (curr >> 16u) & 0b111u;
        BOFFMSK = curr & (1u << 15u);
        ERRMSK = curr & (1u << 14u);
        CLKSRC = curr & (1u << 13u);
        LPB = curr & (1u << 12u);
        TWRNMSK = curr & (1u << 11u);
        RWRNMSK = curr & (1u << 10u);
        SMP = curr & (1u << 7u);
        BOFFREC = curr & (1u << 6u);
        TSYN = curr & (1u << 5u);
        LBUF = curr & (1u << 4u);
        LOM = curr & (1u << 3u);
        PROPSEG = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of CTRL1's bit fields.
     *
     * (read-write) Control 1 register
     */
    inline void set_CTRL1(uint8_t PRESDIV, uint8_t RJW, uint8_t PSEG1,
                          uint8_t PSEG2, bool BOFFMSK, bool ERRMSK,
                          bool CLKSRC, bool LPB, bool TWRNMSK, bool RWRNMSK,
                          bool SMP, bool BOFFREC, bool TSYN, bool LBUF,
                          bool LOM, uint8_t PROPSEG) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRESDIV & 0b11111111u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (RJW & 0b11u) << 22u;
        curr &= ~(0b111u << 19u);
        curr |= (PSEG1 & 0b111u) << 19u;
        curr &= ~(0b111u << 16u);
        curr |= (PSEG2 & 0b111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (BOFFMSK & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ERRMSK & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CLKSRC & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (LPB & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TWRNMSK & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RWRNMSK & 0b1u) << 10u;
        curr &= ~(0b1u << 7u);
        curr |= (SMP & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (BOFFREC & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TSYN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (LBUF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LOM & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (PROPSEG & 0b111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get TIMER's TIMER field.
     *
     * Timer Value
     */
    inline uint16_t get_TIMER_TIMER() volatile
    {
        return (TIMER >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER's TIMER field.
     *
     * Timer Value
     */
    inline void set_TIMER_TIMER(uint16_t value) volatile
    {
        uint32_t curr = TIMER;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER = curr;
    }

    /**
     * Get RXMGMASK's MG field.
     *
     * Rx Mailboxes Global Mask Bits
     */
    inline uint32_t get_RXMGMASK_MG() volatile
    {
        return (RXMGMASK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set RXMGMASK's MG field.
     *
     * Rx Mailboxes Global Mask Bits
     */
    inline void set_RXMGMASK_MG(uint32_t value) volatile
    {
        uint32_t curr = RXMGMASK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        RXMGMASK = curr;
    }

    /**
     * Get RX14MASK's RX14M field.
     *
     * Rx Buffer 14 Mask Bits
     */
    inline uint32_t get_RX14MASK_RX14M() volatile
    {
        return (RX14MASK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set RX14MASK's RX14M field.
     *
     * Rx Buffer 14 Mask Bits
     */
    inline void set_RX14MASK_RX14M(uint32_t value) volatile
    {
        uint32_t curr = RX14MASK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        RX14MASK = curr;
    }

    /**
     * Get RX15MASK's RX15M field.
     *
     * Rx Buffer 15 Mask Bits
     */
    inline uint32_t get_RX15MASK_RX15M() volatile
    {
        return (RX15MASK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set RX15MASK's RX15M field.
     *
     * Rx Buffer 15 Mask Bits
     */
    inline void set_RX15MASK_RX15M(uint32_t value) volatile
    {
        uint32_t curr = RX15MASK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        RX15MASK = curr;
    }

    /**
     * Get ECR's RXERRCNT_FAST field.
     *
     * Receive Error Counter for fast bits
     */
    inline uint8_t get_ECR_RXERRCNT_FAST() volatile
    {
        return (ECR >> 24u) & 0b11111111u;
    }

    /**
     * Set ECR's RXERRCNT_FAST field.
     *
     * Receive Error Counter for fast bits
     */
    inline void set_ECR_RXERRCNT_FAST(uint8_t value) volatile
    {
        uint32_t curr = ECR;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        ECR = curr;
    }

    /**
     * Get ECR's TXERRCNT_FAST field.
     *
     * Transmit Error Counter for fast bits
     */
    inline uint8_t get_ECR_TXERRCNT_FAST() volatile
    {
        return (ECR >> 16u) & 0b11111111u;
    }

    /**
     * Set ECR's TXERRCNT_FAST field.
     *
     * Transmit Error Counter for fast bits
     */
    inline void set_ECR_TXERRCNT_FAST(uint8_t value) volatile
    {
        uint32_t curr = ECR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        ECR = curr;
    }

    /**
     * Get ECR's RXERRCNT field.
     *
     * Receive Error Counter
     */
    inline uint8_t get_ECR_RXERRCNT() volatile
    {
        return (ECR >> 8u) & 0b11111111u;
    }

    /**
     * Set ECR's RXERRCNT field.
     *
     * Receive Error Counter
     */
    inline void set_ECR_RXERRCNT(uint8_t value) volatile
    {
        uint32_t curr = ECR;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        ECR = curr;
    }

    /**
     * Get ECR's TXERRCNT field.
     *
     * Transmit Error Counter
     */
    inline uint8_t get_ECR_TXERRCNT() volatile
    {
        return (ECR >> 0u) & 0b11111111u;
    }

    /**
     * Set ECR's TXERRCNT field.
     *
     * Transmit Error Counter
     */
    inline void set_ECR_TXERRCNT(uint8_t value) volatile
    {
        uint32_t curr = ECR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        ECR = curr;
    }

    /**
     * Get all of ECR's bit fields.
     *
     * (read-write) Error Counter
     */
    inline void get_ECR(uint8_t &RXERRCNT_FAST, uint8_t &TXERRCNT_FAST,
                        uint8_t &RXERRCNT, uint8_t &TXERRCNT) volatile
    {
        uint32_t curr = ECR;

        RXERRCNT_FAST = (curr >> 24u) & 0b11111111u;
        TXERRCNT_FAST = (curr >> 16u) & 0b11111111u;
        RXERRCNT = (curr >> 8u) & 0b11111111u;
        TXERRCNT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of ECR's bit fields.
     *
     * (read-write) Error Counter
     */
    inline void set_ECR(uint8_t RXERRCNT_FAST, uint8_t TXERRCNT_FAST,
                        uint8_t RXERRCNT, uint8_t TXERRCNT) volatile
    {
        uint32_t curr = ECR;

        curr &= ~(0b11111111u << 24u);
        curr |= (RXERRCNT_FAST & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (TXERRCNT_FAST & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (RXERRCNT & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (TXERRCNT & 0b11111111u) << 0u;

        ECR = curr;
    }

    /**
     * Get ESR1's BIT1ERR_FAST bit.
     *
     * Bit1 Error in the Data Phase of CAN FD frames with the BRS bit set
     */
    inline bool get_ESR1_BIT1ERR_FAST() volatile
    {
        return ESR1 & (1u << 31u);
    }

    /**
     * Get ESR1's BIT0ERR_FAST bit.
     *
     * Bit0 Error in the Data Phase of CAN FD frames with the BRS bit set
     */
    inline bool get_ESR1_BIT0ERR_FAST() volatile
    {
        return ESR1 & (1u << 30u);
    }

    /**
     * Get ESR1's CRCERR_FAST bit.
     *
     * Cyclic Redundancy Check Error in the CRC field of CAN FD frames with the
     * BRS bit set
     */
    inline bool get_ESR1_CRCERR_FAST() volatile
    {
        return ESR1 & (1u << 28u);
    }

    /**
     * Get ESR1's FRMERR_FAST bit.
     *
     * Form Error in the Data Phase of CAN FD frames with the BRS bit set
     */
    inline bool get_ESR1_FRMERR_FAST() volatile
    {
        return ESR1 & (1u << 27u);
    }

    /**
     * Get ESR1's STFERR_FAST bit.
     *
     * Stuffing Error in the Data Phase of CAN FD frames with the BRS bit set
     */
    inline bool get_ESR1_STFERR_FAST() volatile
    {
        return ESR1 & (1u << 26u);
    }

    /**
     * Get ESR1's ERROVR bit.
     *
     * Error Overrun
     */
    inline bool get_ESR1_ERROVR() volatile
    {
        return ESR1 & (1u << 21u);
    }

    /**
     * Set ESR1's ERROVR bit.
     *
     * Error Overrun
     */
    inline void set_ESR1_ERROVR() volatile
    {
        ESR1 |= 1u << 21u;
    }

    /**
     * Clear ESR1's ERROVR bit.
     *
     * Error Overrun
     */
    inline void clear_ESR1_ERROVR() volatile
    {
        ESR1 &= ~(1u << 21u);
    }

    /**
     * Toggle ESR1's ERROVR bit.
     *
     * Error Overrun
     */
    inline void toggle_ESR1_ERROVR() volatile
    {
        ESR1 ^= 1u << 21u;
    }

    /**
     * Get ESR1's ERRINT_FAST bit.
     *
     * Error interrupt for errors detected in Data Phase of CAN FD frames with
     * BRS bit set
     */
    inline bool get_ESR1_ERRINT_FAST() volatile
    {
        return ESR1 & (1u << 20u);
    }

    /**
     * Set ESR1's ERRINT_FAST bit.
     *
     * Error interrupt for errors detected in Data Phase of CAN FD frames with
     * BRS bit set
     */
    inline void set_ESR1_ERRINT_FAST() volatile
    {
        ESR1 |= 1u << 20u;
    }

    /**
     * Clear ESR1's ERRINT_FAST bit.
     *
     * Error interrupt for errors detected in Data Phase of CAN FD frames with
     * BRS bit set
     */
    inline void clear_ESR1_ERRINT_FAST() volatile
    {
        ESR1 &= ~(1u << 20u);
    }

    /**
     * Toggle ESR1's ERRINT_FAST bit.
     *
     * Error interrupt for errors detected in Data Phase of CAN FD frames with
     * BRS bit set
     */
    inline void toggle_ESR1_ERRINT_FAST() volatile
    {
        ESR1 ^= 1u << 20u;
    }

    /**
     * Get ESR1's BOFFDONEINT bit.
     *
     * Bus Off Done Interrupt
     */
    inline bool get_ESR1_BOFFDONEINT() volatile
    {
        return ESR1 & (1u << 19u);
    }

    /**
     * Set ESR1's BOFFDONEINT bit.
     *
     * Bus Off Done Interrupt
     */
    inline void set_ESR1_BOFFDONEINT() volatile
    {
        ESR1 |= 1u << 19u;
    }

    /**
     * Clear ESR1's BOFFDONEINT bit.
     *
     * Bus Off Done Interrupt
     */
    inline void clear_ESR1_BOFFDONEINT() volatile
    {
        ESR1 &= ~(1u << 19u);
    }

    /**
     * Toggle ESR1's BOFFDONEINT bit.
     *
     * Bus Off Done Interrupt
     */
    inline void toggle_ESR1_BOFFDONEINT() volatile
    {
        ESR1 ^= 1u << 19u;
    }

    /**
     * Get ESR1's SYNCH bit.
     *
     * CAN Synchronization Status
     */
    inline bool get_ESR1_SYNCH() volatile
    {
        return ESR1 & (1u << 18u);
    }

    /**
     * Get ESR1's TWRNINT bit.
     *
     * Tx Warning Interrupt Flag
     */
    inline bool get_ESR1_TWRNINT() volatile
    {
        return ESR1 & (1u << 17u);
    }

    /**
     * Set ESR1's TWRNINT bit.
     *
     * Tx Warning Interrupt Flag
     */
    inline void set_ESR1_TWRNINT() volatile
    {
        ESR1 |= 1u << 17u;
    }

    /**
     * Clear ESR1's TWRNINT bit.
     *
     * Tx Warning Interrupt Flag
     */
    inline void clear_ESR1_TWRNINT() volatile
    {
        ESR1 &= ~(1u << 17u);
    }

    /**
     * Toggle ESR1's TWRNINT bit.
     *
     * Tx Warning Interrupt Flag
     */
    inline void toggle_ESR1_TWRNINT() volatile
    {
        ESR1 ^= 1u << 17u;
    }

    /**
     * Get ESR1's RWRNINT bit.
     *
     * Rx Warning Interrupt Flag
     */
    inline bool get_ESR1_RWRNINT() volatile
    {
        return ESR1 & (1u << 16u);
    }

    /**
     * Set ESR1's RWRNINT bit.
     *
     * Rx Warning Interrupt Flag
     */
    inline void set_ESR1_RWRNINT() volatile
    {
        ESR1 |= 1u << 16u;
    }

    /**
     * Clear ESR1's RWRNINT bit.
     *
     * Rx Warning Interrupt Flag
     */
    inline void clear_ESR1_RWRNINT() volatile
    {
        ESR1 &= ~(1u << 16u);
    }

    /**
     * Toggle ESR1's RWRNINT bit.
     *
     * Rx Warning Interrupt Flag
     */
    inline void toggle_ESR1_RWRNINT() volatile
    {
        ESR1 ^= 1u << 16u;
    }

    /**
     * Get ESR1's BIT1ERR bit.
     *
     * Bit1 Error
     */
    inline bool get_ESR1_BIT1ERR() volatile
    {
        return ESR1 & (1u << 15u);
    }

    /**
     * Get ESR1's BIT0ERR bit.
     *
     * Bit0 Error
     */
    inline bool get_ESR1_BIT0ERR() volatile
    {
        return ESR1 & (1u << 14u);
    }

    /**
     * Get ESR1's ACKERR bit.
     *
     * Acknowledge Error
     */
    inline bool get_ESR1_ACKERR() volatile
    {
        return ESR1 & (1u << 13u);
    }

    /**
     * Get ESR1's CRCERR bit.
     *
     * Cyclic Redundancy Check Error
     */
    inline bool get_ESR1_CRCERR() volatile
    {
        return ESR1 & (1u << 12u);
    }

    /**
     * Get ESR1's FRMERR bit.
     *
     * Form Error
     */
    inline bool get_ESR1_FRMERR() volatile
    {
        return ESR1 & (1u << 11u);
    }

    /**
     * Get ESR1's STFERR bit.
     *
     * Stuffing Error
     */
    inline bool get_ESR1_STFERR() volatile
    {
        return ESR1 & (1u << 10u);
    }

    /**
     * Get ESR1's TXWRN bit.
     *
     * TX Error Warning
     */
    inline bool get_ESR1_TXWRN() volatile
    {
        return ESR1 & (1u << 9u);
    }

    /**
     * Get ESR1's RXWRN bit.
     *
     * Rx Error Warning
     */
    inline bool get_ESR1_RXWRN() volatile
    {
        return ESR1 & (1u << 8u);
    }

    /**
     * Get ESR1's IDLE bit.
     *
     * IDLE
     */
    inline bool get_ESR1_IDLE() volatile
    {
        return ESR1 & (1u << 7u);
    }

    /**
     * Get ESR1's TX bit.
     *
     * FlexCAN In Transmission
     */
    inline bool get_ESR1_TX() volatile
    {
        return ESR1 & (1u << 6u);
    }

    /**
     * Get ESR1's FLTCONF field.
     *
     * Fault Confinement State
     */
    inline CAN1_ESR1_FLTCONF get_ESR1_FLTCONF() volatile
    {
        return CAN1_ESR1_FLTCONF((ESR1 >> 4u) & 0b11u);
    }

    /**
     * Get ESR1's RX bit.
     *
     * FlexCAN In Reception
     */
    inline bool get_ESR1_RX() volatile
    {
        return ESR1 & (1u << 3u);
    }

    /**
     * Get ESR1's BOFFINT bit.
     *
     * Bus Off Interrupt
     */
    inline bool get_ESR1_BOFFINT() volatile
    {
        return ESR1 & (1u << 2u);
    }

    /**
     * Set ESR1's BOFFINT bit.
     *
     * Bus Off Interrupt
     */
    inline void set_ESR1_BOFFINT() volatile
    {
        ESR1 |= 1u << 2u;
    }

    /**
     * Clear ESR1's BOFFINT bit.
     *
     * Bus Off Interrupt
     */
    inline void clear_ESR1_BOFFINT() volatile
    {
        ESR1 &= ~(1u << 2u);
    }

    /**
     * Toggle ESR1's BOFFINT bit.
     *
     * Bus Off Interrupt
     */
    inline void toggle_ESR1_BOFFINT() volatile
    {
        ESR1 ^= 1u << 2u;
    }

    /**
     * Get ESR1's ERRINT bit.
     *
     * Error Interrupt
     */
    inline bool get_ESR1_ERRINT() volatile
    {
        return ESR1 & (1u << 1u);
    }

    /**
     * Set ESR1's ERRINT bit.
     *
     * Error Interrupt
     */
    inline void set_ESR1_ERRINT() volatile
    {
        ESR1 |= 1u << 1u;
    }

    /**
     * Clear ESR1's ERRINT bit.
     *
     * Error Interrupt
     */
    inline void clear_ESR1_ERRINT() volatile
    {
        ESR1 &= ~(1u << 1u);
    }

    /**
     * Toggle ESR1's ERRINT bit.
     *
     * Error Interrupt
     */
    inline void toggle_ESR1_ERRINT() volatile
    {
        ESR1 ^= 1u << 1u;
    }

    /**
     * Get ESR1's WAKINT bit.
     *
     * Wake-Up Interrupt
     */
    inline bool get_ESR1_WAKINT() volatile
    {
        return ESR1 & (1u << 0u);
    }

    /**
     * Set ESR1's WAKINT bit.
     *
     * Wake-Up Interrupt
     */
    inline void set_ESR1_WAKINT() volatile
    {
        ESR1 |= 1u << 0u;
    }

    /**
     * Clear ESR1's WAKINT bit.
     *
     * Wake-Up Interrupt
     */
    inline void clear_ESR1_WAKINT() volatile
    {
        ESR1 &= ~(1u << 0u);
    }

    /**
     * Toggle ESR1's WAKINT bit.
     *
     * Wake-Up Interrupt
     */
    inline void toggle_ESR1_WAKINT() volatile
    {
        ESR1 ^= 1u << 0u;
    }

    /**
     * Get all of ESR1's bit fields.
     *
     * (read-write) Error and Status 1 register
     */
    inline void get_ESR1(bool &BIT1ERR_FAST, bool &BIT0ERR_FAST,
                         bool &CRCERR_FAST, bool &FRMERR_FAST,
                         bool &STFERR_FAST, bool &ERROVR, bool &ERRINT_FAST,
                         bool &BOFFDONEINT, bool &SYNCH, bool &TWRNINT,
                         bool &RWRNINT, bool &BIT1ERR, bool &BIT0ERR,
                         bool &ACKERR, bool &CRCERR, bool &FRMERR,
                         bool &STFERR, bool &TXWRN, bool &RXWRN, bool &IDLE,
                         bool &TX, CAN1_ESR1_FLTCONF &FLTCONF, bool &RX,
                         bool &BOFFINT, bool &ERRINT, bool &WAKINT) volatile
    {
        uint32_t curr = ESR1;

        BIT1ERR_FAST = curr & (1u << 31u);
        BIT0ERR_FAST = curr & (1u << 30u);
        CRCERR_FAST = curr & (1u << 28u);
        FRMERR_FAST = curr & (1u << 27u);
        STFERR_FAST = curr & (1u << 26u);
        ERROVR = curr & (1u << 21u);
        ERRINT_FAST = curr & (1u << 20u);
        BOFFDONEINT = curr & (1u << 19u);
        SYNCH = curr & (1u << 18u);
        TWRNINT = curr & (1u << 17u);
        RWRNINT = curr & (1u << 16u);
        BIT1ERR = curr & (1u << 15u);
        BIT0ERR = curr & (1u << 14u);
        ACKERR = curr & (1u << 13u);
        CRCERR = curr & (1u << 12u);
        FRMERR = curr & (1u << 11u);
        STFERR = curr & (1u << 10u);
        TXWRN = curr & (1u << 9u);
        RXWRN = curr & (1u << 8u);
        IDLE = curr & (1u << 7u);
        TX = curr & (1u << 6u);
        FLTCONF = CAN1_ESR1_FLTCONF((curr >> 4u) & 0b11u);
        RX = curr & (1u << 3u);
        BOFFINT = curr & (1u << 2u);
        ERRINT = curr & (1u << 1u);
        WAKINT = curr & (1u << 0u);
    }

    /**
     * Set all of ESR1's bit fields.
     *
     * (read-write) Error and Status 1 register
     */
    inline void set_ESR1(bool ERROVR, bool ERRINT_FAST, bool BOFFDONEINT,
                         bool TWRNINT, bool RWRNINT, bool BOFFINT, bool ERRINT,
                         bool WAKINT) volatile
    {
        uint32_t curr = ESR1;

        curr &= ~(0b1u << 21u);
        curr |= (ERROVR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ERRINT_FAST & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (BOFFDONEINT & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (TWRNINT & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RWRNINT & 0b1u) << 16u;
        curr &= ~(0b1u << 2u);
        curr |= (BOFFINT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ERRINT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (WAKINT & 0b1u) << 0u;

        ESR1 = curr;
    }

    /**
     * Get IMASK2's BUF63TO32M field.
     *
     * Buffer MBi Mask
     */
    inline uint32_t get_IMASK2_BUF63TO32M() volatile
    {
        return (IMASK2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IMASK2's BUF63TO32M field.
     *
     * Buffer MBi Mask
     */
    inline void set_IMASK2_BUF63TO32M(uint32_t value) volatile
    {
        uint32_t curr = IMASK2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IMASK2 = curr;
    }

    /**
     * Get IMASK1's BUF31TO0M field.
     *
     * Buffer MBi Mask
     */
    inline uint32_t get_IMASK1_BUF31TO0M() volatile
    {
        return (IMASK1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IMASK1's BUF31TO0M field.
     *
     * Buffer MBi Mask
     */
    inline void set_IMASK1_BUF31TO0M(uint32_t value) volatile
    {
        uint32_t curr = IMASK1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IMASK1 = curr;
    }

    /**
     * Get IFLAG2's BUF63TO32I field.
     *
     * Buffer MBi Interrupt
     */
    inline uint32_t get_IFLAG2_BUF63TO32I() volatile
    {
        return (IFLAG2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IFLAG2's BUF63TO32I field.
     *
     * Buffer MBi Interrupt
     */
    inline void set_IFLAG2_BUF63TO32I(uint32_t value) volatile
    {
        uint32_t curr = IFLAG2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IFLAG2 = curr;
    }

    /**
     * Get IFLAG1's BUF31TO8I field.
     *
     * Buffer MBi Interrupt
     */
    inline uint32_t get_IFLAG1_BUF31TO8I() volatile
    {
        return (IFLAG1 >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set IFLAG1's BUF31TO8I field.
     *
     * Buffer MBi Interrupt
     */
    inline void set_IFLAG1_BUF31TO8I(uint32_t value) volatile
    {
        uint32_t curr = IFLAG1;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        IFLAG1 = curr;
    }

    /**
     * Get IFLAG1's BUF7I bit.
     *
     * Buffer MB7 Interrupt Or Rx FIFO Overflow
     */
    inline bool get_IFLAG1_BUF7I() volatile
    {
        return IFLAG1 & (1u << 7u);
    }

    /**
     * Set IFLAG1's BUF7I bit.
     *
     * Buffer MB7 Interrupt Or Rx FIFO Overflow
     */
    inline void set_IFLAG1_BUF7I() volatile
    {
        IFLAG1 |= 1u << 7u;
    }

    /**
     * Clear IFLAG1's BUF7I bit.
     *
     * Buffer MB7 Interrupt Or Rx FIFO Overflow
     */
    inline void clear_IFLAG1_BUF7I() volatile
    {
        IFLAG1 &= ~(1u << 7u);
    }

    /**
     * Toggle IFLAG1's BUF7I bit.
     *
     * Buffer MB7 Interrupt Or Rx FIFO Overflow
     */
    inline void toggle_IFLAG1_BUF7I() volatile
    {
        IFLAG1 ^= 1u << 7u;
    }

    /**
     * Get IFLAG1's BUF6I bit.
     *
     * Buffer MB6 Interrupt Or Rx FIFO Warning
     */
    inline bool get_IFLAG1_BUF6I() volatile
    {
        return IFLAG1 & (1u << 6u);
    }

    /**
     * Set IFLAG1's BUF6I bit.
     *
     * Buffer MB6 Interrupt Or Rx FIFO Warning
     */
    inline void set_IFLAG1_BUF6I() volatile
    {
        IFLAG1 |= 1u << 6u;
    }

    /**
     * Clear IFLAG1's BUF6I bit.
     *
     * Buffer MB6 Interrupt Or Rx FIFO Warning
     */
    inline void clear_IFLAG1_BUF6I() volatile
    {
        IFLAG1 &= ~(1u << 6u);
    }

    /**
     * Toggle IFLAG1's BUF6I bit.
     *
     * Buffer MB6 Interrupt Or Rx FIFO Warning
     */
    inline void toggle_IFLAG1_BUF6I() volatile
    {
        IFLAG1 ^= 1u << 6u;
    }

    /**
     * Get IFLAG1's BUF5I bit.
     *
     * Buffer MB5 Interrupt Or Frames available in Rx FIFO
     */
    inline bool get_IFLAG1_BUF5I() volatile
    {
        return IFLAG1 & (1u << 5u);
    }

    /**
     * Set IFLAG1's BUF5I bit.
     *
     * Buffer MB5 Interrupt Or Frames available in Rx FIFO
     */
    inline void set_IFLAG1_BUF5I() volatile
    {
        IFLAG1 |= 1u << 5u;
    }

    /**
     * Clear IFLAG1's BUF5I bit.
     *
     * Buffer MB5 Interrupt Or Frames available in Rx FIFO
     */
    inline void clear_IFLAG1_BUF5I() volatile
    {
        IFLAG1 &= ~(1u << 5u);
    }

    /**
     * Toggle IFLAG1's BUF5I bit.
     *
     * Buffer MB5 Interrupt Or Frames available in Rx FIFO
     */
    inline void toggle_IFLAG1_BUF5I() volatile
    {
        IFLAG1 ^= 1u << 5u;
    }

    /**
     * Get IFLAG1's BUF4TO1I field.
     *
     * Buffer MBi Interrupt Or Reserved
     */
    inline uint8_t get_IFLAG1_BUF4TO1I() volatile
    {
        return (IFLAG1 >> 1u) & 0b1111u;
    }

    /**
     * Set IFLAG1's BUF4TO1I field.
     *
     * Buffer MBi Interrupt Or Reserved
     */
    inline void set_IFLAG1_BUF4TO1I(uint8_t value) volatile
    {
        uint32_t curr = IFLAG1;

        curr &= ~(0b1111u << 1u);
        curr |= (value & 0b1111u) << 1u;

        IFLAG1 = curr;
    }

    /**
     * Get IFLAG1's BUF0I bit.
     *
     * Buffer MB0 Interrupt Or Clear FIFO bit
     */
    inline bool get_IFLAG1_BUF0I() volatile
    {
        return IFLAG1 & (1u << 0u);
    }

    /**
     * Set IFLAG1's BUF0I bit.
     *
     * Buffer MB0 Interrupt Or Clear FIFO bit
     */
    inline void set_IFLAG1_BUF0I() volatile
    {
        IFLAG1 |= 1u << 0u;
    }

    /**
     * Clear IFLAG1's BUF0I bit.
     *
     * Buffer MB0 Interrupt Or Clear FIFO bit
     */
    inline void clear_IFLAG1_BUF0I() volatile
    {
        IFLAG1 &= ~(1u << 0u);
    }

    /**
     * Toggle IFLAG1's BUF0I bit.
     *
     * Buffer MB0 Interrupt Or Clear FIFO bit
     */
    inline void toggle_IFLAG1_BUF0I() volatile
    {
        IFLAG1 ^= 1u << 0u;
    }

    /**
     * Get all of IFLAG1's bit fields.
     *
     * (read-write) Interrupt Flags 1 register
     */
    inline void get_IFLAG1(uint32_t &BUF31TO8I, bool &BUF7I, bool &BUF6I,
                           bool &BUF5I, uint8_t &BUF4TO1I,
                           bool &BUF0I) volatile
    {
        uint32_t curr = IFLAG1;

        BUF31TO8I = (curr >> 8u) & 0b111111111111111111111111u;
        BUF7I = curr & (1u << 7u);
        BUF6I = curr & (1u << 6u);
        BUF5I = curr & (1u << 5u);
        BUF4TO1I = (curr >> 1u) & 0b1111u;
        BUF0I = curr & (1u << 0u);
    }

    /**
     * Set all of IFLAG1's bit fields.
     *
     * (read-write) Interrupt Flags 1 register
     */
    inline void set_IFLAG1(uint32_t BUF31TO8I, bool BUF7I, bool BUF6I,
                           bool BUF5I, uint8_t BUF4TO1I, bool BUF0I) volatile
    {
        uint32_t curr = IFLAG1;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (BUF31TO8I & 0b111111111111111111111111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (BUF7I & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (BUF6I & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BUF5I & 0b1u) << 5u;
        curr &= ~(0b1111u << 1u);
        curr |= (BUF4TO1I & 0b1111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (BUF0I & 0b1u) << 0u;

        IFLAG1 = curr;
    }

    /**
     * Get CTRL2's ERRMSK_FAST bit.
     *
     * Error Interrupt Mask for errors detected in the data phase of fast CAN
     * FD frames
     */
    inline bool get_CTRL2_ERRMSK_FAST() volatile
    {
        return CTRL2 & (1u << 31u);
    }

    /**
     * Set CTRL2's ERRMSK_FAST bit.
     *
     * Error Interrupt Mask for errors detected in the data phase of fast CAN
     * FD frames
     */
    inline void set_CTRL2_ERRMSK_FAST() volatile
    {
        CTRL2 |= 1u << 31u;
    }

    /**
     * Clear CTRL2's ERRMSK_FAST bit.
     *
     * Error Interrupt Mask for errors detected in the data phase of fast CAN
     * FD frames
     */
    inline void clear_CTRL2_ERRMSK_FAST() volatile
    {
        CTRL2 &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL2's ERRMSK_FAST bit.
     *
     * Error Interrupt Mask for errors detected in the data phase of fast CAN
     * FD frames
     */
    inline void toggle_CTRL2_ERRMSK_FAST() volatile
    {
        CTRL2 ^= 1u << 31u;
    }

    /**
     * Get CTRL2's BOFFDONEMSK bit.
     *
     * Bus Off Done Interrupt Mask
     */
    inline bool get_CTRL2_BOFFDONEMSK() volatile
    {
        return CTRL2 & (1u << 30u);
    }

    /**
     * Set CTRL2's BOFFDONEMSK bit.
     *
     * Bus Off Done Interrupt Mask
     */
    inline void set_CTRL2_BOFFDONEMSK() volatile
    {
        CTRL2 |= 1u << 30u;
    }

    /**
     * Clear CTRL2's BOFFDONEMSK bit.
     *
     * Bus Off Done Interrupt Mask
     */
    inline void clear_CTRL2_BOFFDONEMSK() volatile
    {
        CTRL2 &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL2's BOFFDONEMSK bit.
     *
     * Bus Off Done Interrupt Mask
     */
    inline void toggle_CTRL2_BOFFDONEMSK() volatile
    {
        CTRL2 ^= 1u << 30u;
    }

    /**
     * Get CTRL2's ECRWRE bit.
     *
     * Error-correction Configuration Register Write Enable
     */
    inline bool get_CTRL2_ECRWRE() volatile
    {
        return CTRL2 & (1u << 29u);
    }

    /**
     * Set CTRL2's ECRWRE bit.
     *
     * Error-correction Configuration Register Write Enable
     */
    inline void set_CTRL2_ECRWRE() volatile
    {
        CTRL2 |= 1u << 29u;
    }

    /**
     * Clear CTRL2's ECRWRE bit.
     *
     * Error-correction Configuration Register Write Enable
     */
    inline void clear_CTRL2_ECRWRE() volatile
    {
        CTRL2 &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL2's ECRWRE bit.
     *
     * Error-correction Configuration Register Write Enable
     */
    inline void toggle_CTRL2_ECRWRE() volatile
    {
        CTRL2 ^= 1u << 29u;
    }

    /**
     * Get CTRL2's WRMFRZ bit.
     *
     * Write-Access To Memory In Freeze Mode
     */
    inline bool get_CTRL2_WRMFRZ() volatile
    {
        return CTRL2 & (1u << 28u);
    }

    /**
     * Set CTRL2's WRMFRZ bit.
     *
     * Write-Access To Memory In Freeze Mode
     */
    inline void set_CTRL2_WRMFRZ() volatile
    {
        CTRL2 |= 1u << 28u;
    }

    /**
     * Clear CTRL2's WRMFRZ bit.
     *
     * Write-Access To Memory In Freeze Mode
     */
    inline void clear_CTRL2_WRMFRZ() volatile
    {
        CTRL2 &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL2's WRMFRZ bit.
     *
     * Write-Access To Memory In Freeze Mode
     */
    inline void toggle_CTRL2_WRMFRZ() volatile
    {
        CTRL2 ^= 1u << 28u;
    }

    /**
     * Get CTRL2's RFFN field.
     *
     * Number Of Rx FIFO Filters
     */
    inline uint8_t get_CTRL2_RFFN() volatile
    {
        return (CTRL2 >> 24u) & 0b1111u;
    }

    /**
     * Set CTRL2's RFFN field.
     *
     * Number Of Rx FIFO Filters
     */
    inline void set_CTRL2_RFFN(uint8_t value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's TASD field.
     *
     * Tx Arbitration Start Delay
     */
    inline uint8_t get_CTRL2_TASD() volatile
    {
        return (CTRL2 >> 19u) & 0b11111u;
    }

    /**
     * Set CTRL2's TASD field.
     *
     * Tx Arbitration Start Delay
     */
    inline void set_CTRL2_TASD(uint8_t value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's MRP bit.
     *
     * Mailboxes Reception Priority
     */
    inline bool get_CTRL2_MRP() volatile
    {
        return CTRL2 & (1u << 18u);
    }

    /**
     * Set CTRL2's MRP bit.
     *
     * Mailboxes Reception Priority
     */
    inline void set_CTRL2_MRP() volatile
    {
        CTRL2 |= 1u << 18u;
    }

    /**
     * Clear CTRL2's MRP bit.
     *
     * Mailboxes Reception Priority
     */
    inline void clear_CTRL2_MRP() volatile
    {
        CTRL2 &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL2's MRP bit.
     *
     * Mailboxes Reception Priority
     */
    inline void toggle_CTRL2_MRP() volatile
    {
        CTRL2 ^= 1u << 18u;
    }

    /**
     * Get CTRL2's RRS bit.
     *
     * Remote Request Storing
     */
    inline bool get_CTRL2_RRS() volatile
    {
        return CTRL2 & (1u << 17u);
    }

    /**
     * Set CTRL2's RRS bit.
     *
     * Remote Request Storing
     */
    inline void set_CTRL2_RRS() volatile
    {
        CTRL2 |= 1u << 17u;
    }

    /**
     * Clear CTRL2's RRS bit.
     *
     * Remote Request Storing
     */
    inline void clear_CTRL2_RRS() volatile
    {
        CTRL2 &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL2's RRS bit.
     *
     * Remote Request Storing
     */
    inline void toggle_CTRL2_RRS() volatile
    {
        CTRL2 ^= 1u << 17u;
    }

    /**
     * Get CTRL2's EACEN bit.
     *
     * Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
     */
    inline bool get_CTRL2_EACEN() volatile
    {
        return CTRL2 & (1u << 16u);
    }

    /**
     * Set CTRL2's EACEN bit.
     *
     * Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
     */
    inline void set_CTRL2_EACEN() volatile
    {
        CTRL2 |= 1u << 16u;
    }

    /**
     * Clear CTRL2's EACEN bit.
     *
     * Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
     */
    inline void clear_CTRL2_EACEN() volatile
    {
        CTRL2 &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL2's EACEN bit.
     *
     * Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
     */
    inline void toggle_CTRL2_EACEN() volatile
    {
        CTRL2 ^= 1u << 16u;
    }

    /**
     * Get CTRL2's TIMER_SRC bit.
     *
     * Timer Source
     */
    inline bool get_CTRL2_TIMER_SRC() volatile
    {
        return CTRL2 & (1u << 15u);
    }

    /**
     * Set CTRL2's TIMER_SRC bit.
     *
     * Timer Source
     */
    inline void set_CTRL2_TIMER_SRC() volatile
    {
        CTRL2 |= 1u << 15u;
    }

    /**
     * Clear CTRL2's TIMER_SRC bit.
     *
     * Timer Source
     */
    inline void clear_CTRL2_TIMER_SRC() volatile
    {
        CTRL2 &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL2's TIMER_SRC bit.
     *
     * Timer Source
     */
    inline void toggle_CTRL2_TIMER_SRC() volatile
    {
        CTRL2 ^= 1u << 15u;
    }

    /**
     * Get CTRL2's PREXCEN bit.
     *
     * Protocol Exception Enable
     */
    inline bool get_CTRL2_PREXCEN() volatile
    {
        return CTRL2 & (1u << 14u);
    }

    /**
     * Set CTRL2's PREXCEN bit.
     *
     * Protocol Exception Enable
     */
    inline void set_CTRL2_PREXCEN() volatile
    {
        CTRL2 |= 1u << 14u;
    }

    /**
     * Clear CTRL2's PREXCEN bit.
     *
     * Protocol Exception Enable
     */
    inline void clear_CTRL2_PREXCEN() volatile
    {
        CTRL2 &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL2's PREXCEN bit.
     *
     * Protocol Exception Enable
     */
    inline void toggle_CTRL2_PREXCEN() volatile
    {
        CTRL2 ^= 1u << 14u;
    }

    /**
     * Get CTRL2's ISOCANFDEN bit.
     *
     * ISO CAN FD Enable
     */
    inline bool get_CTRL2_ISOCANFDEN() volatile
    {
        return CTRL2 & (1u << 12u);
    }

    /**
     * Set CTRL2's ISOCANFDEN bit.
     *
     * ISO CAN FD Enable
     */
    inline void set_CTRL2_ISOCANFDEN() volatile
    {
        CTRL2 |= 1u << 12u;
    }

    /**
     * Clear CTRL2's ISOCANFDEN bit.
     *
     * ISO CAN FD Enable
     */
    inline void clear_CTRL2_ISOCANFDEN() volatile
    {
        CTRL2 &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL2's ISOCANFDEN bit.
     *
     * ISO CAN FD Enable
     */
    inline void toggle_CTRL2_ISOCANFDEN() volatile
    {
        CTRL2 ^= 1u << 12u;
    }

    /**
     * Get CTRL2's EDFLTDIS bit.
     *
     * Edge Filter Disable
     */
    inline bool get_CTRL2_EDFLTDIS() volatile
    {
        return CTRL2 & (1u << 11u);
    }

    /**
     * Set CTRL2's EDFLTDIS bit.
     *
     * Edge Filter Disable
     */
    inline void set_CTRL2_EDFLTDIS() volatile
    {
        CTRL2 |= 1u << 11u;
    }

    /**
     * Clear CTRL2's EDFLTDIS bit.
     *
     * Edge Filter Disable
     */
    inline void clear_CTRL2_EDFLTDIS() volatile
    {
        CTRL2 &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL2's EDFLTDIS bit.
     *
     * Edge Filter Disable
     */
    inline void toggle_CTRL2_EDFLTDIS() volatile
    {
        CTRL2 ^= 1u << 11u;
    }

    /**
     * Get all of CTRL2's bit fields.
     *
     * (read-write) Control 2 register
     */
    inline void get_CTRL2(bool &ERRMSK_FAST, bool &BOFFDONEMSK, bool &ECRWRE,
                          bool &WRMFRZ, uint8_t &RFFN, uint8_t &TASD,
                          bool &MRP, bool &RRS, bool &EACEN, bool &TIMER_SRC,
                          bool &PREXCEN, bool &ISOCANFDEN,
                          bool &EDFLTDIS) volatile
    {
        uint32_t curr = CTRL2;

        ERRMSK_FAST = curr & (1u << 31u);
        BOFFDONEMSK = curr & (1u << 30u);
        ECRWRE = curr & (1u << 29u);
        WRMFRZ = curr & (1u << 28u);
        RFFN = (curr >> 24u) & 0b1111u;
        TASD = (curr >> 19u) & 0b11111u;
        MRP = curr & (1u << 18u);
        RRS = curr & (1u << 17u);
        EACEN = curr & (1u << 16u);
        TIMER_SRC = curr & (1u << 15u);
        PREXCEN = curr & (1u << 14u);
        ISOCANFDEN = curr & (1u << 12u);
        EDFLTDIS = curr & (1u << 11u);
    }

    /**
     * Set all of CTRL2's bit fields.
     *
     * (read-write) Control 2 register
     */
    inline void set_CTRL2(bool ERRMSK_FAST, bool BOFFDONEMSK, bool ECRWRE,
                          bool WRMFRZ, uint8_t RFFN, uint8_t TASD, bool MRP,
                          bool RRS, bool EACEN, bool TIMER_SRC, bool PREXCEN,
                          bool ISOCANFDEN, bool EDFLTDIS) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b1u << 31u);
        curr |= (ERRMSK_FAST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (BOFFDONEMSK & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (ECRWRE & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (WRMFRZ & 0b1u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (RFFN & 0b1111u) << 24u;
        curr &= ~(0b11111u << 19u);
        curr |= (TASD & 0b11111u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (MRP & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RRS & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (EACEN & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TIMER_SRC & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (PREXCEN & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (ISOCANFDEN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (EDFLTDIS & 0b1u) << 11u;

        CTRL2 = curr;
    }

    /**
     * Get ESR2's LPTM field.
     *
     * Lowest Priority Tx Mailbox
     */
    inline uint8_t get_ESR2_LPTM() volatile
    {
        return (ESR2 >> 16u) & 0b1111111u;
    }

    /**
     * Get ESR2's VPS bit.
     *
     * Valid Priority Status
     */
    inline bool get_ESR2_VPS() volatile
    {
        return ESR2 & (1u << 14u);
    }

    /**
     * Get ESR2's IMB bit.
     *
     * Inactive Mailbox
     */
    inline bool get_ESR2_IMB() volatile
    {
        return ESR2 & (1u << 13u);
    }

    /**
     * Get all of ESR2's bit fields.
     *
     * (read-write) Error and Status 2 register
     */
    inline void get_ESR2(uint8_t &LPTM, bool &VPS, bool &IMB) volatile
    {
        uint32_t curr = ESR2;

        LPTM = (curr >> 16u) & 0b1111111u;
        VPS = curr & (1u << 14u);
        IMB = curr & (1u << 13u);
    }

    /**
     * Get CRCR's MBCRC field.
     *
     * CRC Mailbox
     */
    inline uint8_t get_CRCR_MBCRC() volatile
    {
        return (CRCR >> 16u) & 0b1111111u;
    }

    /**
     * Get CRCR's TXCRC field.
     *
     * Transmitted CRC value
     */
    inline uint16_t get_CRCR_TXCRC() volatile
    {
        return (CRCR >> 0u) & 0b111111111111111u;
    }

    /**
     * Get all of CRCR's bit fields.
     *
     * (read-write) CRC register
     */
    inline void get_CRCR(uint8_t &MBCRC, uint16_t &TXCRC) volatile
    {
        uint32_t curr = CRCR;

        MBCRC = (curr >> 16u) & 0b1111111u;
        TXCRC = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Get RXFGMASK's FGM field.
     *
     * Rx FIFO Global Mask Bits
     */
    inline uint32_t get_RXFGMASK_FGM() volatile
    {
        return (RXFGMASK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set RXFGMASK's FGM field.
     *
     * Rx FIFO Global Mask Bits
     */
    inline void set_RXFGMASK_FGM(uint32_t value) volatile
    {
        uint32_t curr = RXFGMASK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        RXFGMASK = curr;
    }

    /**
     * Get RXFIR's IDHIT field.
     *
     * Identifier Acceptance Filter Hit Indicator
     */
    inline uint16_t get_RXFIR_IDHIT() volatile
    {
        return (RXFIR >> 0u) & 0b111111111u;
    }

    /**
     * Get CBT's BTF bit.
     *
     * Bit Timing Format Enable
     */
    inline bool get_CBT_BTF() volatile
    {
        return CBT & (1u << 31u);
    }

    /**
     * Set CBT's BTF bit.
     *
     * Bit Timing Format Enable
     */
    inline void set_CBT_BTF() volatile
    {
        CBT |= 1u << 31u;
    }

    /**
     * Clear CBT's BTF bit.
     *
     * Bit Timing Format Enable
     */
    inline void clear_CBT_BTF() volatile
    {
        CBT &= ~(1u << 31u);
    }

    /**
     * Toggle CBT's BTF bit.
     *
     * Bit Timing Format Enable
     */
    inline void toggle_CBT_BTF() volatile
    {
        CBT ^= 1u << 31u;
    }

    /**
     * Get CBT's EPRESDIV field.
     *
     * Extended Prescaler Division Factor
     */
    inline uint16_t get_CBT_EPRESDIV() volatile
    {
        return (CBT >> 21u) & 0b1111111111u;
    }

    /**
     * Set CBT's EPRESDIV field.
     *
     * Extended Prescaler Division Factor
     */
    inline void set_CBT_EPRESDIV(uint16_t value) volatile
    {
        uint32_t curr = CBT;

        curr &= ~(0b1111111111u << 21u);
        curr |= (value & 0b1111111111u) << 21u;

        CBT = curr;
    }

    /**
     * Get CBT's ERJW field.
     *
     * Extended Resync Jump Width
     */
    inline uint8_t get_CBT_ERJW() volatile
    {
        return (CBT >> 16u) & 0b11111u;
    }

    /**
     * Set CBT's ERJW field.
     *
     * Extended Resync Jump Width
     */
    inline void set_CBT_ERJW(uint8_t value) volatile
    {
        uint32_t curr = CBT;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        CBT = curr;
    }

    /**
     * Get CBT's EPROPSEG field.
     *
     * Extended Propagation Segment
     */
    inline uint8_t get_CBT_EPROPSEG() volatile
    {
        return (CBT >> 10u) & 0b111111u;
    }

    /**
     * Set CBT's EPROPSEG field.
     *
     * Extended Propagation Segment
     */
    inline void set_CBT_EPROPSEG(uint8_t value) volatile
    {
        uint32_t curr = CBT;

        curr &= ~(0b111111u << 10u);
        curr |= (value & 0b111111u) << 10u;

        CBT = curr;
    }

    /**
     * Get CBT's EPSEG1 field.
     *
     * Extended Phase Segment 1
     */
    inline uint8_t get_CBT_EPSEG1() volatile
    {
        return (CBT >> 5u) & 0b11111u;
    }

    /**
     * Set CBT's EPSEG1 field.
     *
     * Extended Phase Segment 1
     */
    inline void set_CBT_EPSEG1(uint8_t value) volatile
    {
        uint32_t curr = CBT;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        CBT = curr;
    }

    /**
     * Get CBT's EPSEG2 field.
     *
     * Extended Phase Segment 2
     */
    inline uint8_t get_CBT_EPSEG2() volatile
    {
        return (CBT >> 0u) & 0b11111u;
    }

    /**
     * Set CBT's EPSEG2 field.
     *
     * Extended Phase Segment 2
     */
    inline void set_CBT_EPSEG2(uint8_t value) volatile
    {
        uint32_t curr = CBT;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        CBT = curr;
    }

    /**
     * Get all of CBT's bit fields.
     *
     * (read-write) CAN Bit Timing register
     */
    inline void get_CBT(bool &BTF, uint16_t &EPRESDIV, uint8_t &ERJW,
                        uint8_t &EPROPSEG, uint8_t &EPSEG1,
                        uint8_t &EPSEG2) volatile
    {
        uint32_t curr = CBT;

        BTF = curr & (1u << 31u);
        EPRESDIV = (curr >> 21u) & 0b1111111111u;
        ERJW = (curr >> 16u) & 0b11111u;
        EPROPSEG = (curr >> 10u) & 0b111111u;
        EPSEG1 = (curr >> 5u) & 0b11111u;
        EPSEG2 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of CBT's bit fields.
     *
     * (read-write) CAN Bit Timing register
     */
    inline void set_CBT(bool BTF, uint16_t EPRESDIV, uint8_t ERJW,
                        uint8_t EPROPSEG, uint8_t EPSEG1,
                        uint8_t EPSEG2) volatile
    {
        uint32_t curr = CBT;

        curr &= ~(0b1u << 31u);
        curr |= (BTF & 0b1u) << 31u;
        curr &= ~(0b1111111111u << 21u);
        curr |= (EPRESDIV & 0b1111111111u) << 21u;
        curr &= ~(0b11111u << 16u);
        curr |= (ERJW & 0b11111u) << 16u;
        curr &= ~(0b111111u << 10u);
        curr |= (EPROPSEG & 0b111111u) << 10u;
        curr &= ~(0b11111u << 5u);
        curr |= (EPSEG1 & 0b11111u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (EPSEG2 & 0b11111u) << 0u;

        CBT = curr;
    }

    /**
     * Get CS0's EDL bit.
     *
     * Extended Data Length. This bit distinguishes between CAN format and CAN
     * FD format frames. The EDL bit must not be set for Message Buffers
     * configured to RANSWER with code field 0b1010.
     */
    inline bool get_CS0_EDL() volatile
    {
        return CS0 & (1u << 31u);
    }

    /**
     * Set CS0's EDL bit.
     *
     * Extended Data Length. This bit distinguishes between CAN format and CAN
     * FD format frames. The EDL bit must not be set for Message Buffers
     * configured to RANSWER with code field 0b1010.
     */
    inline void set_CS0_EDL() volatile
    {
        CS0 |= 1u << 31u;
    }

    /**
     * Clear CS0's EDL bit.
     *
     * Extended Data Length. This bit distinguishes between CAN format and CAN
     * FD format frames. The EDL bit must not be set for Message Buffers
     * configured to RANSWER with code field 0b1010.
     */
    inline void clear_CS0_EDL() volatile
    {
        CS0 &= ~(1u << 31u);
    }

    /**
     * Toggle CS0's EDL bit.
     *
     * Extended Data Length. This bit distinguishes between CAN format and CAN
     * FD format frames. The EDL bit must not be set for Message Buffers
     * configured to RANSWER with code field 0b1010.
     */
    inline void toggle_CS0_EDL() volatile
    {
        CS0 ^= 1u << 31u;
    }

    /**
     * Get CS0's BRS bit.
     *
     * Bit Rate Switch. This bit defines whether the bit rate is switched
     * inside a CAN FD format frame.
     */
    inline bool get_CS0_BRS() volatile
    {
        return CS0 & (1u << 30u);
    }

    /**
     * Set CS0's BRS bit.
     *
     * Bit Rate Switch. This bit defines whether the bit rate is switched
     * inside a CAN FD format frame.
     */
    inline void set_CS0_BRS() volatile
    {
        CS0 |= 1u << 30u;
    }

    /**
     * Clear CS0's BRS bit.
     *
     * Bit Rate Switch. This bit defines whether the bit rate is switched
     * inside a CAN FD format frame.
     */
    inline void clear_CS0_BRS() volatile
    {
        CS0 &= ~(1u << 30u);
    }

    /**
     * Toggle CS0's BRS bit.
     *
     * Bit Rate Switch. This bit defines whether the bit rate is switched
     * inside a CAN FD format frame.
     */
    inline void toggle_CS0_BRS() volatile
    {
        CS0 ^= 1u << 30u;
    }

    /**
     * Get CS0's ESI bit.
     *
     * Error State Indicator. This bit indicates if the transmitting node is
     * error active or error passive.
     */
    inline bool get_CS0_ESI() volatile
    {
        return CS0 & (1u << 29u);
    }

    /**
     * Set CS0's ESI bit.
     *
     * Error State Indicator. This bit indicates if the transmitting node is
     * error active or error passive.
     */
    inline void set_CS0_ESI() volatile
    {
        CS0 |= 1u << 29u;
    }

    /**
     * Clear CS0's ESI bit.
     *
     * Error State Indicator. This bit indicates if the transmitting node is
     * error active or error passive.
     */
    inline void clear_CS0_ESI() volatile
    {
        CS0 &= ~(1u << 29u);
    }

    /**
     * Toggle CS0's ESI bit.
     *
     * Error State Indicator. This bit indicates if the transmitting node is
     * error active or error passive.
     */
    inline void toggle_CS0_ESI() volatile
    {
        CS0 ^= 1u << 29u;
    }

    /**
     * Get CS0's CODE field.
     *
     * Message Buffer Code. This 4-bit field can be accessed (read or write) by
     * the CPU and by the FlexCAN module itself, as part of the message buffer
     * matching and arbitration process.
     */
    inline uint8_t get_CS0_CODE() volatile
    {
        return (CS0 >> 24u) & 0b1111u;
    }

    /**
     * Set CS0's CODE field.
     *
     * Message Buffer Code. This 4-bit field can be accessed (read or write) by
     * the CPU and by the FlexCAN module itself, as part of the message buffer
     * matching and arbitration process.
     */
    inline void set_CS0_CODE(uint8_t value) volatile
    {
        uint32_t curr = CS0;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        CS0 = curr;
    }

    /**
     * Get CS0's SRR bit.
     *
     * Substitute Remote Request. Contains a fixed recessive bit.
     */
    inline bool get_CS0_SRR() volatile
    {
        return CS0 & (1u << 22u);
    }

    /**
     * Set CS0's SRR bit.
     *
     * Substitute Remote Request. Contains a fixed recessive bit.
     */
    inline void set_CS0_SRR() volatile
    {
        CS0 |= 1u << 22u;
    }

    /**
     * Clear CS0's SRR bit.
     *
     * Substitute Remote Request. Contains a fixed recessive bit.
     */
    inline void clear_CS0_SRR() volatile
    {
        CS0 &= ~(1u << 22u);
    }

    /**
     * Toggle CS0's SRR bit.
     *
     * Substitute Remote Request. Contains a fixed recessive bit.
     */
    inline void toggle_CS0_SRR() volatile
    {
        CS0 ^= 1u << 22u;
    }

    /**
     * Get CS0's IDE bit.
     *
     * ID Extended. One/zero for extended/standard format frame.
     */
    inline bool get_CS0_IDE() volatile
    {
        return CS0 & (1u << 21u);
    }

    /**
     * Set CS0's IDE bit.
     *
     * ID Extended. One/zero for extended/standard format frame.
     */
    inline void set_CS0_IDE() volatile
    {
        CS0 |= 1u << 21u;
    }

    /**
     * Clear CS0's IDE bit.
     *
     * ID Extended. One/zero for extended/standard format frame.
     */
    inline void clear_CS0_IDE() volatile
    {
        CS0 &= ~(1u << 21u);
    }

    /**
     * Toggle CS0's IDE bit.
     *
     * ID Extended. One/zero for extended/standard format frame.
     */
    inline void toggle_CS0_IDE() volatile
    {
        CS0 ^= 1u << 21u;
    }

    /**
     * Get CS0's RTR bit.
     *
     * Remote Transmission Request. One/zero for remote/data frame.
     */
    inline bool get_CS0_RTR() volatile
    {
        return CS0 & (1u << 20u);
    }

    /**
     * Set CS0's RTR bit.
     *
     * Remote Transmission Request. One/zero for remote/data frame.
     */
    inline void set_CS0_RTR() volatile
    {
        CS0 |= 1u << 20u;
    }

    /**
     * Clear CS0's RTR bit.
     *
     * Remote Transmission Request. One/zero for remote/data frame.
     */
    inline void clear_CS0_RTR() volatile
    {
        CS0 &= ~(1u << 20u);
    }

    /**
     * Toggle CS0's RTR bit.
     *
     * Remote Transmission Request. One/zero for remote/data frame.
     */
    inline void toggle_CS0_RTR() volatile
    {
        CS0 ^= 1u << 20u;
    }

    /**
     * Get CS0's DLC field.
     *
     * Length of the data to be stored/transmitted.
     */
    inline uint8_t get_CS0_DLC() volatile
    {
        return (CS0 >> 16u) & 0b1111u;
    }

    /**
     * Set CS0's DLC field.
     *
     * Length of the data to be stored/transmitted.
     */
    inline void set_CS0_DLC(uint8_t value) volatile
    {
        uint32_t curr = CS0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CS0 = curr;
    }

    /**
     * Get CS0's TIME_STAMP field.
     *
     * Free-Running Counter Time stamp. This 16-bit field is a copy of the
     * Free-Running Timer, captured for Tx and Rx frames at the time when the
     * beginning of the Identifier field appears on the CAN bus.
     */
    inline uint16_t get_CS0_TIME_STAMP() volatile
    {
        return (CS0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CS0's TIME_STAMP field.
     *
     * Free-Running Counter Time stamp. This 16-bit field is a copy of the
     * Free-Running Timer, captured for Tx and Rx frames at the time when the
     * beginning of the Identifier field appears on the CAN bus.
     */
    inline void set_CS0_TIME_STAMP(uint16_t value) volatile
    {
        uint32_t curr = CS0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CS0 = curr;
    }

    /**
     * Get all of CS0's bit fields.
     *
     * (read-write) Message Buffer 0 CS Register
     */
    inline void get_CS0(bool &EDL, bool &BRS, bool &ESI, uint8_t &CODE,
                        bool &SRR, bool &IDE, bool &RTR, uint8_t &DLC,
                        uint16_t &TIME_STAMP) volatile
    {
        uint32_t curr = CS0;

        EDL = curr & (1u << 31u);
        BRS = curr & (1u << 30u);
        ESI = curr & (1u << 29u);
        CODE = (curr >> 24u) & 0b1111u;
        SRR = curr & (1u << 22u);
        IDE = curr & (1u << 21u);
        RTR = curr & (1u << 20u);
        DLC = (curr >> 16u) & 0b1111u;
        TIME_STAMP = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CS0's bit fields.
     *
     * (read-write) Message Buffer 0 CS Register
     */
    inline void set_CS0(bool EDL, bool BRS, bool ESI, uint8_t CODE, bool SRR,
                        bool IDE, bool RTR, uint8_t DLC,
                        uint16_t TIME_STAMP) volatile
    {
        uint32_t curr = CS0;

        curr &= ~(0b1u << 31u);
        curr |= (EDL & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (BRS & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (ESI & 0b1u) << 29u;
        curr &= ~(0b1111u << 24u);
        curr |= (CODE & 0b1111u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (SRR & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (IDE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (RTR & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (DLC & 0b1111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (TIME_STAMP & 0b1111111111111111u) << 0u;

        CS0 = curr;
    }

    /**
     * Get RXIMR's MI field.
     *
     * Individual Mask Bits
     */
    inline uint32_t get_RXIMR_MI(std::size_t index) volatile
    {
        return (RXIMR[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set RXIMR's MI field.
     *
     * Individual Mask Bits
     */
    inline void set_RXIMR_MI(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = RXIMR[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        RXIMR[index] = curr;
    }

    /**
     * Get MECR's ECRWRDIS bit.
     *
     * Error Configuration Register Write Disable
     */
    inline bool get_MECR_ECRWRDIS() volatile
    {
        return MECR & (1u << 31u);
    }

    /**
     * Set MECR's ECRWRDIS bit.
     *
     * Error Configuration Register Write Disable
     */
    inline void set_MECR_ECRWRDIS() volatile
    {
        MECR |= 1u << 31u;
    }

    /**
     * Clear MECR's ECRWRDIS bit.
     *
     * Error Configuration Register Write Disable
     */
    inline void clear_MECR_ECRWRDIS() volatile
    {
        MECR &= ~(1u << 31u);
    }

    /**
     * Toggle MECR's ECRWRDIS bit.
     *
     * Error Configuration Register Write Disable
     */
    inline void toggle_MECR_ECRWRDIS() volatile
    {
        MECR ^= 1u << 31u;
    }

    /**
     * Get MECR's HANCEI_MSK bit.
     *
     * Host Access With Non-Correctable Errors Interrupt Mask
     */
    inline bool get_MECR_HANCEI_MSK() volatile
    {
        return MECR & (1u << 19u);
    }

    /**
     * Set MECR's HANCEI_MSK bit.
     *
     * Host Access With Non-Correctable Errors Interrupt Mask
     */
    inline void set_MECR_HANCEI_MSK() volatile
    {
        MECR |= 1u << 19u;
    }

    /**
     * Clear MECR's HANCEI_MSK bit.
     *
     * Host Access With Non-Correctable Errors Interrupt Mask
     */
    inline void clear_MECR_HANCEI_MSK() volatile
    {
        MECR &= ~(1u << 19u);
    }

    /**
     * Toggle MECR's HANCEI_MSK bit.
     *
     * Host Access With Non-Correctable Errors Interrupt Mask
     */
    inline void toggle_MECR_HANCEI_MSK() volatile
    {
        MECR ^= 1u << 19u;
    }

    /**
     * Get MECR's FANCEI_MSK bit.
     *
     * FlexCAN Access With Non-Correctable Errors Interrupt Mask
     */
    inline bool get_MECR_FANCEI_MSK() volatile
    {
        return MECR & (1u << 18u);
    }

    /**
     * Set MECR's FANCEI_MSK bit.
     *
     * FlexCAN Access With Non-Correctable Errors Interrupt Mask
     */
    inline void set_MECR_FANCEI_MSK() volatile
    {
        MECR |= 1u << 18u;
    }

    /**
     * Clear MECR's FANCEI_MSK bit.
     *
     * FlexCAN Access With Non-Correctable Errors Interrupt Mask
     */
    inline void clear_MECR_FANCEI_MSK() volatile
    {
        MECR &= ~(1u << 18u);
    }

    /**
     * Toggle MECR's FANCEI_MSK bit.
     *
     * FlexCAN Access With Non-Correctable Errors Interrupt Mask
     */
    inline void toggle_MECR_FANCEI_MSK() volatile
    {
        MECR ^= 1u << 18u;
    }

    /**
     * Get MECR's CEI_MSK bit.
     *
     * Correctable Errors Interrupt Mask
     */
    inline bool get_MECR_CEI_MSK() volatile
    {
        return MECR & (1u << 16u);
    }

    /**
     * Set MECR's CEI_MSK bit.
     *
     * Correctable Errors Interrupt Mask
     */
    inline void set_MECR_CEI_MSK() volatile
    {
        MECR |= 1u << 16u;
    }

    /**
     * Clear MECR's CEI_MSK bit.
     *
     * Correctable Errors Interrupt Mask
     */
    inline void clear_MECR_CEI_MSK() volatile
    {
        MECR &= ~(1u << 16u);
    }

    /**
     * Toggle MECR's CEI_MSK bit.
     *
     * Correctable Errors Interrupt Mask
     */
    inline void toggle_MECR_CEI_MSK() volatile
    {
        MECR ^= 1u << 16u;
    }

    /**
     * Get MECR's HAERRIE bit.
     *
     * Host Access Error Injection Enable
     */
    inline bool get_MECR_HAERRIE() volatile
    {
        return MECR & (1u << 15u);
    }

    /**
     * Set MECR's HAERRIE bit.
     *
     * Host Access Error Injection Enable
     */
    inline void set_MECR_HAERRIE() volatile
    {
        MECR |= 1u << 15u;
    }

    /**
     * Clear MECR's HAERRIE bit.
     *
     * Host Access Error Injection Enable
     */
    inline void clear_MECR_HAERRIE() volatile
    {
        MECR &= ~(1u << 15u);
    }

    /**
     * Toggle MECR's HAERRIE bit.
     *
     * Host Access Error Injection Enable
     */
    inline void toggle_MECR_HAERRIE() volatile
    {
        MECR ^= 1u << 15u;
    }

    /**
     * Get MECR's FAERRIE bit.
     *
     * FlexCAN Access Error Injection Enable
     */
    inline bool get_MECR_FAERRIE() volatile
    {
        return MECR & (1u << 14u);
    }

    /**
     * Set MECR's FAERRIE bit.
     *
     * FlexCAN Access Error Injection Enable
     */
    inline void set_MECR_FAERRIE() volatile
    {
        MECR |= 1u << 14u;
    }

    /**
     * Clear MECR's FAERRIE bit.
     *
     * FlexCAN Access Error Injection Enable
     */
    inline void clear_MECR_FAERRIE() volatile
    {
        MECR &= ~(1u << 14u);
    }

    /**
     * Toggle MECR's FAERRIE bit.
     *
     * FlexCAN Access Error Injection Enable
     */
    inline void toggle_MECR_FAERRIE() volatile
    {
        MECR ^= 1u << 14u;
    }

    /**
     * Get MECR's EXTERRIE bit.
     *
     * Extended Error Injection Enable
     */
    inline bool get_MECR_EXTERRIE() volatile
    {
        return MECR & (1u << 13u);
    }

    /**
     * Set MECR's EXTERRIE bit.
     *
     * Extended Error Injection Enable
     */
    inline void set_MECR_EXTERRIE() volatile
    {
        MECR |= 1u << 13u;
    }

    /**
     * Clear MECR's EXTERRIE bit.
     *
     * Extended Error Injection Enable
     */
    inline void clear_MECR_EXTERRIE() volatile
    {
        MECR &= ~(1u << 13u);
    }

    /**
     * Toggle MECR's EXTERRIE bit.
     *
     * Extended Error Injection Enable
     */
    inline void toggle_MECR_EXTERRIE() volatile
    {
        MECR ^= 1u << 13u;
    }

    /**
     * Get MECR's RERRDIS bit.
     *
     * Error Report Disable
     */
    inline bool get_MECR_RERRDIS() volatile
    {
        return MECR & (1u << 9u);
    }

    /**
     * Set MECR's RERRDIS bit.
     *
     * Error Report Disable
     */
    inline void set_MECR_RERRDIS() volatile
    {
        MECR |= 1u << 9u;
    }

    /**
     * Clear MECR's RERRDIS bit.
     *
     * Error Report Disable
     */
    inline void clear_MECR_RERRDIS() volatile
    {
        MECR &= ~(1u << 9u);
    }

    /**
     * Toggle MECR's RERRDIS bit.
     *
     * Error Report Disable
     */
    inline void toggle_MECR_RERRDIS() volatile
    {
        MECR ^= 1u << 9u;
    }

    /**
     * Get MECR's ECCDIS bit.
     *
     * Error Correction Disable
     */
    inline bool get_MECR_ECCDIS() volatile
    {
        return MECR & (1u << 8u);
    }

    /**
     * Set MECR's ECCDIS bit.
     *
     * Error Correction Disable
     */
    inline void set_MECR_ECCDIS() volatile
    {
        MECR |= 1u << 8u;
    }

    /**
     * Clear MECR's ECCDIS bit.
     *
     * Error Correction Disable
     */
    inline void clear_MECR_ECCDIS() volatile
    {
        MECR &= ~(1u << 8u);
    }

    /**
     * Toggle MECR's ECCDIS bit.
     *
     * Error Correction Disable
     */
    inline void toggle_MECR_ECCDIS() volatile
    {
        MECR ^= 1u << 8u;
    }

    /**
     * Get MECR's NCEFAFRZ bit.
     *
     * Non-Correctable Errors In FlexCAN Access Put Device In Freeze Mode
     */
    inline bool get_MECR_NCEFAFRZ() volatile
    {
        return MECR & (1u << 7u);
    }

    /**
     * Set MECR's NCEFAFRZ bit.
     *
     * Non-Correctable Errors In FlexCAN Access Put Device In Freeze Mode
     */
    inline void set_MECR_NCEFAFRZ() volatile
    {
        MECR |= 1u << 7u;
    }

    /**
     * Clear MECR's NCEFAFRZ bit.
     *
     * Non-Correctable Errors In FlexCAN Access Put Device In Freeze Mode
     */
    inline void clear_MECR_NCEFAFRZ() volatile
    {
        MECR &= ~(1u << 7u);
    }

    /**
     * Toggle MECR's NCEFAFRZ bit.
     *
     * Non-Correctable Errors In FlexCAN Access Put Device In Freeze Mode
     */
    inline void toggle_MECR_NCEFAFRZ() volatile
    {
        MECR ^= 1u << 7u;
    }

    /**
     * Get all of MECR's bit fields.
     *
     * (read-write) Memory Error Control register
     */
    inline void get_MECR(bool &ECRWRDIS, bool &HANCEI_MSK, bool &FANCEI_MSK,
                         bool &CEI_MSK, bool &HAERRIE, bool &FAERRIE,
                         bool &EXTERRIE, bool &RERRDIS, bool &ECCDIS,
                         bool &NCEFAFRZ) volatile
    {
        uint32_t curr = MECR;

        ECRWRDIS = curr & (1u << 31u);
        HANCEI_MSK = curr & (1u << 19u);
        FANCEI_MSK = curr & (1u << 18u);
        CEI_MSK = curr & (1u << 16u);
        HAERRIE = curr & (1u << 15u);
        FAERRIE = curr & (1u << 14u);
        EXTERRIE = curr & (1u << 13u);
        RERRDIS = curr & (1u << 9u);
        ECCDIS = curr & (1u << 8u);
        NCEFAFRZ = curr & (1u << 7u);
    }

    /**
     * Set all of MECR's bit fields.
     *
     * (read-write) Memory Error Control register
     */
    inline void set_MECR(bool ECRWRDIS, bool HANCEI_MSK, bool FANCEI_MSK,
                         bool CEI_MSK, bool HAERRIE, bool FAERRIE,
                         bool EXTERRIE, bool RERRDIS, bool ECCDIS,
                         bool NCEFAFRZ) volatile
    {
        uint32_t curr = MECR;

        curr &= ~(0b1u << 31u);
        curr |= (ECRWRDIS & 0b1u) << 31u;
        curr &= ~(0b1u << 19u);
        curr |= (HANCEI_MSK & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (FANCEI_MSK & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (CEI_MSK & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (HAERRIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (FAERRIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (EXTERRIE & 0b1u) << 13u;
        curr &= ~(0b1u << 9u);
        curr |= (RERRDIS & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (ECCDIS & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (NCEFAFRZ & 0b1u) << 7u;

        MECR = curr;
    }

    /**
     * Get ERRIAR's INJADDR_H field.
     *
     * Error Injection Address High
     */
    inline uint16_t get_ERRIAR_INJADDR_H() volatile
    {
        return (ERRIAR >> 2u) & 0b111111111111u;
    }

    /**
     * Set ERRIAR's INJADDR_H field.
     *
     * Error Injection Address High
     */
    inline void set_ERRIAR_INJADDR_H(uint16_t value) volatile
    {
        uint32_t curr = ERRIAR;

        curr &= ~(0b111111111111u << 2u);
        curr |= (value & 0b111111111111u) << 2u;

        ERRIAR = curr;
    }

    /**
     * Get ERRIAR's INJADDR_L field.
     *
     * Error Injection Address Low
     */
    inline uint8_t get_ERRIAR_INJADDR_L() volatile
    {
        return (ERRIAR >> 0u) & 0b11u;
    }

    /**
     * Get all of ERRIAR's bit fields.
     *
     * (read-write) Error Injection Address register
     */
    inline void get_ERRIAR(uint16_t &INJADDR_H, uint8_t &INJADDR_L) volatile
    {
        uint32_t curr = ERRIAR;

        INJADDR_H = (curr >> 2u) & 0b111111111111u;
        INJADDR_L = (curr >> 0u) & 0b11u;
    }

    /**
     * Get ERRIDPR's DFLIP field.
     *
     * Data flip pattern
     */
    inline uint32_t get_ERRIDPR_DFLIP() volatile
    {
        return (ERRIDPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set ERRIDPR's DFLIP field.
     *
     * Data flip pattern
     */
    inline void set_ERRIDPR_DFLIP(uint32_t value) volatile
    {
        uint32_t curr = ERRIDPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ERRIDPR = curr;
    }

    /**
     * Get ERRIPPR's PFLIP3 field.
     *
     * Parity Flip Pattern For Byte 3 (most significant)
     */
    inline uint8_t get_ERRIPPR_PFLIP3() volatile
    {
        return (ERRIPPR >> 24u) & 0b11111u;
    }

    /**
     * Set ERRIPPR's PFLIP3 field.
     *
     * Parity Flip Pattern For Byte 3 (most significant)
     */
    inline void set_ERRIPPR_PFLIP3(uint8_t value) volatile
    {
        uint32_t curr = ERRIPPR;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        ERRIPPR = curr;
    }

    /**
     * Get ERRIPPR's PFLIP2 field.
     *
     * Parity Flip Pattern For Byte 2
     */
    inline uint8_t get_ERRIPPR_PFLIP2() volatile
    {
        return (ERRIPPR >> 16u) & 0b11111u;
    }

    /**
     * Set ERRIPPR's PFLIP2 field.
     *
     * Parity Flip Pattern For Byte 2
     */
    inline void set_ERRIPPR_PFLIP2(uint8_t value) volatile
    {
        uint32_t curr = ERRIPPR;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        ERRIPPR = curr;
    }

    /**
     * Get ERRIPPR's PFLIP1 field.
     *
     * Parity Flip Pattern For Byte 1
     */
    inline uint8_t get_ERRIPPR_PFLIP1() volatile
    {
        return (ERRIPPR >> 8u) & 0b11111u;
    }

    /**
     * Set ERRIPPR's PFLIP1 field.
     *
     * Parity Flip Pattern For Byte 1
     */
    inline void set_ERRIPPR_PFLIP1(uint8_t value) volatile
    {
        uint32_t curr = ERRIPPR;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        ERRIPPR = curr;
    }

    /**
     * Get ERRIPPR's PFLIP0 field.
     *
     * Parity Flip Pattern For Byte 0 (Least Significant)
     */
    inline uint8_t get_ERRIPPR_PFLIP0() volatile
    {
        return (ERRIPPR >> 0u) & 0b11111u;
    }

    /**
     * Set ERRIPPR's PFLIP0 field.
     *
     * Parity Flip Pattern For Byte 0 (Least Significant)
     */
    inline void set_ERRIPPR_PFLIP0(uint8_t value) volatile
    {
        uint32_t curr = ERRIPPR;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        ERRIPPR = curr;
    }

    /**
     * Get all of ERRIPPR's bit fields.
     *
     * (read-write) Error Injection Parity Pattern register
     */
    inline void get_ERRIPPR(uint8_t &PFLIP3, uint8_t &PFLIP2, uint8_t &PFLIP1,
                            uint8_t &PFLIP0) volatile
    {
        uint32_t curr = ERRIPPR;

        PFLIP3 = (curr >> 24u) & 0b11111u;
        PFLIP2 = (curr >> 16u) & 0b11111u;
        PFLIP1 = (curr >> 8u) & 0b11111u;
        PFLIP0 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of ERRIPPR's bit fields.
     *
     * (read-write) Error Injection Parity Pattern register
     */
    inline void set_ERRIPPR(uint8_t PFLIP3, uint8_t PFLIP2, uint8_t PFLIP1,
                            uint8_t PFLIP0) volatile
    {
        uint32_t curr = ERRIPPR;

        curr &= ~(0b11111u << 24u);
        curr |= (PFLIP3 & 0b11111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (PFLIP2 & 0b11111u) << 16u;
        curr &= ~(0b11111u << 8u);
        curr |= (PFLIP1 & 0b11111u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (PFLIP0 & 0b11111u) << 0u;

        ERRIPPR = curr;
    }

    /**
     * Get RERRAR's NCE bit.
     *
     * Non-Correctable Error
     */
    inline bool get_RERRAR_NCE() volatile
    {
        return RERRAR & (1u << 24u);
    }

    /**
     * Get RERRAR's SAID field.
     *
     * SAID
     */
    inline uint8_t get_RERRAR_SAID() volatile
    {
        return (RERRAR >> 16u) & 0b111u;
    }

    /**
     * Get RERRAR's ERRADDR field.
     *
     * Address Where Error Detected
     */
    inline uint16_t get_RERRAR_ERRADDR() volatile
    {
        return (RERRAR >> 0u) & 0b11111111111111u;
    }

    /**
     * Get all of RERRAR's bit fields.
     *
     * (read-write) Error Report Address register
     */
    inline void get_RERRAR(bool &NCE, uint8_t &SAID,
                           uint16_t &ERRADDR) volatile
    {
        uint32_t curr = RERRAR;

        NCE = curr & (1u << 24u);
        SAID = (curr >> 16u) & 0b111u;
        ERRADDR = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Get RERRDR's RDATA field.
     *
     * Raw data word read from memory with error
     */
    inline uint32_t get_RERRDR_RDATA() volatile
    {
        return (RERRDR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get RERRSYNR's BE3 bit.
     *
     * Byte Enabled For Byte 3 (most significant)
     */
    inline bool get_RERRSYNR_BE3() volatile
    {
        return RERRSYNR & (1u << 31u);
    }

    /**
     * Get RERRSYNR's SYND3 field.
     *
     * Error Syndrome For Byte 3 (most significant)
     */
    inline uint8_t get_RERRSYNR_SYND3() volatile
    {
        return (RERRSYNR >> 24u) & 0b11111u;
    }

    /**
     * Get RERRSYNR's BE2 bit.
     *
     * Byte Enabled For Byte 2
     */
    inline bool get_RERRSYNR_BE2() volatile
    {
        return RERRSYNR & (1u << 23u);
    }

    /**
     * Get RERRSYNR's SYND2 field.
     *
     * Error Syndrome For Byte 2
     */
    inline uint8_t get_RERRSYNR_SYND2() volatile
    {
        return (RERRSYNR >> 16u) & 0b11111u;
    }

    /**
     * Get RERRSYNR's BE1 bit.
     *
     * Byte Enabled For Byte 1
     */
    inline bool get_RERRSYNR_BE1() volatile
    {
        return RERRSYNR & (1u << 15u);
    }

    /**
     * Get RERRSYNR's SYND1 field.
     *
     * Error Syndrome for Byte 1
     */
    inline uint8_t get_RERRSYNR_SYND1() volatile
    {
        return (RERRSYNR >> 8u) & 0b11111u;
    }

    /**
     * Get RERRSYNR's BE0 bit.
     *
     * Byte Enabled For Byte 0 (least significant)
     */
    inline bool get_RERRSYNR_BE0() volatile
    {
        return RERRSYNR & (1u << 7u);
    }

    /**
     * Get RERRSYNR's SYND0 field.
     *
     * Error Syndrome For Byte 0 (least significant)
     */
    inline uint8_t get_RERRSYNR_SYND0() volatile
    {
        return (RERRSYNR >> 0u) & 0b11111u;
    }

    /**
     * Get all of RERRSYNR's bit fields.
     *
     * (read-write) Error Report Syndrome register
     */
    inline void get_RERRSYNR(bool &BE3, uint8_t &SYND3, bool &BE2,
                             uint8_t &SYND2, bool &BE1, uint8_t &SYND1,
                             bool &BE0, uint8_t &SYND0) volatile
    {
        uint32_t curr = RERRSYNR;

        BE3 = curr & (1u << 31u);
        SYND3 = (curr >> 24u) & 0b11111u;
        BE2 = curr & (1u << 23u);
        SYND2 = (curr >> 16u) & 0b11111u;
        BE1 = curr & (1u << 15u);
        SYND1 = (curr >> 8u) & 0b11111u;
        BE0 = curr & (1u << 7u);
        SYND0 = (curr >> 0u) & 0b11111u;
    }

    /**
     * Get ERRSR's HANCEIF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Flag
     */
    inline bool get_ERRSR_HANCEIF() volatile
    {
        return ERRSR & (1u << 19u);
    }

    /**
     * Set ERRSR's HANCEIF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Flag
     */
    inline void set_ERRSR_HANCEIF() volatile
    {
        ERRSR |= 1u << 19u;
    }

    /**
     * Clear ERRSR's HANCEIF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Flag
     */
    inline void clear_ERRSR_HANCEIF() volatile
    {
        ERRSR &= ~(1u << 19u);
    }

    /**
     * Toggle ERRSR's HANCEIF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Flag
     */
    inline void toggle_ERRSR_HANCEIF() volatile
    {
        ERRSR ^= 1u << 19u;
    }

    /**
     * Get ERRSR's FANCEIF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Flag
     */
    inline bool get_ERRSR_FANCEIF() volatile
    {
        return ERRSR & (1u << 18u);
    }

    /**
     * Set ERRSR's FANCEIF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Flag
     */
    inline void set_ERRSR_FANCEIF() volatile
    {
        ERRSR |= 1u << 18u;
    }

    /**
     * Clear ERRSR's FANCEIF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Flag
     */
    inline void clear_ERRSR_FANCEIF() volatile
    {
        ERRSR &= ~(1u << 18u);
    }

    /**
     * Toggle ERRSR's FANCEIF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Flag
     */
    inline void toggle_ERRSR_FANCEIF() volatile
    {
        ERRSR ^= 1u << 18u;
    }

    /**
     * Get ERRSR's CEIF bit.
     *
     * Correctable Error Interrupt Flag
     */
    inline bool get_ERRSR_CEIF() volatile
    {
        return ERRSR & (1u << 16u);
    }

    /**
     * Set ERRSR's CEIF bit.
     *
     * Correctable Error Interrupt Flag
     */
    inline void set_ERRSR_CEIF() volatile
    {
        ERRSR |= 1u << 16u;
    }

    /**
     * Clear ERRSR's CEIF bit.
     *
     * Correctable Error Interrupt Flag
     */
    inline void clear_ERRSR_CEIF() volatile
    {
        ERRSR &= ~(1u << 16u);
    }

    /**
     * Toggle ERRSR's CEIF bit.
     *
     * Correctable Error Interrupt Flag
     */
    inline void toggle_ERRSR_CEIF() volatile
    {
        ERRSR ^= 1u << 16u;
    }

    /**
     * Get ERRSR's HANCEIOF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline bool get_ERRSR_HANCEIOF() volatile
    {
        return ERRSR & (1u << 3u);
    }

    /**
     * Set ERRSR's HANCEIOF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline void set_ERRSR_HANCEIOF() volatile
    {
        ERRSR |= 1u << 3u;
    }

    /**
     * Clear ERRSR's HANCEIOF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline void clear_ERRSR_HANCEIOF() volatile
    {
        ERRSR &= ~(1u << 3u);
    }

    /**
     * Toggle ERRSR's HANCEIOF bit.
     *
     * Host Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline void toggle_ERRSR_HANCEIOF() volatile
    {
        ERRSR ^= 1u << 3u;
    }

    /**
     * Get ERRSR's FANCEIOF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline bool get_ERRSR_FANCEIOF() volatile
    {
        return ERRSR & (1u << 2u);
    }

    /**
     * Set ERRSR's FANCEIOF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline void set_ERRSR_FANCEIOF() volatile
    {
        ERRSR |= 1u << 2u;
    }

    /**
     * Clear ERRSR's FANCEIOF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline void clear_ERRSR_FANCEIOF() volatile
    {
        ERRSR &= ~(1u << 2u);
    }

    /**
     * Toggle ERRSR's FANCEIOF bit.
     *
     * FlexCAN Access With Non-Correctable Error Interrupt Overrun Flag
     */
    inline void toggle_ERRSR_FANCEIOF() volatile
    {
        ERRSR ^= 1u << 2u;
    }

    /**
     * Get ERRSR's CEIOF bit.
     *
     * Correctable Error Interrupt Overrun Flag
     */
    inline bool get_ERRSR_CEIOF() volatile
    {
        return ERRSR & (1u << 0u);
    }

    /**
     * Set ERRSR's CEIOF bit.
     *
     * Correctable Error Interrupt Overrun Flag
     */
    inline void set_ERRSR_CEIOF() volatile
    {
        ERRSR |= 1u << 0u;
    }

    /**
     * Clear ERRSR's CEIOF bit.
     *
     * Correctable Error Interrupt Overrun Flag
     */
    inline void clear_ERRSR_CEIOF() volatile
    {
        ERRSR &= ~(1u << 0u);
    }

    /**
     * Toggle ERRSR's CEIOF bit.
     *
     * Correctable Error Interrupt Overrun Flag
     */
    inline void toggle_ERRSR_CEIOF() volatile
    {
        ERRSR ^= 1u << 0u;
    }

    /**
     * Get all of ERRSR's bit fields.
     *
     * (read-write) Error Status register
     */
    inline void get_ERRSR(bool &HANCEIF, bool &FANCEIF, bool &CEIF,
                          bool &HANCEIOF, bool &FANCEIOF, bool &CEIOF) volatile
    {
        uint32_t curr = ERRSR;

        HANCEIF = curr & (1u << 19u);
        FANCEIF = curr & (1u << 18u);
        CEIF = curr & (1u << 16u);
        HANCEIOF = curr & (1u << 3u);
        FANCEIOF = curr & (1u << 2u);
        CEIOF = curr & (1u << 0u);
    }

    /**
     * Set all of ERRSR's bit fields.
     *
     * (read-write) Error Status register
     */
    inline void set_ERRSR(bool HANCEIF, bool FANCEIF, bool CEIF, bool HANCEIOF,
                          bool FANCEIOF, bool CEIOF) volatile
    {
        uint32_t curr = ERRSR;

        curr &= ~(0b1u << 19u);
        curr |= (HANCEIF & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (FANCEIF & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (CEIF & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (HANCEIOF & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FANCEIOF & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (CEIOF & 0b1u) << 0u;

        ERRSR = curr;
    }

    /**
     * Get FDCTRL's FDRATE bit.
     *
     * Bit Rate Switch Enable
     */
    inline bool get_FDCTRL_FDRATE() volatile
    {
        return FDCTRL & (1u << 31u);
    }

    /**
     * Set FDCTRL's FDRATE bit.
     *
     * Bit Rate Switch Enable
     */
    inline void set_FDCTRL_FDRATE() volatile
    {
        FDCTRL |= 1u << 31u;
    }

    /**
     * Clear FDCTRL's FDRATE bit.
     *
     * Bit Rate Switch Enable
     */
    inline void clear_FDCTRL_FDRATE() volatile
    {
        FDCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle FDCTRL's FDRATE bit.
     *
     * Bit Rate Switch Enable
     */
    inline void toggle_FDCTRL_FDRATE() volatile
    {
        FDCTRL ^= 1u << 31u;
    }

    /**
     * Get FDCTRL's MBDSR1 field.
     *
     * Message Buffer Data Size for Region 1
     */
    inline CAN1_FDCTRL_MBDSR1 get_FDCTRL_MBDSR1() volatile
    {
        return CAN1_FDCTRL_MBDSR1((FDCTRL >> 19u) & 0b11u);
    }

    /**
     * Set FDCTRL's MBDSR1 field.
     *
     * Message Buffer Data Size for Region 1
     */
    inline void set_FDCTRL_MBDSR1(CAN1_FDCTRL_MBDSR1 value) volatile
    {
        uint32_t curr = FDCTRL;

        curr &= ~(0b11u << 19u);
        curr |= (std::to_underlying(value) & 0b11u) << 19u;

        FDCTRL = curr;
    }

    /**
     * Get FDCTRL's MBDSR0 field.
     *
     * Message Buffer Data Size for Region 0
     */
    inline CAN1_FDCTRL_MBDSR0 get_FDCTRL_MBDSR0() volatile
    {
        return CAN1_FDCTRL_MBDSR0((FDCTRL >> 16u) & 0b11u);
    }

    /**
     * Set FDCTRL's MBDSR0 field.
     *
     * Message Buffer Data Size for Region 0
     */
    inline void set_FDCTRL_MBDSR0(CAN1_FDCTRL_MBDSR0 value) volatile
    {
        uint32_t curr = FDCTRL;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        FDCTRL = curr;
    }

    /**
     * Get FDCTRL's TDCEN bit.
     *
     * Transceiver Delay Compensation Enable
     */
    inline bool get_FDCTRL_TDCEN() volatile
    {
        return FDCTRL & (1u << 15u);
    }

    /**
     * Set FDCTRL's TDCEN bit.
     *
     * Transceiver Delay Compensation Enable
     */
    inline void set_FDCTRL_TDCEN() volatile
    {
        FDCTRL |= 1u << 15u;
    }

    /**
     * Clear FDCTRL's TDCEN bit.
     *
     * Transceiver Delay Compensation Enable
     */
    inline void clear_FDCTRL_TDCEN() volatile
    {
        FDCTRL &= ~(1u << 15u);
    }

    /**
     * Toggle FDCTRL's TDCEN bit.
     *
     * Transceiver Delay Compensation Enable
     */
    inline void toggle_FDCTRL_TDCEN() volatile
    {
        FDCTRL ^= 1u << 15u;
    }

    /**
     * Get FDCTRL's TDCFAIL bit.
     *
     * Transceiver Delay Compensation Fail
     */
    inline bool get_FDCTRL_TDCFAIL() volatile
    {
        return FDCTRL & (1u << 14u);
    }

    /**
     * Set FDCTRL's TDCFAIL bit.
     *
     * Transceiver Delay Compensation Fail
     */
    inline void set_FDCTRL_TDCFAIL() volatile
    {
        FDCTRL |= 1u << 14u;
    }

    /**
     * Clear FDCTRL's TDCFAIL bit.
     *
     * Transceiver Delay Compensation Fail
     */
    inline void clear_FDCTRL_TDCFAIL() volatile
    {
        FDCTRL &= ~(1u << 14u);
    }

    /**
     * Toggle FDCTRL's TDCFAIL bit.
     *
     * Transceiver Delay Compensation Fail
     */
    inline void toggle_FDCTRL_TDCFAIL() volatile
    {
        FDCTRL ^= 1u << 14u;
    }

    /**
     * Get FDCTRL's TDCOFF field.
     *
     * Transceiver Delay Compensation Offset
     */
    inline uint8_t get_FDCTRL_TDCOFF() volatile
    {
        return (FDCTRL >> 8u) & 0b11111u;
    }

    /**
     * Set FDCTRL's TDCOFF field.
     *
     * Transceiver Delay Compensation Offset
     */
    inline void set_FDCTRL_TDCOFF(uint8_t value) volatile
    {
        uint32_t curr = FDCTRL;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        FDCTRL = curr;
    }

    /**
     * Get FDCTRL's TDCVAL field.
     *
     * Transceiver Delay Compensation Value
     */
    inline uint8_t get_FDCTRL_TDCVAL() volatile
    {
        return (FDCTRL >> 0u) & 0b111111u;
    }

    /**
     * Get all of FDCTRL's bit fields.
     *
     * (read-write) CAN FD Control register
     */
    inline void get_FDCTRL(bool &FDRATE, CAN1_FDCTRL_MBDSR1 &MBDSR1,
                           CAN1_FDCTRL_MBDSR0 &MBDSR0, bool &TDCEN,
                           bool &TDCFAIL, uint8_t &TDCOFF,
                           uint8_t &TDCVAL) volatile
    {
        uint32_t curr = FDCTRL;

        FDRATE = curr & (1u << 31u);
        MBDSR1 = CAN1_FDCTRL_MBDSR1((curr >> 19u) & 0b11u);
        MBDSR0 = CAN1_FDCTRL_MBDSR0((curr >> 16u) & 0b11u);
        TDCEN = curr & (1u << 15u);
        TDCFAIL = curr & (1u << 14u);
        TDCOFF = (curr >> 8u) & 0b11111u;
        TDCVAL = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of FDCTRL's bit fields.
     *
     * (read-write) CAN FD Control register
     */
    inline void set_FDCTRL(bool FDRATE, CAN1_FDCTRL_MBDSR1 MBDSR1,
                           CAN1_FDCTRL_MBDSR0 MBDSR0, bool TDCEN, bool TDCFAIL,
                           uint8_t TDCOFF) volatile
    {
        uint32_t curr = FDCTRL;

        curr &= ~(0b1u << 31u);
        curr |= (FDRATE & 0b1u) << 31u;
        curr &= ~(0b11u << 19u);
        curr |= (std::to_underlying(MBDSR1) & 0b11u) << 19u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(MBDSR0) & 0b11u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TDCEN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TDCFAIL & 0b1u) << 14u;
        curr &= ~(0b11111u << 8u);
        curr |= (TDCOFF & 0b11111u) << 8u;

        FDCTRL = curr;
    }

    /**
     * Get FDCBT's FPRESDIV field.
     *
     * Fast Prescaler Division Factor
     */
    inline uint16_t get_FDCBT_FPRESDIV() volatile
    {
        return (FDCBT >> 20u) & 0b1111111111u;
    }

    /**
     * Set FDCBT's FPRESDIV field.
     *
     * Fast Prescaler Division Factor
     */
    inline void set_FDCBT_FPRESDIV(uint16_t value) volatile
    {
        uint32_t curr = FDCBT;

        curr &= ~(0b1111111111u << 20u);
        curr |= (value & 0b1111111111u) << 20u;

        FDCBT = curr;
    }

    /**
     * Get FDCBT's FRJW field.
     *
     * Fast Resync Jump Width
     */
    inline uint8_t get_FDCBT_FRJW() volatile
    {
        return (FDCBT >> 16u) & 0b111u;
    }

    /**
     * Set FDCBT's FRJW field.
     *
     * Fast Resync Jump Width
     */
    inline void set_FDCBT_FRJW(uint8_t value) volatile
    {
        uint32_t curr = FDCBT;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        FDCBT = curr;
    }

    /**
     * Get FDCBT's FPROPSEG field.
     *
     * Fast Propagation Segment
     */
    inline uint8_t get_FDCBT_FPROPSEG() volatile
    {
        return (FDCBT >> 10u) & 0b11111u;
    }

    /**
     * Set FDCBT's FPROPSEG field.
     *
     * Fast Propagation Segment
     */
    inline void set_FDCBT_FPROPSEG(uint8_t value) volatile
    {
        uint32_t curr = FDCBT;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        FDCBT = curr;
    }

    /**
     * Get FDCBT's FPSEG1 field.
     *
     * Fast Phase Segment 1
     */
    inline uint8_t get_FDCBT_FPSEG1() volatile
    {
        return (FDCBT >> 5u) & 0b111u;
    }

    /**
     * Set FDCBT's FPSEG1 field.
     *
     * Fast Phase Segment 1
     */
    inline void set_FDCBT_FPSEG1(uint8_t value) volatile
    {
        uint32_t curr = FDCBT;

        curr &= ~(0b111u << 5u);
        curr |= (value & 0b111u) << 5u;

        FDCBT = curr;
    }

    /**
     * Get FDCBT's FPSEG2 field.
     *
     * Fast Phase Segment 2
     */
    inline uint8_t get_FDCBT_FPSEG2() volatile
    {
        return (FDCBT >> 0u) & 0b111u;
    }

    /**
     * Set FDCBT's FPSEG2 field.
     *
     * Fast Phase Segment 2
     */
    inline void set_FDCBT_FPSEG2(uint8_t value) volatile
    {
        uint32_t curr = FDCBT;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        FDCBT = curr;
    }

    /**
     * Get all of FDCBT's bit fields.
     *
     * (read-write) CAN FD Bit Timing register
     */
    inline void get_FDCBT(uint16_t &FPRESDIV, uint8_t &FRJW, uint8_t &FPROPSEG,
                          uint8_t &FPSEG1, uint8_t &FPSEG2) volatile
    {
        uint32_t curr = FDCBT;

        FPRESDIV = (curr >> 20u) & 0b1111111111u;
        FRJW = (curr >> 16u) & 0b111u;
        FPROPSEG = (curr >> 10u) & 0b11111u;
        FPSEG1 = (curr >> 5u) & 0b111u;
        FPSEG2 = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of FDCBT's bit fields.
     *
     * (read-write) CAN FD Bit Timing register
     */
    inline void set_FDCBT(uint16_t FPRESDIV, uint8_t FRJW, uint8_t FPROPSEG,
                          uint8_t FPSEG1, uint8_t FPSEG2) volatile
    {
        uint32_t curr = FDCBT;

        curr &= ~(0b1111111111u << 20u);
        curr |= (FPRESDIV & 0b1111111111u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (FRJW & 0b111u) << 16u;
        curr &= ~(0b11111u << 10u);
        curr |= (FPROPSEG & 0b11111u) << 10u;
        curr &= ~(0b111u << 5u);
        curr |= (FPSEG1 & 0b111u) << 5u;
        curr &= ~(0b111u << 0u);
        curr |= (FPSEG2 & 0b111u) << 0u;

        FDCBT = curr;
    }

    /**
     * Get FDCRC's FD_MBCRC field.
     *
     * CRC Mailbox Number for FD_TXCRC
     */
    inline uint8_t get_FDCRC_FD_MBCRC() volatile
    {
        return (FDCRC >> 24u) & 0b1111111u;
    }

    /**
     * Get FDCRC's FD_TXCRC field.
     *
     * Extended Transmitted CRC value
     */
    inline uint32_t get_FDCRC_FD_TXCRC() volatile
    {
        return (FDCRC >> 0u) & 0b111111111111111111111u;
    }

    /**
     * Get all of FDCRC's bit fields.
     *
     * (read-write) CAN FD CRC register
     */
    inline void get_FDCRC(uint8_t &FD_MBCRC, uint32_t &FD_TXCRC) volatile
    {
        uint32_t curr = FDCRC;

        FD_MBCRC = (curr >> 24u) & 0b1111111u;
        FD_TXCRC = (curr >> 0u) & 0b111111111111111111111u;
    }
};

static_assert(sizeof(can1) == can1::size);

static volatile can1 *const CAN1 = reinterpret_cast<can1 *>(0x400C4000);

static volatile can1 *const CAN2 = reinterpret_cast<can1 *>(0x400C8000);

static volatile can1 *const CAN3 = reinterpret_cast<can1 *>(0x40C3C000);

}; // namespace MIMXRT1176::CM7
