/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/ENET_MSCR_HOLDTIME.h"
#include "../enums/ENET_TCR_ADDSEL.h"
#include "../enums/ENET_TCSR0_TMODE.h"
#include "../enums/ENET_TCSR0_TPWC.h"
#include "../enums/ENET_TCSR1_TMODE.h"
#include "../enums/ENET_TCSR1_TPWC.h"
#include "../enums/ENET_TCSR2_TMODE.h"
#include "../enums/ENET_TCSR2_TPWC.h"
#include "../enums/ENET_TCSR3_TMODE.h"
#include "../enums/ENET_TCSR3_TPWC.h"
#include "../enums/ENET_TFWR_TFWR.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * ENET
 */
struct [[gnu::packed]] enet
{
    /* Constant attributes. */
    static constexpr std::size_t size = 1576; /*!< enet's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint32_t EIR;  /*!< (read-write) Interrupt Event Register */
    uint32_t EIMR; /*!< (read-write) Interrupt Mask Register */
    const uint32_t reserved_padding1 = {};
    uint32_t
        RDAR; /*!< (read-write) Receive Descriptor Active Register - Ring 0 */
    uint32_t
        TDAR; /*!< (read-write) Transmit Descriptor Active Register - Ring 0 */
    static constexpr std::size_t reserved_padding2_length = 3;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t ECR; /*!< (read-write) Ethernet Control Register */
    static constexpr std::size_t reserved_padding3_length = 6;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t MMFR; /*!< (read-write) MII Management Frame Register */
    uint32_t MSCR; /*!< (read-write) MII Speed Control Register */
    static constexpr std::size_t reserved_padding4_length = 7;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t MIBC; /*!< (read-write) MIB Control Register */
    static constexpr std::size_t reserved_padding5_length = 7;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t RCR; /*!< (read-write) Receive Control Register */
    static constexpr std::size_t reserved_padding6_length = 15;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t TCR; /*!< (read-write) Transmit Control Register */
    static constexpr std::size_t reserved_padding7_length = 7;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t PALR; /*!< (read-write) Physical Address Lower Register */
    uint32_t PAUR; /*!< (read-write) Physical Address Upper Register */
    uint32_t OPD;  /*!< (read-write) Opcode/Pause Duration Register */
    static constexpr std::size_t TXIC_length = 3;
    uint32_t TXIC[TXIC_length]; /*!< (read-write) Transmit Interrupt Coalescing
                                   Register */
    const uint32_t reserved_padding8 = {};
    static constexpr std::size_t RXIC_length = 3;
    uint32_t RXIC[RXIC_length]; /*!< (read-write) Receive Interrupt Coalescing
                                   Register */
    static constexpr std::size_t reserved_padding9_length = 3;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t
        IAUR; /*!< (read-write) Descriptor Individual Upper Address Register */
    uint32_t
        IALR; /*!< (read-write) Descriptor Individual Lower Address Register */
    uint32_t GAUR; /*!< (read-write) Descriptor Group Upper Address Register */
    uint32_t GALR; /*!< (read-write) Descriptor Group Lower Address Register */
    static constexpr std::size_t reserved_padding10_length = 7;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t TFWR; /*!< (read-write) Transmit FIFO Watermark Register */
    static constexpr std::size_t reserved_padding11_length = 14;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t
        RDSR; /*!< (read-write) Receive Descriptor Ring 0 Start Register */
    uint32_t TDSR; /*!< (read-write) Transmit Buffer Descriptor Ring 0 Start
                      Register */
    uint32_t MRBR; /*!< (read-write) Maximum Receive Buffer Size Register -
                      Ring 0 */
    const uint32_t reserved_padding12 = {};
    uint32_t RSFL; /*!< (read-write) Receive FIFO Section Full Threshold */
    uint32_t RSEM; /*!< (read-write) Receive FIFO Section Empty Threshold */
    uint32_t RAEM; /*!< (read-write) Receive FIFO Almost Empty Threshold */
    uint32_t RAFL; /*!< (read-write) Receive FIFO Almost Full Threshold */
    uint32_t TSEM; /*!< (read-write) Transmit FIFO Section Empty Threshold */
    uint32_t TAEM; /*!< (read-write) Transmit FIFO Almost Empty Threshold */
    uint32_t TAFL; /*!< (read-write) Transmit FIFO Almost Full Threshold */
    uint32_t TIPG; /*!< (read-write) Transmit Inter-Packet Gap */
    uint32_t FTRL; /*!< (read-write) Frame Truncation Length */
    static constexpr std::size_t reserved_padding13_length = 3;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t
        TACC; /*!< (read-write) Transmit Accelerator Function Configuration */
    uint32_t
        RACC; /*!< (read-write) Receive Accelerator Function Configuration */
    static constexpr std::size_t reserved_padding14_length = 15;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t
        RMON_T_PACKETS; /*!< (read-write) Tx Packet Count Statistic Register */
    uint32_t RMON_T_BC_PKT;    /*!< (read-write) Tx Broadcast Packets Statistic
                                  Register */
    uint32_t RMON_T_MC_PKT;    /*!< (read-write) Tx Multicast Packets Statistic
                                  Register */
    uint32_t RMON_T_CRC_ALIGN; /*!< (read-write) Tx Packets with CRC/Align
                                  Error Statistic Register */
    uint32_t RMON_T_UNDERSIZE; /*!< (read-write) Tx Packets Less Than Bytes and
                                  Good CRC Statistic Register */
    uint32_t RMON_T_OVERSIZE;  /*!< (read-write) Tx Packets GT MAX_FL bytes and
                                  Good CRC Statistic Register */
    uint32_t RMON_T_FRAG; /*!< (read-write) Tx Packets Less Than 64 Bytes and
                             Bad CRC Statistic Register */
    uint32_t RMON_T_JAB; /*!< (read-write) Tx Packets Greater Than MAX_FL bytes
                            and Bad CRC Statistic Register */
    uint32_t
        RMON_T_COL; /*!< (read-write) Tx Collision Count Statistic Register */
    uint32_t
        RMON_T_P64; /*!< (read-write) Tx 64-Byte Packets Statistic Register */
    uint32_t RMON_T_P65TO127;    /*!< (read-write) Tx 65- to 127-byte Packets
                                    Statistic Register */
    uint32_t RMON_T_P128TO255;   /*!< (read-write) Tx 128- to 255-byte Packets
                                    Statistic Register */
    uint32_t RMON_T_P256TO511;   /*!< (read-write) Tx 256- to 511-byte Packets
                                    Statistic Register */
    uint32_t RMON_T_P512TO1023;  /*!< (read-write) Tx 512- to 1023-byte Packets
                                    Statistic Register */
    uint32_t RMON_T_P1024TO2047; /*!< (read-write) Tx 1024- to 2047-byte
                                    Packets Statistic Register */
    uint32_t RMON_T_P_GTE2048;   /*!< (read-write) Tx Packets Greater Than 2048
                                    Bytes Statistic Register */
    uint32_t RMON_T_OCTETS;   /*!< (read-write) Tx Octets Statistic Register */
    uint32_t IEEE_T_DROP;     /*!< (read-write) Reserved Statistic Register */
    uint32_t IEEE_T_FRAME_OK; /*!< (read-write) Frames Transmitted OK Statistic
                                 Register */
    uint32_t IEEE_T_1COL;     /*!< (read-write) Frames Transmitted with Single
                                 Collision Statistic Register */
    uint32_t IEEE_T_MCOL;   /*!< (read-write) Frames Transmitted with Multiple
                               Collisions Statistic Register */
    uint32_t IEEE_T_DEF;    /*!< (read-write) Frames Transmitted after Deferral
                               Delay Statistic Register */
    uint32_t IEEE_T_LCOL;   /*!< (read-write) Frames Transmitted with Late
                               Collision Statistic Register */
    uint32_t IEEE_T_EXCOL;  /*!< (read-write) Frames Transmitted with Excessive
                               Collisions Statistic Register */
    uint32_t IEEE_T_MACERR; /*!< (read-write) Frames Transmitted with Tx FIFO
                               Underrun Statistic Register */
    uint32_t IEEE_T_CSERR;  /*!< (read-write) Frames Transmitted with Carrier
                               Sense Error Statistic Register */
    uint32_t IEEE_T_SQE;    /*!< (read-write) Reserved Statistic Register */
    uint32_t IEEE_T_FDXFC;  /*!< (read-write) Flow Control Pause Frames
                               Transmitted Statistic Register */
    uint32_t IEEE_T_OCTETS_OK; /*!< (read-write) Octet Count for Frames
                                  Transmitted w/o Error Statistic Register */
    static constexpr std::size_t reserved_padding15_length = 3;
    const uint32_t reserved_padding15[reserved_padding15_length] = {};
    uint32_t
        RMON_R_PACKETS; /*!< (read-write) Rx Packet Count Statistic Register */
    uint32_t RMON_R_BC_PKT;    /*!< (read-write) Rx Broadcast Packets Statistic
                                  Register */
    uint32_t RMON_R_MC_PKT;    /*!< (read-write) Rx Multicast Packets Statistic
                                  Register */
    uint32_t RMON_R_CRC_ALIGN; /*!< (read-write) Rx Packets with CRC/Align
                                  Error Statistic Register */
    uint32_t RMON_R_UNDERSIZE; /*!< (read-write) Rx Packets with Less Than 64
                                  Bytes and Good CRC Statistic Register */
    uint32_t RMON_R_OVERSIZE;  /*!< (read-write) Rx Packets Greater Than MAX_FL
                                  and Good CRC Statistic Register */
    uint32_t RMON_R_FRAG; /*!< (read-write) Rx Packets Less Than 64 Bytes and
                             Bad CRC Statistic Register */
    uint32_t RMON_R_JAB; /*!< (read-write) Rx Packets Greater Than MAX_FL Bytes
                            and Bad CRC Statistic Register */
    const uint32_t reserved_padding16 = {};
    uint32_t
        RMON_R_P64; /*!< (read-write) Rx 64-Byte Packets Statistic Register */
    uint32_t RMON_R_P65TO127;    /*!< (read-write) Rx 65- to 127-Byte Packets
                                    Statistic Register */
    uint32_t RMON_R_P128TO255;   /*!< (read-write) Rx 128- to 255-Byte Packets
                                    Statistic Register */
    uint32_t RMON_R_P256TO511;   /*!< (read-write) Rx 256- to 511-Byte Packets
                                    Statistic Register */
    uint32_t RMON_R_P512TO1023;  /*!< (read-write) Rx 512- to 1023-Byte Packets
                                    Statistic Register */
    uint32_t RMON_R_P1024TO2047; /*!< (read-write) Rx 1024- to 2047-Byte
                                    Packets Statistic Register */
    uint32_t RMON_R_P_GTE2048;   /*!< (read-write) Rx Packets Greater than 2048
                                    Bytes Statistic Register */
    uint32_t RMON_R_OCTETS;   /*!< (read-write) Rx Octets Statistic Register */
    uint32_t IEEE_R_DROP;     /*!< (read-write) Frames not Counted Correctly
                                 Statistic Register */
    uint32_t IEEE_R_FRAME_OK; /*!< (read-write) Frames Received OK Statistic
                                 Register */
    uint32_t IEEE_R_CRC;      /*!< (read-write) Frames Received with CRC Error
                                 Statistic Register */
    uint32_t IEEE_R_ALIGN;    /*!< (read-write) Frames Received with Alignment
                                 Error Statistic Register */
    uint32_t IEEE_R_MACERR;   /*!< (read-write) Receive FIFO Overflow Count
                                 Statistic Register */
    uint32_t IEEE_R_FDXFC; /*!< (read-write) Flow Control Pause Frames Received
                              Statistic Register */
    uint32_t IEEE_R_OCTETS_OK; /*!< (read-write) Octet Count for Frames
                                  Received without Error Statistic Register */
    static constexpr std::size_t reserved_padding17_length = 71;
    const uint32_t reserved_padding17[reserved_padding17_length] = {};
    uint32_t ATCR;   /*!< (read-write) Adjustable Timer Control Register */
    uint32_t ATVR;   /*!< (read-write) Timer Value Register */
    uint32_t ATOFF;  /*!< (read-write) Timer Offset Register */
    uint32_t ATPER;  /*!< (read-write) Timer Period Register */
    uint32_t ATCOR;  /*!< (read-write) Timer Correction Register */
    uint32_t ATINC;  /*!< (read-write) Time-Stamping Clock Period Register */
    uint32_t ATSTMP; /*!< (read-write) Timestamp of Last Transmitted Frame */
    static constexpr std::size_t reserved_padding18_length = 122;
    const uint32_t reserved_padding18[reserved_padding18_length] = {};
    uint32_t TGSR;  /*!< (read-write) Timer Global Status Register */
    uint32_t TCSR0; /*!< (read-write) Timer Control Status Register */
    uint32_t TCCR0; /*!< (read-write) Timer Compare Capture Register */
    uint32_t TCSR1; /*!< (read-write) Timer Control Status Register */
    uint32_t TCCR1; /*!< (read-write) Timer Compare Capture Register */
    uint32_t TCSR2; /*!< (read-write) Timer Control Status Register */
    uint32_t TCCR2; /*!< (read-write) Timer Compare Capture Register */
    uint32_t TCSR3; /*!< (read-write) Timer Control Status Register */
    uint32_t TCCR3; /*!< (read-write) Timer Compare Capture Register */

    /* Methods. */

    /**
     * Get EIR's BABR bit.
     *
     * Babbling Receive Error
     */
    inline bool get_EIR_BABR() volatile
    {
        return EIR & (1u << 30u);
    }

    /**
     * Set EIR's BABR bit.
     *
     * Babbling Receive Error
     */
    inline void set_EIR_BABR() volatile
    {
        EIR |= 1u << 30u;
    }

    /**
     * Clear EIR's BABR bit.
     *
     * Babbling Receive Error
     */
    inline void clear_EIR_BABR() volatile
    {
        EIR &= ~(1u << 30u);
    }

    /**
     * Toggle EIR's BABR bit.
     *
     * Babbling Receive Error
     */
    inline void toggle_EIR_BABR() volatile
    {
        EIR ^= 1u << 30u;
    }

    /**
     * Get EIR's BABT bit.
     *
     * Babbling Transmit Error
     */
    inline bool get_EIR_BABT() volatile
    {
        return EIR & (1u << 29u);
    }

    /**
     * Set EIR's BABT bit.
     *
     * Babbling Transmit Error
     */
    inline void set_EIR_BABT() volatile
    {
        EIR |= 1u << 29u;
    }

    /**
     * Clear EIR's BABT bit.
     *
     * Babbling Transmit Error
     */
    inline void clear_EIR_BABT() volatile
    {
        EIR &= ~(1u << 29u);
    }

    /**
     * Toggle EIR's BABT bit.
     *
     * Babbling Transmit Error
     */
    inline void toggle_EIR_BABT() volatile
    {
        EIR ^= 1u << 29u;
    }

    /**
     * Get EIR's GRA bit.
     *
     * Graceful Stop Complete
     */
    inline bool get_EIR_GRA() volatile
    {
        return EIR & (1u << 28u);
    }

    /**
     * Set EIR's GRA bit.
     *
     * Graceful Stop Complete
     */
    inline void set_EIR_GRA() volatile
    {
        EIR |= 1u << 28u;
    }

    /**
     * Clear EIR's GRA bit.
     *
     * Graceful Stop Complete
     */
    inline void clear_EIR_GRA() volatile
    {
        EIR &= ~(1u << 28u);
    }

    /**
     * Toggle EIR's GRA bit.
     *
     * Graceful Stop Complete
     */
    inline void toggle_EIR_GRA() volatile
    {
        EIR ^= 1u << 28u;
    }

    /**
     * Get EIR's TXF bit.
     *
     * Transmit Frame Interrupt
     */
    inline bool get_EIR_TXF() volatile
    {
        return EIR & (1u << 27u);
    }

    /**
     * Set EIR's TXF bit.
     *
     * Transmit Frame Interrupt
     */
    inline void set_EIR_TXF() volatile
    {
        EIR |= 1u << 27u;
    }

    /**
     * Clear EIR's TXF bit.
     *
     * Transmit Frame Interrupt
     */
    inline void clear_EIR_TXF() volatile
    {
        EIR &= ~(1u << 27u);
    }

    /**
     * Toggle EIR's TXF bit.
     *
     * Transmit Frame Interrupt
     */
    inline void toggle_EIR_TXF() volatile
    {
        EIR ^= 1u << 27u;
    }

    /**
     * Get EIR's TXB bit.
     *
     * Transmit Buffer Interrupt
     */
    inline bool get_EIR_TXB() volatile
    {
        return EIR & (1u << 26u);
    }

    /**
     * Set EIR's TXB bit.
     *
     * Transmit Buffer Interrupt
     */
    inline void set_EIR_TXB() volatile
    {
        EIR |= 1u << 26u;
    }

    /**
     * Clear EIR's TXB bit.
     *
     * Transmit Buffer Interrupt
     */
    inline void clear_EIR_TXB() volatile
    {
        EIR &= ~(1u << 26u);
    }

    /**
     * Toggle EIR's TXB bit.
     *
     * Transmit Buffer Interrupt
     */
    inline void toggle_EIR_TXB() volatile
    {
        EIR ^= 1u << 26u;
    }

    /**
     * Get EIR's RXF bit.
     *
     * Receive Frame Interrupt
     */
    inline bool get_EIR_RXF() volatile
    {
        return EIR & (1u << 25u);
    }

    /**
     * Set EIR's RXF bit.
     *
     * Receive Frame Interrupt
     */
    inline void set_EIR_RXF() volatile
    {
        EIR |= 1u << 25u;
    }

    /**
     * Clear EIR's RXF bit.
     *
     * Receive Frame Interrupt
     */
    inline void clear_EIR_RXF() volatile
    {
        EIR &= ~(1u << 25u);
    }

    /**
     * Toggle EIR's RXF bit.
     *
     * Receive Frame Interrupt
     */
    inline void toggle_EIR_RXF() volatile
    {
        EIR ^= 1u << 25u;
    }

    /**
     * Get EIR's RXB bit.
     *
     * Receive Buffer Interrupt
     */
    inline bool get_EIR_RXB() volatile
    {
        return EIR & (1u << 24u);
    }

    /**
     * Set EIR's RXB bit.
     *
     * Receive Buffer Interrupt
     */
    inline void set_EIR_RXB() volatile
    {
        EIR |= 1u << 24u;
    }

    /**
     * Clear EIR's RXB bit.
     *
     * Receive Buffer Interrupt
     */
    inline void clear_EIR_RXB() volatile
    {
        EIR &= ~(1u << 24u);
    }

    /**
     * Toggle EIR's RXB bit.
     *
     * Receive Buffer Interrupt
     */
    inline void toggle_EIR_RXB() volatile
    {
        EIR ^= 1u << 24u;
    }

    /**
     * Get EIR's MII bit.
     *
     * MII Interrupt.
     */
    inline bool get_EIR_MII() volatile
    {
        return EIR & (1u << 23u);
    }

    /**
     * Set EIR's MII bit.
     *
     * MII Interrupt.
     */
    inline void set_EIR_MII() volatile
    {
        EIR |= 1u << 23u;
    }

    /**
     * Clear EIR's MII bit.
     *
     * MII Interrupt.
     */
    inline void clear_EIR_MII() volatile
    {
        EIR &= ~(1u << 23u);
    }

    /**
     * Toggle EIR's MII bit.
     *
     * MII Interrupt.
     */
    inline void toggle_EIR_MII() volatile
    {
        EIR ^= 1u << 23u;
    }

    /**
     * Get EIR's EBERR bit.
     *
     * Ethernet Bus Error
     */
    inline bool get_EIR_EBERR() volatile
    {
        return EIR & (1u << 22u);
    }

    /**
     * Set EIR's EBERR bit.
     *
     * Ethernet Bus Error
     */
    inline void set_EIR_EBERR() volatile
    {
        EIR |= 1u << 22u;
    }

    /**
     * Clear EIR's EBERR bit.
     *
     * Ethernet Bus Error
     */
    inline void clear_EIR_EBERR() volatile
    {
        EIR &= ~(1u << 22u);
    }

    /**
     * Toggle EIR's EBERR bit.
     *
     * Ethernet Bus Error
     */
    inline void toggle_EIR_EBERR() volatile
    {
        EIR ^= 1u << 22u;
    }

    /**
     * Get EIR's LC bit.
     *
     * Late Collision
     */
    inline bool get_EIR_LC() volatile
    {
        return EIR & (1u << 21u);
    }

    /**
     * Set EIR's LC bit.
     *
     * Late Collision
     */
    inline void set_EIR_LC() volatile
    {
        EIR |= 1u << 21u;
    }

    /**
     * Clear EIR's LC bit.
     *
     * Late Collision
     */
    inline void clear_EIR_LC() volatile
    {
        EIR &= ~(1u << 21u);
    }

    /**
     * Toggle EIR's LC bit.
     *
     * Late Collision
     */
    inline void toggle_EIR_LC() volatile
    {
        EIR ^= 1u << 21u;
    }

    /**
     * Get EIR's RL bit.
     *
     * Collision Retry Limit
     */
    inline bool get_EIR_RL() volatile
    {
        return EIR & (1u << 20u);
    }

    /**
     * Set EIR's RL bit.
     *
     * Collision Retry Limit
     */
    inline void set_EIR_RL() volatile
    {
        EIR |= 1u << 20u;
    }

    /**
     * Clear EIR's RL bit.
     *
     * Collision Retry Limit
     */
    inline void clear_EIR_RL() volatile
    {
        EIR &= ~(1u << 20u);
    }

    /**
     * Toggle EIR's RL bit.
     *
     * Collision Retry Limit
     */
    inline void toggle_EIR_RL() volatile
    {
        EIR ^= 1u << 20u;
    }

    /**
     * Get EIR's UN bit.
     *
     * Transmit FIFO Underrun
     */
    inline bool get_EIR_UN() volatile
    {
        return EIR & (1u << 19u);
    }

    /**
     * Set EIR's UN bit.
     *
     * Transmit FIFO Underrun
     */
    inline void set_EIR_UN() volatile
    {
        EIR |= 1u << 19u;
    }

    /**
     * Clear EIR's UN bit.
     *
     * Transmit FIFO Underrun
     */
    inline void clear_EIR_UN() volatile
    {
        EIR &= ~(1u << 19u);
    }

    /**
     * Toggle EIR's UN bit.
     *
     * Transmit FIFO Underrun
     */
    inline void toggle_EIR_UN() volatile
    {
        EIR ^= 1u << 19u;
    }

    /**
     * Get EIR's PLR bit.
     *
     * Payload Receive Error
     */
    inline bool get_EIR_PLR() volatile
    {
        return EIR & (1u << 18u);
    }

    /**
     * Set EIR's PLR bit.
     *
     * Payload Receive Error
     */
    inline void set_EIR_PLR() volatile
    {
        EIR |= 1u << 18u;
    }

    /**
     * Clear EIR's PLR bit.
     *
     * Payload Receive Error
     */
    inline void clear_EIR_PLR() volatile
    {
        EIR &= ~(1u << 18u);
    }

    /**
     * Toggle EIR's PLR bit.
     *
     * Payload Receive Error
     */
    inline void toggle_EIR_PLR() volatile
    {
        EIR ^= 1u << 18u;
    }

    /**
     * Get EIR's WAKEUP bit.
     *
     * Node Wakeup Request Indication
     */
    inline bool get_EIR_WAKEUP() volatile
    {
        return EIR & (1u << 17u);
    }

    /**
     * Set EIR's WAKEUP bit.
     *
     * Node Wakeup Request Indication
     */
    inline void set_EIR_WAKEUP() volatile
    {
        EIR |= 1u << 17u;
    }

    /**
     * Clear EIR's WAKEUP bit.
     *
     * Node Wakeup Request Indication
     */
    inline void clear_EIR_WAKEUP() volatile
    {
        EIR &= ~(1u << 17u);
    }

    /**
     * Toggle EIR's WAKEUP bit.
     *
     * Node Wakeup Request Indication
     */
    inline void toggle_EIR_WAKEUP() volatile
    {
        EIR ^= 1u << 17u;
    }

    /**
     * Get EIR's TS_AVAIL bit.
     *
     * Transmit Timestamp Available
     */
    inline bool get_EIR_TS_AVAIL() volatile
    {
        return EIR & (1u << 16u);
    }

    /**
     * Set EIR's TS_AVAIL bit.
     *
     * Transmit Timestamp Available
     */
    inline void set_EIR_TS_AVAIL() volatile
    {
        EIR |= 1u << 16u;
    }

    /**
     * Clear EIR's TS_AVAIL bit.
     *
     * Transmit Timestamp Available
     */
    inline void clear_EIR_TS_AVAIL() volatile
    {
        EIR &= ~(1u << 16u);
    }

    /**
     * Toggle EIR's TS_AVAIL bit.
     *
     * Transmit Timestamp Available
     */
    inline void toggle_EIR_TS_AVAIL() volatile
    {
        EIR ^= 1u << 16u;
    }

    /**
     * Get EIR's TS_TIMER bit.
     *
     * Timestamp Timer
     */
    inline bool get_EIR_TS_TIMER() volatile
    {
        return EIR & (1u << 15u);
    }

    /**
     * Set EIR's TS_TIMER bit.
     *
     * Timestamp Timer
     */
    inline void set_EIR_TS_TIMER() volatile
    {
        EIR |= 1u << 15u;
    }

    /**
     * Clear EIR's TS_TIMER bit.
     *
     * Timestamp Timer
     */
    inline void clear_EIR_TS_TIMER() volatile
    {
        EIR &= ~(1u << 15u);
    }

    /**
     * Toggle EIR's TS_TIMER bit.
     *
     * Timestamp Timer
     */
    inline void toggle_EIR_TS_TIMER() volatile
    {
        EIR ^= 1u << 15u;
    }

    /**
     * Get all of EIR's bit fields.
     *
     * (read-write) Interrupt Event Register
     */
    inline void get_EIR(bool &BABR, bool &BABT, bool &GRA, bool &TXF,
                        bool &TXB, bool &RXF, bool &RXB, bool &MII,
                        bool &EBERR, bool &LC, bool &RL, bool &UN, bool &PLR,
                        bool &WAKEUP, bool &TS_AVAIL, bool &TS_TIMER) volatile
    {
        uint32_t curr = EIR;

        BABR = curr & (1u << 30u);
        BABT = curr & (1u << 29u);
        GRA = curr & (1u << 28u);
        TXF = curr & (1u << 27u);
        TXB = curr & (1u << 26u);
        RXF = curr & (1u << 25u);
        RXB = curr & (1u << 24u);
        MII = curr & (1u << 23u);
        EBERR = curr & (1u << 22u);
        LC = curr & (1u << 21u);
        RL = curr & (1u << 20u);
        UN = curr & (1u << 19u);
        PLR = curr & (1u << 18u);
        WAKEUP = curr & (1u << 17u);
        TS_AVAIL = curr & (1u << 16u);
        TS_TIMER = curr & (1u << 15u);
    }

    /**
     * Set all of EIR's bit fields.
     *
     * (read-write) Interrupt Event Register
     */
    inline void set_EIR(bool BABR, bool BABT, bool GRA, bool TXF, bool TXB,
                        bool RXF, bool RXB, bool MII, bool EBERR, bool LC,
                        bool RL, bool UN, bool PLR, bool WAKEUP, bool TS_AVAIL,
                        bool TS_TIMER) volatile
    {
        uint32_t curr = EIR;

        curr &= ~(0b1u << 30u);
        curr |= (BABR & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (BABT & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (GRA & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (TXF & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (TXB & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (RXF & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RXB & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (MII & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EBERR & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (LC & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (RL & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (UN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (PLR & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (WAKEUP & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (TS_AVAIL & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TS_TIMER & 0b1u) << 15u;

        EIR = curr;
    }

    /**
     * Get EIMR's BABR bit.
     *
     * BABR Interrupt Mask
     */
    inline bool get_EIMR_BABR() volatile
    {
        return EIMR & (1u << 30u);
    }

    /**
     * Set EIMR's BABR bit.
     *
     * BABR Interrupt Mask
     */
    inline void set_EIMR_BABR() volatile
    {
        EIMR |= 1u << 30u;
    }

    /**
     * Clear EIMR's BABR bit.
     *
     * BABR Interrupt Mask
     */
    inline void clear_EIMR_BABR() volatile
    {
        EIMR &= ~(1u << 30u);
    }

    /**
     * Toggle EIMR's BABR bit.
     *
     * BABR Interrupt Mask
     */
    inline void toggle_EIMR_BABR() volatile
    {
        EIMR ^= 1u << 30u;
    }

    /**
     * Get EIMR's BABT bit.
     *
     * BABT Interrupt Mask
     */
    inline bool get_EIMR_BABT() volatile
    {
        return EIMR & (1u << 29u);
    }

    /**
     * Set EIMR's BABT bit.
     *
     * BABT Interrupt Mask
     */
    inline void set_EIMR_BABT() volatile
    {
        EIMR |= 1u << 29u;
    }

    /**
     * Clear EIMR's BABT bit.
     *
     * BABT Interrupt Mask
     */
    inline void clear_EIMR_BABT() volatile
    {
        EIMR &= ~(1u << 29u);
    }

    /**
     * Toggle EIMR's BABT bit.
     *
     * BABT Interrupt Mask
     */
    inline void toggle_EIMR_BABT() volatile
    {
        EIMR ^= 1u << 29u;
    }

    /**
     * Get EIMR's GRA bit.
     *
     * GRA Interrupt Mask
     */
    inline bool get_EIMR_GRA() volatile
    {
        return EIMR & (1u << 28u);
    }

    /**
     * Set EIMR's GRA bit.
     *
     * GRA Interrupt Mask
     */
    inline void set_EIMR_GRA() volatile
    {
        EIMR |= 1u << 28u;
    }

    /**
     * Clear EIMR's GRA bit.
     *
     * GRA Interrupt Mask
     */
    inline void clear_EIMR_GRA() volatile
    {
        EIMR &= ~(1u << 28u);
    }

    /**
     * Toggle EIMR's GRA bit.
     *
     * GRA Interrupt Mask
     */
    inline void toggle_EIMR_GRA() volatile
    {
        EIMR ^= 1u << 28u;
    }

    /**
     * Get EIMR's TXF bit.
     *
     * TXF Interrupt Mask
     */
    inline bool get_EIMR_TXF() volatile
    {
        return EIMR & (1u << 27u);
    }

    /**
     * Set EIMR's TXF bit.
     *
     * TXF Interrupt Mask
     */
    inline void set_EIMR_TXF() volatile
    {
        EIMR |= 1u << 27u;
    }

    /**
     * Clear EIMR's TXF bit.
     *
     * TXF Interrupt Mask
     */
    inline void clear_EIMR_TXF() volatile
    {
        EIMR &= ~(1u << 27u);
    }

    /**
     * Toggle EIMR's TXF bit.
     *
     * TXF Interrupt Mask
     */
    inline void toggle_EIMR_TXF() volatile
    {
        EIMR ^= 1u << 27u;
    }

    /**
     * Get EIMR's TXB bit.
     *
     * TXB Interrupt Mask
     */
    inline bool get_EIMR_TXB() volatile
    {
        return EIMR & (1u << 26u);
    }

    /**
     * Set EIMR's TXB bit.
     *
     * TXB Interrupt Mask
     */
    inline void set_EIMR_TXB() volatile
    {
        EIMR |= 1u << 26u;
    }

    /**
     * Clear EIMR's TXB bit.
     *
     * TXB Interrupt Mask
     */
    inline void clear_EIMR_TXB() volatile
    {
        EIMR &= ~(1u << 26u);
    }

    /**
     * Toggle EIMR's TXB bit.
     *
     * TXB Interrupt Mask
     */
    inline void toggle_EIMR_TXB() volatile
    {
        EIMR ^= 1u << 26u;
    }

    /**
     * Get EIMR's RXF bit.
     *
     * RXF Interrupt Mask
     */
    inline bool get_EIMR_RXF() volatile
    {
        return EIMR & (1u << 25u);
    }

    /**
     * Set EIMR's RXF bit.
     *
     * RXF Interrupt Mask
     */
    inline void set_EIMR_RXF() volatile
    {
        EIMR |= 1u << 25u;
    }

    /**
     * Clear EIMR's RXF bit.
     *
     * RXF Interrupt Mask
     */
    inline void clear_EIMR_RXF() volatile
    {
        EIMR &= ~(1u << 25u);
    }

    /**
     * Toggle EIMR's RXF bit.
     *
     * RXF Interrupt Mask
     */
    inline void toggle_EIMR_RXF() volatile
    {
        EIMR ^= 1u << 25u;
    }

    /**
     * Get EIMR's RXB bit.
     *
     * RXB Interrupt Mask
     */
    inline bool get_EIMR_RXB() volatile
    {
        return EIMR & (1u << 24u);
    }

    /**
     * Set EIMR's RXB bit.
     *
     * RXB Interrupt Mask
     */
    inline void set_EIMR_RXB() volatile
    {
        EIMR |= 1u << 24u;
    }

    /**
     * Clear EIMR's RXB bit.
     *
     * RXB Interrupt Mask
     */
    inline void clear_EIMR_RXB() volatile
    {
        EIMR &= ~(1u << 24u);
    }

    /**
     * Toggle EIMR's RXB bit.
     *
     * RXB Interrupt Mask
     */
    inline void toggle_EIMR_RXB() volatile
    {
        EIMR ^= 1u << 24u;
    }

    /**
     * Get EIMR's MII bit.
     *
     * MII Interrupt Mask
     */
    inline bool get_EIMR_MII() volatile
    {
        return EIMR & (1u << 23u);
    }

    /**
     * Set EIMR's MII bit.
     *
     * MII Interrupt Mask
     */
    inline void set_EIMR_MII() volatile
    {
        EIMR |= 1u << 23u;
    }

    /**
     * Clear EIMR's MII bit.
     *
     * MII Interrupt Mask
     */
    inline void clear_EIMR_MII() volatile
    {
        EIMR &= ~(1u << 23u);
    }

    /**
     * Toggle EIMR's MII bit.
     *
     * MII Interrupt Mask
     */
    inline void toggle_EIMR_MII() volatile
    {
        EIMR ^= 1u << 23u;
    }

    /**
     * Get EIMR's EBERR bit.
     *
     * EBERR Interrupt Mask
     */
    inline bool get_EIMR_EBERR() volatile
    {
        return EIMR & (1u << 22u);
    }

    /**
     * Set EIMR's EBERR bit.
     *
     * EBERR Interrupt Mask
     */
    inline void set_EIMR_EBERR() volatile
    {
        EIMR |= 1u << 22u;
    }

    /**
     * Clear EIMR's EBERR bit.
     *
     * EBERR Interrupt Mask
     */
    inline void clear_EIMR_EBERR() volatile
    {
        EIMR &= ~(1u << 22u);
    }

    /**
     * Toggle EIMR's EBERR bit.
     *
     * EBERR Interrupt Mask
     */
    inline void toggle_EIMR_EBERR() volatile
    {
        EIMR ^= 1u << 22u;
    }

    /**
     * Get EIMR's LC bit.
     *
     * LC Interrupt Mask
     */
    inline bool get_EIMR_LC() volatile
    {
        return EIMR & (1u << 21u);
    }

    /**
     * Set EIMR's LC bit.
     *
     * LC Interrupt Mask
     */
    inline void set_EIMR_LC() volatile
    {
        EIMR |= 1u << 21u;
    }

    /**
     * Clear EIMR's LC bit.
     *
     * LC Interrupt Mask
     */
    inline void clear_EIMR_LC() volatile
    {
        EIMR &= ~(1u << 21u);
    }

    /**
     * Toggle EIMR's LC bit.
     *
     * LC Interrupt Mask
     */
    inline void toggle_EIMR_LC() volatile
    {
        EIMR ^= 1u << 21u;
    }

    /**
     * Get EIMR's RL bit.
     *
     * RL Interrupt Mask
     */
    inline bool get_EIMR_RL() volatile
    {
        return EIMR & (1u << 20u);
    }

    /**
     * Set EIMR's RL bit.
     *
     * RL Interrupt Mask
     */
    inline void set_EIMR_RL() volatile
    {
        EIMR |= 1u << 20u;
    }

    /**
     * Clear EIMR's RL bit.
     *
     * RL Interrupt Mask
     */
    inline void clear_EIMR_RL() volatile
    {
        EIMR &= ~(1u << 20u);
    }

    /**
     * Toggle EIMR's RL bit.
     *
     * RL Interrupt Mask
     */
    inline void toggle_EIMR_RL() volatile
    {
        EIMR ^= 1u << 20u;
    }

    /**
     * Get EIMR's UN bit.
     *
     * UN Interrupt Mask
     */
    inline bool get_EIMR_UN() volatile
    {
        return EIMR & (1u << 19u);
    }

    /**
     * Set EIMR's UN bit.
     *
     * UN Interrupt Mask
     */
    inline void set_EIMR_UN() volatile
    {
        EIMR |= 1u << 19u;
    }

    /**
     * Clear EIMR's UN bit.
     *
     * UN Interrupt Mask
     */
    inline void clear_EIMR_UN() volatile
    {
        EIMR &= ~(1u << 19u);
    }

    /**
     * Toggle EIMR's UN bit.
     *
     * UN Interrupt Mask
     */
    inline void toggle_EIMR_UN() volatile
    {
        EIMR ^= 1u << 19u;
    }

    /**
     * Get EIMR's PLR bit.
     *
     * PLR Interrupt Mask
     */
    inline bool get_EIMR_PLR() volatile
    {
        return EIMR & (1u << 18u);
    }

    /**
     * Set EIMR's PLR bit.
     *
     * PLR Interrupt Mask
     */
    inline void set_EIMR_PLR() volatile
    {
        EIMR |= 1u << 18u;
    }

    /**
     * Clear EIMR's PLR bit.
     *
     * PLR Interrupt Mask
     */
    inline void clear_EIMR_PLR() volatile
    {
        EIMR &= ~(1u << 18u);
    }

    /**
     * Toggle EIMR's PLR bit.
     *
     * PLR Interrupt Mask
     */
    inline void toggle_EIMR_PLR() volatile
    {
        EIMR ^= 1u << 18u;
    }

    /**
     * Get EIMR's WAKEUP bit.
     *
     * WAKEUP Interrupt Mask
     */
    inline bool get_EIMR_WAKEUP() volatile
    {
        return EIMR & (1u << 17u);
    }

    /**
     * Set EIMR's WAKEUP bit.
     *
     * WAKEUP Interrupt Mask
     */
    inline void set_EIMR_WAKEUP() volatile
    {
        EIMR |= 1u << 17u;
    }

    /**
     * Clear EIMR's WAKEUP bit.
     *
     * WAKEUP Interrupt Mask
     */
    inline void clear_EIMR_WAKEUP() volatile
    {
        EIMR &= ~(1u << 17u);
    }

    /**
     * Toggle EIMR's WAKEUP bit.
     *
     * WAKEUP Interrupt Mask
     */
    inline void toggle_EIMR_WAKEUP() volatile
    {
        EIMR ^= 1u << 17u;
    }

    /**
     * Get EIMR's TS_AVAIL bit.
     *
     * TS_AVAIL Interrupt Mask
     */
    inline bool get_EIMR_TS_AVAIL() volatile
    {
        return EIMR & (1u << 16u);
    }

    /**
     * Set EIMR's TS_AVAIL bit.
     *
     * TS_AVAIL Interrupt Mask
     */
    inline void set_EIMR_TS_AVAIL() volatile
    {
        EIMR |= 1u << 16u;
    }

    /**
     * Clear EIMR's TS_AVAIL bit.
     *
     * TS_AVAIL Interrupt Mask
     */
    inline void clear_EIMR_TS_AVAIL() volatile
    {
        EIMR &= ~(1u << 16u);
    }

    /**
     * Toggle EIMR's TS_AVAIL bit.
     *
     * TS_AVAIL Interrupt Mask
     */
    inline void toggle_EIMR_TS_AVAIL() volatile
    {
        EIMR ^= 1u << 16u;
    }

    /**
     * Get EIMR's TS_TIMER bit.
     *
     * TS_TIMER Interrupt Mask
     */
    inline bool get_EIMR_TS_TIMER() volatile
    {
        return EIMR & (1u << 15u);
    }

    /**
     * Set EIMR's TS_TIMER bit.
     *
     * TS_TIMER Interrupt Mask
     */
    inline void set_EIMR_TS_TIMER() volatile
    {
        EIMR |= 1u << 15u;
    }

    /**
     * Clear EIMR's TS_TIMER bit.
     *
     * TS_TIMER Interrupt Mask
     */
    inline void clear_EIMR_TS_TIMER() volatile
    {
        EIMR &= ~(1u << 15u);
    }

    /**
     * Toggle EIMR's TS_TIMER bit.
     *
     * TS_TIMER Interrupt Mask
     */
    inline void toggle_EIMR_TS_TIMER() volatile
    {
        EIMR ^= 1u << 15u;
    }

    /**
     * Get all of EIMR's bit fields.
     *
     * (read-write) Interrupt Mask Register
     */
    inline void get_EIMR(bool &BABR, bool &BABT, bool &GRA, bool &TXF,
                         bool &TXB, bool &RXF, bool &RXB, bool &MII,
                         bool &EBERR, bool &LC, bool &RL, bool &UN, bool &PLR,
                         bool &WAKEUP, bool &TS_AVAIL, bool &TS_TIMER) volatile
    {
        uint32_t curr = EIMR;

        BABR = curr & (1u << 30u);
        BABT = curr & (1u << 29u);
        GRA = curr & (1u << 28u);
        TXF = curr & (1u << 27u);
        TXB = curr & (1u << 26u);
        RXF = curr & (1u << 25u);
        RXB = curr & (1u << 24u);
        MII = curr & (1u << 23u);
        EBERR = curr & (1u << 22u);
        LC = curr & (1u << 21u);
        RL = curr & (1u << 20u);
        UN = curr & (1u << 19u);
        PLR = curr & (1u << 18u);
        WAKEUP = curr & (1u << 17u);
        TS_AVAIL = curr & (1u << 16u);
        TS_TIMER = curr & (1u << 15u);
    }

    /**
     * Set all of EIMR's bit fields.
     *
     * (read-write) Interrupt Mask Register
     */
    inline void set_EIMR(bool BABR, bool BABT, bool GRA, bool TXF, bool TXB,
                         bool RXF, bool RXB, bool MII, bool EBERR, bool LC,
                         bool RL, bool UN, bool PLR, bool WAKEUP,
                         bool TS_AVAIL, bool TS_TIMER) volatile
    {
        uint32_t curr = EIMR;

        curr &= ~(0b1u << 30u);
        curr |= (BABR & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (BABT & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (GRA & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (TXF & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (TXB & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (RXF & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RXB & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (MII & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EBERR & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (LC & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (RL & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (UN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (PLR & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (WAKEUP & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (TS_AVAIL & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TS_TIMER & 0b1u) << 15u;

        EIMR = curr;
    }

    /**
     * Get RDAR's RDAR bit.
     *
     * Receive Descriptor Active
     */
    inline bool get_RDAR_RDAR() volatile
    {
        return RDAR & (1u << 24u);
    }

    /**
     * Set RDAR's RDAR bit.
     *
     * Receive Descriptor Active
     */
    inline void set_RDAR_RDAR() volatile
    {
        RDAR |= 1u << 24u;
    }

    /**
     * Clear RDAR's RDAR bit.
     *
     * Receive Descriptor Active
     */
    inline void clear_RDAR_RDAR() volatile
    {
        RDAR &= ~(1u << 24u);
    }

    /**
     * Toggle RDAR's RDAR bit.
     *
     * Receive Descriptor Active
     */
    inline void toggle_RDAR_RDAR() volatile
    {
        RDAR ^= 1u << 24u;
    }

    /**
     * Get TDAR's TDAR bit.
     *
     * Transmit Descriptor Active
     */
    inline bool get_TDAR_TDAR() volatile
    {
        return TDAR & (1u << 24u);
    }

    /**
     * Set TDAR's TDAR bit.
     *
     * Transmit Descriptor Active
     */
    inline void set_TDAR_TDAR() volatile
    {
        TDAR |= 1u << 24u;
    }

    /**
     * Clear TDAR's TDAR bit.
     *
     * Transmit Descriptor Active
     */
    inline void clear_TDAR_TDAR() volatile
    {
        TDAR &= ~(1u << 24u);
    }

    /**
     * Toggle TDAR's TDAR bit.
     *
     * Transmit Descriptor Active
     */
    inline void toggle_TDAR_TDAR() volatile
    {
        TDAR ^= 1u << 24u;
    }

    /**
     * Get ECR's DBSWP bit.
     *
     * Descriptor Byte Swapping Enable
     */
    inline bool get_ECR_DBSWP() volatile
    {
        return ECR & (1u << 8u);
    }

    /**
     * Set ECR's DBSWP bit.
     *
     * Descriptor Byte Swapping Enable
     */
    inline void set_ECR_DBSWP() volatile
    {
        ECR |= 1u << 8u;
    }

    /**
     * Clear ECR's DBSWP bit.
     *
     * Descriptor Byte Swapping Enable
     */
    inline void clear_ECR_DBSWP() volatile
    {
        ECR &= ~(1u << 8u);
    }

    /**
     * Toggle ECR's DBSWP bit.
     *
     * Descriptor Byte Swapping Enable
     */
    inline void toggle_ECR_DBSWP() volatile
    {
        ECR ^= 1u << 8u;
    }

    /**
     * Get ECR's DBGEN bit.
     *
     * Debug Enable
     */
    inline bool get_ECR_DBGEN() volatile
    {
        return ECR & (1u << 6u);
    }

    /**
     * Set ECR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void set_ECR_DBGEN() volatile
    {
        ECR |= 1u << 6u;
    }

    /**
     * Clear ECR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void clear_ECR_DBGEN() volatile
    {
        ECR &= ~(1u << 6u);
    }

    /**
     * Toggle ECR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void toggle_ECR_DBGEN() volatile
    {
        ECR ^= 1u << 6u;
    }

    /**
     * Get ECR's EN1588 bit.
     *
     * EN1588 Enable
     */
    inline bool get_ECR_EN1588() volatile
    {
        return ECR & (1u << 4u);
    }

    /**
     * Set ECR's EN1588 bit.
     *
     * EN1588 Enable
     */
    inline void set_ECR_EN1588() volatile
    {
        ECR |= 1u << 4u;
    }

    /**
     * Clear ECR's EN1588 bit.
     *
     * EN1588 Enable
     */
    inline void clear_ECR_EN1588() volatile
    {
        ECR &= ~(1u << 4u);
    }

    /**
     * Toggle ECR's EN1588 bit.
     *
     * EN1588 Enable
     */
    inline void toggle_ECR_EN1588() volatile
    {
        ECR ^= 1u << 4u;
    }

    /**
     * Get ECR's SLEEP bit.
     *
     * Sleep Mode Enable
     */
    inline bool get_ECR_SLEEP() volatile
    {
        return ECR & (1u << 3u);
    }

    /**
     * Set ECR's SLEEP bit.
     *
     * Sleep Mode Enable
     */
    inline void set_ECR_SLEEP() volatile
    {
        ECR |= 1u << 3u;
    }

    /**
     * Clear ECR's SLEEP bit.
     *
     * Sleep Mode Enable
     */
    inline void clear_ECR_SLEEP() volatile
    {
        ECR &= ~(1u << 3u);
    }

    /**
     * Toggle ECR's SLEEP bit.
     *
     * Sleep Mode Enable
     */
    inline void toggle_ECR_SLEEP() volatile
    {
        ECR ^= 1u << 3u;
    }

    /**
     * Get ECR's MAGICEN bit.
     *
     * Magic Packet Detection Enable
     */
    inline bool get_ECR_MAGICEN() volatile
    {
        return ECR & (1u << 2u);
    }

    /**
     * Set ECR's MAGICEN bit.
     *
     * Magic Packet Detection Enable
     */
    inline void set_ECR_MAGICEN() volatile
    {
        ECR |= 1u << 2u;
    }

    /**
     * Clear ECR's MAGICEN bit.
     *
     * Magic Packet Detection Enable
     */
    inline void clear_ECR_MAGICEN() volatile
    {
        ECR &= ~(1u << 2u);
    }

    /**
     * Toggle ECR's MAGICEN bit.
     *
     * Magic Packet Detection Enable
     */
    inline void toggle_ECR_MAGICEN() volatile
    {
        ECR ^= 1u << 2u;
    }

    /**
     * Get ECR's ETHEREN bit.
     *
     * Ethernet Enable
     */
    inline bool get_ECR_ETHEREN() volatile
    {
        return ECR & (1u << 1u);
    }

    /**
     * Set ECR's ETHEREN bit.
     *
     * Ethernet Enable
     */
    inline void set_ECR_ETHEREN() volatile
    {
        ECR |= 1u << 1u;
    }

    /**
     * Clear ECR's ETHEREN bit.
     *
     * Ethernet Enable
     */
    inline void clear_ECR_ETHEREN() volatile
    {
        ECR &= ~(1u << 1u);
    }

    /**
     * Toggle ECR's ETHEREN bit.
     *
     * Ethernet Enable
     */
    inline void toggle_ECR_ETHEREN() volatile
    {
        ECR ^= 1u << 1u;
    }

    /**
     * Get ECR's RESET bit.
     *
     * Ethernet MAC Reset
     */
    inline bool get_ECR_RESET() volatile
    {
        return ECR & (1u << 0u);
    }

    /**
     * Set ECR's RESET bit.
     *
     * Ethernet MAC Reset
     */
    inline void set_ECR_RESET() volatile
    {
        ECR |= 1u << 0u;
    }

    /**
     * Clear ECR's RESET bit.
     *
     * Ethernet MAC Reset
     */
    inline void clear_ECR_RESET() volatile
    {
        ECR &= ~(1u << 0u);
    }

    /**
     * Toggle ECR's RESET bit.
     *
     * Ethernet MAC Reset
     */
    inline void toggle_ECR_RESET() volatile
    {
        ECR ^= 1u << 0u;
    }

    /**
     * Get all of ECR's bit fields.
     *
     * (read-write) Ethernet Control Register
     */
    inline void get_ECR(bool &DBSWP, bool &DBGEN, bool &EN1588, bool &SLEEP,
                        bool &MAGICEN, bool &ETHEREN, bool &RESET) volatile
    {
        uint32_t curr = ECR;

        DBSWP = curr & (1u << 8u);
        DBGEN = curr & (1u << 6u);
        EN1588 = curr & (1u << 4u);
        SLEEP = curr & (1u << 3u);
        MAGICEN = curr & (1u << 2u);
        ETHEREN = curr & (1u << 1u);
        RESET = curr & (1u << 0u);
    }

    /**
     * Set all of ECR's bit fields.
     *
     * (read-write) Ethernet Control Register
     */
    inline void set_ECR(bool DBSWP, bool DBGEN, bool EN1588, bool SLEEP,
                        bool MAGICEN, bool ETHEREN, bool RESET) volatile
    {
        uint32_t curr = ECR;

        curr &= ~(0b1u << 8u);
        curr |= (DBSWP & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (DBGEN & 0b1u) << 6u;
        curr &= ~(0b1u << 4u);
        curr |= (EN1588 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SLEEP & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (MAGICEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ETHEREN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RESET & 0b1u) << 0u;

        ECR = curr;
    }

    /**
     * Get MMFR's ST field.
     *
     * Start Of Frame Delimiter
     */
    inline uint8_t get_MMFR_ST() volatile
    {
        return (MMFR >> 30u) & 0b11u;
    }

    /**
     * Set MMFR's ST field.
     *
     * Start Of Frame Delimiter
     */
    inline void set_MMFR_ST(uint8_t value) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        MMFR = curr;
    }

    /**
     * Get MMFR's OP field.
     *
     * Operation Code
     */
    inline uint8_t get_MMFR_OP() volatile
    {
        return (MMFR >> 28u) & 0b11u;
    }

    /**
     * Set MMFR's OP field.
     *
     * Operation Code
     */
    inline void set_MMFR_OP(uint8_t value) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b11u << 28u);
        curr |= (value & 0b11u) << 28u;

        MMFR = curr;
    }

    /**
     * Get MMFR's PA field.
     *
     * PHY Address
     */
    inline uint8_t get_MMFR_PA() volatile
    {
        return (MMFR >> 23u) & 0b11111u;
    }

    /**
     * Set MMFR's PA field.
     *
     * PHY Address
     */
    inline void set_MMFR_PA(uint8_t value) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b11111u << 23u);
        curr |= (value & 0b11111u) << 23u;

        MMFR = curr;
    }

    /**
     * Get MMFR's RA field.
     *
     * Register Address
     */
    inline uint8_t get_MMFR_RA() volatile
    {
        return (MMFR >> 18u) & 0b11111u;
    }

    /**
     * Set MMFR's RA field.
     *
     * Register Address
     */
    inline void set_MMFR_RA(uint8_t value) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b11111u << 18u);
        curr |= (value & 0b11111u) << 18u;

        MMFR = curr;
    }

    /**
     * Get MMFR's TA field.
     *
     * Turn Around
     */
    inline uint8_t get_MMFR_TA() volatile
    {
        return (MMFR >> 16u) & 0b11u;
    }

    /**
     * Set MMFR's TA field.
     *
     * Turn Around
     */
    inline void set_MMFR_TA(uint8_t value) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        MMFR = curr;
    }

    /**
     * Get MMFR's DATA field.
     *
     * Management Frame Data
     */
    inline uint16_t get_MMFR_DATA() volatile
    {
        return (MMFR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MMFR's DATA field.
     *
     * Management Frame Data
     */
    inline void set_MMFR_DATA(uint16_t value) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MMFR = curr;
    }

    /**
     * Get all of MMFR's bit fields.
     *
     * (read-write) MII Management Frame Register
     */
    inline void get_MMFR(uint8_t &ST, uint8_t &OP, uint8_t &PA, uint8_t &RA,
                         uint8_t &TA, uint16_t &DATA) volatile
    {
        uint32_t curr = MMFR;

        ST = (curr >> 30u) & 0b11u;
        OP = (curr >> 28u) & 0b11u;
        PA = (curr >> 23u) & 0b11111u;
        RA = (curr >> 18u) & 0b11111u;
        TA = (curr >> 16u) & 0b11u;
        DATA = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MMFR's bit fields.
     *
     * (read-write) MII Management Frame Register
     */
    inline void set_MMFR(uint8_t ST, uint8_t OP, uint8_t PA, uint8_t RA,
                         uint8_t TA, uint16_t DATA) volatile
    {
        uint32_t curr = MMFR;

        curr &= ~(0b11u << 30u);
        curr |= (ST & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (OP & 0b11u) << 28u;
        curr &= ~(0b11111u << 23u);
        curr |= (PA & 0b11111u) << 23u;
        curr &= ~(0b11111u << 18u);
        curr |= (RA & 0b11111u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (TA & 0b11u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (DATA & 0b1111111111111111u) << 0u;

        MMFR = curr;
    }

    /**
     * Get MSCR's HOLDTIME field.
     *
     * Hold time On MDIO Output
     */
    inline ENET_MSCR_HOLDTIME get_MSCR_HOLDTIME() volatile
    {
        return ENET_MSCR_HOLDTIME((MSCR >> 8u) & 0b111u);
    }

    /**
     * Set MSCR's HOLDTIME field.
     *
     * Hold time On MDIO Output
     */
    inline void set_MSCR_HOLDTIME(ENET_MSCR_HOLDTIME value) volatile
    {
        uint32_t curr = MSCR;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        MSCR = curr;
    }

    /**
     * Get MSCR's DIS_PRE bit.
     *
     * Disable Preamble
     */
    inline bool get_MSCR_DIS_PRE() volatile
    {
        return MSCR & (1u << 7u);
    }

    /**
     * Set MSCR's DIS_PRE bit.
     *
     * Disable Preamble
     */
    inline void set_MSCR_DIS_PRE() volatile
    {
        MSCR |= 1u << 7u;
    }

    /**
     * Clear MSCR's DIS_PRE bit.
     *
     * Disable Preamble
     */
    inline void clear_MSCR_DIS_PRE() volatile
    {
        MSCR &= ~(1u << 7u);
    }

    /**
     * Toggle MSCR's DIS_PRE bit.
     *
     * Disable Preamble
     */
    inline void toggle_MSCR_DIS_PRE() volatile
    {
        MSCR ^= 1u << 7u;
    }

    /**
     * Get MSCR's MII_SPEED field.
     *
     * MII Speed
     */
    inline uint8_t get_MSCR_MII_SPEED() volatile
    {
        return (MSCR >> 1u) & 0b111111u;
    }

    /**
     * Set MSCR's MII_SPEED field.
     *
     * MII Speed
     */
    inline void set_MSCR_MII_SPEED(uint8_t value) volatile
    {
        uint32_t curr = MSCR;

        curr &= ~(0b111111u << 1u);
        curr |= (value & 0b111111u) << 1u;

        MSCR = curr;
    }

    /**
     * Get all of MSCR's bit fields.
     *
     * (read-write) MII Speed Control Register
     */
    inline void get_MSCR(ENET_MSCR_HOLDTIME &HOLDTIME, bool &DIS_PRE,
                         uint8_t &MII_SPEED) volatile
    {
        uint32_t curr = MSCR;

        HOLDTIME = ENET_MSCR_HOLDTIME((curr >> 8u) & 0b111u);
        DIS_PRE = curr & (1u << 7u);
        MII_SPEED = (curr >> 1u) & 0b111111u;
    }

    /**
     * Set all of MSCR's bit fields.
     *
     * (read-write) MII Speed Control Register
     */
    inline void set_MSCR(ENET_MSCR_HOLDTIME HOLDTIME, bool DIS_PRE,
                         uint8_t MII_SPEED) volatile
    {
        uint32_t curr = MSCR;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(HOLDTIME) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (DIS_PRE & 0b1u) << 7u;
        curr &= ~(0b111111u << 1u);
        curr |= (MII_SPEED & 0b111111u) << 1u;

        MSCR = curr;
    }

    /**
     * Get MIBC's MIB_DIS bit.
     *
     * Disable MIB Logic
     */
    inline bool get_MIBC_MIB_DIS() volatile
    {
        return MIBC & (1u << 31u);
    }

    /**
     * Set MIBC's MIB_DIS bit.
     *
     * Disable MIB Logic
     */
    inline void set_MIBC_MIB_DIS() volatile
    {
        MIBC |= 1u << 31u;
    }

    /**
     * Clear MIBC's MIB_DIS bit.
     *
     * Disable MIB Logic
     */
    inline void clear_MIBC_MIB_DIS() volatile
    {
        MIBC &= ~(1u << 31u);
    }

    /**
     * Toggle MIBC's MIB_DIS bit.
     *
     * Disable MIB Logic
     */
    inline void toggle_MIBC_MIB_DIS() volatile
    {
        MIBC ^= 1u << 31u;
    }

    /**
     * Get MIBC's MIB_IDLE bit.
     *
     * MIB Idle
     */
    inline bool get_MIBC_MIB_IDLE() volatile
    {
        return MIBC & (1u << 30u);
    }

    /**
     * Get MIBC's MIB_CLEAR bit.
     *
     * MIB Clear
     */
    inline bool get_MIBC_MIB_CLEAR() volatile
    {
        return MIBC & (1u << 29u);
    }

    /**
     * Set MIBC's MIB_CLEAR bit.
     *
     * MIB Clear
     */
    inline void set_MIBC_MIB_CLEAR() volatile
    {
        MIBC |= 1u << 29u;
    }

    /**
     * Clear MIBC's MIB_CLEAR bit.
     *
     * MIB Clear
     */
    inline void clear_MIBC_MIB_CLEAR() volatile
    {
        MIBC &= ~(1u << 29u);
    }

    /**
     * Toggle MIBC's MIB_CLEAR bit.
     *
     * MIB Clear
     */
    inline void toggle_MIBC_MIB_CLEAR() volatile
    {
        MIBC ^= 1u << 29u;
    }

    /**
     * Get all of MIBC's bit fields.
     *
     * (read-write) MIB Control Register
     */
    inline void get_MIBC(bool &MIB_DIS, bool &MIB_IDLE,
                         bool &MIB_CLEAR) volatile
    {
        uint32_t curr = MIBC;

        MIB_DIS = curr & (1u << 31u);
        MIB_IDLE = curr & (1u << 30u);
        MIB_CLEAR = curr & (1u << 29u);
    }

    /**
     * Set all of MIBC's bit fields.
     *
     * (read-write) MIB Control Register
     */
    inline void set_MIBC(bool MIB_DIS, bool MIB_CLEAR) volatile
    {
        uint32_t curr = MIBC;

        curr &= ~(0b1u << 31u);
        curr |= (MIB_DIS & 0b1u) << 31u;
        curr &= ~(0b1u << 29u);
        curr |= (MIB_CLEAR & 0b1u) << 29u;

        MIBC = curr;
    }

    /**
     * Get RCR's GRS bit.
     *
     * Graceful Receive Stopped
     */
    inline bool get_RCR_GRS() volatile
    {
        return RCR & (1u << 31u);
    }

    /**
     * Get RCR's NLC bit.
     *
     * Payload Length Check Disable
     */
    inline bool get_RCR_NLC() volatile
    {
        return RCR & (1u << 30u);
    }

    /**
     * Set RCR's NLC bit.
     *
     * Payload Length Check Disable
     */
    inline void set_RCR_NLC() volatile
    {
        RCR |= 1u << 30u;
    }

    /**
     * Clear RCR's NLC bit.
     *
     * Payload Length Check Disable
     */
    inline void clear_RCR_NLC() volatile
    {
        RCR &= ~(1u << 30u);
    }

    /**
     * Toggle RCR's NLC bit.
     *
     * Payload Length Check Disable
     */
    inline void toggle_RCR_NLC() volatile
    {
        RCR ^= 1u << 30u;
    }

    /**
     * Get RCR's MAX_FL field.
     *
     * Maximum Frame Length
     */
    inline uint16_t get_RCR_MAX_FL() volatile
    {
        return (RCR >> 16u) & 0b11111111111111u;
    }

    /**
     * Set RCR's MAX_FL field.
     *
     * Maximum Frame Length
     */
    inline void set_RCR_MAX_FL(uint16_t value) volatile
    {
        uint32_t curr = RCR;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (value & 0b11111111111111u) << 16u;

        RCR = curr;
    }

    /**
     * Get RCR's CFEN bit.
     *
     * MAC Control Frame Enable
     */
    inline bool get_RCR_CFEN() volatile
    {
        return RCR & (1u << 15u);
    }

    /**
     * Set RCR's CFEN bit.
     *
     * MAC Control Frame Enable
     */
    inline void set_RCR_CFEN() volatile
    {
        RCR |= 1u << 15u;
    }

    /**
     * Clear RCR's CFEN bit.
     *
     * MAC Control Frame Enable
     */
    inline void clear_RCR_CFEN() volatile
    {
        RCR &= ~(1u << 15u);
    }

    /**
     * Toggle RCR's CFEN bit.
     *
     * MAC Control Frame Enable
     */
    inline void toggle_RCR_CFEN() volatile
    {
        RCR ^= 1u << 15u;
    }

    /**
     * Get RCR's CRCFWD bit.
     *
     * Terminate/Forward Received CRC
     */
    inline bool get_RCR_CRCFWD() volatile
    {
        return RCR & (1u << 14u);
    }

    /**
     * Set RCR's CRCFWD bit.
     *
     * Terminate/Forward Received CRC
     */
    inline void set_RCR_CRCFWD() volatile
    {
        RCR |= 1u << 14u;
    }

    /**
     * Clear RCR's CRCFWD bit.
     *
     * Terminate/Forward Received CRC
     */
    inline void clear_RCR_CRCFWD() volatile
    {
        RCR &= ~(1u << 14u);
    }

    /**
     * Toggle RCR's CRCFWD bit.
     *
     * Terminate/Forward Received CRC
     */
    inline void toggle_RCR_CRCFWD() volatile
    {
        RCR ^= 1u << 14u;
    }

    /**
     * Get RCR's PAUFWD bit.
     *
     * Terminate/Forward Pause Frames
     */
    inline bool get_RCR_PAUFWD() volatile
    {
        return RCR & (1u << 13u);
    }

    /**
     * Set RCR's PAUFWD bit.
     *
     * Terminate/Forward Pause Frames
     */
    inline void set_RCR_PAUFWD() volatile
    {
        RCR |= 1u << 13u;
    }

    /**
     * Clear RCR's PAUFWD bit.
     *
     * Terminate/Forward Pause Frames
     */
    inline void clear_RCR_PAUFWD() volatile
    {
        RCR &= ~(1u << 13u);
    }

    /**
     * Toggle RCR's PAUFWD bit.
     *
     * Terminate/Forward Pause Frames
     */
    inline void toggle_RCR_PAUFWD() volatile
    {
        RCR ^= 1u << 13u;
    }

    /**
     * Get RCR's PADEN bit.
     *
     * Enable Frame Padding Remove On Receive
     */
    inline bool get_RCR_PADEN() volatile
    {
        return RCR & (1u << 12u);
    }

    /**
     * Set RCR's PADEN bit.
     *
     * Enable Frame Padding Remove On Receive
     */
    inline void set_RCR_PADEN() volatile
    {
        RCR |= 1u << 12u;
    }

    /**
     * Clear RCR's PADEN bit.
     *
     * Enable Frame Padding Remove On Receive
     */
    inline void clear_RCR_PADEN() volatile
    {
        RCR &= ~(1u << 12u);
    }

    /**
     * Toggle RCR's PADEN bit.
     *
     * Enable Frame Padding Remove On Receive
     */
    inline void toggle_RCR_PADEN() volatile
    {
        RCR ^= 1u << 12u;
    }

    /**
     * Get RCR's RMII_10T bit.
     *
     * Enables 10-Mbit/s mode of the RMII .
     */
    inline bool get_RCR_RMII_10T() volatile
    {
        return RCR & (1u << 9u);
    }

    /**
     * Set RCR's RMII_10T bit.
     *
     * Enables 10-Mbit/s mode of the RMII .
     */
    inline void set_RCR_RMII_10T() volatile
    {
        RCR |= 1u << 9u;
    }

    /**
     * Clear RCR's RMII_10T bit.
     *
     * Enables 10-Mbit/s mode of the RMII .
     */
    inline void clear_RCR_RMII_10T() volatile
    {
        RCR &= ~(1u << 9u);
    }

    /**
     * Toggle RCR's RMII_10T bit.
     *
     * Enables 10-Mbit/s mode of the RMII .
     */
    inline void toggle_RCR_RMII_10T() volatile
    {
        RCR ^= 1u << 9u;
    }

    /**
     * Get RCR's RMII_MODE bit.
     *
     * RMII Mode Enable
     */
    inline bool get_RCR_RMII_MODE() volatile
    {
        return RCR & (1u << 8u);
    }

    /**
     * Set RCR's RMII_MODE bit.
     *
     * RMII Mode Enable
     */
    inline void set_RCR_RMII_MODE() volatile
    {
        RCR |= 1u << 8u;
    }

    /**
     * Clear RCR's RMII_MODE bit.
     *
     * RMII Mode Enable
     */
    inline void clear_RCR_RMII_MODE() volatile
    {
        RCR &= ~(1u << 8u);
    }

    /**
     * Toggle RCR's RMII_MODE bit.
     *
     * RMII Mode Enable
     */
    inline void toggle_RCR_RMII_MODE() volatile
    {
        RCR ^= 1u << 8u;
    }

    /**
     * Get RCR's FCE bit.
     *
     * Flow Control Enable
     */
    inline bool get_RCR_FCE() volatile
    {
        return RCR & (1u << 5u);
    }

    /**
     * Set RCR's FCE bit.
     *
     * Flow Control Enable
     */
    inline void set_RCR_FCE() volatile
    {
        RCR |= 1u << 5u;
    }

    /**
     * Clear RCR's FCE bit.
     *
     * Flow Control Enable
     */
    inline void clear_RCR_FCE() volatile
    {
        RCR &= ~(1u << 5u);
    }

    /**
     * Toggle RCR's FCE bit.
     *
     * Flow Control Enable
     */
    inline void toggle_RCR_FCE() volatile
    {
        RCR ^= 1u << 5u;
    }

    /**
     * Get RCR's BC_REJ bit.
     *
     * Broadcast Frame Reject
     */
    inline bool get_RCR_BC_REJ() volatile
    {
        return RCR & (1u << 4u);
    }

    /**
     * Set RCR's BC_REJ bit.
     *
     * Broadcast Frame Reject
     */
    inline void set_RCR_BC_REJ() volatile
    {
        RCR |= 1u << 4u;
    }

    /**
     * Clear RCR's BC_REJ bit.
     *
     * Broadcast Frame Reject
     */
    inline void clear_RCR_BC_REJ() volatile
    {
        RCR &= ~(1u << 4u);
    }

    /**
     * Toggle RCR's BC_REJ bit.
     *
     * Broadcast Frame Reject
     */
    inline void toggle_RCR_BC_REJ() volatile
    {
        RCR ^= 1u << 4u;
    }

    /**
     * Get RCR's PROM bit.
     *
     * Promiscuous Mode
     */
    inline bool get_RCR_PROM() volatile
    {
        return RCR & (1u << 3u);
    }

    /**
     * Set RCR's PROM bit.
     *
     * Promiscuous Mode
     */
    inline void set_RCR_PROM() volatile
    {
        RCR |= 1u << 3u;
    }

    /**
     * Clear RCR's PROM bit.
     *
     * Promiscuous Mode
     */
    inline void clear_RCR_PROM() volatile
    {
        RCR &= ~(1u << 3u);
    }

    /**
     * Toggle RCR's PROM bit.
     *
     * Promiscuous Mode
     */
    inline void toggle_RCR_PROM() volatile
    {
        RCR ^= 1u << 3u;
    }

    /**
     * Get RCR's MII_MODE bit.
     *
     * Media Independent Interface Mode
     */
    inline bool get_RCR_MII_MODE() volatile
    {
        return RCR & (1u << 2u);
    }

    /**
     * Set RCR's MII_MODE bit.
     *
     * Media Independent Interface Mode
     */
    inline void set_RCR_MII_MODE() volatile
    {
        RCR |= 1u << 2u;
    }

    /**
     * Clear RCR's MII_MODE bit.
     *
     * Media Independent Interface Mode
     */
    inline void clear_RCR_MII_MODE() volatile
    {
        RCR &= ~(1u << 2u);
    }

    /**
     * Toggle RCR's MII_MODE bit.
     *
     * Media Independent Interface Mode
     */
    inline void toggle_RCR_MII_MODE() volatile
    {
        RCR ^= 1u << 2u;
    }

    /**
     * Get RCR's DRT bit.
     *
     * Disable Receive On Transmit
     */
    inline bool get_RCR_DRT() volatile
    {
        return RCR & (1u << 1u);
    }

    /**
     * Set RCR's DRT bit.
     *
     * Disable Receive On Transmit
     */
    inline void set_RCR_DRT() volatile
    {
        RCR |= 1u << 1u;
    }

    /**
     * Clear RCR's DRT bit.
     *
     * Disable Receive On Transmit
     */
    inline void clear_RCR_DRT() volatile
    {
        RCR &= ~(1u << 1u);
    }

    /**
     * Toggle RCR's DRT bit.
     *
     * Disable Receive On Transmit
     */
    inline void toggle_RCR_DRT() volatile
    {
        RCR ^= 1u << 1u;
    }

    /**
     * Get RCR's LOOP bit.
     *
     * Internal Loopback
     */
    inline bool get_RCR_LOOP() volatile
    {
        return RCR & (1u << 0u);
    }

    /**
     * Set RCR's LOOP bit.
     *
     * Internal Loopback
     */
    inline void set_RCR_LOOP() volatile
    {
        RCR |= 1u << 0u;
    }

    /**
     * Clear RCR's LOOP bit.
     *
     * Internal Loopback
     */
    inline void clear_RCR_LOOP() volatile
    {
        RCR &= ~(1u << 0u);
    }

    /**
     * Toggle RCR's LOOP bit.
     *
     * Internal Loopback
     */
    inline void toggle_RCR_LOOP() volatile
    {
        RCR ^= 1u << 0u;
    }

    /**
     * Get all of RCR's bit fields.
     *
     * (read-write) Receive Control Register
     */
    inline void get_RCR(bool &GRS, bool &NLC, uint16_t &MAX_FL, bool &CFEN,
                        bool &CRCFWD, bool &PAUFWD, bool &PADEN,
                        bool &RMII_10T, bool &RMII_MODE, bool &FCE,
                        bool &BC_REJ, bool &PROM, bool &MII_MODE, bool &DRT,
                        bool &LOOP) volatile
    {
        uint32_t curr = RCR;

        GRS = curr & (1u << 31u);
        NLC = curr & (1u << 30u);
        MAX_FL = (curr >> 16u) & 0b11111111111111u;
        CFEN = curr & (1u << 15u);
        CRCFWD = curr & (1u << 14u);
        PAUFWD = curr & (1u << 13u);
        PADEN = curr & (1u << 12u);
        RMII_10T = curr & (1u << 9u);
        RMII_MODE = curr & (1u << 8u);
        FCE = curr & (1u << 5u);
        BC_REJ = curr & (1u << 4u);
        PROM = curr & (1u << 3u);
        MII_MODE = curr & (1u << 2u);
        DRT = curr & (1u << 1u);
        LOOP = curr & (1u << 0u);
    }

    /**
     * Set all of RCR's bit fields.
     *
     * (read-write) Receive Control Register
     */
    inline void set_RCR(bool NLC, uint16_t MAX_FL, bool CFEN, bool CRCFWD,
                        bool PAUFWD, bool PADEN, bool RMII_10T, bool RMII_MODE,
                        bool FCE, bool BC_REJ, bool PROM, bool MII_MODE,
                        bool DRT, bool LOOP) volatile
    {
        uint32_t curr = RCR;

        curr &= ~(0b1u << 30u);
        curr |= (NLC & 0b1u) << 30u;
        curr &= ~(0b11111111111111u << 16u);
        curr |= (MAX_FL & 0b11111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (CFEN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (CRCFWD & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (PAUFWD & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PADEN & 0b1u) << 12u;
        curr &= ~(0b1u << 9u);
        curr |= (RMII_10T & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RMII_MODE & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (FCE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BC_REJ & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PROM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (MII_MODE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DRT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (LOOP & 0b1u) << 0u;

        RCR = curr;
    }

    /**
     * Get TCR's CRCFWD bit.
     *
     * Forward Frame From Application With CRC
     */
    inline bool get_TCR_CRCFWD() volatile
    {
        return TCR & (1u << 9u);
    }

    /**
     * Set TCR's CRCFWD bit.
     *
     * Forward Frame From Application With CRC
     */
    inline void set_TCR_CRCFWD() volatile
    {
        TCR |= 1u << 9u;
    }

    /**
     * Clear TCR's CRCFWD bit.
     *
     * Forward Frame From Application With CRC
     */
    inline void clear_TCR_CRCFWD() volatile
    {
        TCR &= ~(1u << 9u);
    }

    /**
     * Toggle TCR's CRCFWD bit.
     *
     * Forward Frame From Application With CRC
     */
    inline void toggle_TCR_CRCFWD() volatile
    {
        TCR ^= 1u << 9u;
    }

    /**
     * Get TCR's ADDINS bit.
     *
     * Set MAC Address On Transmit
     */
    inline bool get_TCR_ADDINS() volatile
    {
        return TCR & (1u << 8u);
    }

    /**
     * Set TCR's ADDINS bit.
     *
     * Set MAC Address On Transmit
     */
    inline void set_TCR_ADDINS() volatile
    {
        TCR |= 1u << 8u;
    }

    /**
     * Clear TCR's ADDINS bit.
     *
     * Set MAC Address On Transmit
     */
    inline void clear_TCR_ADDINS() volatile
    {
        TCR &= ~(1u << 8u);
    }

    /**
     * Toggle TCR's ADDINS bit.
     *
     * Set MAC Address On Transmit
     */
    inline void toggle_TCR_ADDINS() volatile
    {
        TCR ^= 1u << 8u;
    }

    /**
     * Get TCR's ADDSEL field.
     *
     * Source MAC Address Select On Transmit
     */
    inline ENET_TCR_ADDSEL get_TCR_ADDSEL() volatile
    {
        return ENET_TCR_ADDSEL((TCR >> 5u) & 0b111u);
    }

    /**
     * Set TCR's ADDSEL field.
     *
     * Source MAC Address Select On Transmit
     */
    inline void set_TCR_ADDSEL(ENET_TCR_ADDSEL value) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        TCR = curr;
    }

    /**
     * Get TCR's RFC_PAUSE bit.
     *
     * Receive Frame Control Pause
     */
    inline bool get_TCR_RFC_PAUSE() volatile
    {
        return TCR & (1u << 4u);
    }

    /**
     * Get TCR's TFC_PAUSE bit.
     *
     * Transmit Frame Control Pause
     */
    inline bool get_TCR_TFC_PAUSE() volatile
    {
        return TCR & (1u << 3u);
    }

    /**
     * Set TCR's TFC_PAUSE bit.
     *
     * Transmit Frame Control Pause
     */
    inline void set_TCR_TFC_PAUSE() volatile
    {
        TCR |= 1u << 3u;
    }

    /**
     * Clear TCR's TFC_PAUSE bit.
     *
     * Transmit Frame Control Pause
     */
    inline void clear_TCR_TFC_PAUSE() volatile
    {
        TCR &= ~(1u << 3u);
    }

    /**
     * Toggle TCR's TFC_PAUSE bit.
     *
     * Transmit Frame Control Pause
     */
    inline void toggle_TCR_TFC_PAUSE() volatile
    {
        TCR ^= 1u << 3u;
    }

    /**
     * Get TCR's FDEN bit.
     *
     * Full-Duplex Enable
     */
    inline bool get_TCR_FDEN() volatile
    {
        return TCR & (1u << 2u);
    }

    /**
     * Set TCR's FDEN bit.
     *
     * Full-Duplex Enable
     */
    inline void set_TCR_FDEN() volatile
    {
        TCR |= 1u << 2u;
    }

    /**
     * Clear TCR's FDEN bit.
     *
     * Full-Duplex Enable
     */
    inline void clear_TCR_FDEN() volatile
    {
        TCR &= ~(1u << 2u);
    }

    /**
     * Toggle TCR's FDEN bit.
     *
     * Full-Duplex Enable
     */
    inline void toggle_TCR_FDEN() volatile
    {
        TCR ^= 1u << 2u;
    }

    /**
     * Get TCR's GTS bit.
     *
     * Graceful Transmit Stop
     */
    inline bool get_TCR_GTS() volatile
    {
        return TCR & (1u << 0u);
    }

    /**
     * Set TCR's GTS bit.
     *
     * Graceful Transmit Stop
     */
    inline void set_TCR_GTS() volatile
    {
        TCR |= 1u << 0u;
    }

    /**
     * Clear TCR's GTS bit.
     *
     * Graceful Transmit Stop
     */
    inline void clear_TCR_GTS() volatile
    {
        TCR &= ~(1u << 0u);
    }

    /**
     * Toggle TCR's GTS bit.
     *
     * Graceful Transmit Stop
     */
    inline void toggle_TCR_GTS() volatile
    {
        TCR ^= 1u << 0u;
    }

    /**
     * Get all of TCR's bit fields.
     *
     * (read-write) Transmit Control Register
     */
    inline void get_TCR(bool &CRCFWD, bool &ADDINS, ENET_TCR_ADDSEL &ADDSEL,
                        bool &RFC_PAUSE, bool &TFC_PAUSE, bool &FDEN,
                        bool &GTS) volatile
    {
        uint32_t curr = TCR;

        CRCFWD = curr & (1u << 9u);
        ADDINS = curr & (1u << 8u);
        ADDSEL = ENET_TCR_ADDSEL((curr >> 5u) & 0b111u);
        RFC_PAUSE = curr & (1u << 4u);
        TFC_PAUSE = curr & (1u << 3u);
        FDEN = curr & (1u << 2u);
        GTS = curr & (1u << 0u);
    }

    /**
     * Set all of TCR's bit fields.
     *
     * (read-write) Transmit Control Register
     */
    inline void set_TCR(bool CRCFWD, bool ADDINS, ENET_TCR_ADDSEL ADDSEL,
                        bool TFC_PAUSE, bool FDEN, bool GTS) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b1u << 9u);
        curr |= (CRCFWD & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (ADDINS & 0b1u) << 8u;
        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(ADDSEL) & 0b111u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (TFC_PAUSE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FDEN & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (GTS & 0b1u) << 0u;

        TCR = curr;
    }

    /**
     * Get PALR's PADDR1 field.
     *
     * Pause Address
     */
    inline uint32_t get_PALR_PADDR1() volatile
    {
        return (PALR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PALR's PADDR1 field.
     *
     * Pause Address
     */
    inline void set_PALR_PADDR1(uint32_t value) volatile
    {
        uint32_t curr = PALR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PALR = curr;
    }

    /**
     * Get PAUR's PADDR2 field.
     *
     * Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address
     * used for exact match, and the source address field in PAUSE frames
     */
    inline uint16_t get_PAUR_PADDR2() volatile
    {
        return (PAUR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set PAUR's PADDR2 field.
     *
     * Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address
     * used for exact match, and the source address field in PAUSE frames
     */
    inline void set_PAUR_PADDR2(uint16_t value) volatile
    {
        uint32_t curr = PAUR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        PAUR = curr;
    }

    /**
     * Get PAUR's TYPE field.
     *
     * Type Field In PAUSE Frames
     */
    inline uint16_t get_PAUR_TYPE() volatile
    {
        return (PAUR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of PAUR's bit fields.
     *
     * (read-write) Physical Address Upper Register
     */
    inline void get_PAUR(uint16_t &PADDR2, uint16_t &TYPE) volatile
    {
        uint32_t curr = PAUR;

        PADDR2 = (curr >> 16u) & 0b1111111111111111u;
        TYPE = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get OPD's OPCODE field.
     *
     * Opcode Field In PAUSE Frames
     */
    inline uint16_t get_OPD_OPCODE() volatile
    {
        return (OPD >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get OPD's PAUSE_DUR field.
     *
     * Pause Duration
     */
    inline uint16_t get_OPD_PAUSE_DUR() volatile
    {
        return (OPD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set OPD's PAUSE_DUR field.
     *
     * Pause Duration
     */
    inline void set_OPD_PAUSE_DUR(uint16_t value) volatile
    {
        uint32_t curr = OPD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        OPD = curr;
    }

    /**
     * Get all of OPD's bit fields.
     *
     * (read-write) Opcode/Pause Duration Register
     */
    inline void get_OPD(uint16_t &OPCODE, uint16_t &PAUSE_DUR) volatile
    {
        uint32_t curr = OPD;

        OPCODE = (curr >> 16u) & 0b1111111111111111u;
        PAUSE_DUR = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get TXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline bool get_TXIC_ICEN(std::size_t index) volatile
    {
        return TXIC[index] & (1u << 31u);
    }

    /**
     * Set TXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline void set_TXIC_ICEN() volatile
    {
        TXIC |= 1u << 31u;
    }

    /**
     * Clear TXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline void clear_TXIC_ICEN() volatile
    {
        TXIC &= ~(1u << 31u);
    }

    /**
     * Toggle TXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline void toggle_TXIC_ICEN() volatile
    {
        TXIC ^= 1u << 31u;
    }

    /**
     * Get TXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline bool get_TXIC_ICCS(std::size_t index) volatile
    {
        return TXIC[index] & (1u << 30u);
    }

    /**
     * Set TXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline void set_TXIC_ICCS() volatile
    {
        TXIC |= 1u << 30u;
    }

    /**
     * Clear TXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline void clear_TXIC_ICCS() volatile
    {
        TXIC &= ~(1u << 30u);
    }

    /**
     * Toggle TXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline void toggle_TXIC_ICCS() volatile
    {
        TXIC ^= 1u << 30u;
    }

    /**
     * Get TXIC's ICFT field.
     *
     * Interrupt coalescing frame count threshold
     */
    inline uint8_t get_TXIC_ICFT(std::size_t index) volatile
    {
        return (TXIC[index] >> 20u) & 0b11111111u;
    }

    /**
     * Set TXIC's ICFT field.
     *
     * Interrupt coalescing frame count threshold
     */
    inline void set_TXIC_ICFT(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = TXIC[index];

        curr &= ~(0b11111111u << 20u);
        curr |= (value & 0b11111111u) << 20u;

        TXIC[index] = curr;
    }

    /**
     * Get TXIC's ICTT field.
     *
     * Interrupt coalescing timer threshold
     */
    inline uint16_t get_TXIC_ICTT(std::size_t index) volatile
    {
        return (TXIC[index] >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TXIC's ICTT field.
     *
     * Interrupt coalescing timer threshold
     */
    inline void set_TXIC_ICTT(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = TXIC[index];

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TXIC[index] = curr;
    }

    /**
     * Get all of TXIC's bit fields.
     *
     * (read-write) Transmit Interrupt Coalescing Register
     */
    inline void get_TXIC(std::size_t index, bool &ICEN, bool &ICCS,
                         uint8_t &ICFT, uint16_t &ICTT) volatile
    {
        uint32_t curr = TXIC[index];

        ICEN = curr & (1u << 31u);
        ICCS = curr & (1u << 30u);
        ICFT = (curr >> 20u) & 0b11111111u;
        ICTT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of TXIC's bit fields.
     *
     * (read-write) Transmit Interrupt Coalescing Register
     */
    inline void set_TXIC(std::size_t index, bool ICEN, bool ICCS, uint8_t ICFT,
                         uint16_t ICTT) volatile
    {
        uint32_t curr = TXIC[index];

        curr &= ~(0b1u << 31u);
        curr |= (ICEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (ICCS & 0b1u) << 30u;
        curr &= ~(0b11111111u << 20u);
        curr |= (ICFT & 0b11111111u) << 20u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ICTT & 0b1111111111111111u) << 0u;

        TXIC[index] = curr;
    }

    /**
     * Get RXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline bool get_RXIC_ICEN(std::size_t index) volatile
    {
        return RXIC[index] & (1u << 31u);
    }

    /**
     * Set RXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline void set_RXIC_ICEN() volatile
    {
        RXIC |= 1u << 31u;
    }

    /**
     * Clear RXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline void clear_RXIC_ICEN() volatile
    {
        RXIC &= ~(1u << 31u);
    }

    /**
     * Toggle RXIC's ICEN bit.
     *
     * Interrupt Coalescing Enable
     */
    inline void toggle_RXIC_ICEN() volatile
    {
        RXIC ^= 1u << 31u;
    }

    /**
     * Get RXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline bool get_RXIC_ICCS(std::size_t index) volatile
    {
        return RXIC[index] & (1u << 30u);
    }

    /**
     * Set RXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline void set_RXIC_ICCS() volatile
    {
        RXIC |= 1u << 30u;
    }

    /**
     * Clear RXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline void clear_RXIC_ICCS() volatile
    {
        RXIC &= ~(1u << 30u);
    }

    /**
     * Toggle RXIC's ICCS bit.
     *
     * Interrupt Coalescing Timer Clock Source Select
     */
    inline void toggle_RXIC_ICCS() volatile
    {
        RXIC ^= 1u << 30u;
    }

    /**
     * Get RXIC's ICFT field.
     *
     * Interrupt coalescing frame count threshold
     */
    inline uint8_t get_RXIC_ICFT(std::size_t index) volatile
    {
        return (RXIC[index] >> 20u) & 0b11111111u;
    }

    /**
     * Set RXIC's ICFT field.
     *
     * Interrupt coalescing frame count threshold
     */
    inline void set_RXIC_ICFT(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = RXIC[index];

        curr &= ~(0b11111111u << 20u);
        curr |= (value & 0b11111111u) << 20u;

        RXIC[index] = curr;
    }

    /**
     * Get RXIC's ICTT field.
     *
     * Interrupt coalescing timer threshold
     */
    inline uint16_t get_RXIC_ICTT(std::size_t index) volatile
    {
        return (RXIC[index] >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set RXIC's ICTT field.
     *
     * Interrupt coalescing timer threshold
     */
    inline void set_RXIC_ICTT(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = RXIC[index];

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        RXIC[index] = curr;
    }

    /**
     * Get all of RXIC's bit fields.
     *
     * (read-write) Receive Interrupt Coalescing Register
     */
    inline void get_RXIC(std::size_t index, bool &ICEN, bool &ICCS,
                         uint8_t &ICFT, uint16_t &ICTT) volatile
    {
        uint32_t curr = RXIC[index];

        ICEN = curr & (1u << 31u);
        ICCS = curr & (1u << 30u);
        ICFT = (curr >> 20u) & 0b11111111u;
        ICTT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of RXIC's bit fields.
     *
     * (read-write) Receive Interrupt Coalescing Register
     */
    inline void set_RXIC(std::size_t index, bool ICEN, bool ICCS, uint8_t ICFT,
                         uint16_t ICTT) volatile
    {
        uint32_t curr = RXIC[index];

        curr &= ~(0b1u << 31u);
        curr |= (ICEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (ICCS & 0b1u) << 30u;
        curr &= ~(0b11111111u << 20u);
        curr |= (ICFT & 0b11111111u) << 20u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ICTT & 0b1111111111111111u) << 0u;

        RXIC[index] = curr;
    }

    /**
     * Get IAUR's IADDR1 field.
     *
     * Contains the upper 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a unicast address
     */
    inline uint32_t get_IAUR_IADDR1() volatile
    {
        return (IAUR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IAUR's IADDR1 field.
     *
     * Contains the upper 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a unicast address
     */
    inline void set_IAUR_IADDR1(uint32_t value) volatile
    {
        uint32_t curr = IAUR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IAUR = curr;
    }

    /**
     * Get IALR's IADDR2 field.
     *
     * Contains the lower 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a unicast address
     */
    inline uint32_t get_IALR_IADDR2() volatile
    {
        return (IALR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IALR's IADDR2 field.
     *
     * Contains the lower 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a unicast address
     */
    inline void set_IALR_IADDR2(uint32_t value) volatile
    {
        uint32_t curr = IALR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IALR = curr;
    }

    /**
     * Get GAUR's GADDR1 field.
     *
     * Contains the upper 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a multicast address
     */
    inline uint32_t get_GAUR_GADDR1() volatile
    {
        return (GAUR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set GAUR's GADDR1 field.
     *
     * Contains the upper 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a multicast address
     */
    inline void set_GAUR_GADDR1(uint32_t value) volatile
    {
        uint32_t curr = GAUR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        GAUR = curr;
    }

    /**
     * Get GALR's GADDR2 field.
     *
     * Contains the lower 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a multicast address
     */
    inline uint32_t get_GALR_GADDR2() volatile
    {
        return (GALR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set GALR's GADDR2 field.
     *
     * Contains the lower 32 bits of the 64-bit hash table used in the address
     * recognition process for receive frames with a multicast address
     */
    inline void set_GALR_GADDR2(uint32_t value) volatile
    {
        uint32_t curr = GALR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        GALR = curr;
    }

    /**
     * Get TFWR's STRFWD bit.
     *
     * Store And Forward Enable
     */
    inline bool get_TFWR_STRFWD() volatile
    {
        return TFWR & (1u << 8u);
    }

    /**
     * Set TFWR's STRFWD bit.
     *
     * Store And Forward Enable
     */
    inline void set_TFWR_STRFWD() volatile
    {
        TFWR |= 1u << 8u;
    }

    /**
     * Clear TFWR's STRFWD bit.
     *
     * Store And Forward Enable
     */
    inline void clear_TFWR_STRFWD() volatile
    {
        TFWR &= ~(1u << 8u);
    }

    /**
     * Toggle TFWR's STRFWD bit.
     *
     * Store And Forward Enable
     */
    inline void toggle_TFWR_STRFWD() volatile
    {
        TFWR ^= 1u << 8u;
    }

    /**
     * Get TFWR's TFWR field.
     *
     * Transmit FIFO Write
     */
    inline ENET_TFWR_TFWR get_TFWR_TFWR() volatile
    {
        return ENET_TFWR_TFWR((TFWR >> 0u) & 0b111111u);
    }

    /**
     * Set TFWR's TFWR field.
     *
     * Transmit FIFO Write
     */
    inline void set_TFWR_TFWR(ENET_TFWR_TFWR value) volatile
    {
        uint32_t curr = TFWR;

        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111u) << 0u;

        TFWR = curr;
    }

    /**
     * Get all of TFWR's bit fields.
     *
     * (read-write) Transmit FIFO Watermark Register
     */
    inline void get_TFWR(bool &STRFWD, ENET_TFWR_TFWR &TFWR) volatile
    {
        uint32_t curr = TFWR;

        STRFWD = curr & (1u << 8u);
        TFWR = ENET_TFWR_TFWR((curr >> 0u) & 0b111111u);
    }

    /**
     * Set all of TFWR's bit fields.
     *
     * (read-write) Transmit FIFO Watermark Register
     */
    inline void set_TFWR(bool STRFWD, ENET_TFWR_TFWR TFWR) volatile
    {
        uint32_t curr = TFWR;

        curr &= ~(0b1u << 8u);
        curr |= (STRFWD & 0b1u) << 8u;
        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(TFWR) & 0b111111u) << 0u;

        TFWR = curr;
    }

    /**
     * Get RDSR's R_DES_START field.
     *
     * Pointer to the beginning of the receive buffer descriptor queue.
     */
    inline uint32_t get_RDSR_R_DES_START() volatile
    {
        return (RDSR >> 3u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set RDSR's R_DES_START field.
     *
     * Pointer to the beginning of the receive buffer descriptor queue.
     */
    inline void set_RDSR_R_DES_START(uint32_t value) volatile
    {
        uint32_t curr = RDSR;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        RDSR = curr;
    }

    /**
     * Get TDSR's X_DES_START field.
     *
     * Pointer to the beginning of the transmit buffer descriptor queue.
     */
    inline uint32_t get_TDSR_X_DES_START() volatile
    {
        return (TDSR >> 3u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set TDSR's X_DES_START field.
     *
     * Pointer to the beginning of the transmit buffer descriptor queue.
     */
    inline void set_TDSR_X_DES_START(uint32_t value) volatile
    {
        uint32_t curr = TDSR;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        TDSR = curr;
    }

    /**
     * Get MRBR's R_BUF_SIZE field.
     *
     * Receive buffer size in bytes
     */
    inline uint16_t get_MRBR_R_BUF_SIZE() volatile
    {
        return (MRBR >> 4u) & 0b1111111111u;
    }

    /**
     * Set MRBR's R_BUF_SIZE field.
     *
     * Receive buffer size in bytes
     */
    inline void set_MRBR_R_BUF_SIZE(uint16_t value) volatile
    {
        uint32_t curr = MRBR;

        curr &= ~(0b1111111111u << 4u);
        curr |= (value & 0b1111111111u) << 4u;

        MRBR = curr;
    }

    /**
     * Get RSFL's RX_SECTION_FULL field.
     *
     * Value Of Receive FIFO Section Full Threshold
     */
    inline uint8_t get_RSFL_RX_SECTION_FULL() volatile
    {
        return (RSFL >> 0u) & 0b11111111u;
    }

    /**
     * Set RSFL's RX_SECTION_FULL field.
     *
     * Value Of Receive FIFO Section Full Threshold
     */
    inline void set_RSFL_RX_SECTION_FULL(uint8_t value) volatile
    {
        uint32_t curr = RSFL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        RSFL = curr;
    }

    /**
     * Get RSEM's STAT_SECTION_EMPTY field.
     *
     * RX Status FIFO Section Empty Threshold
     */
    inline uint8_t get_RSEM_STAT_SECTION_EMPTY() volatile
    {
        return (RSEM >> 16u) & 0b11111u;
    }

    /**
     * Set RSEM's STAT_SECTION_EMPTY field.
     *
     * RX Status FIFO Section Empty Threshold
     */
    inline void set_RSEM_STAT_SECTION_EMPTY(uint8_t value) volatile
    {
        uint32_t curr = RSEM;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        RSEM = curr;
    }

    /**
     * Get RSEM's RX_SECTION_EMPTY field.
     *
     * Value Of The Receive FIFO Section Empty Threshold
     */
    inline uint8_t get_RSEM_RX_SECTION_EMPTY() volatile
    {
        return (RSEM >> 0u) & 0b11111111u;
    }

    /**
     * Set RSEM's RX_SECTION_EMPTY field.
     *
     * Value Of The Receive FIFO Section Empty Threshold
     */
    inline void set_RSEM_RX_SECTION_EMPTY(uint8_t value) volatile
    {
        uint32_t curr = RSEM;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        RSEM = curr;
    }

    /**
     * Get all of RSEM's bit fields.
     *
     * (read-write) Receive FIFO Section Empty Threshold
     */
    inline void get_RSEM(uint8_t &STAT_SECTION_EMPTY,
                         uint8_t &RX_SECTION_EMPTY) volatile
    {
        uint32_t curr = RSEM;

        STAT_SECTION_EMPTY = (curr >> 16u) & 0b11111u;
        RX_SECTION_EMPTY = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of RSEM's bit fields.
     *
     * (read-write) Receive FIFO Section Empty Threshold
     */
    inline void set_RSEM(uint8_t STAT_SECTION_EMPTY,
                         uint8_t RX_SECTION_EMPTY) volatile
    {
        uint32_t curr = RSEM;

        curr &= ~(0b11111u << 16u);
        curr |= (STAT_SECTION_EMPTY & 0b11111u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RX_SECTION_EMPTY & 0b11111111u) << 0u;

        RSEM = curr;
    }

    /**
     * Get RAEM's RX_ALMOST_EMPTY field.
     *
     * Value Of The Receive FIFO Almost Empty Threshold
     */
    inline uint8_t get_RAEM_RX_ALMOST_EMPTY() volatile
    {
        return (RAEM >> 0u) & 0b11111111u;
    }

    /**
     * Set RAEM's RX_ALMOST_EMPTY field.
     *
     * Value Of The Receive FIFO Almost Empty Threshold
     */
    inline void set_RAEM_RX_ALMOST_EMPTY(uint8_t value) volatile
    {
        uint32_t curr = RAEM;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        RAEM = curr;
    }

    /**
     * Get RAFL's RX_ALMOST_FULL field.
     *
     * Value Of The Receive FIFO Almost Full Threshold
     */
    inline uint8_t get_RAFL_RX_ALMOST_FULL() volatile
    {
        return (RAFL >> 0u) & 0b11111111u;
    }

    /**
     * Set RAFL's RX_ALMOST_FULL field.
     *
     * Value Of The Receive FIFO Almost Full Threshold
     */
    inline void set_RAFL_RX_ALMOST_FULL(uint8_t value) volatile
    {
        uint32_t curr = RAFL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        RAFL = curr;
    }

    /**
     * Get TSEM's TX_SECTION_EMPTY field.
     *
     * Value Of The Transmit FIFO Section Empty Threshold
     */
    inline uint8_t get_TSEM_TX_SECTION_EMPTY() volatile
    {
        return (TSEM >> 0u) & 0b11111111u;
    }

    /**
     * Set TSEM's TX_SECTION_EMPTY field.
     *
     * Value Of The Transmit FIFO Section Empty Threshold
     */
    inline void set_TSEM_TX_SECTION_EMPTY(uint8_t value) volatile
    {
        uint32_t curr = TSEM;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TSEM = curr;
    }

    /**
     * Get TAEM's TX_ALMOST_EMPTY field.
     *
     * Value of Transmit FIFO Almost Empty Threshold
     */
    inline uint8_t get_TAEM_TX_ALMOST_EMPTY() volatile
    {
        return (TAEM >> 0u) & 0b11111111u;
    }

    /**
     * Set TAEM's TX_ALMOST_EMPTY field.
     *
     * Value of Transmit FIFO Almost Empty Threshold
     */
    inline void set_TAEM_TX_ALMOST_EMPTY(uint8_t value) volatile
    {
        uint32_t curr = TAEM;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TAEM = curr;
    }

    /**
     * Get TAFL's TX_ALMOST_FULL field.
     *
     * Value Of The Transmit FIFO Almost Full Threshold
     */
    inline uint8_t get_TAFL_TX_ALMOST_FULL() volatile
    {
        return (TAFL >> 0u) & 0b11111111u;
    }

    /**
     * Set TAFL's TX_ALMOST_FULL field.
     *
     * Value Of The Transmit FIFO Almost Full Threshold
     */
    inline void set_TAFL_TX_ALMOST_FULL(uint8_t value) volatile
    {
        uint32_t curr = TAFL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TAFL = curr;
    }

    /**
     * Get TIPG's IPG field.
     *
     * Transmit Inter-Packet Gap
     */
    inline uint8_t get_TIPG_IPG() volatile
    {
        return (TIPG >> 0u) & 0b11111u;
    }

    /**
     * Set TIPG's IPG field.
     *
     * Transmit Inter-Packet Gap
     */
    inline void set_TIPG_IPG(uint8_t value) volatile
    {
        uint32_t curr = TIPG;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        TIPG = curr;
    }

    /**
     * Get FTRL's TRUNC_FL field.
     *
     * Frame Truncation Length
     */
    inline uint16_t get_FTRL_TRUNC_FL() volatile
    {
        return (FTRL >> 0u) & 0b11111111111111u;
    }

    /**
     * Set FTRL's TRUNC_FL field.
     *
     * Frame Truncation Length
     */
    inline void set_FTRL_TRUNC_FL(uint16_t value) volatile
    {
        uint32_t curr = FTRL;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        FTRL = curr;
    }

    /**
     * Get TACC's PROCHK bit.
     *
     * Enables insertion of protocol checksum.
     */
    inline bool get_TACC_PROCHK() volatile
    {
        return TACC & (1u << 4u);
    }

    /**
     * Set TACC's PROCHK bit.
     *
     * Enables insertion of protocol checksum.
     */
    inline void set_TACC_PROCHK() volatile
    {
        TACC |= 1u << 4u;
    }

    /**
     * Clear TACC's PROCHK bit.
     *
     * Enables insertion of protocol checksum.
     */
    inline void clear_TACC_PROCHK() volatile
    {
        TACC &= ~(1u << 4u);
    }

    /**
     * Toggle TACC's PROCHK bit.
     *
     * Enables insertion of protocol checksum.
     */
    inline void toggle_TACC_PROCHK() volatile
    {
        TACC ^= 1u << 4u;
    }

    /**
     * Get TACC's IPCHK bit.
     *
     * Enables insertion of IP header checksum.
     */
    inline bool get_TACC_IPCHK() volatile
    {
        return TACC & (1u << 3u);
    }

    /**
     * Set TACC's IPCHK bit.
     *
     * Enables insertion of IP header checksum.
     */
    inline void set_TACC_IPCHK() volatile
    {
        TACC |= 1u << 3u;
    }

    /**
     * Clear TACC's IPCHK bit.
     *
     * Enables insertion of IP header checksum.
     */
    inline void clear_TACC_IPCHK() volatile
    {
        TACC &= ~(1u << 3u);
    }

    /**
     * Toggle TACC's IPCHK bit.
     *
     * Enables insertion of IP header checksum.
     */
    inline void toggle_TACC_IPCHK() volatile
    {
        TACC ^= 1u << 3u;
    }

    /**
     * Get TACC's SHIFT16 bit.
     *
     * TX FIFO Shift-16
     */
    inline bool get_TACC_SHIFT16() volatile
    {
        return TACC & (1u << 0u);
    }

    /**
     * Set TACC's SHIFT16 bit.
     *
     * TX FIFO Shift-16
     */
    inline void set_TACC_SHIFT16() volatile
    {
        TACC |= 1u << 0u;
    }

    /**
     * Clear TACC's SHIFT16 bit.
     *
     * TX FIFO Shift-16
     */
    inline void clear_TACC_SHIFT16() volatile
    {
        TACC &= ~(1u << 0u);
    }

    /**
     * Toggle TACC's SHIFT16 bit.
     *
     * TX FIFO Shift-16
     */
    inline void toggle_TACC_SHIFT16() volatile
    {
        TACC ^= 1u << 0u;
    }

    /**
     * Get all of TACC's bit fields.
     *
     * (read-write) Transmit Accelerator Function Configuration
     */
    inline void get_TACC(bool &PROCHK, bool &IPCHK, bool &SHIFT16) volatile
    {
        uint32_t curr = TACC;

        PROCHK = curr & (1u << 4u);
        IPCHK = curr & (1u << 3u);
        SHIFT16 = curr & (1u << 0u);
    }

    /**
     * Set all of TACC's bit fields.
     *
     * (read-write) Transmit Accelerator Function Configuration
     */
    inline void set_TACC(bool PROCHK, bool IPCHK, bool SHIFT16) volatile
    {
        uint32_t curr = TACC;

        curr &= ~(0b1u << 4u);
        curr |= (PROCHK & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IPCHK & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (SHIFT16 & 0b1u) << 0u;

        TACC = curr;
    }

    /**
     * Get RACC's SHIFT16 bit.
     *
     * RX FIFO Shift-16
     */
    inline bool get_RACC_SHIFT16() volatile
    {
        return RACC & (1u << 7u);
    }

    /**
     * Set RACC's SHIFT16 bit.
     *
     * RX FIFO Shift-16
     */
    inline void set_RACC_SHIFT16() volatile
    {
        RACC |= 1u << 7u;
    }

    /**
     * Clear RACC's SHIFT16 bit.
     *
     * RX FIFO Shift-16
     */
    inline void clear_RACC_SHIFT16() volatile
    {
        RACC &= ~(1u << 7u);
    }

    /**
     * Toggle RACC's SHIFT16 bit.
     *
     * RX FIFO Shift-16
     */
    inline void toggle_RACC_SHIFT16() volatile
    {
        RACC ^= 1u << 7u;
    }

    /**
     * Get RACC's LINEDIS bit.
     *
     * Enable Discard Of Frames With MAC Layer Errors
     */
    inline bool get_RACC_LINEDIS() volatile
    {
        return RACC & (1u << 6u);
    }

    /**
     * Set RACC's LINEDIS bit.
     *
     * Enable Discard Of Frames With MAC Layer Errors
     */
    inline void set_RACC_LINEDIS() volatile
    {
        RACC |= 1u << 6u;
    }

    /**
     * Clear RACC's LINEDIS bit.
     *
     * Enable Discard Of Frames With MAC Layer Errors
     */
    inline void clear_RACC_LINEDIS() volatile
    {
        RACC &= ~(1u << 6u);
    }

    /**
     * Toggle RACC's LINEDIS bit.
     *
     * Enable Discard Of Frames With MAC Layer Errors
     */
    inline void toggle_RACC_LINEDIS() volatile
    {
        RACC ^= 1u << 6u;
    }

    /**
     * Get RACC's PRODIS bit.
     *
     * Enable Discard Of Frames With Wrong Protocol Checksum
     */
    inline bool get_RACC_PRODIS() volatile
    {
        return RACC & (1u << 2u);
    }

    /**
     * Set RACC's PRODIS bit.
     *
     * Enable Discard Of Frames With Wrong Protocol Checksum
     */
    inline void set_RACC_PRODIS() volatile
    {
        RACC |= 1u << 2u;
    }

    /**
     * Clear RACC's PRODIS bit.
     *
     * Enable Discard Of Frames With Wrong Protocol Checksum
     */
    inline void clear_RACC_PRODIS() volatile
    {
        RACC &= ~(1u << 2u);
    }

    /**
     * Toggle RACC's PRODIS bit.
     *
     * Enable Discard Of Frames With Wrong Protocol Checksum
     */
    inline void toggle_RACC_PRODIS() volatile
    {
        RACC ^= 1u << 2u;
    }

    /**
     * Get RACC's IPDIS bit.
     *
     * Enable Discard Of Frames With Wrong IPv4 Header Checksum
     */
    inline bool get_RACC_IPDIS() volatile
    {
        return RACC & (1u << 1u);
    }

    /**
     * Set RACC's IPDIS bit.
     *
     * Enable Discard Of Frames With Wrong IPv4 Header Checksum
     */
    inline void set_RACC_IPDIS() volatile
    {
        RACC |= 1u << 1u;
    }

    /**
     * Clear RACC's IPDIS bit.
     *
     * Enable Discard Of Frames With Wrong IPv4 Header Checksum
     */
    inline void clear_RACC_IPDIS() volatile
    {
        RACC &= ~(1u << 1u);
    }

    /**
     * Toggle RACC's IPDIS bit.
     *
     * Enable Discard Of Frames With Wrong IPv4 Header Checksum
     */
    inline void toggle_RACC_IPDIS() volatile
    {
        RACC ^= 1u << 1u;
    }

    /**
     * Get RACC's PADREM bit.
     *
     * Enable Padding Removal For Short IP Frames
     */
    inline bool get_RACC_PADREM() volatile
    {
        return RACC & (1u << 0u);
    }

    /**
     * Set RACC's PADREM bit.
     *
     * Enable Padding Removal For Short IP Frames
     */
    inline void set_RACC_PADREM() volatile
    {
        RACC |= 1u << 0u;
    }

    /**
     * Clear RACC's PADREM bit.
     *
     * Enable Padding Removal For Short IP Frames
     */
    inline void clear_RACC_PADREM() volatile
    {
        RACC &= ~(1u << 0u);
    }

    /**
     * Toggle RACC's PADREM bit.
     *
     * Enable Padding Removal For Short IP Frames
     */
    inline void toggle_RACC_PADREM() volatile
    {
        RACC ^= 1u << 0u;
    }

    /**
     * Get all of RACC's bit fields.
     *
     * (read-write) Receive Accelerator Function Configuration
     */
    inline void get_RACC(bool &SHIFT16, bool &LINEDIS, bool &PRODIS,
                         bool &IPDIS, bool &PADREM) volatile
    {
        uint32_t curr = RACC;

        SHIFT16 = curr & (1u << 7u);
        LINEDIS = curr & (1u << 6u);
        PRODIS = curr & (1u << 2u);
        IPDIS = curr & (1u << 1u);
        PADREM = curr & (1u << 0u);
    }

    /**
     * Set all of RACC's bit fields.
     *
     * (read-write) Receive Accelerator Function Configuration
     */
    inline void set_RACC(bool SHIFT16, bool LINEDIS, bool PRODIS, bool IPDIS,
                         bool PADREM) volatile
    {
        uint32_t curr = RACC;

        curr &= ~(0b1u << 7u);
        curr |= (SHIFT16 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (LINEDIS & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (PRODIS & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IPDIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PADREM & 0b1u) << 0u;

        RACC = curr;
    }

    /**
     * Get RMON_T_PACKETS's TXPKTS field.
     *
     * Packet count
     */
    inline uint16_t get_RMON_T_PACKETS_TXPKTS() volatile
    {
        return (RMON_T_PACKETS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_BC_PKT's TXPKTS field.
     *
     * Broadcast packets
     */
    inline uint16_t get_RMON_T_BC_PKT_TXPKTS() volatile
    {
        return (RMON_T_BC_PKT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_MC_PKT's TXPKTS field.
     *
     * Multicast packets
     */
    inline uint16_t get_RMON_T_MC_PKT_TXPKTS() volatile
    {
        return (RMON_T_MC_PKT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_CRC_ALIGN's TXPKTS field.
     *
     * Packets with CRC/align error
     */
    inline uint16_t get_RMON_T_CRC_ALIGN_TXPKTS() volatile
    {
        return (RMON_T_CRC_ALIGN >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_UNDERSIZE's TXPKTS field.
     *
     * Number of transmit packets less than 64 bytes with good CRC
     */
    inline uint16_t get_RMON_T_UNDERSIZE_TXPKTS() volatile
    {
        return (RMON_T_UNDERSIZE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_OVERSIZE's TXPKTS field.
     *
     * Number of transmit packets greater than MAX_FL bytes with good CRC
     */
    inline uint16_t get_RMON_T_OVERSIZE_TXPKTS() volatile
    {
        return (RMON_T_OVERSIZE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_FRAG's TXPKTS field.
     *
     * Number of packets less than 64 bytes with bad CRC
     */
    inline uint16_t get_RMON_T_FRAG_TXPKTS() volatile
    {
        return (RMON_T_FRAG >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_JAB's TXPKTS field.
     *
     * Number of transmit packets greater than MAX_FL bytes and bad CRC
     */
    inline uint16_t get_RMON_T_JAB_TXPKTS() volatile
    {
        return (RMON_T_JAB >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_COL's TXPKTS field.
     *
     * Number of transmit collisions
     */
    inline uint16_t get_RMON_T_COL_TXPKTS() volatile
    {
        return (RMON_T_COL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P64's TXPKTS field.
     *
     * Number of 64-byte transmit packets
     */
    inline uint16_t get_RMON_T_P64_TXPKTS() volatile
    {
        return (RMON_T_P64 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P65TO127's TXPKTS field.
     *
     * Number of 65- to 127-byte transmit packets
     */
    inline uint16_t get_RMON_T_P65TO127_TXPKTS() volatile
    {
        return (RMON_T_P65TO127 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P128TO255's TXPKTS field.
     *
     * Number of 128- to 255-byte transmit packets
     */
    inline uint16_t get_RMON_T_P128TO255_TXPKTS() volatile
    {
        return (RMON_T_P128TO255 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P256TO511's TXPKTS field.
     *
     * Number of 256- to 511-byte transmit packets
     */
    inline uint16_t get_RMON_T_P256TO511_TXPKTS() volatile
    {
        return (RMON_T_P256TO511 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P512TO1023's TXPKTS field.
     *
     * Number of 512- to 1023-byte transmit packets
     */
    inline uint16_t get_RMON_T_P512TO1023_TXPKTS() volatile
    {
        return (RMON_T_P512TO1023 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P1024TO2047's TXPKTS field.
     *
     * Number of 1024- to 2047-byte transmit packets
     */
    inline uint16_t get_RMON_T_P1024TO2047_TXPKTS() volatile
    {
        return (RMON_T_P1024TO2047 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_P_GTE2048's TXPKTS field.
     *
     * Number of transmit packets greater than 2048 bytes
     */
    inline uint16_t get_RMON_T_P_GTE2048_TXPKTS() volatile
    {
        return (RMON_T_P_GTE2048 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_T_OCTETS's TXOCTS field.
     *
     * Number of transmit octets
     */
    inline uint32_t get_RMON_T_OCTETS_TXOCTS() volatile
    {
        return (RMON_T_OCTETS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get IEEE_T_FRAME_OK's COUNT field.
     *
     * Number of frames transmitted OK
     */
    inline uint16_t get_IEEE_T_FRAME_OK_COUNT() volatile
    {
        return (IEEE_T_FRAME_OK >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_1COL's COUNT field.
     *
     * Number of frames transmitted with one collision
     */
    inline uint16_t get_IEEE_T_1COL_COUNT() volatile
    {
        return (IEEE_T_1COL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_MCOL's COUNT field.
     *
     * Number of frames transmitted with multiple collisions
     */
    inline uint16_t get_IEEE_T_MCOL_COUNT() volatile
    {
        return (IEEE_T_MCOL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_DEF's COUNT field.
     *
     * Number of frames transmitted with deferral delay
     */
    inline uint16_t get_IEEE_T_DEF_COUNT() volatile
    {
        return (IEEE_T_DEF >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_LCOL's COUNT field.
     *
     * Number of frames transmitted with late collision
     */
    inline uint16_t get_IEEE_T_LCOL_COUNT() volatile
    {
        return (IEEE_T_LCOL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_EXCOL's COUNT field.
     *
     * Number of frames transmitted with excessive collisions
     */
    inline uint16_t get_IEEE_T_EXCOL_COUNT() volatile
    {
        return (IEEE_T_EXCOL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_MACERR's COUNT field.
     *
     * Number of frames transmitted with transmit FIFO underrun
     */
    inline uint16_t get_IEEE_T_MACERR_COUNT() volatile
    {
        return (IEEE_T_MACERR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_CSERR's COUNT field.
     *
     * Number of frames transmitted with carrier sense error
     */
    inline uint16_t get_IEEE_T_CSERR_COUNT() volatile
    {
        return (IEEE_T_CSERR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_SQE's COUNT field.
     *
     * This read-only field is reserved and always has the value 0
     */
    inline uint16_t get_IEEE_T_SQE_COUNT() volatile
    {
        return (IEEE_T_SQE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_FDXFC's COUNT field.
     *
     * Number of flow-control pause frames transmitted
     */
    inline uint16_t get_IEEE_T_FDXFC_COUNT() volatile
    {
        return (IEEE_T_FDXFC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_T_OCTETS_OK's COUNT field.
     *
     * Octet count for frames transmitted without error Counts total octets
     * (includes header and FCS fields).
     */
    inline uint32_t get_IEEE_T_OCTETS_OK_COUNT() volatile
    {
        return (IEEE_T_OCTETS_OK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get RMON_R_PACKETS's COUNT field.
     *
     * Number of packets received
     */
    inline uint16_t get_RMON_R_PACKETS_COUNT() volatile
    {
        return (RMON_R_PACKETS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_BC_PKT's COUNT field.
     *
     * Number of receive broadcast packets
     */
    inline uint16_t get_RMON_R_BC_PKT_COUNT() volatile
    {
        return (RMON_R_BC_PKT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_MC_PKT's COUNT field.
     *
     * Number of receive multicast packets
     */
    inline uint16_t get_RMON_R_MC_PKT_COUNT() volatile
    {
        return (RMON_R_MC_PKT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_CRC_ALIGN's COUNT field.
     *
     * Number of receive packets with CRC or align error
     */
    inline uint16_t get_RMON_R_CRC_ALIGN_COUNT() volatile
    {
        return (RMON_R_CRC_ALIGN >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_UNDERSIZE's COUNT field.
     *
     * Number of receive packets with less than 64 bytes and good CRC
     */
    inline uint16_t get_RMON_R_UNDERSIZE_COUNT() volatile
    {
        return (RMON_R_UNDERSIZE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_OVERSIZE's COUNT field.
     *
     * Number of receive packets greater than MAX_FL and good CRC
     */
    inline uint16_t get_RMON_R_OVERSIZE_COUNT() volatile
    {
        return (RMON_R_OVERSIZE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_FRAG's COUNT field.
     *
     * Number of receive packets with less than 64 bytes and bad CRC
     */
    inline uint16_t get_RMON_R_FRAG_COUNT() volatile
    {
        return (RMON_R_FRAG >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_JAB's COUNT field.
     *
     * Number of receive packets greater than MAX_FL and bad CRC
     */
    inline uint16_t get_RMON_R_JAB_COUNT() volatile
    {
        return (RMON_R_JAB >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P64's COUNT field.
     *
     * Number of 64-byte receive packets
     */
    inline uint16_t get_RMON_R_P64_COUNT() volatile
    {
        return (RMON_R_P64 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P65TO127's COUNT field.
     *
     * Number of 65- to 127-byte recieve packets
     */
    inline uint16_t get_RMON_R_P65TO127_COUNT() volatile
    {
        return (RMON_R_P65TO127 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P128TO255's COUNT field.
     *
     * Number of 128- to 255-byte recieve packets
     */
    inline uint16_t get_RMON_R_P128TO255_COUNT() volatile
    {
        return (RMON_R_P128TO255 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P256TO511's COUNT field.
     *
     * Number of 256- to 511-byte recieve packets
     */
    inline uint16_t get_RMON_R_P256TO511_COUNT() volatile
    {
        return (RMON_R_P256TO511 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P512TO1023's COUNT field.
     *
     * Number of 512- to 1023-byte recieve packets
     */
    inline uint16_t get_RMON_R_P512TO1023_COUNT() volatile
    {
        return (RMON_R_P512TO1023 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P1024TO2047's COUNT field.
     *
     * Number of 1024- to 2047-byte recieve packets
     */
    inline uint16_t get_RMON_R_P1024TO2047_COUNT() volatile
    {
        return (RMON_R_P1024TO2047 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_P_GTE2048's COUNT field.
     *
     * Number of greater-than-2048-byte recieve packets
     */
    inline uint16_t get_RMON_R_P_GTE2048_COUNT() volatile
    {
        return (RMON_R_P_GTE2048 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get RMON_R_OCTETS's COUNT field.
     *
     * Number of receive octets
     */
    inline uint32_t get_RMON_R_OCTETS_COUNT() volatile
    {
        return (RMON_R_OCTETS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get IEEE_R_DROP's COUNT field.
     *
     * Frame count
     */
    inline uint16_t get_IEEE_R_DROP_COUNT() volatile
    {
        return (IEEE_R_DROP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_R_FRAME_OK's COUNT field.
     *
     * Number of frames received OK
     */
    inline uint16_t get_IEEE_R_FRAME_OK_COUNT() volatile
    {
        return (IEEE_R_FRAME_OK >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_R_CRC's COUNT field.
     *
     * Number of frames received with CRC error
     */
    inline uint16_t get_IEEE_R_CRC_COUNT() volatile
    {
        return (IEEE_R_CRC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_R_ALIGN's COUNT field.
     *
     * Number of frames received with alignment error
     */
    inline uint16_t get_IEEE_R_ALIGN_COUNT() volatile
    {
        return (IEEE_R_ALIGN >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_R_MACERR's COUNT field.
     *
     * Receive FIFO overflow count
     */
    inline uint16_t get_IEEE_R_MACERR_COUNT() volatile
    {
        return (IEEE_R_MACERR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_R_FDXFC's COUNT field.
     *
     * Number of flow-control pause frames received
     */
    inline uint16_t get_IEEE_R_FDXFC_COUNT() volatile
    {
        return (IEEE_R_FDXFC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get IEEE_R_OCTETS_OK's COUNT field.
     *
     * Number of octets for frames received without error
     */
    inline uint32_t get_IEEE_R_OCTETS_OK_COUNT() volatile
    {
        return (IEEE_R_OCTETS_OK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get ATCR's SLAVE bit.
     *
     * Enable Timer Slave Mode
     */
    inline bool get_ATCR_SLAVE() volatile
    {
        return ATCR & (1u << 13u);
    }

    /**
     * Set ATCR's SLAVE bit.
     *
     * Enable Timer Slave Mode
     */
    inline void set_ATCR_SLAVE() volatile
    {
        ATCR |= 1u << 13u;
    }

    /**
     * Clear ATCR's SLAVE bit.
     *
     * Enable Timer Slave Mode
     */
    inline void clear_ATCR_SLAVE() volatile
    {
        ATCR &= ~(1u << 13u);
    }

    /**
     * Toggle ATCR's SLAVE bit.
     *
     * Enable Timer Slave Mode
     */
    inline void toggle_ATCR_SLAVE() volatile
    {
        ATCR ^= 1u << 13u;
    }

    /**
     * Get ATCR's CAPTURE bit.
     *
     * Capture Timer Value
     */
    inline bool get_ATCR_CAPTURE() volatile
    {
        return ATCR & (1u << 11u);
    }

    /**
     * Set ATCR's CAPTURE bit.
     *
     * Capture Timer Value
     */
    inline void set_ATCR_CAPTURE() volatile
    {
        ATCR |= 1u << 11u;
    }

    /**
     * Clear ATCR's CAPTURE bit.
     *
     * Capture Timer Value
     */
    inline void clear_ATCR_CAPTURE() volatile
    {
        ATCR &= ~(1u << 11u);
    }

    /**
     * Toggle ATCR's CAPTURE bit.
     *
     * Capture Timer Value
     */
    inline void toggle_ATCR_CAPTURE() volatile
    {
        ATCR ^= 1u << 11u;
    }

    /**
     * Get ATCR's RESTART bit.
     *
     * Reset Timer
     */
    inline bool get_ATCR_RESTART() volatile
    {
        return ATCR & (1u << 9u);
    }

    /**
     * Set ATCR's RESTART bit.
     *
     * Reset Timer
     */
    inline void set_ATCR_RESTART() volatile
    {
        ATCR |= 1u << 9u;
    }

    /**
     * Clear ATCR's RESTART bit.
     *
     * Reset Timer
     */
    inline void clear_ATCR_RESTART() volatile
    {
        ATCR &= ~(1u << 9u);
    }

    /**
     * Toggle ATCR's RESTART bit.
     *
     * Reset Timer
     */
    inline void toggle_ATCR_RESTART() volatile
    {
        ATCR ^= 1u << 9u;
    }

    /**
     * Get ATCR's PINPER bit.
     *
     * Enables event signal output external pin frc_evt_period assertion on
     * period event
     */
    inline bool get_ATCR_PINPER() volatile
    {
        return ATCR & (1u << 7u);
    }

    /**
     * Set ATCR's PINPER bit.
     *
     * Enables event signal output external pin frc_evt_period assertion on
     * period event
     */
    inline void set_ATCR_PINPER() volatile
    {
        ATCR |= 1u << 7u;
    }

    /**
     * Clear ATCR's PINPER bit.
     *
     * Enables event signal output external pin frc_evt_period assertion on
     * period event
     */
    inline void clear_ATCR_PINPER() volatile
    {
        ATCR &= ~(1u << 7u);
    }

    /**
     * Toggle ATCR's PINPER bit.
     *
     * Enables event signal output external pin frc_evt_period assertion on
     * period event
     */
    inline void toggle_ATCR_PINPER() volatile
    {
        ATCR ^= 1u << 7u;
    }

    /**
     * Get ATCR's PEREN bit.
     *
     * Enable Periodical Event
     */
    inline bool get_ATCR_PEREN() volatile
    {
        return ATCR & (1u << 4u);
    }

    /**
     * Set ATCR's PEREN bit.
     *
     * Enable Periodical Event
     */
    inline void set_ATCR_PEREN() volatile
    {
        ATCR |= 1u << 4u;
    }

    /**
     * Clear ATCR's PEREN bit.
     *
     * Enable Periodical Event
     */
    inline void clear_ATCR_PEREN() volatile
    {
        ATCR &= ~(1u << 4u);
    }

    /**
     * Toggle ATCR's PEREN bit.
     *
     * Enable Periodical Event
     */
    inline void toggle_ATCR_PEREN() volatile
    {
        ATCR ^= 1u << 4u;
    }

    /**
     * Get ATCR's OFFRST bit.
     *
     * Reset Timer On Offset Event
     */
    inline bool get_ATCR_OFFRST() volatile
    {
        return ATCR & (1u << 3u);
    }

    /**
     * Set ATCR's OFFRST bit.
     *
     * Reset Timer On Offset Event
     */
    inline void set_ATCR_OFFRST() volatile
    {
        ATCR |= 1u << 3u;
    }

    /**
     * Clear ATCR's OFFRST bit.
     *
     * Reset Timer On Offset Event
     */
    inline void clear_ATCR_OFFRST() volatile
    {
        ATCR &= ~(1u << 3u);
    }

    /**
     * Toggle ATCR's OFFRST bit.
     *
     * Reset Timer On Offset Event
     */
    inline void toggle_ATCR_OFFRST() volatile
    {
        ATCR ^= 1u << 3u;
    }

    /**
     * Get ATCR's OFFEN bit.
     *
     * Enable One-Shot Offset Event
     */
    inline bool get_ATCR_OFFEN() volatile
    {
        return ATCR & (1u << 2u);
    }

    /**
     * Set ATCR's OFFEN bit.
     *
     * Enable One-Shot Offset Event
     */
    inline void set_ATCR_OFFEN() volatile
    {
        ATCR |= 1u << 2u;
    }

    /**
     * Clear ATCR's OFFEN bit.
     *
     * Enable One-Shot Offset Event
     */
    inline void clear_ATCR_OFFEN() volatile
    {
        ATCR &= ~(1u << 2u);
    }

    /**
     * Toggle ATCR's OFFEN bit.
     *
     * Enable One-Shot Offset Event
     */
    inline void toggle_ATCR_OFFEN() volatile
    {
        ATCR ^= 1u << 2u;
    }

    /**
     * Get ATCR's EN bit.
     *
     * Enable Timer
     */
    inline bool get_ATCR_EN() volatile
    {
        return ATCR & (1u << 0u);
    }

    /**
     * Set ATCR's EN bit.
     *
     * Enable Timer
     */
    inline void set_ATCR_EN() volatile
    {
        ATCR |= 1u << 0u;
    }

    /**
     * Clear ATCR's EN bit.
     *
     * Enable Timer
     */
    inline void clear_ATCR_EN() volatile
    {
        ATCR &= ~(1u << 0u);
    }

    /**
     * Toggle ATCR's EN bit.
     *
     * Enable Timer
     */
    inline void toggle_ATCR_EN() volatile
    {
        ATCR ^= 1u << 0u;
    }

    /**
     * Get all of ATCR's bit fields.
     *
     * (read-write) Adjustable Timer Control Register
     */
    inline void get_ATCR(bool &SLAVE, bool &CAPTURE, bool &RESTART,
                         bool &PINPER, bool &PEREN, bool &OFFRST, bool &OFFEN,
                         bool &EN) volatile
    {
        uint32_t curr = ATCR;

        SLAVE = curr & (1u << 13u);
        CAPTURE = curr & (1u << 11u);
        RESTART = curr & (1u << 9u);
        PINPER = curr & (1u << 7u);
        PEREN = curr & (1u << 4u);
        OFFRST = curr & (1u << 3u);
        OFFEN = curr & (1u << 2u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of ATCR's bit fields.
     *
     * (read-write) Adjustable Timer Control Register
     */
    inline void set_ATCR(bool SLAVE, bool CAPTURE, bool RESTART, bool PINPER,
                         bool PEREN, bool OFFRST, bool OFFEN, bool EN) volatile
    {
        uint32_t curr = ATCR;

        curr &= ~(0b1u << 13u);
        curr |= (SLAVE & 0b1u) << 13u;
        curr &= ~(0b1u << 11u);
        curr |= (CAPTURE & 0b1u) << 11u;
        curr &= ~(0b1u << 9u);
        curr |= (RESTART & 0b1u) << 9u;
        curr &= ~(0b1u << 7u);
        curr |= (PINPER & 0b1u) << 7u;
        curr &= ~(0b1u << 4u);
        curr |= (PEREN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (OFFRST & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (OFFEN & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        ATCR = curr;
    }

    /**
     * Get ATVR's ATIME field.
     *
     * A write sets the timer
     */
    inline uint32_t get_ATVR_ATIME() volatile
    {
        return (ATVR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set ATVR's ATIME field.
     *
     * A write sets the timer
     */
    inline void set_ATVR_ATIME(uint32_t value) volatile
    {
        uint32_t curr = ATVR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ATVR = curr;
    }

    /**
     * Get ATOFF's OFFSET field.
     *
     * Offset value for one-shot event generation
     */
    inline uint32_t get_ATOFF_OFFSET() volatile
    {
        return (ATOFF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set ATOFF's OFFSET field.
     *
     * Offset value for one-shot event generation
     */
    inline void set_ATOFF_OFFSET(uint32_t value) volatile
    {
        uint32_t curr = ATOFF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ATOFF = curr;
    }

    /**
     * Get ATPER's PERIOD field.
     *
     * Value for generating periodic events
     */
    inline uint32_t get_ATPER_PERIOD() volatile
    {
        return (ATPER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set ATPER's PERIOD field.
     *
     * Value for generating periodic events
     */
    inline void set_ATPER_PERIOD(uint32_t value) volatile
    {
        uint32_t curr = ATPER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ATPER = curr;
    }

    /**
     * Get ATCOR's COR field.
     *
     * Correction Counter Wrap-Around Value
     */
    inline uint32_t get_ATCOR_COR() volatile
    {
        return (ATCOR >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Set ATCOR's COR field.
     *
     * Correction Counter Wrap-Around Value
     */
    inline void set_ATCOR_COR(uint32_t value) volatile
    {
        uint32_t curr = ATCOR;

        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111111111u) << 0u;

        ATCOR = curr;
    }

    /**
     * Get ATINC's INC_CORR field.
     *
     * Correction Increment Value
     */
    inline uint8_t get_ATINC_INC_CORR() volatile
    {
        return (ATINC >> 8u) & 0b1111111u;
    }

    /**
     * Set ATINC's INC_CORR field.
     *
     * Correction Increment Value
     */
    inline void set_ATINC_INC_CORR(uint8_t value) volatile
    {
        uint32_t curr = ATINC;

        curr &= ~(0b1111111u << 8u);
        curr |= (value & 0b1111111u) << 8u;

        ATINC = curr;
    }

    /**
     * Get ATINC's INC field.
     *
     * Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
     */
    inline uint8_t get_ATINC_INC() volatile
    {
        return (ATINC >> 0u) & 0b1111111u;
    }

    /**
     * Set ATINC's INC field.
     *
     * Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
     */
    inline void set_ATINC_INC(uint8_t value) volatile
    {
        uint32_t curr = ATINC;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ATINC = curr;
    }

    /**
     * Get all of ATINC's bit fields.
     *
     * (read-write) Time-Stamping Clock Period Register
     */
    inline void get_ATINC(uint8_t &INC_CORR, uint8_t &INC) volatile
    {
        uint32_t curr = ATINC;

        INC_CORR = (curr >> 8u) & 0b1111111u;
        INC = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of ATINC's bit fields.
     *
     * (read-write) Time-Stamping Clock Period Register
     */
    inline void set_ATINC(uint8_t INC_CORR, uint8_t INC) volatile
    {
        uint32_t curr = ATINC;

        curr &= ~(0b1111111u << 8u);
        curr |= (INC_CORR & 0b1111111u) << 8u;
        curr &= ~(0b1111111u << 0u);
        curr |= (INC & 0b1111111u) << 0u;

        ATINC = curr;
    }

    /**
     * Get ATSTMP's TIMESTAMP field.
     *
     * Timestamp of the last frame transmitted by the core that had TxBD[TS]
     * set the ff_tx_ts_frm signal asserted from the user application
     */
    inline uint32_t get_ATSTMP_TIMESTAMP() volatile
    {
        return (ATSTMP >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get TGSR's TF3 bit.
     *
     * Copy Of Timer Flag For Channel 3
     */
    inline bool get_TGSR_TF3() volatile
    {
        return TGSR & (1u << 3u);
    }

    /**
     * Set TGSR's TF3 bit.
     *
     * Copy Of Timer Flag For Channel 3
     */
    inline void set_TGSR_TF3() volatile
    {
        TGSR |= 1u << 3u;
    }

    /**
     * Clear TGSR's TF3 bit.
     *
     * Copy Of Timer Flag For Channel 3
     */
    inline void clear_TGSR_TF3() volatile
    {
        TGSR &= ~(1u << 3u);
    }

    /**
     * Toggle TGSR's TF3 bit.
     *
     * Copy Of Timer Flag For Channel 3
     */
    inline void toggle_TGSR_TF3() volatile
    {
        TGSR ^= 1u << 3u;
    }

    /**
     * Get TGSR's TF2 bit.
     *
     * Copy Of Timer Flag For Channel 2
     */
    inline bool get_TGSR_TF2() volatile
    {
        return TGSR & (1u << 2u);
    }

    /**
     * Set TGSR's TF2 bit.
     *
     * Copy Of Timer Flag For Channel 2
     */
    inline void set_TGSR_TF2() volatile
    {
        TGSR |= 1u << 2u;
    }

    /**
     * Clear TGSR's TF2 bit.
     *
     * Copy Of Timer Flag For Channel 2
     */
    inline void clear_TGSR_TF2() volatile
    {
        TGSR &= ~(1u << 2u);
    }

    /**
     * Toggle TGSR's TF2 bit.
     *
     * Copy Of Timer Flag For Channel 2
     */
    inline void toggle_TGSR_TF2() volatile
    {
        TGSR ^= 1u << 2u;
    }

    /**
     * Get TGSR's TF1 bit.
     *
     * Copy Of Timer Flag For Channel 1
     */
    inline bool get_TGSR_TF1() volatile
    {
        return TGSR & (1u << 1u);
    }

    /**
     * Set TGSR's TF1 bit.
     *
     * Copy Of Timer Flag For Channel 1
     */
    inline void set_TGSR_TF1() volatile
    {
        TGSR |= 1u << 1u;
    }

    /**
     * Clear TGSR's TF1 bit.
     *
     * Copy Of Timer Flag For Channel 1
     */
    inline void clear_TGSR_TF1() volatile
    {
        TGSR &= ~(1u << 1u);
    }

    /**
     * Toggle TGSR's TF1 bit.
     *
     * Copy Of Timer Flag For Channel 1
     */
    inline void toggle_TGSR_TF1() volatile
    {
        TGSR ^= 1u << 1u;
    }

    /**
     * Get TGSR's TF0 bit.
     *
     * Copy Of Timer Flag For Channel 0
     */
    inline bool get_TGSR_TF0() volatile
    {
        return TGSR & (1u << 0u);
    }

    /**
     * Set TGSR's TF0 bit.
     *
     * Copy Of Timer Flag For Channel 0
     */
    inline void set_TGSR_TF0() volatile
    {
        TGSR |= 1u << 0u;
    }

    /**
     * Clear TGSR's TF0 bit.
     *
     * Copy Of Timer Flag For Channel 0
     */
    inline void clear_TGSR_TF0() volatile
    {
        TGSR &= ~(1u << 0u);
    }

    /**
     * Toggle TGSR's TF0 bit.
     *
     * Copy Of Timer Flag For Channel 0
     */
    inline void toggle_TGSR_TF0() volatile
    {
        TGSR ^= 1u << 0u;
    }

    /**
     * Get all of TGSR's bit fields.
     *
     * (read-write) Timer Global Status Register
     */
    inline void get_TGSR(bool &TF3, bool &TF2, bool &TF1, bool &TF0) volatile
    {
        uint32_t curr = TGSR;

        TF3 = curr & (1u << 3u);
        TF2 = curr & (1u << 2u);
        TF1 = curr & (1u << 1u);
        TF0 = curr & (1u << 0u);
    }

    /**
     * Set all of TGSR's bit fields.
     *
     * (read-write) Timer Global Status Register
     */
    inline void set_TGSR(bool TF3, bool TF2, bool TF1, bool TF0) volatile
    {
        uint32_t curr = TGSR;

        curr &= ~(0b1u << 3u);
        curr |= (TF3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TF2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TF1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TF0 & 0b1u) << 0u;

        TGSR = curr;
    }

    /**
     * Get TCSR0's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline ENET_TCSR0_TPWC get_TCSR0_TPWC() volatile
    {
        return ENET_TCSR0_TPWC((TCSR0 >> 11u) & 0b11111u);
    }

    /**
     * Set TCSR0's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline void set_TCSR0_TPWC(ENET_TCSR0_TPWC value) volatile
    {
        uint32_t curr = TCSR0;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(value) & 0b11111u) << 11u;

        TCSR0 = curr;
    }

    /**
     * Get TCSR0's TF bit.
     *
     * Timer Flag
     */
    inline bool get_TCSR0_TF() volatile
    {
        return TCSR0 & (1u << 7u);
    }

    /**
     * Set TCSR0's TF bit.
     *
     * Timer Flag
     */
    inline void set_TCSR0_TF() volatile
    {
        TCSR0 |= 1u << 7u;
    }

    /**
     * Clear TCSR0's TF bit.
     *
     * Timer Flag
     */
    inline void clear_TCSR0_TF() volatile
    {
        TCSR0 &= ~(1u << 7u);
    }

    /**
     * Toggle TCSR0's TF bit.
     *
     * Timer Flag
     */
    inline void toggle_TCSR0_TF() volatile
    {
        TCSR0 ^= 1u << 7u;
    }

    /**
     * Get TCSR0's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline bool get_TCSR0_TIE() volatile
    {
        return TCSR0 & (1u << 6u);
    }

    /**
     * Set TCSR0's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void set_TCSR0_TIE() volatile
    {
        TCSR0 |= 1u << 6u;
    }

    /**
     * Clear TCSR0's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void clear_TCSR0_TIE() volatile
    {
        TCSR0 &= ~(1u << 6u);
    }

    /**
     * Toggle TCSR0's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void toggle_TCSR0_TIE() volatile
    {
        TCSR0 ^= 1u << 6u;
    }

    /**
     * Get TCSR0's TMODE field.
     *
     * Timer Mode
     */
    inline ENET_TCSR0_TMODE get_TCSR0_TMODE() volatile
    {
        return ENET_TCSR0_TMODE((TCSR0 >> 2u) & 0b1111u);
    }

    /**
     * Set TCSR0's TMODE field.
     *
     * Timer Mode
     */
    inline void set_TCSR0_TMODE(ENET_TCSR0_TMODE value) volatile
    {
        uint32_t curr = TCSR0;

        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(value) & 0b1111u) << 2u;

        TCSR0 = curr;
    }

    /**
     * Get TCSR0's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline bool get_TCSR0_TDRE() volatile
    {
        return TCSR0 & (1u << 0u);
    }

    /**
     * Set TCSR0's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void set_TCSR0_TDRE() volatile
    {
        TCSR0 |= 1u << 0u;
    }

    /**
     * Clear TCSR0's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void clear_TCSR0_TDRE() volatile
    {
        TCSR0 &= ~(1u << 0u);
    }

    /**
     * Toggle TCSR0's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void toggle_TCSR0_TDRE() volatile
    {
        TCSR0 ^= 1u << 0u;
    }

    /**
     * Get all of TCSR0's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void get_TCSR0(ENET_TCSR0_TPWC &TPWC, bool &TF, bool &TIE,
                          ENET_TCSR0_TMODE &TMODE, bool &TDRE) volatile
    {
        uint32_t curr = TCSR0;

        TPWC = ENET_TCSR0_TPWC((curr >> 11u) & 0b11111u);
        TF = curr & (1u << 7u);
        TIE = curr & (1u << 6u);
        TMODE = ENET_TCSR0_TMODE((curr >> 2u) & 0b1111u);
        TDRE = curr & (1u << 0u);
    }

    /**
     * Set all of TCSR0's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void set_TCSR0(ENET_TCSR0_TPWC TPWC, bool TF, bool TIE,
                          ENET_TCSR0_TMODE TMODE, bool TDRE) volatile
    {
        uint32_t curr = TCSR0;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(TPWC) & 0b11111u) << 11u;
        curr &= ~(0b1u << 7u);
        curr |= (TF & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TIE & 0b1u) << 6u;
        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(TMODE) & 0b1111u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (TDRE & 0b1u) << 0u;

        TCSR0 = curr;
    }

    /**
     * Get TCCR0's TCC field.
     *
     * Timer Capture Compare
     */
    inline uint32_t get_TCCR0_TCC() volatile
    {
        return (TCCR0 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set TCCR0's TCC field.
     *
     * Timer Capture Compare
     */
    inline void set_TCCR0_TCC(uint32_t value) volatile
    {
        uint32_t curr = TCCR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        TCCR0 = curr;
    }

    /**
     * Get TCSR1's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline ENET_TCSR1_TPWC get_TCSR1_TPWC() volatile
    {
        return ENET_TCSR1_TPWC((TCSR1 >> 11u) & 0b11111u);
    }

    /**
     * Set TCSR1's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline void set_TCSR1_TPWC(ENET_TCSR1_TPWC value) volatile
    {
        uint32_t curr = TCSR1;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(value) & 0b11111u) << 11u;

        TCSR1 = curr;
    }

    /**
     * Get TCSR1's TF bit.
     *
     * Timer Flag
     */
    inline bool get_TCSR1_TF() volatile
    {
        return TCSR1 & (1u << 7u);
    }

    /**
     * Set TCSR1's TF bit.
     *
     * Timer Flag
     */
    inline void set_TCSR1_TF() volatile
    {
        TCSR1 |= 1u << 7u;
    }

    /**
     * Clear TCSR1's TF bit.
     *
     * Timer Flag
     */
    inline void clear_TCSR1_TF() volatile
    {
        TCSR1 &= ~(1u << 7u);
    }

    /**
     * Toggle TCSR1's TF bit.
     *
     * Timer Flag
     */
    inline void toggle_TCSR1_TF() volatile
    {
        TCSR1 ^= 1u << 7u;
    }

    /**
     * Get TCSR1's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline bool get_TCSR1_TIE() volatile
    {
        return TCSR1 & (1u << 6u);
    }

    /**
     * Set TCSR1's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void set_TCSR1_TIE() volatile
    {
        TCSR1 |= 1u << 6u;
    }

    /**
     * Clear TCSR1's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void clear_TCSR1_TIE() volatile
    {
        TCSR1 &= ~(1u << 6u);
    }

    /**
     * Toggle TCSR1's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void toggle_TCSR1_TIE() volatile
    {
        TCSR1 ^= 1u << 6u;
    }

    /**
     * Get TCSR1's TMODE field.
     *
     * Timer Mode
     */
    inline ENET_TCSR1_TMODE get_TCSR1_TMODE() volatile
    {
        return ENET_TCSR1_TMODE((TCSR1 >> 2u) & 0b1111u);
    }

    /**
     * Set TCSR1's TMODE field.
     *
     * Timer Mode
     */
    inline void set_TCSR1_TMODE(ENET_TCSR1_TMODE value) volatile
    {
        uint32_t curr = TCSR1;

        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(value) & 0b1111u) << 2u;

        TCSR1 = curr;
    }

    /**
     * Get TCSR1's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline bool get_TCSR1_TDRE() volatile
    {
        return TCSR1 & (1u << 0u);
    }

    /**
     * Set TCSR1's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void set_TCSR1_TDRE() volatile
    {
        TCSR1 |= 1u << 0u;
    }

    /**
     * Clear TCSR1's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void clear_TCSR1_TDRE() volatile
    {
        TCSR1 &= ~(1u << 0u);
    }

    /**
     * Toggle TCSR1's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void toggle_TCSR1_TDRE() volatile
    {
        TCSR1 ^= 1u << 0u;
    }

    /**
     * Get all of TCSR1's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void get_TCSR1(ENET_TCSR1_TPWC &TPWC, bool &TF, bool &TIE,
                          ENET_TCSR1_TMODE &TMODE, bool &TDRE) volatile
    {
        uint32_t curr = TCSR1;

        TPWC = ENET_TCSR1_TPWC((curr >> 11u) & 0b11111u);
        TF = curr & (1u << 7u);
        TIE = curr & (1u << 6u);
        TMODE = ENET_TCSR1_TMODE((curr >> 2u) & 0b1111u);
        TDRE = curr & (1u << 0u);
    }

    /**
     * Set all of TCSR1's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void set_TCSR1(ENET_TCSR1_TPWC TPWC, bool TF, bool TIE,
                          ENET_TCSR1_TMODE TMODE, bool TDRE) volatile
    {
        uint32_t curr = TCSR1;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(TPWC) & 0b11111u) << 11u;
        curr &= ~(0b1u << 7u);
        curr |= (TF & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TIE & 0b1u) << 6u;
        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(TMODE) & 0b1111u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (TDRE & 0b1u) << 0u;

        TCSR1 = curr;
    }

    /**
     * Get TCCR1's TCC field.
     *
     * Timer Capture Compare
     */
    inline uint32_t get_TCCR1_TCC() volatile
    {
        return (TCCR1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set TCCR1's TCC field.
     *
     * Timer Capture Compare
     */
    inline void set_TCCR1_TCC(uint32_t value) volatile
    {
        uint32_t curr = TCCR1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        TCCR1 = curr;
    }

    /**
     * Get TCSR2's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline ENET_TCSR2_TPWC get_TCSR2_TPWC() volatile
    {
        return ENET_TCSR2_TPWC((TCSR2 >> 11u) & 0b11111u);
    }

    /**
     * Set TCSR2's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline void set_TCSR2_TPWC(ENET_TCSR2_TPWC value) volatile
    {
        uint32_t curr = TCSR2;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(value) & 0b11111u) << 11u;

        TCSR2 = curr;
    }

    /**
     * Get TCSR2's TF bit.
     *
     * Timer Flag
     */
    inline bool get_TCSR2_TF() volatile
    {
        return TCSR2 & (1u << 7u);
    }

    /**
     * Set TCSR2's TF bit.
     *
     * Timer Flag
     */
    inline void set_TCSR2_TF() volatile
    {
        TCSR2 |= 1u << 7u;
    }

    /**
     * Clear TCSR2's TF bit.
     *
     * Timer Flag
     */
    inline void clear_TCSR2_TF() volatile
    {
        TCSR2 &= ~(1u << 7u);
    }

    /**
     * Toggle TCSR2's TF bit.
     *
     * Timer Flag
     */
    inline void toggle_TCSR2_TF() volatile
    {
        TCSR2 ^= 1u << 7u;
    }

    /**
     * Get TCSR2's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline bool get_TCSR2_TIE() volatile
    {
        return TCSR2 & (1u << 6u);
    }

    /**
     * Set TCSR2's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void set_TCSR2_TIE() volatile
    {
        TCSR2 |= 1u << 6u;
    }

    /**
     * Clear TCSR2's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void clear_TCSR2_TIE() volatile
    {
        TCSR2 &= ~(1u << 6u);
    }

    /**
     * Toggle TCSR2's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void toggle_TCSR2_TIE() volatile
    {
        TCSR2 ^= 1u << 6u;
    }

    /**
     * Get TCSR2's TMODE field.
     *
     * Timer Mode
     */
    inline ENET_TCSR2_TMODE get_TCSR2_TMODE() volatile
    {
        return ENET_TCSR2_TMODE((TCSR2 >> 2u) & 0b1111u);
    }

    /**
     * Set TCSR2's TMODE field.
     *
     * Timer Mode
     */
    inline void set_TCSR2_TMODE(ENET_TCSR2_TMODE value) volatile
    {
        uint32_t curr = TCSR2;

        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(value) & 0b1111u) << 2u;

        TCSR2 = curr;
    }

    /**
     * Get TCSR2's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline bool get_TCSR2_TDRE() volatile
    {
        return TCSR2 & (1u << 0u);
    }

    /**
     * Set TCSR2's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void set_TCSR2_TDRE() volatile
    {
        TCSR2 |= 1u << 0u;
    }

    /**
     * Clear TCSR2's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void clear_TCSR2_TDRE() volatile
    {
        TCSR2 &= ~(1u << 0u);
    }

    /**
     * Toggle TCSR2's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void toggle_TCSR2_TDRE() volatile
    {
        TCSR2 ^= 1u << 0u;
    }

    /**
     * Get all of TCSR2's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void get_TCSR2(ENET_TCSR2_TPWC &TPWC, bool &TF, bool &TIE,
                          ENET_TCSR2_TMODE &TMODE, bool &TDRE) volatile
    {
        uint32_t curr = TCSR2;

        TPWC = ENET_TCSR2_TPWC((curr >> 11u) & 0b11111u);
        TF = curr & (1u << 7u);
        TIE = curr & (1u << 6u);
        TMODE = ENET_TCSR2_TMODE((curr >> 2u) & 0b1111u);
        TDRE = curr & (1u << 0u);
    }

    /**
     * Set all of TCSR2's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void set_TCSR2(ENET_TCSR2_TPWC TPWC, bool TF, bool TIE,
                          ENET_TCSR2_TMODE TMODE, bool TDRE) volatile
    {
        uint32_t curr = TCSR2;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(TPWC) & 0b11111u) << 11u;
        curr &= ~(0b1u << 7u);
        curr |= (TF & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TIE & 0b1u) << 6u;
        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(TMODE) & 0b1111u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (TDRE & 0b1u) << 0u;

        TCSR2 = curr;
    }

    /**
     * Get TCCR2's TCC field.
     *
     * Timer Capture Compare
     */
    inline uint32_t get_TCCR2_TCC() volatile
    {
        return (TCCR2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set TCCR2's TCC field.
     *
     * Timer Capture Compare
     */
    inline void set_TCCR2_TCC(uint32_t value) volatile
    {
        uint32_t curr = TCCR2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        TCCR2 = curr;
    }

    /**
     * Get TCSR3's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline ENET_TCSR3_TPWC get_TCSR3_TPWC() volatile
    {
        return ENET_TCSR3_TPWC((TCSR3 >> 11u) & 0b11111u);
    }

    /**
     * Set TCSR3's TPWC field.
     *
     * Timer PulseWidth Control
     */
    inline void set_TCSR3_TPWC(ENET_TCSR3_TPWC value) volatile
    {
        uint32_t curr = TCSR3;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(value) & 0b11111u) << 11u;

        TCSR3 = curr;
    }

    /**
     * Get TCSR3's TF bit.
     *
     * Timer Flag
     */
    inline bool get_TCSR3_TF() volatile
    {
        return TCSR3 & (1u << 7u);
    }

    /**
     * Set TCSR3's TF bit.
     *
     * Timer Flag
     */
    inline void set_TCSR3_TF() volatile
    {
        TCSR3 |= 1u << 7u;
    }

    /**
     * Clear TCSR3's TF bit.
     *
     * Timer Flag
     */
    inline void clear_TCSR3_TF() volatile
    {
        TCSR3 &= ~(1u << 7u);
    }

    /**
     * Toggle TCSR3's TF bit.
     *
     * Timer Flag
     */
    inline void toggle_TCSR3_TF() volatile
    {
        TCSR3 ^= 1u << 7u;
    }

    /**
     * Get TCSR3's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline bool get_TCSR3_TIE() volatile
    {
        return TCSR3 & (1u << 6u);
    }

    /**
     * Set TCSR3's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void set_TCSR3_TIE() volatile
    {
        TCSR3 |= 1u << 6u;
    }

    /**
     * Clear TCSR3's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void clear_TCSR3_TIE() volatile
    {
        TCSR3 &= ~(1u << 6u);
    }

    /**
     * Toggle TCSR3's TIE bit.
     *
     * Timer Interrupt Enable
     */
    inline void toggle_TCSR3_TIE() volatile
    {
        TCSR3 ^= 1u << 6u;
    }

    /**
     * Get TCSR3's TMODE field.
     *
     * Timer Mode
     */
    inline ENET_TCSR3_TMODE get_TCSR3_TMODE() volatile
    {
        return ENET_TCSR3_TMODE((TCSR3 >> 2u) & 0b1111u);
    }

    /**
     * Set TCSR3's TMODE field.
     *
     * Timer Mode
     */
    inline void set_TCSR3_TMODE(ENET_TCSR3_TMODE value) volatile
    {
        uint32_t curr = TCSR3;

        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(value) & 0b1111u) << 2u;

        TCSR3 = curr;
    }

    /**
     * Get TCSR3's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline bool get_TCSR3_TDRE() volatile
    {
        return TCSR3 & (1u << 0u);
    }

    /**
     * Set TCSR3's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void set_TCSR3_TDRE() volatile
    {
        TCSR3 |= 1u << 0u;
    }

    /**
     * Clear TCSR3's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void clear_TCSR3_TDRE() volatile
    {
        TCSR3 &= ~(1u << 0u);
    }

    /**
     * Toggle TCSR3's TDRE bit.
     *
     * Timer DMA Request Enable
     */
    inline void toggle_TCSR3_TDRE() volatile
    {
        TCSR3 ^= 1u << 0u;
    }

    /**
     * Get all of TCSR3's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void get_TCSR3(ENET_TCSR3_TPWC &TPWC, bool &TF, bool &TIE,
                          ENET_TCSR3_TMODE &TMODE, bool &TDRE) volatile
    {
        uint32_t curr = TCSR3;

        TPWC = ENET_TCSR3_TPWC((curr >> 11u) & 0b11111u);
        TF = curr & (1u << 7u);
        TIE = curr & (1u << 6u);
        TMODE = ENET_TCSR3_TMODE((curr >> 2u) & 0b1111u);
        TDRE = curr & (1u << 0u);
    }

    /**
     * Set all of TCSR3's bit fields.
     *
     * (read-write) Timer Control Status Register
     */
    inline void set_TCSR3(ENET_TCSR3_TPWC TPWC, bool TF, bool TIE,
                          ENET_TCSR3_TMODE TMODE, bool TDRE) volatile
    {
        uint32_t curr = TCSR3;

        curr &= ~(0b11111u << 11u);
        curr |= (std::to_underlying(TPWC) & 0b11111u) << 11u;
        curr &= ~(0b1u << 7u);
        curr |= (TF & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TIE & 0b1u) << 6u;
        curr &= ~(0b1111u << 2u);
        curr |= (std::to_underlying(TMODE) & 0b1111u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (TDRE & 0b1u) << 0u;

        TCSR3 = curr;
    }

    /**
     * Get TCCR3's TCC field.
     *
     * Timer Capture Compare
     */
    inline uint32_t get_TCCR3_TCC() volatile
    {
        return (TCCR3 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set TCCR3's TCC field.
     *
     * Timer Capture Compare
     */
    inline void set_TCCR3_TCC(uint32_t value) volatile
    {
        uint32_t curr = TCCR3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        TCCR3 = curr;
    }
};

static_assert(sizeof(enet) == enet::size);

static volatile enet *const ENET = reinterpret_cast<enet *>(0x40424000);

}; // namespace MIMXRT1176::CM7
