/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/USDHC1_BLK_ATT_BLKCNT.h"
#include "../enums/USDHC1_BLK_ATT_BLKSIZE.h"
#include "../enums/USDHC1_CMD_XFR_TYP_CMDTYP.h"
#include "../enums/USDHC1_CMD_XFR_TYP_RSPTYP.h"
#include "../enums/USDHC1_HOST_CTRL_CAP_MBL.h"
#include "../enums/USDHC1_MMC_BOOT_DTOCV_ACK.h"
#include "../enums/USDHC1_PRES_STATE_DLSL.h"
#include "../enums/USDHC1_PROT_CTRL_DMASEL.h"
#include "../enums/USDHC1_PROT_CTRL_DTW.h"
#include "../enums/USDHC1_PROT_CTRL_EMODE.h"
#include "../enums/USDHC1_SYS_CTRL_DTOCV.h"
#include "../enums/USDHC1_SYS_CTRL_DVS.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * uSDHC
 */
struct [[gnu::packed]] usdhc1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 208; /*!< usdhc1's size in bytes. */

    /* Fields. */
    uint32_t DS_ADDR;              /*!< (read-write) DMA System Address */
    uint32_t BLK_ATT;              /*!< (read-write) Block Attributes */
    uint32_t CMD_ARG;              /*!< (read-write) Command Argument */
    uint32_t CMD_XFR_TYP;          /*!< (read-write) Command Transfer Type */
    uint32_t CMD_RSP0;             /*!< (read-write) Command Response0 */
    uint32_t CMD_RSP1;             /*!< (read-write) Command Response1 */
    uint32_t CMD_RSP2;             /*!< (read-write) Command Response2 */
    uint32_t CMD_RSP3;             /*!< (read-write) Command Response3 */
    uint32_t DATA_BUFF_ACC_PORT;   /*!< (read-write) Data Buffer Access Port */
    uint32_t PRES_STATE;           /*!< (read-write) Present State */
    uint32_t PROT_CTRL;            /*!< (read-write) Protocol Control */
    uint32_t SYS_CTRL;             /*!< (read-write) System Control */
    uint32_t INT_STATUS;           /*!< (read-write) Interrupt Status */
    uint32_t INT_STATUS_EN;        /*!< (read-write) Interrupt Status Enable */
    uint32_t INT_SIGNAL_EN;        /*!< (read-write) Interrupt Signal Enable */
    uint32_t AUTOCMD12_ERR_STATUS; /*!< (read-write) Auto CMD12 Error Status */
    uint32_t HOST_CTRL_CAP; /*!< (read-write) Host Controller Capabilities */
    uint32_t WTMK_LVL;      /*!< (read-write) Watermark Level */
    uint32_t MIX_CTRL;      /*!< (read-write) Mixer Control */
    const uint32_t reserved_padding0 = {};
    uint32_t FORCE_EVENT;     /*!< (read-write) Force Event */
    uint32_t ADMA_ERR_STATUS; /*!< (read-write) ADMA Error Status */
    uint32_t ADMA_SYS_ADDR;   /*!< (read-write) ADMA System Address */
    const uint32_t reserved_padding1 = {};
    uint32_t DLL_CTRL;   /*!< (read-write) DLL (Delay Line) Control */
    uint32_t DLL_STATUS; /*!< (read-write) DLL Status */
    uint32_t CLK_TUNE_CTRL_STATUS; /*!< (read-write) CLK Tuning Control and
                                      Status */
    const uint32_t reserved_padding2 = {};
    uint32_t STROBE_DLL_CTRL;   /*!< (read-write) Strobe DLL control */
    uint32_t STROBE_DLL_STATUS; /*!< (read-write) Strobe DLL status */
    static constexpr std::size_t reserved_padding3_length = 18;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t VEND_SPEC;   /*!< (read-write) Vendor Specific Register */
    uint32_t MMC_BOOT;    /*!< (read-write) MMC Boot */
    uint32_t VEND_SPEC2;  /*!< (read-write) Vendor Specific 2 Register */
    uint32_t TUNING_CTRL; /*!< (read-write) Tuning Control */

    /* Methods. */

    /**
     * Get DS_ADDR's DS_ADDR field.
     *
     * System address
     */
    inline uint32_t get_DS_ADDR_DS_ADDR() volatile
    {
        return (DS_ADDR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DS_ADDR's DS_ADDR field.
     *
     * System address
     */
    inline void set_DS_ADDR_DS_ADDR(uint32_t value) volatile
    {
        uint32_t curr = DS_ADDR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DS_ADDR = curr;
    }

    /**
     * Get BLK_ATT's BLKCNT field.
     *
     * Blocks count for current transfer
     */
    inline USDHC1_BLK_ATT_BLKCNT get_BLK_ATT_BLKCNT() volatile
    {
        return USDHC1_BLK_ATT_BLKCNT((BLK_ATT >> 16u) & 0b1111111111111111u);
    }

    /**
     * Set BLK_ATT's BLKCNT field.
     *
     * Blocks count for current transfer
     */
    inline void set_BLK_ATT_BLKCNT(USDHC1_BLK_ATT_BLKCNT value) volatile
    {
        uint32_t curr = BLK_ATT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        BLK_ATT = curr;
    }

    /**
     * Get BLK_ATT's BLKSIZE field.
     *
     * Transfer block size
     */
    inline USDHC1_BLK_ATT_BLKSIZE get_BLK_ATT_BLKSIZE() volatile
    {
        return USDHC1_BLK_ATT_BLKSIZE((BLK_ATT >> 0u) & 0b1111111111111u);
    }

    /**
     * Set BLK_ATT's BLKSIZE field.
     *
     * Transfer block size
     */
    inline void set_BLK_ATT_BLKSIZE(USDHC1_BLK_ATT_BLKSIZE value) volatile
    {
        uint32_t curr = BLK_ATT;

        curr &= ~(0b1111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111u) << 0u;

        BLK_ATT = curr;
    }

    /**
     * Get all of BLK_ATT's bit fields.
     *
     * (read-write) Block Attributes
     */
    inline void get_BLK_ATT(USDHC1_BLK_ATT_BLKCNT &BLKCNT,
                            USDHC1_BLK_ATT_BLKSIZE &BLKSIZE) volatile
    {
        uint32_t curr = BLK_ATT;

        BLKCNT = USDHC1_BLK_ATT_BLKCNT((curr >> 16u) & 0b1111111111111111u);
        BLKSIZE = USDHC1_BLK_ATT_BLKSIZE((curr >> 0u) & 0b1111111111111u);
    }

    /**
     * Set all of BLK_ATT's bit fields.
     *
     * (read-write) Block Attributes
     */
    inline void set_BLK_ATT(USDHC1_BLK_ATT_BLKCNT BLKCNT,
                            USDHC1_BLK_ATT_BLKSIZE BLKSIZE) volatile
    {
        uint32_t curr = BLK_ATT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(BLKCNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111u << 0u);
        curr |= (std::to_underlying(BLKSIZE) & 0b1111111111111u) << 0u;

        BLK_ATT = curr;
    }

    /**
     * Get CMD_ARG's CMDARG field.
     *
     * Command argument
     */
    inline uint32_t get_CMD_ARG_CMDARG() volatile
    {
        return (CMD_ARG >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set CMD_ARG's CMDARG field.
     *
     * Command argument
     */
    inline void set_CMD_ARG_CMDARG(uint32_t value) volatile
    {
        uint32_t curr = CMD_ARG;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CMD_ARG = curr;
    }

    /**
     * Get CMD_XFR_TYP's CMDINX field.
     *
     * Command index
     */
    inline uint8_t get_CMD_XFR_TYP_CMDINX() volatile
    {
        return (CMD_XFR_TYP >> 24u) & 0b111111u;
    }

    /**
     * Set CMD_XFR_TYP's CMDINX field.
     *
     * Command index
     */
    inline void set_CMD_XFR_TYP_CMDINX(uint8_t value) volatile
    {
        uint32_t curr = CMD_XFR_TYP;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        CMD_XFR_TYP = curr;
    }

    /**
     * Get CMD_XFR_TYP's CMDTYP field.
     *
     * Command type
     */
    inline USDHC1_CMD_XFR_TYP_CMDTYP get_CMD_XFR_TYP_CMDTYP() volatile
    {
        return USDHC1_CMD_XFR_TYP_CMDTYP((CMD_XFR_TYP >> 22u) & 0b11u);
    }

    /**
     * Set CMD_XFR_TYP's CMDTYP field.
     *
     * Command type
     */
    inline void set_CMD_XFR_TYP_CMDTYP(
        USDHC1_CMD_XFR_TYP_CMDTYP value) volatile
    {
        uint32_t curr = CMD_XFR_TYP;

        curr &= ~(0b11u << 22u);
        curr |= (std::to_underlying(value) & 0b11u) << 22u;

        CMD_XFR_TYP = curr;
    }

    /**
     * Get CMD_XFR_TYP's DPSEL bit.
     *
     * Data present select
     */
    inline bool get_CMD_XFR_TYP_DPSEL() volatile
    {
        return CMD_XFR_TYP & (1u << 21u);
    }

    /**
     * Set CMD_XFR_TYP's DPSEL bit.
     *
     * Data present select
     */
    inline void set_CMD_XFR_TYP_DPSEL() volatile
    {
        CMD_XFR_TYP |= 1u << 21u;
    }

    /**
     * Clear CMD_XFR_TYP's DPSEL bit.
     *
     * Data present select
     */
    inline void clear_CMD_XFR_TYP_DPSEL() volatile
    {
        CMD_XFR_TYP &= ~(1u << 21u);
    }

    /**
     * Toggle CMD_XFR_TYP's DPSEL bit.
     *
     * Data present select
     */
    inline void toggle_CMD_XFR_TYP_DPSEL() volatile
    {
        CMD_XFR_TYP ^= 1u << 21u;
    }

    /**
     * Get CMD_XFR_TYP's CICEN bit.
     *
     * Command index check enable
     */
    inline bool get_CMD_XFR_TYP_CICEN() volatile
    {
        return CMD_XFR_TYP & (1u << 20u);
    }

    /**
     * Set CMD_XFR_TYP's CICEN bit.
     *
     * Command index check enable
     */
    inline void set_CMD_XFR_TYP_CICEN() volatile
    {
        CMD_XFR_TYP |= 1u << 20u;
    }

    /**
     * Clear CMD_XFR_TYP's CICEN bit.
     *
     * Command index check enable
     */
    inline void clear_CMD_XFR_TYP_CICEN() volatile
    {
        CMD_XFR_TYP &= ~(1u << 20u);
    }

    /**
     * Toggle CMD_XFR_TYP's CICEN bit.
     *
     * Command index check enable
     */
    inline void toggle_CMD_XFR_TYP_CICEN() volatile
    {
        CMD_XFR_TYP ^= 1u << 20u;
    }

    /**
     * Get CMD_XFR_TYP's CCCEN bit.
     *
     * Command CRC check enable
     */
    inline bool get_CMD_XFR_TYP_CCCEN() volatile
    {
        return CMD_XFR_TYP & (1u << 19u);
    }

    /**
     * Set CMD_XFR_TYP's CCCEN bit.
     *
     * Command CRC check enable
     */
    inline void set_CMD_XFR_TYP_CCCEN() volatile
    {
        CMD_XFR_TYP |= 1u << 19u;
    }

    /**
     * Clear CMD_XFR_TYP's CCCEN bit.
     *
     * Command CRC check enable
     */
    inline void clear_CMD_XFR_TYP_CCCEN() volatile
    {
        CMD_XFR_TYP &= ~(1u << 19u);
    }

    /**
     * Toggle CMD_XFR_TYP's CCCEN bit.
     *
     * Command CRC check enable
     */
    inline void toggle_CMD_XFR_TYP_CCCEN() volatile
    {
        CMD_XFR_TYP ^= 1u << 19u;
    }

    /**
     * Get CMD_XFR_TYP's RSPTYP field.
     *
     * Response type select
     */
    inline USDHC1_CMD_XFR_TYP_RSPTYP get_CMD_XFR_TYP_RSPTYP() volatile
    {
        return USDHC1_CMD_XFR_TYP_RSPTYP((CMD_XFR_TYP >> 16u) & 0b11u);
    }

    /**
     * Set CMD_XFR_TYP's RSPTYP field.
     *
     * Response type select
     */
    inline void set_CMD_XFR_TYP_RSPTYP(
        USDHC1_CMD_XFR_TYP_RSPTYP value) volatile
    {
        uint32_t curr = CMD_XFR_TYP;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        CMD_XFR_TYP = curr;
    }

    /**
     * Get all of CMD_XFR_TYP's bit fields.
     *
     * (read-write) Command Transfer Type
     */
    inline void get_CMD_XFR_TYP(uint8_t &CMDINX,
                                USDHC1_CMD_XFR_TYP_CMDTYP &CMDTYP, bool &DPSEL,
                                bool &CICEN, bool &CCCEN,
                                USDHC1_CMD_XFR_TYP_RSPTYP &RSPTYP) volatile
    {
        uint32_t curr = CMD_XFR_TYP;

        CMDINX = (curr >> 24u) & 0b111111u;
        CMDTYP = USDHC1_CMD_XFR_TYP_CMDTYP((curr >> 22u) & 0b11u);
        DPSEL = curr & (1u << 21u);
        CICEN = curr & (1u << 20u);
        CCCEN = curr & (1u << 19u);
        RSPTYP = USDHC1_CMD_XFR_TYP_RSPTYP((curr >> 16u) & 0b11u);
    }

    /**
     * Set all of CMD_XFR_TYP's bit fields.
     *
     * (read-write) Command Transfer Type
     */
    inline void set_CMD_XFR_TYP(uint8_t CMDINX,
                                USDHC1_CMD_XFR_TYP_CMDTYP CMDTYP, bool DPSEL,
                                bool CICEN, bool CCCEN,
                                USDHC1_CMD_XFR_TYP_RSPTYP RSPTYP) volatile
    {
        uint32_t curr = CMD_XFR_TYP;

        curr &= ~(0b111111u << 24u);
        curr |= (CMDINX & 0b111111u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (std::to_underlying(CMDTYP) & 0b11u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (DPSEL & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (CICEN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CCCEN & 0b1u) << 19u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(RSPTYP) & 0b11u) << 16u;

        CMD_XFR_TYP = curr;
    }

    /**
     * Get CMD_RSP0's CMDRSP0 field.
     *
     * Command response 0
     */
    inline uint32_t get_CMD_RSP0_CMDRSP0() volatile
    {
        return (CMD_RSP0 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get CMD_RSP1's CMDRSP1 field.
     *
     * Command response 1
     */
    inline uint32_t get_CMD_RSP1_CMDRSP1() volatile
    {
        return (CMD_RSP1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get CMD_RSP2's CMDRSP2 field.
     *
     * Command response 2
     */
    inline uint32_t get_CMD_RSP2_CMDRSP2() volatile
    {
        return (CMD_RSP2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get CMD_RSP3's CMDRSP3 field.
     *
     * Command response 3
     */
    inline uint32_t get_CMD_RSP3_CMDRSP3() volatile
    {
        return (CMD_RSP3 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get DATA_BUFF_ACC_PORT's DATCONT field.
     *
     * Data content
     */
    inline uint32_t get_DATA_BUFF_ACC_PORT_DATCONT() volatile
    {
        return (DATA_BUFF_ACC_PORT >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set DATA_BUFF_ACC_PORT's DATCONT field.
     *
     * Data content
     */
    inline void set_DATA_BUFF_ACC_PORT_DATCONT(uint32_t value) volatile
    {
        uint32_t curr = DATA_BUFF_ACC_PORT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DATA_BUFF_ACC_PORT = curr;
    }

    /**
     * Get PRES_STATE's DLSL field.
     *
     * DATA[7:0] line signal level
     */
    inline USDHC1_PRES_STATE_DLSL get_PRES_STATE_DLSL() volatile
    {
        return USDHC1_PRES_STATE_DLSL((PRES_STATE >> 24u) & 0b11111111u);
    }

    /**
     * Get PRES_STATE's CLSL bit.
     *
     * CMD line signal level
     */
    inline bool get_PRES_STATE_CLSL() volatile
    {
        return PRES_STATE & (1u << 23u);
    }

    /**
     * Get PRES_STATE's WPSPL bit.
     *
     * Write protect switch pin level
     */
    inline bool get_PRES_STATE_WPSPL() volatile
    {
        return PRES_STATE & (1u << 19u);
    }

    /**
     * Get PRES_STATE's CDPL bit.
     *
     * Card detect pin level
     */
    inline bool get_PRES_STATE_CDPL() volatile
    {
        return PRES_STATE & (1u << 18u);
    }

    /**
     * Get PRES_STATE's CINST bit.
     *
     * Card inserted
     */
    inline bool get_PRES_STATE_CINST() volatile
    {
        return PRES_STATE & (1u << 16u);
    }

    /**
     * Get PRES_STATE's TSCD bit.
     *
     * Tap select change done
     */
    inline bool get_PRES_STATE_TSCD() volatile
    {
        return PRES_STATE & (1u << 15u);
    }

    /**
     * Get PRES_STATE's RTR bit.
     *
     * Re-Tuning Request (only for SD3.0 SDR104 mode,and EMMC HS200 mode)
     */
    inline bool get_PRES_STATE_RTR() volatile
    {
        return PRES_STATE & (1u << 12u);
    }

    /**
     * Get PRES_STATE's BREN bit.
     *
     * Buffer read enable
     */
    inline bool get_PRES_STATE_BREN() volatile
    {
        return PRES_STATE & (1u << 11u);
    }

    /**
     * Get PRES_STATE's BWEN bit.
     *
     * Buffer write enable
     */
    inline bool get_PRES_STATE_BWEN() volatile
    {
        return PRES_STATE & (1u << 10u);
    }

    /**
     * Get PRES_STATE's RTA bit.
     *
     * Read transfer active
     */
    inline bool get_PRES_STATE_RTA() volatile
    {
        return PRES_STATE & (1u << 9u);
    }

    /**
     * Get PRES_STATE's WTA bit.
     *
     * Write transfer active
     */
    inline bool get_PRES_STATE_WTA() volatile
    {
        return PRES_STATE & (1u << 8u);
    }

    /**
     * Get PRES_STATE's SDOFF bit.
     *
     * SD clock gated off internally
     */
    inline bool get_PRES_STATE_SDOFF() volatile
    {
        return PRES_STATE & (1u << 7u);
    }

    /**
     * Get PRES_STATE's PEROFF bit.
     *
     * IPG_PERCLK gated off internally
     */
    inline bool get_PRES_STATE_PEROFF() volatile
    {
        return PRES_STATE & (1u << 6u);
    }

    /**
     * Get PRES_STATE's HCKOFF bit.
     *
     * HCLK gated off internally
     */
    inline bool get_PRES_STATE_HCKOFF() volatile
    {
        return PRES_STATE & (1u << 5u);
    }

    /**
     * Get PRES_STATE's IPGOFF bit.
     *
     * Peripheral clock gated off internally
     */
    inline bool get_PRES_STATE_IPGOFF() volatile
    {
        return PRES_STATE & (1u << 4u);
    }

    /**
     * Get PRES_STATE's SDSTB bit.
     *
     * SD clock stable
     */
    inline bool get_PRES_STATE_SDSTB() volatile
    {
        return PRES_STATE & (1u << 3u);
    }

    /**
     * Get PRES_STATE's DLA bit.
     *
     * Data line active
     */
    inline bool get_PRES_STATE_DLA() volatile
    {
        return PRES_STATE & (1u << 2u);
    }

    /**
     * Get PRES_STATE's CDIHB bit.
     *
     * Command Inhibit Data (DATA)
     */
    inline bool get_PRES_STATE_CDIHB() volatile
    {
        return PRES_STATE & (1u << 1u);
    }

    /**
     * Get PRES_STATE's CIHB bit.
     *
     * Command inhibit (CMD)
     */
    inline bool get_PRES_STATE_CIHB() volatile
    {
        return PRES_STATE & (1u << 0u);
    }

    /**
     * Get all of PRES_STATE's bit fields.
     *
     * (read-write) Present State
     */
    inline void get_PRES_STATE(USDHC1_PRES_STATE_DLSL &DLSL, bool &CLSL,
                               bool &WPSPL, bool &CDPL, bool &CINST,
                               bool &TSCD, bool &RTR, bool &BREN, bool &BWEN,
                               bool &RTA, bool &WTA, bool &SDOFF, bool &PEROFF,
                               bool &HCKOFF, bool &IPGOFF, bool &SDSTB,
                               bool &DLA, bool &CDIHB, bool &CIHB) volatile
    {
        uint32_t curr = PRES_STATE;

        DLSL = USDHC1_PRES_STATE_DLSL((curr >> 24u) & 0b11111111u);
        CLSL = curr & (1u << 23u);
        WPSPL = curr & (1u << 19u);
        CDPL = curr & (1u << 18u);
        CINST = curr & (1u << 16u);
        TSCD = curr & (1u << 15u);
        RTR = curr & (1u << 12u);
        BREN = curr & (1u << 11u);
        BWEN = curr & (1u << 10u);
        RTA = curr & (1u << 9u);
        WTA = curr & (1u << 8u);
        SDOFF = curr & (1u << 7u);
        PEROFF = curr & (1u << 6u);
        HCKOFF = curr & (1u << 5u);
        IPGOFF = curr & (1u << 4u);
        SDSTB = curr & (1u << 3u);
        DLA = curr & (1u << 2u);
        CDIHB = curr & (1u << 1u);
        CIHB = curr & (1u << 0u);
    }

    /**
     * Get PROT_CTRL's NON_EXACT_BLK_RD bit.
     *
     * Non-exact block read
     */
    inline bool get_PROT_CTRL_NON_EXACT_BLK_RD() volatile
    {
        return PROT_CTRL & (1u << 30u);
    }

    /**
     * Set PROT_CTRL's NON_EXACT_BLK_RD bit.
     *
     * Non-exact block read
     */
    inline void set_PROT_CTRL_NON_EXACT_BLK_RD() volatile
    {
        PROT_CTRL |= 1u << 30u;
    }

    /**
     * Clear PROT_CTRL's NON_EXACT_BLK_RD bit.
     *
     * Non-exact block read
     */
    inline void clear_PROT_CTRL_NON_EXACT_BLK_RD() volatile
    {
        PROT_CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle PROT_CTRL's NON_EXACT_BLK_RD bit.
     *
     * Non-exact block read
     */
    inline void toggle_PROT_CTRL_NON_EXACT_BLK_RD() volatile
    {
        PROT_CTRL ^= 1u << 30u;
    }

    /**
     * Get PROT_CTRL's WECRM bit.
     *
     * Wakeup event enable on SD card removal
     */
    inline bool get_PROT_CTRL_WECRM() volatile
    {
        return PROT_CTRL & (1u << 26u);
    }

    /**
     * Set PROT_CTRL's WECRM bit.
     *
     * Wakeup event enable on SD card removal
     */
    inline void set_PROT_CTRL_WECRM() volatile
    {
        PROT_CTRL |= 1u << 26u;
    }

    /**
     * Clear PROT_CTRL's WECRM bit.
     *
     * Wakeup event enable on SD card removal
     */
    inline void clear_PROT_CTRL_WECRM() volatile
    {
        PROT_CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle PROT_CTRL's WECRM bit.
     *
     * Wakeup event enable on SD card removal
     */
    inline void toggle_PROT_CTRL_WECRM() volatile
    {
        PROT_CTRL ^= 1u << 26u;
    }

    /**
     * Get PROT_CTRL's WECINS bit.
     *
     * Wakeup event enable on SD card insertion
     */
    inline bool get_PROT_CTRL_WECINS() volatile
    {
        return PROT_CTRL & (1u << 25u);
    }

    /**
     * Set PROT_CTRL's WECINS bit.
     *
     * Wakeup event enable on SD card insertion
     */
    inline void set_PROT_CTRL_WECINS() volatile
    {
        PROT_CTRL |= 1u << 25u;
    }

    /**
     * Clear PROT_CTRL's WECINS bit.
     *
     * Wakeup event enable on SD card insertion
     */
    inline void clear_PROT_CTRL_WECINS() volatile
    {
        PROT_CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle PROT_CTRL's WECINS bit.
     *
     * Wakeup event enable on SD card insertion
     */
    inline void toggle_PROT_CTRL_WECINS() volatile
    {
        PROT_CTRL ^= 1u << 25u;
    }

    /**
     * Get PROT_CTRL's WECINT bit.
     *
     * Wakeup event enable on card interrupt
     */
    inline bool get_PROT_CTRL_WECINT() volatile
    {
        return PROT_CTRL & (1u << 24u);
    }

    /**
     * Set PROT_CTRL's WECINT bit.
     *
     * Wakeup event enable on card interrupt
     */
    inline void set_PROT_CTRL_WECINT() volatile
    {
        PROT_CTRL |= 1u << 24u;
    }

    /**
     * Clear PROT_CTRL's WECINT bit.
     *
     * Wakeup event enable on card interrupt
     */
    inline void clear_PROT_CTRL_WECINT() volatile
    {
        PROT_CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle PROT_CTRL's WECINT bit.
     *
     * Wakeup event enable on card interrupt
     */
    inline void toggle_PROT_CTRL_WECINT() volatile
    {
        PROT_CTRL ^= 1u << 24u;
    }

    /**
     * Get PROT_CTRL's RD_DONE_NO_8CLK bit.
     *
     * Read performed number 8 clock
     */
    inline bool get_PROT_CTRL_RD_DONE_NO_8CLK() volatile
    {
        return PROT_CTRL & (1u << 20u);
    }

    /**
     * Set PROT_CTRL's RD_DONE_NO_8CLK bit.
     *
     * Read performed number 8 clock
     */
    inline void set_PROT_CTRL_RD_DONE_NO_8CLK() volatile
    {
        PROT_CTRL |= 1u << 20u;
    }

    /**
     * Clear PROT_CTRL's RD_DONE_NO_8CLK bit.
     *
     * Read performed number 8 clock
     */
    inline void clear_PROT_CTRL_RD_DONE_NO_8CLK() volatile
    {
        PROT_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle PROT_CTRL's RD_DONE_NO_8CLK bit.
     *
     * Read performed number 8 clock
     */
    inline void toggle_PROT_CTRL_RD_DONE_NO_8CLK() volatile
    {
        PROT_CTRL ^= 1u << 20u;
    }

    /**
     * Get PROT_CTRL's IABG bit.
     *
     * Interrupt at block gap
     */
    inline bool get_PROT_CTRL_IABG() volatile
    {
        return PROT_CTRL & (1u << 19u);
    }

    /**
     * Set PROT_CTRL's IABG bit.
     *
     * Interrupt at block gap
     */
    inline void set_PROT_CTRL_IABG() volatile
    {
        PROT_CTRL |= 1u << 19u;
    }

    /**
     * Clear PROT_CTRL's IABG bit.
     *
     * Interrupt at block gap
     */
    inline void clear_PROT_CTRL_IABG() volatile
    {
        PROT_CTRL &= ~(1u << 19u);
    }

    /**
     * Toggle PROT_CTRL's IABG bit.
     *
     * Interrupt at block gap
     */
    inline void toggle_PROT_CTRL_IABG() volatile
    {
        PROT_CTRL ^= 1u << 19u;
    }

    /**
     * Get PROT_CTRL's RWCTL bit.
     *
     * Read wait control
     */
    inline bool get_PROT_CTRL_RWCTL() volatile
    {
        return PROT_CTRL & (1u << 18u);
    }

    /**
     * Set PROT_CTRL's RWCTL bit.
     *
     * Read wait control
     */
    inline void set_PROT_CTRL_RWCTL() volatile
    {
        PROT_CTRL |= 1u << 18u;
    }

    /**
     * Clear PROT_CTRL's RWCTL bit.
     *
     * Read wait control
     */
    inline void clear_PROT_CTRL_RWCTL() volatile
    {
        PROT_CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle PROT_CTRL's RWCTL bit.
     *
     * Read wait control
     */
    inline void toggle_PROT_CTRL_RWCTL() volatile
    {
        PROT_CTRL ^= 1u << 18u;
    }

    /**
     * Get PROT_CTRL's CREQ bit.
     *
     * Continue request
     */
    inline bool get_PROT_CTRL_CREQ() volatile
    {
        return PROT_CTRL & (1u << 17u);
    }

    /**
     * Set PROT_CTRL's CREQ bit.
     *
     * Continue request
     */
    inline void set_PROT_CTRL_CREQ() volatile
    {
        PROT_CTRL |= 1u << 17u;
    }

    /**
     * Clear PROT_CTRL's CREQ bit.
     *
     * Continue request
     */
    inline void clear_PROT_CTRL_CREQ() volatile
    {
        PROT_CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle PROT_CTRL's CREQ bit.
     *
     * Continue request
     */
    inline void toggle_PROT_CTRL_CREQ() volatile
    {
        PROT_CTRL ^= 1u << 17u;
    }

    /**
     * Get PROT_CTRL's SABGREQ bit.
     *
     * Stop at block gap request
     */
    inline bool get_PROT_CTRL_SABGREQ() volatile
    {
        return PROT_CTRL & (1u << 16u);
    }

    /**
     * Set PROT_CTRL's SABGREQ bit.
     *
     * Stop at block gap request
     */
    inline void set_PROT_CTRL_SABGREQ() volatile
    {
        PROT_CTRL |= 1u << 16u;
    }

    /**
     * Clear PROT_CTRL's SABGREQ bit.
     *
     * Stop at block gap request
     */
    inline void clear_PROT_CTRL_SABGREQ() volatile
    {
        PROT_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle PROT_CTRL's SABGREQ bit.
     *
     * Stop at block gap request
     */
    inline void toggle_PROT_CTRL_SABGREQ() volatile
    {
        PROT_CTRL ^= 1u << 16u;
    }

    /**
     * Get PROT_CTRL's DMASEL field.
     *
     * DMA select
     */
    inline USDHC1_PROT_CTRL_DMASEL get_PROT_CTRL_DMASEL() volatile
    {
        return USDHC1_PROT_CTRL_DMASEL((PROT_CTRL >> 8u) & 0b11u);
    }

    /**
     * Set PROT_CTRL's DMASEL field.
     *
     * DMA select
     */
    inline void set_PROT_CTRL_DMASEL(USDHC1_PROT_CTRL_DMASEL value) volatile
    {
        uint32_t curr = PROT_CTRL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        PROT_CTRL = curr;
    }

    /**
     * Get PROT_CTRL's CDSS bit.
     *
     * Card detect signal selection
     */
    inline bool get_PROT_CTRL_CDSS() volatile
    {
        return PROT_CTRL & (1u << 7u);
    }

    /**
     * Set PROT_CTRL's CDSS bit.
     *
     * Card detect signal selection
     */
    inline void set_PROT_CTRL_CDSS() volatile
    {
        PROT_CTRL |= 1u << 7u;
    }

    /**
     * Clear PROT_CTRL's CDSS bit.
     *
     * Card detect signal selection
     */
    inline void clear_PROT_CTRL_CDSS() volatile
    {
        PROT_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle PROT_CTRL's CDSS bit.
     *
     * Card detect signal selection
     */
    inline void toggle_PROT_CTRL_CDSS() volatile
    {
        PROT_CTRL ^= 1u << 7u;
    }

    /**
     * Get PROT_CTRL's CDTL bit.
     *
     * Card detect test level
     */
    inline bool get_PROT_CTRL_CDTL() volatile
    {
        return PROT_CTRL & (1u << 6u);
    }

    /**
     * Set PROT_CTRL's CDTL bit.
     *
     * Card detect test level
     */
    inline void set_PROT_CTRL_CDTL() volatile
    {
        PROT_CTRL |= 1u << 6u;
    }

    /**
     * Clear PROT_CTRL's CDTL bit.
     *
     * Card detect test level
     */
    inline void clear_PROT_CTRL_CDTL() volatile
    {
        PROT_CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle PROT_CTRL's CDTL bit.
     *
     * Card detect test level
     */
    inline void toggle_PROT_CTRL_CDTL() volatile
    {
        PROT_CTRL ^= 1u << 6u;
    }

    /**
     * Get PROT_CTRL's EMODE field.
     *
     * Endian mode
     */
    inline USDHC1_PROT_CTRL_EMODE get_PROT_CTRL_EMODE() volatile
    {
        return USDHC1_PROT_CTRL_EMODE((PROT_CTRL >> 4u) & 0b11u);
    }

    /**
     * Set PROT_CTRL's EMODE field.
     *
     * Endian mode
     */
    inline void set_PROT_CTRL_EMODE(USDHC1_PROT_CTRL_EMODE value) volatile
    {
        uint32_t curr = PROT_CTRL;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        PROT_CTRL = curr;
    }

    /**
     * Get PROT_CTRL's D3CD bit.
     *
     * DATA3 as card detection pin
     */
    inline bool get_PROT_CTRL_D3CD() volatile
    {
        return PROT_CTRL & (1u << 3u);
    }

    /**
     * Set PROT_CTRL's D3CD bit.
     *
     * DATA3 as card detection pin
     */
    inline void set_PROT_CTRL_D3CD() volatile
    {
        PROT_CTRL |= 1u << 3u;
    }

    /**
     * Clear PROT_CTRL's D3CD bit.
     *
     * DATA3 as card detection pin
     */
    inline void clear_PROT_CTRL_D3CD() volatile
    {
        PROT_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle PROT_CTRL's D3CD bit.
     *
     * DATA3 as card detection pin
     */
    inline void toggle_PROT_CTRL_D3CD() volatile
    {
        PROT_CTRL ^= 1u << 3u;
    }

    /**
     * Get PROT_CTRL's DTW field.
     *
     * Data transfer width
     */
    inline USDHC1_PROT_CTRL_DTW get_PROT_CTRL_DTW() volatile
    {
        return USDHC1_PROT_CTRL_DTW((PROT_CTRL >> 1u) & 0b11u);
    }

    /**
     * Set PROT_CTRL's DTW field.
     *
     * Data transfer width
     */
    inline void set_PROT_CTRL_DTW(USDHC1_PROT_CTRL_DTW value) volatile
    {
        uint32_t curr = PROT_CTRL;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        PROT_CTRL = curr;
    }

    /**
     * Get all of PROT_CTRL's bit fields.
     *
     * (read-write) Protocol Control
     */
    inline void get_PROT_CTRL(bool &NON_EXACT_BLK_RD, bool &WECRM,
                              bool &WECINS, bool &WECINT,
                              bool &RD_DONE_NO_8CLK, bool &IABG, bool &RWCTL,
                              bool &CREQ, bool &SABGREQ,
                              USDHC1_PROT_CTRL_DMASEL &DMASEL, bool &CDSS,
                              bool &CDTL, USDHC1_PROT_CTRL_EMODE &EMODE,
                              bool &D3CD, USDHC1_PROT_CTRL_DTW &DTW) volatile
    {
        uint32_t curr = PROT_CTRL;

        NON_EXACT_BLK_RD = curr & (1u << 30u);
        WECRM = curr & (1u << 26u);
        WECINS = curr & (1u << 25u);
        WECINT = curr & (1u << 24u);
        RD_DONE_NO_8CLK = curr & (1u << 20u);
        IABG = curr & (1u << 19u);
        RWCTL = curr & (1u << 18u);
        CREQ = curr & (1u << 17u);
        SABGREQ = curr & (1u << 16u);
        DMASEL = USDHC1_PROT_CTRL_DMASEL((curr >> 8u) & 0b11u);
        CDSS = curr & (1u << 7u);
        CDTL = curr & (1u << 6u);
        EMODE = USDHC1_PROT_CTRL_EMODE((curr >> 4u) & 0b11u);
        D3CD = curr & (1u << 3u);
        DTW = USDHC1_PROT_CTRL_DTW((curr >> 1u) & 0b11u);
    }

    /**
     * Set all of PROT_CTRL's bit fields.
     *
     * (read-write) Protocol Control
     */
    inline void set_PROT_CTRL(bool NON_EXACT_BLK_RD, bool WECRM, bool WECINS,
                              bool WECINT, bool RD_DONE_NO_8CLK, bool IABG,
                              bool RWCTL, bool CREQ, bool SABGREQ,
                              USDHC1_PROT_CTRL_DMASEL DMASEL, bool CDSS,
                              bool CDTL, USDHC1_PROT_CTRL_EMODE EMODE,
                              bool D3CD, USDHC1_PROT_CTRL_DTW DTW) volatile
    {
        uint32_t curr = PROT_CTRL;

        curr &= ~(0b1u << 30u);
        curr |= (NON_EXACT_BLK_RD & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (WECRM & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (WECINS & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (WECINT & 0b1u) << 24u;
        curr &= ~(0b1u << 20u);
        curr |= (RD_DONE_NO_8CLK & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (IABG & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RWCTL & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (CREQ & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SABGREQ & 0b1u) << 16u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(DMASEL) & 0b11u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CDSS & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CDTL & 0b1u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(EMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (D3CD & 0b1u) << 3u;
        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(DTW) & 0b11u) << 1u;

        PROT_CTRL = curr;
    }

    /**
     * Get SYS_CTRL's RSTT bit.
     *
     * Reset tuning
     */
    inline bool get_SYS_CTRL_RSTT() volatile
    {
        return SYS_CTRL & (1u << 28u);
    }

    /**
     * Set SYS_CTRL's RSTT bit.
     *
     * Reset tuning
     */
    inline void set_SYS_CTRL_RSTT() volatile
    {
        SYS_CTRL |= 1u << 28u;
    }

    /**
     * Clear SYS_CTRL's RSTT bit.
     *
     * Reset tuning
     */
    inline void clear_SYS_CTRL_RSTT() volatile
    {
        SYS_CTRL &= ~(1u << 28u);
    }

    /**
     * Toggle SYS_CTRL's RSTT bit.
     *
     * Reset tuning
     */
    inline void toggle_SYS_CTRL_RSTT() volatile
    {
        SYS_CTRL ^= 1u << 28u;
    }

    /**
     * Get SYS_CTRL's INITA bit.
     *
     * Initialization active
     */
    inline bool get_SYS_CTRL_INITA() volatile
    {
        return SYS_CTRL & (1u << 27u);
    }

    /**
     * Set SYS_CTRL's INITA bit.
     *
     * Initialization active
     */
    inline void set_SYS_CTRL_INITA() volatile
    {
        SYS_CTRL |= 1u << 27u;
    }

    /**
     * Clear SYS_CTRL's INITA bit.
     *
     * Initialization active
     */
    inline void clear_SYS_CTRL_INITA() volatile
    {
        SYS_CTRL &= ~(1u << 27u);
    }

    /**
     * Toggle SYS_CTRL's INITA bit.
     *
     * Initialization active
     */
    inline void toggle_SYS_CTRL_INITA() volatile
    {
        SYS_CTRL ^= 1u << 27u;
    }

    /**
     * Get SYS_CTRL's RSTD bit.
     *
     * Software reset for data line
     */
    inline bool get_SYS_CTRL_RSTD() volatile
    {
        return SYS_CTRL & (1u << 26u);
    }

    /**
     * Set SYS_CTRL's RSTD bit.
     *
     * Software reset for data line
     */
    inline void set_SYS_CTRL_RSTD() volatile
    {
        SYS_CTRL |= 1u << 26u;
    }

    /**
     * Clear SYS_CTRL's RSTD bit.
     *
     * Software reset for data line
     */
    inline void clear_SYS_CTRL_RSTD() volatile
    {
        SYS_CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle SYS_CTRL's RSTD bit.
     *
     * Software reset for data line
     */
    inline void toggle_SYS_CTRL_RSTD() volatile
    {
        SYS_CTRL ^= 1u << 26u;
    }

    /**
     * Get SYS_CTRL's RSTC bit.
     *
     * Software reset for CMD line
     */
    inline bool get_SYS_CTRL_RSTC() volatile
    {
        return SYS_CTRL & (1u << 25u);
    }

    /**
     * Set SYS_CTRL's RSTC bit.
     *
     * Software reset for CMD line
     */
    inline void set_SYS_CTRL_RSTC() volatile
    {
        SYS_CTRL |= 1u << 25u;
    }

    /**
     * Clear SYS_CTRL's RSTC bit.
     *
     * Software reset for CMD line
     */
    inline void clear_SYS_CTRL_RSTC() volatile
    {
        SYS_CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle SYS_CTRL's RSTC bit.
     *
     * Software reset for CMD line
     */
    inline void toggle_SYS_CTRL_RSTC() volatile
    {
        SYS_CTRL ^= 1u << 25u;
    }

    /**
     * Get SYS_CTRL's RSTA bit.
     *
     * Software reset for all
     */
    inline bool get_SYS_CTRL_RSTA() volatile
    {
        return SYS_CTRL & (1u << 24u);
    }

    /**
     * Set SYS_CTRL's RSTA bit.
     *
     * Software reset for all
     */
    inline void set_SYS_CTRL_RSTA() volatile
    {
        SYS_CTRL |= 1u << 24u;
    }

    /**
     * Clear SYS_CTRL's RSTA bit.
     *
     * Software reset for all
     */
    inline void clear_SYS_CTRL_RSTA() volatile
    {
        SYS_CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle SYS_CTRL's RSTA bit.
     *
     * Software reset for all
     */
    inline void toggle_SYS_CTRL_RSTA() volatile
    {
        SYS_CTRL ^= 1u << 24u;
    }

    /**
     * Get SYS_CTRL's IPP_RST_N bit.
     *
     * Hardware reset
     */
    inline bool get_SYS_CTRL_IPP_RST_N() volatile
    {
        return SYS_CTRL & (1u << 23u);
    }

    /**
     * Set SYS_CTRL's IPP_RST_N bit.
     *
     * Hardware reset
     */
    inline void set_SYS_CTRL_IPP_RST_N() volatile
    {
        SYS_CTRL |= 1u << 23u;
    }

    /**
     * Clear SYS_CTRL's IPP_RST_N bit.
     *
     * Hardware reset
     */
    inline void clear_SYS_CTRL_IPP_RST_N() volatile
    {
        SYS_CTRL &= ~(1u << 23u);
    }

    /**
     * Toggle SYS_CTRL's IPP_RST_N bit.
     *
     * Hardware reset
     */
    inline void toggle_SYS_CTRL_IPP_RST_N() volatile
    {
        SYS_CTRL ^= 1u << 23u;
    }

    /**
     * Get SYS_CTRL's DTOCV field.
     *
     * Data timeout counter value
     */
    inline USDHC1_SYS_CTRL_DTOCV get_SYS_CTRL_DTOCV() volatile
    {
        return USDHC1_SYS_CTRL_DTOCV((SYS_CTRL >> 16u) & 0b1111u);
    }

    /**
     * Set SYS_CTRL's DTOCV field.
     *
     * Data timeout counter value
     */
    inline void set_SYS_CTRL_DTOCV(USDHC1_SYS_CTRL_DTOCV value) volatile
    {
        uint32_t curr = SYS_CTRL;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        SYS_CTRL = curr;
    }

    /**
     * Get SYS_CTRL's SDCLKFS field.
     *
     * SDCLK frequency select
     */
    inline uint8_t get_SYS_CTRL_SDCLKFS() volatile
    {
        return (SYS_CTRL >> 8u) & 0b11111111u;
    }

    /**
     * Set SYS_CTRL's SDCLKFS field.
     *
     * SDCLK frequency select
     */
    inline void set_SYS_CTRL_SDCLKFS(uint8_t value) volatile
    {
        uint32_t curr = SYS_CTRL;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SYS_CTRL = curr;
    }

    /**
     * Get SYS_CTRL's DVS field.
     *
     * Divisor
     */
    inline USDHC1_SYS_CTRL_DVS get_SYS_CTRL_DVS() volatile
    {
        return USDHC1_SYS_CTRL_DVS((SYS_CTRL >> 4u) & 0b1111u);
    }

    /**
     * Set SYS_CTRL's DVS field.
     *
     * Divisor
     */
    inline void set_SYS_CTRL_DVS(USDHC1_SYS_CTRL_DVS value) volatile
    {
        uint32_t curr = SYS_CTRL;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        SYS_CTRL = curr;
    }

    /**
     * Get all of SYS_CTRL's bit fields.
     *
     * (read-write) System Control
     */
    inline void get_SYS_CTRL(bool &RSTT, bool &INITA, bool &RSTD, bool &RSTC,
                             bool &RSTA, bool &IPP_RST_N,
                             USDHC1_SYS_CTRL_DTOCV &DTOCV, uint8_t &SDCLKFS,
                             USDHC1_SYS_CTRL_DVS &DVS) volatile
    {
        uint32_t curr = SYS_CTRL;

        RSTT = curr & (1u << 28u);
        INITA = curr & (1u << 27u);
        RSTD = curr & (1u << 26u);
        RSTC = curr & (1u << 25u);
        RSTA = curr & (1u << 24u);
        IPP_RST_N = curr & (1u << 23u);
        DTOCV = USDHC1_SYS_CTRL_DTOCV((curr >> 16u) & 0b1111u);
        SDCLKFS = (curr >> 8u) & 0b11111111u;
        DVS = USDHC1_SYS_CTRL_DVS((curr >> 4u) & 0b1111u);
    }

    /**
     * Set all of SYS_CTRL's bit fields.
     *
     * (read-write) System Control
     */
    inline void set_SYS_CTRL(bool RSTT, bool INITA, bool RSTD, bool RSTC,
                             bool RSTA, bool IPP_RST_N,
                             USDHC1_SYS_CTRL_DTOCV DTOCV, uint8_t SDCLKFS,
                             USDHC1_SYS_CTRL_DVS DVS) volatile
    {
        uint32_t curr = SYS_CTRL;

        curr &= ~(0b1u << 28u);
        curr |= (RSTT & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (INITA & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (RSTD & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (RSTC & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RSTA & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (IPP_RST_N & 0b1u) << 23u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(DTOCV) & 0b1111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (SDCLKFS & 0b11111111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(DVS) & 0b1111u) << 4u;

        SYS_CTRL = curr;
    }

    /**
     * Get INT_STATUS's DMAE bit.
     *
     * DMA error
     */
    inline bool get_INT_STATUS_DMAE() volatile
    {
        return INT_STATUS & (1u << 28u);
    }

    /**
     * Set INT_STATUS's DMAE bit.
     *
     * DMA error
     */
    inline void set_INT_STATUS_DMAE() volatile
    {
        INT_STATUS |= 1u << 28u;
    }

    /**
     * Clear INT_STATUS's DMAE bit.
     *
     * DMA error
     */
    inline void clear_INT_STATUS_DMAE() volatile
    {
        INT_STATUS &= ~(1u << 28u);
    }

    /**
     * Toggle INT_STATUS's DMAE bit.
     *
     * DMA error
     */
    inline void toggle_INT_STATUS_DMAE() volatile
    {
        INT_STATUS ^= 1u << 28u;
    }

    /**
     * Get INT_STATUS's TNE bit.
     *
     * Tuning error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline bool get_INT_STATUS_TNE() volatile
    {
        return INT_STATUS & (1u << 26u);
    }

    /**
     * Set INT_STATUS's TNE bit.
     *
     * Tuning error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void set_INT_STATUS_TNE() volatile
    {
        INT_STATUS |= 1u << 26u;
    }

    /**
     * Clear INT_STATUS's TNE bit.
     *
     * Tuning error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void clear_INT_STATUS_TNE() volatile
    {
        INT_STATUS &= ~(1u << 26u);
    }

    /**
     * Toggle INT_STATUS's TNE bit.
     *
     * Tuning error: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void toggle_INT_STATUS_TNE() volatile
    {
        INT_STATUS ^= 1u << 26u;
    }

    /**
     * Get INT_STATUS's AC12E bit.
     *
     * Auto CMD12 error
     */
    inline bool get_INT_STATUS_AC12E() volatile
    {
        return INT_STATUS & (1u << 24u);
    }

    /**
     * Set INT_STATUS's AC12E bit.
     *
     * Auto CMD12 error
     */
    inline void set_INT_STATUS_AC12E() volatile
    {
        INT_STATUS |= 1u << 24u;
    }

    /**
     * Clear INT_STATUS's AC12E bit.
     *
     * Auto CMD12 error
     */
    inline void clear_INT_STATUS_AC12E() volatile
    {
        INT_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle INT_STATUS's AC12E bit.
     *
     * Auto CMD12 error
     */
    inline void toggle_INT_STATUS_AC12E() volatile
    {
        INT_STATUS ^= 1u << 24u;
    }

    /**
     * Get INT_STATUS's DEBE bit.
     *
     * Data end bit error
     */
    inline bool get_INT_STATUS_DEBE() volatile
    {
        return INT_STATUS & (1u << 22u);
    }

    /**
     * Set INT_STATUS's DEBE bit.
     *
     * Data end bit error
     */
    inline void set_INT_STATUS_DEBE() volatile
    {
        INT_STATUS |= 1u << 22u;
    }

    /**
     * Clear INT_STATUS's DEBE bit.
     *
     * Data end bit error
     */
    inline void clear_INT_STATUS_DEBE() volatile
    {
        INT_STATUS &= ~(1u << 22u);
    }

    /**
     * Toggle INT_STATUS's DEBE bit.
     *
     * Data end bit error
     */
    inline void toggle_INT_STATUS_DEBE() volatile
    {
        INT_STATUS ^= 1u << 22u;
    }

    /**
     * Get INT_STATUS's DCE bit.
     *
     * Data CRC error
     */
    inline bool get_INT_STATUS_DCE() volatile
    {
        return INT_STATUS & (1u << 21u);
    }

    /**
     * Set INT_STATUS's DCE bit.
     *
     * Data CRC error
     */
    inline void set_INT_STATUS_DCE() volatile
    {
        INT_STATUS |= 1u << 21u;
    }

    /**
     * Clear INT_STATUS's DCE bit.
     *
     * Data CRC error
     */
    inline void clear_INT_STATUS_DCE() volatile
    {
        INT_STATUS &= ~(1u << 21u);
    }

    /**
     * Toggle INT_STATUS's DCE bit.
     *
     * Data CRC error
     */
    inline void toggle_INT_STATUS_DCE() volatile
    {
        INT_STATUS ^= 1u << 21u;
    }

    /**
     * Get INT_STATUS's DTOE bit.
     *
     * Data timeout error
     */
    inline bool get_INT_STATUS_DTOE() volatile
    {
        return INT_STATUS & (1u << 20u);
    }

    /**
     * Set INT_STATUS's DTOE bit.
     *
     * Data timeout error
     */
    inline void set_INT_STATUS_DTOE() volatile
    {
        INT_STATUS |= 1u << 20u;
    }

    /**
     * Clear INT_STATUS's DTOE bit.
     *
     * Data timeout error
     */
    inline void clear_INT_STATUS_DTOE() volatile
    {
        INT_STATUS &= ~(1u << 20u);
    }

    /**
     * Toggle INT_STATUS's DTOE bit.
     *
     * Data timeout error
     */
    inline void toggle_INT_STATUS_DTOE() volatile
    {
        INT_STATUS ^= 1u << 20u;
    }

    /**
     * Get INT_STATUS's CIE bit.
     *
     * Command index error
     */
    inline bool get_INT_STATUS_CIE() volatile
    {
        return INT_STATUS & (1u << 19u);
    }

    /**
     * Set INT_STATUS's CIE bit.
     *
     * Command index error
     */
    inline void set_INT_STATUS_CIE() volatile
    {
        INT_STATUS |= 1u << 19u;
    }

    /**
     * Clear INT_STATUS's CIE bit.
     *
     * Command index error
     */
    inline void clear_INT_STATUS_CIE() volatile
    {
        INT_STATUS &= ~(1u << 19u);
    }

    /**
     * Toggle INT_STATUS's CIE bit.
     *
     * Command index error
     */
    inline void toggle_INT_STATUS_CIE() volatile
    {
        INT_STATUS ^= 1u << 19u;
    }

    /**
     * Get INT_STATUS's CEBE bit.
     *
     * Command end bit error
     */
    inline bool get_INT_STATUS_CEBE() volatile
    {
        return INT_STATUS & (1u << 18u);
    }

    /**
     * Set INT_STATUS's CEBE bit.
     *
     * Command end bit error
     */
    inline void set_INT_STATUS_CEBE() volatile
    {
        INT_STATUS |= 1u << 18u;
    }

    /**
     * Clear INT_STATUS's CEBE bit.
     *
     * Command end bit error
     */
    inline void clear_INT_STATUS_CEBE() volatile
    {
        INT_STATUS &= ~(1u << 18u);
    }

    /**
     * Toggle INT_STATUS's CEBE bit.
     *
     * Command end bit error
     */
    inline void toggle_INT_STATUS_CEBE() volatile
    {
        INT_STATUS ^= 1u << 18u;
    }

    /**
     * Get INT_STATUS's CCE bit.
     *
     * Command CRC error
     */
    inline bool get_INT_STATUS_CCE() volatile
    {
        return INT_STATUS & (1u << 17u);
    }

    /**
     * Set INT_STATUS's CCE bit.
     *
     * Command CRC error
     */
    inline void set_INT_STATUS_CCE() volatile
    {
        INT_STATUS |= 1u << 17u;
    }

    /**
     * Clear INT_STATUS's CCE bit.
     *
     * Command CRC error
     */
    inline void clear_INT_STATUS_CCE() volatile
    {
        INT_STATUS &= ~(1u << 17u);
    }

    /**
     * Toggle INT_STATUS's CCE bit.
     *
     * Command CRC error
     */
    inline void toggle_INT_STATUS_CCE() volatile
    {
        INT_STATUS ^= 1u << 17u;
    }

    /**
     * Get INT_STATUS's CTOE bit.
     *
     * Command timeout error
     */
    inline bool get_INT_STATUS_CTOE() volatile
    {
        return INT_STATUS & (1u << 16u);
    }

    /**
     * Set INT_STATUS's CTOE bit.
     *
     * Command timeout error
     */
    inline void set_INT_STATUS_CTOE() volatile
    {
        INT_STATUS |= 1u << 16u;
    }

    /**
     * Clear INT_STATUS's CTOE bit.
     *
     * Command timeout error
     */
    inline void clear_INT_STATUS_CTOE() volatile
    {
        INT_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle INT_STATUS's CTOE bit.
     *
     * Command timeout error
     */
    inline void toggle_INT_STATUS_CTOE() volatile
    {
        INT_STATUS ^= 1u << 16u;
    }

    /**
     * Get INT_STATUS's TP bit.
     *
     * Tuning pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline bool get_INT_STATUS_TP() volatile
    {
        return INT_STATUS & (1u << 14u);
    }

    /**
     * Set INT_STATUS's TP bit.
     *
     * Tuning pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void set_INT_STATUS_TP() volatile
    {
        INT_STATUS |= 1u << 14u;
    }

    /**
     * Clear INT_STATUS's TP bit.
     *
     * Tuning pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void clear_INT_STATUS_TP() volatile
    {
        INT_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle INT_STATUS's TP bit.
     *
     * Tuning pass:(only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void toggle_INT_STATUS_TP() volatile
    {
        INT_STATUS ^= 1u << 14u;
    }

    /**
     * Get INT_STATUS's RTE bit.
     *
     * Re-tuning event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline bool get_INT_STATUS_RTE() volatile
    {
        return INT_STATUS & (1u << 12u);
    }

    /**
     * Set INT_STATUS's RTE bit.
     *
     * Re-tuning event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void set_INT_STATUS_RTE() volatile
    {
        INT_STATUS |= 1u << 12u;
    }

    /**
     * Clear INT_STATUS's RTE bit.
     *
     * Re-tuning event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void clear_INT_STATUS_RTE() volatile
    {
        INT_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle INT_STATUS's RTE bit.
     *
     * Re-tuning event: (only for SD3.0 SDR104 mode and EMMC HS200 mode)
     */
    inline void toggle_INT_STATUS_RTE() volatile
    {
        INT_STATUS ^= 1u << 12u;
    }

    /**
     * Get INT_STATUS's CINT bit.
     *
     * Card interrupt
     */
    inline bool get_INT_STATUS_CINT() volatile
    {
        return INT_STATUS & (1u << 8u);
    }

    /**
     * Set INT_STATUS's CINT bit.
     *
     * Card interrupt
     */
    inline void set_INT_STATUS_CINT() volatile
    {
        INT_STATUS |= 1u << 8u;
    }

    /**
     * Clear INT_STATUS's CINT bit.
     *
     * Card interrupt
     */
    inline void clear_INT_STATUS_CINT() volatile
    {
        INT_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle INT_STATUS's CINT bit.
     *
     * Card interrupt
     */
    inline void toggle_INT_STATUS_CINT() volatile
    {
        INT_STATUS ^= 1u << 8u;
    }

    /**
     * Get INT_STATUS's CRM bit.
     *
     * Card removal
     */
    inline bool get_INT_STATUS_CRM() volatile
    {
        return INT_STATUS & (1u << 7u);
    }

    /**
     * Set INT_STATUS's CRM bit.
     *
     * Card removal
     */
    inline void set_INT_STATUS_CRM() volatile
    {
        INT_STATUS |= 1u << 7u;
    }

    /**
     * Clear INT_STATUS's CRM bit.
     *
     * Card removal
     */
    inline void clear_INT_STATUS_CRM() volatile
    {
        INT_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle INT_STATUS's CRM bit.
     *
     * Card removal
     */
    inline void toggle_INT_STATUS_CRM() volatile
    {
        INT_STATUS ^= 1u << 7u;
    }

    /**
     * Get INT_STATUS's CINS bit.
     *
     * Card insertion
     */
    inline bool get_INT_STATUS_CINS() volatile
    {
        return INT_STATUS & (1u << 6u);
    }

    /**
     * Set INT_STATUS's CINS bit.
     *
     * Card insertion
     */
    inline void set_INT_STATUS_CINS() volatile
    {
        INT_STATUS |= 1u << 6u;
    }

    /**
     * Clear INT_STATUS's CINS bit.
     *
     * Card insertion
     */
    inline void clear_INT_STATUS_CINS() volatile
    {
        INT_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle INT_STATUS's CINS bit.
     *
     * Card insertion
     */
    inline void toggle_INT_STATUS_CINS() volatile
    {
        INT_STATUS ^= 1u << 6u;
    }

    /**
     * Get INT_STATUS's BRR bit.
     *
     * Buffer read ready
     */
    inline bool get_INT_STATUS_BRR() volatile
    {
        return INT_STATUS & (1u << 5u);
    }

    /**
     * Set INT_STATUS's BRR bit.
     *
     * Buffer read ready
     */
    inline void set_INT_STATUS_BRR() volatile
    {
        INT_STATUS |= 1u << 5u;
    }

    /**
     * Clear INT_STATUS's BRR bit.
     *
     * Buffer read ready
     */
    inline void clear_INT_STATUS_BRR() volatile
    {
        INT_STATUS &= ~(1u << 5u);
    }

    /**
     * Toggle INT_STATUS's BRR bit.
     *
     * Buffer read ready
     */
    inline void toggle_INT_STATUS_BRR() volatile
    {
        INT_STATUS ^= 1u << 5u;
    }

    /**
     * Get INT_STATUS's BWR bit.
     *
     * Buffer write ready
     */
    inline bool get_INT_STATUS_BWR() volatile
    {
        return INT_STATUS & (1u << 4u);
    }

    /**
     * Set INT_STATUS's BWR bit.
     *
     * Buffer write ready
     */
    inline void set_INT_STATUS_BWR() volatile
    {
        INT_STATUS |= 1u << 4u;
    }

    /**
     * Clear INT_STATUS's BWR bit.
     *
     * Buffer write ready
     */
    inline void clear_INT_STATUS_BWR() volatile
    {
        INT_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle INT_STATUS's BWR bit.
     *
     * Buffer write ready
     */
    inline void toggle_INT_STATUS_BWR() volatile
    {
        INT_STATUS ^= 1u << 4u;
    }

    /**
     * Get INT_STATUS's DINT bit.
     *
     * DMA interrupt
     */
    inline bool get_INT_STATUS_DINT() volatile
    {
        return INT_STATUS & (1u << 3u);
    }

    /**
     * Set INT_STATUS's DINT bit.
     *
     * DMA interrupt
     */
    inline void set_INT_STATUS_DINT() volatile
    {
        INT_STATUS |= 1u << 3u;
    }

    /**
     * Clear INT_STATUS's DINT bit.
     *
     * DMA interrupt
     */
    inline void clear_INT_STATUS_DINT() volatile
    {
        INT_STATUS &= ~(1u << 3u);
    }

    /**
     * Toggle INT_STATUS's DINT bit.
     *
     * DMA interrupt
     */
    inline void toggle_INT_STATUS_DINT() volatile
    {
        INT_STATUS ^= 1u << 3u;
    }

    /**
     * Get INT_STATUS's BGE bit.
     *
     * Block gap event
     */
    inline bool get_INT_STATUS_BGE() volatile
    {
        return INT_STATUS & (1u << 2u);
    }

    /**
     * Set INT_STATUS's BGE bit.
     *
     * Block gap event
     */
    inline void set_INT_STATUS_BGE() volatile
    {
        INT_STATUS |= 1u << 2u;
    }

    /**
     * Clear INT_STATUS's BGE bit.
     *
     * Block gap event
     */
    inline void clear_INT_STATUS_BGE() volatile
    {
        INT_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle INT_STATUS's BGE bit.
     *
     * Block gap event
     */
    inline void toggle_INT_STATUS_BGE() volatile
    {
        INT_STATUS ^= 1u << 2u;
    }

    /**
     * Get INT_STATUS's TC bit.
     *
     * Transfer complete
     */
    inline bool get_INT_STATUS_TC() volatile
    {
        return INT_STATUS & (1u << 1u);
    }

    /**
     * Set INT_STATUS's TC bit.
     *
     * Transfer complete
     */
    inline void set_INT_STATUS_TC() volatile
    {
        INT_STATUS |= 1u << 1u;
    }

    /**
     * Clear INT_STATUS's TC bit.
     *
     * Transfer complete
     */
    inline void clear_INT_STATUS_TC() volatile
    {
        INT_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle INT_STATUS's TC bit.
     *
     * Transfer complete
     */
    inline void toggle_INT_STATUS_TC() volatile
    {
        INT_STATUS ^= 1u << 1u;
    }

    /**
     * Get INT_STATUS's CC bit.
     *
     * Command complete
     */
    inline bool get_INT_STATUS_CC() volatile
    {
        return INT_STATUS & (1u << 0u);
    }

    /**
     * Set INT_STATUS's CC bit.
     *
     * Command complete
     */
    inline void set_INT_STATUS_CC() volatile
    {
        INT_STATUS |= 1u << 0u;
    }

    /**
     * Clear INT_STATUS's CC bit.
     *
     * Command complete
     */
    inline void clear_INT_STATUS_CC() volatile
    {
        INT_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle INT_STATUS's CC bit.
     *
     * Command complete
     */
    inline void toggle_INT_STATUS_CC() volatile
    {
        INT_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of INT_STATUS's bit fields.
     *
     * (read-write) Interrupt Status
     */
    inline void get_INT_STATUS(bool &DMAE, bool &TNE, bool &AC12E, bool &DEBE,
                               bool &DCE, bool &DTOE, bool &CIE, bool &CEBE,
                               bool &CCE, bool &CTOE, bool &TP, bool &RTE,
                               bool &CINT, bool &CRM, bool &CINS, bool &BRR,
                               bool &BWR, bool &DINT, bool &BGE, bool &TC,
                               bool &CC) volatile
    {
        uint32_t curr = INT_STATUS;

        DMAE = curr & (1u << 28u);
        TNE = curr & (1u << 26u);
        AC12E = curr & (1u << 24u);
        DEBE = curr & (1u << 22u);
        DCE = curr & (1u << 21u);
        DTOE = curr & (1u << 20u);
        CIE = curr & (1u << 19u);
        CEBE = curr & (1u << 18u);
        CCE = curr & (1u << 17u);
        CTOE = curr & (1u << 16u);
        TP = curr & (1u << 14u);
        RTE = curr & (1u << 12u);
        CINT = curr & (1u << 8u);
        CRM = curr & (1u << 7u);
        CINS = curr & (1u << 6u);
        BRR = curr & (1u << 5u);
        BWR = curr & (1u << 4u);
        DINT = curr & (1u << 3u);
        BGE = curr & (1u << 2u);
        TC = curr & (1u << 1u);
        CC = curr & (1u << 0u);
    }

    /**
     * Set all of INT_STATUS's bit fields.
     *
     * (read-write) Interrupt Status
     */
    inline void set_INT_STATUS(bool DMAE, bool TNE, bool AC12E, bool DEBE,
                               bool DCE, bool DTOE, bool CIE, bool CEBE,
                               bool CCE, bool CTOE, bool TP, bool RTE,
                               bool CINT, bool CRM, bool CINS, bool BRR,
                               bool BWR, bool DINT, bool BGE, bool TC,
                               bool CC) volatile
    {
        uint32_t curr = INT_STATUS;

        curr &= ~(0b1u << 28u);
        curr |= (DMAE & 0b1u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (TNE & 0b1u) << 26u;
        curr &= ~(0b1u << 24u);
        curr |= (AC12E & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (DEBE & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (DCE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (DTOE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CIE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (CEBE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (CCE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (CTOE & 0b1u) << 16u;
        curr &= ~(0b1u << 14u);
        curr |= (TP & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (RTE & 0b1u) << 12u;
        curr &= ~(0b1u << 8u);
        curr |= (CINT & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CRM & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CINS & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BRR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BWR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DINT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BGE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CC & 0b1u) << 0u;

        INT_STATUS = curr;
    }

    /**
     * Get INT_STATUS_EN's DMAESEN bit.
     *
     * DMA error status enable
     */
    inline bool get_INT_STATUS_EN_DMAESEN() volatile
    {
        return INT_STATUS_EN & (1u << 28u);
    }

    /**
     * Set INT_STATUS_EN's DMAESEN bit.
     *
     * DMA error status enable
     */
    inline void set_INT_STATUS_EN_DMAESEN() volatile
    {
        INT_STATUS_EN |= 1u << 28u;
    }

    /**
     * Clear INT_STATUS_EN's DMAESEN bit.
     *
     * DMA error status enable
     */
    inline void clear_INT_STATUS_EN_DMAESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 28u);
    }

    /**
     * Toggle INT_STATUS_EN's DMAESEN bit.
     *
     * DMA error status enable
     */
    inline void toggle_INT_STATUS_EN_DMAESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 28u;
    }

    /**
     * Get INT_STATUS_EN's TNESEN bit.
     *
     * Tuning error status enable
     */
    inline bool get_INT_STATUS_EN_TNESEN() volatile
    {
        return INT_STATUS_EN & (1u << 26u);
    }

    /**
     * Set INT_STATUS_EN's TNESEN bit.
     *
     * Tuning error status enable
     */
    inline void set_INT_STATUS_EN_TNESEN() volatile
    {
        INT_STATUS_EN |= 1u << 26u;
    }

    /**
     * Clear INT_STATUS_EN's TNESEN bit.
     *
     * Tuning error status enable
     */
    inline void clear_INT_STATUS_EN_TNESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 26u);
    }

    /**
     * Toggle INT_STATUS_EN's TNESEN bit.
     *
     * Tuning error status enable
     */
    inline void toggle_INT_STATUS_EN_TNESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 26u;
    }

    /**
     * Get INT_STATUS_EN's AC12ESEN bit.
     *
     * Auto CMD12 error status enable
     */
    inline bool get_INT_STATUS_EN_AC12ESEN() volatile
    {
        return INT_STATUS_EN & (1u << 24u);
    }

    /**
     * Set INT_STATUS_EN's AC12ESEN bit.
     *
     * Auto CMD12 error status enable
     */
    inline void set_INT_STATUS_EN_AC12ESEN() volatile
    {
        INT_STATUS_EN |= 1u << 24u;
    }

    /**
     * Clear INT_STATUS_EN's AC12ESEN bit.
     *
     * Auto CMD12 error status enable
     */
    inline void clear_INT_STATUS_EN_AC12ESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 24u);
    }

    /**
     * Toggle INT_STATUS_EN's AC12ESEN bit.
     *
     * Auto CMD12 error status enable
     */
    inline void toggle_INT_STATUS_EN_AC12ESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 24u;
    }

    /**
     * Get INT_STATUS_EN's DEBESEN bit.
     *
     * Data end bit error status enable
     */
    inline bool get_INT_STATUS_EN_DEBESEN() volatile
    {
        return INT_STATUS_EN & (1u << 22u);
    }

    /**
     * Set INT_STATUS_EN's DEBESEN bit.
     *
     * Data end bit error status enable
     */
    inline void set_INT_STATUS_EN_DEBESEN() volatile
    {
        INT_STATUS_EN |= 1u << 22u;
    }

    /**
     * Clear INT_STATUS_EN's DEBESEN bit.
     *
     * Data end bit error status enable
     */
    inline void clear_INT_STATUS_EN_DEBESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 22u);
    }

    /**
     * Toggle INT_STATUS_EN's DEBESEN bit.
     *
     * Data end bit error status enable
     */
    inline void toggle_INT_STATUS_EN_DEBESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 22u;
    }

    /**
     * Get INT_STATUS_EN's DCESEN bit.
     *
     * Data CRC error status enable
     */
    inline bool get_INT_STATUS_EN_DCESEN() volatile
    {
        return INT_STATUS_EN & (1u << 21u);
    }

    /**
     * Set INT_STATUS_EN's DCESEN bit.
     *
     * Data CRC error status enable
     */
    inline void set_INT_STATUS_EN_DCESEN() volatile
    {
        INT_STATUS_EN |= 1u << 21u;
    }

    /**
     * Clear INT_STATUS_EN's DCESEN bit.
     *
     * Data CRC error status enable
     */
    inline void clear_INT_STATUS_EN_DCESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 21u);
    }

    /**
     * Toggle INT_STATUS_EN's DCESEN bit.
     *
     * Data CRC error status enable
     */
    inline void toggle_INT_STATUS_EN_DCESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 21u;
    }

    /**
     * Get INT_STATUS_EN's DTOESEN bit.
     *
     * Data timeout error status enable
     */
    inline bool get_INT_STATUS_EN_DTOESEN() volatile
    {
        return INT_STATUS_EN & (1u << 20u);
    }

    /**
     * Set INT_STATUS_EN's DTOESEN bit.
     *
     * Data timeout error status enable
     */
    inline void set_INT_STATUS_EN_DTOESEN() volatile
    {
        INT_STATUS_EN |= 1u << 20u;
    }

    /**
     * Clear INT_STATUS_EN's DTOESEN bit.
     *
     * Data timeout error status enable
     */
    inline void clear_INT_STATUS_EN_DTOESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 20u);
    }

    /**
     * Toggle INT_STATUS_EN's DTOESEN bit.
     *
     * Data timeout error status enable
     */
    inline void toggle_INT_STATUS_EN_DTOESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 20u;
    }

    /**
     * Get INT_STATUS_EN's CIESEN bit.
     *
     * Command index error status enable
     */
    inline bool get_INT_STATUS_EN_CIESEN() volatile
    {
        return INT_STATUS_EN & (1u << 19u);
    }

    /**
     * Set INT_STATUS_EN's CIESEN bit.
     *
     * Command index error status enable
     */
    inline void set_INT_STATUS_EN_CIESEN() volatile
    {
        INT_STATUS_EN |= 1u << 19u;
    }

    /**
     * Clear INT_STATUS_EN's CIESEN bit.
     *
     * Command index error status enable
     */
    inline void clear_INT_STATUS_EN_CIESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 19u);
    }

    /**
     * Toggle INT_STATUS_EN's CIESEN bit.
     *
     * Command index error status enable
     */
    inline void toggle_INT_STATUS_EN_CIESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 19u;
    }

    /**
     * Get INT_STATUS_EN's CEBESEN bit.
     *
     * Command end bit error status enable
     */
    inline bool get_INT_STATUS_EN_CEBESEN() volatile
    {
        return INT_STATUS_EN & (1u << 18u);
    }

    /**
     * Set INT_STATUS_EN's CEBESEN bit.
     *
     * Command end bit error status enable
     */
    inline void set_INT_STATUS_EN_CEBESEN() volatile
    {
        INT_STATUS_EN |= 1u << 18u;
    }

    /**
     * Clear INT_STATUS_EN's CEBESEN bit.
     *
     * Command end bit error status enable
     */
    inline void clear_INT_STATUS_EN_CEBESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 18u);
    }

    /**
     * Toggle INT_STATUS_EN's CEBESEN bit.
     *
     * Command end bit error status enable
     */
    inline void toggle_INT_STATUS_EN_CEBESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 18u;
    }

    /**
     * Get INT_STATUS_EN's CCESEN bit.
     *
     * Command CRC error status enable
     */
    inline bool get_INT_STATUS_EN_CCESEN() volatile
    {
        return INT_STATUS_EN & (1u << 17u);
    }

    /**
     * Set INT_STATUS_EN's CCESEN bit.
     *
     * Command CRC error status enable
     */
    inline void set_INT_STATUS_EN_CCESEN() volatile
    {
        INT_STATUS_EN |= 1u << 17u;
    }

    /**
     * Clear INT_STATUS_EN's CCESEN bit.
     *
     * Command CRC error status enable
     */
    inline void clear_INT_STATUS_EN_CCESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 17u);
    }

    /**
     * Toggle INT_STATUS_EN's CCESEN bit.
     *
     * Command CRC error status enable
     */
    inline void toggle_INT_STATUS_EN_CCESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 17u;
    }

    /**
     * Get INT_STATUS_EN's CTOESEN bit.
     *
     * Command timeout error status enable
     */
    inline bool get_INT_STATUS_EN_CTOESEN() volatile
    {
        return INT_STATUS_EN & (1u << 16u);
    }

    /**
     * Set INT_STATUS_EN's CTOESEN bit.
     *
     * Command timeout error status enable
     */
    inline void set_INT_STATUS_EN_CTOESEN() volatile
    {
        INT_STATUS_EN |= 1u << 16u;
    }

    /**
     * Clear INT_STATUS_EN's CTOESEN bit.
     *
     * Command timeout error status enable
     */
    inline void clear_INT_STATUS_EN_CTOESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 16u);
    }

    /**
     * Toggle INT_STATUS_EN's CTOESEN bit.
     *
     * Command timeout error status enable
     */
    inline void toggle_INT_STATUS_EN_CTOESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 16u;
    }

    /**
     * Get INT_STATUS_EN's TPSEN bit.
     *
     * Tuning pass status enable
     */
    inline bool get_INT_STATUS_EN_TPSEN() volatile
    {
        return INT_STATUS_EN & (1u << 14u);
    }

    /**
     * Set INT_STATUS_EN's TPSEN bit.
     *
     * Tuning pass status enable
     */
    inline void set_INT_STATUS_EN_TPSEN() volatile
    {
        INT_STATUS_EN |= 1u << 14u;
    }

    /**
     * Clear INT_STATUS_EN's TPSEN bit.
     *
     * Tuning pass status enable
     */
    inline void clear_INT_STATUS_EN_TPSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 14u);
    }

    /**
     * Toggle INT_STATUS_EN's TPSEN bit.
     *
     * Tuning pass status enable
     */
    inline void toggle_INT_STATUS_EN_TPSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 14u;
    }

    /**
     * Get INT_STATUS_EN's RTESEN bit.
     *
     * Re-tuning event status enable
     */
    inline bool get_INT_STATUS_EN_RTESEN() volatile
    {
        return INT_STATUS_EN & (1u << 12u);
    }

    /**
     * Set INT_STATUS_EN's RTESEN bit.
     *
     * Re-tuning event status enable
     */
    inline void set_INT_STATUS_EN_RTESEN() volatile
    {
        INT_STATUS_EN |= 1u << 12u;
    }

    /**
     * Clear INT_STATUS_EN's RTESEN bit.
     *
     * Re-tuning event status enable
     */
    inline void clear_INT_STATUS_EN_RTESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 12u);
    }

    /**
     * Toggle INT_STATUS_EN's RTESEN bit.
     *
     * Re-tuning event status enable
     */
    inline void toggle_INT_STATUS_EN_RTESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 12u;
    }

    /**
     * Get INT_STATUS_EN's CINTSEN bit.
     *
     * Card interrupt status enable
     */
    inline bool get_INT_STATUS_EN_CINTSEN() volatile
    {
        return INT_STATUS_EN & (1u << 8u);
    }

    /**
     * Set INT_STATUS_EN's CINTSEN bit.
     *
     * Card interrupt status enable
     */
    inline void set_INT_STATUS_EN_CINTSEN() volatile
    {
        INT_STATUS_EN |= 1u << 8u;
    }

    /**
     * Clear INT_STATUS_EN's CINTSEN bit.
     *
     * Card interrupt status enable
     */
    inline void clear_INT_STATUS_EN_CINTSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 8u);
    }

    /**
     * Toggle INT_STATUS_EN's CINTSEN bit.
     *
     * Card interrupt status enable
     */
    inline void toggle_INT_STATUS_EN_CINTSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 8u;
    }

    /**
     * Get INT_STATUS_EN's CRMSEN bit.
     *
     * Card removal status enable
     */
    inline bool get_INT_STATUS_EN_CRMSEN() volatile
    {
        return INT_STATUS_EN & (1u << 7u);
    }

    /**
     * Set INT_STATUS_EN's CRMSEN bit.
     *
     * Card removal status enable
     */
    inline void set_INT_STATUS_EN_CRMSEN() volatile
    {
        INT_STATUS_EN |= 1u << 7u;
    }

    /**
     * Clear INT_STATUS_EN's CRMSEN bit.
     *
     * Card removal status enable
     */
    inline void clear_INT_STATUS_EN_CRMSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 7u);
    }

    /**
     * Toggle INT_STATUS_EN's CRMSEN bit.
     *
     * Card removal status enable
     */
    inline void toggle_INT_STATUS_EN_CRMSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 7u;
    }

    /**
     * Get INT_STATUS_EN's CINSSEN bit.
     *
     * Card insertion status enable
     */
    inline bool get_INT_STATUS_EN_CINSSEN() volatile
    {
        return INT_STATUS_EN & (1u << 6u);
    }

    /**
     * Set INT_STATUS_EN's CINSSEN bit.
     *
     * Card insertion status enable
     */
    inline void set_INT_STATUS_EN_CINSSEN() volatile
    {
        INT_STATUS_EN |= 1u << 6u;
    }

    /**
     * Clear INT_STATUS_EN's CINSSEN bit.
     *
     * Card insertion status enable
     */
    inline void clear_INT_STATUS_EN_CINSSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 6u);
    }

    /**
     * Toggle INT_STATUS_EN's CINSSEN bit.
     *
     * Card insertion status enable
     */
    inline void toggle_INT_STATUS_EN_CINSSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 6u;
    }

    /**
     * Get INT_STATUS_EN's BRRSEN bit.
     *
     * Buffer read ready status enable
     */
    inline bool get_INT_STATUS_EN_BRRSEN() volatile
    {
        return INT_STATUS_EN & (1u << 5u);
    }

    /**
     * Set INT_STATUS_EN's BRRSEN bit.
     *
     * Buffer read ready status enable
     */
    inline void set_INT_STATUS_EN_BRRSEN() volatile
    {
        INT_STATUS_EN |= 1u << 5u;
    }

    /**
     * Clear INT_STATUS_EN's BRRSEN bit.
     *
     * Buffer read ready status enable
     */
    inline void clear_INT_STATUS_EN_BRRSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 5u);
    }

    /**
     * Toggle INT_STATUS_EN's BRRSEN bit.
     *
     * Buffer read ready status enable
     */
    inline void toggle_INT_STATUS_EN_BRRSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 5u;
    }

    /**
     * Get INT_STATUS_EN's BWRSEN bit.
     *
     * Buffer write ready status enable
     */
    inline bool get_INT_STATUS_EN_BWRSEN() volatile
    {
        return INT_STATUS_EN & (1u << 4u);
    }

    /**
     * Set INT_STATUS_EN's BWRSEN bit.
     *
     * Buffer write ready status enable
     */
    inline void set_INT_STATUS_EN_BWRSEN() volatile
    {
        INT_STATUS_EN |= 1u << 4u;
    }

    /**
     * Clear INT_STATUS_EN's BWRSEN bit.
     *
     * Buffer write ready status enable
     */
    inline void clear_INT_STATUS_EN_BWRSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 4u);
    }

    /**
     * Toggle INT_STATUS_EN's BWRSEN bit.
     *
     * Buffer write ready status enable
     */
    inline void toggle_INT_STATUS_EN_BWRSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 4u;
    }

    /**
     * Get INT_STATUS_EN's DINTSEN bit.
     *
     * DMA interrupt status enable
     */
    inline bool get_INT_STATUS_EN_DINTSEN() volatile
    {
        return INT_STATUS_EN & (1u << 3u);
    }

    /**
     * Set INT_STATUS_EN's DINTSEN bit.
     *
     * DMA interrupt status enable
     */
    inline void set_INT_STATUS_EN_DINTSEN() volatile
    {
        INT_STATUS_EN |= 1u << 3u;
    }

    /**
     * Clear INT_STATUS_EN's DINTSEN bit.
     *
     * DMA interrupt status enable
     */
    inline void clear_INT_STATUS_EN_DINTSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 3u);
    }

    /**
     * Toggle INT_STATUS_EN's DINTSEN bit.
     *
     * DMA interrupt status enable
     */
    inline void toggle_INT_STATUS_EN_DINTSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 3u;
    }

    /**
     * Get INT_STATUS_EN's BGESEN bit.
     *
     * Block gap event status enable
     */
    inline bool get_INT_STATUS_EN_BGESEN() volatile
    {
        return INT_STATUS_EN & (1u << 2u);
    }

    /**
     * Set INT_STATUS_EN's BGESEN bit.
     *
     * Block gap event status enable
     */
    inline void set_INT_STATUS_EN_BGESEN() volatile
    {
        INT_STATUS_EN |= 1u << 2u;
    }

    /**
     * Clear INT_STATUS_EN's BGESEN bit.
     *
     * Block gap event status enable
     */
    inline void clear_INT_STATUS_EN_BGESEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 2u);
    }

    /**
     * Toggle INT_STATUS_EN's BGESEN bit.
     *
     * Block gap event status enable
     */
    inline void toggle_INT_STATUS_EN_BGESEN() volatile
    {
        INT_STATUS_EN ^= 1u << 2u;
    }

    /**
     * Get INT_STATUS_EN's TCSEN bit.
     *
     * Transfer complete status enable
     */
    inline bool get_INT_STATUS_EN_TCSEN() volatile
    {
        return INT_STATUS_EN & (1u << 1u);
    }

    /**
     * Set INT_STATUS_EN's TCSEN bit.
     *
     * Transfer complete status enable
     */
    inline void set_INT_STATUS_EN_TCSEN() volatile
    {
        INT_STATUS_EN |= 1u << 1u;
    }

    /**
     * Clear INT_STATUS_EN's TCSEN bit.
     *
     * Transfer complete status enable
     */
    inline void clear_INT_STATUS_EN_TCSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 1u);
    }

    /**
     * Toggle INT_STATUS_EN's TCSEN bit.
     *
     * Transfer complete status enable
     */
    inline void toggle_INT_STATUS_EN_TCSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 1u;
    }

    /**
     * Get INT_STATUS_EN's CCSEN bit.
     *
     * Command complete status enable
     */
    inline bool get_INT_STATUS_EN_CCSEN() volatile
    {
        return INT_STATUS_EN & (1u << 0u);
    }

    /**
     * Set INT_STATUS_EN's CCSEN bit.
     *
     * Command complete status enable
     */
    inline void set_INT_STATUS_EN_CCSEN() volatile
    {
        INT_STATUS_EN |= 1u << 0u;
    }

    /**
     * Clear INT_STATUS_EN's CCSEN bit.
     *
     * Command complete status enable
     */
    inline void clear_INT_STATUS_EN_CCSEN() volatile
    {
        INT_STATUS_EN &= ~(1u << 0u);
    }

    /**
     * Toggle INT_STATUS_EN's CCSEN bit.
     *
     * Command complete status enable
     */
    inline void toggle_INT_STATUS_EN_CCSEN() volatile
    {
        INT_STATUS_EN ^= 1u << 0u;
    }

    /**
     * Get all of INT_STATUS_EN's bit fields.
     *
     * (read-write) Interrupt Status Enable
     */
    inline void get_INT_STATUS_EN(bool &DMAESEN, bool &TNESEN, bool &AC12ESEN,
                                  bool &DEBESEN, bool &DCESEN, bool &DTOESEN,
                                  bool &CIESEN, bool &CEBESEN, bool &CCESEN,
                                  bool &CTOESEN, bool &TPSEN, bool &RTESEN,
                                  bool &CINTSEN, bool &CRMSEN, bool &CINSSEN,
                                  bool &BRRSEN, bool &BWRSEN, bool &DINTSEN,
                                  bool &BGESEN, bool &TCSEN,
                                  bool &CCSEN) volatile
    {
        uint32_t curr = INT_STATUS_EN;

        DMAESEN = curr & (1u << 28u);
        TNESEN = curr & (1u << 26u);
        AC12ESEN = curr & (1u << 24u);
        DEBESEN = curr & (1u << 22u);
        DCESEN = curr & (1u << 21u);
        DTOESEN = curr & (1u << 20u);
        CIESEN = curr & (1u << 19u);
        CEBESEN = curr & (1u << 18u);
        CCESEN = curr & (1u << 17u);
        CTOESEN = curr & (1u << 16u);
        TPSEN = curr & (1u << 14u);
        RTESEN = curr & (1u << 12u);
        CINTSEN = curr & (1u << 8u);
        CRMSEN = curr & (1u << 7u);
        CINSSEN = curr & (1u << 6u);
        BRRSEN = curr & (1u << 5u);
        BWRSEN = curr & (1u << 4u);
        DINTSEN = curr & (1u << 3u);
        BGESEN = curr & (1u << 2u);
        TCSEN = curr & (1u << 1u);
        CCSEN = curr & (1u << 0u);
    }

    /**
     * Set all of INT_STATUS_EN's bit fields.
     *
     * (read-write) Interrupt Status Enable
     */
    inline void set_INT_STATUS_EN(bool DMAESEN, bool TNESEN, bool AC12ESEN,
                                  bool DEBESEN, bool DCESEN, bool DTOESEN,
                                  bool CIESEN, bool CEBESEN, bool CCESEN,
                                  bool CTOESEN, bool TPSEN, bool RTESEN,
                                  bool CINTSEN, bool CRMSEN, bool CINSSEN,
                                  bool BRRSEN, bool BWRSEN, bool DINTSEN,
                                  bool BGESEN, bool TCSEN, bool CCSEN) volatile
    {
        uint32_t curr = INT_STATUS_EN;

        curr &= ~(0b1u << 28u);
        curr |= (DMAESEN & 0b1u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (TNESEN & 0b1u) << 26u;
        curr &= ~(0b1u << 24u);
        curr |= (AC12ESEN & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (DEBESEN & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (DCESEN & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (DTOESEN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CIESEN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (CEBESEN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (CCESEN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (CTOESEN & 0b1u) << 16u;
        curr &= ~(0b1u << 14u);
        curr |= (TPSEN & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (RTESEN & 0b1u) << 12u;
        curr &= ~(0b1u << 8u);
        curr |= (CINTSEN & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CRMSEN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CINSSEN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BRRSEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BWRSEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DINTSEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BGESEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TCSEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CCSEN & 0b1u) << 0u;

        INT_STATUS_EN = curr;
    }

    /**
     * Get INT_SIGNAL_EN's DMAEIEN bit.
     *
     * DMA error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_DMAEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 28u);
    }

    /**
     * Set INT_SIGNAL_EN's DMAEIEN bit.
     *
     * DMA error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_DMAEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 28u;
    }

    /**
     * Clear INT_SIGNAL_EN's DMAEIEN bit.
     *
     * DMA error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_DMAEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 28u);
    }

    /**
     * Toggle INT_SIGNAL_EN's DMAEIEN bit.
     *
     * DMA error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_DMAEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 28u;
    }

    /**
     * Get INT_SIGNAL_EN's TNEIEN bit.
     *
     * Tuning error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_TNEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 26u);
    }

    /**
     * Set INT_SIGNAL_EN's TNEIEN bit.
     *
     * Tuning error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_TNEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 26u;
    }

    /**
     * Clear INT_SIGNAL_EN's TNEIEN bit.
     *
     * Tuning error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_TNEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 26u);
    }

    /**
     * Toggle INT_SIGNAL_EN's TNEIEN bit.
     *
     * Tuning error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_TNEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 26u;
    }

    /**
     * Get INT_SIGNAL_EN's AC12EIEN bit.
     *
     * Auto CMD12 error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_AC12EIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 24u);
    }

    /**
     * Set INT_SIGNAL_EN's AC12EIEN bit.
     *
     * Auto CMD12 error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_AC12EIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 24u;
    }

    /**
     * Clear INT_SIGNAL_EN's AC12EIEN bit.
     *
     * Auto CMD12 error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_AC12EIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 24u);
    }

    /**
     * Toggle INT_SIGNAL_EN's AC12EIEN bit.
     *
     * Auto CMD12 error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_AC12EIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 24u;
    }

    /**
     * Get INT_SIGNAL_EN's DEBEIEN bit.
     *
     * Data end bit error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_DEBEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 22u);
    }

    /**
     * Set INT_SIGNAL_EN's DEBEIEN bit.
     *
     * Data end bit error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_DEBEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 22u;
    }

    /**
     * Clear INT_SIGNAL_EN's DEBEIEN bit.
     *
     * Data end bit error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_DEBEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 22u);
    }

    /**
     * Toggle INT_SIGNAL_EN's DEBEIEN bit.
     *
     * Data end bit error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_DEBEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 22u;
    }

    /**
     * Get INT_SIGNAL_EN's DCEIEN bit.
     *
     * Data CRC error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_DCEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 21u);
    }

    /**
     * Set INT_SIGNAL_EN's DCEIEN bit.
     *
     * Data CRC error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_DCEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 21u;
    }

    /**
     * Clear INT_SIGNAL_EN's DCEIEN bit.
     *
     * Data CRC error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_DCEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 21u);
    }

    /**
     * Toggle INT_SIGNAL_EN's DCEIEN bit.
     *
     * Data CRC error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_DCEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 21u;
    }

    /**
     * Get INT_SIGNAL_EN's DTOEIEN bit.
     *
     * Data timeout error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_DTOEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 20u);
    }

    /**
     * Set INT_SIGNAL_EN's DTOEIEN bit.
     *
     * Data timeout error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_DTOEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 20u;
    }

    /**
     * Clear INT_SIGNAL_EN's DTOEIEN bit.
     *
     * Data timeout error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_DTOEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 20u);
    }

    /**
     * Toggle INT_SIGNAL_EN's DTOEIEN bit.
     *
     * Data timeout error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_DTOEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 20u;
    }

    /**
     * Get INT_SIGNAL_EN's CIEIEN bit.
     *
     * Command index error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CIEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 19u);
    }

    /**
     * Set INT_SIGNAL_EN's CIEIEN bit.
     *
     * Command index error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CIEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 19u;
    }

    /**
     * Clear INT_SIGNAL_EN's CIEIEN bit.
     *
     * Command index error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CIEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 19u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CIEIEN bit.
     *
     * Command index error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CIEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 19u;
    }

    /**
     * Get INT_SIGNAL_EN's CEBEIEN bit.
     *
     * Command end bit error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CEBEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 18u);
    }

    /**
     * Set INT_SIGNAL_EN's CEBEIEN bit.
     *
     * Command end bit error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CEBEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 18u;
    }

    /**
     * Clear INT_SIGNAL_EN's CEBEIEN bit.
     *
     * Command end bit error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CEBEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 18u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CEBEIEN bit.
     *
     * Command end bit error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CEBEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 18u;
    }

    /**
     * Get INT_SIGNAL_EN's CCEIEN bit.
     *
     * Command CRC error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CCEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 17u);
    }

    /**
     * Set INT_SIGNAL_EN's CCEIEN bit.
     *
     * Command CRC error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CCEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 17u;
    }

    /**
     * Clear INT_SIGNAL_EN's CCEIEN bit.
     *
     * Command CRC error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CCEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 17u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CCEIEN bit.
     *
     * Command CRC error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CCEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 17u;
    }

    /**
     * Get INT_SIGNAL_EN's CTOEIEN bit.
     *
     * Command timeout error interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CTOEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 16u);
    }

    /**
     * Set INT_SIGNAL_EN's CTOEIEN bit.
     *
     * Command timeout error interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CTOEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 16u;
    }

    /**
     * Clear INT_SIGNAL_EN's CTOEIEN bit.
     *
     * Command timeout error interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CTOEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 16u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CTOEIEN bit.
     *
     * Command timeout error interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CTOEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 16u;
    }

    /**
     * Get INT_SIGNAL_EN's TPIEN bit.
     *
     * Tuning Pass interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_TPIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 14u);
    }

    /**
     * Set INT_SIGNAL_EN's TPIEN bit.
     *
     * Tuning Pass interrupt enable
     */
    inline void set_INT_SIGNAL_EN_TPIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 14u;
    }

    /**
     * Clear INT_SIGNAL_EN's TPIEN bit.
     *
     * Tuning Pass interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_TPIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 14u);
    }

    /**
     * Toggle INT_SIGNAL_EN's TPIEN bit.
     *
     * Tuning Pass interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_TPIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 14u;
    }

    /**
     * Get INT_SIGNAL_EN's RTEIEN bit.
     *
     * Re-tuning event interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_RTEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 12u);
    }

    /**
     * Set INT_SIGNAL_EN's RTEIEN bit.
     *
     * Re-tuning event interrupt enable
     */
    inline void set_INT_SIGNAL_EN_RTEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 12u;
    }

    /**
     * Clear INT_SIGNAL_EN's RTEIEN bit.
     *
     * Re-tuning event interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_RTEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 12u);
    }

    /**
     * Toggle INT_SIGNAL_EN's RTEIEN bit.
     *
     * Re-tuning event interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_RTEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 12u;
    }

    /**
     * Get INT_SIGNAL_EN's CINTIEN bit.
     *
     * Card interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CINTIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 8u);
    }

    /**
     * Set INT_SIGNAL_EN's CINTIEN bit.
     *
     * Card interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CINTIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 8u;
    }

    /**
     * Clear INT_SIGNAL_EN's CINTIEN bit.
     *
     * Card interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CINTIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 8u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CINTIEN bit.
     *
     * Card interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CINTIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 8u;
    }

    /**
     * Get INT_SIGNAL_EN's CRMIEN bit.
     *
     * Card removal interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CRMIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 7u);
    }

    /**
     * Set INT_SIGNAL_EN's CRMIEN bit.
     *
     * Card removal interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CRMIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 7u;
    }

    /**
     * Clear INT_SIGNAL_EN's CRMIEN bit.
     *
     * Card removal interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CRMIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 7u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CRMIEN bit.
     *
     * Card removal interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CRMIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 7u;
    }

    /**
     * Get INT_SIGNAL_EN's CINSIEN bit.
     *
     * Card insertion interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CINSIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 6u);
    }

    /**
     * Set INT_SIGNAL_EN's CINSIEN bit.
     *
     * Card insertion interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CINSIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 6u;
    }

    /**
     * Clear INT_SIGNAL_EN's CINSIEN bit.
     *
     * Card insertion interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CINSIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 6u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CINSIEN bit.
     *
     * Card insertion interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CINSIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 6u;
    }

    /**
     * Get INT_SIGNAL_EN's BRRIEN bit.
     *
     * Buffer read ready interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_BRRIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 5u);
    }

    /**
     * Set INT_SIGNAL_EN's BRRIEN bit.
     *
     * Buffer read ready interrupt enable
     */
    inline void set_INT_SIGNAL_EN_BRRIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 5u;
    }

    /**
     * Clear INT_SIGNAL_EN's BRRIEN bit.
     *
     * Buffer read ready interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_BRRIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 5u);
    }

    /**
     * Toggle INT_SIGNAL_EN's BRRIEN bit.
     *
     * Buffer read ready interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_BRRIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 5u;
    }

    /**
     * Get INT_SIGNAL_EN's BWRIEN bit.
     *
     * Buffer write ready interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_BWRIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 4u);
    }

    /**
     * Set INT_SIGNAL_EN's BWRIEN bit.
     *
     * Buffer write ready interrupt enable
     */
    inline void set_INT_SIGNAL_EN_BWRIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 4u;
    }

    /**
     * Clear INT_SIGNAL_EN's BWRIEN bit.
     *
     * Buffer write ready interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_BWRIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 4u);
    }

    /**
     * Toggle INT_SIGNAL_EN's BWRIEN bit.
     *
     * Buffer write ready interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_BWRIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 4u;
    }

    /**
     * Get INT_SIGNAL_EN's DINTIEN bit.
     *
     * DMA interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_DINTIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 3u);
    }

    /**
     * Set INT_SIGNAL_EN's DINTIEN bit.
     *
     * DMA interrupt enable
     */
    inline void set_INT_SIGNAL_EN_DINTIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 3u;
    }

    /**
     * Clear INT_SIGNAL_EN's DINTIEN bit.
     *
     * DMA interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_DINTIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 3u);
    }

    /**
     * Toggle INT_SIGNAL_EN's DINTIEN bit.
     *
     * DMA interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_DINTIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 3u;
    }

    /**
     * Get INT_SIGNAL_EN's BGEIEN bit.
     *
     * Block gap event interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_BGEIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 2u);
    }

    /**
     * Set INT_SIGNAL_EN's BGEIEN bit.
     *
     * Block gap event interrupt enable
     */
    inline void set_INT_SIGNAL_EN_BGEIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 2u;
    }

    /**
     * Clear INT_SIGNAL_EN's BGEIEN bit.
     *
     * Block gap event interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_BGEIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 2u);
    }

    /**
     * Toggle INT_SIGNAL_EN's BGEIEN bit.
     *
     * Block gap event interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_BGEIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 2u;
    }

    /**
     * Get INT_SIGNAL_EN's TCIEN bit.
     *
     * Transfer complete interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_TCIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 1u);
    }

    /**
     * Set INT_SIGNAL_EN's TCIEN bit.
     *
     * Transfer complete interrupt enable
     */
    inline void set_INT_SIGNAL_EN_TCIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 1u;
    }

    /**
     * Clear INT_SIGNAL_EN's TCIEN bit.
     *
     * Transfer complete interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_TCIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 1u);
    }

    /**
     * Toggle INT_SIGNAL_EN's TCIEN bit.
     *
     * Transfer complete interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_TCIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 1u;
    }

    /**
     * Get INT_SIGNAL_EN's CCIEN bit.
     *
     * Command complete interrupt enable
     */
    inline bool get_INT_SIGNAL_EN_CCIEN() volatile
    {
        return INT_SIGNAL_EN & (1u << 0u);
    }

    /**
     * Set INT_SIGNAL_EN's CCIEN bit.
     *
     * Command complete interrupt enable
     */
    inline void set_INT_SIGNAL_EN_CCIEN() volatile
    {
        INT_SIGNAL_EN |= 1u << 0u;
    }

    /**
     * Clear INT_SIGNAL_EN's CCIEN bit.
     *
     * Command complete interrupt enable
     */
    inline void clear_INT_SIGNAL_EN_CCIEN() volatile
    {
        INT_SIGNAL_EN &= ~(1u << 0u);
    }

    /**
     * Toggle INT_SIGNAL_EN's CCIEN bit.
     *
     * Command complete interrupt enable
     */
    inline void toggle_INT_SIGNAL_EN_CCIEN() volatile
    {
        INT_SIGNAL_EN ^= 1u << 0u;
    }

    /**
     * Get all of INT_SIGNAL_EN's bit fields.
     *
     * (read-write) Interrupt Signal Enable
     */
    inline void get_INT_SIGNAL_EN(bool &DMAEIEN, bool &TNEIEN, bool &AC12EIEN,
                                  bool &DEBEIEN, bool &DCEIEN, bool &DTOEIEN,
                                  bool &CIEIEN, bool &CEBEIEN, bool &CCEIEN,
                                  bool &CTOEIEN, bool &TPIEN, bool &RTEIEN,
                                  bool &CINTIEN, bool &CRMIEN, bool &CINSIEN,
                                  bool &BRRIEN, bool &BWRIEN, bool &DINTIEN,
                                  bool &BGEIEN, bool &TCIEN,
                                  bool &CCIEN) volatile
    {
        uint32_t curr = INT_SIGNAL_EN;

        DMAEIEN = curr & (1u << 28u);
        TNEIEN = curr & (1u << 26u);
        AC12EIEN = curr & (1u << 24u);
        DEBEIEN = curr & (1u << 22u);
        DCEIEN = curr & (1u << 21u);
        DTOEIEN = curr & (1u << 20u);
        CIEIEN = curr & (1u << 19u);
        CEBEIEN = curr & (1u << 18u);
        CCEIEN = curr & (1u << 17u);
        CTOEIEN = curr & (1u << 16u);
        TPIEN = curr & (1u << 14u);
        RTEIEN = curr & (1u << 12u);
        CINTIEN = curr & (1u << 8u);
        CRMIEN = curr & (1u << 7u);
        CINSIEN = curr & (1u << 6u);
        BRRIEN = curr & (1u << 5u);
        BWRIEN = curr & (1u << 4u);
        DINTIEN = curr & (1u << 3u);
        BGEIEN = curr & (1u << 2u);
        TCIEN = curr & (1u << 1u);
        CCIEN = curr & (1u << 0u);
    }

    /**
     * Set all of INT_SIGNAL_EN's bit fields.
     *
     * (read-write) Interrupt Signal Enable
     */
    inline void set_INT_SIGNAL_EN(bool DMAEIEN, bool TNEIEN, bool AC12EIEN,
                                  bool DEBEIEN, bool DCEIEN, bool DTOEIEN,
                                  bool CIEIEN, bool CEBEIEN, bool CCEIEN,
                                  bool CTOEIEN, bool TPIEN, bool RTEIEN,
                                  bool CINTIEN, bool CRMIEN, bool CINSIEN,
                                  bool BRRIEN, bool BWRIEN, bool DINTIEN,
                                  bool BGEIEN, bool TCIEN, bool CCIEN) volatile
    {
        uint32_t curr = INT_SIGNAL_EN;

        curr &= ~(0b1u << 28u);
        curr |= (DMAEIEN & 0b1u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (TNEIEN & 0b1u) << 26u;
        curr &= ~(0b1u << 24u);
        curr |= (AC12EIEN & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (DEBEIEN & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (DCEIEN & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (DTOEIEN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CIEIEN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (CEBEIEN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (CCEIEN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (CTOEIEN & 0b1u) << 16u;
        curr &= ~(0b1u << 14u);
        curr |= (TPIEN & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (RTEIEN & 0b1u) << 12u;
        curr &= ~(0b1u << 8u);
        curr |= (CINTIEN & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CRMIEN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CINSIEN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BRRIEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BWRIEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DINTIEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BGEIEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TCIEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CCIEN & 0b1u) << 0u;

        INT_SIGNAL_EN = curr;
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's SMP_CLK_SEL bit.
     *
     * Sample clock select
     */
    inline bool get_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 23u);
    }

    /**
     * Set AUTOCMD12_ERR_STATUS's SMP_CLK_SEL bit.
     *
     * Sample clock select
     */
    inline void set_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL() volatile
    {
        AUTOCMD12_ERR_STATUS |= 1u << 23u;
    }

    /**
     * Clear AUTOCMD12_ERR_STATUS's SMP_CLK_SEL bit.
     *
     * Sample clock select
     */
    inline void clear_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL() volatile
    {
        AUTOCMD12_ERR_STATUS &= ~(1u << 23u);
    }

    /**
     * Toggle AUTOCMD12_ERR_STATUS's SMP_CLK_SEL bit.
     *
     * Sample clock select
     */
    inline void toggle_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL() volatile
    {
        AUTOCMD12_ERR_STATUS ^= 1u << 23u;
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's EXECUTE_TUNING bit.
     *
     * Execute tuning
     */
    inline bool get_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 22u);
    }

    /**
     * Set AUTOCMD12_ERR_STATUS's EXECUTE_TUNING bit.
     *
     * Execute tuning
     */
    inline void set_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING() volatile
    {
        AUTOCMD12_ERR_STATUS |= 1u << 22u;
    }

    /**
     * Clear AUTOCMD12_ERR_STATUS's EXECUTE_TUNING bit.
     *
     * Execute tuning
     */
    inline void clear_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING() volatile
    {
        AUTOCMD12_ERR_STATUS &= ~(1u << 22u);
    }

    /**
     * Toggle AUTOCMD12_ERR_STATUS's EXECUTE_TUNING bit.
     *
     * Execute tuning
     */
    inline void toggle_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING() volatile
    {
        AUTOCMD12_ERR_STATUS ^= 1u << 22u;
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's CNIBAC12E bit.
     *
     * Command not issued by Auto CMD12 error
     */
    inline bool get_AUTOCMD12_ERR_STATUS_CNIBAC12E() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 7u);
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's AC12IE bit.
     *
     * Auto CMD12 / 23 index error
     */
    inline bool get_AUTOCMD12_ERR_STATUS_AC12IE() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 4u);
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's AC12CE bit.
     *
     * Auto CMD12 / 23 CRC error
     */
    inline bool get_AUTOCMD12_ERR_STATUS_AC12CE() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 3u);
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's AC12EBE bit.
     *
     * Auto CMD12 / 23 end bit error
     */
    inline bool get_AUTOCMD12_ERR_STATUS_AC12EBE() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 2u);
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's AC12TOE bit.
     *
     * Auto CMD12 / 23 timeout error
     */
    inline bool get_AUTOCMD12_ERR_STATUS_AC12TOE() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 1u);
    }

    /**
     * Get AUTOCMD12_ERR_STATUS's AC12NE bit.
     *
     * Auto CMD12 not executed
     */
    inline bool get_AUTOCMD12_ERR_STATUS_AC12NE() volatile
    {
        return AUTOCMD12_ERR_STATUS & (1u << 0u);
    }

    /**
     * Get all of AUTOCMD12_ERR_STATUS's bit fields.
     *
     * (read-write) Auto CMD12 Error Status
     */
    inline void get_AUTOCMD12_ERR_STATUS(bool &SMP_CLK_SEL,
                                         bool &EXECUTE_TUNING, bool &CNIBAC12E,
                                         bool &AC12IE, bool &AC12CE,
                                         bool &AC12EBE, bool &AC12TOE,
                                         bool &AC12NE) volatile
    {
        uint32_t curr = AUTOCMD12_ERR_STATUS;

        SMP_CLK_SEL = curr & (1u << 23u);
        EXECUTE_TUNING = curr & (1u << 22u);
        CNIBAC12E = curr & (1u << 7u);
        AC12IE = curr & (1u << 4u);
        AC12CE = curr & (1u << 3u);
        AC12EBE = curr & (1u << 2u);
        AC12TOE = curr & (1u << 1u);
        AC12NE = curr & (1u << 0u);
    }

    /**
     * Set all of AUTOCMD12_ERR_STATUS's bit fields.
     *
     * (read-write) Auto CMD12 Error Status
     */
    inline void set_AUTOCMD12_ERR_STATUS(bool SMP_CLK_SEL,
                                         bool EXECUTE_TUNING) volatile
    {
        uint32_t curr = AUTOCMD12_ERR_STATUS;

        curr &= ~(0b1u << 23u);
        curr |= (SMP_CLK_SEL & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EXECUTE_TUNING & 0b1u) << 22u;

        AUTOCMD12_ERR_STATUS = curr;
    }

    /**
     * Get HOST_CTRL_CAP's VS18 bit.
     *
     * Voltage support 1.8 V
     */
    inline bool get_HOST_CTRL_CAP_VS18() volatile
    {
        return HOST_CTRL_CAP & (1u << 26u);
    }

    /**
     * Get HOST_CTRL_CAP's VS30 bit.
     *
     * Voltage support 3.0 V
     */
    inline bool get_HOST_CTRL_CAP_VS30() volatile
    {
        return HOST_CTRL_CAP & (1u << 25u);
    }

    /**
     * Get HOST_CTRL_CAP's VS33 bit.
     *
     * Voltage support 3.3 V
     */
    inline bool get_HOST_CTRL_CAP_VS33() volatile
    {
        return HOST_CTRL_CAP & (1u << 24u);
    }

    /**
     * Get HOST_CTRL_CAP's SRS bit.
     *
     * Suspend / resume support
     */
    inline bool get_HOST_CTRL_CAP_SRS() volatile
    {
        return HOST_CTRL_CAP & (1u << 23u);
    }

    /**
     * Get HOST_CTRL_CAP's DMAS bit.
     *
     * DMA support
     */
    inline bool get_HOST_CTRL_CAP_DMAS() volatile
    {
        return HOST_CTRL_CAP & (1u << 22u);
    }

    /**
     * Get HOST_CTRL_CAP's HSS bit.
     *
     * High speed support
     */
    inline bool get_HOST_CTRL_CAP_HSS() volatile
    {
        return HOST_CTRL_CAP & (1u << 21u);
    }

    /**
     * Get HOST_CTRL_CAP's ADMAS bit.
     *
     * ADMA support
     */
    inline bool get_HOST_CTRL_CAP_ADMAS() volatile
    {
        return HOST_CTRL_CAP & (1u << 20u);
    }

    /**
     * Get HOST_CTRL_CAP's MBL field.
     *
     * Max block length
     */
    inline USDHC1_HOST_CTRL_CAP_MBL get_HOST_CTRL_CAP_MBL() volatile
    {
        return USDHC1_HOST_CTRL_CAP_MBL((HOST_CTRL_CAP >> 16u) & 0b111u);
    }

    /**
     * Get HOST_CTRL_CAP's USE_TUNING_SDR50 bit.
     *
     * Use Tuning for SDR50
     */
    inline bool get_HOST_CTRL_CAP_USE_TUNING_SDR50() volatile
    {
        return HOST_CTRL_CAP & (1u << 13u);
    }

    /**
     * Set HOST_CTRL_CAP's USE_TUNING_SDR50 bit.
     *
     * Use Tuning for SDR50
     */
    inline void set_HOST_CTRL_CAP_USE_TUNING_SDR50() volatile
    {
        HOST_CTRL_CAP |= 1u << 13u;
    }

    /**
     * Clear HOST_CTRL_CAP's USE_TUNING_SDR50 bit.
     *
     * Use Tuning for SDR50
     */
    inline void clear_HOST_CTRL_CAP_USE_TUNING_SDR50() volatile
    {
        HOST_CTRL_CAP &= ~(1u << 13u);
    }

    /**
     * Toggle HOST_CTRL_CAP's USE_TUNING_SDR50 bit.
     *
     * Use Tuning for SDR50
     */
    inline void toggle_HOST_CTRL_CAP_USE_TUNING_SDR50() volatile
    {
        HOST_CTRL_CAP ^= 1u << 13u;
    }

    /**
     * Get HOST_CTRL_CAP's DDR50_SUPPORT bit.
     *
     * DDR50 support
     */
    inline bool get_HOST_CTRL_CAP_DDR50_SUPPORT() volatile
    {
        return HOST_CTRL_CAP & (1u << 2u);
    }

    /**
     * Get HOST_CTRL_CAP's SDR104_SUPPORT bit.
     *
     * SDR104 support
     */
    inline bool get_HOST_CTRL_CAP_SDR104_SUPPORT() volatile
    {
        return HOST_CTRL_CAP & (1u << 1u);
    }

    /**
     * Get HOST_CTRL_CAP's SDR50_SUPPORT bit.
     *
     * SDR50 support
     */
    inline bool get_HOST_CTRL_CAP_SDR50_SUPPORT() volatile
    {
        return HOST_CTRL_CAP & (1u << 0u);
    }

    /**
     * Get all of HOST_CTRL_CAP's bit fields.
     *
     * (read-write) Host Controller Capabilities
     */
    inline void get_HOST_CTRL_CAP(bool &VS18, bool &VS30, bool &VS33,
                                  bool &SRS, bool &DMAS, bool &HSS,
                                  bool &ADMAS, USDHC1_HOST_CTRL_CAP_MBL &MBL,
                                  bool &USE_TUNING_SDR50, bool &DDR50_SUPPORT,
                                  bool &SDR104_SUPPORT,
                                  bool &SDR50_SUPPORT) volatile
    {
        uint32_t curr = HOST_CTRL_CAP;

        VS18 = curr & (1u << 26u);
        VS30 = curr & (1u << 25u);
        VS33 = curr & (1u << 24u);
        SRS = curr & (1u << 23u);
        DMAS = curr & (1u << 22u);
        HSS = curr & (1u << 21u);
        ADMAS = curr & (1u << 20u);
        MBL = USDHC1_HOST_CTRL_CAP_MBL((curr >> 16u) & 0b111u);
        USE_TUNING_SDR50 = curr & (1u << 13u);
        DDR50_SUPPORT = curr & (1u << 2u);
        SDR104_SUPPORT = curr & (1u << 1u);
        SDR50_SUPPORT = curr & (1u << 0u);
    }

    /**
     * Get WTMK_LVL's WR_WML field.
     *
     * Write watermark level
     */
    inline uint8_t get_WTMK_LVL_WR_WML() volatile
    {
        return (WTMK_LVL >> 16u) & 0b11111111u;
    }

    /**
     * Set WTMK_LVL's WR_WML field.
     *
     * Write watermark level
     */
    inline void set_WTMK_LVL_WR_WML(uint8_t value) volatile
    {
        uint32_t curr = WTMK_LVL;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        WTMK_LVL = curr;
    }

    /**
     * Get WTMK_LVL's RD_WML field.
     *
     * Read watermark level
     */
    inline uint8_t get_WTMK_LVL_RD_WML() volatile
    {
        return (WTMK_LVL >> 0u) & 0b11111111u;
    }

    /**
     * Set WTMK_LVL's RD_WML field.
     *
     * Read watermark level
     */
    inline void set_WTMK_LVL_RD_WML(uint8_t value) volatile
    {
        uint32_t curr = WTMK_LVL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        WTMK_LVL = curr;
    }

    /**
     * Get all of WTMK_LVL's bit fields.
     *
     * (read-write) Watermark Level
     */
    inline void get_WTMK_LVL(uint8_t &WR_WML, uint8_t &RD_WML) volatile
    {
        uint32_t curr = WTMK_LVL;

        WR_WML = (curr >> 16u) & 0b11111111u;
        RD_WML = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of WTMK_LVL's bit fields.
     *
     * (read-write) Watermark Level
     */
    inline void set_WTMK_LVL(uint8_t WR_WML, uint8_t RD_WML) volatile
    {
        uint32_t curr = WTMK_LVL;

        curr &= ~(0b11111111u << 16u);
        curr |= (WR_WML & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RD_WML & 0b11111111u) << 0u;

        WTMK_LVL = curr;
    }

    /**
     * Get MIX_CTRL's HS400_MODE bit.
     *
     * Enable HS400 mode
     */
    inline bool get_MIX_CTRL_HS400_MODE() volatile
    {
        return MIX_CTRL & (1u << 26u);
    }

    /**
     * Set MIX_CTRL's HS400_MODE bit.
     *
     * Enable HS400 mode
     */
    inline void set_MIX_CTRL_HS400_MODE() volatile
    {
        MIX_CTRL |= 1u << 26u;
    }

    /**
     * Clear MIX_CTRL's HS400_MODE bit.
     *
     * Enable HS400 mode
     */
    inline void clear_MIX_CTRL_HS400_MODE() volatile
    {
        MIX_CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle MIX_CTRL's HS400_MODE bit.
     *
     * Enable HS400 mode
     */
    inline void toggle_MIX_CTRL_HS400_MODE() volatile
    {
        MIX_CTRL ^= 1u << 26u;
    }

    /**
     * Get MIX_CTRL's FBCLK_SEL bit.
     *
     * Feedback clock source selection (Only used for SD3.0, SDR104 mode and
     * EMMC HS200 mode)
     */
    inline bool get_MIX_CTRL_FBCLK_SEL() volatile
    {
        return MIX_CTRL & (1u << 25u);
    }

    /**
     * Set MIX_CTRL's FBCLK_SEL bit.
     *
     * Feedback clock source selection (Only used for SD3.0, SDR104 mode and
     * EMMC HS200 mode)
     */
    inline void set_MIX_CTRL_FBCLK_SEL() volatile
    {
        MIX_CTRL |= 1u << 25u;
    }

    /**
     * Clear MIX_CTRL's FBCLK_SEL bit.
     *
     * Feedback clock source selection (Only used for SD3.0, SDR104 mode and
     * EMMC HS200 mode)
     */
    inline void clear_MIX_CTRL_FBCLK_SEL() volatile
    {
        MIX_CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle MIX_CTRL's FBCLK_SEL bit.
     *
     * Feedback clock source selection (Only used for SD3.0, SDR104 mode and
     * EMMC HS200 mode)
     */
    inline void toggle_MIX_CTRL_FBCLK_SEL() volatile
    {
        MIX_CTRL ^= 1u << 25u;
    }

    /**
     * Get MIX_CTRL's AUTO_TUNE_EN bit.
     *
     * Auto tuning enable (Only used for SD3.0, SDR104 mode and and EMMC HS200
     * mode)
     */
    inline bool get_MIX_CTRL_AUTO_TUNE_EN() volatile
    {
        return MIX_CTRL & (1u << 24u);
    }

    /**
     * Set MIX_CTRL's AUTO_TUNE_EN bit.
     *
     * Auto tuning enable (Only used for SD3.0, SDR104 mode and and EMMC HS200
     * mode)
     */
    inline void set_MIX_CTRL_AUTO_TUNE_EN() volatile
    {
        MIX_CTRL |= 1u << 24u;
    }

    /**
     * Clear MIX_CTRL's AUTO_TUNE_EN bit.
     *
     * Auto tuning enable (Only used for SD3.0, SDR104 mode and and EMMC HS200
     * mode)
     */
    inline void clear_MIX_CTRL_AUTO_TUNE_EN() volatile
    {
        MIX_CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle MIX_CTRL's AUTO_TUNE_EN bit.
     *
     * Auto tuning enable (Only used for SD3.0, SDR104 mode and and EMMC HS200
     * mode)
     */
    inline void toggle_MIX_CTRL_AUTO_TUNE_EN() volatile
    {
        MIX_CTRL ^= 1u << 24u;
    }

    /**
     * Get MIX_CTRL's SMP_CLK_SEL bit.
     *
     * Clock selection
     */
    inline bool get_MIX_CTRL_SMP_CLK_SEL() volatile
    {
        return MIX_CTRL & (1u << 23u);
    }

    /**
     * Set MIX_CTRL's SMP_CLK_SEL bit.
     *
     * Clock selection
     */
    inline void set_MIX_CTRL_SMP_CLK_SEL() volatile
    {
        MIX_CTRL |= 1u << 23u;
    }

    /**
     * Clear MIX_CTRL's SMP_CLK_SEL bit.
     *
     * Clock selection
     */
    inline void clear_MIX_CTRL_SMP_CLK_SEL() volatile
    {
        MIX_CTRL &= ~(1u << 23u);
    }

    /**
     * Toggle MIX_CTRL's SMP_CLK_SEL bit.
     *
     * Clock selection
     */
    inline void toggle_MIX_CTRL_SMP_CLK_SEL() volatile
    {
        MIX_CTRL ^= 1u << 23u;
    }

    /**
     * Get MIX_CTRL's EXE_TUNE bit.
     *
     * Execute tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
     */
    inline bool get_MIX_CTRL_EXE_TUNE() volatile
    {
        return MIX_CTRL & (1u << 22u);
    }

    /**
     * Set MIX_CTRL's EXE_TUNE bit.
     *
     * Execute tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
     */
    inline void set_MIX_CTRL_EXE_TUNE() volatile
    {
        MIX_CTRL |= 1u << 22u;
    }

    /**
     * Clear MIX_CTRL's EXE_TUNE bit.
     *
     * Execute tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
     */
    inline void clear_MIX_CTRL_EXE_TUNE() volatile
    {
        MIX_CTRL &= ~(1u << 22u);
    }

    /**
     * Toggle MIX_CTRL's EXE_TUNE bit.
     *
     * Execute tuning: (Only used for SD3.0, SDR104 mode and EMMC HS200 mode)
     */
    inline void toggle_MIX_CTRL_EXE_TUNE() volatile
    {
        MIX_CTRL ^= 1u << 22u;
    }

    /**
     * Get MIX_CTRL's AC23EN bit.
     *
     * Auto CMD23 enable
     */
    inline bool get_MIX_CTRL_AC23EN() volatile
    {
        return MIX_CTRL & (1u << 7u);
    }

    /**
     * Set MIX_CTRL's AC23EN bit.
     *
     * Auto CMD23 enable
     */
    inline void set_MIX_CTRL_AC23EN() volatile
    {
        MIX_CTRL |= 1u << 7u;
    }

    /**
     * Clear MIX_CTRL's AC23EN bit.
     *
     * Auto CMD23 enable
     */
    inline void clear_MIX_CTRL_AC23EN() volatile
    {
        MIX_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle MIX_CTRL's AC23EN bit.
     *
     * Auto CMD23 enable
     */
    inline void toggle_MIX_CTRL_AC23EN() volatile
    {
        MIX_CTRL ^= 1u << 7u;
    }

    /**
     * Get MIX_CTRL's NIBBLE_POS bit.
     *
     * Nibble position indication
     */
    inline bool get_MIX_CTRL_NIBBLE_POS() volatile
    {
        return MIX_CTRL & (1u << 6u);
    }

    /**
     * Set MIX_CTRL's NIBBLE_POS bit.
     *
     * Nibble position indication
     */
    inline void set_MIX_CTRL_NIBBLE_POS() volatile
    {
        MIX_CTRL |= 1u << 6u;
    }

    /**
     * Clear MIX_CTRL's NIBBLE_POS bit.
     *
     * Nibble position indication
     */
    inline void clear_MIX_CTRL_NIBBLE_POS() volatile
    {
        MIX_CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle MIX_CTRL's NIBBLE_POS bit.
     *
     * Nibble position indication
     */
    inline void toggle_MIX_CTRL_NIBBLE_POS() volatile
    {
        MIX_CTRL ^= 1u << 6u;
    }

    /**
     * Get MIX_CTRL's MSBSEL bit.
     *
     * Multi / Single block select
     */
    inline bool get_MIX_CTRL_MSBSEL() volatile
    {
        return MIX_CTRL & (1u << 5u);
    }

    /**
     * Set MIX_CTRL's MSBSEL bit.
     *
     * Multi / Single block select
     */
    inline void set_MIX_CTRL_MSBSEL() volatile
    {
        MIX_CTRL |= 1u << 5u;
    }

    /**
     * Clear MIX_CTRL's MSBSEL bit.
     *
     * Multi / Single block select
     */
    inline void clear_MIX_CTRL_MSBSEL() volatile
    {
        MIX_CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle MIX_CTRL's MSBSEL bit.
     *
     * Multi / Single block select
     */
    inline void toggle_MIX_CTRL_MSBSEL() volatile
    {
        MIX_CTRL ^= 1u << 5u;
    }

    /**
     * Get MIX_CTRL's DTDSEL bit.
     *
     * Data transfer direction select
     */
    inline bool get_MIX_CTRL_DTDSEL() volatile
    {
        return MIX_CTRL & (1u << 4u);
    }

    /**
     * Set MIX_CTRL's DTDSEL bit.
     *
     * Data transfer direction select
     */
    inline void set_MIX_CTRL_DTDSEL() volatile
    {
        MIX_CTRL |= 1u << 4u;
    }

    /**
     * Clear MIX_CTRL's DTDSEL bit.
     *
     * Data transfer direction select
     */
    inline void clear_MIX_CTRL_DTDSEL() volatile
    {
        MIX_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle MIX_CTRL's DTDSEL bit.
     *
     * Data transfer direction select
     */
    inline void toggle_MIX_CTRL_DTDSEL() volatile
    {
        MIX_CTRL ^= 1u << 4u;
    }

    /**
     * Get MIX_CTRL's DDR_EN bit.
     *
     * Dual data rate mode selection
     */
    inline bool get_MIX_CTRL_DDR_EN() volatile
    {
        return MIX_CTRL & (1u << 3u);
    }

    /**
     * Set MIX_CTRL's DDR_EN bit.
     *
     * Dual data rate mode selection
     */
    inline void set_MIX_CTRL_DDR_EN() volatile
    {
        MIX_CTRL |= 1u << 3u;
    }

    /**
     * Clear MIX_CTRL's DDR_EN bit.
     *
     * Dual data rate mode selection
     */
    inline void clear_MIX_CTRL_DDR_EN() volatile
    {
        MIX_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle MIX_CTRL's DDR_EN bit.
     *
     * Dual data rate mode selection
     */
    inline void toggle_MIX_CTRL_DDR_EN() volatile
    {
        MIX_CTRL ^= 1u << 3u;
    }

    /**
     * Get MIX_CTRL's AC12EN bit.
     *
     * Auto CMD12 enable
     */
    inline bool get_MIX_CTRL_AC12EN() volatile
    {
        return MIX_CTRL & (1u << 2u);
    }

    /**
     * Set MIX_CTRL's AC12EN bit.
     *
     * Auto CMD12 enable
     */
    inline void set_MIX_CTRL_AC12EN() volatile
    {
        MIX_CTRL |= 1u << 2u;
    }

    /**
     * Clear MIX_CTRL's AC12EN bit.
     *
     * Auto CMD12 enable
     */
    inline void clear_MIX_CTRL_AC12EN() volatile
    {
        MIX_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle MIX_CTRL's AC12EN bit.
     *
     * Auto CMD12 enable
     */
    inline void toggle_MIX_CTRL_AC12EN() volatile
    {
        MIX_CTRL ^= 1u << 2u;
    }

    /**
     * Get MIX_CTRL's BCEN bit.
     *
     * Block count enable
     */
    inline bool get_MIX_CTRL_BCEN() volatile
    {
        return MIX_CTRL & (1u << 1u);
    }

    /**
     * Set MIX_CTRL's BCEN bit.
     *
     * Block count enable
     */
    inline void set_MIX_CTRL_BCEN() volatile
    {
        MIX_CTRL |= 1u << 1u;
    }

    /**
     * Clear MIX_CTRL's BCEN bit.
     *
     * Block count enable
     */
    inline void clear_MIX_CTRL_BCEN() volatile
    {
        MIX_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MIX_CTRL's BCEN bit.
     *
     * Block count enable
     */
    inline void toggle_MIX_CTRL_BCEN() volatile
    {
        MIX_CTRL ^= 1u << 1u;
    }

    /**
     * Get MIX_CTRL's DMAEN bit.
     *
     * DMA enable
     */
    inline bool get_MIX_CTRL_DMAEN() volatile
    {
        return MIX_CTRL & (1u << 0u);
    }

    /**
     * Set MIX_CTRL's DMAEN bit.
     *
     * DMA enable
     */
    inline void set_MIX_CTRL_DMAEN() volatile
    {
        MIX_CTRL |= 1u << 0u;
    }

    /**
     * Clear MIX_CTRL's DMAEN bit.
     *
     * DMA enable
     */
    inline void clear_MIX_CTRL_DMAEN() volatile
    {
        MIX_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MIX_CTRL's DMAEN bit.
     *
     * DMA enable
     */
    inline void toggle_MIX_CTRL_DMAEN() volatile
    {
        MIX_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MIX_CTRL's bit fields.
     *
     * (read-write) Mixer Control
     */
    inline void get_MIX_CTRL(bool &HS400_MODE, bool &FBCLK_SEL,
                             bool &AUTO_TUNE_EN, bool &SMP_CLK_SEL,
                             bool &EXE_TUNE, bool &AC23EN, bool &NIBBLE_POS,
                             bool &MSBSEL, bool &DTDSEL, bool &DDR_EN,
                             bool &AC12EN, bool &BCEN, bool &DMAEN) volatile
    {
        uint32_t curr = MIX_CTRL;

        HS400_MODE = curr & (1u << 26u);
        FBCLK_SEL = curr & (1u << 25u);
        AUTO_TUNE_EN = curr & (1u << 24u);
        SMP_CLK_SEL = curr & (1u << 23u);
        EXE_TUNE = curr & (1u << 22u);
        AC23EN = curr & (1u << 7u);
        NIBBLE_POS = curr & (1u << 6u);
        MSBSEL = curr & (1u << 5u);
        DTDSEL = curr & (1u << 4u);
        DDR_EN = curr & (1u << 3u);
        AC12EN = curr & (1u << 2u);
        BCEN = curr & (1u << 1u);
        DMAEN = curr & (1u << 0u);
    }

    /**
     * Set all of MIX_CTRL's bit fields.
     *
     * (read-write) Mixer Control
     */
    inline void set_MIX_CTRL(bool HS400_MODE, bool FBCLK_SEL,
                             bool AUTO_TUNE_EN, bool SMP_CLK_SEL,
                             bool EXE_TUNE, bool AC23EN, bool NIBBLE_POS,
                             bool MSBSEL, bool DTDSEL, bool DDR_EN,
                             bool AC12EN, bool BCEN, bool DMAEN) volatile
    {
        uint32_t curr = MIX_CTRL;

        curr &= ~(0b1u << 26u);
        curr |= (HS400_MODE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (FBCLK_SEL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (AUTO_TUNE_EN & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (SMP_CLK_SEL & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EXE_TUNE & 0b1u) << 22u;
        curr &= ~(0b1u << 7u);
        curr |= (AC23EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (NIBBLE_POS & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MSBSEL & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DTDSEL & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DDR_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AC12EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (BCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DMAEN & 0b1u) << 0u;

        MIX_CTRL = curr;
    }

    /**
     * Get FORCE_EVENT's FEVTCINT bit.
     *
     * Force event card interrupt
     */
    inline bool get_FORCE_EVENT_FEVTCINT() volatile
    {
        return FORCE_EVENT & (1u << 31u);
    }

    /**
     * Set FORCE_EVENT's FEVTCINT bit.
     *
     * Force event card interrupt
     */
    inline void set_FORCE_EVENT_FEVTCINT() volatile
    {
        FORCE_EVENT |= 1u << 31u;
    }

    /**
     * Clear FORCE_EVENT's FEVTCINT bit.
     *
     * Force event card interrupt
     */
    inline void clear_FORCE_EVENT_FEVTCINT() volatile
    {
        FORCE_EVENT &= ~(1u << 31u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTCINT bit.
     *
     * Force event card interrupt
     */
    inline void toggle_FORCE_EVENT_FEVTCINT() volatile
    {
        FORCE_EVENT ^= 1u << 31u;
    }

    /**
     * Get FORCE_EVENT's FEVTDMAE bit.
     *
     * Force event DMA error
     */
    inline bool get_FORCE_EVENT_FEVTDMAE() volatile
    {
        return FORCE_EVENT & (1u << 28u);
    }

    /**
     * Set FORCE_EVENT's FEVTDMAE bit.
     *
     * Force event DMA error
     */
    inline void set_FORCE_EVENT_FEVTDMAE() volatile
    {
        FORCE_EVENT |= 1u << 28u;
    }

    /**
     * Clear FORCE_EVENT's FEVTDMAE bit.
     *
     * Force event DMA error
     */
    inline void clear_FORCE_EVENT_FEVTDMAE() volatile
    {
        FORCE_EVENT &= ~(1u << 28u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTDMAE bit.
     *
     * Force event DMA error
     */
    inline void toggle_FORCE_EVENT_FEVTDMAE() volatile
    {
        FORCE_EVENT ^= 1u << 28u;
    }

    /**
     * Get FORCE_EVENT's FEVTTNE bit.
     *
     * Force tuning error
     */
    inline bool get_FORCE_EVENT_FEVTTNE() volatile
    {
        return FORCE_EVENT & (1u << 26u);
    }

    /**
     * Set FORCE_EVENT's FEVTTNE bit.
     *
     * Force tuning error
     */
    inline void set_FORCE_EVENT_FEVTTNE() volatile
    {
        FORCE_EVENT |= 1u << 26u;
    }

    /**
     * Clear FORCE_EVENT's FEVTTNE bit.
     *
     * Force tuning error
     */
    inline void clear_FORCE_EVENT_FEVTTNE() volatile
    {
        FORCE_EVENT &= ~(1u << 26u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTTNE bit.
     *
     * Force tuning error
     */
    inline void toggle_FORCE_EVENT_FEVTTNE() volatile
    {
        FORCE_EVENT ^= 1u << 26u;
    }

    /**
     * Get FORCE_EVENT's FEVTAC12E bit.
     *
     * Force event Auto Command 12 error
     */
    inline bool get_FORCE_EVENT_FEVTAC12E() volatile
    {
        return FORCE_EVENT & (1u << 24u);
    }

    /**
     * Set FORCE_EVENT's FEVTAC12E bit.
     *
     * Force event Auto Command 12 error
     */
    inline void set_FORCE_EVENT_FEVTAC12E() volatile
    {
        FORCE_EVENT |= 1u << 24u;
    }

    /**
     * Clear FORCE_EVENT's FEVTAC12E bit.
     *
     * Force event Auto Command 12 error
     */
    inline void clear_FORCE_EVENT_FEVTAC12E() volatile
    {
        FORCE_EVENT &= ~(1u << 24u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTAC12E bit.
     *
     * Force event Auto Command 12 error
     */
    inline void toggle_FORCE_EVENT_FEVTAC12E() volatile
    {
        FORCE_EVENT ^= 1u << 24u;
    }

    /**
     * Get FORCE_EVENT's FEVTDEBE bit.
     *
     * Force event data end bit error
     */
    inline bool get_FORCE_EVENT_FEVTDEBE() volatile
    {
        return FORCE_EVENT & (1u << 22u);
    }

    /**
     * Set FORCE_EVENT's FEVTDEBE bit.
     *
     * Force event data end bit error
     */
    inline void set_FORCE_EVENT_FEVTDEBE() volatile
    {
        FORCE_EVENT |= 1u << 22u;
    }

    /**
     * Clear FORCE_EVENT's FEVTDEBE bit.
     *
     * Force event data end bit error
     */
    inline void clear_FORCE_EVENT_FEVTDEBE() volatile
    {
        FORCE_EVENT &= ~(1u << 22u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTDEBE bit.
     *
     * Force event data end bit error
     */
    inline void toggle_FORCE_EVENT_FEVTDEBE() volatile
    {
        FORCE_EVENT ^= 1u << 22u;
    }

    /**
     * Get FORCE_EVENT's FEVTDCE bit.
     *
     * Force event data CRC error
     */
    inline bool get_FORCE_EVENT_FEVTDCE() volatile
    {
        return FORCE_EVENT & (1u << 21u);
    }

    /**
     * Set FORCE_EVENT's FEVTDCE bit.
     *
     * Force event data CRC error
     */
    inline void set_FORCE_EVENT_FEVTDCE() volatile
    {
        FORCE_EVENT |= 1u << 21u;
    }

    /**
     * Clear FORCE_EVENT's FEVTDCE bit.
     *
     * Force event data CRC error
     */
    inline void clear_FORCE_EVENT_FEVTDCE() volatile
    {
        FORCE_EVENT &= ~(1u << 21u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTDCE bit.
     *
     * Force event data CRC error
     */
    inline void toggle_FORCE_EVENT_FEVTDCE() volatile
    {
        FORCE_EVENT ^= 1u << 21u;
    }

    /**
     * Get FORCE_EVENT's FEVTDTOE bit.
     *
     * Force event data time out error
     */
    inline bool get_FORCE_EVENT_FEVTDTOE() volatile
    {
        return FORCE_EVENT & (1u << 20u);
    }

    /**
     * Set FORCE_EVENT's FEVTDTOE bit.
     *
     * Force event data time out error
     */
    inline void set_FORCE_EVENT_FEVTDTOE() volatile
    {
        FORCE_EVENT |= 1u << 20u;
    }

    /**
     * Clear FORCE_EVENT's FEVTDTOE bit.
     *
     * Force event data time out error
     */
    inline void clear_FORCE_EVENT_FEVTDTOE() volatile
    {
        FORCE_EVENT &= ~(1u << 20u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTDTOE bit.
     *
     * Force event data time out error
     */
    inline void toggle_FORCE_EVENT_FEVTDTOE() volatile
    {
        FORCE_EVENT ^= 1u << 20u;
    }

    /**
     * Get FORCE_EVENT's FEVTCIE bit.
     *
     * Force event command index error
     */
    inline bool get_FORCE_EVENT_FEVTCIE() volatile
    {
        return FORCE_EVENT & (1u << 19u);
    }

    /**
     * Set FORCE_EVENT's FEVTCIE bit.
     *
     * Force event command index error
     */
    inline void set_FORCE_EVENT_FEVTCIE() volatile
    {
        FORCE_EVENT |= 1u << 19u;
    }

    /**
     * Clear FORCE_EVENT's FEVTCIE bit.
     *
     * Force event command index error
     */
    inline void clear_FORCE_EVENT_FEVTCIE() volatile
    {
        FORCE_EVENT &= ~(1u << 19u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTCIE bit.
     *
     * Force event command index error
     */
    inline void toggle_FORCE_EVENT_FEVTCIE() volatile
    {
        FORCE_EVENT ^= 1u << 19u;
    }

    /**
     * Get FORCE_EVENT's FEVTCEBE bit.
     *
     * Force event command end bit error
     */
    inline bool get_FORCE_EVENT_FEVTCEBE() volatile
    {
        return FORCE_EVENT & (1u << 18u);
    }

    /**
     * Set FORCE_EVENT's FEVTCEBE bit.
     *
     * Force event command end bit error
     */
    inline void set_FORCE_EVENT_FEVTCEBE() volatile
    {
        FORCE_EVENT |= 1u << 18u;
    }

    /**
     * Clear FORCE_EVENT's FEVTCEBE bit.
     *
     * Force event command end bit error
     */
    inline void clear_FORCE_EVENT_FEVTCEBE() volatile
    {
        FORCE_EVENT &= ~(1u << 18u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTCEBE bit.
     *
     * Force event command end bit error
     */
    inline void toggle_FORCE_EVENT_FEVTCEBE() volatile
    {
        FORCE_EVENT ^= 1u << 18u;
    }

    /**
     * Get FORCE_EVENT's FEVTCCE bit.
     *
     * Force event command CRC error
     */
    inline bool get_FORCE_EVENT_FEVTCCE() volatile
    {
        return FORCE_EVENT & (1u << 17u);
    }

    /**
     * Set FORCE_EVENT's FEVTCCE bit.
     *
     * Force event command CRC error
     */
    inline void set_FORCE_EVENT_FEVTCCE() volatile
    {
        FORCE_EVENT |= 1u << 17u;
    }

    /**
     * Clear FORCE_EVENT's FEVTCCE bit.
     *
     * Force event command CRC error
     */
    inline void clear_FORCE_EVENT_FEVTCCE() volatile
    {
        FORCE_EVENT &= ~(1u << 17u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTCCE bit.
     *
     * Force event command CRC error
     */
    inline void toggle_FORCE_EVENT_FEVTCCE() volatile
    {
        FORCE_EVENT ^= 1u << 17u;
    }

    /**
     * Get FORCE_EVENT's FEVTCTOE bit.
     *
     * Force event command time out error
     */
    inline bool get_FORCE_EVENT_FEVTCTOE() volatile
    {
        return FORCE_EVENT & (1u << 16u);
    }

    /**
     * Set FORCE_EVENT's FEVTCTOE bit.
     *
     * Force event command time out error
     */
    inline void set_FORCE_EVENT_FEVTCTOE() volatile
    {
        FORCE_EVENT |= 1u << 16u;
    }

    /**
     * Clear FORCE_EVENT's FEVTCTOE bit.
     *
     * Force event command time out error
     */
    inline void clear_FORCE_EVENT_FEVTCTOE() volatile
    {
        FORCE_EVENT &= ~(1u << 16u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTCTOE bit.
     *
     * Force event command time out error
     */
    inline void toggle_FORCE_EVENT_FEVTCTOE() volatile
    {
        FORCE_EVENT ^= 1u << 16u;
    }

    /**
     * Get FORCE_EVENT's FEVTCNIBAC12E bit.
     *
     * Force event command not executed by Auto Command 12 error
     */
    inline bool get_FORCE_EVENT_FEVTCNIBAC12E() volatile
    {
        return FORCE_EVENT & (1u << 7u);
    }

    /**
     * Set FORCE_EVENT's FEVTCNIBAC12E bit.
     *
     * Force event command not executed by Auto Command 12 error
     */
    inline void set_FORCE_EVENT_FEVTCNIBAC12E() volatile
    {
        FORCE_EVENT |= 1u << 7u;
    }

    /**
     * Clear FORCE_EVENT's FEVTCNIBAC12E bit.
     *
     * Force event command not executed by Auto Command 12 error
     */
    inline void clear_FORCE_EVENT_FEVTCNIBAC12E() volatile
    {
        FORCE_EVENT &= ~(1u << 7u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTCNIBAC12E bit.
     *
     * Force event command not executed by Auto Command 12 error
     */
    inline void toggle_FORCE_EVENT_FEVTCNIBAC12E() volatile
    {
        FORCE_EVENT ^= 1u << 7u;
    }

    /**
     * Get FORCE_EVENT's FEVTAC12IE bit.
     *
     * Force event Auto Command 12 index error
     */
    inline bool get_FORCE_EVENT_FEVTAC12IE() volatile
    {
        return FORCE_EVENT & (1u << 4u);
    }

    /**
     * Set FORCE_EVENT's FEVTAC12IE bit.
     *
     * Force event Auto Command 12 index error
     */
    inline void set_FORCE_EVENT_FEVTAC12IE() volatile
    {
        FORCE_EVENT |= 1u << 4u;
    }

    /**
     * Clear FORCE_EVENT's FEVTAC12IE bit.
     *
     * Force event Auto Command 12 index error
     */
    inline void clear_FORCE_EVENT_FEVTAC12IE() volatile
    {
        FORCE_EVENT &= ~(1u << 4u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTAC12IE bit.
     *
     * Force event Auto Command 12 index error
     */
    inline void toggle_FORCE_EVENT_FEVTAC12IE() volatile
    {
        FORCE_EVENT ^= 1u << 4u;
    }

    /**
     * Get FORCE_EVENT's FEVTAC12EBE bit.
     *
     * Force event Auto Command 12 end bit error
     */
    inline bool get_FORCE_EVENT_FEVTAC12EBE() volatile
    {
        return FORCE_EVENT & (1u << 3u);
    }

    /**
     * Set FORCE_EVENT's FEVTAC12EBE bit.
     *
     * Force event Auto Command 12 end bit error
     */
    inline void set_FORCE_EVENT_FEVTAC12EBE() volatile
    {
        FORCE_EVENT |= 1u << 3u;
    }

    /**
     * Clear FORCE_EVENT's FEVTAC12EBE bit.
     *
     * Force event Auto Command 12 end bit error
     */
    inline void clear_FORCE_EVENT_FEVTAC12EBE() volatile
    {
        FORCE_EVENT &= ~(1u << 3u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTAC12EBE bit.
     *
     * Force event Auto Command 12 end bit error
     */
    inline void toggle_FORCE_EVENT_FEVTAC12EBE() volatile
    {
        FORCE_EVENT ^= 1u << 3u;
    }

    /**
     * Get FORCE_EVENT's FEVTAC12CE bit.
     *
     * Force event auto command 12 CRC error
     */
    inline bool get_FORCE_EVENT_FEVTAC12CE() volatile
    {
        return FORCE_EVENT & (1u << 2u);
    }

    /**
     * Set FORCE_EVENT's FEVTAC12CE bit.
     *
     * Force event auto command 12 CRC error
     */
    inline void set_FORCE_EVENT_FEVTAC12CE() volatile
    {
        FORCE_EVENT |= 1u << 2u;
    }

    /**
     * Clear FORCE_EVENT's FEVTAC12CE bit.
     *
     * Force event auto command 12 CRC error
     */
    inline void clear_FORCE_EVENT_FEVTAC12CE() volatile
    {
        FORCE_EVENT &= ~(1u << 2u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTAC12CE bit.
     *
     * Force event auto command 12 CRC error
     */
    inline void toggle_FORCE_EVENT_FEVTAC12CE() volatile
    {
        FORCE_EVENT ^= 1u << 2u;
    }

    /**
     * Get FORCE_EVENT's FEVTAC12TOE bit.
     *
     * Force event auto command 12 time out error
     */
    inline bool get_FORCE_EVENT_FEVTAC12TOE() volatile
    {
        return FORCE_EVENT & (1u << 1u);
    }

    /**
     * Set FORCE_EVENT's FEVTAC12TOE bit.
     *
     * Force event auto command 12 time out error
     */
    inline void set_FORCE_EVENT_FEVTAC12TOE() volatile
    {
        FORCE_EVENT |= 1u << 1u;
    }

    /**
     * Clear FORCE_EVENT's FEVTAC12TOE bit.
     *
     * Force event auto command 12 time out error
     */
    inline void clear_FORCE_EVENT_FEVTAC12TOE() volatile
    {
        FORCE_EVENT &= ~(1u << 1u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTAC12TOE bit.
     *
     * Force event auto command 12 time out error
     */
    inline void toggle_FORCE_EVENT_FEVTAC12TOE() volatile
    {
        FORCE_EVENT ^= 1u << 1u;
    }

    /**
     * Get FORCE_EVENT's FEVTAC12NE bit.
     *
     * Force event auto command 12 not executed
     */
    inline bool get_FORCE_EVENT_FEVTAC12NE() volatile
    {
        return FORCE_EVENT & (1u << 0u);
    }

    /**
     * Set FORCE_EVENT's FEVTAC12NE bit.
     *
     * Force event auto command 12 not executed
     */
    inline void set_FORCE_EVENT_FEVTAC12NE() volatile
    {
        FORCE_EVENT |= 1u << 0u;
    }

    /**
     * Clear FORCE_EVENT's FEVTAC12NE bit.
     *
     * Force event auto command 12 not executed
     */
    inline void clear_FORCE_EVENT_FEVTAC12NE() volatile
    {
        FORCE_EVENT &= ~(1u << 0u);
    }

    /**
     * Toggle FORCE_EVENT's FEVTAC12NE bit.
     *
     * Force event auto command 12 not executed
     */
    inline void toggle_FORCE_EVENT_FEVTAC12NE() volatile
    {
        FORCE_EVENT ^= 1u << 0u;
    }

    /**
     * Get all of FORCE_EVENT's bit fields.
     *
     * (read-write) Force Event
     */
    inline void get_FORCE_EVENT(bool &FEVTCINT, bool &FEVTDMAE, bool &FEVTTNE,
                                bool &FEVTAC12E, bool &FEVTDEBE, bool &FEVTDCE,
                                bool &FEVTDTOE, bool &FEVTCIE, bool &FEVTCEBE,
                                bool &FEVTCCE, bool &FEVTCTOE,
                                bool &FEVTCNIBAC12E, bool &FEVTAC12IE,
                                bool &FEVTAC12EBE, bool &FEVTAC12CE,
                                bool &FEVTAC12TOE, bool &FEVTAC12NE) volatile
    {
        uint32_t curr = FORCE_EVENT;

        FEVTCINT = curr & (1u << 31u);
        FEVTDMAE = curr & (1u << 28u);
        FEVTTNE = curr & (1u << 26u);
        FEVTAC12E = curr & (1u << 24u);
        FEVTDEBE = curr & (1u << 22u);
        FEVTDCE = curr & (1u << 21u);
        FEVTDTOE = curr & (1u << 20u);
        FEVTCIE = curr & (1u << 19u);
        FEVTCEBE = curr & (1u << 18u);
        FEVTCCE = curr & (1u << 17u);
        FEVTCTOE = curr & (1u << 16u);
        FEVTCNIBAC12E = curr & (1u << 7u);
        FEVTAC12IE = curr & (1u << 4u);
        FEVTAC12EBE = curr & (1u << 3u);
        FEVTAC12CE = curr & (1u << 2u);
        FEVTAC12TOE = curr & (1u << 1u);
        FEVTAC12NE = curr & (1u << 0u);
    }

    /**
     * Set all of FORCE_EVENT's bit fields.
     *
     * (read-write) Force Event
     */
    inline void set_FORCE_EVENT(bool FEVTCINT, bool FEVTDMAE, bool FEVTTNE,
                                bool FEVTAC12E, bool FEVTDEBE, bool FEVTDCE,
                                bool FEVTDTOE, bool FEVTCIE, bool FEVTCEBE,
                                bool FEVTCCE, bool FEVTCTOE,
                                bool FEVTCNIBAC12E, bool FEVTAC12IE,
                                bool FEVTAC12EBE, bool FEVTAC12CE,
                                bool FEVTAC12TOE, bool FEVTAC12NE) volatile
    {
        uint32_t curr = FORCE_EVENT;

        curr &= ~(0b1u << 31u);
        curr |= (FEVTCINT & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (FEVTDMAE & 0b1u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (FEVTTNE & 0b1u) << 26u;
        curr &= ~(0b1u << 24u);
        curr |= (FEVTAC12E & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (FEVTDEBE & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (FEVTDCE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (FEVTDTOE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (FEVTCIE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (FEVTCEBE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (FEVTCCE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (FEVTCTOE & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (FEVTCNIBAC12E & 0b1u) << 7u;
        curr &= ~(0b1u << 4u);
        curr |= (FEVTAC12IE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FEVTAC12EBE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FEVTAC12CE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (FEVTAC12TOE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FEVTAC12NE & 0b1u) << 0u;

        FORCE_EVENT = curr;
    }

    /**
     * Get ADMA_ERR_STATUS's ADMADCE bit.
     *
     * ADMA descriptor error
     */
    inline bool get_ADMA_ERR_STATUS_ADMADCE() volatile
    {
        return ADMA_ERR_STATUS & (1u << 3u);
    }

    /**
     * Get ADMA_ERR_STATUS's ADMALME bit.
     *
     * ADMA length mismatch error
     */
    inline bool get_ADMA_ERR_STATUS_ADMALME() volatile
    {
        return ADMA_ERR_STATUS & (1u << 2u);
    }

    /**
     * Get ADMA_ERR_STATUS's ADMAES field.
     *
     * ADMA error state (when ADMA error is occurred)
     */
    inline uint8_t get_ADMA_ERR_STATUS_ADMAES() volatile
    {
        return (ADMA_ERR_STATUS >> 0u) & 0b11u;
    }

    /**
     * Get all of ADMA_ERR_STATUS's bit fields.
     *
     * (read-write) ADMA Error Status
     */
    inline void get_ADMA_ERR_STATUS(bool &ADMADCE, bool &ADMALME,
                                    uint8_t &ADMAES) volatile
    {
        uint32_t curr = ADMA_ERR_STATUS;

        ADMADCE = curr & (1u << 3u);
        ADMALME = curr & (1u << 2u);
        ADMAES = (curr >> 0u) & 0b11u;
    }

    /**
     * Get ADMA_SYS_ADDR's ADS_ADDR field.
     *
     * ADMA system address
     */
    inline uint32_t get_ADMA_SYS_ADDR_ADS_ADDR() volatile
    {
        return (ADMA_SYS_ADDR >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set ADMA_SYS_ADDR's ADS_ADDR field.
     *
     * ADMA system address
     */
    inline void set_ADMA_SYS_ADDR_ADS_ADDR(uint32_t value) volatile
    {
        uint32_t curr = ADMA_SYS_ADDR;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        ADMA_SYS_ADDR = curr;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_REF_UPDATE_INT field.
     *
     * DLL control loop update interval
     */
    inline uint8_t get_DLL_CTRL_DLL_CTRL_REF_UPDATE_INT() volatile
    {
        return (DLL_CTRL >> 28u) & 0b1111u;
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_REF_UPDATE_INT field.
     *
     * DLL control loop update interval
     */
    inline void set_DLL_CTRL_DLL_CTRL_REF_UPDATE_INT(uint8_t value) volatile
    {
        uint32_t curr = DLL_CTRL;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        DLL_CTRL = curr;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_SLV_UPDATE_INT field.
     *
     * Slave delay line update interval
     */
    inline uint8_t get_DLL_CTRL_DLL_CTRL_SLV_UPDATE_INT() volatile
    {
        return (DLL_CTRL >> 20u) & 0b11111111u;
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_SLV_UPDATE_INT field.
     *
     * Slave delay line update interval
     */
    inline void set_DLL_CTRL_DLL_CTRL_SLV_UPDATE_INT(uint8_t value) volatile
    {
        uint32_t curr = DLL_CTRL;

        curr &= ~(0b11111111u << 20u);
        curr |= (value & 0b11111111u) << 20u;

        DLL_CTRL = curr;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_SLV_DLY_TARGET1 field.
     *
     * DLL slave delay target1
     */
    inline uint8_t get_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET1() volatile
    {
        return (DLL_CTRL >> 16u) & 0b111u;
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_SLV_DLY_TARGET1 field.
     *
     * DLL slave delay target1
     */
    inline void set_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET1(uint8_t value) volatile
    {
        uint32_t curr = DLL_CTRL;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        DLL_CTRL = curr;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_SLV_OVERRIDE_VAL field.
     *
     * DLL slave override val
     */
    inline uint8_t get_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE_VAL() volatile
    {
        return (DLL_CTRL >> 9u) & 0b1111111u;
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_SLV_OVERRIDE_VAL field.
     *
     * DLL slave override val
     */
    inline void set_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE_VAL(uint8_t value) volatile
    {
        uint32_t curr = DLL_CTRL;

        curr &= ~(0b1111111u << 9u);
        curr |= (value & 0b1111111u) << 9u;

        DLL_CTRL = curr;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_SLV_OVERRIDE bit.
     *
     * DLL slave override
     */
    inline bool get_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        return DLL_CTRL & (1u << 8u);
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_SLV_OVERRIDE bit.
     *
     * DLL slave override
     */
    inline void set_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        DLL_CTRL |= 1u << 8u;
    }

    /**
     * Clear DLL_CTRL's DLL_CTRL_SLV_OVERRIDE bit.
     *
     * DLL slave override
     */
    inline void clear_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        DLL_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle DLL_CTRL's DLL_CTRL_SLV_OVERRIDE bit.
     *
     * DLL slave override
     */
    inline void toggle_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        DLL_CTRL ^= 1u << 8u;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_GATE_UPDATE bit.
     *
     * DLL gate update
     */
    inline bool get_DLL_CTRL_DLL_CTRL_GATE_UPDATE() volatile
    {
        return DLL_CTRL & (1u << 7u);
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_GATE_UPDATE bit.
     *
     * DLL gate update
     */
    inline void set_DLL_CTRL_DLL_CTRL_GATE_UPDATE() volatile
    {
        DLL_CTRL |= 1u << 7u;
    }

    /**
     * Clear DLL_CTRL's DLL_CTRL_GATE_UPDATE bit.
     *
     * DLL gate update
     */
    inline void clear_DLL_CTRL_DLL_CTRL_GATE_UPDATE() volatile
    {
        DLL_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle DLL_CTRL's DLL_CTRL_GATE_UPDATE bit.
     *
     * DLL gate update
     */
    inline void toggle_DLL_CTRL_DLL_CTRL_GATE_UPDATE() volatile
    {
        DLL_CTRL ^= 1u << 7u;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_SLV_DLY_TARGET0 field.
     *
     * DLL slave delay target0
     */
    inline uint8_t get_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET0() volatile
    {
        return (DLL_CTRL >> 3u) & 0b1111u;
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_SLV_DLY_TARGET0 field.
     *
     * DLL slave delay target0
     */
    inline void set_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET0(uint8_t value) volatile
    {
        uint32_t curr = DLL_CTRL;

        curr &= ~(0b1111u << 3u);
        curr |= (value & 0b1111u) << 3u;

        DLL_CTRL = curr;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * DLL slave delay line
     */
    inline bool get_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        return DLL_CTRL & (1u << 2u);
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * DLL slave delay line
     */
    inline void set_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        DLL_CTRL |= 1u << 2u;
    }

    /**
     * Clear DLL_CTRL's DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * DLL slave delay line
     */
    inline void clear_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        DLL_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle DLL_CTRL's DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * DLL slave delay line
     */
    inline void toggle_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        DLL_CTRL ^= 1u << 2u;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_RESET bit.
     *
     * DLL reset
     */
    inline bool get_DLL_CTRL_DLL_CTRL_RESET() volatile
    {
        return DLL_CTRL & (1u << 1u);
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_RESET bit.
     *
     * DLL reset
     */
    inline void set_DLL_CTRL_DLL_CTRL_RESET() volatile
    {
        DLL_CTRL |= 1u << 1u;
    }

    /**
     * Clear DLL_CTRL's DLL_CTRL_RESET bit.
     *
     * DLL reset
     */
    inline void clear_DLL_CTRL_DLL_CTRL_RESET() volatile
    {
        DLL_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle DLL_CTRL's DLL_CTRL_RESET bit.
     *
     * DLL reset
     */
    inline void toggle_DLL_CTRL_DLL_CTRL_RESET() volatile
    {
        DLL_CTRL ^= 1u << 1u;
    }

    /**
     * Get DLL_CTRL's DLL_CTRL_ENABLE bit.
     *
     * DLL and delay chain
     */
    inline bool get_DLL_CTRL_DLL_CTRL_ENABLE() volatile
    {
        return DLL_CTRL & (1u << 0u);
    }

    /**
     * Set DLL_CTRL's DLL_CTRL_ENABLE bit.
     *
     * DLL and delay chain
     */
    inline void set_DLL_CTRL_DLL_CTRL_ENABLE() volatile
    {
        DLL_CTRL |= 1u << 0u;
    }

    /**
     * Clear DLL_CTRL's DLL_CTRL_ENABLE bit.
     *
     * DLL and delay chain
     */
    inline void clear_DLL_CTRL_DLL_CTRL_ENABLE() volatile
    {
        DLL_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle DLL_CTRL's DLL_CTRL_ENABLE bit.
     *
     * DLL and delay chain
     */
    inline void toggle_DLL_CTRL_DLL_CTRL_ENABLE() volatile
    {
        DLL_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of DLL_CTRL's bit fields.
     *
     * (read-write) DLL (Delay Line) Control
     */
    inline void get_DLL_CTRL(
        uint8_t &DLL_CTRL_REF_UPDATE_INT, uint8_t &DLL_CTRL_SLV_UPDATE_INT,
        uint8_t &DLL_CTRL_SLV_DLY_TARGET1, uint8_t &DLL_CTRL_SLV_OVERRIDE_VAL,
        bool &DLL_CTRL_SLV_OVERRIDE, bool &DLL_CTRL_GATE_UPDATE,
        uint8_t &DLL_CTRL_SLV_DLY_TARGET0, bool &DLL_CTRL_SLV_FORCE_UPD,
        bool &DLL_CTRL_RESET, bool &DLL_CTRL_ENABLE) volatile
    {
        uint32_t curr = DLL_CTRL;

        DLL_CTRL_REF_UPDATE_INT = (curr >> 28u) & 0b1111u;
        DLL_CTRL_SLV_UPDATE_INT = (curr >> 20u) & 0b11111111u;
        DLL_CTRL_SLV_DLY_TARGET1 = (curr >> 16u) & 0b111u;
        DLL_CTRL_SLV_OVERRIDE_VAL = (curr >> 9u) & 0b1111111u;
        DLL_CTRL_SLV_OVERRIDE = curr & (1u << 8u);
        DLL_CTRL_GATE_UPDATE = curr & (1u << 7u);
        DLL_CTRL_SLV_DLY_TARGET0 = (curr >> 3u) & 0b1111u;
        DLL_CTRL_SLV_FORCE_UPD = curr & (1u << 2u);
        DLL_CTRL_RESET = curr & (1u << 1u);
        DLL_CTRL_ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of DLL_CTRL's bit fields.
     *
     * (read-write) DLL (Delay Line) Control
     */
    inline void set_DLL_CTRL(
        uint8_t DLL_CTRL_REF_UPDATE_INT, uint8_t DLL_CTRL_SLV_UPDATE_INT,
        uint8_t DLL_CTRL_SLV_DLY_TARGET1, uint8_t DLL_CTRL_SLV_OVERRIDE_VAL,
        bool DLL_CTRL_SLV_OVERRIDE, bool DLL_CTRL_GATE_UPDATE,
        uint8_t DLL_CTRL_SLV_DLY_TARGET0, bool DLL_CTRL_SLV_FORCE_UPD,
        bool DLL_CTRL_RESET, bool DLL_CTRL_ENABLE) volatile
    {
        uint32_t curr = DLL_CTRL;

        curr &= ~(0b1111u << 28u);
        curr |= (DLL_CTRL_REF_UPDATE_INT & 0b1111u) << 28u;
        curr &= ~(0b11111111u << 20u);
        curr |= (DLL_CTRL_SLV_UPDATE_INT & 0b11111111u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (DLL_CTRL_SLV_DLY_TARGET1 & 0b111u) << 16u;
        curr &= ~(0b1111111u << 9u);
        curr |= (DLL_CTRL_SLV_OVERRIDE_VAL & 0b1111111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (DLL_CTRL_SLV_OVERRIDE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (DLL_CTRL_GATE_UPDATE & 0b1u) << 7u;
        curr &= ~(0b1111u << 3u);
        curr |= (DLL_CTRL_SLV_DLY_TARGET0 & 0b1111u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DLL_CTRL_SLV_FORCE_UPD & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DLL_CTRL_RESET & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DLL_CTRL_ENABLE & 0b1u) << 0u;

        DLL_CTRL = curr;
    }

    /**
     * Get DLL_STATUS's DLL_STS_REF_SEL field.
     *
     * Reference delay line select taps
     */
    inline uint8_t get_DLL_STATUS_DLL_STS_REF_SEL() volatile
    {
        return (DLL_STATUS >> 9u) & 0b1111111u;
    }

    /**
     * Get DLL_STATUS's DLL_STS_SLV_SEL field.
     *
     * Slave delay line select status
     */
    inline uint8_t get_DLL_STATUS_DLL_STS_SLV_SEL() volatile
    {
        return (DLL_STATUS >> 2u) & 0b1111111u;
    }

    /**
     * Get DLL_STATUS's DLL_STS_REF_LOCK bit.
     *
     * Reference DLL lock status
     */
    inline bool get_DLL_STATUS_DLL_STS_REF_LOCK() volatile
    {
        return DLL_STATUS & (1u << 1u);
    }

    /**
     * Get DLL_STATUS's DLL_STS_SLV_LOCK bit.
     *
     * Slave delay-line lock status
     */
    inline bool get_DLL_STATUS_DLL_STS_SLV_LOCK() volatile
    {
        return DLL_STATUS & (1u << 0u);
    }

    /**
     * Get all of DLL_STATUS's bit fields.
     *
     * (read-write) DLL Status
     */
    inline void get_DLL_STATUS(uint8_t &DLL_STS_REF_SEL,
                               uint8_t &DLL_STS_SLV_SEL,
                               bool &DLL_STS_REF_LOCK,
                               bool &DLL_STS_SLV_LOCK) volatile
    {
        uint32_t curr = DLL_STATUS;

        DLL_STS_REF_SEL = (curr >> 9u) & 0b1111111u;
        DLL_STS_SLV_SEL = (curr >> 2u) & 0b1111111u;
        DLL_STS_REF_LOCK = curr & (1u << 1u);
        DLL_STS_SLV_LOCK = curr & (1u << 0u);
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's PRE_ERR bit.
     *
     * PRE error
     */
    inline bool get_CLK_TUNE_CTRL_STATUS_PRE_ERR() volatile
    {
        return CLK_TUNE_CTRL_STATUS & (1u << 31u);
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's TAP_SEL_PRE field.
     *
     * TAP_SEL_PRE
     */
    inline uint8_t get_CLK_TUNE_CTRL_STATUS_TAP_SEL_PRE() volatile
    {
        return (CLK_TUNE_CTRL_STATUS >> 24u) & 0b1111111u;
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's TAP_SEL_OUT field.
     *
     * Delay cells added on the feedback clock between CLK_PRE and CLK_OUT
     */
    inline uint8_t get_CLK_TUNE_CTRL_STATUS_TAP_SEL_OUT() volatile
    {
        return (CLK_TUNE_CTRL_STATUS >> 20u) & 0b1111u;
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's TAP_SEL_POST field.
     *
     * Delay cells added on the feedback clock between CLK_OUT and CLK_POST
     */
    inline uint8_t get_CLK_TUNE_CTRL_STATUS_TAP_SEL_POST() volatile
    {
        return (CLK_TUNE_CTRL_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's NXT_ERR bit.
     *
     * NXT error
     */
    inline bool get_CLK_TUNE_CTRL_STATUS_NXT_ERR() volatile
    {
        return CLK_TUNE_CTRL_STATUS & (1u << 15u);
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's DLY_CELL_SET_PRE field.
     *
     * delay cells on the feedback clock between the feedback clock and CLK_PRE
     */
    inline uint8_t get_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE() volatile
    {
        return (CLK_TUNE_CTRL_STATUS >> 8u) & 0b1111111u;
    }

    /**
     * Set CLK_TUNE_CTRL_STATUS's DLY_CELL_SET_PRE field.
     *
     * delay cells on the feedback clock between the feedback clock and CLK_PRE
     */
    inline void set_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE(
        uint8_t value) volatile
    {
        uint32_t curr = CLK_TUNE_CTRL_STATUS;

        curr &= ~(0b1111111u << 8u);
        curr |= (value & 0b1111111u) << 8u;

        CLK_TUNE_CTRL_STATUS = curr;
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's DLY_CELL_SET_OUT field.
     *
     * Delay cells on the feedback clock between CLK_PRE and CLK_OUT
     */
    inline uint8_t get_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_OUT() volatile
    {
        return (CLK_TUNE_CTRL_STATUS >> 4u) & 0b1111u;
    }

    /**
     * Set CLK_TUNE_CTRL_STATUS's DLY_CELL_SET_OUT field.
     *
     * Delay cells on the feedback clock between CLK_PRE and CLK_OUT
     */
    inline void set_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_OUT(
        uint8_t value) volatile
    {
        uint32_t curr = CLK_TUNE_CTRL_STATUS;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CLK_TUNE_CTRL_STATUS = curr;
    }

    /**
     * Get CLK_TUNE_CTRL_STATUS's DLY_CELL_SET_POST field.
     *
     * Delay cells on the feedback clock between CLK_OUT and CLK_POST
     */
    inline uint8_t get_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_POST() volatile
    {
        return (CLK_TUNE_CTRL_STATUS >> 0u) & 0b1111u;
    }

    /**
     * Set CLK_TUNE_CTRL_STATUS's DLY_CELL_SET_POST field.
     *
     * Delay cells on the feedback clock between CLK_OUT and CLK_POST
     */
    inline void set_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_POST(
        uint8_t value) volatile
    {
        uint32_t curr = CLK_TUNE_CTRL_STATUS;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CLK_TUNE_CTRL_STATUS = curr;
    }

    /**
     * Get all of CLK_TUNE_CTRL_STATUS's bit fields.
     *
     * (read-write) CLK Tuning Control and Status
     */
    inline void get_CLK_TUNE_CTRL_STATUS(bool &PRE_ERR, uint8_t &TAP_SEL_PRE,
                                         uint8_t &TAP_SEL_OUT,
                                         uint8_t &TAP_SEL_POST, bool &NXT_ERR,
                                         uint8_t &DLY_CELL_SET_PRE,
                                         uint8_t &DLY_CELL_SET_OUT,
                                         uint8_t &DLY_CELL_SET_POST) volatile
    {
        uint32_t curr = CLK_TUNE_CTRL_STATUS;

        PRE_ERR = curr & (1u << 31u);
        TAP_SEL_PRE = (curr >> 24u) & 0b1111111u;
        TAP_SEL_OUT = (curr >> 20u) & 0b1111u;
        TAP_SEL_POST = (curr >> 16u) & 0b1111u;
        NXT_ERR = curr & (1u << 15u);
        DLY_CELL_SET_PRE = (curr >> 8u) & 0b1111111u;
        DLY_CELL_SET_OUT = (curr >> 4u) & 0b1111u;
        DLY_CELL_SET_POST = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CLK_TUNE_CTRL_STATUS's bit fields.
     *
     * (read-write) CLK Tuning Control and Status
     */
    inline void set_CLK_TUNE_CTRL_STATUS(uint8_t DLY_CELL_SET_PRE,
                                         uint8_t DLY_CELL_SET_OUT,
                                         uint8_t DLY_CELL_SET_POST) volatile
    {
        uint32_t curr = CLK_TUNE_CTRL_STATUS;

        curr &= ~(0b1111111u << 8u);
        curr |= (DLY_CELL_SET_PRE & 0b1111111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (DLY_CELL_SET_OUT & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (DLY_CELL_SET_POST & 0b1111u) << 0u;

        CLK_TUNE_CTRL_STATUS = curr;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_REF_UPDATE_INT field.
     *
     * Strobe DLL control reference update interval
     */
    inline uint8_t
    get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_REF_UPDATE_INT() volatile
    {
        return (STROBE_DLL_CTRL >> 28u) & 0b1111u;
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_REF_UPDATE_INT field.
     *
     * Strobe DLL control reference update interval
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_REF_UPDATE_INT(
        uint8_t value) volatile
    {
        uint32_t curr = STROBE_DLL_CTRL;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        STROBE_DLL_CTRL = curr;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_UPDATE_INT field.
     *
     * Strobe DLL control slave update interval
     */
    inline uint8_t
    get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_UPDATE_INT() volatile
    {
        return (STROBE_DLL_CTRL >> 20u) & 0b11111111u;
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_UPDATE_INT field.
     *
     * Strobe DLL control slave update interval
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_UPDATE_INT(
        uint8_t value) volatile
    {
        uint32_t curr = STROBE_DLL_CTRL;

        curr &= ~(0b11111111u << 20u);
        curr |= (value & 0b11111111u) << 20u;

        STROBE_DLL_CTRL = curr;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_OVERRIDE_VAL field.
     *
     * Strobe DLL control slave Override value
     */
    inline uint8_t
    get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_OVERRIDE_VAL() volatile
    {
        return (STROBE_DLL_CTRL >> 9u) & 0b1111111u;
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_OVERRIDE_VAL field.
     *
     * Strobe DLL control slave Override value
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_OVERRIDE_VAL(
        uint8_t value) volatile
    {
        uint32_t curr = STROBE_DLL_CTRL;

        curr &= ~(0b1111111u << 9u);
        curr |= (value & 0b1111111u) << 9u;

        STROBE_DLL_CTRL = curr;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_OVERRIDE bit.
     *
     * Strobe DLL control slave override
     */
    inline bool get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        return STROBE_DLL_CTRL & (1u << 8u);
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_OVERRIDE bit.
     *
     * Strobe DLL control slave override
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        STROBE_DLL_CTRL |= 1u << 8u;
    }

    /**
     * Clear STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_OVERRIDE bit.
     *
     * Strobe DLL control slave override
     */
    inline void clear_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        STROBE_DLL_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_OVERRIDE bit.
     *
     * Strobe DLL control slave override
     */
    inline void toggle_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_OVERRIDE() volatile
    {
        STROBE_DLL_CTRL ^= 1u << 8u;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_GATE_UPDATE bit.
     *
     * Strobe DLL control gate update
     */
    inline bool get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_GATE_UPDATE() volatile
    {
        return STROBE_DLL_CTRL & (1u << 7u);
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_GATE_UPDATE bit.
     *
     * Strobe DLL control gate update
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_GATE_UPDATE() volatile
    {
        STROBE_DLL_CTRL |= 1u << 7u;
    }

    /**
     * Clear STROBE_DLL_CTRL's STROBE_DLL_CTRL_GATE_UPDATE bit.
     *
     * Strobe DLL control gate update
     */
    inline void clear_STROBE_DLL_CTRL_STROBE_DLL_CTRL_GATE_UPDATE() volatile
    {
        STROBE_DLL_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle STROBE_DLL_CTRL's STROBE_DLL_CTRL_GATE_UPDATE bit.
     *
     * Strobe DLL control gate update
     */
    inline void toggle_STROBE_DLL_CTRL_STROBE_DLL_CTRL_GATE_UPDATE() volatile
    {
        STROBE_DLL_CTRL ^= 1u << 7u;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_DLY_TARGET field.
     *
     * Strobe DLL Control Slave Delay Target
     */
    inline uint8_t
    get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_DLY_TARGET() volatile
    {
        return (STROBE_DLL_CTRL >> 3u) & 0b1111u;
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_DLY_TARGET field.
     *
     * Strobe DLL Control Slave Delay Target
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_DLY_TARGET(
        uint8_t value) volatile
    {
        uint32_t curr = STROBE_DLL_CTRL;

        curr &= ~(0b1111u << 3u);
        curr |= (value & 0b1111u) << 3u;

        STROBE_DLL_CTRL = curr;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * Strobe DLL control slave force updated
     */
    inline bool get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        return STROBE_DLL_CTRL & (1u << 2u);
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * Strobe DLL control slave force updated
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        STROBE_DLL_CTRL |= 1u << 2u;
    }

    /**
     * Clear STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * Strobe DLL control slave force updated
     */
    inline void clear_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        STROBE_DLL_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle STROBE_DLL_CTRL's STROBE_DLL_CTRL_SLV_FORCE_UPD bit.
     *
     * Strobe DLL control slave force updated
     */
    inline void toggle_STROBE_DLL_CTRL_STROBE_DLL_CTRL_SLV_FORCE_UPD() volatile
    {
        STROBE_DLL_CTRL ^= 1u << 2u;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_RESET bit.
     *
     * Strobe DLL control reset
     */
    inline bool get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_RESET() volatile
    {
        return STROBE_DLL_CTRL & (1u << 1u);
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_RESET bit.
     *
     * Strobe DLL control reset
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_RESET() volatile
    {
        STROBE_DLL_CTRL |= 1u << 1u;
    }

    /**
     * Clear STROBE_DLL_CTRL's STROBE_DLL_CTRL_RESET bit.
     *
     * Strobe DLL control reset
     */
    inline void clear_STROBE_DLL_CTRL_STROBE_DLL_CTRL_RESET() volatile
    {
        STROBE_DLL_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle STROBE_DLL_CTRL's STROBE_DLL_CTRL_RESET bit.
     *
     * Strobe DLL control reset
     */
    inline void toggle_STROBE_DLL_CTRL_STROBE_DLL_CTRL_RESET() volatile
    {
        STROBE_DLL_CTRL ^= 1u << 1u;
    }

    /**
     * Get STROBE_DLL_CTRL's STROBE_DLL_CTRL_ENABLE bit.
     *
     * Strobe DLL control enable
     */
    inline bool get_STROBE_DLL_CTRL_STROBE_DLL_CTRL_ENABLE() volatile
    {
        return STROBE_DLL_CTRL & (1u << 0u);
    }

    /**
     * Set STROBE_DLL_CTRL's STROBE_DLL_CTRL_ENABLE bit.
     *
     * Strobe DLL control enable
     */
    inline void set_STROBE_DLL_CTRL_STROBE_DLL_CTRL_ENABLE() volatile
    {
        STROBE_DLL_CTRL |= 1u << 0u;
    }

    /**
     * Clear STROBE_DLL_CTRL's STROBE_DLL_CTRL_ENABLE bit.
     *
     * Strobe DLL control enable
     */
    inline void clear_STROBE_DLL_CTRL_STROBE_DLL_CTRL_ENABLE() volatile
    {
        STROBE_DLL_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle STROBE_DLL_CTRL's STROBE_DLL_CTRL_ENABLE bit.
     *
     * Strobe DLL control enable
     */
    inline void toggle_STROBE_DLL_CTRL_STROBE_DLL_CTRL_ENABLE() volatile
    {
        STROBE_DLL_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of STROBE_DLL_CTRL's bit fields.
     *
     * (read-write) Strobe DLL control
     */
    inline void get_STROBE_DLL_CTRL(uint8_t &STROBE_DLL_CTRL_REF_UPDATE_INT,
                                    uint8_t &STROBE_DLL_CTRL_SLV_UPDATE_INT,
                                    uint8_t &STROBE_DLL_CTRL_SLV_OVERRIDE_VAL,
                                    bool &STROBE_DLL_CTRL_SLV_OVERRIDE,
                                    bool &STROBE_DLL_CTRL_GATE_UPDATE,
                                    uint8_t &STROBE_DLL_CTRL_SLV_DLY_TARGET,
                                    bool &STROBE_DLL_CTRL_SLV_FORCE_UPD,
                                    bool &STROBE_DLL_CTRL_RESET,
                                    bool &STROBE_DLL_CTRL_ENABLE) volatile
    {
        uint32_t curr = STROBE_DLL_CTRL;

        STROBE_DLL_CTRL_REF_UPDATE_INT = (curr >> 28u) & 0b1111u;
        STROBE_DLL_CTRL_SLV_UPDATE_INT = (curr >> 20u) & 0b11111111u;
        STROBE_DLL_CTRL_SLV_OVERRIDE_VAL = (curr >> 9u) & 0b1111111u;
        STROBE_DLL_CTRL_SLV_OVERRIDE = curr & (1u << 8u);
        STROBE_DLL_CTRL_GATE_UPDATE = curr & (1u << 7u);
        STROBE_DLL_CTRL_SLV_DLY_TARGET = (curr >> 3u) & 0b1111u;
        STROBE_DLL_CTRL_SLV_FORCE_UPD = curr & (1u << 2u);
        STROBE_DLL_CTRL_RESET = curr & (1u << 1u);
        STROBE_DLL_CTRL_ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of STROBE_DLL_CTRL's bit fields.
     *
     * (read-write) Strobe DLL control
     */
    inline void set_STROBE_DLL_CTRL(uint8_t STROBE_DLL_CTRL_REF_UPDATE_INT,
                                    uint8_t STROBE_DLL_CTRL_SLV_UPDATE_INT,
                                    uint8_t STROBE_DLL_CTRL_SLV_OVERRIDE_VAL,
                                    bool STROBE_DLL_CTRL_SLV_OVERRIDE,
                                    bool STROBE_DLL_CTRL_GATE_UPDATE,
                                    uint8_t STROBE_DLL_CTRL_SLV_DLY_TARGET,
                                    bool STROBE_DLL_CTRL_SLV_FORCE_UPD,
                                    bool STROBE_DLL_CTRL_RESET,
                                    bool STROBE_DLL_CTRL_ENABLE) volatile
    {
        uint32_t curr = STROBE_DLL_CTRL;

        curr &= ~(0b1111u << 28u);
        curr |= (STROBE_DLL_CTRL_REF_UPDATE_INT & 0b1111u) << 28u;
        curr &= ~(0b11111111u << 20u);
        curr |= (STROBE_DLL_CTRL_SLV_UPDATE_INT & 0b11111111u) << 20u;
        curr &= ~(0b1111111u << 9u);
        curr |= (STROBE_DLL_CTRL_SLV_OVERRIDE_VAL & 0b1111111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (STROBE_DLL_CTRL_SLV_OVERRIDE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (STROBE_DLL_CTRL_GATE_UPDATE & 0b1u) << 7u;
        curr &= ~(0b1111u << 3u);
        curr |= (STROBE_DLL_CTRL_SLV_DLY_TARGET & 0b1111u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (STROBE_DLL_CTRL_SLV_FORCE_UPD & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (STROBE_DLL_CTRL_RESET & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (STROBE_DLL_CTRL_ENABLE & 0b1u) << 0u;

        STROBE_DLL_CTRL = curr;
    }

    /**
     * Get STROBE_DLL_STATUS's STROBE_DLL_STS_REF_SEL field.
     *
     * Strobe DLL status reference select
     */
    inline uint8_t get_STROBE_DLL_STATUS_STROBE_DLL_STS_REF_SEL() volatile
    {
        return (STROBE_DLL_STATUS >> 9u) & 0b1111111u;
    }

    /**
     * Get STROBE_DLL_STATUS's STROBE_DLL_STS_SLV_SEL field.
     *
     * Strobe DLL status slave select
     */
    inline uint8_t get_STROBE_DLL_STATUS_STROBE_DLL_STS_SLV_SEL() volatile
    {
        return (STROBE_DLL_STATUS >> 2u) & 0b1111111u;
    }

    /**
     * Get STROBE_DLL_STATUS's STROBE_DLL_STS_REF_LOCK bit.
     *
     * Strobe DLL status reference lock
     */
    inline bool get_STROBE_DLL_STATUS_STROBE_DLL_STS_REF_LOCK() volatile
    {
        return STROBE_DLL_STATUS & (1u << 1u);
    }

    /**
     * Get STROBE_DLL_STATUS's STROBE_DLL_STS_SLV_LOCK bit.
     *
     * Strobe DLL status slave lock
     */
    inline bool get_STROBE_DLL_STATUS_STROBE_DLL_STS_SLV_LOCK() volatile
    {
        return STROBE_DLL_STATUS & (1u << 0u);
    }

    /**
     * Get all of STROBE_DLL_STATUS's bit fields.
     *
     * (read-write) Strobe DLL status
     */
    inline void get_STROBE_DLL_STATUS(uint8_t &STROBE_DLL_STS_REF_SEL,
                                      uint8_t &STROBE_DLL_STS_SLV_SEL,
                                      bool &STROBE_DLL_STS_REF_LOCK,
                                      bool &STROBE_DLL_STS_SLV_LOCK) volatile
    {
        uint32_t curr = STROBE_DLL_STATUS;

        STROBE_DLL_STS_REF_SEL = (curr >> 9u) & 0b1111111u;
        STROBE_DLL_STS_SLV_SEL = (curr >> 2u) & 0b1111111u;
        STROBE_DLL_STS_REF_LOCK = curr & (1u << 1u);
        STROBE_DLL_STS_SLV_LOCK = curr & (1u << 0u);
    }

    /**
     * Get VEND_SPEC's CMD_BYTE_EN bit.
     *
     * Byte access
     */
    inline bool get_VEND_SPEC_CMD_BYTE_EN() volatile
    {
        return VEND_SPEC & (1u << 31u);
    }

    /**
     * Set VEND_SPEC's CMD_BYTE_EN bit.
     *
     * Byte access
     */
    inline void set_VEND_SPEC_CMD_BYTE_EN() volatile
    {
        VEND_SPEC |= 1u << 31u;
    }

    /**
     * Clear VEND_SPEC's CMD_BYTE_EN bit.
     *
     * Byte access
     */
    inline void clear_VEND_SPEC_CMD_BYTE_EN() volatile
    {
        VEND_SPEC &= ~(1u << 31u);
    }

    /**
     * Toggle VEND_SPEC's CMD_BYTE_EN bit.
     *
     * Byte access
     */
    inline void toggle_VEND_SPEC_CMD_BYTE_EN() volatile
    {
        VEND_SPEC ^= 1u << 31u;
    }

    /**
     * Get VEND_SPEC's CRC_CHK_DIS bit.
     *
     * CRC Check Disable
     */
    inline bool get_VEND_SPEC_CRC_CHK_DIS() volatile
    {
        return VEND_SPEC & (1u << 15u);
    }

    /**
     * Set VEND_SPEC's CRC_CHK_DIS bit.
     *
     * CRC Check Disable
     */
    inline void set_VEND_SPEC_CRC_CHK_DIS() volatile
    {
        VEND_SPEC |= 1u << 15u;
    }

    /**
     * Clear VEND_SPEC's CRC_CHK_DIS bit.
     *
     * CRC Check Disable
     */
    inline void clear_VEND_SPEC_CRC_CHK_DIS() volatile
    {
        VEND_SPEC &= ~(1u << 15u);
    }

    /**
     * Toggle VEND_SPEC's CRC_CHK_DIS bit.
     *
     * CRC Check Disable
     */
    inline void toggle_VEND_SPEC_CRC_CHK_DIS() volatile
    {
        VEND_SPEC ^= 1u << 15u;
    }

    /**
     * Get VEND_SPEC's FRC_SDCLK_ON bit.
     *
     * Force CLK
     */
    inline bool get_VEND_SPEC_FRC_SDCLK_ON() volatile
    {
        return VEND_SPEC & (1u << 8u);
    }

    /**
     * Set VEND_SPEC's FRC_SDCLK_ON bit.
     *
     * Force CLK
     */
    inline void set_VEND_SPEC_FRC_SDCLK_ON() volatile
    {
        VEND_SPEC |= 1u << 8u;
    }

    /**
     * Clear VEND_SPEC's FRC_SDCLK_ON bit.
     *
     * Force CLK
     */
    inline void clear_VEND_SPEC_FRC_SDCLK_ON() volatile
    {
        VEND_SPEC &= ~(1u << 8u);
    }

    /**
     * Toggle VEND_SPEC's FRC_SDCLK_ON bit.
     *
     * Force CLK
     */
    inline void toggle_VEND_SPEC_FRC_SDCLK_ON() volatile
    {
        VEND_SPEC ^= 1u << 8u;
    }

    /**
     * Get VEND_SPEC's AC12_WR_CHKBUSY_EN bit.
     *
     * Check busy enable
     */
    inline bool get_VEND_SPEC_AC12_WR_CHKBUSY_EN() volatile
    {
        return VEND_SPEC & (1u << 3u);
    }

    /**
     * Set VEND_SPEC's AC12_WR_CHKBUSY_EN bit.
     *
     * Check busy enable
     */
    inline void set_VEND_SPEC_AC12_WR_CHKBUSY_EN() volatile
    {
        VEND_SPEC |= 1u << 3u;
    }

    /**
     * Clear VEND_SPEC's AC12_WR_CHKBUSY_EN bit.
     *
     * Check busy enable
     */
    inline void clear_VEND_SPEC_AC12_WR_CHKBUSY_EN() volatile
    {
        VEND_SPEC &= ~(1u << 3u);
    }

    /**
     * Toggle VEND_SPEC's AC12_WR_CHKBUSY_EN bit.
     *
     * Check busy enable
     */
    inline void toggle_VEND_SPEC_AC12_WR_CHKBUSY_EN() volatile
    {
        VEND_SPEC ^= 1u << 3u;
    }

    /**
     * Get VEND_SPEC's CONFLICT_CHK_EN bit.
     *
     * Conflict check enable
     */
    inline bool get_VEND_SPEC_CONFLICT_CHK_EN() volatile
    {
        return VEND_SPEC & (1u << 2u);
    }

    /**
     * Set VEND_SPEC's CONFLICT_CHK_EN bit.
     *
     * Conflict check enable
     */
    inline void set_VEND_SPEC_CONFLICT_CHK_EN() volatile
    {
        VEND_SPEC |= 1u << 2u;
    }

    /**
     * Clear VEND_SPEC's CONFLICT_CHK_EN bit.
     *
     * Conflict check enable
     */
    inline void clear_VEND_SPEC_CONFLICT_CHK_EN() volatile
    {
        VEND_SPEC &= ~(1u << 2u);
    }

    /**
     * Toggle VEND_SPEC's CONFLICT_CHK_EN bit.
     *
     * Conflict check enable
     */
    inline void toggle_VEND_SPEC_CONFLICT_CHK_EN() volatile
    {
        VEND_SPEC ^= 1u << 2u;
    }

    /**
     * Get VEND_SPEC's VSELECT bit.
     *
     * Voltage selection
     */
    inline bool get_VEND_SPEC_VSELECT() volatile
    {
        return VEND_SPEC & (1u << 1u);
    }

    /**
     * Set VEND_SPEC's VSELECT bit.
     *
     * Voltage selection
     */
    inline void set_VEND_SPEC_VSELECT() volatile
    {
        VEND_SPEC |= 1u << 1u;
    }

    /**
     * Clear VEND_SPEC's VSELECT bit.
     *
     * Voltage selection
     */
    inline void clear_VEND_SPEC_VSELECT() volatile
    {
        VEND_SPEC &= ~(1u << 1u);
    }

    /**
     * Toggle VEND_SPEC's VSELECT bit.
     *
     * Voltage selection
     */
    inline void toggle_VEND_SPEC_VSELECT() volatile
    {
        VEND_SPEC ^= 1u << 1u;
    }

    /**
     * Get all of VEND_SPEC's bit fields.
     *
     * (read-write) Vendor Specific Register
     */
    inline void get_VEND_SPEC(bool &CMD_BYTE_EN, bool &CRC_CHK_DIS,
                              bool &FRC_SDCLK_ON, bool &AC12_WR_CHKBUSY_EN,
                              bool &CONFLICT_CHK_EN, bool &VSELECT) volatile
    {
        uint32_t curr = VEND_SPEC;

        CMD_BYTE_EN = curr & (1u << 31u);
        CRC_CHK_DIS = curr & (1u << 15u);
        FRC_SDCLK_ON = curr & (1u << 8u);
        AC12_WR_CHKBUSY_EN = curr & (1u << 3u);
        CONFLICT_CHK_EN = curr & (1u << 2u);
        VSELECT = curr & (1u << 1u);
    }

    /**
     * Set all of VEND_SPEC's bit fields.
     *
     * (read-write) Vendor Specific Register
     */
    inline void set_VEND_SPEC(bool CMD_BYTE_EN, bool CRC_CHK_DIS,
                              bool FRC_SDCLK_ON, bool AC12_WR_CHKBUSY_EN,
                              bool CONFLICT_CHK_EN, bool VSELECT) volatile
    {
        uint32_t curr = VEND_SPEC;

        curr &= ~(0b1u << 31u);
        curr |= (CMD_BYTE_EN & 0b1u) << 31u;
        curr &= ~(0b1u << 15u);
        curr |= (CRC_CHK_DIS & 0b1u) << 15u;
        curr &= ~(0b1u << 8u);
        curr |= (FRC_SDCLK_ON & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (AC12_WR_CHKBUSY_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (CONFLICT_CHK_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (VSELECT & 0b1u) << 1u;

        VEND_SPEC = curr;
    }

    /**
     * Get MMC_BOOT's BOOT_BLK_CNT field.
     *
     * Stop At Block Gap value of automatic mode
     */
    inline uint16_t get_MMC_BOOT_BOOT_BLK_CNT() volatile
    {
        return (MMC_BOOT >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MMC_BOOT's BOOT_BLK_CNT field.
     *
     * Stop At Block Gap value of automatic mode
     */
    inline void set_MMC_BOOT_BOOT_BLK_CNT(uint16_t value) volatile
    {
        uint32_t curr = MMC_BOOT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MMC_BOOT = curr;
    }

    /**
     * Get MMC_BOOT's DISABLE_TIME_OUT bit.
     *
     * Time out
     */
    inline bool get_MMC_BOOT_DISABLE_TIME_OUT() volatile
    {
        return MMC_BOOT & (1u << 8u);
    }

    /**
     * Set MMC_BOOT's DISABLE_TIME_OUT bit.
     *
     * Time out
     */
    inline void set_MMC_BOOT_DISABLE_TIME_OUT() volatile
    {
        MMC_BOOT |= 1u << 8u;
    }

    /**
     * Clear MMC_BOOT's DISABLE_TIME_OUT bit.
     *
     * Time out
     */
    inline void clear_MMC_BOOT_DISABLE_TIME_OUT() volatile
    {
        MMC_BOOT &= ~(1u << 8u);
    }

    /**
     * Toggle MMC_BOOT's DISABLE_TIME_OUT bit.
     *
     * Time out
     */
    inline void toggle_MMC_BOOT_DISABLE_TIME_OUT() volatile
    {
        MMC_BOOT ^= 1u << 8u;
    }

    /**
     * Get MMC_BOOT's AUTO_SABG_EN bit.
     *
     * Auto stop at block gap
     */
    inline bool get_MMC_BOOT_AUTO_SABG_EN() volatile
    {
        return MMC_BOOT & (1u << 7u);
    }

    /**
     * Set MMC_BOOT's AUTO_SABG_EN bit.
     *
     * Auto stop at block gap
     */
    inline void set_MMC_BOOT_AUTO_SABG_EN() volatile
    {
        MMC_BOOT |= 1u << 7u;
    }

    /**
     * Clear MMC_BOOT's AUTO_SABG_EN bit.
     *
     * Auto stop at block gap
     */
    inline void clear_MMC_BOOT_AUTO_SABG_EN() volatile
    {
        MMC_BOOT &= ~(1u << 7u);
    }

    /**
     * Toggle MMC_BOOT's AUTO_SABG_EN bit.
     *
     * Auto stop at block gap
     */
    inline void toggle_MMC_BOOT_AUTO_SABG_EN() volatile
    {
        MMC_BOOT ^= 1u << 7u;
    }

    /**
     * Get MMC_BOOT's BOOT_EN bit.
     *
     * Boot enable
     */
    inline bool get_MMC_BOOT_BOOT_EN() volatile
    {
        return MMC_BOOT & (1u << 6u);
    }

    /**
     * Set MMC_BOOT's BOOT_EN bit.
     *
     * Boot enable
     */
    inline void set_MMC_BOOT_BOOT_EN() volatile
    {
        MMC_BOOT |= 1u << 6u;
    }

    /**
     * Clear MMC_BOOT's BOOT_EN bit.
     *
     * Boot enable
     */
    inline void clear_MMC_BOOT_BOOT_EN() volatile
    {
        MMC_BOOT &= ~(1u << 6u);
    }

    /**
     * Toggle MMC_BOOT's BOOT_EN bit.
     *
     * Boot enable
     */
    inline void toggle_MMC_BOOT_BOOT_EN() volatile
    {
        MMC_BOOT ^= 1u << 6u;
    }

    /**
     * Get MMC_BOOT's BOOT_MODE bit.
     *
     * Boot mode
     */
    inline bool get_MMC_BOOT_BOOT_MODE() volatile
    {
        return MMC_BOOT & (1u << 5u);
    }

    /**
     * Set MMC_BOOT's BOOT_MODE bit.
     *
     * Boot mode
     */
    inline void set_MMC_BOOT_BOOT_MODE() volatile
    {
        MMC_BOOT |= 1u << 5u;
    }

    /**
     * Clear MMC_BOOT's BOOT_MODE bit.
     *
     * Boot mode
     */
    inline void clear_MMC_BOOT_BOOT_MODE() volatile
    {
        MMC_BOOT &= ~(1u << 5u);
    }

    /**
     * Toggle MMC_BOOT's BOOT_MODE bit.
     *
     * Boot mode
     */
    inline void toggle_MMC_BOOT_BOOT_MODE() volatile
    {
        MMC_BOOT ^= 1u << 5u;
    }

    /**
     * Get MMC_BOOT's BOOT_ACK bit.
     *
     * BOOT ACK
     */
    inline bool get_MMC_BOOT_BOOT_ACK() volatile
    {
        return MMC_BOOT & (1u << 4u);
    }

    /**
     * Set MMC_BOOT's BOOT_ACK bit.
     *
     * BOOT ACK
     */
    inline void set_MMC_BOOT_BOOT_ACK() volatile
    {
        MMC_BOOT |= 1u << 4u;
    }

    /**
     * Clear MMC_BOOT's BOOT_ACK bit.
     *
     * BOOT ACK
     */
    inline void clear_MMC_BOOT_BOOT_ACK() volatile
    {
        MMC_BOOT &= ~(1u << 4u);
    }

    /**
     * Toggle MMC_BOOT's BOOT_ACK bit.
     *
     * BOOT ACK
     */
    inline void toggle_MMC_BOOT_BOOT_ACK() volatile
    {
        MMC_BOOT ^= 1u << 4u;
    }

    /**
     * Get MMC_BOOT's DTOCV_ACK field.
     *
     * Boot ACK time out
     */
    inline USDHC1_MMC_BOOT_DTOCV_ACK get_MMC_BOOT_DTOCV_ACK() volatile
    {
        return USDHC1_MMC_BOOT_DTOCV_ACK((MMC_BOOT >> 0u) & 0b1111u);
    }

    /**
     * Set MMC_BOOT's DTOCV_ACK field.
     *
     * Boot ACK time out
     */
    inline void set_MMC_BOOT_DTOCV_ACK(
        USDHC1_MMC_BOOT_DTOCV_ACK value) volatile
    {
        uint32_t curr = MMC_BOOT;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        MMC_BOOT = curr;
    }

    /**
     * Get all of MMC_BOOT's bit fields.
     *
     * (read-write) MMC Boot
     */
    inline void get_MMC_BOOT(uint16_t &BOOT_BLK_CNT, bool &DISABLE_TIME_OUT,
                             bool &AUTO_SABG_EN, bool &BOOT_EN,
                             bool &BOOT_MODE, bool &BOOT_ACK,
                             USDHC1_MMC_BOOT_DTOCV_ACK &DTOCV_ACK) volatile
    {
        uint32_t curr = MMC_BOOT;

        BOOT_BLK_CNT = (curr >> 16u) & 0b1111111111111111u;
        DISABLE_TIME_OUT = curr & (1u << 8u);
        AUTO_SABG_EN = curr & (1u << 7u);
        BOOT_EN = curr & (1u << 6u);
        BOOT_MODE = curr & (1u << 5u);
        BOOT_ACK = curr & (1u << 4u);
        DTOCV_ACK = USDHC1_MMC_BOOT_DTOCV_ACK((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of MMC_BOOT's bit fields.
     *
     * (read-write) MMC Boot
     */
    inline void set_MMC_BOOT(uint16_t BOOT_BLK_CNT, bool DISABLE_TIME_OUT,
                             bool AUTO_SABG_EN, bool BOOT_EN, bool BOOT_MODE,
                             bool BOOT_ACK,
                             USDHC1_MMC_BOOT_DTOCV_ACK DTOCV_ACK) volatile
    {
        uint32_t curr = MMC_BOOT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (BOOT_BLK_CNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 8u);
        curr |= (DISABLE_TIME_OUT & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (AUTO_SABG_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (BOOT_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BOOT_MODE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BOOT_ACK & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(DTOCV_ACK) & 0b1111u) << 0u;

        MMC_BOOT = curr;
    }

    /**
     * Get VEND_SPEC2's ACMD23_ARGU2_EN bit.
     *
     * Argument2 register enable for ACMD23
     */
    inline bool get_VEND_SPEC2_ACMD23_ARGU2_EN() volatile
    {
        return VEND_SPEC2 & (1u << 12u);
    }

    /**
     * Set VEND_SPEC2's ACMD23_ARGU2_EN bit.
     *
     * Argument2 register enable for ACMD23
     */
    inline void set_VEND_SPEC2_ACMD23_ARGU2_EN() volatile
    {
        VEND_SPEC2 |= 1u << 12u;
    }

    /**
     * Clear VEND_SPEC2's ACMD23_ARGU2_EN bit.
     *
     * Argument2 register enable for ACMD23
     */
    inline void clear_VEND_SPEC2_ACMD23_ARGU2_EN() volatile
    {
        VEND_SPEC2 &= ~(1u << 12u);
    }

    /**
     * Toggle VEND_SPEC2's ACMD23_ARGU2_EN bit.
     *
     * Argument2 register enable for ACMD23
     */
    inline void toggle_VEND_SPEC2_ACMD23_ARGU2_EN() volatile
    {
        VEND_SPEC2 ^= 1u << 12u;
    }

    /**
     * Get VEND_SPEC2's HS400_RD_CLK_STOP_EN bit.
     *
     * HS400 read clock stop enable
     */
    inline bool get_VEND_SPEC2_HS400_RD_CLK_STOP_EN() volatile
    {
        return VEND_SPEC2 & (1u << 11u);
    }

    /**
     * Set VEND_SPEC2's HS400_RD_CLK_STOP_EN bit.
     *
     * HS400 read clock stop enable
     */
    inline void set_VEND_SPEC2_HS400_RD_CLK_STOP_EN() volatile
    {
        VEND_SPEC2 |= 1u << 11u;
    }

    /**
     * Clear VEND_SPEC2's HS400_RD_CLK_STOP_EN bit.
     *
     * HS400 read clock stop enable
     */
    inline void clear_VEND_SPEC2_HS400_RD_CLK_STOP_EN() volatile
    {
        VEND_SPEC2 &= ~(1u << 11u);
    }

    /**
     * Toggle VEND_SPEC2's HS400_RD_CLK_STOP_EN bit.
     *
     * HS400 read clock stop enable
     */
    inline void toggle_VEND_SPEC2_HS400_RD_CLK_STOP_EN() volatile
    {
        VEND_SPEC2 ^= 1u << 11u;
    }

    /**
     * Get VEND_SPEC2's HS400_WR_CLK_STOP_EN bit.
     *
     * HS400 write clock stop enable
     */
    inline bool get_VEND_SPEC2_HS400_WR_CLK_STOP_EN() volatile
    {
        return VEND_SPEC2 & (1u << 10u);
    }

    /**
     * Set VEND_SPEC2's HS400_WR_CLK_STOP_EN bit.
     *
     * HS400 write clock stop enable
     */
    inline void set_VEND_SPEC2_HS400_WR_CLK_STOP_EN() volatile
    {
        VEND_SPEC2 |= 1u << 10u;
    }

    /**
     * Clear VEND_SPEC2's HS400_WR_CLK_STOP_EN bit.
     *
     * HS400 write clock stop enable
     */
    inline void clear_VEND_SPEC2_HS400_WR_CLK_STOP_EN() volatile
    {
        VEND_SPEC2 &= ~(1u << 10u);
    }

    /**
     * Toggle VEND_SPEC2's HS400_WR_CLK_STOP_EN bit.
     *
     * HS400 write clock stop enable
     */
    inline void toggle_VEND_SPEC2_HS400_WR_CLK_STOP_EN() volatile
    {
        VEND_SPEC2 ^= 1u << 10u;
    }

    /**
     * Get VEND_SPEC2's TUNING_CMD_EN bit.
     *
     * Tuning command enable
     */
    inline bool get_VEND_SPEC2_TUNING_CMD_EN() volatile
    {
        return VEND_SPEC2 & (1u << 6u);
    }

    /**
     * Set VEND_SPEC2's TUNING_CMD_EN bit.
     *
     * Tuning command enable
     */
    inline void set_VEND_SPEC2_TUNING_CMD_EN() volatile
    {
        VEND_SPEC2 |= 1u << 6u;
    }

    /**
     * Clear VEND_SPEC2's TUNING_CMD_EN bit.
     *
     * Tuning command enable
     */
    inline void clear_VEND_SPEC2_TUNING_CMD_EN() volatile
    {
        VEND_SPEC2 &= ~(1u << 6u);
    }

    /**
     * Toggle VEND_SPEC2's TUNING_CMD_EN bit.
     *
     * Tuning command enable
     */
    inline void toggle_VEND_SPEC2_TUNING_CMD_EN() volatile
    {
        VEND_SPEC2 ^= 1u << 6u;
    }

    /**
     * Get VEND_SPEC2's TUNING_1bit_EN bit.
     *
     * Tuning 1bit enable
     */
    inline bool get_VEND_SPEC2_TUNING_1bit_EN() volatile
    {
        return VEND_SPEC2 & (1u << 5u);
    }

    /**
     * Set VEND_SPEC2's TUNING_1bit_EN bit.
     *
     * Tuning 1bit enable
     */
    inline void set_VEND_SPEC2_TUNING_1bit_EN() volatile
    {
        VEND_SPEC2 |= 1u << 5u;
    }

    /**
     * Clear VEND_SPEC2's TUNING_1bit_EN bit.
     *
     * Tuning 1bit enable
     */
    inline void clear_VEND_SPEC2_TUNING_1bit_EN() volatile
    {
        VEND_SPEC2 &= ~(1u << 5u);
    }

    /**
     * Toggle VEND_SPEC2's TUNING_1bit_EN bit.
     *
     * Tuning 1bit enable
     */
    inline void toggle_VEND_SPEC2_TUNING_1bit_EN() volatile
    {
        VEND_SPEC2 ^= 1u << 5u;
    }

    /**
     * Get VEND_SPEC2's TUNING_8bit_EN bit.
     *
     * Tuning 8bit enable
     */
    inline bool get_VEND_SPEC2_TUNING_8bit_EN() volatile
    {
        return VEND_SPEC2 & (1u << 4u);
    }

    /**
     * Set VEND_SPEC2's TUNING_8bit_EN bit.
     *
     * Tuning 8bit enable
     */
    inline void set_VEND_SPEC2_TUNING_8bit_EN() volatile
    {
        VEND_SPEC2 |= 1u << 4u;
    }

    /**
     * Clear VEND_SPEC2's TUNING_8bit_EN bit.
     *
     * Tuning 8bit enable
     */
    inline void clear_VEND_SPEC2_TUNING_8bit_EN() volatile
    {
        VEND_SPEC2 &= ~(1u << 4u);
    }

    /**
     * Toggle VEND_SPEC2's TUNING_8bit_EN bit.
     *
     * Tuning 8bit enable
     */
    inline void toggle_VEND_SPEC2_TUNING_8bit_EN() volatile
    {
        VEND_SPEC2 ^= 1u << 4u;
    }

    /**
     * Get VEND_SPEC2's CARD_INT_D3_TEST bit.
     *
     * Card interrupt detection test
     */
    inline bool get_VEND_SPEC2_CARD_INT_D3_TEST() volatile
    {
        return VEND_SPEC2 & (1u << 3u);
    }

    /**
     * Set VEND_SPEC2's CARD_INT_D3_TEST bit.
     *
     * Card interrupt detection test
     */
    inline void set_VEND_SPEC2_CARD_INT_D3_TEST() volatile
    {
        VEND_SPEC2 |= 1u << 3u;
    }

    /**
     * Clear VEND_SPEC2's CARD_INT_D3_TEST bit.
     *
     * Card interrupt detection test
     */
    inline void clear_VEND_SPEC2_CARD_INT_D3_TEST() volatile
    {
        VEND_SPEC2 &= ~(1u << 3u);
    }

    /**
     * Toggle VEND_SPEC2's CARD_INT_D3_TEST bit.
     *
     * Card interrupt detection test
     */
    inline void toggle_VEND_SPEC2_CARD_INT_D3_TEST() volatile
    {
        VEND_SPEC2 ^= 1u << 3u;
    }

    /**
     * Get all of VEND_SPEC2's bit fields.
     *
     * (read-write) Vendor Specific 2 Register
     */
    inline void get_VEND_SPEC2(bool &ACMD23_ARGU2_EN,
                               bool &HS400_RD_CLK_STOP_EN,
                               bool &HS400_WR_CLK_STOP_EN, bool &TUNING_CMD_EN,
                               bool &TUNING_1bit_EN, bool &TUNING_8bit_EN,
                               bool &CARD_INT_D3_TEST) volatile
    {
        uint32_t curr = VEND_SPEC2;

        ACMD23_ARGU2_EN = curr & (1u << 12u);
        HS400_RD_CLK_STOP_EN = curr & (1u << 11u);
        HS400_WR_CLK_STOP_EN = curr & (1u << 10u);
        TUNING_CMD_EN = curr & (1u << 6u);
        TUNING_1bit_EN = curr & (1u << 5u);
        TUNING_8bit_EN = curr & (1u << 4u);
        CARD_INT_D3_TEST = curr & (1u << 3u);
    }

    /**
     * Set all of VEND_SPEC2's bit fields.
     *
     * (read-write) Vendor Specific 2 Register
     */
    inline void set_VEND_SPEC2(bool ACMD23_ARGU2_EN, bool HS400_RD_CLK_STOP_EN,
                               bool HS400_WR_CLK_STOP_EN, bool TUNING_CMD_EN,
                               bool TUNING_1bit_EN, bool TUNING_8bit_EN,
                               bool CARD_INT_D3_TEST) volatile
    {
        uint32_t curr = VEND_SPEC2;

        curr &= ~(0b1u << 12u);
        curr |= (ACMD23_ARGU2_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (HS400_RD_CLK_STOP_EN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (HS400_WR_CLK_STOP_EN & 0b1u) << 10u;
        curr &= ~(0b1u << 6u);
        curr |= (TUNING_CMD_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TUNING_1bit_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TUNING_8bit_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CARD_INT_D3_TEST & 0b1u) << 3u;

        VEND_SPEC2 = curr;
    }

    /**
     * Get TUNING_CTRL's STD_TUNING_EN bit.
     *
     * Standard tuning circuit and procedure enable
     */
    inline bool get_TUNING_CTRL_STD_TUNING_EN() volatile
    {
        return TUNING_CTRL & (1u << 24u);
    }

    /**
     * Set TUNING_CTRL's STD_TUNING_EN bit.
     *
     * Standard tuning circuit and procedure enable
     */
    inline void set_TUNING_CTRL_STD_TUNING_EN() volatile
    {
        TUNING_CTRL |= 1u << 24u;
    }

    /**
     * Clear TUNING_CTRL's STD_TUNING_EN bit.
     *
     * Standard tuning circuit and procedure enable
     */
    inline void clear_TUNING_CTRL_STD_TUNING_EN() volatile
    {
        TUNING_CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle TUNING_CTRL's STD_TUNING_EN bit.
     *
     * Standard tuning circuit and procedure enable
     */
    inline void toggle_TUNING_CTRL_STD_TUNING_EN() volatile
    {
        TUNING_CTRL ^= 1u << 24u;
    }

    /**
     * Get TUNING_CTRL's TUNING_WINDOW field.
     *
     * Data window
     */
    inline uint8_t get_TUNING_CTRL_TUNING_WINDOW() volatile
    {
        return (TUNING_CTRL >> 20u) & 0b111u;
    }

    /**
     * Set TUNING_CTRL's TUNING_WINDOW field.
     *
     * Data window
     */
    inline void set_TUNING_CTRL_TUNING_WINDOW(uint8_t value) volatile
    {
        uint32_t curr = TUNING_CTRL;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        TUNING_CTRL = curr;
    }

    /**
     * Get TUNING_CTRL's TUNING_STEP field.
     *
     * TUNING_STEP
     */
    inline uint8_t get_TUNING_CTRL_TUNING_STEP() volatile
    {
        return (TUNING_CTRL >> 16u) & 0b111u;
    }

    /**
     * Set TUNING_CTRL's TUNING_STEP field.
     *
     * TUNING_STEP
     */
    inline void set_TUNING_CTRL_TUNING_STEP(uint8_t value) volatile
    {
        uint32_t curr = TUNING_CTRL;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        TUNING_CTRL = curr;
    }

    /**
     * Get TUNING_CTRL's TUNING_COUNTER field.
     *
     * Tuning counter
     */
    inline uint8_t get_TUNING_CTRL_TUNING_COUNTER() volatile
    {
        return (TUNING_CTRL >> 8u) & 0b11111111u;
    }

    /**
     * Set TUNING_CTRL's TUNING_COUNTER field.
     *
     * Tuning counter
     */
    inline void set_TUNING_CTRL_TUNING_COUNTER(uint8_t value) volatile
    {
        uint32_t curr = TUNING_CTRL;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        TUNING_CTRL = curr;
    }

    /**
     * Get TUNING_CTRL's DIS_CMD_CHK_FOR_STD_TUNING bit.
     *
     * Disable command check for standard tuning
     */
    inline bool get_TUNING_CTRL_DIS_CMD_CHK_FOR_STD_TUNING() volatile
    {
        return TUNING_CTRL & (1u << 7u);
    }

    /**
     * Set TUNING_CTRL's DIS_CMD_CHK_FOR_STD_TUNING bit.
     *
     * Disable command check for standard tuning
     */
    inline void set_TUNING_CTRL_DIS_CMD_CHK_FOR_STD_TUNING() volatile
    {
        TUNING_CTRL |= 1u << 7u;
    }

    /**
     * Clear TUNING_CTRL's DIS_CMD_CHK_FOR_STD_TUNING bit.
     *
     * Disable command check for standard tuning
     */
    inline void clear_TUNING_CTRL_DIS_CMD_CHK_FOR_STD_TUNING() volatile
    {
        TUNING_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle TUNING_CTRL's DIS_CMD_CHK_FOR_STD_TUNING bit.
     *
     * Disable command check for standard tuning
     */
    inline void toggle_TUNING_CTRL_DIS_CMD_CHK_FOR_STD_TUNING() volatile
    {
        TUNING_CTRL ^= 1u << 7u;
    }

    /**
     * Get TUNING_CTRL's TUNING_START_TAP field.
     *
     * Tuning start
     */
    inline uint8_t get_TUNING_CTRL_TUNING_START_TAP() volatile
    {
        return (TUNING_CTRL >> 0u) & 0b1111111u;
    }

    /**
     * Set TUNING_CTRL's TUNING_START_TAP field.
     *
     * Tuning start
     */
    inline void set_TUNING_CTRL_TUNING_START_TAP(uint8_t value) volatile
    {
        uint32_t curr = TUNING_CTRL;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        TUNING_CTRL = curr;
    }

    /**
     * Get all of TUNING_CTRL's bit fields.
     *
     * (read-write) Tuning Control
     */
    inline void get_TUNING_CTRL(bool &STD_TUNING_EN, uint8_t &TUNING_WINDOW,
                                uint8_t &TUNING_STEP, uint8_t &TUNING_COUNTER,
                                bool &DIS_CMD_CHK_FOR_STD_TUNING,
                                uint8_t &TUNING_START_TAP) volatile
    {
        uint32_t curr = TUNING_CTRL;

        STD_TUNING_EN = curr & (1u << 24u);
        TUNING_WINDOW = (curr >> 20u) & 0b111u;
        TUNING_STEP = (curr >> 16u) & 0b111u;
        TUNING_COUNTER = (curr >> 8u) & 0b11111111u;
        DIS_CMD_CHK_FOR_STD_TUNING = curr & (1u << 7u);
        TUNING_START_TAP = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of TUNING_CTRL's bit fields.
     *
     * (read-write) Tuning Control
     */
    inline void set_TUNING_CTRL(bool STD_TUNING_EN, uint8_t TUNING_WINDOW,
                                uint8_t TUNING_STEP, uint8_t TUNING_COUNTER,
                                bool DIS_CMD_CHK_FOR_STD_TUNING,
                                uint8_t TUNING_START_TAP) volatile
    {
        uint32_t curr = TUNING_CTRL;

        curr &= ~(0b1u << 24u);
        curr |= (STD_TUNING_EN & 0b1u) << 24u;
        curr &= ~(0b111u << 20u);
        curr |= (TUNING_WINDOW & 0b111u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (TUNING_STEP & 0b111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (TUNING_COUNTER & 0b11111111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (DIS_CMD_CHK_FOR_STD_TUNING & 0b1u) << 7u;
        curr &= ~(0b1111111u << 0u);
        curr |= (TUNING_START_TAP & 0b1111111u) << 0u;

        TUNING_CTRL = curr;
    }
};

static_assert(sizeof(usdhc1) == usdhc1::size);

static volatile usdhc1 *const USDHC1 = reinterpret_cast<usdhc1 *>(0x40418000);

static volatile usdhc1 *const USDHC2 = reinterpret_cast<usdhc1 *>(0x4041C000);

}; // namespace MIMXRT1176::CM7
