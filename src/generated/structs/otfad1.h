/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/OTFAD1_SR_MODE.h"
#include "../ifgen/common.h"
#include "CTX_instance.h"

namespace MIMXRT1176::CM7
{

/**
 * OTFAD
 */
struct [[gnu::packed]] otfad1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 3208; /*!< otfad1's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 768;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t CR; /*!< (read-write) Control Register */
    uint32_t SR; /*!< (read-write) Status Register */
    static constexpr std::size_t CTX_length = 4;
    CTX_instance CTX[CTX_length]; /*!< no description available */

    /* Methods. */

    /**
     * Get CR's GE bit.
     *
     * Global OTFAD Enable
     */
    inline bool get_CR_GE() volatile
    {
        return CR & (1u << 31u);
    }

    /**
     * Set CR's GE bit.
     *
     * Global OTFAD Enable
     */
    inline void set_CR_GE() volatile
    {
        CR |= 1u << 31u;
    }

    /**
     * Clear CR's GE bit.
     *
     * Global OTFAD Enable
     */
    inline void clear_CR_GE() volatile
    {
        CR &= ~(1u << 31u);
    }

    /**
     * Toggle CR's GE bit.
     *
     * Global OTFAD Enable
     */
    inline void toggle_CR_GE() volatile
    {
        CR ^= 1u << 31u;
    }

    /**
     * Get CR's SKBP bit.
     *
     * Start key blob processing
     */
    inline bool get_CR_SKBP() volatile
    {
        return CR & (1u << 30u);
    }

    /**
     * Set CR's SKBP bit.
     *
     * Start key blob processing
     */
    inline void set_CR_SKBP() volatile
    {
        CR |= 1u << 30u;
    }

    /**
     * Clear CR's SKBP bit.
     *
     * Start key blob processing
     */
    inline void clear_CR_SKBP() volatile
    {
        CR &= ~(1u << 30u);
    }

    /**
     * Toggle CR's SKBP bit.
     *
     * Start key blob processing
     */
    inline void toggle_CR_SKBP() volatile
    {
        CR ^= 1u << 30u;
    }

    /**
     * Get CR's RRAE bit.
     *
     * Restricted Register Access Enable
     */
    inline bool get_CR_RRAE() volatile
    {
        return CR & (1u << 7u);
    }

    /**
     * Set CR's RRAE bit.
     *
     * Restricted Register Access Enable
     */
    inline void set_CR_RRAE() volatile
    {
        CR |= 1u << 7u;
    }

    /**
     * Clear CR's RRAE bit.
     *
     * Restricted Register Access Enable
     */
    inline void clear_CR_RRAE() volatile
    {
        CR &= ~(1u << 7u);
    }

    /**
     * Toggle CR's RRAE bit.
     *
     * Restricted Register Access Enable
     */
    inline void toggle_CR_RRAE() volatile
    {
        CR ^= 1u << 7u;
    }

    /**
     * Get CR's KBPE bit.
     *
     * Key Blob Processing Enable
     */
    inline bool get_CR_KBPE() volatile
    {
        return CR & (1u << 5u);
    }

    /**
     * Set CR's KBPE bit.
     *
     * Key Blob Processing Enable
     */
    inline void set_CR_KBPE() volatile
    {
        CR |= 1u << 5u;
    }

    /**
     * Clear CR's KBPE bit.
     *
     * Key Blob Processing Enable
     */
    inline void clear_CR_KBPE() volatile
    {
        CR &= ~(1u << 5u);
    }

    /**
     * Toggle CR's KBPE bit.
     *
     * Key Blob Processing Enable
     */
    inline void toggle_CR_KBPE() volatile
    {
        CR ^= 1u << 5u;
    }

    /**
     * Get CR's KBSE bit.
     *
     * Key Blob Scramble Enable
     */
    inline bool get_CR_KBSE() volatile
    {
        return CR & (1u << 4u);
    }

    /**
     * Set CR's KBSE bit.
     *
     * Key Blob Scramble Enable
     */
    inline void set_CR_KBSE() volatile
    {
        CR |= 1u << 4u;
    }

    /**
     * Clear CR's KBSE bit.
     *
     * Key Blob Scramble Enable
     */
    inline void clear_CR_KBSE() volatile
    {
        CR &= ~(1u << 4u);
    }

    /**
     * Toggle CR's KBSE bit.
     *
     * Key Blob Scramble Enable
     */
    inline void toggle_CR_KBSE() volatile
    {
        CR ^= 1u << 4u;
    }

    /**
     * Get CR's FLDM bit.
     *
     * Force Logically Disabled Mode
     */
    inline bool get_CR_FLDM() volatile
    {
        return CR & (1u << 3u);
    }

    /**
     * Set CR's FLDM bit.
     *
     * Force Logically Disabled Mode
     */
    inline void set_CR_FLDM() volatile
    {
        CR |= 1u << 3u;
    }

    /**
     * Clear CR's FLDM bit.
     *
     * Force Logically Disabled Mode
     */
    inline void clear_CR_FLDM() volatile
    {
        CR &= ~(1u << 3u);
    }

    /**
     * Toggle CR's FLDM bit.
     *
     * Force Logically Disabled Mode
     */
    inline void toggle_CR_FLDM() volatile
    {
        CR ^= 1u << 3u;
    }

    /**
     * Get CR's FERR bit.
     *
     * Force Error
     */
    inline bool get_CR_FERR() volatile
    {
        return CR & (1u << 1u);
    }

    /**
     * Set CR's FERR bit.
     *
     * Force Error
     */
    inline void set_CR_FERR() volatile
    {
        CR |= 1u << 1u;
    }

    /**
     * Clear CR's FERR bit.
     *
     * Force Error
     */
    inline void clear_CR_FERR() volatile
    {
        CR &= ~(1u << 1u);
    }

    /**
     * Toggle CR's FERR bit.
     *
     * Force Error
     */
    inline void toggle_CR_FERR() volatile
    {
        CR ^= 1u << 1u;
    }

    /**
     * Get all of CR's bit fields.
     *
     * (read-write) Control Register
     */
    inline void get_CR(bool &GE, bool &SKBP, bool &RRAE, bool &KBPE,
                       bool &KBSE, bool &FLDM, bool &FERR) volatile
    {
        uint32_t curr = CR;

        GE = curr & (1u << 31u);
        SKBP = curr & (1u << 30u);
        RRAE = curr & (1u << 7u);
        KBPE = curr & (1u << 5u);
        KBSE = curr & (1u << 4u);
        FLDM = curr & (1u << 3u);
        FERR = curr & (1u << 1u);
    }

    /**
     * Set all of CR's bit fields.
     *
     * (read-write) Control Register
     */
    inline void set_CR(bool GE, bool SKBP, bool RRAE, bool KBPE, bool KBSE,
                       bool FLDM, bool FERR) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b1u << 31u);
        curr |= (GE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SKBP & 0b1u) << 30u;
        curr &= ~(0b1u << 7u);
        curr |= (RRAE & 0b1u) << 7u;
        curr &= ~(0b1u << 5u);
        curr |= (KBPE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (KBSE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FLDM & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (FERR & 0b1u) << 1u;

        CR = curr;
    }

    /**
     * Get SR's KBD bit.
     *
     * Key Blob Processing Done
     */
    inline bool get_SR_KBD() volatile
    {
        return SR & (1u << 31u);
    }

    /**
     * Get SR's KBPE bit.
     *
     * Key Blob Processing Enable
     */
    inline bool get_SR_KBPE() volatile
    {
        return SR & (1u << 30u);
    }

    /**
     * Get SR's GEM bit.
     *
     * Global Enable Mode
     */
    inline bool get_SR_GEM() volatile
    {
        return SR & (1u << 29u);
    }

    /**
     * Get SR's RRAM bit.
     *
     * Restricted Register Access Mode
     */
    inline bool get_SR_RRAM() volatile
    {
        return SR & (1u << 28u);
    }

    /**
     * Get SR's HRL field.
     *
     * Hardware Revision Level
     */
    inline uint8_t get_SR_HRL() volatile
    {
        return (SR >> 24u) & 0b1111u;
    }

    /**
     * Get SR's CTXIE3 bit.
     *
     * Context Integrity Error
     */
    inline bool get_SR_CTXIE3() volatile
    {
        return SR & (1u << 19u);
    }

    /**
     * Get SR's CTXIE2 bit.
     *
     * Context Integrity Error
     */
    inline bool get_SR_CTXIE2() volatile
    {
        return SR & (1u << 18u);
    }

    /**
     * Get SR's CTXIE1 bit.
     *
     * Context Integrity Error
     */
    inline bool get_SR_CTXIE1() volatile
    {
        return SR & (1u << 17u);
    }

    /**
     * Get SR's CTXIE0 bit.
     *
     * Context Integrity Error
     */
    inline bool get_SR_CTXIE0() volatile
    {
        return SR & (1u << 16u);
    }

    /**
     * Get SR's CTXER3 bit.
     *
     * Context Error
     */
    inline bool get_SR_CTXER3() volatile
    {
        return SR & (1u << 11u);
    }

    /**
     * Get SR's CTXER2 bit.
     *
     * Context Error
     */
    inline bool get_SR_CTXER2() volatile
    {
        return SR & (1u << 10u);
    }

    /**
     * Get SR's CTXER1 bit.
     *
     * Context Error
     */
    inline bool get_SR_CTXER1() volatile
    {
        return SR & (1u << 9u);
    }

    /**
     * Get SR's CTXER0 bit.
     *
     * Context Error
     */
    inline bool get_SR_CTXER0() volatile
    {
        return SR & (1u << 8u);
    }

    /**
     * Get SR's NCTX field.
     *
     * Number of Contexts
     */
    inline uint8_t get_SR_NCTX() volatile
    {
        return (SR >> 4u) & 0b1111u;
    }

    /**
     * Get SR's MODE field.
     *
     * Operating Mode
     */
    inline OTFAD1_SR_MODE get_SR_MODE() volatile
    {
        return OTFAD1_SR_MODE((SR >> 2u) & 0b11u);
    }

    /**
     * Get SR's MDPCP bit.
     *
     * MDPC Present
     */
    inline bool get_SR_MDPCP() volatile
    {
        return SR & (1u << 1u);
    }

    /**
     * Get SR's KBERR bit.
     *
     * Key Blob Error
     */
    inline bool get_SR_KBERR() volatile
    {
        return SR & (1u << 0u);
    }

    /**
     * Set SR's KBERR bit.
     *
     * Key Blob Error
     */
    inline void set_SR_KBERR() volatile
    {
        SR |= 1u << 0u;
    }

    /**
     * Clear SR's KBERR bit.
     *
     * Key Blob Error
     */
    inline void clear_SR_KBERR() volatile
    {
        SR &= ~(1u << 0u);
    }

    /**
     * Toggle SR's KBERR bit.
     *
     * Key Blob Error
     */
    inline void toggle_SR_KBERR() volatile
    {
        SR ^= 1u << 0u;
    }

    /**
     * Get all of SR's bit fields.
     *
     * (read-write) Status Register
     */
    inline void get_SR(bool &KBD, bool &KBPE, bool &GEM, bool &RRAM,
                       uint8_t &HRL, bool &CTXIE3, bool &CTXIE2, bool &CTXIE1,
                       bool &CTXIE0, bool &CTXER3, bool &CTXER2, bool &CTXER1,
                       bool &CTXER0, uint8_t &NCTX, OTFAD1_SR_MODE &MODE,
                       bool &MDPCP, bool &KBERR) volatile
    {
        uint32_t curr = SR;

        KBD = curr & (1u << 31u);
        KBPE = curr & (1u << 30u);
        GEM = curr & (1u << 29u);
        RRAM = curr & (1u << 28u);
        HRL = (curr >> 24u) & 0b1111u;
        CTXIE3 = curr & (1u << 19u);
        CTXIE2 = curr & (1u << 18u);
        CTXIE1 = curr & (1u << 17u);
        CTXIE0 = curr & (1u << 16u);
        CTXER3 = curr & (1u << 11u);
        CTXER2 = curr & (1u << 10u);
        CTXER1 = curr & (1u << 9u);
        CTXER0 = curr & (1u << 8u);
        NCTX = (curr >> 4u) & 0b1111u;
        MODE = OTFAD1_SR_MODE((curr >> 2u) & 0b11u);
        MDPCP = curr & (1u << 1u);
        KBERR = curr & (1u << 0u);
    }
};

static_assert(sizeof(otfad1) == otfad1::size);

static volatile otfad1 *const OTFAD1 = reinterpret_cast<otfad1 *>(0x400CC000);

static volatile otfad1 *const OTFAD2 = reinterpret_cast<otfad1 *>(0x400D0000);

}; // namespace MIMXRT1176::CM7
