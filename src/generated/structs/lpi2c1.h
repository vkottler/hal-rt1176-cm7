/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/LPI2C1_MCFGR1_MATCFG.h"
#include "../enums/LPI2C1_MCFGR1_PINCFG.h"
#include "../enums/LPI2C1_MCFGR1_PRESCALE.h"
#include "../enums/LPI2C1_MTDR_CMD.h"
#include "../enums/LPI2C1_SCFGR1_ADDRCFG.h"
#include "../enums/LPI2C1_VERID_FEATURE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * LPI2C
 */
struct [[gnu::packed]] lpi2c1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 372; /*!< lpi2c1's size in bytes. */

    /* Fields. */
    uint32_t VERID; /*!< (read-write) Version ID */
    uint32_t PARAM; /*!< (read-write) Parameter */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t MCR;    /*!< (read-write) Master Control */
    uint32_t MSR;    /*!< (read-write) Master Status */
    uint32_t MIER;   /*!< (read-write) Master Interrupt Enable */
    uint32_t MDER;   /*!< (read-write) Master DMA Enable */
    uint32_t MCFGR0; /*!< (read-write) Master Configuration 0 */
    uint32_t MCFGR1; /*!< (read-write) Master Configuration 1 */
    uint32_t MCFGR2; /*!< (read-write) Master Configuration 2 */
    uint32_t MCFGR3; /*!< (read-write) Master Configuration 3 */
    static constexpr std::size_t reserved_padding1_length = 4;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t MDMR; /*!< (read-write) Master Data Match */
    const uint32_t reserved_padding2 = {};
    uint32_t MCCR0; /*!< (read-write) Master Clock Configuration 0 */
    const uint32_t reserved_padding3 = {};
    uint32_t MCCR1; /*!< (read-write) Master Clock Configuration 1 */
    const uint32_t reserved_padding4 = {};
    uint32_t MFCR; /*!< (read-write) Master FIFO Control */
    uint32_t MFSR; /*!< (read-write) Master FIFO Status */
    uint32_t MTDR; /*!< (read-write) Master Transmit Data */
    static constexpr std::size_t reserved_padding5_length = 3;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t MRDR; /*!< (read-write) Master Receive Data */
    static constexpr std::size_t reserved_padding6_length = 39;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t SCR;  /*!< (read-write) Slave Control */
    uint32_t SSR;  /*!< (read-write) Slave Status */
    uint32_t SIER; /*!< (read-write) Slave Interrupt Enable */
    uint32_t SDER; /*!< (read-write) Slave DMA Enable */
    const uint32_t reserved_padding7 = {};
    uint32_t SCFGR1; /*!< (read-write) Slave Configuration 1 */
    uint32_t SCFGR2; /*!< (read-write) Slave Configuration 2 */
    static constexpr std::size_t reserved_padding8_length = 5;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t SAMR; /*!< (read-write) Slave Address Match */
    static constexpr std::size_t reserved_padding9_length = 3;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t SASR; /*!< (read-write) Slave Address Status */
    uint32_t STAR; /*!< (read-write) Slave Transmit ACK */
    static constexpr std::size_t reserved_padding10_length = 2;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t STDR; /*!< (read-write) Slave Transmit Data */
    static constexpr std::size_t reserved_padding11_length = 3;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t SRDR; /*!< (read-write) Slave Receive Data */

    /* Methods. */

    /**
     * Get VERID's MAJOR field.
     *
     * Major Version Number
     */
    inline uint8_t get_VERID_MAJOR() volatile
    {
        return (VERID >> 24u) & 0b11111111u;
    }

    /**
     * Get VERID's MINOR field.
     *
     * Minor Version Number
     */
    inline uint8_t get_VERID_MINOR() volatile
    {
        return (VERID >> 16u) & 0b11111111u;
    }

    /**
     * Get VERID's FEATURE field.
     *
     * Feature Specification Number
     */
    inline LPI2C1_VERID_FEATURE get_VERID_FEATURE() volatile
    {
        return LPI2C1_VERID_FEATURE((VERID >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get all of VERID's bit fields.
     *
     * (read-write) Version ID
     */
    inline void get_VERID(uint8_t &MAJOR, uint8_t &MINOR,
                          LPI2C1_VERID_FEATURE &FEATURE) volatile
    {
        uint32_t curr = VERID;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        FEATURE = LPI2C1_VERID_FEATURE((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get PARAM's MRXFIFO field.
     *
     * Master Receive FIFO Size
     */
    inline uint8_t get_PARAM_MRXFIFO() volatile
    {
        return (PARAM >> 8u) & 0b1111u;
    }

    /**
     * Get PARAM's MTXFIFO field.
     *
     * Master Transmit FIFO Size
     */
    inline uint8_t get_PARAM_MTXFIFO() volatile
    {
        return (PARAM >> 0u) & 0b1111u;
    }

    /**
     * Get all of PARAM's bit fields.
     *
     * (read-write) Parameter
     */
    inline void get_PARAM(uint8_t &MRXFIFO, uint8_t &MTXFIFO) volatile
    {
        uint32_t curr = PARAM;

        MRXFIFO = (curr >> 8u) & 0b1111u;
        MTXFIFO = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get MCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline bool get_MCR_RRF() volatile
    {
        return MCR & (1u << 9u);
    }

    /**
     * Set MCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void set_MCR_RRF() volatile
    {
        MCR |= 1u << 9u;
    }

    /**
     * Clear MCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void clear_MCR_RRF() volatile
    {
        MCR &= ~(1u << 9u);
    }

    /**
     * Toggle MCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void toggle_MCR_RRF() volatile
    {
        MCR ^= 1u << 9u;
    }

    /**
     * Get MCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline bool get_MCR_RTF() volatile
    {
        return MCR & (1u << 8u);
    }

    /**
     * Set MCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void set_MCR_RTF() volatile
    {
        MCR |= 1u << 8u;
    }

    /**
     * Clear MCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void clear_MCR_RTF() volatile
    {
        MCR &= ~(1u << 8u);
    }

    /**
     * Toggle MCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void toggle_MCR_RTF() volatile
    {
        MCR ^= 1u << 8u;
    }

    /**
     * Get MCR's DBGEN bit.
     *
     * Debug Enable
     */
    inline bool get_MCR_DBGEN() volatile
    {
        return MCR & (1u << 3u);
    }

    /**
     * Set MCR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void set_MCR_DBGEN() volatile
    {
        MCR |= 1u << 3u;
    }

    /**
     * Clear MCR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void clear_MCR_DBGEN() volatile
    {
        MCR &= ~(1u << 3u);
    }

    /**
     * Toggle MCR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void toggle_MCR_DBGEN() volatile
    {
        MCR ^= 1u << 3u;
    }

    /**
     * Get MCR's DOZEN bit.
     *
     * Doze mode enable
     */
    inline bool get_MCR_DOZEN() volatile
    {
        return MCR & (1u << 2u);
    }

    /**
     * Set MCR's DOZEN bit.
     *
     * Doze mode enable
     */
    inline void set_MCR_DOZEN() volatile
    {
        MCR |= 1u << 2u;
    }

    /**
     * Clear MCR's DOZEN bit.
     *
     * Doze mode enable
     */
    inline void clear_MCR_DOZEN() volatile
    {
        MCR &= ~(1u << 2u);
    }

    /**
     * Toggle MCR's DOZEN bit.
     *
     * Doze mode enable
     */
    inline void toggle_MCR_DOZEN() volatile
    {
        MCR ^= 1u << 2u;
    }

    /**
     * Get MCR's RST bit.
     *
     * Software Reset
     */
    inline bool get_MCR_RST() volatile
    {
        return MCR & (1u << 1u);
    }

    /**
     * Set MCR's RST bit.
     *
     * Software Reset
     */
    inline void set_MCR_RST() volatile
    {
        MCR |= 1u << 1u;
    }

    /**
     * Clear MCR's RST bit.
     *
     * Software Reset
     */
    inline void clear_MCR_RST() volatile
    {
        MCR &= ~(1u << 1u);
    }

    /**
     * Toggle MCR's RST bit.
     *
     * Software Reset
     */
    inline void toggle_MCR_RST() volatile
    {
        MCR ^= 1u << 1u;
    }

    /**
     * Get MCR's MEN bit.
     *
     * Master Enable
     */
    inline bool get_MCR_MEN() volatile
    {
        return MCR & (1u << 0u);
    }

    /**
     * Set MCR's MEN bit.
     *
     * Master Enable
     */
    inline void set_MCR_MEN() volatile
    {
        MCR |= 1u << 0u;
    }

    /**
     * Clear MCR's MEN bit.
     *
     * Master Enable
     */
    inline void clear_MCR_MEN() volatile
    {
        MCR &= ~(1u << 0u);
    }

    /**
     * Toggle MCR's MEN bit.
     *
     * Master Enable
     */
    inline void toggle_MCR_MEN() volatile
    {
        MCR ^= 1u << 0u;
    }

    /**
     * Get all of MCR's bit fields.
     *
     * (read-write) Master Control
     */
    inline void get_MCR(bool &RRF, bool &RTF, bool &DBGEN, bool &DOZEN,
                        bool &RST, bool &MEN) volatile
    {
        uint32_t curr = MCR;

        RRF = curr & (1u << 9u);
        RTF = curr & (1u << 8u);
        DBGEN = curr & (1u << 3u);
        DOZEN = curr & (1u << 2u);
        RST = curr & (1u << 1u);
        MEN = curr & (1u << 0u);
    }

    /**
     * Set all of MCR's bit fields.
     *
     * (read-write) Master Control
     */
    inline void set_MCR(bool RRF, bool RTF, bool DBGEN, bool DOZEN, bool RST,
                        bool MEN) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b1u << 9u);
        curr |= (RRF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RTF & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (DBGEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DOZEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RST & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MEN & 0b1u) << 0u;

        MCR = curr;
    }

    /**
     * Get MSR's BBF bit.
     *
     * Bus Busy Flag
     */
    inline bool get_MSR_BBF() volatile
    {
        return MSR & (1u << 25u);
    }

    /**
     * Get MSR's MBF bit.
     *
     * Master Busy Flag
     */
    inline bool get_MSR_MBF() volatile
    {
        return MSR & (1u << 24u);
    }

    /**
     * Get MSR's DMF bit.
     *
     * Data Match Flag
     */
    inline bool get_MSR_DMF() volatile
    {
        return MSR & (1u << 14u);
    }

    /**
     * Set MSR's DMF bit.
     *
     * Data Match Flag
     */
    inline void set_MSR_DMF() volatile
    {
        MSR |= 1u << 14u;
    }

    /**
     * Clear MSR's DMF bit.
     *
     * Data Match Flag
     */
    inline void clear_MSR_DMF() volatile
    {
        MSR &= ~(1u << 14u);
    }

    /**
     * Toggle MSR's DMF bit.
     *
     * Data Match Flag
     */
    inline void toggle_MSR_DMF() volatile
    {
        MSR ^= 1u << 14u;
    }

    /**
     * Get MSR's PLTF bit.
     *
     * Pin Low Timeout Flag
     */
    inline bool get_MSR_PLTF() volatile
    {
        return MSR & (1u << 13u);
    }

    /**
     * Set MSR's PLTF bit.
     *
     * Pin Low Timeout Flag
     */
    inline void set_MSR_PLTF() volatile
    {
        MSR |= 1u << 13u;
    }

    /**
     * Clear MSR's PLTF bit.
     *
     * Pin Low Timeout Flag
     */
    inline void clear_MSR_PLTF() volatile
    {
        MSR &= ~(1u << 13u);
    }

    /**
     * Toggle MSR's PLTF bit.
     *
     * Pin Low Timeout Flag
     */
    inline void toggle_MSR_PLTF() volatile
    {
        MSR ^= 1u << 13u;
    }

    /**
     * Get MSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline bool get_MSR_FEF() volatile
    {
        return MSR & (1u << 12u);
    }

    /**
     * Set MSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline void set_MSR_FEF() volatile
    {
        MSR |= 1u << 12u;
    }

    /**
     * Clear MSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline void clear_MSR_FEF() volatile
    {
        MSR &= ~(1u << 12u);
    }

    /**
     * Toggle MSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline void toggle_MSR_FEF() volatile
    {
        MSR ^= 1u << 12u;
    }

    /**
     * Get MSR's ALF bit.
     *
     * Arbitration Lost Flag
     */
    inline bool get_MSR_ALF() volatile
    {
        return MSR & (1u << 11u);
    }

    /**
     * Set MSR's ALF bit.
     *
     * Arbitration Lost Flag
     */
    inline void set_MSR_ALF() volatile
    {
        MSR |= 1u << 11u;
    }

    /**
     * Clear MSR's ALF bit.
     *
     * Arbitration Lost Flag
     */
    inline void clear_MSR_ALF() volatile
    {
        MSR &= ~(1u << 11u);
    }

    /**
     * Toggle MSR's ALF bit.
     *
     * Arbitration Lost Flag
     */
    inline void toggle_MSR_ALF() volatile
    {
        MSR ^= 1u << 11u;
    }

    /**
     * Get MSR's NDF bit.
     *
     * NACK Detect Flag
     */
    inline bool get_MSR_NDF() volatile
    {
        return MSR & (1u << 10u);
    }

    /**
     * Set MSR's NDF bit.
     *
     * NACK Detect Flag
     */
    inline void set_MSR_NDF() volatile
    {
        MSR |= 1u << 10u;
    }

    /**
     * Clear MSR's NDF bit.
     *
     * NACK Detect Flag
     */
    inline void clear_MSR_NDF() volatile
    {
        MSR &= ~(1u << 10u);
    }

    /**
     * Toggle MSR's NDF bit.
     *
     * NACK Detect Flag
     */
    inline void toggle_MSR_NDF() volatile
    {
        MSR ^= 1u << 10u;
    }

    /**
     * Get MSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline bool get_MSR_SDF() volatile
    {
        return MSR & (1u << 9u);
    }

    /**
     * Set MSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline void set_MSR_SDF() volatile
    {
        MSR |= 1u << 9u;
    }

    /**
     * Clear MSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline void clear_MSR_SDF() volatile
    {
        MSR &= ~(1u << 9u);
    }

    /**
     * Toggle MSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline void toggle_MSR_SDF() volatile
    {
        MSR ^= 1u << 9u;
    }

    /**
     * Get MSR's EPF bit.
     *
     * End Packet Flag
     */
    inline bool get_MSR_EPF() volatile
    {
        return MSR & (1u << 8u);
    }

    /**
     * Set MSR's EPF bit.
     *
     * End Packet Flag
     */
    inline void set_MSR_EPF() volatile
    {
        MSR |= 1u << 8u;
    }

    /**
     * Clear MSR's EPF bit.
     *
     * End Packet Flag
     */
    inline void clear_MSR_EPF() volatile
    {
        MSR &= ~(1u << 8u);
    }

    /**
     * Toggle MSR's EPF bit.
     *
     * End Packet Flag
     */
    inline void toggle_MSR_EPF() volatile
    {
        MSR ^= 1u << 8u;
    }

    /**
     * Get MSR's RDF bit.
     *
     * Receive Data Flag
     */
    inline bool get_MSR_RDF() volatile
    {
        return MSR & (1u << 1u);
    }

    /**
     * Get MSR's TDF bit.
     *
     * Transmit Data Flag
     */
    inline bool get_MSR_TDF() volatile
    {
        return MSR & (1u << 0u);
    }

    /**
     * Get all of MSR's bit fields.
     *
     * (read-write) Master Status
     */
    inline void get_MSR(bool &BBF, bool &MBF, bool &DMF, bool &PLTF, bool &FEF,
                        bool &ALF, bool &NDF, bool &SDF, bool &EPF, bool &RDF,
                        bool &TDF) volatile
    {
        uint32_t curr = MSR;

        BBF = curr & (1u << 25u);
        MBF = curr & (1u << 24u);
        DMF = curr & (1u << 14u);
        PLTF = curr & (1u << 13u);
        FEF = curr & (1u << 12u);
        ALF = curr & (1u << 11u);
        NDF = curr & (1u << 10u);
        SDF = curr & (1u << 9u);
        EPF = curr & (1u << 8u);
        RDF = curr & (1u << 1u);
        TDF = curr & (1u << 0u);
    }

    /**
     * Set all of MSR's bit fields.
     *
     * (read-write) Master Status
     */
    inline void set_MSR(bool DMF, bool PLTF, bool FEF, bool ALF, bool NDF,
                        bool SDF, bool EPF) volatile
    {
        uint32_t curr = MSR;

        curr &= ~(0b1u << 14u);
        curr |= (DMF & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (PLTF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FEF & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ALF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (NDF & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SDF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (EPF & 0b1u) << 8u;

        MSR = curr;
    }

    /**
     * Get MIER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline bool get_MIER_DMIE() volatile
    {
        return MIER & (1u << 14u);
    }

    /**
     * Set MIER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline void set_MIER_DMIE() volatile
    {
        MIER |= 1u << 14u;
    }

    /**
     * Clear MIER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline void clear_MIER_DMIE() volatile
    {
        MIER &= ~(1u << 14u);
    }

    /**
     * Toggle MIER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline void toggle_MIER_DMIE() volatile
    {
        MIER ^= 1u << 14u;
    }

    /**
     * Get MIER's PLTIE bit.
     *
     * Pin Low Timeout Interrupt Enable
     */
    inline bool get_MIER_PLTIE() volatile
    {
        return MIER & (1u << 13u);
    }

    /**
     * Set MIER's PLTIE bit.
     *
     * Pin Low Timeout Interrupt Enable
     */
    inline void set_MIER_PLTIE() volatile
    {
        MIER |= 1u << 13u;
    }

    /**
     * Clear MIER's PLTIE bit.
     *
     * Pin Low Timeout Interrupt Enable
     */
    inline void clear_MIER_PLTIE() volatile
    {
        MIER &= ~(1u << 13u);
    }

    /**
     * Toggle MIER's PLTIE bit.
     *
     * Pin Low Timeout Interrupt Enable
     */
    inline void toggle_MIER_PLTIE() volatile
    {
        MIER ^= 1u << 13u;
    }

    /**
     * Get MIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline bool get_MIER_FEIE() volatile
    {
        return MIER & (1u << 12u);
    }

    /**
     * Set MIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline void set_MIER_FEIE() volatile
    {
        MIER |= 1u << 12u;
    }

    /**
     * Clear MIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline void clear_MIER_FEIE() volatile
    {
        MIER &= ~(1u << 12u);
    }

    /**
     * Toggle MIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline void toggle_MIER_FEIE() volatile
    {
        MIER ^= 1u << 12u;
    }

    /**
     * Get MIER's ALIE bit.
     *
     * Arbitration Lost Interrupt Enable
     */
    inline bool get_MIER_ALIE() volatile
    {
        return MIER & (1u << 11u);
    }

    /**
     * Set MIER's ALIE bit.
     *
     * Arbitration Lost Interrupt Enable
     */
    inline void set_MIER_ALIE() volatile
    {
        MIER |= 1u << 11u;
    }

    /**
     * Clear MIER's ALIE bit.
     *
     * Arbitration Lost Interrupt Enable
     */
    inline void clear_MIER_ALIE() volatile
    {
        MIER &= ~(1u << 11u);
    }

    /**
     * Toggle MIER's ALIE bit.
     *
     * Arbitration Lost Interrupt Enable
     */
    inline void toggle_MIER_ALIE() volatile
    {
        MIER ^= 1u << 11u;
    }

    /**
     * Get MIER's NDIE bit.
     *
     * NACK Detect Interrupt Enable
     */
    inline bool get_MIER_NDIE() volatile
    {
        return MIER & (1u << 10u);
    }

    /**
     * Set MIER's NDIE bit.
     *
     * NACK Detect Interrupt Enable
     */
    inline void set_MIER_NDIE() volatile
    {
        MIER |= 1u << 10u;
    }

    /**
     * Clear MIER's NDIE bit.
     *
     * NACK Detect Interrupt Enable
     */
    inline void clear_MIER_NDIE() volatile
    {
        MIER &= ~(1u << 10u);
    }

    /**
     * Toggle MIER's NDIE bit.
     *
     * NACK Detect Interrupt Enable
     */
    inline void toggle_MIER_NDIE() volatile
    {
        MIER ^= 1u << 10u;
    }

    /**
     * Get MIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline bool get_MIER_SDIE() volatile
    {
        return MIER & (1u << 9u);
    }

    /**
     * Set MIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline void set_MIER_SDIE() volatile
    {
        MIER |= 1u << 9u;
    }

    /**
     * Clear MIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline void clear_MIER_SDIE() volatile
    {
        MIER &= ~(1u << 9u);
    }

    /**
     * Toggle MIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline void toggle_MIER_SDIE() volatile
    {
        MIER ^= 1u << 9u;
    }

    /**
     * Get MIER's EPIE bit.
     *
     * End Packet Interrupt Enable
     */
    inline bool get_MIER_EPIE() volatile
    {
        return MIER & (1u << 8u);
    }

    /**
     * Set MIER's EPIE bit.
     *
     * End Packet Interrupt Enable
     */
    inline void set_MIER_EPIE() volatile
    {
        MIER |= 1u << 8u;
    }

    /**
     * Clear MIER's EPIE bit.
     *
     * End Packet Interrupt Enable
     */
    inline void clear_MIER_EPIE() volatile
    {
        MIER &= ~(1u << 8u);
    }

    /**
     * Toggle MIER's EPIE bit.
     *
     * End Packet Interrupt Enable
     */
    inline void toggle_MIER_EPIE() volatile
    {
        MIER ^= 1u << 8u;
    }

    /**
     * Get MIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline bool get_MIER_RDIE() volatile
    {
        return MIER & (1u << 1u);
    }

    /**
     * Set MIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void set_MIER_RDIE() volatile
    {
        MIER |= 1u << 1u;
    }

    /**
     * Clear MIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void clear_MIER_RDIE() volatile
    {
        MIER &= ~(1u << 1u);
    }

    /**
     * Toggle MIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void toggle_MIER_RDIE() volatile
    {
        MIER ^= 1u << 1u;
    }

    /**
     * Get MIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline bool get_MIER_TDIE() volatile
    {
        return MIER & (1u << 0u);
    }

    /**
     * Set MIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void set_MIER_TDIE() volatile
    {
        MIER |= 1u << 0u;
    }

    /**
     * Clear MIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void clear_MIER_TDIE() volatile
    {
        MIER &= ~(1u << 0u);
    }

    /**
     * Toggle MIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void toggle_MIER_TDIE() volatile
    {
        MIER ^= 1u << 0u;
    }

    /**
     * Get all of MIER's bit fields.
     *
     * (read-write) Master Interrupt Enable
     */
    inline void get_MIER(bool &DMIE, bool &PLTIE, bool &FEIE, bool &ALIE,
                         bool &NDIE, bool &SDIE, bool &EPIE, bool &RDIE,
                         bool &TDIE) volatile
    {
        uint32_t curr = MIER;

        DMIE = curr & (1u << 14u);
        PLTIE = curr & (1u << 13u);
        FEIE = curr & (1u << 12u);
        ALIE = curr & (1u << 11u);
        NDIE = curr & (1u << 10u);
        SDIE = curr & (1u << 9u);
        EPIE = curr & (1u << 8u);
        RDIE = curr & (1u << 1u);
        TDIE = curr & (1u << 0u);
    }

    /**
     * Set all of MIER's bit fields.
     *
     * (read-write) Master Interrupt Enable
     */
    inline void set_MIER(bool DMIE, bool PLTIE, bool FEIE, bool ALIE,
                         bool NDIE, bool SDIE, bool EPIE, bool RDIE,
                         bool TDIE) volatile
    {
        uint32_t curr = MIER;

        curr &= ~(0b1u << 14u);
        curr |= (DMIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (PLTIE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FEIE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ALIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (NDIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SDIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (EPIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (RDIE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TDIE & 0b1u) << 0u;

        MIER = curr;
    }

    /**
     * Get MDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline bool get_MDER_RDDE() volatile
    {
        return MDER & (1u << 1u);
    }

    /**
     * Set MDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void set_MDER_RDDE() volatile
    {
        MDER |= 1u << 1u;
    }

    /**
     * Clear MDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void clear_MDER_RDDE() volatile
    {
        MDER &= ~(1u << 1u);
    }

    /**
     * Toggle MDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void toggle_MDER_RDDE() volatile
    {
        MDER ^= 1u << 1u;
    }

    /**
     * Get MDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline bool get_MDER_TDDE() volatile
    {
        return MDER & (1u << 0u);
    }

    /**
     * Set MDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void set_MDER_TDDE() volatile
    {
        MDER |= 1u << 0u;
    }

    /**
     * Clear MDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void clear_MDER_TDDE() volatile
    {
        MDER &= ~(1u << 0u);
    }

    /**
     * Toggle MDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void toggle_MDER_TDDE() volatile
    {
        MDER ^= 1u << 0u;
    }

    /**
     * Get all of MDER's bit fields.
     *
     * (read-write) Master DMA Enable
     */
    inline void get_MDER(bool &RDDE, bool &TDDE) volatile
    {
        uint32_t curr = MDER;

        RDDE = curr & (1u << 1u);
        TDDE = curr & (1u << 0u);
    }

    /**
     * Set all of MDER's bit fields.
     *
     * (read-write) Master DMA Enable
     */
    inline void set_MDER(bool RDDE, bool TDDE) volatile
    {
        uint32_t curr = MDER;

        curr &= ~(0b1u << 1u);
        curr |= (RDDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TDDE & 0b1u) << 0u;

        MDER = curr;
    }

    /**
     * Get MCFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline bool get_MCFGR0_RDMO() volatile
    {
        return MCFGR0 & (1u << 9u);
    }

    /**
     * Set MCFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline void set_MCFGR0_RDMO() volatile
    {
        MCFGR0 |= 1u << 9u;
    }

    /**
     * Clear MCFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline void clear_MCFGR0_RDMO() volatile
    {
        MCFGR0 &= ~(1u << 9u);
    }

    /**
     * Toggle MCFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline void toggle_MCFGR0_RDMO() volatile
    {
        MCFGR0 ^= 1u << 9u;
    }

    /**
     * Get MCFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline bool get_MCFGR0_CIRFIFO() volatile
    {
        return MCFGR0 & (1u << 8u);
    }

    /**
     * Set MCFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline void set_MCFGR0_CIRFIFO() volatile
    {
        MCFGR0 |= 1u << 8u;
    }

    /**
     * Clear MCFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline void clear_MCFGR0_CIRFIFO() volatile
    {
        MCFGR0 &= ~(1u << 8u);
    }

    /**
     * Toggle MCFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline void toggle_MCFGR0_CIRFIFO() volatile
    {
        MCFGR0 ^= 1u << 8u;
    }

    /**
     * Get MCFGR0's HRSEL bit.
     *
     * Host Request Select
     */
    inline bool get_MCFGR0_HRSEL() volatile
    {
        return MCFGR0 & (1u << 2u);
    }

    /**
     * Set MCFGR0's HRSEL bit.
     *
     * Host Request Select
     */
    inline void set_MCFGR0_HRSEL() volatile
    {
        MCFGR0 |= 1u << 2u;
    }

    /**
     * Clear MCFGR0's HRSEL bit.
     *
     * Host Request Select
     */
    inline void clear_MCFGR0_HRSEL() volatile
    {
        MCFGR0 &= ~(1u << 2u);
    }

    /**
     * Toggle MCFGR0's HRSEL bit.
     *
     * Host Request Select
     */
    inline void toggle_MCFGR0_HRSEL() volatile
    {
        MCFGR0 ^= 1u << 2u;
    }

    /**
     * Get MCFGR0's HRPOL bit.
     *
     * Host Request Polarity
     */
    inline bool get_MCFGR0_HRPOL() volatile
    {
        return MCFGR0 & (1u << 1u);
    }

    /**
     * Set MCFGR0's HRPOL bit.
     *
     * Host Request Polarity
     */
    inline void set_MCFGR0_HRPOL() volatile
    {
        MCFGR0 |= 1u << 1u;
    }

    /**
     * Clear MCFGR0's HRPOL bit.
     *
     * Host Request Polarity
     */
    inline void clear_MCFGR0_HRPOL() volatile
    {
        MCFGR0 &= ~(1u << 1u);
    }

    /**
     * Toggle MCFGR0's HRPOL bit.
     *
     * Host Request Polarity
     */
    inline void toggle_MCFGR0_HRPOL() volatile
    {
        MCFGR0 ^= 1u << 1u;
    }

    /**
     * Get MCFGR0's HREN bit.
     *
     * Host Request Enable
     */
    inline bool get_MCFGR0_HREN() volatile
    {
        return MCFGR0 & (1u << 0u);
    }

    /**
     * Set MCFGR0's HREN bit.
     *
     * Host Request Enable
     */
    inline void set_MCFGR0_HREN() volatile
    {
        MCFGR0 |= 1u << 0u;
    }

    /**
     * Clear MCFGR0's HREN bit.
     *
     * Host Request Enable
     */
    inline void clear_MCFGR0_HREN() volatile
    {
        MCFGR0 &= ~(1u << 0u);
    }

    /**
     * Toggle MCFGR0's HREN bit.
     *
     * Host Request Enable
     */
    inline void toggle_MCFGR0_HREN() volatile
    {
        MCFGR0 ^= 1u << 0u;
    }

    /**
     * Get all of MCFGR0's bit fields.
     *
     * (read-write) Master Configuration 0
     */
    inline void get_MCFGR0(bool &RDMO, bool &CIRFIFO, bool &HRSEL, bool &HRPOL,
                           bool &HREN) volatile
    {
        uint32_t curr = MCFGR0;

        RDMO = curr & (1u << 9u);
        CIRFIFO = curr & (1u << 8u);
        HRSEL = curr & (1u << 2u);
        HRPOL = curr & (1u << 1u);
        HREN = curr & (1u << 0u);
    }

    /**
     * Set all of MCFGR0's bit fields.
     *
     * (read-write) Master Configuration 0
     */
    inline void set_MCFGR0(bool RDMO, bool CIRFIFO, bool HRSEL, bool HRPOL,
                           bool HREN) volatile
    {
        uint32_t curr = MCFGR0;

        curr &= ~(0b1u << 9u);
        curr |= (RDMO & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CIRFIFO & 0b1u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (HRSEL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (HRPOL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (HREN & 0b1u) << 0u;

        MCFGR0 = curr;
    }

    /**
     * Get MCFGR1's PINCFG field.
     *
     * Pin Configuration
     */
    inline LPI2C1_MCFGR1_PINCFG get_MCFGR1_PINCFG() volatile
    {
        return LPI2C1_MCFGR1_PINCFG((MCFGR1 >> 24u) & 0b111u);
    }

    /**
     * Set MCFGR1's PINCFG field.
     *
     * Pin Configuration
     */
    inline void set_MCFGR1_PINCFG(LPI2C1_MCFGR1_PINCFG value) volatile
    {
        uint32_t curr = MCFGR1;

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(value) & 0b111u) << 24u;

        MCFGR1 = curr;
    }

    /**
     * Get MCFGR1's MATCFG field.
     *
     * Match Configuration
     */
    inline LPI2C1_MCFGR1_MATCFG get_MCFGR1_MATCFG() volatile
    {
        return LPI2C1_MCFGR1_MATCFG((MCFGR1 >> 16u) & 0b111u);
    }

    /**
     * Set MCFGR1's MATCFG field.
     *
     * Match Configuration
     */
    inline void set_MCFGR1_MATCFG(LPI2C1_MCFGR1_MATCFG value) volatile
    {
        uint32_t curr = MCFGR1;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        MCFGR1 = curr;
    }

    /**
     * Get MCFGR1's TIMECFG bit.
     *
     * Timeout Configuration
     */
    inline bool get_MCFGR1_TIMECFG() volatile
    {
        return MCFGR1 & (1u << 10u);
    }

    /**
     * Set MCFGR1's TIMECFG bit.
     *
     * Timeout Configuration
     */
    inline void set_MCFGR1_TIMECFG() volatile
    {
        MCFGR1 |= 1u << 10u;
    }

    /**
     * Clear MCFGR1's TIMECFG bit.
     *
     * Timeout Configuration
     */
    inline void clear_MCFGR1_TIMECFG() volatile
    {
        MCFGR1 &= ~(1u << 10u);
    }

    /**
     * Toggle MCFGR1's TIMECFG bit.
     *
     * Timeout Configuration
     */
    inline void toggle_MCFGR1_TIMECFG() volatile
    {
        MCFGR1 ^= 1u << 10u;
    }

    /**
     * Get MCFGR1's IGNACK bit.
     *
     * IGNACK
     */
    inline bool get_MCFGR1_IGNACK() volatile
    {
        return MCFGR1 & (1u << 9u);
    }

    /**
     * Set MCFGR1's IGNACK bit.
     *
     * IGNACK
     */
    inline void set_MCFGR1_IGNACK() volatile
    {
        MCFGR1 |= 1u << 9u;
    }

    /**
     * Clear MCFGR1's IGNACK bit.
     *
     * IGNACK
     */
    inline void clear_MCFGR1_IGNACK() volatile
    {
        MCFGR1 &= ~(1u << 9u);
    }

    /**
     * Toggle MCFGR1's IGNACK bit.
     *
     * IGNACK
     */
    inline void toggle_MCFGR1_IGNACK() volatile
    {
        MCFGR1 ^= 1u << 9u;
    }

    /**
     * Get MCFGR1's AUTOSTOP bit.
     *
     * Automatic STOP Generation
     */
    inline bool get_MCFGR1_AUTOSTOP() volatile
    {
        return MCFGR1 & (1u << 8u);
    }

    /**
     * Set MCFGR1's AUTOSTOP bit.
     *
     * Automatic STOP Generation
     */
    inline void set_MCFGR1_AUTOSTOP() volatile
    {
        MCFGR1 |= 1u << 8u;
    }

    /**
     * Clear MCFGR1's AUTOSTOP bit.
     *
     * Automatic STOP Generation
     */
    inline void clear_MCFGR1_AUTOSTOP() volatile
    {
        MCFGR1 &= ~(1u << 8u);
    }

    /**
     * Toggle MCFGR1's AUTOSTOP bit.
     *
     * Automatic STOP Generation
     */
    inline void toggle_MCFGR1_AUTOSTOP() volatile
    {
        MCFGR1 ^= 1u << 8u;
    }

    /**
     * Get MCFGR1's PRESCALE field.
     *
     * Prescaler
     */
    inline LPI2C1_MCFGR1_PRESCALE get_MCFGR1_PRESCALE() volatile
    {
        return LPI2C1_MCFGR1_PRESCALE((MCFGR1 >> 0u) & 0b111u);
    }

    /**
     * Set MCFGR1's PRESCALE field.
     *
     * Prescaler
     */
    inline void set_MCFGR1_PRESCALE(LPI2C1_MCFGR1_PRESCALE value) volatile
    {
        uint32_t curr = MCFGR1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        MCFGR1 = curr;
    }

    /**
     * Get all of MCFGR1's bit fields.
     *
     * (read-write) Master Configuration 1
     */
    inline void get_MCFGR1(LPI2C1_MCFGR1_PINCFG &PINCFG,
                           LPI2C1_MCFGR1_MATCFG &MATCFG, bool &TIMECFG,
                           bool &IGNACK, bool &AUTOSTOP,
                           LPI2C1_MCFGR1_PRESCALE &PRESCALE) volatile
    {
        uint32_t curr = MCFGR1;

        PINCFG = LPI2C1_MCFGR1_PINCFG((curr >> 24u) & 0b111u);
        MATCFG = LPI2C1_MCFGR1_MATCFG((curr >> 16u) & 0b111u);
        TIMECFG = curr & (1u << 10u);
        IGNACK = curr & (1u << 9u);
        AUTOSTOP = curr & (1u << 8u);
        PRESCALE = LPI2C1_MCFGR1_PRESCALE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of MCFGR1's bit fields.
     *
     * (read-write) Master Configuration 1
     */
    inline void set_MCFGR1(LPI2C1_MCFGR1_PINCFG PINCFG,
                           LPI2C1_MCFGR1_MATCFG MATCFG, bool TIMECFG,
                           bool IGNACK, bool AUTOSTOP,
                           LPI2C1_MCFGR1_PRESCALE PRESCALE) volatile
    {
        uint32_t curr = MCFGR1;

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(PINCFG) & 0b111u) << 24u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(MATCFG) & 0b111u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (TIMECFG & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IGNACK & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (AUTOSTOP & 0b1u) << 8u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(PRESCALE) & 0b111u) << 0u;

        MCFGR1 = curr;
    }

    /**
     * Get MCFGR2's FILTSDA field.
     *
     * Glitch Filter SDA
     */
    inline uint8_t get_MCFGR2_FILTSDA() volatile
    {
        return (MCFGR2 >> 24u) & 0b1111u;
    }

    /**
     * Set MCFGR2's FILTSDA field.
     *
     * Glitch Filter SDA
     */
    inline void set_MCFGR2_FILTSDA(uint8_t value) volatile
    {
        uint32_t curr = MCFGR2;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        MCFGR2 = curr;
    }

    /**
     * Get MCFGR2's FILTSCL field.
     *
     * Glitch Filter SCL
     */
    inline uint8_t get_MCFGR2_FILTSCL() volatile
    {
        return (MCFGR2 >> 16u) & 0b1111u;
    }

    /**
     * Set MCFGR2's FILTSCL field.
     *
     * Glitch Filter SCL
     */
    inline void set_MCFGR2_FILTSCL(uint8_t value) volatile
    {
        uint32_t curr = MCFGR2;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        MCFGR2 = curr;
    }

    /**
     * Get MCFGR2's BUSIDLE field.
     *
     * Bus Idle Timeout
     */
    inline uint16_t get_MCFGR2_BUSIDLE() volatile
    {
        return (MCFGR2 >> 0u) & 0b111111111111u;
    }

    /**
     * Set MCFGR2's BUSIDLE field.
     *
     * Bus Idle Timeout
     */
    inline void set_MCFGR2_BUSIDLE(uint16_t value) volatile
    {
        uint32_t curr = MCFGR2;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        MCFGR2 = curr;
    }

    /**
     * Get all of MCFGR2's bit fields.
     *
     * (read-write) Master Configuration 2
     */
    inline void get_MCFGR2(uint8_t &FILTSDA, uint8_t &FILTSCL,
                           uint16_t &BUSIDLE) volatile
    {
        uint32_t curr = MCFGR2;

        FILTSDA = (curr >> 24u) & 0b1111u;
        FILTSCL = (curr >> 16u) & 0b1111u;
        BUSIDLE = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of MCFGR2's bit fields.
     *
     * (read-write) Master Configuration 2
     */
    inline void set_MCFGR2(uint8_t FILTSDA, uint8_t FILTSCL,
                           uint16_t BUSIDLE) volatile
    {
        uint32_t curr = MCFGR2;

        curr &= ~(0b1111u << 24u);
        curr |= (FILTSDA & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (FILTSCL & 0b1111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (BUSIDLE & 0b111111111111u) << 0u;

        MCFGR2 = curr;
    }

    /**
     * Get MCFGR3's PINLOW field.
     *
     * Pin Low Timeout
     */
    inline uint16_t get_MCFGR3_PINLOW() volatile
    {
        return (MCFGR3 >> 8u) & 0b111111111111u;
    }

    /**
     * Set MCFGR3's PINLOW field.
     *
     * Pin Low Timeout
     */
    inline void set_MCFGR3_PINLOW(uint16_t value) volatile
    {
        uint32_t curr = MCFGR3;

        curr &= ~(0b111111111111u << 8u);
        curr |= (value & 0b111111111111u) << 8u;

        MCFGR3 = curr;
    }

    /**
     * Get MDMR's MATCH1 field.
     *
     * Match 1 Value
     */
    inline uint8_t get_MDMR_MATCH1() volatile
    {
        return (MDMR >> 16u) & 0b11111111u;
    }

    /**
     * Set MDMR's MATCH1 field.
     *
     * Match 1 Value
     */
    inline void set_MDMR_MATCH1(uint8_t value) volatile
    {
        uint32_t curr = MDMR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MDMR = curr;
    }

    /**
     * Get MDMR's MATCH0 field.
     *
     * Match 0 Value
     */
    inline uint8_t get_MDMR_MATCH0() volatile
    {
        return (MDMR >> 0u) & 0b11111111u;
    }

    /**
     * Set MDMR's MATCH0 field.
     *
     * Match 0 Value
     */
    inline void set_MDMR_MATCH0(uint8_t value) volatile
    {
        uint32_t curr = MDMR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MDMR = curr;
    }

    /**
     * Get all of MDMR's bit fields.
     *
     * (read-write) Master Data Match
     */
    inline void get_MDMR(uint8_t &MATCH1, uint8_t &MATCH0) volatile
    {
        uint32_t curr = MDMR;

        MATCH1 = (curr >> 16u) & 0b11111111u;
        MATCH0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of MDMR's bit fields.
     *
     * (read-write) Master Data Match
     */
    inline void set_MDMR(uint8_t MATCH1, uint8_t MATCH0) volatile
    {
        uint32_t curr = MDMR;

        curr &= ~(0b11111111u << 16u);
        curr |= (MATCH1 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (MATCH0 & 0b11111111u) << 0u;

        MDMR = curr;
    }

    /**
     * Get MCCR0's DATAVD field.
     *
     * Data Valid Delay
     */
    inline uint8_t get_MCCR0_DATAVD() volatile
    {
        return (MCCR0 >> 24u) & 0b111111u;
    }

    /**
     * Set MCCR0's DATAVD field.
     *
     * Data Valid Delay
     */
    inline void set_MCCR0_DATAVD(uint8_t value) volatile
    {
        uint32_t curr = MCCR0;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MCCR0 = curr;
    }

    /**
     * Get MCCR0's SETHOLD field.
     *
     * Setup Hold Delay
     */
    inline uint8_t get_MCCR0_SETHOLD() volatile
    {
        return (MCCR0 >> 16u) & 0b111111u;
    }

    /**
     * Set MCCR0's SETHOLD field.
     *
     * Setup Hold Delay
     */
    inline void set_MCCR0_SETHOLD(uint8_t value) volatile
    {
        uint32_t curr = MCCR0;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        MCCR0 = curr;
    }

    /**
     * Get MCCR0's CLKHI field.
     *
     * Clock High Period
     */
    inline uint8_t get_MCCR0_CLKHI() volatile
    {
        return (MCCR0 >> 8u) & 0b111111u;
    }

    /**
     * Set MCCR0's CLKHI field.
     *
     * Clock High Period
     */
    inline void set_MCCR0_CLKHI(uint8_t value) volatile
    {
        uint32_t curr = MCCR0;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        MCCR0 = curr;
    }

    /**
     * Get MCCR0's CLKLO field.
     *
     * Clock Low Period
     */
    inline uint8_t get_MCCR0_CLKLO() volatile
    {
        return (MCCR0 >> 0u) & 0b111111u;
    }

    /**
     * Set MCCR0's CLKLO field.
     *
     * Clock Low Period
     */
    inline void set_MCCR0_CLKLO(uint8_t value) volatile
    {
        uint32_t curr = MCCR0;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        MCCR0 = curr;
    }

    /**
     * Get all of MCCR0's bit fields.
     *
     * (read-write) Master Clock Configuration 0
     */
    inline void get_MCCR0(uint8_t &DATAVD, uint8_t &SETHOLD, uint8_t &CLKHI,
                          uint8_t &CLKLO) volatile
    {
        uint32_t curr = MCCR0;

        DATAVD = (curr >> 24u) & 0b111111u;
        SETHOLD = (curr >> 16u) & 0b111111u;
        CLKHI = (curr >> 8u) & 0b111111u;
        CLKLO = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of MCCR0's bit fields.
     *
     * (read-write) Master Clock Configuration 0
     */
    inline void set_MCCR0(uint8_t DATAVD, uint8_t SETHOLD, uint8_t CLKHI,
                          uint8_t CLKLO) volatile
    {
        uint32_t curr = MCCR0;

        curr &= ~(0b111111u << 24u);
        curr |= (DATAVD & 0b111111u) << 24u;
        curr &= ~(0b111111u << 16u);
        curr |= (SETHOLD & 0b111111u) << 16u;
        curr &= ~(0b111111u << 8u);
        curr |= (CLKHI & 0b111111u) << 8u;
        curr &= ~(0b111111u << 0u);
        curr |= (CLKLO & 0b111111u) << 0u;

        MCCR0 = curr;
    }

    /**
     * Get MCCR1's DATAVD field.
     *
     * Data Valid Delay
     */
    inline uint8_t get_MCCR1_DATAVD() volatile
    {
        return (MCCR1 >> 24u) & 0b111111u;
    }

    /**
     * Set MCCR1's DATAVD field.
     *
     * Data Valid Delay
     */
    inline void set_MCCR1_DATAVD(uint8_t value) volatile
    {
        uint32_t curr = MCCR1;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MCCR1 = curr;
    }

    /**
     * Get MCCR1's SETHOLD field.
     *
     * Setup Hold Delay
     */
    inline uint8_t get_MCCR1_SETHOLD() volatile
    {
        return (MCCR1 >> 16u) & 0b111111u;
    }

    /**
     * Set MCCR1's SETHOLD field.
     *
     * Setup Hold Delay
     */
    inline void set_MCCR1_SETHOLD(uint8_t value) volatile
    {
        uint32_t curr = MCCR1;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        MCCR1 = curr;
    }

    /**
     * Get MCCR1's CLKHI field.
     *
     * Clock High Period
     */
    inline uint8_t get_MCCR1_CLKHI() volatile
    {
        return (MCCR1 >> 8u) & 0b111111u;
    }

    /**
     * Set MCCR1's CLKHI field.
     *
     * Clock High Period
     */
    inline void set_MCCR1_CLKHI(uint8_t value) volatile
    {
        uint32_t curr = MCCR1;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        MCCR1 = curr;
    }

    /**
     * Get MCCR1's CLKLO field.
     *
     * Clock Low Period
     */
    inline uint8_t get_MCCR1_CLKLO() volatile
    {
        return (MCCR1 >> 0u) & 0b111111u;
    }

    /**
     * Set MCCR1's CLKLO field.
     *
     * Clock Low Period
     */
    inline void set_MCCR1_CLKLO(uint8_t value) volatile
    {
        uint32_t curr = MCCR1;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        MCCR1 = curr;
    }

    /**
     * Get all of MCCR1's bit fields.
     *
     * (read-write) Master Clock Configuration 1
     */
    inline void get_MCCR1(uint8_t &DATAVD, uint8_t &SETHOLD, uint8_t &CLKHI,
                          uint8_t &CLKLO) volatile
    {
        uint32_t curr = MCCR1;

        DATAVD = (curr >> 24u) & 0b111111u;
        SETHOLD = (curr >> 16u) & 0b111111u;
        CLKHI = (curr >> 8u) & 0b111111u;
        CLKLO = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of MCCR1's bit fields.
     *
     * (read-write) Master Clock Configuration 1
     */
    inline void set_MCCR1(uint8_t DATAVD, uint8_t SETHOLD, uint8_t CLKHI,
                          uint8_t CLKLO) volatile
    {
        uint32_t curr = MCCR1;

        curr &= ~(0b111111u << 24u);
        curr |= (DATAVD & 0b111111u) << 24u;
        curr &= ~(0b111111u << 16u);
        curr |= (SETHOLD & 0b111111u) << 16u;
        curr &= ~(0b111111u << 8u);
        curr |= (CLKHI & 0b111111u) << 8u;
        curr &= ~(0b111111u << 0u);
        curr |= (CLKLO & 0b111111u) << 0u;

        MCCR1 = curr;
    }

    /**
     * Get MFCR's RXWATER field.
     *
     * Receive FIFO Watermark
     */
    inline uint8_t get_MFCR_RXWATER() volatile
    {
        return (MFCR >> 16u) & 0b11u;
    }

    /**
     * Set MFCR's RXWATER field.
     *
     * Receive FIFO Watermark
     */
    inline void set_MFCR_RXWATER(uint8_t value) volatile
    {
        uint32_t curr = MFCR;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        MFCR = curr;
    }

    /**
     * Get MFCR's TXWATER field.
     *
     * Transmit FIFO Watermark
     */
    inline uint8_t get_MFCR_TXWATER() volatile
    {
        return (MFCR >> 0u) & 0b11u;
    }

    /**
     * Set MFCR's TXWATER field.
     *
     * Transmit FIFO Watermark
     */
    inline void set_MFCR_TXWATER(uint8_t value) volatile
    {
        uint32_t curr = MFCR;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        MFCR = curr;
    }

    /**
     * Get all of MFCR's bit fields.
     *
     * (read-write) Master FIFO Control
     */
    inline void get_MFCR(uint8_t &RXWATER, uint8_t &TXWATER) volatile
    {
        uint32_t curr = MFCR;

        RXWATER = (curr >> 16u) & 0b11u;
        TXWATER = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of MFCR's bit fields.
     *
     * (read-write) Master FIFO Control
     */
    inline void set_MFCR(uint8_t RXWATER, uint8_t TXWATER) volatile
    {
        uint32_t curr = MFCR;

        curr &= ~(0b11u << 16u);
        curr |= (RXWATER & 0b11u) << 16u;
        curr &= ~(0b11u << 0u);
        curr |= (TXWATER & 0b11u) << 0u;

        MFCR = curr;
    }

    /**
     * Get MFSR's RXCOUNT field.
     *
     * Receive FIFO Count
     */
    inline uint8_t get_MFSR_RXCOUNT() volatile
    {
        return (MFSR >> 16u) & 0b111u;
    }

    /**
     * Get MFSR's TXCOUNT field.
     *
     * Transmit FIFO Count
     */
    inline uint8_t get_MFSR_TXCOUNT() volatile
    {
        return (MFSR >> 0u) & 0b111u;
    }

    /**
     * Get all of MFSR's bit fields.
     *
     * (read-write) Master FIFO Status
     */
    inline void get_MFSR(uint8_t &RXCOUNT, uint8_t &TXCOUNT) volatile
    {
        uint32_t curr = MFSR;

        RXCOUNT = (curr >> 16u) & 0b111u;
        TXCOUNT = (curr >> 0u) & 0b111u;
    }

    /**
     * Set MTDR's CMD field.
     *
     * Command Data
     */
    inline void set_MTDR_CMD(LPI2C1_MTDR_CMD value) volatile
    {
        uint32_t curr = MTDR;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        MTDR = curr;
    }

    /**
     * Set MTDR's DATA field.
     *
     * Transmit Data
     */
    inline void set_MTDR_DATA(uint8_t value) volatile
    {
        uint32_t curr = MTDR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MTDR = curr;
    }

    /**
     * Set all of MTDR's bit fields.
     *
     * (read-write) Master Transmit Data
     */
    inline void set_MTDR(LPI2C1_MTDR_CMD CMD, uint8_t DATA) volatile
    {
        uint32_t curr = MTDR;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(CMD) & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DATA & 0b11111111u) << 0u;

        MTDR = curr;
    }

    /**
     * Get MRDR's RXEMPTY bit.
     *
     * RX Empty
     */
    inline bool get_MRDR_RXEMPTY() volatile
    {
        return MRDR & (1u << 14u);
    }

    /**
     * Get MRDR's DATA field.
     *
     * Receive Data
     */
    inline uint8_t get_MRDR_DATA() volatile
    {
        return (MRDR >> 0u) & 0b11111111u;
    }

    /**
     * Get all of MRDR's bit fields.
     *
     * (read-write) Master Receive Data
     */
    inline void get_MRDR(bool &RXEMPTY, uint8_t &DATA) volatile
    {
        uint32_t curr = MRDR;

        RXEMPTY = curr & (1u << 14u);
        DATA = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get SCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline bool get_SCR_RRF() volatile
    {
        return SCR & (1u << 9u);
    }

    /**
     * Set SCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void set_SCR_RRF() volatile
    {
        SCR |= 1u << 9u;
    }

    /**
     * Clear SCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void clear_SCR_RRF() volatile
    {
        SCR &= ~(1u << 9u);
    }

    /**
     * Toggle SCR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void toggle_SCR_RRF() volatile
    {
        SCR ^= 1u << 9u;
    }

    /**
     * Get SCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline bool get_SCR_RTF() volatile
    {
        return SCR & (1u << 8u);
    }

    /**
     * Set SCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void set_SCR_RTF() volatile
    {
        SCR |= 1u << 8u;
    }

    /**
     * Clear SCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void clear_SCR_RTF() volatile
    {
        SCR &= ~(1u << 8u);
    }

    /**
     * Toggle SCR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void toggle_SCR_RTF() volatile
    {
        SCR ^= 1u << 8u;
    }

    /**
     * Get SCR's FILTDZ bit.
     *
     * Filter Doze Enable
     */
    inline bool get_SCR_FILTDZ() volatile
    {
        return SCR & (1u << 5u);
    }

    /**
     * Set SCR's FILTDZ bit.
     *
     * Filter Doze Enable
     */
    inline void set_SCR_FILTDZ() volatile
    {
        SCR |= 1u << 5u;
    }

    /**
     * Clear SCR's FILTDZ bit.
     *
     * Filter Doze Enable
     */
    inline void clear_SCR_FILTDZ() volatile
    {
        SCR &= ~(1u << 5u);
    }

    /**
     * Toggle SCR's FILTDZ bit.
     *
     * Filter Doze Enable
     */
    inline void toggle_SCR_FILTDZ() volatile
    {
        SCR ^= 1u << 5u;
    }

    /**
     * Get SCR's FILTEN bit.
     *
     * Filter Enable
     */
    inline bool get_SCR_FILTEN() volatile
    {
        return SCR & (1u << 4u);
    }

    /**
     * Set SCR's FILTEN bit.
     *
     * Filter Enable
     */
    inline void set_SCR_FILTEN() volatile
    {
        SCR |= 1u << 4u;
    }

    /**
     * Clear SCR's FILTEN bit.
     *
     * Filter Enable
     */
    inline void clear_SCR_FILTEN() volatile
    {
        SCR &= ~(1u << 4u);
    }

    /**
     * Toggle SCR's FILTEN bit.
     *
     * Filter Enable
     */
    inline void toggle_SCR_FILTEN() volatile
    {
        SCR ^= 1u << 4u;
    }

    /**
     * Get SCR's RST bit.
     *
     * Software Reset
     */
    inline bool get_SCR_RST() volatile
    {
        return SCR & (1u << 1u);
    }

    /**
     * Set SCR's RST bit.
     *
     * Software Reset
     */
    inline void set_SCR_RST() volatile
    {
        SCR |= 1u << 1u;
    }

    /**
     * Clear SCR's RST bit.
     *
     * Software Reset
     */
    inline void clear_SCR_RST() volatile
    {
        SCR &= ~(1u << 1u);
    }

    /**
     * Toggle SCR's RST bit.
     *
     * Software Reset
     */
    inline void toggle_SCR_RST() volatile
    {
        SCR ^= 1u << 1u;
    }

    /**
     * Get SCR's SEN bit.
     *
     * Slave Enable
     */
    inline bool get_SCR_SEN() volatile
    {
        return SCR & (1u << 0u);
    }

    /**
     * Set SCR's SEN bit.
     *
     * Slave Enable
     */
    inline void set_SCR_SEN() volatile
    {
        SCR |= 1u << 0u;
    }

    /**
     * Clear SCR's SEN bit.
     *
     * Slave Enable
     */
    inline void clear_SCR_SEN() volatile
    {
        SCR &= ~(1u << 0u);
    }

    /**
     * Toggle SCR's SEN bit.
     *
     * Slave Enable
     */
    inline void toggle_SCR_SEN() volatile
    {
        SCR ^= 1u << 0u;
    }

    /**
     * Get all of SCR's bit fields.
     *
     * (read-write) Slave Control
     */
    inline void get_SCR(bool &RRF, bool &RTF, bool &FILTDZ, bool &FILTEN,
                        bool &RST, bool &SEN) volatile
    {
        uint32_t curr = SCR;

        RRF = curr & (1u << 9u);
        RTF = curr & (1u << 8u);
        FILTDZ = curr & (1u << 5u);
        FILTEN = curr & (1u << 4u);
        RST = curr & (1u << 1u);
        SEN = curr & (1u << 0u);
    }

    /**
     * Set all of SCR's bit fields.
     *
     * (read-write) Slave Control
     */
    inline void set_SCR(bool RRF, bool RTF, bool FILTDZ, bool FILTEN, bool RST,
                        bool SEN) volatile
    {
        uint32_t curr = SCR;

        curr &= ~(0b1u << 9u);
        curr |= (RRF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RTF & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (FILTDZ & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (FILTEN & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (RST & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SEN & 0b1u) << 0u;

        SCR = curr;
    }

    /**
     * Get SSR's BBF bit.
     *
     * Bus Busy Flag
     */
    inline bool get_SSR_BBF() volatile
    {
        return SSR & (1u << 25u);
    }

    /**
     * Get SSR's SBF bit.
     *
     * Slave Busy Flag
     */
    inline bool get_SSR_SBF() volatile
    {
        return SSR & (1u << 24u);
    }

    /**
     * Get SSR's SARF bit.
     *
     * SMBus Alert Response Flag
     */
    inline bool get_SSR_SARF() volatile
    {
        return SSR & (1u << 15u);
    }

    /**
     * Get SSR's GCF bit.
     *
     * General Call Flag
     */
    inline bool get_SSR_GCF() volatile
    {
        return SSR & (1u << 14u);
    }

    /**
     * Get SSR's AM1F bit.
     *
     * Address Match 1 Flag
     */
    inline bool get_SSR_AM1F() volatile
    {
        return SSR & (1u << 13u);
    }

    /**
     * Get SSR's AM0F bit.
     *
     * Address Match 0 Flag
     */
    inline bool get_SSR_AM0F() volatile
    {
        return SSR & (1u << 12u);
    }

    /**
     * Get SSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline bool get_SSR_FEF() volatile
    {
        return SSR & (1u << 11u);
    }

    /**
     * Set SSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline void set_SSR_FEF() volatile
    {
        SSR |= 1u << 11u;
    }

    /**
     * Clear SSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline void clear_SSR_FEF() volatile
    {
        SSR &= ~(1u << 11u);
    }

    /**
     * Toggle SSR's FEF bit.
     *
     * FIFO Error Flag
     */
    inline void toggle_SSR_FEF() volatile
    {
        SSR ^= 1u << 11u;
    }

    /**
     * Get SSR's BEF bit.
     *
     * Bit Error Flag
     */
    inline bool get_SSR_BEF() volatile
    {
        return SSR & (1u << 10u);
    }

    /**
     * Set SSR's BEF bit.
     *
     * Bit Error Flag
     */
    inline void set_SSR_BEF() volatile
    {
        SSR |= 1u << 10u;
    }

    /**
     * Clear SSR's BEF bit.
     *
     * Bit Error Flag
     */
    inline void clear_SSR_BEF() volatile
    {
        SSR &= ~(1u << 10u);
    }

    /**
     * Toggle SSR's BEF bit.
     *
     * Bit Error Flag
     */
    inline void toggle_SSR_BEF() volatile
    {
        SSR ^= 1u << 10u;
    }

    /**
     * Get SSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline bool get_SSR_SDF() volatile
    {
        return SSR & (1u << 9u);
    }

    /**
     * Set SSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline void set_SSR_SDF() volatile
    {
        SSR |= 1u << 9u;
    }

    /**
     * Clear SSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline void clear_SSR_SDF() volatile
    {
        SSR &= ~(1u << 9u);
    }

    /**
     * Toggle SSR's SDF bit.
     *
     * STOP Detect Flag
     */
    inline void toggle_SSR_SDF() volatile
    {
        SSR ^= 1u << 9u;
    }

    /**
     * Get SSR's RSF bit.
     *
     * Repeated Start Flag
     */
    inline bool get_SSR_RSF() volatile
    {
        return SSR & (1u << 8u);
    }

    /**
     * Set SSR's RSF bit.
     *
     * Repeated Start Flag
     */
    inline void set_SSR_RSF() volatile
    {
        SSR |= 1u << 8u;
    }

    /**
     * Clear SSR's RSF bit.
     *
     * Repeated Start Flag
     */
    inline void clear_SSR_RSF() volatile
    {
        SSR &= ~(1u << 8u);
    }

    /**
     * Toggle SSR's RSF bit.
     *
     * Repeated Start Flag
     */
    inline void toggle_SSR_RSF() volatile
    {
        SSR ^= 1u << 8u;
    }

    /**
     * Get SSR's TAF bit.
     *
     * Transmit ACK Flag
     */
    inline bool get_SSR_TAF() volatile
    {
        return SSR & (1u << 3u);
    }

    /**
     * Get SSR's AVF bit.
     *
     * Address Valid Flag
     */
    inline bool get_SSR_AVF() volatile
    {
        return SSR & (1u << 2u);
    }

    /**
     * Get SSR's RDF bit.
     *
     * Receive Data Flag
     */
    inline bool get_SSR_RDF() volatile
    {
        return SSR & (1u << 1u);
    }

    /**
     * Get SSR's TDF bit.
     *
     * Transmit Data Flag
     */
    inline bool get_SSR_TDF() volatile
    {
        return SSR & (1u << 0u);
    }

    /**
     * Get all of SSR's bit fields.
     *
     * (read-write) Slave Status
     */
    inline void get_SSR(bool &BBF, bool &SBF, bool &SARF, bool &GCF,
                        bool &AM1F, bool &AM0F, bool &FEF, bool &BEF,
                        bool &SDF, bool &RSF, bool &TAF, bool &AVF, bool &RDF,
                        bool &TDF) volatile
    {
        uint32_t curr = SSR;

        BBF = curr & (1u << 25u);
        SBF = curr & (1u << 24u);
        SARF = curr & (1u << 15u);
        GCF = curr & (1u << 14u);
        AM1F = curr & (1u << 13u);
        AM0F = curr & (1u << 12u);
        FEF = curr & (1u << 11u);
        BEF = curr & (1u << 10u);
        SDF = curr & (1u << 9u);
        RSF = curr & (1u << 8u);
        TAF = curr & (1u << 3u);
        AVF = curr & (1u << 2u);
        RDF = curr & (1u << 1u);
        TDF = curr & (1u << 0u);
    }

    /**
     * Set all of SSR's bit fields.
     *
     * (read-write) Slave Status
     */
    inline void set_SSR(bool FEF, bool BEF, bool SDF, bool RSF) volatile
    {
        uint32_t curr = SSR;

        curr &= ~(0b1u << 11u);
        curr |= (FEF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (BEF & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SDF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSF & 0b1u) << 8u;

        SSR = curr;
    }

    /**
     * Get SIER's SARIE bit.
     *
     * SMBus Alert Response Interrupt Enable
     */
    inline bool get_SIER_SARIE() volatile
    {
        return SIER & (1u << 15u);
    }

    /**
     * Set SIER's SARIE bit.
     *
     * SMBus Alert Response Interrupt Enable
     */
    inline void set_SIER_SARIE() volatile
    {
        SIER |= 1u << 15u;
    }

    /**
     * Clear SIER's SARIE bit.
     *
     * SMBus Alert Response Interrupt Enable
     */
    inline void clear_SIER_SARIE() volatile
    {
        SIER &= ~(1u << 15u);
    }

    /**
     * Toggle SIER's SARIE bit.
     *
     * SMBus Alert Response Interrupt Enable
     */
    inline void toggle_SIER_SARIE() volatile
    {
        SIER ^= 1u << 15u;
    }

    /**
     * Get SIER's GCIE bit.
     *
     * General Call Interrupt Enable
     */
    inline bool get_SIER_GCIE() volatile
    {
        return SIER & (1u << 14u);
    }

    /**
     * Set SIER's GCIE bit.
     *
     * General Call Interrupt Enable
     */
    inline void set_SIER_GCIE() volatile
    {
        SIER |= 1u << 14u;
    }

    /**
     * Clear SIER's GCIE bit.
     *
     * General Call Interrupt Enable
     */
    inline void clear_SIER_GCIE() volatile
    {
        SIER &= ~(1u << 14u);
    }

    /**
     * Toggle SIER's GCIE bit.
     *
     * General Call Interrupt Enable
     */
    inline void toggle_SIER_GCIE() volatile
    {
        SIER ^= 1u << 14u;
    }

    /**
     * Get SIER's AM1IE bit.
     *
     * Address Match 1 Interrupt Enable
     */
    inline bool get_SIER_AM1IE() volatile
    {
        return SIER & (1u << 13u);
    }

    /**
     * Set SIER's AM1IE bit.
     *
     * Address Match 1 Interrupt Enable
     */
    inline void set_SIER_AM1IE() volatile
    {
        SIER |= 1u << 13u;
    }

    /**
     * Clear SIER's AM1IE bit.
     *
     * Address Match 1 Interrupt Enable
     */
    inline void clear_SIER_AM1IE() volatile
    {
        SIER &= ~(1u << 13u);
    }

    /**
     * Toggle SIER's AM1IE bit.
     *
     * Address Match 1 Interrupt Enable
     */
    inline void toggle_SIER_AM1IE() volatile
    {
        SIER ^= 1u << 13u;
    }

    /**
     * Get SIER's AM0IE bit.
     *
     * Address Match 0 Interrupt Enable
     */
    inline bool get_SIER_AM0IE() volatile
    {
        return SIER & (1u << 12u);
    }

    /**
     * Set SIER's AM0IE bit.
     *
     * Address Match 0 Interrupt Enable
     */
    inline void set_SIER_AM0IE() volatile
    {
        SIER |= 1u << 12u;
    }

    /**
     * Clear SIER's AM0IE bit.
     *
     * Address Match 0 Interrupt Enable
     */
    inline void clear_SIER_AM0IE() volatile
    {
        SIER &= ~(1u << 12u);
    }

    /**
     * Toggle SIER's AM0IE bit.
     *
     * Address Match 0 Interrupt Enable
     */
    inline void toggle_SIER_AM0IE() volatile
    {
        SIER ^= 1u << 12u;
    }

    /**
     * Get SIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline bool get_SIER_FEIE() volatile
    {
        return SIER & (1u << 11u);
    }

    /**
     * Set SIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline void set_SIER_FEIE() volatile
    {
        SIER |= 1u << 11u;
    }

    /**
     * Clear SIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline void clear_SIER_FEIE() volatile
    {
        SIER &= ~(1u << 11u);
    }

    /**
     * Toggle SIER's FEIE bit.
     *
     * FIFO Error Interrupt Enable
     */
    inline void toggle_SIER_FEIE() volatile
    {
        SIER ^= 1u << 11u;
    }

    /**
     * Get SIER's BEIE bit.
     *
     * Bit Error Interrupt Enable
     */
    inline bool get_SIER_BEIE() volatile
    {
        return SIER & (1u << 10u);
    }

    /**
     * Set SIER's BEIE bit.
     *
     * Bit Error Interrupt Enable
     */
    inline void set_SIER_BEIE() volatile
    {
        SIER |= 1u << 10u;
    }

    /**
     * Clear SIER's BEIE bit.
     *
     * Bit Error Interrupt Enable
     */
    inline void clear_SIER_BEIE() volatile
    {
        SIER &= ~(1u << 10u);
    }

    /**
     * Toggle SIER's BEIE bit.
     *
     * Bit Error Interrupt Enable
     */
    inline void toggle_SIER_BEIE() volatile
    {
        SIER ^= 1u << 10u;
    }

    /**
     * Get SIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline bool get_SIER_SDIE() volatile
    {
        return SIER & (1u << 9u);
    }

    /**
     * Set SIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline void set_SIER_SDIE() volatile
    {
        SIER |= 1u << 9u;
    }

    /**
     * Clear SIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline void clear_SIER_SDIE() volatile
    {
        SIER &= ~(1u << 9u);
    }

    /**
     * Toggle SIER's SDIE bit.
     *
     * STOP Detect Interrupt Enable
     */
    inline void toggle_SIER_SDIE() volatile
    {
        SIER ^= 1u << 9u;
    }

    /**
     * Get SIER's RSIE bit.
     *
     * Repeated Start Interrupt Enable
     */
    inline bool get_SIER_RSIE() volatile
    {
        return SIER & (1u << 8u);
    }

    /**
     * Set SIER's RSIE bit.
     *
     * Repeated Start Interrupt Enable
     */
    inline void set_SIER_RSIE() volatile
    {
        SIER |= 1u << 8u;
    }

    /**
     * Clear SIER's RSIE bit.
     *
     * Repeated Start Interrupt Enable
     */
    inline void clear_SIER_RSIE() volatile
    {
        SIER &= ~(1u << 8u);
    }

    /**
     * Toggle SIER's RSIE bit.
     *
     * Repeated Start Interrupt Enable
     */
    inline void toggle_SIER_RSIE() volatile
    {
        SIER ^= 1u << 8u;
    }

    /**
     * Get SIER's TAIE bit.
     *
     * Transmit ACK Interrupt Enable
     */
    inline bool get_SIER_TAIE() volatile
    {
        return SIER & (1u << 3u);
    }

    /**
     * Set SIER's TAIE bit.
     *
     * Transmit ACK Interrupt Enable
     */
    inline void set_SIER_TAIE() volatile
    {
        SIER |= 1u << 3u;
    }

    /**
     * Clear SIER's TAIE bit.
     *
     * Transmit ACK Interrupt Enable
     */
    inline void clear_SIER_TAIE() volatile
    {
        SIER &= ~(1u << 3u);
    }

    /**
     * Toggle SIER's TAIE bit.
     *
     * Transmit ACK Interrupt Enable
     */
    inline void toggle_SIER_TAIE() volatile
    {
        SIER ^= 1u << 3u;
    }

    /**
     * Get SIER's AVIE bit.
     *
     * Address Valid Interrupt Enable
     */
    inline bool get_SIER_AVIE() volatile
    {
        return SIER & (1u << 2u);
    }

    /**
     * Set SIER's AVIE bit.
     *
     * Address Valid Interrupt Enable
     */
    inline void set_SIER_AVIE() volatile
    {
        SIER |= 1u << 2u;
    }

    /**
     * Clear SIER's AVIE bit.
     *
     * Address Valid Interrupt Enable
     */
    inline void clear_SIER_AVIE() volatile
    {
        SIER &= ~(1u << 2u);
    }

    /**
     * Toggle SIER's AVIE bit.
     *
     * Address Valid Interrupt Enable
     */
    inline void toggle_SIER_AVIE() volatile
    {
        SIER ^= 1u << 2u;
    }

    /**
     * Get SIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline bool get_SIER_RDIE() volatile
    {
        return SIER & (1u << 1u);
    }

    /**
     * Set SIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void set_SIER_RDIE() volatile
    {
        SIER |= 1u << 1u;
    }

    /**
     * Clear SIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void clear_SIER_RDIE() volatile
    {
        SIER &= ~(1u << 1u);
    }

    /**
     * Toggle SIER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void toggle_SIER_RDIE() volatile
    {
        SIER ^= 1u << 1u;
    }

    /**
     * Get SIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline bool get_SIER_TDIE() volatile
    {
        return SIER & (1u << 0u);
    }

    /**
     * Set SIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void set_SIER_TDIE() volatile
    {
        SIER |= 1u << 0u;
    }

    /**
     * Clear SIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void clear_SIER_TDIE() volatile
    {
        SIER &= ~(1u << 0u);
    }

    /**
     * Toggle SIER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void toggle_SIER_TDIE() volatile
    {
        SIER ^= 1u << 0u;
    }

    /**
     * Get all of SIER's bit fields.
     *
     * (read-write) Slave Interrupt Enable
     */
    inline void get_SIER(bool &SARIE, bool &GCIE, bool &AM1IE, bool &AM0IE,
                         bool &FEIE, bool &BEIE, bool &SDIE, bool &RSIE,
                         bool &TAIE, bool &AVIE, bool &RDIE,
                         bool &TDIE) volatile
    {
        uint32_t curr = SIER;

        SARIE = curr & (1u << 15u);
        GCIE = curr & (1u << 14u);
        AM1IE = curr & (1u << 13u);
        AM0IE = curr & (1u << 12u);
        FEIE = curr & (1u << 11u);
        BEIE = curr & (1u << 10u);
        SDIE = curr & (1u << 9u);
        RSIE = curr & (1u << 8u);
        TAIE = curr & (1u << 3u);
        AVIE = curr & (1u << 2u);
        RDIE = curr & (1u << 1u);
        TDIE = curr & (1u << 0u);
    }

    /**
     * Set all of SIER's bit fields.
     *
     * (read-write) Slave Interrupt Enable
     */
    inline void set_SIER(bool SARIE, bool GCIE, bool AM1IE, bool AM0IE,
                         bool FEIE, bool BEIE, bool SDIE, bool RSIE, bool TAIE,
                         bool AVIE, bool RDIE, bool TDIE) volatile
    {
        uint32_t curr = SIER;

        curr &= ~(0b1u << 15u);
        curr |= (SARIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (GCIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (AM1IE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (AM0IE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (FEIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (BEIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SDIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSIE & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (TAIE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AVIE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RDIE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TDIE & 0b1u) << 0u;

        SIER = curr;
    }

    /**
     * Get SDER's AVDE bit.
     *
     * Address Valid DMA Enable
     */
    inline bool get_SDER_AVDE() volatile
    {
        return SDER & (1u << 2u);
    }

    /**
     * Set SDER's AVDE bit.
     *
     * Address Valid DMA Enable
     */
    inline void set_SDER_AVDE() volatile
    {
        SDER |= 1u << 2u;
    }

    /**
     * Clear SDER's AVDE bit.
     *
     * Address Valid DMA Enable
     */
    inline void clear_SDER_AVDE() volatile
    {
        SDER &= ~(1u << 2u);
    }

    /**
     * Toggle SDER's AVDE bit.
     *
     * Address Valid DMA Enable
     */
    inline void toggle_SDER_AVDE() volatile
    {
        SDER ^= 1u << 2u;
    }

    /**
     * Get SDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline bool get_SDER_RDDE() volatile
    {
        return SDER & (1u << 1u);
    }

    /**
     * Set SDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void set_SDER_RDDE() volatile
    {
        SDER |= 1u << 1u;
    }

    /**
     * Clear SDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void clear_SDER_RDDE() volatile
    {
        SDER &= ~(1u << 1u);
    }

    /**
     * Toggle SDER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void toggle_SDER_RDDE() volatile
    {
        SDER ^= 1u << 1u;
    }

    /**
     * Get SDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline bool get_SDER_TDDE() volatile
    {
        return SDER & (1u << 0u);
    }

    /**
     * Set SDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void set_SDER_TDDE() volatile
    {
        SDER |= 1u << 0u;
    }

    /**
     * Clear SDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void clear_SDER_TDDE() volatile
    {
        SDER &= ~(1u << 0u);
    }

    /**
     * Toggle SDER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void toggle_SDER_TDDE() volatile
    {
        SDER ^= 1u << 0u;
    }

    /**
     * Get all of SDER's bit fields.
     *
     * (read-write) Slave DMA Enable
     */
    inline void get_SDER(bool &AVDE, bool &RDDE, bool &TDDE) volatile
    {
        uint32_t curr = SDER;

        AVDE = curr & (1u << 2u);
        RDDE = curr & (1u << 1u);
        TDDE = curr & (1u << 0u);
    }

    /**
     * Set all of SDER's bit fields.
     *
     * (read-write) Slave DMA Enable
     */
    inline void set_SDER(bool AVDE, bool RDDE, bool TDDE) volatile
    {
        uint32_t curr = SDER;

        curr &= ~(0b1u << 2u);
        curr |= (AVDE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RDDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TDDE & 0b1u) << 0u;

        SDER = curr;
    }

    /**
     * Get SCFGR1's ADDRCFG field.
     *
     * Address Configuration
     */
    inline LPI2C1_SCFGR1_ADDRCFG get_SCFGR1_ADDRCFG() volatile
    {
        return LPI2C1_SCFGR1_ADDRCFG((SCFGR1 >> 16u) & 0b111u);
    }

    /**
     * Set SCFGR1's ADDRCFG field.
     *
     * Address Configuration
     */
    inline void set_SCFGR1_ADDRCFG(LPI2C1_SCFGR1_ADDRCFG value) volatile
    {
        uint32_t curr = SCFGR1;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        SCFGR1 = curr;
    }

    /**
     * Get SCFGR1's HSMEN bit.
     *
     * High Speed Mode Enable
     */
    inline bool get_SCFGR1_HSMEN() volatile
    {
        return SCFGR1 & (1u << 13u);
    }

    /**
     * Set SCFGR1's HSMEN bit.
     *
     * High Speed Mode Enable
     */
    inline void set_SCFGR1_HSMEN() volatile
    {
        SCFGR1 |= 1u << 13u;
    }

    /**
     * Clear SCFGR1's HSMEN bit.
     *
     * High Speed Mode Enable
     */
    inline void clear_SCFGR1_HSMEN() volatile
    {
        SCFGR1 &= ~(1u << 13u);
    }

    /**
     * Toggle SCFGR1's HSMEN bit.
     *
     * High Speed Mode Enable
     */
    inline void toggle_SCFGR1_HSMEN() volatile
    {
        SCFGR1 ^= 1u << 13u;
    }

    /**
     * Get SCFGR1's IGNACK bit.
     *
     * Ignore NACK
     */
    inline bool get_SCFGR1_IGNACK() volatile
    {
        return SCFGR1 & (1u << 12u);
    }

    /**
     * Set SCFGR1's IGNACK bit.
     *
     * Ignore NACK
     */
    inline void set_SCFGR1_IGNACK() volatile
    {
        SCFGR1 |= 1u << 12u;
    }

    /**
     * Clear SCFGR1's IGNACK bit.
     *
     * Ignore NACK
     */
    inline void clear_SCFGR1_IGNACK() volatile
    {
        SCFGR1 &= ~(1u << 12u);
    }

    /**
     * Toggle SCFGR1's IGNACK bit.
     *
     * Ignore NACK
     */
    inline void toggle_SCFGR1_IGNACK() volatile
    {
        SCFGR1 ^= 1u << 12u;
    }

    /**
     * Get SCFGR1's RXCFG bit.
     *
     * Receive Data Configuration
     */
    inline bool get_SCFGR1_RXCFG() volatile
    {
        return SCFGR1 & (1u << 11u);
    }

    /**
     * Set SCFGR1's RXCFG bit.
     *
     * Receive Data Configuration
     */
    inline void set_SCFGR1_RXCFG() volatile
    {
        SCFGR1 |= 1u << 11u;
    }

    /**
     * Clear SCFGR1's RXCFG bit.
     *
     * Receive Data Configuration
     */
    inline void clear_SCFGR1_RXCFG() volatile
    {
        SCFGR1 &= ~(1u << 11u);
    }

    /**
     * Toggle SCFGR1's RXCFG bit.
     *
     * Receive Data Configuration
     */
    inline void toggle_SCFGR1_RXCFG() volatile
    {
        SCFGR1 ^= 1u << 11u;
    }

    /**
     * Get SCFGR1's TXCFG bit.
     *
     * Transmit Flag Configuration
     */
    inline bool get_SCFGR1_TXCFG() volatile
    {
        return SCFGR1 & (1u << 10u);
    }

    /**
     * Set SCFGR1's TXCFG bit.
     *
     * Transmit Flag Configuration
     */
    inline void set_SCFGR1_TXCFG() volatile
    {
        SCFGR1 |= 1u << 10u;
    }

    /**
     * Clear SCFGR1's TXCFG bit.
     *
     * Transmit Flag Configuration
     */
    inline void clear_SCFGR1_TXCFG() volatile
    {
        SCFGR1 &= ~(1u << 10u);
    }

    /**
     * Toggle SCFGR1's TXCFG bit.
     *
     * Transmit Flag Configuration
     */
    inline void toggle_SCFGR1_TXCFG() volatile
    {
        SCFGR1 ^= 1u << 10u;
    }

    /**
     * Get SCFGR1's SAEN bit.
     *
     * SMBus Alert Enable
     */
    inline bool get_SCFGR1_SAEN() volatile
    {
        return SCFGR1 & (1u << 9u);
    }

    /**
     * Set SCFGR1's SAEN bit.
     *
     * SMBus Alert Enable
     */
    inline void set_SCFGR1_SAEN() volatile
    {
        SCFGR1 |= 1u << 9u;
    }

    /**
     * Clear SCFGR1's SAEN bit.
     *
     * SMBus Alert Enable
     */
    inline void clear_SCFGR1_SAEN() volatile
    {
        SCFGR1 &= ~(1u << 9u);
    }

    /**
     * Toggle SCFGR1's SAEN bit.
     *
     * SMBus Alert Enable
     */
    inline void toggle_SCFGR1_SAEN() volatile
    {
        SCFGR1 ^= 1u << 9u;
    }

    /**
     * Get SCFGR1's GCEN bit.
     *
     * General Call Enable
     */
    inline bool get_SCFGR1_GCEN() volatile
    {
        return SCFGR1 & (1u << 8u);
    }

    /**
     * Set SCFGR1's GCEN bit.
     *
     * General Call Enable
     */
    inline void set_SCFGR1_GCEN() volatile
    {
        SCFGR1 |= 1u << 8u;
    }

    /**
     * Clear SCFGR1's GCEN bit.
     *
     * General Call Enable
     */
    inline void clear_SCFGR1_GCEN() volatile
    {
        SCFGR1 &= ~(1u << 8u);
    }

    /**
     * Toggle SCFGR1's GCEN bit.
     *
     * General Call Enable
     */
    inline void toggle_SCFGR1_GCEN() volatile
    {
        SCFGR1 ^= 1u << 8u;
    }

    /**
     * Get SCFGR1's ACKSTALL bit.
     *
     * ACK SCL Stall
     */
    inline bool get_SCFGR1_ACKSTALL() volatile
    {
        return SCFGR1 & (1u << 3u);
    }

    /**
     * Set SCFGR1's ACKSTALL bit.
     *
     * ACK SCL Stall
     */
    inline void set_SCFGR1_ACKSTALL() volatile
    {
        SCFGR1 |= 1u << 3u;
    }

    /**
     * Clear SCFGR1's ACKSTALL bit.
     *
     * ACK SCL Stall
     */
    inline void clear_SCFGR1_ACKSTALL() volatile
    {
        SCFGR1 &= ~(1u << 3u);
    }

    /**
     * Toggle SCFGR1's ACKSTALL bit.
     *
     * ACK SCL Stall
     */
    inline void toggle_SCFGR1_ACKSTALL() volatile
    {
        SCFGR1 ^= 1u << 3u;
    }

    /**
     * Get SCFGR1's TXDSTALL bit.
     *
     * TX Data SCL Stall
     */
    inline bool get_SCFGR1_TXDSTALL() volatile
    {
        return SCFGR1 & (1u << 2u);
    }

    /**
     * Set SCFGR1's TXDSTALL bit.
     *
     * TX Data SCL Stall
     */
    inline void set_SCFGR1_TXDSTALL() volatile
    {
        SCFGR1 |= 1u << 2u;
    }

    /**
     * Clear SCFGR1's TXDSTALL bit.
     *
     * TX Data SCL Stall
     */
    inline void clear_SCFGR1_TXDSTALL() volatile
    {
        SCFGR1 &= ~(1u << 2u);
    }

    /**
     * Toggle SCFGR1's TXDSTALL bit.
     *
     * TX Data SCL Stall
     */
    inline void toggle_SCFGR1_TXDSTALL() volatile
    {
        SCFGR1 ^= 1u << 2u;
    }

    /**
     * Get SCFGR1's RXSTALL bit.
     *
     * RX SCL Stall
     */
    inline bool get_SCFGR1_RXSTALL() volatile
    {
        return SCFGR1 & (1u << 1u);
    }

    /**
     * Set SCFGR1's RXSTALL bit.
     *
     * RX SCL Stall
     */
    inline void set_SCFGR1_RXSTALL() volatile
    {
        SCFGR1 |= 1u << 1u;
    }

    /**
     * Clear SCFGR1's RXSTALL bit.
     *
     * RX SCL Stall
     */
    inline void clear_SCFGR1_RXSTALL() volatile
    {
        SCFGR1 &= ~(1u << 1u);
    }

    /**
     * Toggle SCFGR1's RXSTALL bit.
     *
     * RX SCL Stall
     */
    inline void toggle_SCFGR1_RXSTALL() volatile
    {
        SCFGR1 ^= 1u << 1u;
    }

    /**
     * Get SCFGR1's ADRSTALL bit.
     *
     * Address SCL Stall
     */
    inline bool get_SCFGR1_ADRSTALL() volatile
    {
        return SCFGR1 & (1u << 0u);
    }

    /**
     * Set SCFGR1's ADRSTALL bit.
     *
     * Address SCL Stall
     */
    inline void set_SCFGR1_ADRSTALL() volatile
    {
        SCFGR1 |= 1u << 0u;
    }

    /**
     * Clear SCFGR1's ADRSTALL bit.
     *
     * Address SCL Stall
     */
    inline void clear_SCFGR1_ADRSTALL() volatile
    {
        SCFGR1 &= ~(1u << 0u);
    }

    /**
     * Toggle SCFGR1's ADRSTALL bit.
     *
     * Address SCL Stall
     */
    inline void toggle_SCFGR1_ADRSTALL() volatile
    {
        SCFGR1 ^= 1u << 0u;
    }

    /**
     * Get all of SCFGR1's bit fields.
     *
     * (read-write) Slave Configuration 1
     */
    inline void get_SCFGR1(LPI2C1_SCFGR1_ADDRCFG &ADDRCFG, bool &HSMEN,
                           bool &IGNACK, bool &RXCFG, bool &TXCFG, bool &SAEN,
                           bool &GCEN, bool &ACKSTALL, bool &TXDSTALL,
                           bool &RXSTALL, bool &ADRSTALL) volatile
    {
        uint32_t curr = SCFGR1;

        ADDRCFG = LPI2C1_SCFGR1_ADDRCFG((curr >> 16u) & 0b111u);
        HSMEN = curr & (1u << 13u);
        IGNACK = curr & (1u << 12u);
        RXCFG = curr & (1u << 11u);
        TXCFG = curr & (1u << 10u);
        SAEN = curr & (1u << 9u);
        GCEN = curr & (1u << 8u);
        ACKSTALL = curr & (1u << 3u);
        TXDSTALL = curr & (1u << 2u);
        RXSTALL = curr & (1u << 1u);
        ADRSTALL = curr & (1u << 0u);
    }

    /**
     * Set all of SCFGR1's bit fields.
     *
     * (read-write) Slave Configuration 1
     */
    inline void set_SCFGR1(LPI2C1_SCFGR1_ADDRCFG ADDRCFG, bool HSMEN,
                           bool IGNACK, bool RXCFG, bool TXCFG, bool SAEN,
                           bool GCEN, bool ACKSTALL, bool TXDSTALL,
                           bool RXSTALL, bool ADRSTALL) volatile
    {
        uint32_t curr = SCFGR1;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(ADDRCFG) & 0b111u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (HSMEN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (IGNACK & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (RXCFG & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TXCFG & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SAEN & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (GCEN & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (ACKSTALL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TXDSTALL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RXSTALL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ADRSTALL & 0b1u) << 0u;

        SCFGR1 = curr;
    }

    /**
     * Get SCFGR2's FILTSDA field.
     *
     * Glitch Filter SDA
     */
    inline uint8_t get_SCFGR2_FILTSDA() volatile
    {
        return (SCFGR2 >> 24u) & 0b1111u;
    }

    /**
     * Set SCFGR2's FILTSDA field.
     *
     * Glitch Filter SDA
     */
    inline void set_SCFGR2_FILTSDA(uint8_t value) volatile
    {
        uint32_t curr = SCFGR2;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        SCFGR2 = curr;
    }

    /**
     * Get SCFGR2's FILTSCL field.
     *
     * Glitch Filter SCL
     */
    inline uint8_t get_SCFGR2_FILTSCL() volatile
    {
        return (SCFGR2 >> 16u) & 0b1111u;
    }

    /**
     * Set SCFGR2's FILTSCL field.
     *
     * Glitch Filter SCL
     */
    inline void set_SCFGR2_FILTSCL(uint8_t value) volatile
    {
        uint32_t curr = SCFGR2;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        SCFGR2 = curr;
    }

    /**
     * Get SCFGR2's DATAVD field.
     *
     * Data Valid Delay
     */
    inline uint8_t get_SCFGR2_DATAVD() volatile
    {
        return (SCFGR2 >> 8u) & 0b111111u;
    }

    /**
     * Set SCFGR2's DATAVD field.
     *
     * Data Valid Delay
     */
    inline void set_SCFGR2_DATAVD(uint8_t value) volatile
    {
        uint32_t curr = SCFGR2;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        SCFGR2 = curr;
    }

    /**
     * Get SCFGR2's CLKHOLD field.
     *
     * Clock Hold Time
     */
    inline uint8_t get_SCFGR2_CLKHOLD() volatile
    {
        return (SCFGR2 >> 0u) & 0b1111u;
    }

    /**
     * Set SCFGR2's CLKHOLD field.
     *
     * Clock Hold Time
     */
    inline void set_SCFGR2_CLKHOLD(uint8_t value) volatile
    {
        uint32_t curr = SCFGR2;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SCFGR2 = curr;
    }

    /**
     * Get all of SCFGR2's bit fields.
     *
     * (read-write) Slave Configuration 2
     */
    inline void get_SCFGR2(uint8_t &FILTSDA, uint8_t &FILTSCL, uint8_t &DATAVD,
                           uint8_t &CLKHOLD) volatile
    {
        uint32_t curr = SCFGR2;

        FILTSDA = (curr >> 24u) & 0b1111u;
        FILTSCL = (curr >> 16u) & 0b1111u;
        DATAVD = (curr >> 8u) & 0b111111u;
        CLKHOLD = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of SCFGR2's bit fields.
     *
     * (read-write) Slave Configuration 2
     */
    inline void set_SCFGR2(uint8_t FILTSDA, uint8_t FILTSCL, uint8_t DATAVD,
                           uint8_t CLKHOLD) volatile
    {
        uint32_t curr = SCFGR2;

        curr &= ~(0b1111u << 24u);
        curr |= (FILTSDA & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (FILTSCL & 0b1111u) << 16u;
        curr &= ~(0b111111u << 8u);
        curr |= (DATAVD & 0b111111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (CLKHOLD & 0b1111u) << 0u;

        SCFGR2 = curr;
    }

    /**
     * Get SAMR's ADDR1 field.
     *
     * Address 1 Value
     */
    inline uint16_t get_SAMR_ADDR1() volatile
    {
        return (SAMR >> 17u) & 0b1111111111u;
    }

    /**
     * Set SAMR's ADDR1 field.
     *
     * Address 1 Value
     */
    inline void set_SAMR_ADDR1(uint16_t value) volatile
    {
        uint32_t curr = SAMR;

        curr &= ~(0b1111111111u << 17u);
        curr |= (value & 0b1111111111u) << 17u;

        SAMR = curr;
    }

    /**
     * Get SAMR's ADDR0 field.
     *
     * Address 0 Value
     */
    inline uint16_t get_SAMR_ADDR0() volatile
    {
        return (SAMR >> 1u) & 0b1111111111u;
    }

    /**
     * Set SAMR's ADDR0 field.
     *
     * Address 0 Value
     */
    inline void set_SAMR_ADDR0(uint16_t value) volatile
    {
        uint32_t curr = SAMR;

        curr &= ~(0b1111111111u << 1u);
        curr |= (value & 0b1111111111u) << 1u;

        SAMR = curr;
    }

    /**
     * Get all of SAMR's bit fields.
     *
     * (read-write) Slave Address Match
     */
    inline void get_SAMR(uint16_t &ADDR1, uint16_t &ADDR0) volatile
    {
        uint32_t curr = SAMR;

        ADDR1 = (curr >> 17u) & 0b1111111111u;
        ADDR0 = (curr >> 1u) & 0b1111111111u;
    }

    /**
     * Set all of SAMR's bit fields.
     *
     * (read-write) Slave Address Match
     */
    inline void set_SAMR(uint16_t ADDR1, uint16_t ADDR0) volatile
    {
        uint32_t curr = SAMR;

        curr &= ~(0b1111111111u << 17u);
        curr |= (ADDR1 & 0b1111111111u) << 17u;
        curr &= ~(0b1111111111u << 1u);
        curr |= (ADDR0 & 0b1111111111u) << 1u;

        SAMR = curr;
    }

    /**
     * Get SASR's ANV bit.
     *
     * Address Not Valid
     */
    inline bool get_SASR_ANV() volatile
    {
        return SASR & (1u << 14u);
    }

    /**
     * Get SASR's RADDR field.
     *
     * Received Address
     */
    inline uint16_t get_SASR_RADDR() volatile
    {
        return (SASR >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of SASR's bit fields.
     *
     * (read-write) Slave Address Status
     */
    inline void get_SASR(bool &ANV, uint16_t &RADDR) volatile
    {
        uint32_t curr = SASR;

        ANV = curr & (1u << 14u);
        RADDR = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get STAR's TXNACK bit.
     *
     * Transmit NACK
     */
    inline bool get_STAR_TXNACK() volatile
    {
        return STAR & (1u << 0u);
    }

    /**
     * Set STAR's TXNACK bit.
     *
     * Transmit NACK
     */
    inline void set_STAR_TXNACK() volatile
    {
        STAR |= 1u << 0u;
    }

    /**
     * Clear STAR's TXNACK bit.
     *
     * Transmit NACK
     */
    inline void clear_STAR_TXNACK() volatile
    {
        STAR &= ~(1u << 0u);
    }

    /**
     * Toggle STAR's TXNACK bit.
     *
     * Transmit NACK
     */
    inline void toggle_STAR_TXNACK() volatile
    {
        STAR ^= 1u << 0u;
    }

    /**
     * Set STDR's DATA field.
     *
     * Transmit Data
     */
    inline void set_STDR_DATA(uint8_t value) volatile
    {
        uint32_t curr = STDR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        STDR = curr;
    }

    /**
     * Get SRDR's SOF bit.
     *
     * Start Of Frame
     */
    inline bool get_SRDR_SOF() volatile
    {
        return SRDR & (1u << 15u);
    }

    /**
     * Get SRDR's RXEMPTY bit.
     *
     * RX Empty
     */
    inline bool get_SRDR_RXEMPTY() volatile
    {
        return SRDR & (1u << 14u);
    }

    /**
     * Get SRDR's DATA field.
     *
     * Receive Data
     */
    inline uint8_t get_SRDR_DATA() volatile
    {
        return (SRDR >> 0u) & 0b11111111u;
    }

    /**
     * Get all of SRDR's bit fields.
     *
     * (read-write) Slave Receive Data
     */
    inline void get_SRDR(bool &SOF, bool &RXEMPTY, uint8_t &DATA) volatile
    {
        uint32_t curr = SRDR;

        SOF = curr & (1u << 15u);
        RXEMPTY = curr & (1u << 14u);
        DATA = (curr >> 0u) & 0b11111111u;
    }
};

static_assert(sizeof(lpi2c1) == lpi2c1::size);

static volatile lpi2c1 *const LPI2C1 = reinterpret_cast<lpi2c1 *>(0x40104000);

static volatile lpi2c1 *const LPI2C2 = reinterpret_cast<lpi2c1 *>(0x40108000);

static volatile lpi2c1 *const LPI2C3 = reinterpret_cast<lpi2c1 *>(0x4010C000);

static volatile lpi2c1 *const LPI2C4 = reinterpret_cast<lpi2c1 *>(0x40110000);

static volatile lpi2c1 *const LPI2C5 = reinterpret_cast<lpi2c1 *>(0x40C34000);

static volatile lpi2c1 *const LPI2C6 = reinterpret_cast<lpi2c1 *>(0x40C38000);

}; // namespace MIMXRT1176::CM7
