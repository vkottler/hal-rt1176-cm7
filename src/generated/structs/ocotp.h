/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/OCOTP_CTRL_ADDR.h"
#include "../enums/OCOTP_CTRL_WR_UNLOCK.h"
#include "../enums/OCOTP_READ_CTRL_READ_FUSE_CNTR.h"
#include "../ifgen/common.h"
#include "FUSEn_instance.h"

namespace MIMXRT1176::CM7
{

/**
 * no description available
 */
struct [[gnu::packed]] ocotp
{
    /* Constant attributes. */
    static constexpr std::size_t size = 2180; /*!< ocotp's size in bytes. */

    /* Fields. */
    uint32_t
        CTRL; /*!< (read-write) OTP Controller Control and Status Register */
    uint32_t CTRL_SET; /*!< (read-write) OTP Controller Control and Status
                          Register */
    uint32_t CTRL_CLR; /*!< (read-write) OTP Controller Control and Status
                          Register */
    uint32_t CTRL_TOG; /*!< (read-write) OTP Controller Control and Status
                          Register */
    uint32_t PDN;      /*!< (read-write) OTP Controller PDN Register */
    static constexpr std::size_t reserved_padding0_length = 3;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t DATA; /*!< (read-write) OTP Controller Write Data Register */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t
        READ_CTRL; /*!< (read-write) OTP Controller Read Control Register */
    static constexpr std::size_t reserved_padding2_length = 23;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t OUT_STATUS;     /*!< (read-write) 8K OTP Memory STATUS Register */
    uint32_t OUT_STATUS_SET; /*!< (read-write) 8K OTP Memory STATUS Register */
    uint32_t OUT_STATUS_CLR; /*!< (read-write) 8K OTP Memory STATUS Register */
    uint32_t OUT_STATUS_TOG; /*!< (read-write) 8K OTP Memory STATUS Register */
    static constexpr std::size_t reserved_padding3_length = 4;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t VERSION; /*!< (read-write) OTP Controller Version Register */
    static constexpr std::size_t reserved_padding4_length = 19;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t READ_FUSE_DATA0; /*!< (read-write) OTP Controller Read Data 0
                                 Register */
    static constexpr std::size_t reserved_padding5_length = 3;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t READ_FUSE_DATA1; /*!< (read-write) OTP Controller Read Data 1
                                 Register */
    static constexpr std::size_t reserved_padding6_length = 3;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t READ_FUSE_DATA2; /*!< (read-write) OTP Controller Read Data 2
                                 Register */
    static constexpr std::size_t reserved_padding7_length = 3;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t READ_FUSE_DATA3; /*!< (read-write) OTP Controller Read Data 3
                                 Register */
    static constexpr std::size_t reserved_padding8_length = 3;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t SW_LOCK; /*!< (read-write) SW_LOCK Register */
    static constexpr std::size_t reserved_padding9_length = 3;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t BIT_LOCK; /*!< (read-write) BIT_LOCK Register */
    static constexpr std::size_t reserved_padding10_length = 299;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t LOCKED0; /*!< (read-write) OTP Controller Program Locked Status 0
                         Register */
    static constexpr std::size_t reserved_padding11_length = 3;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t LOCKED1; /*!< (read-write) OTP Controller Program Locked Status 1
                         Register */
    static constexpr std::size_t reserved_padding12_length = 3;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t LOCKED2; /*!< (read-write) OTP Controller Program Locked Status 2
                         Register */
    static constexpr std::size_t reserved_padding13_length = 3;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t LOCKED3; /*!< (read-write) OTP Controller Program Locked Status 3
                         Register */
    static constexpr std::size_t reserved_padding14_length = 3;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t LOCKED4; /*!< (read-write) OTP Controller Program Locked Status 4
                         Register */
    static constexpr std::size_t FUSEn_length = 144;
    FUSEn_instance FUSEn[FUSEn_length]; /*!< no description available */

    /* Methods. */

    /**
     * Get CTRL's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline OCOTP_CTRL_WR_UNLOCK get_CTRL_WR_UNLOCK() volatile
    {
        return OCOTP_CTRL_WR_UNLOCK((CTRL >> 16u) & 0b1111111111111111u);
    }

    /**
     * Set CTRL's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline void set_CTRL_WR_UNLOCK(OCOTP_CTRL_WR_UNLOCK value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        CTRL = curr;
    }

    /**
     * Get CTRL's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline bool get_CTRL_WORDLOCK() volatile
    {
        return CTRL & (1u << 15u);
    }

    /**
     * Set CTRL's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void set_CTRL_WORDLOCK() volatile
    {
        CTRL |= 1u << 15u;
    }

    /**
     * Clear CTRL's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void clear_CTRL_WORDLOCK() volatile
    {
        CTRL &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void toggle_CTRL_WORDLOCK() volatile
    {
        CTRL ^= 1u << 15u;
    }

    /**
     * Get CTRL's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline bool get_CTRL_RELOAD_SHADOWS() volatile
    {
        return CTRL & (1u << 12u);
    }

    /**
     * Set CTRL's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void set_CTRL_RELOAD_SHADOWS() volatile
    {
        CTRL |= 1u << 12u;
    }

    /**
     * Clear CTRL's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void clear_CTRL_RELOAD_SHADOWS() volatile
    {
        CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void toggle_CTRL_RELOAD_SHADOWS() volatile
    {
        CTRL ^= 1u << 12u;
    }

    /**
     * Get CTRL's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline bool get_CTRL_ERROR() volatile
    {
        return CTRL & (1u << 11u);
    }

    /**
     * Set CTRL's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void set_CTRL_ERROR() volatile
    {
        CTRL |= 1u << 11u;
    }

    /**
     * Clear CTRL's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void clear_CTRL_ERROR() volatile
    {
        CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void toggle_CTRL_ERROR() volatile
    {
        CTRL ^= 1u << 11u;
    }

    /**
     * Get CTRL's BUSY bit.
     *
     * OTP controller status bit
     */
    inline bool get_CTRL_BUSY() volatile
    {
        return CTRL & (1u << 10u);
    }

    /**
     * Get CTRL's ADDR field.
     *
     * OTP write and read access address register
     */
    inline OCOTP_CTRL_ADDR get_CTRL_ADDR() volatile
    {
        return OCOTP_CTRL_ADDR((CTRL >> 0u) & 0b1111111111u);
    }

    /**
     * Set CTRL's ADDR field.
     *
     * OTP write and read access address register
     */
    inline void set_CTRL_ADDR(OCOTP_CTRL_ADDR value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111u) << 0u;

        CTRL = curr;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void get_CTRL(OCOTP_CTRL_WR_UNLOCK &WR_UNLOCK, bool &WORDLOCK,
                         bool &RELOAD_SHADOWS, bool &ERROR, bool &BUSY,
                         OCOTP_CTRL_ADDR &ADDR) volatile
    {
        uint32_t curr = CTRL;

        WR_UNLOCK = OCOTP_CTRL_WR_UNLOCK((curr >> 16u) & 0b1111111111111111u);
        WORDLOCK = curr & (1u << 15u);
        RELOAD_SHADOWS = curr & (1u << 12u);
        ERROR = curr & (1u << 11u);
        BUSY = curr & (1u << 10u);
        ADDR = OCOTP_CTRL_ADDR((curr >> 0u) & 0b1111111111u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void set_CTRL(OCOTP_CTRL_WR_UNLOCK WR_UNLOCK, bool WORDLOCK,
                         bool RELOAD_SHADOWS, bool ERROR,
                         OCOTP_CTRL_ADDR ADDR) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(WR_UNLOCK) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (WORDLOCK & 0b1u) << 15u;
        curr &= ~(0b1u << 12u);
        curr |= (RELOAD_SHADOWS & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERROR & 0b1u) << 11u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (std::to_underlying(ADDR) & 0b1111111111u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL_SET's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline uint16_t get_CTRL_SET_WR_UNLOCK() volatile
    {
        return (CTRL_SET >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL_SET's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline void set_CTRL_SET_WR_UNLOCK(uint16_t value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline bool get_CTRL_SET_WORDLOCK() volatile
    {
        return CTRL_SET & (1u << 15u);
    }

    /**
     * Set CTRL_SET's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void set_CTRL_SET_WORDLOCK() volatile
    {
        CTRL_SET |= 1u << 15u;
    }

    /**
     * Clear CTRL_SET's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void clear_CTRL_SET_WORDLOCK() volatile
    {
        CTRL_SET &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL_SET's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void toggle_CTRL_SET_WORDLOCK() volatile
    {
        CTRL_SET ^= 1u << 15u;
    }

    /**
     * Get CTRL_SET's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline bool get_CTRL_SET_RELOAD_SHADOWS() volatile
    {
        return CTRL_SET & (1u << 12u);
    }

    /**
     * Set CTRL_SET's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void set_CTRL_SET_RELOAD_SHADOWS() volatile
    {
        CTRL_SET |= 1u << 12u;
    }

    /**
     * Clear CTRL_SET's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void clear_CTRL_SET_RELOAD_SHADOWS() volatile
    {
        CTRL_SET &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL_SET's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void toggle_CTRL_SET_RELOAD_SHADOWS() volatile
    {
        CTRL_SET ^= 1u << 12u;
    }

    /**
     * Get CTRL_SET's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline bool get_CTRL_SET_ERROR() volatile
    {
        return CTRL_SET & (1u << 11u);
    }

    /**
     * Set CTRL_SET's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void set_CTRL_SET_ERROR() volatile
    {
        CTRL_SET |= 1u << 11u;
    }

    /**
     * Clear CTRL_SET's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void clear_CTRL_SET_ERROR() volatile
    {
        CTRL_SET &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_SET's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void toggle_CTRL_SET_ERROR() volatile
    {
        CTRL_SET ^= 1u << 11u;
    }

    /**
     * Get CTRL_SET's BUSY bit.
     *
     * OTP controller status bit
     */
    inline bool get_CTRL_SET_BUSY() volatile
    {
        return CTRL_SET & (1u << 10u);
    }

    /**
     * Get CTRL_SET's ADDR field.
     *
     * OTP write and read access address register
     */
    inline uint16_t get_CTRL_SET_ADDR() volatile
    {
        return (CTRL_SET >> 0u) & 0b1111111111u;
    }

    /**
     * Set CTRL_SET's ADDR field.
     *
     * OTP write and read access address register
     */
    inline void set_CTRL_SET_ADDR(uint16_t value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        CTRL_SET = curr;
    }

    /**
     * Get all of CTRL_SET's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void get_CTRL_SET(uint16_t &WR_UNLOCK, bool &WORDLOCK,
                             bool &RELOAD_SHADOWS, bool &ERROR, bool &BUSY,
                             uint16_t &ADDR) volatile
    {
        uint32_t curr = CTRL_SET;

        WR_UNLOCK = (curr >> 16u) & 0b1111111111111111u;
        WORDLOCK = curr & (1u << 15u);
        RELOAD_SHADOWS = curr & (1u << 12u);
        ERROR = curr & (1u << 11u);
        BUSY = curr & (1u << 10u);
        ADDR = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of CTRL_SET's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void set_CTRL_SET(uint16_t WR_UNLOCK, bool WORDLOCK,
                             bool RELOAD_SHADOWS, bool ERROR,
                             uint16_t ADDR) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (WR_UNLOCK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (WORDLOCK & 0b1u) << 15u;
        curr &= ~(0b1u << 12u);
        curr |= (RELOAD_SHADOWS & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERROR & 0b1u) << 11u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (ADDR & 0b1111111111u) << 0u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_CLR's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline uint16_t get_CTRL_CLR_WR_UNLOCK() volatile
    {
        return (CTRL_CLR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL_CLR's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline void set_CTRL_CLR_WR_UNLOCK(uint16_t value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline bool get_CTRL_CLR_WORDLOCK() volatile
    {
        return CTRL_CLR & (1u << 15u);
    }

    /**
     * Set CTRL_CLR's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void set_CTRL_CLR_WORDLOCK() volatile
    {
        CTRL_CLR |= 1u << 15u;
    }

    /**
     * Clear CTRL_CLR's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void clear_CTRL_CLR_WORDLOCK() volatile
    {
        CTRL_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL_CLR's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void toggle_CTRL_CLR_WORDLOCK() volatile
    {
        CTRL_CLR ^= 1u << 15u;
    }

    /**
     * Get CTRL_CLR's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline bool get_CTRL_CLR_RELOAD_SHADOWS() volatile
    {
        return CTRL_CLR & (1u << 12u);
    }

    /**
     * Set CTRL_CLR's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void set_CTRL_CLR_RELOAD_SHADOWS() volatile
    {
        CTRL_CLR |= 1u << 12u;
    }

    /**
     * Clear CTRL_CLR's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void clear_CTRL_CLR_RELOAD_SHADOWS() volatile
    {
        CTRL_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL_CLR's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void toggle_CTRL_CLR_RELOAD_SHADOWS() volatile
    {
        CTRL_CLR ^= 1u << 12u;
    }

    /**
     * Get CTRL_CLR's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline bool get_CTRL_CLR_ERROR() volatile
    {
        return CTRL_CLR & (1u << 11u);
    }

    /**
     * Set CTRL_CLR's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void set_CTRL_CLR_ERROR() volatile
    {
        CTRL_CLR |= 1u << 11u;
    }

    /**
     * Clear CTRL_CLR's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void clear_CTRL_CLR_ERROR() volatile
    {
        CTRL_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_CLR's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void toggle_CTRL_CLR_ERROR() volatile
    {
        CTRL_CLR ^= 1u << 11u;
    }

    /**
     * Get CTRL_CLR's BUSY bit.
     *
     * OTP controller status bit
     */
    inline bool get_CTRL_CLR_BUSY() volatile
    {
        return CTRL_CLR & (1u << 10u);
    }

    /**
     * Get CTRL_CLR's ADDR field.
     *
     * OTP write and read access address register
     */
    inline uint16_t get_CTRL_CLR_ADDR() volatile
    {
        return (CTRL_CLR >> 0u) & 0b1111111111u;
    }

    /**
     * Set CTRL_CLR's ADDR field.
     *
     * OTP write and read access address register
     */
    inline void set_CTRL_CLR_ADDR(uint16_t value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        CTRL_CLR = curr;
    }

    /**
     * Get all of CTRL_CLR's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void get_CTRL_CLR(uint16_t &WR_UNLOCK, bool &WORDLOCK,
                             bool &RELOAD_SHADOWS, bool &ERROR, bool &BUSY,
                             uint16_t &ADDR) volatile
    {
        uint32_t curr = CTRL_CLR;

        WR_UNLOCK = (curr >> 16u) & 0b1111111111111111u;
        WORDLOCK = curr & (1u << 15u);
        RELOAD_SHADOWS = curr & (1u << 12u);
        ERROR = curr & (1u << 11u);
        BUSY = curr & (1u << 10u);
        ADDR = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of CTRL_CLR's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void set_CTRL_CLR(uint16_t WR_UNLOCK, bool WORDLOCK,
                             bool RELOAD_SHADOWS, bool ERROR,
                             uint16_t ADDR) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (WR_UNLOCK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (WORDLOCK & 0b1u) << 15u;
        curr &= ~(0b1u << 12u);
        curr |= (RELOAD_SHADOWS & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERROR & 0b1u) << 11u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (ADDR & 0b1111111111u) << 0u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_TOG's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline uint16_t get_CTRL_TOG_WR_UNLOCK() volatile
    {
        return (CTRL_TOG >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL_TOG's WR_UNLOCK field.
     *
     * Write unlock
     */
    inline void set_CTRL_TOG_WR_UNLOCK(uint16_t value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline bool get_CTRL_TOG_WORDLOCK() volatile
    {
        return CTRL_TOG & (1u << 15u);
    }

    /**
     * Set CTRL_TOG's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void set_CTRL_TOG_WORDLOCK() volatile
    {
        CTRL_TOG |= 1u << 15u;
    }

    /**
     * Clear CTRL_TOG's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void clear_CTRL_TOG_WORDLOCK() volatile
    {
        CTRL_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL_TOG's WORDLOCK bit.
     *
     * Lock fuse word
     */
    inline void toggle_CTRL_TOG_WORDLOCK() volatile
    {
        CTRL_TOG ^= 1u << 15u;
    }

    /**
     * Get CTRL_TOG's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline bool get_CTRL_TOG_RELOAD_SHADOWS() volatile
    {
        return CTRL_TOG & (1u << 12u);
    }

    /**
     * Set CTRL_TOG's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void set_CTRL_TOG_RELOAD_SHADOWS() volatile
    {
        CTRL_TOG |= 1u << 12u;
    }

    /**
     * Clear CTRL_TOG's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void clear_CTRL_TOG_RELOAD_SHADOWS() volatile
    {
        CTRL_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL_TOG's RELOAD_SHADOWS bit.
     *
     * Reload Shadow Registers
     */
    inline void toggle_CTRL_TOG_RELOAD_SHADOWS() volatile
    {
        CTRL_TOG ^= 1u << 12u;
    }

    /**
     * Get CTRL_TOG's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline bool get_CTRL_TOG_ERROR() volatile
    {
        return CTRL_TOG & (1u << 11u);
    }

    /**
     * Set CTRL_TOG's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void set_CTRL_TOG_ERROR() volatile
    {
        CTRL_TOG |= 1u << 11u;
    }

    /**
     * Clear CTRL_TOG's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void clear_CTRL_TOG_ERROR() volatile
    {
        CTRL_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_TOG's ERROR bit.
     *
     * Locked Region Access Error
     */
    inline void toggle_CTRL_TOG_ERROR() volatile
    {
        CTRL_TOG ^= 1u << 11u;
    }

    /**
     * Get CTRL_TOG's BUSY bit.
     *
     * OTP controller status bit
     */
    inline bool get_CTRL_TOG_BUSY() volatile
    {
        return CTRL_TOG & (1u << 10u);
    }

    /**
     * Get CTRL_TOG's ADDR field.
     *
     * OTP write and read access address register
     */
    inline uint16_t get_CTRL_TOG_ADDR() volatile
    {
        return (CTRL_TOG >> 0u) & 0b1111111111u;
    }

    /**
     * Set CTRL_TOG's ADDR field.
     *
     * OTP write and read access address register
     */
    inline void set_CTRL_TOG_ADDR(uint16_t value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        CTRL_TOG = curr;
    }

    /**
     * Get all of CTRL_TOG's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void get_CTRL_TOG(uint16_t &WR_UNLOCK, bool &WORDLOCK,
                             bool &RELOAD_SHADOWS, bool &ERROR, bool &BUSY,
                             uint16_t &ADDR) volatile
    {
        uint32_t curr = CTRL_TOG;

        WR_UNLOCK = (curr >> 16u) & 0b1111111111111111u;
        WORDLOCK = curr & (1u << 15u);
        RELOAD_SHADOWS = curr & (1u << 12u);
        ERROR = curr & (1u << 11u);
        BUSY = curr & (1u << 10u);
        ADDR = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of CTRL_TOG's bit fields.
     *
     * (read-write) OTP Controller Control and Status Register
     */
    inline void set_CTRL_TOG(uint16_t WR_UNLOCK, bool WORDLOCK,
                             bool RELOAD_SHADOWS, bool ERROR,
                             uint16_t ADDR) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (WR_UNLOCK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (WORDLOCK & 0b1u) << 15u;
        curr &= ~(0b1u << 12u);
        curr |= (RELOAD_SHADOWS & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERROR & 0b1u) << 11u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (ADDR & 0b1111111111u) << 0u;

        CTRL_TOG = curr;
    }

    /**
     * Get PDN's PDN bit.
     *
     * PDN value
     */
    inline bool get_PDN_PDN() volatile
    {
        return PDN & (1u << 0u);
    }

    /**
     * Set PDN's PDN bit.
     *
     * PDN value
     */
    inline void set_PDN_PDN() volatile
    {
        PDN |= 1u << 0u;
    }

    /**
     * Clear PDN's PDN bit.
     *
     * PDN value
     */
    inline void clear_PDN_PDN() volatile
    {
        PDN &= ~(1u << 0u);
    }

    /**
     * Toggle PDN's PDN bit.
     *
     * PDN value
     */
    inline void toggle_PDN_PDN() volatile
    {
        PDN ^= 1u << 0u;
    }

    /**
     * Get DATA's DATA field.
     *
     * Data
     */
    inline uint32_t get_DATA_DATA() volatile
    {
        return (DATA >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DATA's DATA field.
     *
     * Data
     */
    inline void set_DATA_DATA(uint32_t value) volatile
    {
        uint32_t curr = DATA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DATA = curr;
    }

    /**
     * Get READ_CTRL's READ_FUSE_ERROR_INTR_ENA bit.
     *
     * Enable read-error interrupt
     */
    inline bool get_READ_CTRL_READ_FUSE_ERROR_INTR_ENA() volatile
    {
        return READ_CTRL & (1u << 4u);
    }

    /**
     * Set READ_CTRL's READ_FUSE_ERROR_INTR_ENA bit.
     *
     * Enable read-error interrupt
     */
    inline void set_READ_CTRL_READ_FUSE_ERROR_INTR_ENA() volatile
    {
        READ_CTRL |= 1u << 4u;
    }

    /**
     * Clear READ_CTRL's READ_FUSE_ERROR_INTR_ENA bit.
     *
     * Enable read-error interrupt
     */
    inline void clear_READ_CTRL_READ_FUSE_ERROR_INTR_ENA() volatile
    {
        READ_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle READ_CTRL's READ_FUSE_ERROR_INTR_ENA bit.
     *
     * Enable read-error interrupt
     */
    inline void toggle_READ_CTRL_READ_FUSE_ERROR_INTR_ENA() volatile
    {
        READ_CTRL ^= 1u << 4u;
    }

    /**
     * Get READ_CTRL's READ_FUSE_DONE_INTR_ENA bit.
     *
     * Enable read-done interrupt
     */
    inline bool get_READ_CTRL_READ_FUSE_DONE_INTR_ENA() volatile
    {
        return READ_CTRL & (1u << 3u);
    }

    /**
     * Set READ_CTRL's READ_FUSE_DONE_INTR_ENA bit.
     *
     * Enable read-done interrupt
     */
    inline void set_READ_CTRL_READ_FUSE_DONE_INTR_ENA() volatile
    {
        READ_CTRL |= 1u << 3u;
    }

    /**
     * Clear READ_CTRL's READ_FUSE_DONE_INTR_ENA bit.
     *
     * Enable read-done interrupt
     */
    inline void clear_READ_CTRL_READ_FUSE_DONE_INTR_ENA() volatile
    {
        READ_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle READ_CTRL's READ_FUSE_DONE_INTR_ENA bit.
     *
     * Enable read-done interrupt
     */
    inline void toggle_READ_CTRL_READ_FUSE_DONE_INTR_ENA() volatile
    {
        READ_CTRL ^= 1u << 3u;
    }

    /**
     * Get READ_CTRL's READ_FUSE_CNTR field.
     *
     * Number of words to read.
     */
    inline OCOTP_READ_CTRL_READ_FUSE_CNTR
    get_READ_CTRL_READ_FUSE_CNTR() volatile
    {
        return OCOTP_READ_CTRL_READ_FUSE_CNTR((READ_CTRL >> 1u) & 0b11u);
    }

    /**
     * Set READ_CTRL's READ_FUSE_CNTR field.
     *
     * Number of words to read.
     */
    inline void set_READ_CTRL_READ_FUSE_CNTR(
        OCOTP_READ_CTRL_READ_FUSE_CNTR value) volatile
    {
        uint32_t curr = READ_CTRL;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        READ_CTRL = curr;
    }

    /**
     * Get READ_CTRL's READ_FUSE bit.
     *
     * Read Fuse
     */
    inline bool get_READ_CTRL_READ_FUSE() volatile
    {
        return READ_CTRL & (1u << 0u);
    }

    /**
     * Set READ_CTRL's READ_FUSE bit.
     *
     * Read Fuse
     */
    inline void set_READ_CTRL_READ_FUSE() volatile
    {
        READ_CTRL |= 1u << 0u;
    }

    /**
     * Clear READ_CTRL's READ_FUSE bit.
     *
     * Read Fuse
     */
    inline void clear_READ_CTRL_READ_FUSE() volatile
    {
        READ_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle READ_CTRL's READ_FUSE bit.
     *
     * Read Fuse
     */
    inline void toggle_READ_CTRL_READ_FUSE() volatile
    {
        READ_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of READ_CTRL's bit fields.
     *
     * (read-write) OTP Controller Read Control Register
     */
    inline void get_READ_CTRL(bool &READ_FUSE_ERROR_INTR_ENA,
                              bool &READ_FUSE_DONE_INTR_ENA,
                              OCOTP_READ_CTRL_READ_FUSE_CNTR &READ_FUSE_CNTR,
                              bool &READ_FUSE) volatile
    {
        uint32_t curr = READ_CTRL;

        READ_FUSE_ERROR_INTR_ENA = curr & (1u << 4u);
        READ_FUSE_DONE_INTR_ENA = curr & (1u << 3u);
        READ_FUSE_CNTR = OCOTP_READ_CTRL_READ_FUSE_CNTR((curr >> 1u) & 0b11u);
        READ_FUSE = curr & (1u << 0u);
    }

    /**
     * Set all of READ_CTRL's bit fields.
     *
     * (read-write) OTP Controller Read Control Register
     */
    inline void set_READ_CTRL(bool READ_FUSE_ERROR_INTR_ENA,
                              bool READ_FUSE_DONE_INTR_ENA,
                              OCOTP_READ_CTRL_READ_FUSE_CNTR READ_FUSE_CNTR,
                              bool READ_FUSE) volatile
    {
        uint32_t curr = READ_CTRL;

        curr &= ~(0b1u << 4u);
        curr |= (READ_FUSE_ERROR_INTR_ENA & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (READ_FUSE_DONE_INTR_ENA & 0b1u) << 3u;
        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(READ_FUSE_CNTR) & 0b11u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (READ_FUSE & 0b1u) << 0u;

        READ_CTRL = curr;
    }

    /**
     * Get OUT_STATUS's DED3 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_DED3() volatile
    {
        return OUT_STATUS & (1u << 27u);
    }

    /**
     * Set OUT_STATUS's DED3 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_DED3() volatile
    {
        OUT_STATUS |= 1u << 27u;
    }

    /**
     * Clear OUT_STATUS's DED3 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_DED3() volatile
    {
        OUT_STATUS &= ~(1u << 27u);
    }

    /**
     * Toggle OUT_STATUS's DED3 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_DED3() volatile
    {
        OUT_STATUS ^= 1u << 27u;
    }

    /**
     * Get OUT_STATUS's DED2 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_DED2() volatile
    {
        return OUT_STATUS & (1u << 26u);
    }

    /**
     * Set OUT_STATUS's DED2 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_DED2() volatile
    {
        OUT_STATUS |= 1u << 26u;
    }

    /**
     * Clear OUT_STATUS's DED2 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_DED2() volatile
    {
        OUT_STATUS &= ~(1u << 26u);
    }

    /**
     * Toggle OUT_STATUS's DED2 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_DED2() volatile
    {
        OUT_STATUS ^= 1u << 26u;
    }

    /**
     * Get OUT_STATUS's DED1 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_DED1() volatile
    {
        return OUT_STATUS & (1u << 25u);
    }

    /**
     * Set OUT_STATUS's DED1 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_DED1() volatile
    {
        OUT_STATUS |= 1u << 25u;
    }

    /**
     * Clear OUT_STATUS's DED1 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_DED1() volatile
    {
        OUT_STATUS &= ~(1u << 25u);
    }

    /**
     * Toggle OUT_STATUS's DED1 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_DED1() volatile
    {
        OUT_STATUS ^= 1u << 25u;
    }

    /**
     * Get OUT_STATUS's DED0 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_DED0() volatile
    {
        return OUT_STATUS & (1u << 24u);
    }

    /**
     * Set OUT_STATUS's DED0 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_DED0() volatile
    {
        OUT_STATUS |= 1u << 24u;
    }

    /**
     * Clear OUT_STATUS's DED0 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_DED0() volatile
    {
        OUT_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle OUT_STATUS's DED0 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_DED0() volatile
    {
        OUT_STATUS ^= 1u << 24u;
    }

    /**
     * Get OUT_STATUS's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline bool get_OUT_STATUS_READ_ERROR_INTR() volatile
    {
        return OUT_STATUS & (1u << 23u);
    }

    /**
     * Set OUT_STATUS's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void set_OUT_STATUS_READ_ERROR_INTR() volatile
    {
        OUT_STATUS |= 1u << 23u;
    }

    /**
     * Clear OUT_STATUS's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void clear_OUT_STATUS_READ_ERROR_INTR() volatile
    {
        OUT_STATUS &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_STATUS's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void toggle_OUT_STATUS_READ_ERROR_INTR() volatile
    {
        OUT_STATUS ^= 1u << 23u;
    }

    /**
     * Get OUT_STATUS's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline bool get_OUT_STATUS_READ_DONE_INTR() volatile
    {
        return OUT_STATUS & (1u << 22u);
    }

    /**
     * Set OUT_STATUS's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void set_OUT_STATUS_READ_DONE_INTR() volatile
    {
        OUT_STATUS |= 1u << 22u;
    }

    /**
     * Clear OUT_STATUS's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void clear_OUT_STATUS_READ_DONE_INTR() volatile
    {
        OUT_STATUS &= ~(1u << 22u);
    }

    /**
     * Toggle OUT_STATUS's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void toggle_OUT_STATUS_READ_DONE_INTR() volatile
    {
        OUT_STATUS ^= 1u << 22u;
    }

    /**
     * Get OUT_STATUS's CALIBRATED bit.
     *
     * Calibrated status
     */
    inline bool get_OUT_STATUS_CALIBRATED() volatile
    {
        return OUT_STATUS & (1u << 21u);
    }

    /**
     * Get OUT_STATUS's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline bool get_OUT_STATUS_DED_RELOAD() volatile
    {
        return OUT_STATUS & (1u << 20u);
    }

    /**
     * Set OUT_STATUS's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void set_OUT_STATUS_DED_RELOAD() volatile
    {
        OUT_STATUS |= 1u << 20u;
    }

    /**
     * Clear OUT_STATUS's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void clear_OUT_STATUS_DED_RELOAD() volatile
    {
        OUT_STATUS &= ~(1u << 20u);
    }

    /**
     * Toggle OUT_STATUS's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void toggle_OUT_STATUS_DED_RELOAD() volatile
    {
        OUT_STATUS ^= 1u << 20u;
    }

    /**
     * Get OUT_STATUS's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline bool get_OUT_STATUS_SEC_RELOAD() volatile
    {
        return OUT_STATUS & (1u << 19u);
    }

    /**
     * Set OUT_STATUS's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void set_OUT_STATUS_SEC_RELOAD() volatile
    {
        OUT_STATUS |= 1u << 19u;
    }

    /**
     * Clear OUT_STATUS's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void clear_OUT_STATUS_SEC_RELOAD() volatile
    {
        OUT_STATUS &= ~(1u << 19u);
    }

    /**
     * Toggle OUT_STATUS's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void toggle_OUT_STATUS_SEC_RELOAD() volatile
    {
        OUT_STATUS ^= 1u << 19u;
    }

    /**
     * Get OUT_STATUS's FLAGSTATE field.
     *
     * Flag state
     */
    inline uint8_t get_OUT_STATUS_FLAGSTATE() volatile
    {
        return (OUT_STATUS >> 15u) & 0b1111u;
    }

    /**
     * Get OUT_STATUS's PWOK bit.
     *
     * Power OK
     */
    inline bool get_OUT_STATUS_PWOK() volatile
    {
        return OUT_STATUS & (1u << 14u);
    }

    /**
     * Get OUT_STATUS's ACK bit.
     *
     * Acknowledge
     */
    inline bool get_OUT_STATUS_ACK() volatile
    {
        return OUT_STATUS & (1u << 13u);
    }

    /**
     * Get OUT_STATUS's PROGFAIL bit.
     *
     * Programming failed
     */
    inline bool get_OUT_STATUS_PROGFAIL() volatile
    {
        return OUT_STATUS & (1u << 12u);
    }

    /**
     * Set OUT_STATUS's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void set_OUT_STATUS_PROGFAIL() volatile
    {
        OUT_STATUS |= 1u << 12u;
    }

    /**
     * Clear OUT_STATUS's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void clear_OUT_STATUS_PROGFAIL() volatile
    {
        OUT_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle OUT_STATUS's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void toggle_OUT_STATUS_PROGFAIL() volatile
    {
        OUT_STATUS ^= 1u << 12u;
    }

    /**
     * Get OUT_STATUS's LOCKED bit.
     *
     * Word Locked
     */
    inline bool get_OUT_STATUS_LOCKED() volatile
    {
        return OUT_STATUS & (1u << 11u);
    }

    /**
     * Set OUT_STATUS's LOCKED bit.
     *
     * Word Locked
     */
    inline void set_OUT_STATUS_LOCKED() volatile
    {
        OUT_STATUS |= 1u << 11u;
    }

    /**
     * Clear OUT_STATUS's LOCKED bit.
     *
     * Word Locked
     */
    inline void clear_OUT_STATUS_LOCKED() volatile
    {
        OUT_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle OUT_STATUS's LOCKED bit.
     *
     * Word Locked
     */
    inline void toggle_OUT_STATUS_LOCKED() volatile
    {
        OUT_STATUS ^= 1u << 11u;
    }

    /**
     * Get OUT_STATUS's DED bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_DED() volatile
    {
        return OUT_STATUS & (1u << 10u);
    }

    /**
     * Set OUT_STATUS's DED bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_DED() volatile
    {
        OUT_STATUS |= 1u << 10u;
    }

    /**
     * Clear OUT_STATUS's DED bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_DED() volatile
    {
        OUT_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle OUT_STATUS's DED bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_DED() volatile
    {
        OUT_STATUS ^= 1u << 10u;
    }

    /**
     * Get OUT_STATUS's SEC bit.
     *
     * Single Error Correct
     */
    inline bool get_OUT_STATUS_SEC() volatile
    {
        return OUT_STATUS & (1u << 9u);
    }

    /**
     * Set OUT_STATUS's SEC bit.
     *
     * Single Error Correct
     */
    inline void set_OUT_STATUS_SEC() volatile
    {
        OUT_STATUS |= 1u << 9u;
    }

    /**
     * Clear OUT_STATUS's SEC bit.
     *
     * Single Error Correct
     */
    inline void clear_OUT_STATUS_SEC() volatile
    {
        OUT_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle OUT_STATUS's SEC bit.
     *
     * Single Error Correct
     */
    inline void toggle_OUT_STATUS_SEC() volatile
    {
        OUT_STATUS ^= 1u << 9u;
    }

    /**
     * Get all of OUT_STATUS's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void get_OUT_STATUS(bool &DED3, bool &DED2, bool &DED1, bool &DED0,
                               bool &READ_ERROR_INTR, bool &READ_DONE_INTR,
                               bool &CALIBRATED, bool &DED_RELOAD,
                               bool &SEC_RELOAD, uint8_t &FLAGSTATE,
                               bool &PWOK, bool &ACK, bool &PROGFAIL,
                               bool &LOCKED, bool &DED, bool &SEC) volatile
    {
        uint32_t curr = OUT_STATUS;

        DED3 = curr & (1u << 27u);
        DED2 = curr & (1u << 26u);
        DED1 = curr & (1u << 25u);
        DED0 = curr & (1u << 24u);
        READ_ERROR_INTR = curr & (1u << 23u);
        READ_DONE_INTR = curr & (1u << 22u);
        CALIBRATED = curr & (1u << 21u);
        DED_RELOAD = curr & (1u << 20u);
        SEC_RELOAD = curr & (1u << 19u);
        FLAGSTATE = (curr >> 15u) & 0b1111u;
        PWOK = curr & (1u << 14u);
        ACK = curr & (1u << 13u);
        PROGFAIL = curr & (1u << 12u);
        LOCKED = curr & (1u << 11u);
        DED = curr & (1u << 10u);
        SEC = curr & (1u << 9u);
    }

    /**
     * Set all of OUT_STATUS's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void set_OUT_STATUS(bool DED3, bool DED2, bool DED1, bool DED0,
                               bool READ_ERROR_INTR, bool READ_DONE_INTR,
                               bool DED_RELOAD, bool SEC_RELOAD, bool PROGFAIL,
                               bool LOCKED, bool DED, bool SEC) volatile
    {
        uint32_t curr = OUT_STATUS;

        curr &= ~(0b1u << 27u);
        curr |= (DED3 & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (DED2 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DED1 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (DED0 & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (READ_ERROR_INTR & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (READ_DONE_INTR & 0b1u) << 22u;
        curr &= ~(0b1u << 20u);
        curr |= (DED_RELOAD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (SEC_RELOAD & 0b1u) << 19u;
        curr &= ~(0b1u << 12u);
        curr |= (PROGFAIL & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LOCKED & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (DED & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SEC & 0b1u) << 9u;

        OUT_STATUS = curr;
    }

    /**
     * Get OUT_STATUS_SET's DED3 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_SET_DED3() volatile
    {
        return OUT_STATUS_SET & (1u << 27u);
    }

    /**
     * Set OUT_STATUS_SET's DED3 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_SET_DED3() volatile
    {
        OUT_STATUS_SET |= 1u << 27u;
    }

    /**
     * Clear OUT_STATUS_SET's DED3 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_SET_DED3() volatile
    {
        OUT_STATUS_SET &= ~(1u << 27u);
    }

    /**
     * Toggle OUT_STATUS_SET's DED3 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_SET_DED3() volatile
    {
        OUT_STATUS_SET ^= 1u << 27u;
    }

    /**
     * Get OUT_STATUS_SET's DED2 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_SET_DED2() volatile
    {
        return OUT_STATUS_SET & (1u << 26u);
    }

    /**
     * Set OUT_STATUS_SET's DED2 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_SET_DED2() volatile
    {
        OUT_STATUS_SET |= 1u << 26u;
    }

    /**
     * Clear OUT_STATUS_SET's DED2 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_SET_DED2() volatile
    {
        OUT_STATUS_SET &= ~(1u << 26u);
    }

    /**
     * Toggle OUT_STATUS_SET's DED2 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_SET_DED2() volatile
    {
        OUT_STATUS_SET ^= 1u << 26u;
    }

    /**
     * Get OUT_STATUS_SET's DED1 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_SET_DED1() volatile
    {
        return OUT_STATUS_SET & (1u << 25u);
    }

    /**
     * Set OUT_STATUS_SET's DED1 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_SET_DED1() volatile
    {
        OUT_STATUS_SET |= 1u << 25u;
    }

    /**
     * Clear OUT_STATUS_SET's DED1 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_SET_DED1() volatile
    {
        OUT_STATUS_SET &= ~(1u << 25u);
    }

    /**
     * Toggle OUT_STATUS_SET's DED1 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_SET_DED1() volatile
    {
        OUT_STATUS_SET ^= 1u << 25u;
    }

    /**
     * Get OUT_STATUS_SET's DED0 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_SET_DED0() volatile
    {
        return OUT_STATUS_SET & (1u << 24u);
    }

    /**
     * Set OUT_STATUS_SET's DED0 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_SET_DED0() volatile
    {
        OUT_STATUS_SET |= 1u << 24u;
    }

    /**
     * Clear OUT_STATUS_SET's DED0 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_SET_DED0() volatile
    {
        OUT_STATUS_SET &= ~(1u << 24u);
    }

    /**
     * Toggle OUT_STATUS_SET's DED0 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_SET_DED0() volatile
    {
        OUT_STATUS_SET ^= 1u << 24u;
    }

    /**
     * Get OUT_STATUS_SET's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline bool get_OUT_STATUS_SET_READ_ERROR_INTR() volatile
    {
        return OUT_STATUS_SET & (1u << 23u);
    }

    /**
     * Set OUT_STATUS_SET's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void set_OUT_STATUS_SET_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_SET |= 1u << 23u;
    }

    /**
     * Clear OUT_STATUS_SET's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void clear_OUT_STATUS_SET_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_SET &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_STATUS_SET's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void toggle_OUT_STATUS_SET_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_SET ^= 1u << 23u;
    }

    /**
     * Get OUT_STATUS_SET's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline bool get_OUT_STATUS_SET_READ_DONE_INTR() volatile
    {
        return OUT_STATUS_SET & (1u << 22u);
    }

    /**
     * Set OUT_STATUS_SET's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void set_OUT_STATUS_SET_READ_DONE_INTR() volatile
    {
        OUT_STATUS_SET |= 1u << 22u;
    }

    /**
     * Clear OUT_STATUS_SET's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void clear_OUT_STATUS_SET_READ_DONE_INTR() volatile
    {
        OUT_STATUS_SET &= ~(1u << 22u);
    }

    /**
     * Toggle OUT_STATUS_SET's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void toggle_OUT_STATUS_SET_READ_DONE_INTR() volatile
    {
        OUT_STATUS_SET ^= 1u << 22u;
    }

    /**
     * Get OUT_STATUS_SET's CALIBRATED bit.
     *
     * Calibrated status
     */
    inline bool get_OUT_STATUS_SET_CALIBRATED() volatile
    {
        return OUT_STATUS_SET & (1u << 21u);
    }

    /**
     * Get OUT_STATUS_SET's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline bool get_OUT_STATUS_SET_DED_RELOAD() volatile
    {
        return OUT_STATUS_SET & (1u << 20u);
    }

    /**
     * Set OUT_STATUS_SET's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void set_OUT_STATUS_SET_DED_RELOAD() volatile
    {
        OUT_STATUS_SET |= 1u << 20u;
    }

    /**
     * Clear OUT_STATUS_SET's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void clear_OUT_STATUS_SET_DED_RELOAD() volatile
    {
        OUT_STATUS_SET &= ~(1u << 20u);
    }

    /**
     * Toggle OUT_STATUS_SET's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void toggle_OUT_STATUS_SET_DED_RELOAD() volatile
    {
        OUT_STATUS_SET ^= 1u << 20u;
    }

    /**
     * Get OUT_STATUS_SET's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline bool get_OUT_STATUS_SET_SEC_RELOAD() volatile
    {
        return OUT_STATUS_SET & (1u << 19u);
    }

    /**
     * Set OUT_STATUS_SET's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void set_OUT_STATUS_SET_SEC_RELOAD() volatile
    {
        OUT_STATUS_SET |= 1u << 19u;
    }

    /**
     * Clear OUT_STATUS_SET's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void clear_OUT_STATUS_SET_SEC_RELOAD() volatile
    {
        OUT_STATUS_SET &= ~(1u << 19u);
    }

    /**
     * Toggle OUT_STATUS_SET's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void toggle_OUT_STATUS_SET_SEC_RELOAD() volatile
    {
        OUT_STATUS_SET ^= 1u << 19u;
    }

    /**
     * Get OUT_STATUS_SET's FLAGSTATE field.
     *
     * Flag state
     */
    inline uint8_t get_OUT_STATUS_SET_FLAGSTATE() volatile
    {
        return (OUT_STATUS_SET >> 15u) & 0b1111u;
    }

    /**
     * Get OUT_STATUS_SET's PWOK bit.
     *
     * Power OK
     */
    inline bool get_OUT_STATUS_SET_PWOK() volatile
    {
        return OUT_STATUS_SET & (1u << 14u);
    }

    /**
     * Get OUT_STATUS_SET's ACK bit.
     *
     * Acknowledge
     */
    inline bool get_OUT_STATUS_SET_ACK() volatile
    {
        return OUT_STATUS_SET & (1u << 13u);
    }

    /**
     * Get OUT_STATUS_SET's PROGFAIL bit.
     *
     * Programming failed
     */
    inline bool get_OUT_STATUS_SET_PROGFAIL() volatile
    {
        return OUT_STATUS_SET & (1u << 12u);
    }

    /**
     * Set OUT_STATUS_SET's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void set_OUT_STATUS_SET_PROGFAIL() volatile
    {
        OUT_STATUS_SET |= 1u << 12u;
    }

    /**
     * Clear OUT_STATUS_SET's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void clear_OUT_STATUS_SET_PROGFAIL() volatile
    {
        OUT_STATUS_SET &= ~(1u << 12u);
    }

    /**
     * Toggle OUT_STATUS_SET's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void toggle_OUT_STATUS_SET_PROGFAIL() volatile
    {
        OUT_STATUS_SET ^= 1u << 12u;
    }

    /**
     * Get OUT_STATUS_SET's LOCKED bit.
     *
     * Word Locked
     */
    inline bool get_OUT_STATUS_SET_LOCKED() volatile
    {
        return OUT_STATUS_SET & (1u << 11u);
    }

    /**
     * Set OUT_STATUS_SET's LOCKED bit.
     *
     * Word Locked
     */
    inline void set_OUT_STATUS_SET_LOCKED() volatile
    {
        OUT_STATUS_SET |= 1u << 11u;
    }

    /**
     * Clear OUT_STATUS_SET's LOCKED bit.
     *
     * Word Locked
     */
    inline void clear_OUT_STATUS_SET_LOCKED() volatile
    {
        OUT_STATUS_SET &= ~(1u << 11u);
    }

    /**
     * Toggle OUT_STATUS_SET's LOCKED bit.
     *
     * Word Locked
     */
    inline void toggle_OUT_STATUS_SET_LOCKED() volatile
    {
        OUT_STATUS_SET ^= 1u << 11u;
    }

    /**
     * Get OUT_STATUS_SET's DED bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_SET_DED() volatile
    {
        return OUT_STATUS_SET & (1u << 10u);
    }

    /**
     * Set OUT_STATUS_SET's DED bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_SET_DED() volatile
    {
        OUT_STATUS_SET |= 1u << 10u;
    }

    /**
     * Clear OUT_STATUS_SET's DED bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_SET_DED() volatile
    {
        OUT_STATUS_SET &= ~(1u << 10u);
    }

    /**
     * Toggle OUT_STATUS_SET's DED bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_SET_DED() volatile
    {
        OUT_STATUS_SET ^= 1u << 10u;
    }

    /**
     * Get OUT_STATUS_SET's SEC bit.
     *
     * Single Error Correct
     */
    inline bool get_OUT_STATUS_SET_SEC() volatile
    {
        return OUT_STATUS_SET & (1u << 9u);
    }

    /**
     * Set OUT_STATUS_SET's SEC bit.
     *
     * Single Error Correct
     */
    inline void set_OUT_STATUS_SET_SEC() volatile
    {
        OUT_STATUS_SET |= 1u << 9u;
    }

    /**
     * Clear OUT_STATUS_SET's SEC bit.
     *
     * Single Error Correct
     */
    inline void clear_OUT_STATUS_SET_SEC() volatile
    {
        OUT_STATUS_SET &= ~(1u << 9u);
    }

    /**
     * Toggle OUT_STATUS_SET's SEC bit.
     *
     * Single Error Correct
     */
    inline void toggle_OUT_STATUS_SET_SEC() volatile
    {
        OUT_STATUS_SET ^= 1u << 9u;
    }

    /**
     * Get all of OUT_STATUS_SET's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void get_OUT_STATUS_SET(bool &DED3, bool &DED2, bool &DED1,
                                   bool &DED0, bool &READ_ERROR_INTR,
                                   bool &READ_DONE_INTR, bool &CALIBRATED,
                                   bool &DED_RELOAD, bool &SEC_RELOAD,
                                   uint8_t &FLAGSTATE, bool &PWOK, bool &ACK,
                                   bool &PROGFAIL, bool &LOCKED, bool &DED,
                                   bool &SEC) volatile
    {
        uint32_t curr = OUT_STATUS_SET;

        DED3 = curr & (1u << 27u);
        DED2 = curr & (1u << 26u);
        DED1 = curr & (1u << 25u);
        DED0 = curr & (1u << 24u);
        READ_ERROR_INTR = curr & (1u << 23u);
        READ_DONE_INTR = curr & (1u << 22u);
        CALIBRATED = curr & (1u << 21u);
        DED_RELOAD = curr & (1u << 20u);
        SEC_RELOAD = curr & (1u << 19u);
        FLAGSTATE = (curr >> 15u) & 0b1111u;
        PWOK = curr & (1u << 14u);
        ACK = curr & (1u << 13u);
        PROGFAIL = curr & (1u << 12u);
        LOCKED = curr & (1u << 11u);
        DED = curr & (1u << 10u);
        SEC = curr & (1u << 9u);
    }

    /**
     * Set all of OUT_STATUS_SET's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void set_OUT_STATUS_SET(bool DED3, bool DED2, bool DED1, bool DED0,
                                   bool READ_ERROR_INTR, bool READ_DONE_INTR,
                                   bool DED_RELOAD, bool SEC_RELOAD,
                                   bool PROGFAIL, bool LOCKED, bool DED,
                                   bool SEC) volatile
    {
        uint32_t curr = OUT_STATUS_SET;

        curr &= ~(0b1u << 27u);
        curr |= (DED3 & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (DED2 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DED1 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (DED0 & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (READ_ERROR_INTR & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (READ_DONE_INTR & 0b1u) << 22u;
        curr &= ~(0b1u << 20u);
        curr |= (DED_RELOAD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (SEC_RELOAD & 0b1u) << 19u;
        curr &= ~(0b1u << 12u);
        curr |= (PROGFAIL & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LOCKED & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (DED & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SEC & 0b1u) << 9u;

        OUT_STATUS_SET = curr;
    }

    /**
     * Get OUT_STATUS_CLR's DED3 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_CLR_DED3() volatile
    {
        return OUT_STATUS_CLR & (1u << 27u);
    }

    /**
     * Set OUT_STATUS_CLR's DED3 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_CLR_DED3() volatile
    {
        OUT_STATUS_CLR |= 1u << 27u;
    }

    /**
     * Clear OUT_STATUS_CLR's DED3 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_CLR_DED3() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 27u);
    }

    /**
     * Toggle OUT_STATUS_CLR's DED3 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_CLR_DED3() volatile
    {
        OUT_STATUS_CLR ^= 1u << 27u;
    }

    /**
     * Get OUT_STATUS_CLR's DED2 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_CLR_DED2() volatile
    {
        return OUT_STATUS_CLR & (1u << 26u);
    }

    /**
     * Set OUT_STATUS_CLR's DED2 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_CLR_DED2() volatile
    {
        OUT_STATUS_CLR |= 1u << 26u;
    }

    /**
     * Clear OUT_STATUS_CLR's DED2 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_CLR_DED2() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 26u);
    }

    /**
     * Toggle OUT_STATUS_CLR's DED2 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_CLR_DED2() volatile
    {
        OUT_STATUS_CLR ^= 1u << 26u;
    }

    /**
     * Get OUT_STATUS_CLR's DED1 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_CLR_DED1() volatile
    {
        return OUT_STATUS_CLR & (1u << 25u);
    }

    /**
     * Set OUT_STATUS_CLR's DED1 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_CLR_DED1() volatile
    {
        OUT_STATUS_CLR |= 1u << 25u;
    }

    /**
     * Clear OUT_STATUS_CLR's DED1 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_CLR_DED1() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 25u);
    }

    /**
     * Toggle OUT_STATUS_CLR's DED1 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_CLR_DED1() volatile
    {
        OUT_STATUS_CLR ^= 1u << 25u;
    }

    /**
     * Get OUT_STATUS_CLR's DED0 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_CLR_DED0() volatile
    {
        return OUT_STATUS_CLR & (1u << 24u);
    }

    /**
     * Set OUT_STATUS_CLR's DED0 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_CLR_DED0() volatile
    {
        OUT_STATUS_CLR |= 1u << 24u;
    }

    /**
     * Clear OUT_STATUS_CLR's DED0 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_CLR_DED0() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 24u);
    }

    /**
     * Toggle OUT_STATUS_CLR's DED0 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_CLR_DED0() volatile
    {
        OUT_STATUS_CLR ^= 1u << 24u;
    }

    /**
     * Get OUT_STATUS_CLR's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline bool get_OUT_STATUS_CLR_READ_ERROR_INTR() volatile
    {
        return OUT_STATUS_CLR & (1u << 23u);
    }

    /**
     * Set OUT_STATUS_CLR's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void set_OUT_STATUS_CLR_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_CLR |= 1u << 23u;
    }

    /**
     * Clear OUT_STATUS_CLR's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void clear_OUT_STATUS_CLR_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_STATUS_CLR's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void toggle_OUT_STATUS_CLR_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_CLR ^= 1u << 23u;
    }

    /**
     * Get OUT_STATUS_CLR's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline bool get_OUT_STATUS_CLR_READ_DONE_INTR() volatile
    {
        return OUT_STATUS_CLR & (1u << 22u);
    }

    /**
     * Set OUT_STATUS_CLR's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void set_OUT_STATUS_CLR_READ_DONE_INTR() volatile
    {
        OUT_STATUS_CLR |= 1u << 22u;
    }

    /**
     * Clear OUT_STATUS_CLR's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void clear_OUT_STATUS_CLR_READ_DONE_INTR() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 22u);
    }

    /**
     * Toggle OUT_STATUS_CLR's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void toggle_OUT_STATUS_CLR_READ_DONE_INTR() volatile
    {
        OUT_STATUS_CLR ^= 1u << 22u;
    }

    /**
     * Get OUT_STATUS_CLR's CALIBRATED bit.
     *
     * Calibrated status
     */
    inline bool get_OUT_STATUS_CLR_CALIBRATED() volatile
    {
        return OUT_STATUS_CLR & (1u << 21u);
    }

    /**
     * Get OUT_STATUS_CLR's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline bool get_OUT_STATUS_CLR_DED_RELOAD() volatile
    {
        return OUT_STATUS_CLR & (1u << 20u);
    }

    /**
     * Set OUT_STATUS_CLR's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void set_OUT_STATUS_CLR_DED_RELOAD() volatile
    {
        OUT_STATUS_CLR |= 1u << 20u;
    }

    /**
     * Clear OUT_STATUS_CLR's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void clear_OUT_STATUS_CLR_DED_RELOAD() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle OUT_STATUS_CLR's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void toggle_OUT_STATUS_CLR_DED_RELOAD() volatile
    {
        OUT_STATUS_CLR ^= 1u << 20u;
    }

    /**
     * Get OUT_STATUS_CLR's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline bool get_OUT_STATUS_CLR_SEC_RELOAD() volatile
    {
        return OUT_STATUS_CLR & (1u << 19u);
    }

    /**
     * Set OUT_STATUS_CLR's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void set_OUT_STATUS_CLR_SEC_RELOAD() volatile
    {
        OUT_STATUS_CLR |= 1u << 19u;
    }

    /**
     * Clear OUT_STATUS_CLR's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void clear_OUT_STATUS_CLR_SEC_RELOAD() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 19u);
    }

    /**
     * Toggle OUT_STATUS_CLR's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void toggle_OUT_STATUS_CLR_SEC_RELOAD() volatile
    {
        OUT_STATUS_CLR ^= 1u << 19u;
    }

    /**
     * Get OUT_STATUS_CLR's FLAGSTATE field.
     *
     * Flag state
     */
    inline uint8_t get_OUT_STATUS_CLR_FLAGSTATE() volatile
    {
        return (OUT_STATUS_CLR >> 15u) & 0b1111u;
    }

    /**
     * Get OUT_STATUS_CLR's PWOK bit.
     *
     * Power OK
     */
    inline bool get_OUT_STATUS_CLR_PWOK() volatile
    {
        return OUT_STATUS_CLR & (1u << 14u);
    }

    /**
     * Get OUT_STATUS_CLR's ACK bit.
     *
     * Acknowledge
     */
    inline bool get_OUT_STATUS_CLR_ACK() volatile
    {
        return OUT_STATUS_CLR & (1u << 13u);
    }

    /**
     * Get OUT_STATUS_CLR's PROGFAIL bit.
     *
     * Programming failed
     */
    inline bool get_OUT_STATUS_CLR_PROGFAIL() volatile
    {
        return OUT_STATUS_CLR & (1u << 12u);
    }

    /**
     * Set OUT_STATUS_CLR's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void set_OUT_STATUS_CLR_PROGFAIL() volatile
    {
        OUT_STATUS_CLR |= 1u << 12u;
    }

    /**
     * Clear OUT_STATUS_CLR's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void clear_OUT_STATUS_CLR_PROGFAIL() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle OUT_STATUS_CLR's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void toggle_OUT_STATUS_CLR_PROGFAIL() volatile
    {
        OUT_STATUS_CLR ^= 1u << 12u;
    }

    /**
     * Get OUT_STATUS_CLR's LOCKED bit.
     *
     * Word Locked
     */
    inline bool get_OUT_STATUS_CLR_LOCKED() volatile
    {
        return OUT_STATUS_CLR & (1u << 11u);
    }

    /**
     * Set OUT_STATUS_CLR's LOCKED bit.
     *
     * Word Locked
     */
    inline void set_OUT_STATUS_CLR_LOCKED() volatile
    {
        OUT_STATUS_CLR |= 1u << 11u;
    }

    /**
     * Clear OUT_STATUS_CLR's LOCKED bit.
     *
     * Word Locked
     */
    inline void clear_OUT_STATUS_CLR_LOCKED() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle OUT_STATUS_CLR's LOCKED bit.
     *
     * Word Locked
     */
    inline void toggle_OUT_STATUS_CLR_LOCKED() volatile
    {
        OUT_STATUS_CLR ^= 1u << 11u;
    }

    /**
     * Get OUT_STATUS_CLR's DED bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_CLR_DED() volatile
    {
        return OUT_STATUS_CLR & (1u << 10u);
    }

    /**
     * Set OUT_STATUS_CLR's DED bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_CLR_DED() volatile
    {
        OUT_STATUS_CLR |= 1u << 10u;
    }

    /**
     * Clear OUT_STATUS_CLR's DED bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_CLR_DED() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle OUT_STATUS_CLR's DED bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_CLR_DED() volatile
    {
        OUT_STATUS_CLR ^= 1u << 10u;
    }

    /**
     * Get OUT_STATUS_CLR's SEC bit.
     *
     * Single Error Correct
     */
    inline bool get_OUT_STATUS_CLR_SEC() volatile
    {
        return OUT_STATUS_CLR & (1u << 9u);
    }

    /**
     * Set OUT_STATUS_CLR's SEC bit.
     *
     * Single Error Correct
     */
    inline void set_OUT_STATUS_CLR_SEC() volatile
    {
        OUT_STATUS_CLR |= 1u << 9u;
    }

    /**
     * Clear OUT_STATUS_CLR's SEC bit.
     *
     * Single Error Correct
     */
    inline void clear_OUT_STATUS_CLR_SEC() volatile
    {
        OUT_STATUS_CLR &= ~(1u << 9u);
    }

    /**
     * Toggle OUT_STATUS_CLR's SEC bit.
     *
     * Single Error Correct
     */
    inline void toggle_OUT_STATUS_CLR_SEC() volatile
    {
        OUT_STATUS_CLR ^= 1u << 9u;
    }

    /**
     * Get all of OUT_STATUS_CLR's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void get_OUT_STATUS_CLR(bool &DED3, bool &DED2, bool &DED1,
                                   bool &DED0, bool &READ_ERROR_INTR,
                                   bool &READ_DONE_INTR, bool &CALIBRATED,
                                   bool &DED_RELOAD, bool &SEC_RELOAD,
                                   uint8_t &FLAGSTATE, bool &PWOK, bool &ACK,
                                   bool &PROGFAIL, bool &LOCKED, bool &DED,
                                   bool &SEC) volatile
    {
        uint32_t curr = OUT_STATUS_CLR;

        DED3 = curr & (1u << 27u);
        DED2 = curr & (1u << 26u);
        DED1 = curr & (1u << 25u);
        DED0 = curr & (1u << 24u);
        READ_ERROR_INTR = curr & (1u << 23u);
        READ_DONE_INTR = curr & (1u << 22u);
        CALIBRATED = curr & (1u << 21u);
        DED_RELOAD = curr & (1u << 20u);
        SEC_RELOAD = curr & (1u << 19u);
        FLAGSTATE = (curr >> 15u) & 0b1111u;
        PWOK = curr & (1u << 14u);
        ACK = curr & (1u << 13u);
        PROGFAIL = curr & (1u << 12u);
        LOCKED = curr & (1u << 11u);
        DED = curr & (1u << 10u);
        SEC = curr & (1u << 9u);
    }

    /**
     * Set all of OUT_STATUS_CLR's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void set_OUT_STATUS_CLR(bool DED3, bool DED2, bool DED1, bool DED0,
                                   bool READ_ERROR_INTR, bool READ_DONE_INTR,
                                   bool DED_RELOAD, bool SEC_RELOAD,
                                   bool PROGFAIL, bool LOCKED, bool DED,
                                   bool SEC) volatile
    {
        uint32_t curr = OUT_STATUS_CLR;

        curr &= ~(0b1u << 27u);
        curr |= (DED3 & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (DED2 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DED1 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (DED0 & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (READ_ERROR_INTR & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (READ_DONE_INTR & 0b1u) << 22u;
        curr &= ~(0b1u << 20u);
        curr |= (DED_RELOAD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (SEC_RELOAD & 0b1u) << 19u;
        curr &= ~(0b1u << 12u);
        curr |= (PROGFAIL & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LOCKED & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (DED & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SEC & 0b1u) << 9u;

        OUT_STATUS_CLR = curr;
    }

    /**
     * Get OUT_STATUS_TOG's DED3 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_TOG_DED3() volatile
    {
        return OUT_STATUS_TOG & (1u << 27u);
    }

    /**
     * Set OUT_STATUS_TOG's DED3 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_TOG_DED3() volatile
    {
        OUT_STATUS_TOG |= 1u << 27u;
    }

    /**
     * Clear OUT_STATUS_TOG's DED3 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_TOG_DED3() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 27u);
    }

    /**
     * Toggle OUT_STATUS_TOG's DED3 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_TOG_DED3() volatile
    {
        OUT_STATUS_TOG ^= 1u << 27u;
    }

    /**
     * Get OUT_STATUS_TOG's DED2 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_TOG_DED2() volatile
    {
        return OUT_STATUS_TOG & (1u << 26u);
    }

    /**
     * Set OUT_STATUS_TOG's DED2 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_TOG_DED2() volatile
    {
        OUT_STATUS_TOG |= 1u << 26u;
    }

    /**
     * Clear OUT_STATUS_TOG's DED2 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_TOG_DED2() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 26u);
    }

    /**
     * Toggle OUT_STATUS_TOG's DED2 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_TOG_DED2() volatile
    {
        OUT_STATUS_TOG ^= 1u << 26u;
    }

    /**
     * Get OUT_STATUS_TOG's DED1 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_TOG_DED1() volatile
    {
        return OUT_STATUS_TOG & (1u << 25u);
    }

    /**
     * Set OUT_STATUS_TOG's DED1 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_TOG_DED1() volatile
    {
        OUT_STATUS_TOG |= 1u << 25u;
    }

    /**
     * Clear OUT_STATUS_TOG's DED1 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_TOG_DED1() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 25u);
    }

    /**
     * Toggle OUT_STATUS_TOG's DED1 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_TOG_DED1() volatile
    {
        OUT_STATUS_TOG ^= 1u << 25u;
    }

    /**
     * Get OUT_STATUS_TOG's DED0 bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_TOG_DED0() volatile
    {
        return OUT_STATUS_TOG & (1u << 24u);
    }

    /**
     * Set OUT_STATUS_TOG's DED0 bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_TOG_DED0() volatile
    {
        OUT_STATUS_TOG |= 1u << 24u;
    }

    /**
     * Clear OUT_STATUS_TOG's DED0 bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_TOG_DED0() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 24u);
    }

    /**
     * Toggle OUT_STATUS_TOG's DED0 bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_TOG_DED0() volatile
    {
        OUT_STATUS_TOG ^= 1u << 24u;
    }

    /**
     * Get OUT_STATUS_TOG's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline bool get_OUT_STATUS_TOG_READ_ERROR_INTR() volatile
    {
        return OUT_STATUS_TOG & (1u << 23u);
    }

    /**
     * Set OUT_STATUS_TOG's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void set_OUT_STATUS_TOG_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_TOG |= 1u << 23u;
    }

    /**
     * Clear OUT_STATUS_TOG's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void clear_OUT_STATUS_TOG_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_STATUS_TOG's READ_ERROR_INTR bit.
     *
     * Fuse read error
     */
    inline void toggle_OUT_STATUS_TOG_READ_ERROR_INTR() volatile
    {
        OUT_STATUS_TOG ^= 1u << 23u;
    }

    /**
     * Get OUT_STATUS_TOG's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline bool get_OUT_STATUS_TOG_READ_DONE_INTR() volatile
    {
        return OUT_STATUS_TOG & (1u << 22u);
    }

    /**
     * Set OUT_STATUS_TOG's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void set_OUT_STATUS_TOG_READ_DONE_INTR() volatile
    {
        OUT_STATUS_TOG |= 1u << 22u;
    }

    /**
     * Clear OUT_STATUS_TOG's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void clear_OUT_STATUS_TOG_READ_DONE_INTR() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 22u);
    }

    /**
     * Toggle OUT_STATUS_TOG's READ_DONE_INTR bit.
     *
     * Read fuse done
     */
    inline void toggle_OUT_STATUS_TOG_READ_DONE_INTR() volatile
    {
        OUT_STATUS_TOG ^= 1u << 22u;
    }

    /**
     * Get OUT_STATUS_TOG's CALIBRATED bit.
     *
     * Calibrated status
     */
    inline bool get_OUT_STATUS_TOG_CALIBRATED() volatile
    {
        return OUT_STATUS_TOG & (1u << 21u);
    }

    /**
     * Get OUT_STATUS_TOG's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline bool get_OUT_STATUS_TOG_DED_RELOAD() volatile
    {
        return OUT_STATUS_TOG & (1u << 20u);
    }

    /**
     * Set OUT_STATUS_TOG's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void set_OUT_STATUS_TOG_DED_RELOAD() volatile
    {
        OUT_STATUS_TOG |= 1u << 20u;
    }

    /**
     * Clear OUT_STATUS_TOG's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void clear_OUT_STATUS_TOG_DED_RELOAD() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle OUT_STATUS_TOG's DED_RELOAD bit.
     *
     * Indicates double error detection occured on reload
     */
    inline void toggle_OUT_STATUS_TOG_DED_RELOAD() volatile
    {
        OUT_STATUS_TOG ^= 1u << 20u;
    }

    /**
     * Get OUT_STATUS_TOG's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline bool get_OUT_STATUS_TOG_SEC_RELOAD() volatile
    {
        return OUT_STATUS_TOG & (1u << 19u);
    }

    /**
     * Set OUT_STATUS_TOG's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void set_OUT_STATUS_TOG_SEC_RELOAD() volatile
    {
        OUT_STATUS_TOG |= 1u << 19u;
    }

    /**
     * Clear OUT_STATUS_TOG's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void clear_OUT_STATUS_TOG_SEC_RELOAD() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 19u);
    }

    /**
     * Toggle OUT_STATUS_TOG's SEC_RELOAD bit.
     *
     * Indicates single error correction occured on reload
     */
    inline void toggle_OUT_STATUS_TOG_SEC_RELOAD() volatile
    {
        OUT_STATUS_TOG ^= 1u << 19u;
    }

    /**
     * Get OUT_STATUS_TOG's FLAGSTATE field.
     *
     * Flag state
     */
    inline uint8_t get_OUT_STATUS_TOG_FLAGSTATE() volatile
    {
        return (OUT_STATUS_TOG >> 15u) & 0b1111u;
    }

    /**
     * Get OUT_STATUS_TOG's PWOK bit.
     *
     * Power OK
     */
    inline bool get_OUT_STATUS_TOG_PWOK() volatile
    {
        return OUT_STATUS_TOG & (1u << 14u);
    }

    /**
     * Get OUT_STATUS_TOG's ACK bit.
     *
     * Acknowledge
     */
    inline bool get_OUT_STATUS_TOG_ACK() volatile
    {
        return OUT_STATUS_TOG & (1u << 13u);
    }

    /**
     * Get OUT_STATUS_TOG's PROGFAIL bit.
     *
     * Programming failed
     */
    inline bool get_OUT_STATUS_TOG_PROGFAIL() volatile
    {
        return OUT_STATUS_TOG & (1u << 12u);
    }

    /**
     * Set OUT_STATUS_TOG's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void set_OUT_STATUS_TOG_PROGFAIL() volatile
    {
        OUT_STATUS_TOG |= 1u << 12u;
    }

    /**
     * Clear OUT_STATUS_TOG's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void clear_OUT_STATUS_TOG_PROGFAIL() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle OUT_STATUS_TOG's PROGFAIL bit.
     *
     * Programming failed
     */
    inline void toggle_OUT_STATUS_TOG_PROGFAIL() volatile
    {
        OUT_STATUS_TOG ^= 1u << 12u;
    }

    /**
     * Get OUT_STATUS_TOG's LOCKED bit.
     *
     * Word Locked
     */
    inline bool get_OUT_STATUS_TOG_LOCKED() volatile
    {
        return OUT_STATUS_TOG & (1u << 11u);
    }

    /**
     * Set OUT_STATUS_TOG's LOCKED bit.
     *
     * Word Locked
     */
    inline void set_OUT_STATUS_TOG_LOCKED() volatile
    {
        OUT_STATUS_TOG |= 1u << 11u;
    }

    /**
     * Clear OUT_STATUS_TOG's LOCKED bit.
     *
     * Word Locked
     */
    inline void clear_OUT_STATUS_TOG_LOCKED() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle OUT_STATUS_TOG's LOCKED bit.
     *
     * Word Locked
     */
    inline void toggle_OUT_STATUS_TOG_LOCKED() volatile
    {
        OUT_STATUS_TOG ^= 1u << 11u;
    }

    /**
     * Get OUT_STATUS_TOG's DED bit.
     *
     * Double error detect
     */
    inline bool get_OUT_STATUS_TOG_DED() volatile
    {
        return OUT_STATUS_TOG & (1u << 10u);
    }

    /**
     * Set OUT_STATUS_TOG's DED bit.
     *
     * Double error detect
     */
    inline void set_OUT_STATUS_TOG_DED() volatile
    {
        OUT_STATUS_TOG |= 1u << 10u;
    }

    /**
     * Clear OUT_STATUS_TOG's DED bit.
     *
     * Double error detect
     */
    inline void clear_OUT_STATUS_TOG_DED() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle OUT_STATUS_TOG's DED bit.
     *
     * Double error detect
     */
    inline void toggle_OUT_STATUS_TOG_DED() volatile
    {
        OUT_STATUS_TOG ^= 1u << 10u;
    }

    /**
     * Get OUT_STATUS_TOG's SEC bit.
     *
     * Single Error Correct
     */
    inline bool get_OUT_STATUS_TOG_SEC() volatile
    {
        return OUT_STATUS_TOG & (1u << 9u);
    }

    /**
     * Set OUT_STATUS_TOG's SEC bit.
     *
     * Single Error Correct
     */
    inline void set_OUT_STATUS_TOG_SEC() volatile
    {
        OUT_STATUS_TOG |= 1u << 9u;
    }

    /**
     * Clear OUT_STATUS_TOG's SEC bit.
     *
     * Single Error Correct
     */
    inline void clear_OUT_STATUS_TOG_SEC() volatile
    {
        OUT_STATUS_TOG &= ~(1u << 9u);
    }

    /**
     * Toggle OUT_STATUS_TOG's SEC bit.
     *
     * Single Error Correct
     */
    inline void toggle_OUT_STATUS_TOG_SEC() volatile
    {
        OUT_STATUS_TOG ^= 1u << 9u;
    }

    /**
     * Get all of OUT_STATUS_TOG's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void get_OUT_STATUS_TOG(bool &DED3, bool &DED2, bool &DED1,
                                   bool &DED0, bool &READ_ERROR_INTR,
                                   bool &READ_DONE_INTR, bool &CALIBRATED,
                                   bool &DED_RELOAD, bool &SEC_RELOAD,
                                   uint8_t &FLAGSTATE, bool &PWOK, bool &ACK,
                                   bool &PROGFAIL, bool &LOCKED, bool &DED,
                                   bool &SEC) volatile
    {
        uint32_t curr = OUT_STATUS_TOG;

        DED3 = curr & (1u << 27u);
        DED2 = curr & (1u << 26u);
        DED1 = curr & (1u << 25u);
        DED0 = curr & (1u << 24u);
        READ_ERROR_INTR = curr & (1u << 23u);
        READ_DONE_INTR = curr & (1u << 22u);
        CALIBRATED = curr & (1u << 21u);
        DED_RELOAD = curr & (1u << 20u);
        SEC_RELOAD = curr & (1u << 19u);
        FLAGSTATE = (curr >> 15u) & 0b1111u;
        PWOK = curr & (1u << 14u);
        ACK = curr & (1u << 13u);
        PROGFAIL = curr & (1u << 12u);
        LOCKED = curr & (1u << 11u);
        DED = curr & (1u << 10u);
        SEC = curr & (1u << 9u);
    }

    /**
     * Set all of OUT_STATUS_TOG's bit fields.
     *
     * (read-write) 8K OTP Memory STATUS Register
     */
    inline void set_OUT_STATUS_TOG(bool DED3, bool DED2, bool DED1, bool DED0,
                                   bool READ_ERROR_INTR, bool READ_DONE_INTR,
                                   bool DED_RELOAD, bool SEC_RELOAD,
                                   bool PROGFAIL, bool LOCKED, bool DED,
                                   bool SEC) volatile
    {
        uint32_t curr = OUT_STATUS_TOG;

        curr &= ~(0b1u << 27u);
        curr |= (DED3 & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (DED2 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DED1 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (DED0 & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (READ_ERROR_INTR & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (READ_DONE_INTR & 0b1u) << 22u;
        curr &= ~(0b1u << 20u);
        curr |= (DED_RELOAD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (SEC_RELOAD & 0b1u) << 19u;
        curr &= ~(0b1u << 12u);
        curr |= (PROGFAIL & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LOCKED & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (DED & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SEC & 0b1u) << 9u;

        OUT_STATUS_TOG = curr;
    }

    /**
     * Get VERSION's MAJOR field.
     *
     * Major RTL Version
     */
    inline uint8_t get_VERSION_MAJOR() volatile
    {
        return (VERSION >> 24u) & 0b11111111u;
    }

    /**
     * Get VERSION's MINOR field.
     *
     * Minor RTL Version
     */
    inline uint8_t get_VERSION_MINOR() volatile
    {
        return (VERSION >> 16u) & 0b11111111u;
    }

    /**
     * Get VERSION's STEP field.
     *
     * RTL Version Stepping
     */
    inline uint16_t get_VERSION_STEP() volatile
    {
        return (VERSION >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of VERSION's bit fields.
     *
     * (read-write) OTP Controller Version Register
     */
    inline void get_VERSION(uint8_t &MAJOR, uint8_t &MINOR,
                            uint16_t &STEP) volatile
    {
        uint32_t curr = VERSION;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        STEP = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get READ_FUSE_DATA0's DATA field.
     *
     * Data
     */
    inline uint32_t get_READ_FUSE_DATA0_DATA() volatile
    {
        return (READ_FUSE_DATA0 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set READ_FUSE_DATA0's DATA field.
     *
     * Data
     */
    inline void set_READ_FUSE_DATA0_DATA(uint32_t value) volatile
    {
        uint32_t curr = READ_FUSE_DATA0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        READ_FUSE_DATA0 = curr;
    }

    /**
     * Get READ_FUSE_DATA1's DATA field.
     *
     * Data
     */
    inline uint32_t get_READ_FUSE_DATA1_DATA() volatile
    {
        return (READ_FUSE_DATA1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set READ_FUSE_DATA1's DATA field.
     *
     * Data
     */
    inline void set_READ_FUSE_DATA1_DATA(uint32_t value) volatile
    {
        uint32_t curr = READ_FUSE_DATA1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        READ_FUSE_DATA1 = curr;
    }

    /**
     * Get READ_FUSE_DATA2's DATA field.
     *
     * Data
     */
    inline uint32_t get_READ_FUSE_DATA2_DATA() volatile
    {
        return (READ_FUSE_DATA2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set READ_FUSE_DATA2's DATA field.
     *
     * Data
     */
    inline void set_READ_FUSE_DATA2_DATA(uint32_t value) volatile
    {
        uint32_t curr = READ_FUSE_DATA2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        READ_FUSE_DATA2 = curr;
    }

    /**
     * Get READ_FUSE_DATA3's DATA field.
     *
     * Data
     */
    inline uint32_t get_READ_FUSE_DATA3_DATA() volatile
    {
        return (READ_FUSE_DATA3 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set READ_FUSE_DATA3's DATA field.
     *
     * Data
     */
    inline void set_READ_FUSE_DATA3_DATA(uint32_t value) volatile
    {
        uint32_t curr = READ_FUSE_DATA3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        READ_FUSE_DATA3 = curr;
    }

    /**
     * Get SW_LOCK's SW_LOCK field.
     *
     * This register contains lock information, which has the same function as
     * the RLOCK fuse words (supplementary fuse words 8 (0x880) and 9 (0x890))
     * in fuse memory
     */
    inline uint32_t get_SW_LOCK_SW_LOCK() volatile
    {
        return (SW_LOCK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SW_LOCK's SW_LOCK field.
     *
     * This register contains lock information, which has the same function as
     * the RLOCK fuse words (supplementary fuse words 8 (0x880) and 9 (0x890))
     * in fuse memory
     */
    inline void set_SW_LOCK_SW_LOCK(uint32_t value) volatile
    {
        uint32_t curr = SW_LOCK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SW_LOCK = curr;
    }

    /**
     * Get BIT_LOCK's BIT_LOCK field.
     *
     * Each bit controls the corresponding bit in supplementary fuse word 13
     * and its shadow register
     */
    inline uint32_t get_BIT_LOCK_BIT_LOCK() volatile
    {
        return (BIT_LOCK >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set BIT_LOCK's BIT_LOCK field.
     *
     * Each bit controls the corresponding bit in supplementary fuse word 13
     * and its shadow register
     */
    inline void set_BIT_LOCK_BIT_LOCK(uint32_t value) volatile
    {
        uint32_t curr = BIT_LOCK;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        BIT_LOCK = curr;
    }

    /**
     * Get LOCKED0's LOCKED field.
     *
     * Stores program locked status for fuse words 0-15.
     */
    inline uint16_t get_LOCKED0_LOCKED() volatile
    {
        return (LOCKED0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get LOCKED1's LOCKED field.
     *
     * Stores program locked status for fuse words 16-47
     */
    inline uint32_t get_LOCKED1_LOCKED() volatile
    {
        return (LOCKED1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get LOCKED2's LOCKED field.
     *
     * Stores program locked status for fuse words 48-79
     */
    inline uint32_t get_LOCKED2_LOCKED() volatile
    {
        return (LOCKED2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get LOCKED3's LOCKED field.
     *
     * Stores program locked status for fuse words 80-111
     */
    inline uint32_t get_LOCKED3_LOCKED() volatile
    {
        return (LOCKED3 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get LOCKED4's LOCKED field.
     *
     * Stores program locked status for fuse words 112-143
     */
    inline uint32_t get_LOCKED4_LOCKED() volatile
    {
        return (LOCKED4 >> 0u) & 0b11111111111111111111111111111111u;
    }
};

static_assert(sizeof(ocotp) == ocotp::size);

static volatile ocotp *const OCOTP = reinterpret_cast<ocotp *>(0x40CAC000);

}; // namespace MIMXRT1176::CM7
