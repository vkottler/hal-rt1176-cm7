/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/ENET_QOS_DMA_DEBUG_STATUS0_RPS0.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS0_RPS1.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS0_RPS2.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS0_TPS0.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS0_TPS1.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS0_TPS2.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS1_RPS3.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS1_RPS4.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS1_TPS3.h"
#include "../enums/ENET_QOS_DMA_DEBUG_STATUS1_TPS4.h"
#include "../enums/ENET_QOS_DMA_MODE_INTM.h"
#include "../enums/ENET_QOS_MAC_CONFIGURATION_BL.h"
#include "../enums/ENET_QOS_MAC_CONFIGURATION_IPG.h"
#include "../enums/ENET_QOS_MAC_CONFIGURATION_PRELEN.h"
#include "../enums/ENET_QOS_MAC_CONFIGURATION_SARC.h"
#include "../enums/ENET_QOS_MAC_DEBUG_TFCSTS.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE0_ACTPHYSEL.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE0_TSSTSSEL.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE1_ADDR64.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE1_HASHTBLSZ.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE1_L3L4FNUM.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE1_RXFIFOSIZE.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE1_TXFIFOSIZE.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE2_AUXSNAPNUM.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE2_PPSOUTNUM.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE2_RXCHCNT.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE2_RXQCNT.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE2_TXCHCNT.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE2_TXQCNT.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE3_ASP.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE3_ESTDEP.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE3_ESTWID.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE3_FRPBS.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE3_FRPES.h"
#include "../enums/ENET_QOS_MAC_HW_FEATURE3_NRVF.h"
#include "../enums/ENET_QOS_MAC_INNER_VLAN_INCL_VLC.h"
#include "../enums/ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR.h"
#include "../enums/ENET_QOS_MAC_PACKET_FILTER_PCF.h"
#include "../enums/ENET_QOS_MAC_PHYIF_CONTROL_STATUS_LNKSPEED.h"
#include "../enums/ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0.h"
#include "../enums/ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1.h"
#include "../enums/ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2.h"
#include "../enums/ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3.h"
#include "../enums/ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT.h"
#include "../enums/ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT.h"
#include "../enums/ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT.h"
#include "../enums/ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT.h"
#include "../enums/ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL1_AVCPQ.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL1_MCBCQ.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL1_PTPQ.h"
#include "../enums/ENET_QOS_MAC_RXQ_CTRL1_UPQ.h"
#include "../enums/ENET_QOS_MAC_VLAN_INCL_VLC.h"
#include "../enums/ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS.h"
#include "../enums/ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS.h"
#include "../enums/ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO.h"
#include "../enums/ENET_QOS_MTL_DBG_CTL_BYTEEN.h"
#include "../enums/ENET_QOS_MTL_DBG_CTL_FIFOSEL.h"
#include "../enums/ENET_QOS_MTL_DBG_CTL_PKTSTATE.h"
#include "../enums/ENET_QOS_MTL_DBG_STS_BYTEEN.h"
#include "../enums/ENET_QOS_MTL_DBG_STS_PKTSTATE.h"
#include "../enums/ENET_QOS_MTL_EST_CONTROL_LCSE.h"
#include "../enums/ENET_QOS_MTL_EST_GCL_CONTROL_ESTEIEC.h"
#include "../enums/ENET_QOS_MTL_OPERATION_MODE_SCHALG.h"
#include "../enums/ENET_QOS_MTL_RXQ0_DEBUG_RRCSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ0_DEBUG_RXQSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC.h"
#include "../enums/ENET_QOS_MTL_RXQ1_DEBUG_RRCSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ1_DEBUG_RXQSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC.h"
#include "../enums/ENET_QOS_MTL_RXQ2_DEBUG_RRCSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ2_DEBUG_RXQSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC.h"
#include "../enums/ENET_QOS_MTL_RXQ3_DEBUG_RRCSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ3_DEBUG_RXQSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC.h"
#include "../enums/ENET_QOS_MTL_RXQ4_DEBUG_RRCSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ4_DEBUG_RXQSTS.h"
#include "../enums/ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC.h"
#include "../enums/ENET_QOS_MTL_TXQ0_DEBUG_TRCSTS.h"
#include "../enums/ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC.h"
#include "../enums/ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN.h"
#include "../enums/ENET_QOS_MTL_TXQ1_DEBUG_TRCSTS.h"
#include "../enums/ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC.h"
#include "../enums/ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC.h"
#include "../enums/ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN.h"
#include "../enums/ENET_QOS_MTL_TXQ2_DEBUG_TRCSTS.h"
#include "../enums/ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC.h"
#include "../enums/ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC.h"
#include "../enums/ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN.h"
#include "../enums/ENET_QOS_MTL_TXQ3_DEBUG_TRCSTS.h"
#include "../enums/ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC.h"
#include "../enums/ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC.h"
#include "../enums/ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN.h"
#include "../enums/ENET_QOS_MTL_TXQ4_DEBUG_TRCSTS.h"
#include "../enums/ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC.h"
#include "../enums/ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC.h"
#include "../enums/ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * ENET_QOS
 */
struct [[gnu::packed]] enet_qos
{
    /* Constant attributes. */
    static constexpr std::size_t size = 4976; /*!< enet_qos's size in bytes. */

    /* Fields. */
    uint32_t MAC_CONFIGURATION; /*!< (read-write) MAC Configuration Register */
    uint32_t MAC_EXT_CONFIGURATION; /*!< (read-write) MAC Extended
                                       Configuration Register */
    uint32_t MAC_PACKET_FILTER;     /*!< (read-write) MAC Packet Filter */
    uint32_t MAC_WATCHDOG_TIMEOUT;  /*!< (read-write) Watchdog Timeout */
    uint32_t
        MAC_HASH_TABLE_REG0; /*!< (read-write) MAC Hash Table Register 0 */
    uint32_t
        MAC_HASH_TABLE_REG1; /*!< (read-write) MAC Hash Table Register 1 */
    static constexpr std::size_t reserved_padding0_length = 14;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t MAC_VLAN_TAG_CTRL;   /*!< (read-write) MAC VLAN Tag Control */
    uint32_t MAC_VLAN_TAG_DATA;   /*!< (read-write) MAC VLAN Tag Data */
    uint32_t MAC_VLAN_HASH_TABLE; /*!< (read-write) MAC VLAN Hash Table */
    const uint32_t reserved_padding1 = {};
    uint32_t
        MAC_VLAN_INCL; /*!< (read-write) VLAN Tag Inclusion or Replacement */
    uint32_t MAC_INNER_VLAN_INCL; /*!< (read-write) MAC Inner VLAN Tag
                                     Inclusion or Replacement */
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t MAC_Q0_TX_FLOW_CTRL; /*!< (read-write) MAC Q0 Tx Flow Control */
    uint32_t MAC_Q1_TX_FLOW_CTRL; /*!< (read-write) MAC Q1 Tx Flow Control */
    uint32_t MAC_Q2_TX_FLOW_CTRL; /*!< (read-write) MAC Q2 Tx Flow Control */
    uint32_t MAC_Q3_TX_FLOW_CTRL; /*!< (read-write) MAC Q3 Tx Flow Control */
    uint32_t MAC_Q4_TX_FLOW_CTRL; /*!< (read-write) MAC Q4 Tx Flow Control */
    static constexpr std::size_t reserved_padding3_length = 3;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t MAC_RX_FLOW_CTRL;     /*!< (read-write) MAC Rx Flow Control */
    uint32_t MAC_RXQ_CTRL4;        /*!< (read-write) Receive Queue Control 4 */
    uint32_t MAC_TXQ_PRTY_MAP0;    /*!< (read-write) Transmit Queue Priority
                                      Mapping 0 */
    uint32_t MAC_TXQ_PRTY_MAP1;    /*!< (read-write) Transmit Queue Priority
                                      Mapping 1 */
    uint32_t MAC_RXQ_CTRL0;        /*!< (read-write) Receive Queue Control 0 */
    uint32_t MAC_RXQ_CTRL1;        /*!< (read-write) Receive Queue Control 1 */
    uint32_t MAC_RXQ_CTRL2;        /*!< (read-write) Receive Queue Control 2 */
    uint32_t MAC_RXQ_CTRL3;        /*!< (read-write) Receive Queue Control 3 */
    uint32_t MAC_INTERRUPT_STATUS; /*!< (read-write) Interrupt Status */
    uint32_t MAC_INTERRUPT_ENABLE; /*!< (read-write) Interrupt Enable */
    uint32_t MAC_RX_TX_STATUS;     /*!< (read-write) Receive Transmit Status */
    const uint32_t reserved_padding4 = {};
    uint32_t
        MAC_PMT_CONTROL_STATUS;     /*!< (read-write) PMT Control and Status */
    uint32_t MAC_RWK_PACKET_FILTER; /*!< (read-write) Remote Wakeup Filter */
    static constexpr std::size_t reserved_padding5_length = 2;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t
        MAC_LPI_CONTROL_STATUS; /*!< (read-write) LPI Control and Status */
    uint32_t MAC_LPI_TIMERS_CONTROL; /*!< (read-write) LPI Timers Control */
    uint32_t
        MAC_LPI_ENTRY_TIMER; /*!< (read-write) Tx LPI Entry Timer Control */
    uint32_t MAC_ONEUS_TIC_COUNTER; /*!< (read-write) One-microsecond Reference
                                       Timer */
    static constexpr std::size_t reserved_padding6_length = 6;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t MAC_PHYIF_CONTROL_STATUS; /*!< (read-write) PHY Interface Control
                                          and Status */
    static constexpr std::size_t reserved_padding7_length = 5;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t MAC_VERSION; /*!< (read-write) MAC Version */
    uint32_t MAC_DEBUG;   /*!< (read-write) MAC Debug */
    const uint32_t reserved_padding8 = {};
    uint32_t
        MAC_HW_FEATURE0; /*!< (read-write) Optional Features or Functions 0 */
    uint32_t
        MAC_HW_FEATURE1; /*!< (read-write) Optional Features or Functions 1 */
    uint32_t
        MAC_HW_FEATURE2; /*!< (read-write) Optional Features or Functions 2 */
    uint32_t
        MAC_HW_FEATURE3; /*!< (read-write) Optional Features or Functions 3 */
    static constexpr std::size_t reserved_padding9_length = 53;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t MAC_MDIO_ADDRESS; /*!< (read-write) MDIO Address */
    uint32_t MAC_MDIO_DATA;    /*!< (read-write) MAC MDIO Data */
    static constexpr std::size_t reserved_padding10_length = 10;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t MAC_CSR_SW_CTRL;  /*!< (read-write) CSR Software Control */
    uint32_t MAC_FPE_CTRL_STS; /*!< (read-write) Frame Preemption Control */
    static constexpr std::size_t reserved_padding11_length = 2;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t MAC_PRESN_TIME_NS; /*!< (read-write) 32-bit Binary Rollover
                                   Equivalent Time */
    uint32_t
        MAC_PRESN_TIME_UPDT; /*!< (read-write) MAC 1722 Presentation Time */
    static constexpr std::size_t reserved_padding12_length = 46;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t MAC_ADDRESS0_HIGH;  /*!< (read-write) MAC Address0 High */
    uint32_t MAC_ADDRESS0_LOW;   /*!< (read-write) MAC Address0 Low */
    uint32_t MAC_ADDRESS1_HIGH;  /*!< (read-write) MAC Address1 High */
    uint32_t MAC_ADDRESS1_LOW;   /*!< (read-write) MAC Address1 Low */
    uint32_t MAC_ADDRESS2_HIGH;  /*!< (read-write) MAC Address2 High */
    uint32_t MAC_ADDRESS2_LOW;   /*!< (read-write) MAC Address2 Low */
    uint32_t MAC_ADDRESS3_HIGH;  /*!< (read-write) MAC Address3 High */
    uint32_t MAC_ADDRESS3_LOW;   /*!< (read-write) MAC Address3 Low */
    uint32_t MAC_ADDRESS4_HIGH;  /*!< (read-write) MAC Address4 High */
    uint32_t MAC_ADDRESS4_LOW;   /*!< (read-write) MAC Address4 Low */
    uint32_t MAC_ADDRESS5_HIGH;  /*!< (read-write) MAC Address5 High */
    uint32_t MAC_ADDRESS5_LOW;   /*!< (read-write) MAC Address5 Low */
    uint32_t MAC_ADDRESS6_HIGH;  /*!< (read-write) MAC Address6 High */
    uint32_t MAC_ADDRESS6_LOW;   /*!< (read-write) MAC Address6 Low */
    uint32_t MAC_ADDRESS7_HIGH;  /*!< (read-write) MAC Address7 High */
    uint32_t MAC_ADDRESS7_LOW;   /*!< (read-write) MAC Address7 Low */
    uint32_t MAC_ADDRESS8_HIGH;  /*!< (read-write) MAC Address8 High */
    uint32_t MAC_ADDRESS8_LOW;   /*!< (read-write) MAC Address8 Low */
    uint32_t MAC_ADDRESS9_HIGH;  /*!< (read-write) MAC Address9 High */
    uint32_t MAC_ADDRESS9_LOW;   /*!< (read-write) MAC Address9 Low */
    uint32_t MAC_ADDRESS10_HIGH; /*!< (read-write) MAC Address10 High */
    uint32_t MAC_ADDRESS10_LOW;  /*!< (read-write) MAC Address10 Low */
    uint32_t MAC_ADDRESS11_HIGH; /*!< (read-write) MAC Address11 High */
    uint32_t MAC_ADDRESS11_LOW;  /*!< (read-write) MAC Address11 Low */
    uint32_t MAC_ADDRESS12_HIGH; /*!< (read-write) MAC Address12 High */
    uint32_t MAC_ADDRESS12_LOW;  /*!< (read-write) MAC Address12 Low */
    uint32_t MAC_ADDRESS13_HIGH; /*!< (read-write) MAC Address13 High */
    uint32_t MAC_ADDRESS13_LOW;  /*!< (read-write) MAC Address13 Low */
    uint32_t MAC_ADDRESS14_HIGH; /*!< (read-write) MAC Address14 High */
    uint32_t MAC_ADDRESS14_LOW;  /*!< (read-write) MAC Address14 Low */
    uint32_t MAC_ADDRESS15_HIGH; /*!< (read-write) MAC Address15 High */
    uint32_t MAC_ADDRESS15_LOW;  /*!< (read-write) MAC Address15 Low */
    uint32_t MAC_ADDRESS16_HIGH; /*!< (read-write) MAC Address16 High */
    uint32_t MAC_ADDRESS16_LOW;  /*!< (read-write) MAC Address16 Low */
    uint32_t MAC_ADDRESS17_HIGH; /*!< (read-write) MAC Address17 High */
    uint32_t MAC_ADDRESS17_LOW;  /*!< (read-write) MAC Address17 Low */
    uint32_t MAC_ADDRESS18_HIGH; /*!< (read-write) MAC Address18 High */
    uint32_t MAC_ADDRESS18_LOW;  /*!< (read-write) MAC Address18 Low */
    uint32_t MAC_ADDRESS19_HIGH; /*!< (read-write) MAC Address19 High */
    uint32_t MAC_ADDRESS19_LOW;  /*!< (read-write) MAC Address19 Low */
    uint32_t MAC_ADDRESS20_HIGH; /*!< (read-write) MAC Address20 High */
    uint32_t MAC_ADDRESS20_LOW;  /*!< (read-write) MAC Address20 Low */
    uint32_t MAC_ADDRESS21_HIGH; /*!< (read-write) MAC Address21 High */
    uint32_t MAC_ADDRESS21_LOW;  /*!< (read-write) MAC Address21 Low */
    uint32_t MAC_ADDRESS22_HIGH; /*!< (read-write) MAC Address22 High */
    uint32_t MAC_ADDRESS22_LOW;  /*!< (read-write) MAC Address22 Low */
    uint32_t MAC_ADDRESS23_HIGH; /*!< (read-write) MAC Address23 High */
    uint32_t MAC_ADDRESS23_LOW;  /*!< (read-write) MAC Address23 Low */
    uint32_t MAC_ADDRESS24_HIGH; /*!< (read-write) MAC Address24 High */
    uint32_t MAC_ADDRESS24_LOW;  /*!< (read-write) MAC Address24 Low */
    uint32_t MAC_ADDRESS25_HIGH; /*!< (read-write) MAC Address25 High */
    uint32_t MAC_ADDRESS25_LOW;  /*!< (read-write) MAC Address25 Low */
    uint32_t MAC_ADDRESS26_HIGH; /*!< (read-write) MAC Address26 High */
    uint32_t MAC_ADDRESS26_LOW;  /*!< (read-write) MAC Address26 Low */
    uint32_t MAC_ADDRESS27_HIGH; /*!< (read-write) MAC Address27 High */
    uint32_t MAC_ADDRESS27_LOW;  /*!< (read-write) MAC Address27 Low */
    uint32_t MAC_ADDRESS28_HIGH; /*!< (read-write) MAC Address28 High */
    uint32_t MAC_ADDRESS28_LOW;  /*!< (read-write) MAC Address28 Low */
    uint32_t MAC_ADDRESS29_HIGH; /*!< (read-write) MAC Address29 High */
    uint32_t MAC_ADDRESS29_LOW;  /*!< (read-write) MAC Address29 Low */
    uint32_t MAC_ADDRESS30_HIGH; /*!< (read-write) MAC Address30 High */
    uint32_t MAC_ADDRESS30_LOW;  /*!< (read-write) MAC Address30 Low */
    uint32_t MAC_ADDRESS31_HIGH; /*!< (read-write) MAC Address31 High */
    uint32_t MAC_ADDRESS31_LOW;  /*!< (read-write) MAC Address31 Low */
    uint32_t MAC_ADDRESS32_HIGH; /*!< (read-write) MAC Address32 High */
    uint32_t MAC_ADDRESS32_LOW;  /*!< (read-write) MAC Address32 Low */
    uint32_t MAC_ADDRESS33_HIGH; /*!< (read-write) MAC Address33 High */
    uint32_t MAC_ADDRESS33_LOW;  /*!< (read-write) MAC Address33 Low */
    uint32_t MAC_ADDRESS34_HIGH; /*!< (read-write) MAC Address34 High */
    uint32_t MAC_ADDRESS34_LOW;  /*!< (read-write) MAC Address34 Low */
    uint32_t MAC_ADDRESS35_HIGH; /*!< (read-write) MAC Address35 High */
    uint32_t MAC_ADDRESS35_LOW;  /*!< (read-write) MAC Address35 Low */
    uint32_t MAC_ADDRESS36_HIGH; /*!< (read-write) MAC Address36 High */
    uint32_t MAC_ADDRESS36_LOW;  /*!< (read-write) MAC Address36 Low */
    uint32_t MAC_ADDRESS37_HIGH; /*!< (read-write) MAC Address37 High */
    uint32_t MAC_ADDRESS37_LOW;  /*!< (read-write) MAC Address37 Low */
    uint32_t MAC_ADDRESS38_HIGH; /*!< (read-write) MAC Address38 High */
    uint32_t MAC_ADDRESS38_LOW;  /*!< (read-write) MAC Address38 Low */
    uint32_t MAC_ADDRESS39_HIGH; /*!< (read-write) MAC Address39 High */
    uint32_t MAC_ADDRESS39_LOW;  /*!< (read-write) MAC Address39 Low */
    uint32_t MAC_ADDRESS40_HIGH; /*!< (read-write) MAC Address40 High */
    uint32_t MAC_ADDRESS40_LOW;  /*!< (read-write) MAC Address40 Low */
    uint32_t MAC_ADDRESS41_HIGH; /*!< (read-write) MAC Address41 High */
    uint32_t MAC_ADDRESS41_LOW;  /*!< (read-write) MAC Address41 Low */
    uint32_t MAC_ADDRESS42_HIGH; /*!< (read-write) MAC Address42 High */
    uint32_t MAC_ADDRESS42_LOW;  /*!< (read-write) MAC Address42 Low */
    uint32_t MAC_ADDRESS43_HIGH; /*!< (read-write) MAC Address43 High */
    uint32_t MAC_ADDRESS43_LOW;  /*!< (read-write) MAC Address43 Low */
    uint32_t MAC_ADDRESS44_HIGH; /*!< (read-write) MAC Address44 High */
    uint32_t MAC_ADDRESS44_LOW;  /*!< (read-write) MAC Address44 Low */
    uint32_t MAC_ADDRESS45_HIGH; /*!< (read-write) MAC Address45 High */
    uint32_t MAC_ADDRESS45_LOW;  /*!< (read-write) MAC Address45 Low */
    uint32_t MAC_ADDRESS46_HIGH; /*!< (read-write) MAC Address46 High */
    uint32_t MAC_ADDRESS46_LOW;  /*!< (read-write) MAC Address46 Low */
    uint32_t MAC_ADDRESS47_HIGH; /*!< (read-write) MAC Address47 High */
    uint32_t MAC_ADDRESS47_LOW;  /*!< (read-write) MAC Address47 Low */
    uint32_t MAC_ADDRESS48_HIGH; /*!< (read-write) MAC Address48 High */
    uint32_t MAC_ADDRESS48_LOW;  /*!< (read-write) MAC Address48 Low */
    uint32_t MAC_ADDRESS49_HIGH; /*!< (read-write) MAC Address49 High */
    uint32_t MAC_ADDRESS49_LOW;  /*!< (read-write) MAC Address49 Low */
    uint32_t MAC_ADDRESS50_HIGH; /*!< (read-write) MAC Address50 High */
    uint32_t MAC_ADDRESS50_LOW;  /*!< (read-write) MAC Address50 Low */
    uint32_t MAC_ADDRESS51_HIGH; /*!< (read-write) MAC Address51 High */
    uint32_t MAC_ADDRESS51_LOW;  /*!< (read-write) MAC Address51 Low */
    uint32_t MAC_ADDRESS52_HIGH; /*!< (read-write) MAC Address52 High */
    uint32_t MAC_ADDRESS52_LOW;  /*!< (read-write) MAC Address52 Low */
    uint32_t MAC_ADDRESS53_HIGH; /*!< (read-write) MAC Address53 High */
    uint32_t MAC_ADDRESS53_LOW;  /*!< (read-write) MAC Address53 Low */
    uint32_t MAC_ADDRESS54_HIGH; /*!< (read-write) MAC Address54 High */
    uint32_t MAC_ADDRESS54_LOW;  /*!< (read-write) MAC Address54 Low */
    uint32_t MAC_ADDRESS55_HIGH; /*!< (read-write) MAC Address55 High */
    uint32_t MAC_ADDRESS55_LOW;  /*!< (read-write) MAC Address55 Low */
    uint32_t MAC_ADDRESS56_HIGH; /*!< (read-write) MAC Address56 High */
    uint32_t MAC_ADDRESS56_LOW;  /*!< (read-write) MAC Address56 Low */
    uint32_t MAC_ADDRESS57_HIGH; /*!< (read-write) MAC Address57 High */
    uint32_t MAC_ADDRESS57_LOW;  /*!< (read-write) MAC Address57 Low */
    uint32_t MAC_ADDRESS58_HIGH; /*!< (read-write) MAC Address58 High */
    uint32_t MAC_ADDRESS58_LOW;  /*!< (read-write) MAC Address58 Low */
    uint32_t MAC_ADDRESS59_HIGH; /*!< (read-write) MAC Address59 High */
    uint32_t MAC_ADDRESS59_LOW;  /*!< (read-write) MAC Address59 Low */
    uint32_t MAC_ADDRESS60_HIGH; /*!< (read-write) MAC Address60 High */
    uint32_t MAC_ADDRESS60_LOW;  /*!< (read-write) MAC Address60 Low */
    uint32_t MAC_ADDRESS61_HIGH; /*!< (read-write) MAC Address61 High */
    uint32_t MAC_ADDRESS61_LOW;  /*!< (read-write) MAC Address61 Low */
    uint32_t MAC_ADDRESS62_HIGH; /*!< (read-write) MAC Address62 High */
    uint32_t MAC_ADDRESS62_LOW;  /*!< (read-write) MAC Address62 Low */
    uint32_t MAC_ADDRESS63_HIGH; /*!< (read-write) MAC Address63 High */
    uint32_t MAC_ADDRESS63_LOW;  /*!< (read-write) MAC Address63 Low */
    static constexpr std::size_t reserved_padding13_length = 128;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t MAC_MMC_CONTROL;      /*!< (read-write) MMC Control */
    uint32_t MAC_MMC_RX_INTERRUPT; /*!< (read-write) MMC Rx Interrupt */
    uint32_t MAC_MMC_TX_INTERRUPT; /*!< (read-write) MMC Tx Interrupt */
    uint32_t
        MAC_MMC_RX_INTERRUPT_MASK; /*!< (read-write) MMC Rx Interrupt Mask */
    uint32_t
        MAC_MMC_TX_INTERRUPT_MASK; /*!< (read-write) MMC Tx Interrupt Mask */
    uint32_t MAC_TX_OCTET_COUNT_GOOD_BAD; /*!< (read-write) Tx Octet Count Good
                                             and Bad */
    uint32_t MAC_TX_PACKET_COUNT_GOOD_BAD;  /*!< (read-write) Tx Packet Count
                                               Good and Bad */
    uint32_t MAC_TX_BROADCAST_PACKETS_GOOD; /*!< (read-write) Tx Broadcast
                                               Packets Good */
    uint32_t MAC_TX_MULTICAST_PACKETS_GOOD; /*!< (read-write) Tx Multicast
                                               Packets Good */
    uint32_t MAC_TX_64OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Tx Good and
                                                  Bad 64-Byte Packets */
    uint32_t
        MAC_TX_65TO127OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Tx Good and
                                                  Bad 65 to 127-Byte Packets */
    uint32_t MAC_TX_128TO255OCTETS_PACKETS_GOOD_BAD;  /*!< (read-write) Tx Good
                                                         and Bad 128 to 255-Byte
                                                         Packets */
    uint32_t MAC_TX_256TO511OCTETS_PACKETS_GOOD_BAD;  /*!< (read-write) Tx Good
                                                         and Bad 256 to 511-Byte
                                                         Packets */
    uint32_t MAC_TX_512TO1023OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Tx Good
                                                         and Bad 512 to
                                                         1023-Byte Packets */
    uint32_t MAC_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Tx Good
                                                         and Bad 1024 to
                                                         Max-Byte Packets */
    uint32_t MAC_TX_UNICAST_PACKETS_GOOD_BAD; /*!< (read-write) Good and Bad
                                                 Unicast Packets Transmitted */
    uint32_t
        MAC_TX_MULTICAST_PACKETS_GOOD_BAD; /*!< (read-write) Good and Bad
                                              Multicast Packets Transmitted */
    uint32_t
        MAC_TX_BROADCAST_PACKETS_GOOD_BAD;   /*!< (read-write) Good and Bad
                                                Broadcast Packets Transmitted */
    uint32_t MAC_TX_UNDERFLOW_ERROR_PACKETS; /*!< (read-write) Tx Packets
                                                Aborted By Underflow Error */
    uint32_t MAC_TX_SINGLE_COLLISION_GOOD_PACKETS;   /*!< (read-write) Single
                                                        Collision Good Packets
                                                        Transmitted */
    uint32_t MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS; /*!< (read-write) Multiple
                                                        Collision Good Packets
                                                        Transmitted */
    uint32_t MAC_TX_DEFERRED_PACKETS;       /*!< (read-write) Deferred Packets
                                               Transmitted */
    uint32_t MAC_TX_LATE_COLLISION_PACKETS; /*!< (read-write) Late Collision
                                               Packets Transmitted */
    uint32_t
        MAC_TX_EXCESSIVE_COLLISION_PACKETS; /*!< (read-write) Excessive
                                               Collision Packets Transmitted */
    uint32_t MAC_TX_CARRIER_ERROR_PACKETS;  /*!< (read-write) Carrier Error
                                               Packets Transmitted */
    uint32_t MAC_TX_OCTET_COUNT_GOOD; /*!< (read-write) Bytes Transmitted in
                                         Good Packets */
    uint32_t
        MAC_TX_PACKET_COUNT_GOOD; /*!< (read-write) Good Packets Transmitted */
    uint32_t MAC_TX_EXCESSIVE_DEFERRAL_ERROR; /*!< (read-write) Packets Aborted
                                                 By Excessive Deferral Error */
    uint32_t
        MAC_TX_PAUSE_PACKETS; /*!< (read-write) Pause Packets Transmitted */
    uint32_t MAC_TX_VLAN_PACKETS_GOOD;  /*!< (read-write) Good VLAN Packets
                                           Transmitted */
    uint32_t MAC_TX_OSIZE_PACKETS_GOOD; /*!< (read-write) Good Oversize Packets
                                           Transmitted */
    const uint32_t reserved_padding14 = {};
    uint32_t MAC_RX_PACKETS_COUNT_GOOD_BAD; /*!< (read-write) Good and Bad
                                               Packets Received */
    uint32_t MAC_RX_OCTET_COUNT_GOOD_BAD;   /*!< (read-write) Bytes in Good and
                                               Bad Packets Received */
    uint32_t MAC_RX_OCTET_COUNT_GOOD; /*!< (read-write) Bytes in Good Packets
                                         Received */
    uint32_t MAC_RX_BROADCAST_PACKETS_GOOD; /*!< (read-write) Good Broadcast
                                               Packets Received */
    uint32_t MAC_RX_MULTICAST_PACKETS_GOOD; /*!< (read-write) Good Multicast
                                               Packets Received */
    uint32_t MAC_RX_CRC_ERROR_PACKETS;      /*!< (read-write) CRC Error Packets
                                               Received */
    uint32_t MAC_RX_ALIGNMENT_ERROR_PACKETS; /*!< (read-write) Alignment Error
                                                Packets Received */
    uint32_t MAC_RX_RUNT_ERROR_PACKETS;   /*!< (read-write) Runt Error Packets
                                             Received */
    uint32_t MAC_RX_JABBER_ERROR_PACKETS; /*!< (read-write) Jabber Error
                                             Packets Received */
    uint32_t MAC_RX_UNDERSIZE_PACKETS_GOOD;    /*!< (read-write) Good Undersize
                                                  Packets Received */
    uint32_t MAC_RX_OVERSIZE_PACKETS_GOOD;     /*!< (read-write) Good Oversize
                                                  Packets Received */
    uint32_t MAC_RX_64OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Good and Bad
                                                  64-Byte Packets Received */
    uint32_t MAC_RX_65TO127OCTETS_PACKETS_GOOD_BAD;  /*!< (read-write) Good and
                                                        Bad 64-to-127 Byte
                                                        Packets Received */
    uint32_t MAC_RX_128TO255OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Good and
                                                        Bad 128-to-255 Byte
                                                        Packets Received */
    uint32_t MAC_RX_256TO511OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Good and
                                                        Bad 256-to-511 Byte
                                                        Packets Received */
    uint32_t
        MAC_RX_512TO1023OCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Good and Bad
                                                    512-to-1023 Byte Packets
                                                    Received */
    uint32_t
        MAC_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD; /*!< (read-write) Good and Bad
                                                    1024-to-Max Byte Packets
                                                    Received */
    uint32_t MAC_RX_UNICAST_PACKETS_GOOD;        /*!< (read-write) Good Unicast
                                                    Packets Received */
    uint32_t MAC_RX_LENGTH_ERROR_PACKETS;        /*!< (read-write) Length Error
                                                    Packets Received */
    uint32_t MAC_RX_OUT_OF_RANGE_TYPE_PACKETS;   /*!< (read-write) Out-of-range
                                                    Type Packets Received */
    uint32_t MAC_RX_PAUSE_PACKETS; /*!< (read-write) Pause Packets Received */
    uint32_t MAC_RX_FIFO_OVERFLOW_PACKETS; /*!< (read-write) Missed Packets Due
                                              to FIFO Overflow */
    uint32_t MAC_RX_VLAN_PACKETS_GOOD_BAD; /*!< (read-write) Good and Bad VLAN
                                              Packets Received */
    uint32_t MAC_RX_WATCHDOG_ERROR_PACKETS; /*!< (read-write) Watchdog Error
                                               Packets Received */
    uint32_t MAC_RX_RECEIVE_ERROR_PACKETS;  /*!< (read-write) Receive Error
                                               Packets Received */
    uint32_t MAC_RX_CONTROL_PACKETS_GOOD;   /*!< (read-write) Good Control
                                               Packets Received */
    const uint32_t reserved_padding15 = {};
    uint32_t
        MAC_TX_LPI_USEC_CNTR; /*!< (read-write) Microseconds Tx LPI Asserted */
    uint32_t MAC_TX_LPI_TRAN_CNTR; /*!< (read-write) Number of Times Tx LPI
                                      Asserted */
    uint32_t
        MAC_RX_LPI_USEC_CNTR; /*!< (read-write) Microseconds Rx LPI Sampled */
    uint32_t MAC_RX_LPI_TRAN_CNTR; /*!< (read-write) Number of Times Rx LPI
                                      Entered */
    const uint32_t reserved_padding16 = {};
    uint32_t MAC_MMC_IPC_RX_INTERRUPT_MASK; /*!< (read-write) MMC IPC Receive
                                               Interrupt Mask */
    const uint32_t reserved_padding17 = {};
    uint32_t MAC_MMC_IPC_RX_INTERRUPT; /*!< (read-write) MMC IPC Receive
                                          Interrupt */
    const uint32_t reserved_padding18 = {};
    uint32_t MAC_RXIPV4_GOOD_PACKETS; /*!< (read-write) Good IPv4 Datagrams
                                         Received */
    uint32_t MAC_RXIPV4_HEADER_ERROR_PACKETS; /*!< (read-write) IPv4 Datagrams
                                                 Received with Header Errors */
    uint32_t MAC_RXIPV4_NO_PAYLOAD_PACKETS;   /*!< (read-write) IPv4 Datagrams
                                                 Received with No Payload */
    uint32_t MAC_RXIPV4_FRAGMENTED_PACKETS;   /*!< (read-write) IPv4 Datagrams
                                                 Received with Fragmentation */
    uint32_t
        MAC_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS; /*!< (read-write) IPv4
                                                     Datagrams Received with
                                                     UDP Checksum Disabled */
    uint32_t MAC_RXIPV6_GOOD_PACKETS; /*!< (read-write) Good IPv6 Datagrams
                                         Received */
    uint32_t MAC_RXIPV6_HEADER_ERROR_PACKETS; /*!< (read-write) IPv6 Datagrams
                                                 Received with Header Errors */
    uint32_t MAC_RXIPV6_NO_PAYLOAD_PACKETS;   /*!< (read-write) IPv6 Datagrams
                                                 Received with No Payload */
    uint32_t MAC_RXUDP_GOOD_PACKETS;  /*!< (read-write) IPv6 Datagrams Received
                                         with Good UDP */
    uint32_t MAC_RXUDP_ERROR_PACKETS; /*!< (read-write) IPv6 Datagrams Received
                                         with UDP Checksum Error */
    uint32_t MAC_RXTCP_GOOD_PACKETS;  /*!< (read-write) IPv6 Datagrams Received
                                         with Good TCP Payload */
    uint32_t MAC_RXTCP_ERROR_PACKETS; /*!< (read-write) IPv6 Datagrams Received
                                         with TCP Checksum Error */
    uint32_t MAC_RXICMP_GOOD_PACKETS; /*!< (read-write) IPv6 Datagrams Received
                                         with Good ICMP Payload */
    uint32_t MAC_RXICMP_ERROR_PACKETS; /*!< (read-write) IPv6 Datagrams
                                          Received with ICMP Checksum Error */
    static constexpr std::size_t reserved_padding19_length = 2;
    const uint32_t reserved_padding19[reserved_padding19_length] = {};
    uint32_t MAC_RXIPV4_GOOD_OCTETS; /*!< (read-write) Good Bytes Received in
                                        IPv4 Datagrams */
    uint32_t
        MAC_RXIPV4_HEADER_ERROR_OCTETS;    /*!< (read-write) Bytes Received in
                                              IPv4 Datagrams with Header Errors */
    uint32_t MAC_RXIPV4_NO_PAYLOAD_OCTETS; /*!< (read-write) Bytes Received in
                                              IPv4 Datagrams with No Payload */
    uint32_t MAC_RXIPV4_FRAGMENTED_OCTETS; /*!< (read-write) Bytes Received in
                                              Fragmented IPv4 Datagrams */
    uint32_t MAC_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS; /*!< (read-write) Bytes
                                                        Received with UDP
                                                        Checksum Disabled */
    uint32_t MAC_RXIPV6_GOOD_OCTETS; /*!< (read-write) Bytes Received in Good
                                        IPv6 Datagrams */
    uint32_t
        MAC_RXIPV6_HEADER_ERROR_OCTETS;    /*!< (read-write) Bytes Received in
                                              IPv6 Datagrams with Data Errors */
    uint32_t MAC_RXIPV6_NO_PAYLOAD_OCTETS; /*!< (read-write) Bytes Received in
                                              IPv6 Datagrams with No Payload */
    uint32_t MAC_RXUDP_GOOD_OCTETS;   /*!< (read-write) Bytes Received in Good
                                         UDP Segment */
    uint32_t MAC_RXUDP_ERROR_OCTETS;  /*!< (read-write) Bytes Received in UDP
                                         Segment with Checksum Errors */
    uint32_t MAC_RXTCP_GOOD_OCTETS;   /*!< (read-write) Bytes Received in Good
                                         TCP Segment */
    uint32_t MAC_RXTCP_ERROR_OCTETS;  /*!< (read-write) Bytes Received in TCP
                                         Segment with Checksum Errors */
    uint32_t MAC_RXICMP_GOOD_OCTETS;  /*!< (read-write) Bytes Received in Good
                                         ICMP Segment */
    uint32_t MAC_RXICMP_ERROR_OCTETS; /*!< (read-write) Bytes Received in ICMP
                                         Segment with Checksum Errors */
    static constexpr std::size_t reserved_padding20_length = 6;
    const uint32_t reserved_padding20[reserved_padding20_length] = {};
    uint32_t MAC_MMC_FPE_TX_INTERRUPT;      /*!< (read-write) MMC FPE Transmit
                                               Interrupt */
    uint32_t MAC_MMC_FPE_TX_INTERRUPT_MASK; /*!< (read-write) MMC FPE Transmit
                                               Mask Interrupt */
    uint32_t MAC_MMC_TX_FPE_FRAGMENT_CNTR;  /*!< (read-write) MMC FPE
                                               Transmitted Fragment Counter */
    uint32_t MAC_MMC_TX_HOLD_REQ_CNTR; /*!< (read-write) MMC FPE Transmitted
                                          Hold Request Counter */
    static constexpr std::size_t reserved_padding21_length = 4;
    const uint32_t reserved_padding21[reserved_padding21_length] = {};
    uint32_t MAC_MMC_FPE_RX_INTERRUPT;      /*!< (read-write) MMC FPE Receive
                                               Interrupt */
    uint32_t MAC_MMC_FPE_RX_INTERRUPT_MASK; /*!< (read-write) MMC FPE Receive
                                               Interrupt Mask */
    uint32_t MAC_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR; /*!< (read-write) MMC Receive
                                                     Packet Reassembly Error
                                                     Counter */
    uint32_t MAC_MMC_RX_PACKET_SMD_ERR_CNTR;      /*!< (read-write) MMC Receive
                                                     Packet SMD Error Counter */
    uint32_t MAC_MMC_RX_PACKET_ASSEMBLY_OK_CNTR;  /*!< (read-write) MMC Receive
                                                     Packet Successful
                                                     Reassembly Counter */
    uint32_t MAC_MMC_RX_FPE_FRAGMENT_CNTR; /*!< (read-write) MMC FPE Received
                                              Fragment Counter */
    static constexpr std::size_t reserved_padding22_length = 10;
    const uint32_t reserved_padding22[reserved_padding22_length] = {};
    uint32_t MAC_L3_L4_CONTROL0;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 0 */
    uint32_t MAC_LAYER4_ADDRESS0; /*!< (read-write) Layer 4 Address 0 */
    static constexpr std::size_t reserved_padding23_length = 2;
    const uint32_t reserved_padding23[reserved_padding23_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG0; /*!< (read-write) Layer 3 Address 0
                                       Register 0 */
    uint32_t MAC_LAYER3_ADDR1_REG0; /*!< (read-write) Layer 3 Address 1
                                       Register 0 */
    uint32_t MAC_LAYER3_ADDR2_REG0; /*!< (read-write) Layer 3 Address 2
                                       Register 0 */
    uint32_t MAC_LAYER3_ADDR3_REG0; /*!< (read-write) Layer 3 Address 3
                                       Register 0 */
    static constexpr std::size_t reserved_padding24_length = 4;
    const uint32_t reserved_padding24[reserved_padding24_length] = {};
    uint32_t MAC_L3_L4_CONTROL1;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 1 */
    uint32_t MAC_LAYER4_ADDRESS1; /*!< (read-write) Layer 4 Address 0 */
    static constexpr std::size_t reserved_padding25_length = 2;
    const uint32_t reserved_padding25[reserved_padding25_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG1; /*!< (read-write) Layer 3 Address 0
                                       Register 1 */
    uint32_t MAC_LAYER3_ADDR1_REG1; /*!< (read-write) Layer 3 Address 1
                                       Register 1 */
    uint32_t MAC_LAYER3_ADDR2_REG1; /*!< (read-write) Layer 3 Address 2
                                       Register 1 */
    uint32_t MAC_LAYER3_ADDR3_REG1; /*!< (read-write) Layer 3 Address 3
                                       Register 1 */
    static constexpr std::size_t reserved_padding26_length = 4;
    const uint32_t reserved_padding26[reserved_padding26_length] = {};
    uint32_t MAC_L3_L4_CONTROL2;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 2 */
    uint32_t MAC_LAYER4_ADDRESS2; /*!< (read-write) Layer 4 Address 2 */
    static constexpr std::size_t reserved_padding27_length = 2;
    const uint32_t reserved_padding27[reserved_padding27_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG2; /*!< (read-write) Layer 3 Address 0
                                       Register 2 */
    uint32_t MAC_LAYER3_ADDR1_REG2; /*!< (read-write) Layer 3 Address 0
                                       Register 2 */
    uint32_t MAC_LAYER3_ADDR2_REG2; /*!< (read-write) Layer 3 Address 2
                                       Register 2 */
    uint32_t MAC_LAYER3_ADDR3_REG2; /*!< (read-write) Layer 3 Address 3
                                       Register 2 */
    static constexpr std::size_t reserved_padding28_length = 4;
    const uint32_t reserved_padding28[reserved_padding28_length] = {};
    uint32_t MAC_L3_L4_CONTROL3;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 3 */
    uint32_t MAC_LAYER4_ADDRESS3; /*!< (read-write) Layer 4 Address 3 */
    static constexpr std::size_t reserved_padding29_length = 2;
    const uint32_t reserved_padding29[reserved_padding29_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG3; /*!< (read-write) Layer 3 Address 0
                                       Register 3 */
    uint32_t MAC_LAYER3_ADDR1_REG3; /*!< (read-write) Layer 3 Address 1
                                       Register 3 */
    uint32_t MAC_LAYER3_ADDR2_REG3; /*!< (read-write) Layer 3 Address 2
                                       Register 3 */
    uint32_t MAC_LAYER3_ADDR3_REG3; /*!< (read-write) Layer 3 Address 3
                                       Register 3 */
    static constexpr std::size_t reserved_padding30_length = 4;
    const uint32_t reserved_padding30[reserved_padding30_length] = {};
    uint32_t MAC_L3_L4_CONTROL4;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 4 */
    uint32_t MAC_LAYER4_ADDRESS4; /*!< (read-write) Layer 4 Address 4 */
    static constexpr std::size_t reserved_padding31_length = 2;
    const uint32_t reserved_padding31[reserved_padding31_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG4; /*!< (read-write) Layer 3 Address 0
                                       Register 4 */
    uint32_t MAC_LAYER3_ADDR1_REG4; /*!< (read-write) Layer 3 Address 1
                                       Register 4 */
    uint32_t MAC_LAYER3_ADDR2_REG4; /*!< (read-write) Layer 3 Address 2
                                       Register 4 */
    uint32_t MAC_LAYER3_ADDR3_REG4; /*!< (read-write) Layer 3 Address 3
                                       Register 4 */
    static constexpr std::size_t reserved_padding32_length = 4;
    const uint32_t reserved_padding32[reserved_padding32_length] = {};
    uint32_t MAC_L3_L4_CONTROL5;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 5 */
    uint32_t MAC_LAYER4_ADDRESS5; /*!< (read-write) Layer 4 Address 5 */
    static constexpr std::size_t reserved_padding33_length = 2;
    const uint32_t reserved_padding33[reserved_padding33_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG5; /*!< (read-write) Layer 3 Address 0
                                       Register 5 */
    uint32_t MAC_LAYER3_ADDR1_REG5; /*!< (read-write) Layer 3 Address 1
                                       Register 5 */
    uint32_t MAC_LAYER3_ADDR2_REG5; /*!< (read-write) Layer 3 Address 2
                                       Register 5 */
    uint32_t MAC_LAYER3_ADDR3_REG5; /*!< (read-write) Layer 3 Address 3
                                       Register 5 */
    static constexpr std::size_t reserved_padding34_length = 4;
    const uint32_t reserved_padding34[reserved_padding34_length] = {};
    uint32_t MAC_L3_L4_CONTROL6;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 6 */
    uint32_t MAC_LAYER4_ADDRESS6; /*!< (read-write) Layer 4 Address 6 */
    static constexpr std::size_t reserved_padding35_length = 2;
    const uint32_t reserved_padding35[reserved_padding35_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG6; /*!< (read-write) Layer 3 Address 0
                                       Register 6 */
    uint32_t MAC_LAYER3_ADDR1_REG6; /*!< (read-write) Layer 3 Address 1
                                       Register 6 */
    uint32_t MAC_LAYER3_ADDR2_REG6; /*!< (read-write) Layer 3 Address 2
                                       Register 6 */
    uint32_t MAC_LAYER3_ADDR3_REG6; /*!< (read-write) Layer 3 Address 3
                                       Register 6 */
    static constexpr std::size_t reserved_padding36_length = 4;
    const uint32_t reserved_padding36[reserved_padding36_length] = {};
    uint32_t MAC_L3_L4_CONTROL7;  /*!< (read-write) Layer 3 and Layer 4 Control
                                     of Filter 0 */
    uint32_t MAC_LAYER4_ADDRESS7; /*!< (read-write) Layer 4 Address 7 */
    static constexpr std::size_t reserved_padding37_length = 2;
    const uint32_t reserved_padding37[reserved_padding37_length] = {};
    uint32_t MAC_LAYER3_ADDR0_REG7; /*!< (read-write) Layer 3 Address 0
                                       Register 7 */
    uint32_t MAC_LAYER3_ADDR1_REG7; /*!< (read-write) Layer 3 Address 1
                                       Register 7 */
    uint32_t MAC_LAYER3_ADDR2_REG7; /*!< (read-write) Layer 3 Address 2
                                       Register 7 */
    uint32_t MAC_LAYER3_ADDR3_REG7; /*!< (read-write) Layer 3 Address 3
                                       Register 7 */
    static constexpr std::size_t reserved_padding38_length = 36;
    const uint32_t reserved_padding38[reserved_padding38_length] = {};
    uint32_t MAC_TIMESTAMP_CONTROL;    /*!< (read-write) Timestamp Control */
    uint32_t MAC_SUB_SECOND_INCREMENT; /*!< (read-write) Subsecond Increment */
    uint32_t MAC_SYSTEM_TIME_SECONDS;  /*!< (read-write) System Time Seconds */
    uint32_t MAC_SYSTEM_TIME_NANOSECONDS;        /*!< (read-write) System Time
                                                    Nanoseconds */
    uint32_t MAC_SYSTEM_TIME_SECONDS_UPDATE;     /*!< (read-write) System Time
                                                    Seconds Update */
    uint32_t MAC_SYSTEM_TIME_NANOSECONDS_UPDATE; /*!< (read-write) System Time
                                                    Nanoseconds Update */
    uint32_t MAC_TIMESTAMP_ADDEND; /*!< (read-write) Timestamp Addend */
    uint32_t MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS; /*!< (read-write) System Time
                                                     - Higher Word Seconds */
    uint32_t MAC_TIMESTAMP_STATUS; /*!< (read-write) Timestamp Status */
    static constexpr std::size_t reserved_padding39_length = 3;
    const uint32_t reserved_padding39[reserved_padding39_length] = {};
    uint32_t
        MAC_TX_TIMESTAMP_STATUS_NANOSECONDS;  /*!< (read-write) Transmit
                                                 Timestamp Status Nanoseconds */
    uint32_t MAC_TX_TIMESTAMP_STATUS_SECONDS; /*!< (read-write) Transmit
                                                 Timestamp Status Seconds */
    static constexpr std::size_t reserved_padding40_length = 2;
    const uint32_t reserved_padding40[reserved_padding40_length] = {};
    uint32_t
        MAC_AUXILIARY_CONTROL; /*!< (read-write) Auxiliary Timestamp Control */
    const uint32_t reserved_padding41 = {};
    uint32_t MAC_AUXILIARY_TIMESTAMP_NANOSECONDS; /*!< (read-write) Auxiliary
                                                     Timestamp Nanoseconds */
    uint32_t MAC_AUXILIARY_TIMESTAMP_SECONDS;     /*!< (read-write) Auxiliary
                                                     Timestamp Seconds */
    uint32_t
        MAC_TIMESTAMP_INGRESS_ASYM_CORR; /*!< (read-write) Timestamp Ingress
                                            Asymmetry Correction */
    uint32_t MAC_TIMESTAMP_EGRESS_ASYM_CORR; /*!< (read-write) imestamp Egress
                                                Asymmetry Correction */
    uint32_t MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND; /*!< (read-write) Timestamp
                                                       Ingress Correction
                                                       Nanosecond */
    uint32_t MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND;  /*!< (read-write) Timestamp
                                                       Egress Correction
                                                       Nanosecond */
    uint32_t MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC; /*!< (read-write) Timestamp
                                                       Ingress Correction
                                                       Subnanosecond */
    uint32_t MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC;  /*!< (read-write) Timestamp
                                                       Egress Correction
                                                       Subnanosecond */
    uint32_t MAC_TIMESTAMP_INGRESS_LATENCY; /*!< (read-write) Timestamp Ingress
                                               Latency */
    uint32_t MAC_TIMESTAMP_EGRESS_LATENCY;  /*!< (read-write) Timestamp Egress
                                               Latency */
    uint32_t MAC_PPS_CONTROL;               /*!< (read-write) PPS Control */
    static constexpr std::size_t reserved_padding42_length = 3;
    const uint32_t reserved_padding42[reserved_padding42_length] = {};
    uint32_t MAC_PPS0_TARGET_TIME_SECONDS; /*!< (read-write) PPS0 Target Time
                                              Seconds */
    uint32_t MAC_PPS0_TARGET_TIME_NANOSECONDS; /*!< (read-write) PPS0 Target
                                                  Time Nanoseconds */
    uint32_t MAC_PPS0_INTERVAL;            /*!< (read-write) PPS0 Interval */
    uint32_t MAC_PPS0_WIDTH;               /*!< (read-write) PPS0 Width */
    uint32_t MAC_PPS1_TARGET_TIME_SECONDS; /*!< (read-write) PPS1 Target Time
                                              Seconds */
    uint32_t MAC_PPS1_TARGET_TIME_NANOSECONDS; /*!< (read-write) PPS1 Target
                                                  Time Nanoseconds */
    uint32_t MAC_PPS1_INTERVAL;            /*!< (read-write) PPS1 Interval */
    uint32_t MAC_PPS1_WIDTH;               /*!< (read-write) PPS1 Width */
    uint32_t MAC_PPS2_TARGET_TIME_SECONDS; /*!< (read-write) PPS2 Target Time
                                              Seconds */
    uint32_t MAC_PPS2_TARGET_TIME_NANOSECONDS; /*!< (read-write) PPS2 Target
                                                  Time Nanoseconds */
    uint32_t MAC_PPS2_INTERVAL;            /*!< (read-write) PPS2 Interval */
    uint32_t MAC_PPS2_WIDTH;               /*!< (read-write) PPS2 Width */
    uint32_t MAC_PPS3_TARGET_TIME_SECONDS; /*!< (read-write) PPS3 Target Time
                                              Seconds */
    uint32_t MAC_PPS3_TARGET_TIME_NANOSECONDS; /*!< (read-write) PPS3 Target
                                                  Time Nanoseconds */
    uint32_t MAC_PPS3_INTERVAL; /*!< (read-write) PPS3 Interval */
    uint32_t MAC_PPS3_WIDTH;    /*!< (read-write) PPS3 Width */
    uint32_t MAC_PTO_CONTROL;   /*!< (read-write) PTP Offload Engine Control */
    uint32_t
        MAC_SOURCE_PORT_IDENTITY0; /*!< (read-write) Source Port Identity 0 */
    uint32_t
        MAC_SOURCE_PORT_IDENTITY1; /*!< (read-write) Source Port Identity 1 */
    uint32_t
        MAC_SOURCE_PORT_IDENTITY2; /*!< (read-write) Source Port Identity 2 */
    uint32_t
        MAC_LOG_MESSAGE_INTERVAL; /*!< (read-write) Log Message Interval */
    static constexpr std::size_t reserved_padding43_length = 11;
    const uint32_t reserved_padding43[reserved_padding43_length] = {};
    uint32_t MTL_OPERATION_MODE; /*!< (read-write) MTL Operation Mode */
    const uint32_t reserved_padding44 = {};
    uint32_t
        MTL_DBG_CTL; /*!< (read-write) FIFO Debug Access Control and Status */
    uint32_t MTL_DBG_STS;         /*!< (read-write) FIFO Debug Status */
    uint32_t MTL_FIFO_DEBUG_DATA; /*!< (read-write) FIFO Debug Data */
    static constexpr std::size_t reserved_padding45_length = 3;
    const uint32_t reserved_padding45[reserved_padding45_length] = {};
    uint32_t MTL_INTERRUPT_STATUS; /*!< (read-write) MTL Interrupt Status */
    static constexpr std::size_t reserved_padding46_length = 3;
    const uint32_t reserved_padding46[reserved_padding46_length] = {};
    uint32_t MTL_RXQ_DMA_MAP0; /*!< (read-write) Receive Queue and DMA Channel
                                  Mapping 0 */
    uint32_t MTL_RXQ_DMA_MAP1; /*!< (read-write) Receive Queue and DMA Channel
                                  Mapping 1 */
    static constexpr std::size_t reserved_padding47_length = 2;
    const uint32_t reserved_padding47[reserved_padding47_length] = {};
    uint32_t MTL_TBS_CTRL; /*!< (read-write) Time Based Scheduling Control */
    static constexpr std::size_t reserved_padding48_length = 3;
    const uint32_t reserved_padding48[reserved_padding48_length] = {};
    uint32_t MTL_EST_CONTROL; /*!< (read-write) Enhancements to Scheduled
                                 Transmission Control */
    const uint32_t reserved_padding49 = {};
    uint32_t MTL_EST_STATUS; /*!< (read-write) Enhancements to Scheduled
                                Transmission Status */
    const uint32_t reserved_padding50 = {};
    uint32_t MTL_EST_SCH_ERROR;      /*!< (read-write) EST Scheduling Error */
    uint32_t MTL_EST_FRM_SIZE_ERROR; /*!< (read-write) EST Frame Size Error */
    uint32_t
        MTL_EST_FRM_SIZE_CAPTURE; /*!< (read-write) EST Frame Size Capture */
    const uint32_t reserved_padding51 = {};
    uint32_t MTL_EST_INTR_ENABLE; /*!< (read-write) EST Interrupt Enable */
    static constexpr std::size_t reserved_padding52_length = 3;
    const uint32_t reserved_padding52[reserved_padding52_length] = {};
    uint32_t MTL_EST_GCL_CONTROL; /*!< (read-write) EST GCL Control */
    uint32_t MTL_EST_GCL_DATA;    /*!< (read-write) EST GCL Data */
    static constexpr std::size_t reserved_padding53_length = 2;
    const uint32_t reserved_padding53[reserved_padding53_length] = {};
    uint32_t MTL_FPE_CTRL_STS; /*!< (read-write) Frame Preemption Control and
                                  Status */
    uint32_t MTL_FPE_ADVANCE;  /*!< (read-write) Frame Preemption Hold and
                                  Release Advance */
    static constexpr std::size_t reserved_padding54_length = 2;
    const uint32_t reserved_padding54[reserved_padding54_length] = {};
    uint32_t MTL_RXP_CONTROL_STATUS; /*!< (read-write) RXP Control Status */
    uint32_t MTL_RXP_INTERRUPT_CONTROL_STATUS; /*!< (read-write) RXP Interrupt
                                                  Control Status */
    uint32_t MTL_RXP_DROP_CNT;  /*!< (read-write) RXP Drop Count */
    uint32_t MTL_RXP_ERROR_CNT; /*!< (read-write) RXP Error Count */
    uint32_t
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS; /*!< (read-write) RXP Indirect
                                                Access Control and Status */
    uint32_t MTL_RXP_INDIRECT_ACC_DATA; /*!< (read-write) RXP Indirect Access
                                           Data */
    static constexpr std::size_t reserved_padding55_length = 18;
    const uint32_t reserved_padding55[reserved_padding55_length] = {};
    uint32_t MTL_TXQ0_OPERATION_MODE; /*!< (read-write) Queue 0 Transmit
                                         Operation Mode */
    uint32_t MTL_TXQ0_UNDERFLOW; /*!< (read-write) Queue 0 Underflow Counter */
    uint32_t MTL_TXQ0_DEBUG;     /*!< (read-write) Queue 0 Transmit Debug */
    static constexpr std::size_t reserved_padding56_length = 2;
    const uint32_t reserved_padding56[reserved_padding56_length] = {};
    uint32_t MTL_TXQ0_ETS_STATUS;     /*!< (read-write) Queue 0 ETS Status */
    uint32_t MTL_TXQ0_QUANTUM_WEIGHT; /*!< (read-write) Queue 0 Quantum or
                                         Weights */
    static constexpr std::size_t reserved_padding57_length = 4;
    const uint32_t reserved_padding57[reserved_padding57_length] = {};
    uint32_t MTL_Q0_INTERRUPT_CONTROL_STATUS; /*!< (read-write) Queue 0
                                                 Interrupt Control Status */
    uint32_t MTL_RXQ0_OPERATION_MODE;         /*!< (read-write) Queue 0 Receive
                                                 Operation Mode */
    uint32_t
        MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT; /*!< (read-write) Queue 0 Missed
                                                Packet and Overflow Counter */
    uint32_t MTL_RXQ0_DEBUG;   /*!< (read-write) Queue 0 Receive Debug */
    uint32_t MTL_RXQ0_CONTROL; /*!< (read-write) Queue 0 Receive Control */
    uint32_t MTL_TXQ1_OPERATION_MODE; /*!< (read-write) Queue 1 Transmit
                                         Operation Mode */
    uint32_t MTL_TXQ1_UNDERFLOW; /*!< (read-write) Queue 1 Underflow Counter */
    uint32_t MTL_TXQ1_DEBUG;     /*!< (read-write) Queue 1 Transmit Debug */
    const uint32_t reserved_padding58 = {};
    uint32_t MTL_TXQ1_ETS_CONTROL;    /*!< (read-write) Queue 1 ETS Control */
    uint32_t MTL_TXQ1_ETS_STATUS;     /*!< (read-write) Queue 1 ETS Status */
    uint32_t MTL_TXQ1_QUANTUM_WEIGHT; /*!< (read-write) Queue 1
                                         idleSlopeCredit, Quantum or Weights */
    uint32_t
        MTL_TXQ1_SENDSLOPECREDIT; /*!< (read-write) Queue 1 sendSlopeCredit */
    uint32_t MTL_TXQ1_HICREDIT;   /*!< (read-write) Queue 1 hiCredit */
    uint32_t MTL_TXQ1_LOCREDIT;   /*!< (read-write) Queue 1 loCredit */
    const uint32_t reserved_padding59 = {};
    uint32_t MTL_Q1_INTERRUPT_CONTROL_STATUS; /*!< (read-write) Queue 1
                                                 Interrupt Control Status */
    uint32_t MTL_RXQ1_OPERATION_MODE;         /*!< (read-write) Queue 1 Receive
                                                 Operation Mode */
    uint32_t
        MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT; /*!< (read-write) Queue 1 Missed
                                                Packet and Overflow Counter */
    uint32_t MTL_RXQ1_DEBUG;   /*!< (read-write) Queue 1 Receive Debug */
    uint32_t MTL_RXQ1_CONTROL; /*!< (read-write) Queue 1 Receive Control */
    uint32_t MTL_TXQ2_OPERATION_MODE; /*!< (read-write) Queue 2 Transmit
                                         Operation Mode */
    uint32_t MTL_TXQ2_UNDERFLOW; /*!< (read-write) Queue 2 Underflow Counter */
    uint32_t MTL_TXQ2_DEBUG;     /*!< (read-write) Queue 2 Transmit Debug */
    const uint32_t reserved_padding60 = {};
    uint32_t MTL_TXQ2_ETS_CONTROL;    /*!< (read-write) Queue 2 ETS Control */
    uint32_t MTL_TXQ2_ETS_STATUS;     /*!< (read-write) Queue 2 ETS Status */
    uint32_t MTL_TXQ2_QUANTUM_WEIGHT; /*!< (read-write) Queue 2
                                         idleSlopeCredit, Quantum or Weights */
    uint32_t
        MTL_TXQ2_SENDSLOPECREDIT; /*!< (read-write) Queue 2 sendSlopeCredit */
    uint32_t MTL_TXQ2_HICREDIT;   /*!< (read-write) Queue 2 hiCredit */
    uint32_t MTL_TXQ2_LOCREDIT;   /*!< (read-write) Queue 2 loCredit */
    const uint32_t reserved_padding61 = {};
    uint32_t MTL_Q2_INTERRUPT_CONTROL_STATUS; /*!< (read-write) Queue 2
                                                 Interrupt Control Status */
    uint32_t MTL_RXQ2_OPERATION_MODE;         /*!< (read-write) Queue 2 Receive
                                                 Operation Mode */
    uint32_t
        MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT; /*!< (read-write) Queue 2 Missed
                                                Packet and Overflow Counter */
    uint32_t MTL_RXQ2_DEBUG;   /*!< (read-write) Queue 2 Receive Debug */
    uint32_t MTL_RXQ2_CONTROL; /*!< (read-write) Queue 2 Receive Control */
    uint32_t MTL_TXQ3_OPERATION_MODE; /*!< (read-write) Queue 3 Transmit
                                         Operation Mode */
    uint32_t MTL_TXQ3_UNDERFLOW; /*!< (read-write) Queue 3 Underflow Counter */
    uint32_t MTL_TXQ3_DEBUG;     /*!< (read-write) Queue 3 Transmit Debug */
    const uint32_t reserved_padding62 = {};
    uint32_t MTL_TXQ3_ETS_CONTROL;    /*!< (read-write) Queue 3 ETS Control */
    uint32_t MTL_TXQ3_ETS_STATUS;     /*!< (read-write) Queue 3 ETS Status */
    uint32_t MTL_TXQ3_QUANTUM_WEIGHT; /*!< (read-write) Queue 3
                                         idleSlopeCredit, Quantum or Weights */
    uint32_t
        MTL_TXQ3_SENDSLOPECREDIT; /*!< (read-write) Queue 3 sendSlopeCredit */
    uint32_t MTL_TXQ3_HICREDIT;   /*!< (read-write) Queue 3 hiCredit */
    uint32_t MTL_TXQ3_LOCREDIT;   /*!< (read-write) Queue 3 loCredit */
    const uint32_t reserved_padding63 = {};
    uint32_t MTL_Q3_INTERRUPT_CONTROL_STATUS; /*!< (read-write) Queue 3
                                                 Interrupt Control Status */
    uint32_t MTL_RXQ3_OPERATION_MODE;         /*!< (read-write) Queue 3 Receive
                                                 Operation Mode */
    uint32_t
        MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT; /*!< (read-write) Queue 3 Missed
                                                Packet and Overflow Counter */
    uint32_t MTL_RXQ3_DEBUG;   /*!< (read-write) Queue 3 Receive Debug */
    uint32_t MTL_RXQ3_CONTROL; /*!< (read-write) Queue 3 Receive Control */
    uint32_t MTL_TXQ4_OPERATION_MODE; /*!< (read-write) Queue 4 Transmit
                                         Operation Mode */
    uint32_t MTL_TXQ4_UNDERFLOW; /*!< (read-write) Queue 4 Underflow Counter */
    uint32_t MTL_TXQ4_DEBUG;     /*!< (read-write) Queue 4 Transmit Debug */
    const uint32_t reserved_padding64 = {};
    uint32_t MTL_TXQ4_ETS_CONTROL;    /*!< (read-write) Queue 4 ETS Control */
    uint32_t MTL_TXQ4_ETS_STATUS;     /*!< (read-write) Queue 4 ETS Status */
    uint32_t MTL_TXQ4_QUANTUM_WEIGHT; /*!< (read-write) Queue 4
                                         idleSlopeCredit, Quantum or Weights */
    uint32_t
        MTL_TXQ4_SENDSLOPECREDIT; /*!< (read-write) Queue 4 sendSlopeCredit */
    uint32_t MTL_TXQ4_HICREDIT;   /*!< (read-write) Queue 4 hiCredit */
    uint32_t MTL_TXQ4_LOCREDIT;   /*!< (read-write) Queue 4 loCredit */
    const uint32_t reserved_padding65 = {};
    uint32_t MTL_Q4_INTERRUPT_CONTROL_STATUS; /*!< (read-write) Queue 4
                                                 Interrupt Control Status */
    uint32_t MTL_RXQ4_OPERATION_MODE;         /*!< (read-write) Queue 4 Receive
                                                 Operation Mode */
    uint32_t
        MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT; /*!< (read-write) Queue 4 Missed
                                                Packet and Overflow Counter */
    uint32_t MTL_RXQ4_DEBUG;   /*!< (read-write) Queue 4 Receive Debug */
    uint32_t MTL_RXQ4_CONTROL; /*!< (read-write) Queue 4 Receive Control */
    static constexpr std::size_t reserved_padding66_length = 112;
    const uint32_t reserved_padding66[reserved_padding66_length] = {};
    uint32_t DMA_MODE;             /*!< (read-write) DMA Bus Mode */
    uint32_t DMA_SYSBUS_MODE;      /*!< (read-write) DMA System Bus Mode */
    uint32_t DMA_INTERRUPT_STATUS; /*!< (read-write) DMA Interrupt Status */
    uint32_t DMA_DEBUG_STATUS0;    /*!< (read-write) DMA Debug Status 0 */
    uint32_t DMA_DEBUG_STATUS1;    /*!< (read-write) DMA Debug Status 1 */
    static constexpr std::size_t reserved_padding67_length = 11;
    const uint32_t reserved_padding67[reserved_padding67_length] = {};
    uint32_t DMA_AXI_LPI_ENTRY_INTERVAL; /*!< (read-write) AXI LPI Entry
                                            Interval Control */
    static constexpr std::size_t reserved_padding68_length = 3;
    const uint32_t reserved_padding68[reserved_padding68_length] = {};
    uint32_t DMA_TBS_CTRL; /*!< (read-write) TBS Control */
    static constexpr std::size_t reserved_padding69_length = 43;
    const uint32_t reserved_padding69[reserved_padding69_length] = {};
    uint32_t DMA_CH0_CONTROL; /*!< (read-write) DMA Channel 0 Control */
    uint32_t
        DMA_CH0_TX_CONTROL; /*!< (read-write) DMA Channel 0 Transmit Control */
    uint32_t
        DMA_CH0_RX_CONTROL; /*!< (read-write) DMA Channel 0 Receive Control */
    static constexpr std::size_t reserved_padding70_length = 2;
    const uint32_t reserved_padding70[reserved_padding70_length] = {};
    uint32_t
        DMA_CH0_TXDESC_LIST_ADDRESS; /*!< (read-write) Channel 0 Tx Descriptor
                                        List Address register */
    const uint32_t reserved_padding71 = {};
    uint32_t
        DMA_CH0_RXDESC_LIST_ADDRESS; /*!< (read-write) Channel 0 Rx Descriptor
                                        List Address register */
    uint32_t DMA_CH0_TXDESC_TAIL_POINTER; /*!< (read-write) Channel 0 Tx
                                             Descriptor Tail Pointer */
    const uint32_t reserved_padding72 = {};
    uint32_t DMA_CH0_RXDESC_TAIL_POINTER; /*!< (read-write) Channel 0 Rx
                                             Descriptor Tail Pointer */
    uint32_t DMA_CH0_TXDESC_RING_LENGTH;  /*!< (read-write) Channel 0 Tx
                                             Descriptor Ring Length */
    uint32_t DMA_CH0_RXDESC_RING_LENGTH;  /*!< (read-write) Channel 0 Rx
                                             Descriptor Ring Length */
    uint32_t DMA_CH0_INTERRUPT_ENABLE;    /*!< (read-write) Channel 0 Interrupt
                                             Enable */
    uint32_t DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER; /*!< (read-write) Channel 0
                                                     Receive Interrupt Watchdog
                                                     Timer */
    uint32_t
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS; /*!< (read-write) Channel 0 Slot
                                                 Function Control and Status */
    const uint32_t reserved_padding73 = {};
    uint32_t DMA_CH0_CURRENT_APP_TXDESC; /*!< (read-write) Channel 0 Current
                                            Application Transmit Descriptor */
    const uint32_t reserved_padding74 = {};
    uint32_t DMA_CH0_CURRENT_APP_RXDESC; /*!< (read-write) Channel 0 Current
                                            Application Receive Descriptor */
    const uint32_t reserved_padding75 = {};
    uint32_t
        DMA_CH0_CURRENT_APP_TXBUFFER; /*!< (read-write) Channel 0 Current
                                         Application Transmit Buffer Address */
    const uint32_t reserved_padding76 = {};
    uint32_t
        DMA_CH0_CURRENT_APP_RXBUFFER; /*!< (read-write) Channel 0 Current
                                         Application Receive Buffer Address */
    uint32_t DMA_CH0_STATUS;          /*!< (read-write) DMA Channel 0 Status */
    uint32_t DMA_CH0_MISS_FRAME_CNT;  /*!< (read-write) Channel 0 Missed Frame
                                         Counter */
    uint32_t DMA_CH0_RXP_ACCEPT_CNT;  /*!< (read-write) Channel 0 RXP Frames
                                         Accepted Counter */
    uint32_t
        DMA_CH0_RX_ERI_CNT; /*!< (read-write) Channel 0 Receive ERI Counter */
    static constexpr std::size_t reserved_padding77_length = 4;
    const uint32_t reserved_padding77[reserved_padding77_length] = {};
    uint32_t DMA_CH1_CONTROL; /*!< (read-write) DMA Channel 1 Control */
    uint32_t
        DMA_CH1_TX_CONTROL; /*!< (read-write) DMA Channel 1 Transmit Control */
    uint32_t
        DMA_CH1_RX_CONTROL; /*!< (read-write) DMA Channel 1 Receive Control */
    static constexpr std::size_t reserved_padding78_length = 2;
    const uint32_t reserved_padding78[reserved_padding78_length] = {};
    uint32_t DMA_CH1_TXDESC_LIST_ADDRESS; /*!< (read-write) Channel 1 Tx
                                             Descriptor List Address */
    const uint32_t reserved_padding79 = {};
    uint32_t DMA_CH1_RXDESC_LIST_ADDRESS; /*!< (read-write) Channel 1 Rx
                                             Descriptor List Address */
    uint32_t DMA_CH1_TXDESC_TAIL_POINTER; /*!< (read-write) Channel 1 Tx
                                             Descriptor Tail Pointer */
    const uint32_t reserved_padding80 = {};
    uint32_t DMA_CH1_RXDESC_TAIL_POINTER; /*!< (read-write) Channel 1 Rx
                                             Descriptor Tail Pointer */
    uint32_t DMA_CH1_TXDESC_RING_LENGTH;  /*!< (read-write) Channel 1 Tx
                                             Descriptor Ring Length */
    uint32_t DMA_CH1_RXDESC_RING_LENGTH;  /*!< (read-write) Channel 1 Rx
                                             Descriptor Ring Length */
    uint32_t DMA_CH1_INTERRUPT_ENABLE;    /*!< (read-write) Channel 1 Interrupt
                                             Enable */
    uint32_t DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER; /*!< (read-write) Channel 1
                                                     Receive Interrupt Watchdog
                                                     Timer */
    uint32_t
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS; /*!< (read-write) Channel 1 Slot
                                                 Function Control and Status */
    const uint32_t reserved_padding81 = {};
    uint32_t DMA_CH1_CURRENT_APP_TXDESC; /*!< (read-write) Channel 1 Current
                                            Application Transmit Descriptor */
    const uint32_t reserved_padding82 = {};
    uint32_t DMA_CH1_CURRENT_APP_RXDESC; /*!< (read-write) Channel 1 Current
                                            Application Receive Descriptor */
    const uint32_t reserved_padding83 = {};
    uint32_t
        DMA_CH1_CURRENT_APP_TXBUFFER; /*!< (read-write) Channel 1 Current
                                         Application Transmit Buffer Address */
    const uint32_t reserved_padding84 = {};
    uint32_t
        DMA_CH1_CURRENT_APP_RXBUFFER; /*!< (read-write) Channel 1 Current
                                         Application Receive Buffer Address */
    uint32_t DMA_CH1_STATUS;          /*!< (read-write) DMA Channel 1 Status */
    uint32_t DMA_CH1_MISS_FRAME_CNT;  /*!< (read-write) Channel 1 Missed Frame
                                         Counter */
    uint32_t DMA_CH1_RXP_ACCEPT_CNT;  /*!< (read-write) Channel 1 RXP Frames
                                         Accepted Counter */
    uint32_t
        DMA_CH1_RX_ERI_CNT; /*!< (read-write) Channel 1 Receive ERI Counter */
    static constexpr std::size_t reserved_padding85_length = 4;
    const uint32_t reserved_padding85[reserved_padding85_length] = {};
    uint32_t DMA_CH2_CONTROL; /*!< (read-write) DMA Channel 2 Control */
    uint32_t
        DMA_CH2_TX_CONTROL; /*!< (read-write) DMA Channel 2 Transmit Control */
    uint32_t
        DMA_CH2_RX_CONTROL; /*!< (read-write) DMA Channel 2 Receive Control */
    static constexpr std::size_t reserved_padding86_length = 2;
    const uint32_t reserved_padding86[reserved_padding86_length] = {};
    uint32_t DMA_CH2_TXDESC_LIST_ADDRESS; /*!< (read-write) Channel 2 Tx
                                             Descriptor List Address */
    const uint32_t reserved_padding87 = {};
    uint32_t DMA_CH2_RXDESC_LIST_ADDRESS; /*!< (read-write) Channel 2 Rx
                                             Descriptor List Address */
    uint32_t DMA_CH2_TXDESC_TAIL_POINTER; /*!< (read-write) Channel 2 Tx
                                             Descriptor Tail Pointer */
    const uint32_t reserved_padding88 = {};
    uint32_t DMA_CH2_RXDESC_TAIL_POINTER; /*!< (read-write) Channel 2 Rx
                                             Descriptor Tail Pointer */
    uint32_t DMA_CH2_TXDESC_RING_LENGTH;  /*!< (read-write) Channel 2 Tx
                                             Descriptor Ring Length */
    uint32_t DMA_CH2_RXDESC_RING_LENGTH;  /*!< (read-write) Channel 2 Rx
                                             Descriptor Ring Length */
    uint32_t DMA_CH2_INTERRUPT_ENABLE;    /*!< (read-write) Channel 2 Interrupt
                                             Enable */
    uint32_t DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER; /*!< (read-write) Channel 2
                                                     Receive Interrupt Watchdog
                                                     Timer */
    uint32_t
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS; /*!< (read-write) Channel 2 Slot
                                                 Function Control and Status */
    const uint32_t reserved_padding89 = {};
    uint32_t DMA_CH2_CURRENT_APP_TXDESC; /*!< (read-write) Channel 2 Current
                                            Application Transmit Descriptor */
    const uint32_t reserved_padding90 = {};
    uint32_t DMA_CH2_CURRENT_APP_RXDESC; /*!< (read-write) Channel 2 Current
                                            Application Receive Descriptor */
    const uint32_t reserved_padding91 = {};
    uint32_t
        DMA_CH2_CURRENT_APP_TXBUFFER; /*!< (read-write) Channel 2 Current
                                         Application Transmit Buffer Address */
    const uint32_t reserved_padding92 = {};
    uint32_t
        DMA_CH2_CURRENT_APP_RXBUFFER; /*!< (read-write) Channel 2 Current
                                         Application Receive Buffer Address */
    uint32_t DMA_CH2_STATUS;          /*!< (read-write) DMA Channel 2 Status */
    uint32_t DMA_CH2_MISS_FRAME_CNT;  /*!< (read-write) Channel 2 Missed Frame
                                         Counter */
    uint32_t DMA_CH2_RXP_ACCEPT_CNT;  /*!< (read-write) Channel 2 RXP Frames
                                         Accepted Counter */
    uint32_t
        DMA_CH2_RX_ERI_CNT; /*!< (read-write) Channel 2 Receive ERI Counter */
    static constexpr std::size_t reserved_padding93_length = 4;
    const uint32_t reserved_padding93[reserved_padding93_length] = {};
    uint32_t DMA_CH3_CONTROL; /*!< (read-write) DMA Channel 3 Control */
    uint32_t
        DMA_CH3_TX_CONTROL; /*!< (read-write) DMA Channel 3 Transmit Control */
    uint32_t
        DMA_CH3_RX_CONTROL; /*!< (read-write) DMA Channel 3 Receive Control */
    static constexpr std::size_t reserved_padding94_length = 2;
    const uint32_t reserved_padding94[reserved_padding94_length] = {};
    uint32_t DMA_CH3_TXDESC_LIST_ADDRESS; /*!< (read-write) Channel 3 Tx
                                             Descriptor List Address */
    const uint32_t reserved_padding95 = {};
    uint32_t DMA_CH3_RXDESC_LIST_ADDRESS; /*!< (read-write) Channel 3 Rx
                                             Descriptor List Address */
    uint32_t DMA_CH3_TXDESC_TAIL_POINTER; /*!< (read-write) Channel 3 Tx
                                             Descriptor Tail Pointer */
    const uint32_t reserved_padding96 = {};
    uint32_t DMA_CH3_RXDESC_TAIL_POINTER; /*!< (read-write) Channel 3 Rx
                                             Descriptor Tail Pointer */
    uint32_t DMA_CH3_TXDESC_RING_LENGTH;  /*!< (read-write) Channel 3 Tx
                                             Descriptor Ring Length */
    uint32_t DMA_CH3_RXDESC_RING_LENGTH;  /*!< (read-write) Channel 3 Rx
                                             Descriptor Ring Length */
    uint32_t DMA_CH3_INTERRUPT_ENABLE;    /*!< (read-write) Channel 3 Interrupt
                                             Enable */
    uint32_t DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER; /*!< (read-write) Channel 3
                                                     Receive Interrupt Watchdog
                                                     Time */
    uint32_t
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS; /*!< (read-write) Channel 3 Slot
                                                 Function Control and Status */
    const uint32_t reserved_padding97 = {};
    uint32_t DMA_CH3_CURRENT_APP_TXDESC; /*!< (read-write) Channel 3 Current
                                            Application Transmit Descriptor */
    const uint32_t reserved_padding98 = {};
    uint32_t DMA_CH3_CURRENT_APP_RXDESC; /*!< (read-write) Channel 3 Current
                                            Application Receive Descriptor */
    const uint32_t reserved_padding99 = {};
    uint32_t
        DMA_CH3_CURRENT_APP_TXBUFFER; /*!< (read-write) Channel 3 Current
                                         Application Transmit Buffer Address */
    const uint32_t reserved_padding100 = {};
    uint32_t
        DMA_CH3_CURRENT_APP_RXBUFFER; /*!< (read-write) Channel 3 Current
                                         Application Receive Buffer Address */
    uint32_t DMA_CH3_STATUS;          /*!< (read-write) DMA Channel 3 Status */
    uint32_t DMA_CH3_MISS_FRAME_CNT;  /*!< (read-write) Channel 3 Missed Frame
                                         Counter */
    uint32_t DMA_CH3_RXP_ACCEPT_CNT;  /*!< (read-write) Channel 3 RXP Frames
                                         Accepted Counter */
    uint32_t
        DMA_CH3_RX_ERI_CNT; /*!< (read-write) Channel 3 Receive ERI Counter */
    static constexpr std::size_t reserved_padding101_length = 4;
    const uint32_t reserved_padding101[reserved_padding101_length] = {};
    uint32_t DMA_CH4_CONTROL; /*!< (read-write) DMA Channel 4 Control */
    uint32_t
        DMA_CH4_TX_CONTROL; /*!< (read-write) DMA Channel 4 Transmit Control */
    uint32_t
        DMA_CH4_RX_CONTROL; /*!< (read-write) DMA Channel 4 Receive Control */
    static constexpr std::size_t reserved_padding102_length = 2;
    const uint32_t reserved_padding102[reserved_padding102_length] = {};
    uint32_t DMA_CH4_TXDESC_LIST_ADDRESS; /*!< (read-write) Channel 4 Tx
                                             Descriptor List Address */
    const uint32_t reserved_padding103 = {};
    uint32_t DMA_CH4_RXDESC_LIST_ADDRESS; /*!< (read-write) Channel 4 Rx
                                             Descriptor List Address */
    uint32_t DMA_CH4_TXDESC_TAIL_POINTER; /*!< (read-write) Channel 4 Tx
                                             Descriptor Tail Pointer */
    const uint32_t reserved_padding104 = {};
    uint32_t DMA_CH4_RXDESC_TAIL_POINTER; /*!< (read-write) Channel 4 Rx
                                             Descriptor Tail Pointer */
    uint32_t DMA_CH4_TXDESC_RING_LENGTH;  /*!< (read-write) Channel 4 Tx
                                             Descriptor Ring Length */
    uint32_t DMA_CH4_RXDESC_RING_LENGTH;  /*!< (read-write) Channel 4 Rx
                                             Descriptor Ring Length */
    uint32_t DMA_CH4_INTERRUPT_ENABLE;    /*!< (read-write) Channel 4 Interrupt
                                             Enable */
    uint32_t DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER; /*!< (read-write) Channel 4
                                                     Receive Interrupt Watchdog
                                                     Timer */
    uint32_t
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS; /*!< (read-write) Channel 4 Slot
                                                 Function Control and Status */
    const uint32_t reserved_padding105 = {};
    uint32_t DMA_CH4_CURRENT_APP_TXDESC; /*!< (read-write) Channel 4 Current
                                            Application Transmit Descriptor */
    const uint32_t reserved_padding106 = {};
    uint32_t DMA_CH4_CURRENT_APP_RXDESC; /*!< (read-write) Channel 4 Current
                                            Application Receive Descriptor */
    const uint32_t reserved_padding107 = {};
    uint32_t
        DMA_CH4_CURRENT_APP_TXBUFFER; /*!< (read-write) Channel 4 Current
                                         Application Transmit Buffer Address */
    const uint32_t reserved_padding108 = {};
    uint32_t
        DMA_CH4_CURRENT_APP_RXBUFFER; /*!< (read-write) Channel 4 Current
                                         Application Receive Buffer Address */
    uint32_t DMA_CH4_STATUS;          /*!< (read-write) DMA Channel 4 Status */
    uint32_t DMA_CH4_MISS_FRAME_CNT;  /*!< (read-write) Channel 4 Missed Frame
                                         Counter */
    uint32_t DMA_CH4_RXP_ACCEPT_CNT;  /*!< (read-write) Channel 4 RXP Frames
                                         Accepted Counter */
    uint32_t
        DMA_CH4_RX_ERI_CNT; /*!< (read-write) Channel 4 Receive ERI Counter */

    /* Methods. */

    /**
     * Get MAC_CONFIGURATION's SARC field.
     *
     * Source Address Insertion or Replacement Control
     */
    inline ENET_QOS_MAC_CONFIGURATION_SARC
    get_MAC_CONFIGURATION_SARC() volatile
    {
        return ENET_QOS_MAC_CONFIGURATION_SARC((MAC_CONFIGURATION >> 28u) &
                                               0b111u);
    }

    /**
     * Set MAC_CONFIGURATION's SARC field.
     *
     * Source Address Insertion or Replacement Control
     */
    inline void set_MAC_CONFIGURATION_SARC(
        ENET_QOS_MAC_CONFIGURATION_SARC value) volatile
    {
        uint32_t curr = MAC_CONFIGURATION;

        curr &= ~(0b111u << 28u);
        curr |= (std::to_underlying(value) & 0b111u) << 28u;

        MAC_CONFIGURATION = curr;
    }

    /**
     * Get MAC_CONFIGURATION's IPC bit.
     *
     * Checksum Offload
     */
    inline bool get_MAC_CONFIGURATION_IPC() volatile
    {
        return MAC_CONFIGURATION & (1u << 27u);
    }

    /**
     * Set MAC_CONFIGURATION's IPC bit.
     *
     * Checksum Offload
     */
    inline void set_MAC_CONFIGURATION_IPC() volatile
    {
        MAC_CONFIGURATION |= 1u << 27u;
    }

    /**
     * Clear MAC_CONFIGURATION's IPC bit.
     *
     * Checksum Offload
     */
    inline void clear_MAC_CONFIGURATION_IPC() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 27u);
    }

    /**
     * Toggle MAC_CONFIGURATION's IPC bit.
     *
     * Checksum Offload
     */
    inline void toggle_MAC_CONFIGURATION_IPC() volatile
    {
        MAC_CONFIGURATION ^= 1u << 27u;
    }

    /**
     * Get MAC_CONFIGURATION's IPG field.
     *
     * Inter-Packet Gap These bits control the minimum IPG between packets
     * during transmission.
     */
    inline ENET_QOS_MAC_CONFIGURATION_IPG get_MAC_CONFIGURATION_IPG() volatile
    {
        return ENET_QOS_MAC_CONFIGURATION_IPG((MAC_CONFIGURATION >> 24u) &
                                              0b111u);
    }

    /**
     * Set MAC_CONFIGURATION's IPG field.
     *
     * Inter-Packet Gap These bits control the minimum IPG between packets
     * during transmission.
     */
    inline void set_MAC_CONFIGURATION_IPG(
        ENET_QOS_MAC_CONFIGURATION_IPG value) volatile
    {
        uint32_t curr = MAC_CONFIGURATION;

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(value) & 0b111u) << 24u;

        MAC_CONFIGURATION = curr;
    }

    /**
     * Get MAC_CONFIGURATION's GPSLCE bit.
     *
     * Giant Packet Size Limit Control Enable
     */
    inline bool get_MAC_CONFIGURATION_GPSLCE() volatile
    {
        return MAC_CONFIGURATION & (1u << 23u);
    }

    /**
     * Set MAC_CONFIGURATION's GPSLCE bit.
     *
     * Giant Packet Size Limit Control Enable
     */
    inline void set_MAC_CONFIGURATION_GPSLCE() volatile
    {
        MAC_CONFIGURATION |= 1u << 23u;
    }

    /**
     * Clear MAC_CONFIGURATION's GPSLCE bit.
     *
     * Giant Packet Size Limit Control Enable
     */
    inline void clear_MAC_CONFIGURATION_GPSLCE() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 23u);
    }

    /**
     * Toggle MAC_CONFIGURATION's GPSLCE bit.
     *
     * Giant Packet Size Limit Control Enable
     */
    inline void toggle_MAC_CONFIGURATION_GPSLCE() volatile
    {
        MAC_CONFIGURATION ^= 1u << 23u;
    }

    /**
     * Get MAC_CONFIGURATION's S2KP bit.
     *
     * IEEE 802.
     */
    inline bool get_MAC_CONFIGURATION_S2KP() volatile
    {
        return MAC_CONFIGURATION & (1u << 22u);
    }

    /**
     * Set MAC_CONFIGURATION's S2KP bit.
     *
     * IEEE 802.
     */
    inline void set_MAC_CONFIGURATION_S2KP() volatile
    {
        MAC_CONFIGURATION |= 1u << 22u;
    }

    /**
     * Clear MAC_CONFIGURATION's S2KP bit.
     *
     * IEEE 802.
     */
    inline void clear_MAC_CONFIGURATION_S2KP() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 22u);
    }

    /**
     * Toggle MAC_CONFIGURATION's S2KP bit.
     *
     * IEEE 802.
     */
    inline void toggle_MAC_CONFIGURATION_S2KP() volatile
    {
        MAC_CONFIGURATION ^= 1u << 22u;
    }

    /**
     * Get MAC_CONFIGURATION's CST bit.
     *
     * CRC stripping for Type packets When this bit is set, the last four bytes
     * (FCS) of all packets of Ether type (type field greater than 1,536) are
     * stripped and dropped before forwarding the packet to the application.
     */
    inline bool get_MAC_CONFIGURATION_CST() volatile
    {
        return MAC_CONFIGURATION & (1u << 21u);
    }

    /**
     * Set MAC_CONFIGURATION's CST bit.
     *
     * CRC stripping for Type packets When this bit is set, the last four bytes
     * (FCS) of all packets of Ether type (type field greater than 1,536) are
     * stripped and dropped before forwarding the packet to the application.
     */
    inline void set_MAC_CONFIGURATION_CST() volatile
    {
        MAC_CONFIGURATION |= 1u << 21u;
    }

    /**
     * Clear MAC_CONFIGURATION's CST bit.
     *
     * CRC stripping for Type packets When this bit is set, the last four bytes
     * (FCS) of all packets of Ether type (type field greater than 1,536) are
     * stripped and dropped before forwarding the packet to the application.
     */
    inline void clear_MAC_CONFIGURATION_CST() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_CONFIGURATION's CST bit.
     *
     * CRC stripping for Type packets When this bit is set, the last four bytes
     * (FCS) of all packets of Ether type (type field greater than 1,536) are
     * stripped and dropped before forwarding the packet to the application.
     */
    inline void toggle_MAC_CONFIGURATION_CST() volatile
    {
        MAC_CONFIGURATION ^= 1u << 21u;
    }

    /**
     * Get MAC_CONFIGURATION's ACS bit.
     *
     * Automatic Pad or CRC Stripping When this bit is set, the MAC strips the
     * Pad or FCS field on the incoming packets only if the value of the length
     * field is less than 1,536 bytes.
     */
    inline bool get_MAC_CONFIGURATION_ACS() volatile
    {
        return MAC_CONFIGURATION & (1u << 20u);
    }

    /**
     * Set MAC_CONFIGURATION's ACS bit.
     *
     * Automatic Pad or CRC Stripping When this bit is set, the MAC strips the
     * Pad or FCS field on the incoming packets only if the value of the length
     * field is less than 1,536 bytes.
     */
    inline void set_MAC_CONFIGURATION_ACS() volatile
    {
        MAC_CONFIGURATION |= 1u << 20u;
    }

    /**
     * Clear MAC_CONFIGURATION's ACS bit.
     *
     * Automatic Pad or CRC Stripping When this bit is set, the MAC strips the
     * Pad or FCS field on the incoming packets only if the value of the length
     * field is less than 1,536 bytes.
     */
    inline void clear_MAC_CONFIGURATION_ACS() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_CONFIGURATION's ACS bit.
     *
     * Automatic Pad or CRC Stripping When this bit is set, the MAC strips the
     * Pad or FCS field on the incoming packets only if the value of the length
     * field is less than 1,536 bytes.
     */
    inline void toggle_MAC_CONFIGURATION_ACS() volatile
    {
        MAC_CONFIGURATION ^= 1u << 20u;
    }

    /**
     * Get MAC_CONFIGURATION's WD bit.
     *
     * Watchdog Disable
     */
    inline bool get_MAC_CONFIGURATION_WD() volatile
    {
        return MAC_CONFIGURATION & (1u << 19u);
    }

    /**
     * Set MAC_CONFIGURATION's WD bit.
     *
     * Watchdog Disable
     */
    inline void set_MAC_CONFIGURATION_WD() volatile
    {
        MAC_CONFIGURATION |= 1u << 19u;
    }

    /**
     * Clear MAC_CONFIGURATION's WD bit.
     *
     * Watchdog Disable
     */
    inline void clear_MAC_CONFIGURATION_WD() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_CONFIGURATION's WD bit.
     *
     * Watchdog Disable
     */
    inline void toggle_MAC_CONFIGURATION_WD() volatile
    {
        MAC_CONFIGURATION ^= 1u << 19u;
    }

    /**
     * Get MAC_CONFIGURATION's BE bit.
     *
     * Packet Burst Enable When this bit is set, the MAC allows packet bursting
     * during transmission in the GMII half-duplex mode.
     */
    inline bool get_MAC_CONFIGURATION_BE() volatile
    {
        return MAC_CONFIGURATION & (1u << 18u);
    }

    /**
     * Set MAC_CONFIGURATION's BE bit.
     *
     * Packet Burst Enable When this bit is set, the MAC allows packet bursting
     * during transmission in the GMII half-duplex mode.
     */
    inline void set_MAC_CONFIGURATION_BE() volatile
    {
        MAC_CONFIGURATION |= 1u << 18u;
    }

    /**
     * Clear MAC_CONFIGURATION's BE bit.
     *
     * Packet Burst Enable When this bit is set, the MAC allows packet bursting
     * during transmission in the GMII half-duplex mode.
     */
    inline void clear_MAC_CONFIGURATION_BE() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_CONFIGURATION's BE bit.
     *
     * Packet Burst Enable When this bit is set, the MAC allows packet bursting
     * during transmission in the GMII half-duplex mode.
     */
    inline void toggle_MAC_CONFIGURATION_BE() volatile
    {
        MAC_CONFIGURATION ^= 1u << 18u;
    }

    /**
     * Get MAC_CONFIGURATION's JD bit.
     *
     * Jabber Disable
     */
    inline bool get_MAC_CONFIGURATION_JD() volatile
    {
        return MAC_CONFIGURATION & (1u << 17u);
    }

    /**
     * Set MAC_CONFIGURATION's JD bit.
     *
     * Jabber Disable
     */
    inline void set_MAC_CONFIGURATION_JD() volatile
    {
        MAC_CONFIGURATION |= 1u << 17u;
    }

    /**
     * Clear MAC_CONFIGURATION's JD bit.
     *
     * Jabber Disable
     */
    inline void clear_MAC_CONFIGURATION_JD() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_CONFIGURATION's JD bit.
     *
     * Jabber Disable
     */
    inline void toggle_MAC_CONFIGURATION_JD() volatile
    {
        MAC_CONFIGURATION ^= 1u << 17u;
    }

    /**
     * Get MAC_CONFIGURATION's JE bit.
     *
     * Jumbo Packet Enable When this bit is set, the MAC allows jumbo packets
     * of 9,018 bytes (9,022 bytes for VLAN tagged packets) without reporting a
     * giant packet error in the Rx packet status.
     */
    inline bool get_MAC_CONFIGURATION_JE() volatile
    {
        return MAC_CONFIGURATION & (1u << 16u);
    }

    /**
     * Set MAC_CONFIGURATION's JE bit.
     *
     * Jumbo Packet Enable When this bit is set, the MAC allows jumbo packets
     * of 9,018 bytes (9,022 bytes for VLAN tagged packets) without reporting a
     * giant packet error in the Rx packet status.
     */
    inline void set_MAC_CONFIGURATION_JE() volatile
    {
        MAC_CONFIGURATION |= 1u << 16u;
    }

    /**
     * Clear MAC_CONFIGURATION's JE bit.
     *
     * Jumbo Packet Enable When this bit is set, the MAC allows jumbo packets
     * of 9,018 bytes (9,022 bytes for VLAN tagged packets) without reporting a
     * giant packet error in the Rx packet status.
     */
    inline void clear_MAC_CONFIGURATION_JE() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_CONFIGURATION's JE bit.
     *
     * Jumbo Packet Enable When this bit is set, the MAC allows jumbo packets
     * of 9,018 bytes (9,022 bytes for VLAN tagged packets) without reporting a
     * giant packet error in the Rx packet status.
     */
    inline void toggle_MAC_CONFIGURATION_JE() volatile
    {
        MAC_CONFIGURATION ^= 1u << 16u;
    }

    /**
     * Get MAC_CONFIGURATION's PS bit.
     *
     * Port Select
     */
    inline bool get_MAC_CONFIGURATION_PS() volatile
    {
        return MAC_CONFIGURATION & (1u << 15u);
    }

    /**
     * Set MAC_CONFIGURATION's PS bit.
     *
     * Port Select
     */
    inline void set_MAC_CONFIGURATION_PS() volatile
    {
        MAC_CONFIGURATION |= 1u << 15u;
    }

    /**
     * Clear MAC_CONFIGURATION's PS bit.
     *
     * Port Select
     */
    inline void clear_MAC_CONFIGURATION_PS() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 15u);
    }

    /**
     * Toggle MAC_CONFIGURATION's PS bit.
     *
     * Port Select
     */
    inline void toggle_MAC_CONFIGURATION_PS() volatile
    {
        MAC_CONFIGURATION ^= 1u << 15u;
    }

    /**
     * Get MAC_CONFIGURATION's FES bit.
     *
     * Speed
     */
    inline bool get_MAC_CONFIGURATION_FES() volatile
    {
        return MAC_CONFIGURATION & (1u << 14u);
    }

    /**
     * Set MAC_CONFIGURATION's FES bit.
     *
     * Speed
     */
    inline void set_MAC_CONFIGURATION_FES() volatile
    {
        MAC_CONFIGURATION |= 1u << 14u;
    }

    /**
     * Clear MAC_CONFIGURATION's FES bit.
     *
     * Speed
     */
    inline void clear_MAC_CONFIGURATION_FES() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 14u);
    }

    /**
     * Toggle MAC_CONFIGURATION's FES bit.
     *
     * Speed
     */
    inline void toggle_MAC_CONFIGURATION_FES() volatile
    {
        MAC_CONFIGURATION ^= 1u << 14u;
    }

    /**
     * Get MAC_CONFIGURATION's DM bit.
     *
     * Duplex Mode
     */
    inline bool get_MAC_CONFIGURATION_DM() volatile
    {
        return MAC_CONFIGURATION & (1u << 13u);
    }

    /**
     * Set MAC_CONFIGURATION's DM bit.
     *
     * Duplex Mode
     */
    inline void set_MAC_CONFIGURATION_DM() volatile
    {
        MAC_CONFIGURATION |= 1u << 13u;
    }

    /**
     * Clear MAC_CONFIGURATION's DM bit.
     *
     * Duplex Mode
     */
    inline void clear_MAC_CONFIGURATION_DM() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 13u);
    }

    /**
     * Toggle MAC_CONFIGURATION's DM bit.
     *
     * Duplex Mode
     */
    inline void toggle_MAC_CONFIGURATION_DM() volatile
    {
        MAC_CONFIGURATION ^= 1u << 13u;
    }

    /**
     * Get MAC_CONFIGURATION's LM bit.
     *
     * Loopback Mode
     */
    inline bool get_MAC_CONFIGURATION_LM() volatile
    {
        return MAC_CONFIGURATION & (1u << 12u);
    }

    /**
     * Set MAC_CONFIGURATION's LM bit.
     *
     * Loopback Mode
     */
    inline void set_MAC_CONFIGURATION_LM() volatile
    {
        MAC_CONFIGURATION |= 1u << 12u;
    }

    /**
     * Clear MAC_CONFIGURATION's LM bit.
     *
     * Loopback Mode
     */
    inline void clear_MAC_CONFIGURATION_LM() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 12u);
    }

    /**
     * Toggle MAC_CONFIGURATION's LM bit.
     *
     * Loopback Mode
     */
    inline void toggle_MAC_CONFIGURATION_LM() volatile
    {
        MAC_CONFIGURATION ^= 1u << 12u;
    }

    /**
     * Get MAC_CONFIGURATION's ECRSFD bit.
     *
     * Enable Carrier Sense Before Transmission in Full-Duplex Mode
     */
    inline bool get_MAC_CONFIGURATION_ECRSFD() volatile
    {
        return MAC_CONFIGURATION & (1u << 11u);
    }

    /**
     * Set MAC_CONFIGURATION's ECRSFD bit.
     *
     * Enable Carrier Sense Before Transmission in Full-Duplex Mode
     */
    inline void set_MAC_CONFIGURATION_ECRSFD() volatile
    {
        MAC_CONFIGURATION |= 1u << 11u;
    }

    /**
     * Clear MAC_CONFIGURATION's ECRSFD bit.
     *
     * Enable Carrier Sense Before Transmission in Full-Duplex Mode
     */
    inline void clear_MAC_CONFIGURATION_ECRSFD() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 11u);
    }

    /**
     * Toggle MAC_CONFIGURATION's ECRSFD bit.
     *
     * Enable Carrier Sense Before Transmission in Full-Duplex Mode
     */
    inline void toggle_MAC_CONFIGURATION_ECRSFD() volatile
    {
        MAC_CONFIGURATION ^= 1u << 11u;
    }

    /**
     * Get MAC_CONFIGURATION's DO bit.
     *
     * Disable Receive Own
     */
    inline bool get_MAC_CONFIGURATION_DO() volatile
    {
        return MAC_CONFIGURATION & (1u << 10u);
    }

    /**
     * Set MAC_CONFIGURATION's DO bit.
     *
     * Disable Receive Own
     */
    inline void set_MAC_CONFIGURATION_DO() volatile
    {
        MAC_CONFIGURATION |= 1u << 10u;
    }

    /**
     * Clear MAC_CONFIGURATION's DO bit.
     *
     * Disable Receive Own
     */
    inline void clear_MAC_CONFIGURATION_DO() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_CONFIGURATION's DO bit.
     *
     * Disable Receive Own
     */
    inline void toggle_MAC_CONFIGURATION_DO() volatile
    {
        MAC_CONFIGURATION ^= 1u << 10u;
    }

    /**
     * Get MAC_CONFIGURATION's DCRS bit.
     *
     * Disable Carrier Sense During Transmission
     */
    inline bool get_MAC_CONFIGURATION_DCRS() volatile
    {
        return MAC_CONFIGURATION & (1u << 9u);
    }

    /**
     * Set MAC_CONFIGURATION's DCRS bit.
     *
     * Disable Carrier Sense During Transmission
     */
    inline void set_MAC_CONFIGURATION_DCRS() volatile
    {
        MAC_CONFIGURATION |= 1u << 9u;
    }

    /**
     * Clear MAC_CONFIGURATION's DCRS bit.
     *
     * Disable Carrier Sense During Transmission
     */
    inline void clear_MAC_CONFIGURATION_DCRS() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_CONFIGURATION's DCRS bit.
     *
     * Disable Carrier Sense During Transmission
     */
    inline void toggle_MAC_CONFIGURATION_DCRS() volatile
    {
        MAC_CONFIGURATION ^= 1u << 9u;
    }

    /**
     * Get MAC_CONFIGURATION's DR bit.
     *
     * Disable Retry
     */
    inline bool get_MAC_CONFIGURATION_DR() volatile
    {
        return MAC_CONFIGURATION & (1u << 8u);
    }

    /**
     * Set MAC_CONFIGURATION's DR bit.
     *
     * Disable Retry
     */
    inline void set_MAC_CONFIGURATION_DR() volatile
    {
        MAC_CONFIGURATION |= 1u << 8u;
    }

    /**
     * Clear MAC_CONFIGURATION's DR bit.
     *
     * Disable Retry
     */
    inline void clear_MAC_CONFIGURATION_DR() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_CONFIGURATION's DR bit.
     *
     * Disable Retry
     */
    inline void toggle_MAC_CONFIGURATION_DR() volatile
    {
        MAC_CONFIGURATION ^= 1u << 8u;
    }

    /**
     * Get MAC_CONFIGURATION's BL field.
     *
     * Back-Off Limit
     */
    inline ENET_QOS_MAC_CONFIGURATION_BL get_MAC_CONFIGURATION_BL() volatile
    {
        return ENET_QOS_MAC_CONFIGURATION_BL((MAC_CONFIGURATION >> 5u) &
                                             0b11u);
    }

    /**
     * Set MAC_CONFIGURATION's BL field.
     *
     * Back-Off Limit
     */
    inline void set_MAC_CONFIGURATION_BL(
        ENET_QOS_MAC_CONFIGURATION_BL value) volatile
    {
        uint32_t curr = MAC_CONFIGURATION;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        MAC_CONFIGURATION = curr;
    }

    /**
     * Get MAC_CONFIGURATION's DC bit.
     *
     * Deferral Check
     */
    inline bool get_MAC_CONFIGURATION_DC() volatile
    {
        return MAC_CONFIGURATION & (1u << 4u);
    }

    /**
     * Set MAC_CONFIGURATION's DC bit.
     *
     * Deferral Check
     */
    inline void set_MAC_CONFIGURATION_DC() volatile
    {
        MAC_CONFIGURATION |= 1u << 4u;
    }

    /**
     * Clear MAC_CONFIGURATION's DC bit.
     *
     * Deferral Check
     */
    inline void clear_MAC_CONFIGURATION_DC() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_CONFIGURATION's DC bit.
     *
     * Deferral Check
     */
    inline void toggle_MAC_CONFIGURATION_DC() volatile
    {
        MAC_CONFIGURATION ^= 1u << 4u;
    }

    /**
     * Get MAC_CONFIGURATION's PRELEN field.
     *
     * Preamble Length for Transmit packets
     */
    inline ENET_QOS_MAC_CONFIGURATION_PRELEN
    get_MAC_CONFIGURATION_PRELEN() volatile
    {
        return ENET_QOS_MAC_CONFIGURATION_PRELEN((MAC_CONFIGURATION >> 2u) &
                                                 0b11u);
    }

    /**
     * Set MAC_CONFIGURATION's PRELEN field.
     *
     * Preamble Length for Transmit packets
     */
    inline void set_MAC_CONFIGURATION_PRELEN(
        ENET_QOS_MAC_CONFIGURATION_PRELEN value) volatile
    {
        uint32_t curr = MAC_CONFIGURATION;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MAC_CONFIGURATION = curr;
    }

    /**
     * Get MAC_CONFIGURATION's TE bit.
     *
     * Transmitter Enable
     */
    inline bool get_MAC_CONFIGURATION_TE() volatile
    {
        return MAC_CONFIGURATION & (1u << 1u);
    }

    /**
     * Set MAC_CONFIGURATION's TE bit.
     *
     * Transmitter Enable
     */
    inline void set_MAC_CONFIGURATION_TE() volatile
    {
        MAC_CONFIGURATION |= 1u << 1u;
    }

    /**
     * Clear MAC_CONFIGURATION's TE bit.
     *
     * Transmitter Enable
     */
    inline void clear_MAC_CONFIGURATION_TE() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_CONFIGURATION's TE bit.
     *
     * Transmitter Enable
     */
    inline void toggle_MAC_CONFIGURATION_TE() volatile
    {
        MAC_CONFIGURATION ^= 1u << 1u;
    }

    /**
     * Get MAC_CONFIGURATION's RE bit.
     *
     * Receiver Enable
     */
    inline bool get_MAC_CONFIGURATION_RE() volatile
    {
        return MAC_CONFIGURATION & (1u << 0u);
    }

    /**
     * Set MAC_CONFIGURATION's RE bit.
     *
     * Receiver Enable
     */
    inline void set_MAC_CONFIGURATION_RE() volatile
    {
        MAC_CONFIGURATION |= 1u << 0u;
    }

    /**
     * Clear MAC_CONFIGURATION's RE bit.
     *
     * Receiver Enable
     */
    inline void clear_MAC_CONFIGURATION_RE() volatile
    {
        MAC_CONFIGURATION &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_CONFIGURATION's RE bit.
     *
     * Receiver Enable
     */
    inline void toggle_MAC_CONFIGURATION_RE() volatile
    {
        MAC_CONFIGURATION ^= 1u << 0u;
    }

    /**
     * Get all of MAC_CONFIGURATION's bit fields.
     *
     * (read-write) MAC Configuration Register
     */
    inline void get_MAC_CONFIGURATION(
        ENET_QOS_MAC_CONFIGURATION_SARC &SARC, bool &IPC,
        ENET_QOS_MAC_CONFIGURATION_IPG &IPG, bool &GPSLCE, bool &S2KP,
        bool &CST, bool &ACS, bool &WD, bool &BE, bool &JD, bool &JE, bool &PS,
        bool &FES, bool &DM, bool &LM, bool &ECRSFD, bool &DO, bool &DCRS,
        bool &DR, ENET_QOS_MAC_CONFIGURATION_BL &BL, bool &DC,
        ENET_QOS_MAC_CONFIGURATION_PRELEN &PRELEN, bool &TE, bool &RE) volatile
    {
        uint32_t curr = MAC_CONFIGURATION;

        SARC = ENET_QOS_MAC_CONFIGURATION_SARC((curr >> 28u) & 0b111u);
        IPC = curr & (1u << 27u);
        IPG = ENET_QOS_MAC_CONFIGURATION_IPG((curr >> 24u) & 0b111u);
        GPSLCE = curr & (1u << 23u);
        S2KP = curr & (1u << 22u);
        CST = curr & (1u << 21u);
        ACS = curr & (1u << 20u);
        WD = curr & (1u << 19u);
        BE = curr & (1u << 18u);
        JD = curr & (1u << 17u);
        JE = curr & (1u << 16u);
        PS = curr & (1u << 15u);
        FES = curr & (1u << 14u);
        DM = curr & (1u << 13u);
        LM = curr & (1u << 12u);
        ECRSFD = curr & (1u << 11u);
        DO = curr & (1u << 10u);
        DCRS = curr & (1u << 9u);
        DR = curr & (1u << 8u);
        BL = ENET_QOS_MAC_CONFIGURATION_BL((curr >> 5u) & 0b11u);
        DC = curr & (1u << 4u);
        PRELEN = ENET_QOS_MAC_CONFIGURATION_PRELEN((curr >> 2u) & 0b11u);
        TE = curr & (1u << 1u);
        RE = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_CONFIGURATION's bit fields.
     *
     * (read-write) MAC Configuration Register
     */
    inline void set_MAC_CONFIGURATION(
        ENET_QOS_MAC_CONFIGURATION_SARC SARC, bool IPC,
        ENET_QOS_MAC_CONFIGURATION_IPG IPG, bool GPSLCE, bool S2KP, bool CST,
        bool ACS, bool WD, bool BE, bool JD, bool JE, bool PS, bool FES,
        bool DM, bool LM, bool ECRSFD, bool DO, bool DCRS, bool DR,
        ENET_QOS_MAC_CONFIGURATION_BL BL, bool DC,
        ENET_QOS_MAC_CONFIGURATION_PRELEN PRELEN, bool TE, bool RE) volatile
    {
        uint32_t curr = MAC_CONFIGURATION;

        curr &= ~(0b111u << 28u);
        curr |= (std::to_underlying(SARC) & 0b111u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (IPC & 0b1u) << 27u;
        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(IPG) & 0b111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (GPSLCE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (S2KP & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (CST & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ACS & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (WD & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (BE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (JD & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (JE & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (PS & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (FES & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (DM & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (LM & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ECRSFD & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (DO & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (DCRS & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (DR & 0b1u) << 8u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(BL) & 0b11u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DC & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PRELEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RE & 0b1u) << 0u;

        MAC_CONFIGURATION = curr;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's EIPG field.
     *
     * Extended Inter-Packet Gap
     */
    inline uint8_t get_MAC_EXT_CONFIGURATION_EIPG() volatile
    {
        return (MAC_EXT_CONFIGURATION >> 25u) & 0b11111u;
    }

    /**
     * Set MAC_EXT_CONFIGURATION's EIPG field.
     *
     * Extended Inter-Packet Gap
     */
    inline void set_MAC_EXT_CONFIGURATION_EIPG(uint8_t value) volatile
    {
        uint32_t curr = MAC_EXT_CONFIGURATION;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        MAC_EXT_CONFIGURATION = curr;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's EIPGEN bit.
     *
     * Extended Inter-Packet Gap Enable
     */
    inline bool get_MAC_EXT_CONFIGURATION_EIPGEN() volatile
    {
        return MAC_EXT_CONFIGURATION & (1u << 24u);
    }

    /**
     * Set MAC_EXT_CONFIGURATION's EIPGEN bit.
     *
     * Extended Inter-Packet Gap Enable
     */
    inline void set_MAC_EXT_CONFIGURATION_EIPGEN() volatile
    {
        MAC_EXT_CONFIGURATION |= 1u << 24u;
    }

    /**
     * Clear MAC_EXT_CONFIGURATION's EIPGEN bit.
     *
     * Extended Inter-Packet Gap Enable
     */
    inline void clear_MAC_EXT_CONFIGURATION_EIPGEN() volatile
    {
        MAC_EXT_CONFIGURATION &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_EXT_CONFIGURATION's EIPGEN bit.
     *
     * Extended Inter-Packet Gap Enable
     */
    inline void toggle_MAC_EXT_CONFIGURATION_EIPGEN() volatile
    {
        MAC_EXT_CONFIGURATION ^= 1u << 24u;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's PDC bit.
     *
     * Packet Duplication Control
     */
    inline bool get_MAC_EXT_CONFIGURATION_PDC() volatile
    {
        return MAC_EXT_CONFIGURATION & (1u << 19u);
    }

    /**
     * Set MAC_EXT_CONFIGURATION's PDC bit.
     *
     * Packet Duplication Control
     */
    inline void set_MAC_EXT_CONFIGURATION_PDC() volatile
    {
        MAC_EXT_CONFIGURATION |= 1u << 19u;
    }

    /**
     * Clear MAC_EXT_CONFIGURATION's PDC bit.
     *
     * Packet Duplication Control
     */
    inline void clear_MAC_EXT_CONFIGURATION_PDC() volatile
    {
        MAC_EXT_CONFIGURATION &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_EXT_CONFIGURATION's PDC bit.
     *
     * Packet Duplication Control
     */
    inline void toggle_MAC_EXT_CONFIGURATION_PDC() volatile
    {
        MAC_EXT_CONFIGURATION ^= 1u << 19u;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's USP bit.
     *
     * Unicast Slow Protocol Packet Detect
     */
    inline bool get_MAC_EXT_CONFIGURATION_USP() volatile
    {
        return MAC_EXT_CONFIGURATION & (1u << 18u);
    }

    /**
     * Set MAC_EXT_CONFIGURATION's USP bit.
     *
     * Unicast Slow Protocol Packet Detect
     */
    inline void set_MAC_EXT_CONFIGURATION_USP() volatile
    {
        MAC_EXT_CONFIGURATION |= 1u << 18u;
    }

    /**
     * Clear MAC_EXT_CONFIGURATION's USP bit.
     *
     * Unicast Slow Protocol Packet Detect
     */
    inline void clear_MAC_EXT_CONFIGURATION_USP() volatile
    {
        MAC_EXT_CONFIGURATION &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_EXT_CONFIGURATION's USP bit.
     *
     * Unicast Slow Protocol Packet Detect
     */
    inline void toggle_MAC_EXT_CONFIGURATION_USP() volatile
    {
        MAC_EXT_CONFIGURATION ^= 1u << 18u;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's SPEN bit.
     *
     * Slow Protocol Detection Enable
     */
    inline bool get_MAC_EXT_CONFIGURATION_SPEN() volatile
    {
        return MAC_EXT_CONFIGURATION & (1u << 17u);
    }

    /**
     * Set MAC_EXT_CONFIGURATION's SPEN bit.
     *
     * Slow Protocol Detection Enable
     */
    inline void set_MAC_EXT_CONFIGURATION_SPEN() volatile
    {
        MAC_EXT_CONFIGURATION |= 1u << 17u;
    }

    /**
     * Clear MAC_EXT_CONFIGURATION's SPEN bit.
     *
     * Slow Protocol Detection Enable
     */
    inline void clear_MAC_EXT_CONFIGURATION_SPEN() volatile
    {
        MAC_EXT_CONFIGURATION &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_EXT_CONFIGURATION's SPEN bit.
     *
     * Slow Protocol Detection Enable
     */
    inline void toggle_MAC_EXT_CONFIGURATION_SPEN() volatile
    {
        MAC_EXT_CONFIGURATION ^= 1u << 17u;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's DCRCC bit.
     *
     * Disable CRC Checking for Received Packets
     */
    inline bool get_MAC_EXT_CONFIGURATION_DCRCC() volatile
    {
        return MAC_EXT_CONFIGURATION & (1u << 16u);
    }

    /**
     * Set MAC_EXT_CONFIGURATION's DCRCC bit.
     *
     * Disable CRC Checking for Received Packets
     */
    inline void set_MAC_EXT_CONFIGURATION_DCRCC() volatile
    {
        MAC_EXT_CONFIGURATION |= 1u << 16u;
    }

    /**
     * Clear MAC_EXT_CONFIGURATION's DCRCC bit.
     *
     * Disable CRC Checking for Received Packets
     */
    inline void clear_MAC_EXT_CONFIGURATION_DCRCC() volatile
    {
        MAC_EXT_CONFIGURATION &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_EXT_CONFIGURATION's DCRCC bit.
     *
     * Disable CRC Checking for Received Packets
     */
    inline void toggle_MAC_EXT_CONFIGURATION_DCRCC() volatile
    {
        MAC_EXT_CONFIGURATION ^= 1u << 16u;
    }

    /**
     * Get MAC_EXT_CONFIGURATION's GPSL field.
     *
     * Giant Packet Size Limit
     */
    inline uint16_t get_MAC_EXT_CONFIGURATION_GPSL() volatile
    {
        return (MAC_EXT_CONFIGURATION >> 0u) & 0b11111111111111u;
    }

    /**
     * Set MAC_EXT_CONFIGURATION's GPSL field.
     *
     * Giant Packet Size Limit
     */
    inline void set_MAC_EXT_CONFIGURATION_GPSL(uint16_t value) volatile
    {
        uint32_t curr = MAC_EXT_CONFIGURATION;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        MAC_EXT_CONFIGURATION = curr;
    }

    /**
     * Get all of MAC_EXT_CONFIGURATION's bit fields.
     *
     * (read-write) MAC Extended Configuration Register
     */
    inline void get_MAC_EXT_CONFIGURATION(uint8_t &EIPG, bool &EIPGEN,
                                          bool &PDC, bool &USP, bool &SPEN,
                                          bool &DCRCC, uint16_t &GPSL) volatile
    {
        uint32_t curr = MAC_EXT_CONFIGURATION;

        EIPG = (curr >> 25u) & 0b11111u;
        EIPGEN = curr & (1u << 24u);
        PDC = curr & (1u << 19u);
        USP = curr & (1u << 18u);
        SPEN = curr & (1u << 17u);
        DCRCC = curr & (1u << 16u);
        GPSL = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Set all of MAC_EXT_CONFIGURATION's bit fields.
     *
     * (read-write) MAC Extended Configuration Register
     */
    inline void set_MAC_EXT_CONFIGURATION(uint8_t EIPG, bool EIPGEN, bool PDC,
                                          bool USP, bool SPEN, bool DCRCC,
                                          uint16_t GPSL) volatile
    {
        uint32_t curr = MAC_EXT_CONFIGURATION;

        curr &= ~(0b11111u << 25u);
        curr |= (EIPG & 0b11111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (EIPGEN & 0b1u) << 24u;
        curr &= ~(0b1u << 19u);
        curr |= (PDC & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (USP & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (SPEN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DCRCC & 0b1u) << 16u;
        curr &= ~(0b11111111111111u << 0u);
        curr |= (GPSL & 0b11111111111111u) << 0u;

        MAC_EXT_CONFIGURATION = curr;
    }

    /**
     * Get MAC_PACKET_FILTER's RA bit.
     *
     * Receive All
     */
    inline bool get_MAC_PACKET_FILTER_RA() volatile
    {
        return MAC_PACKET_FILTER & (1u << 31u);
    }

    /**
     * Set MAC_PACKET_FILTER's RA bit.
     *
     * Receive All
     */
    inline void set_MAC_PACKET_FILTER_RA() volatile
    {
        MAC_PACKET_FILTER |= 1u << 31u;
    }

    /**
     * Clear MAC_PACKET_FILTER's RA bit.
     *
     * Receive All
     */
    inline void clear_MAC_PACKET_FILTER_RA() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's RA bit.
     *
     * Receive All
     */
    inline void toggle_MAC_PACKET_FILTER_RA() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 31u;
    }

    /**
     * Get MAC_PACKET_FILTER's DNTU bit.
     *
     * Drop Non-TCP/UDP over IP Packets
     */
    inline bool get_MAC_PACKET_FILTER_DNTU() volatile
    {
        return MAC_PACKET_FILTER & (1u << 21u);
    }

    /**
     * Set MAC_PACKET_FILTER's DNTU bit.
     *
     * Drop Non-TCP/UDP over IP Packets
     */
    inline void set_MAC_PACKET_FILTER_DNTU() volatile
    {
        MAC_PACKET_FILTER |= 1u << 21u;
    }

    /**
     * Clear MAC_PACKET_FILTER's DNTU bit.
     *
     * Drop Non-TCP/UDP over IP Packets
     */
    inline void clear_MAC_PACKET_FILTER_DNTU() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's DNTU bit.
     *
     * Drop Non-TCP/UDP over IP Packets
     */
    inline void toggle_MAC_PACKET_FILTER_DNTU() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 21u;
    }

    /**
     * Get MAC_PACKET_FILTER's IPFE bit.
     *
     * Layer 3 and Layer 4 Filter Enable
     */
    inline bool get_MAC_PACKET_FILTER_IPFE() volatile
    {
        return MAC_PACKET_FILTER & (1u << 20u);
    }

    /**
     * Set MAC_PACKET_FILTER's IPFE bit.
     *
     * Layer 3 and Layer 4 Filter Enable
     */
    inline void set_MAC_PACKET_FILTER_IPFE() volatile
    {
        MAC_PACKET_FILTER |= 1u << 20u;
    }

    /**
     * Clear MAC_PACKET_FILTER's IPFE bit.
     *
     * Layer 3 and Layer 4 Filter Enable
     */
    inline void clear_MAC_PACKET_FILTER_IPFE() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's IPFE bit.
     *
     * Layer 3 and Layer 4 Filter Enable
     */
    inline void toggle_MAC_PACKET_FILTER_IPFE() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 20u;
    }

    /**
     * Get MAC_PACKET_FILTER's VTFE bit.
     *
     * VLAN Tag Filter Enable
     */
    inline bool get_MAC_PACKET_FILTER_VTFE() volatile
    {
        return MAC_PACKET_FILTER & (1u << 16u);
    }

    /**
     * Set MAC_PACKET_FILTER's VTFE bit.
     *
     * VLAN Tag Filter Enable
     */
    inline void set_MAC_PACKET_FILTER_VTFE() volatile
    {
        MAC_PACKET_FILTER |= 1u << 16u;
    }

    /**
     * Clear MAC_PACKET_FILTER's VTFE bit.
     *
     * VLAN Tag Filter Enable
     */
    inline void clear_MAC_PACKET_FILTER_VTFE() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's VTFE bit.
     *
     * VLAN Tag Filter Enable
     */
    inline void toggle_MAC_PACKET_FILTER_VTFE() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 16u;
    }

    /**
     * Get MAC_PACKET_FILTER's HPF bit.
     *
     * Hash or Perfect Filter
     */
    inline bool get_MAC_PACKET_FILTER_HPF() volatile
    {
        return MAC_PACKET_FILTER & (1u << 10u);
    }

    /**
     * Set MAC_PACKET_FILTER's HPF bit.
     *
     * Hash or Perfect Filter
     */
    inline void set_MAC_PACKET_FILTER_HPF() volatile
    {
        MAC_PACKET_FILTER |= 1u << 10u;
    }

    /**
     * Clear MAC_PACKET_FILTER's HPF bit.
     *
     * Hash or Perfect Filter
     */
    inline void clear_MAC_PACKET_FILTER_HPF() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's HPF bit.
     *
     * Hash or Perfect Filter
     */
    inline void toggle_MAC_PACKET_FILTER_HPF() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 10u;
    }

    /**
     * Get MAC_PACKET_FILTER's SAF bit.
     *
     * Source Address Filter Enable
     */
    inline bool get_MAC_PACKET_FILTER_SAF() volatile
    {
        return MAC_PACKET_FILTER & (1u << 9u);
    }

    /**
     * Set MAC_PACKET_FILTER's SAF bit.
     *
     * Source Address Filter Enable
     */
    inline void set_MAC_PACKET_FILTER_SAF() volatile
    {
        MAC_PACKET_FILTER |= 1u << 9u;
    }

    /**
     * Clear MAC_PACKET_FILTER's SAF bit.
     *
     * Source Address Filter Enable
     */
    inline void clear_MAC_PACKET_FILTER_SAF() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's SAF bit.
     *
     * Source Address Filter Enable
     */
    inline void toggle_MAC_PACKET_FILTER_SAF() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 9u;
    }

    /**
     * Get MAC_PACKET_FILTER's SAIF bit.
     *
     * SA Inverse Filtering
     */
    inline bool get_MAC_PACKET_FILTER_SAIF() volatile
    {
        return MAC_PACKET_FILTER & (1u << 8u);
    }

    /**
     * Set MAC_PACKET_FILTER's SAIF bit.
     *
     * SA Inverse Filtering
     */
    inline void set_MAC_PACKET_FILTER_SAIF() volatile
    {
        MAC_PACKET_FILTER |= 1u << 8u;
    }

    /**
     * Clear MAC_PACKET_FILTER's SAIF bit.
     *
     * SA Inverse Filtering
     */
    inline void clear_MAC_PACKET_FILTER_SAIF() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's SAIF bit.
     *
     * SA Inverse Filtering
     */
    inline void toggle_MAC_PACKET_FILTER_SAIF() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 8u;
    }

    /**
     * Get MAC_PACKET_FILTER's PCF field.
     *
     * Pass Control Packets These bits control the forwarding of all control
     * packets (including unicast and multicast Pause packets).
     */
    inline ENET_QOS_MAC_PACKET_FILTER_PCF get_MAC_PACKET_FILTER_PCF() volatile
    {
        return ENET_QOS_MAC_PACKET_FILTER_PCF((MAC_PACKET_FILTER >> 6u) &
                                              0b11u);
    }

    /**
     * Set MAC_PACKET_FILTER's PCF field.
     *
     * Pass Control Packets These bits control the forwarding of all control
     * packets (including unicast and multicast Pause packets).
     */
    inline void set_MAC_PACKET_FILTER_PCF(
        ENET_QOS_MAC_PACKET_FILTER_PCF value) volatile
    {
        uint32_t curr = MAC_PACKET_FILTER;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        MAC_PACKET_FILTER = curr;
    }

    /**
     * Get MAC_PACKET_FILTER's DBF bit.
     *
     * Disable Broadcast Packets
     */
    inline bool get_MAC_PACKET_FILTER_DBF() volatile
    {
        return MAC_PACKET_FILTER & (1u << 5u);
    }

    /**
     * Set MAC_PACKET_FILTER's DBF bit.
     *
     * Disable Broadcast Packets
     */
    inline void set_MAC_PACKET_FILTER_DBF() volatile
    {
        MAC_PACKET_FILTER |= 1u << 5u;
    }

    /**
     * Clear MAC_PACKET_FILTER's DBF bit.
     *
     * Disable Broadcast Packets
     */
    inline void clear_MAC_PACKET_FILTER_DBF() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's DBF bit.
     *
     * Disable Broadcast Packets
     */
    inline void toggle_MAC_PACKET_FILTER_DBF() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 5u;
    }

    /**
     * Get MAC_PACKET_FILTER's PM bit.
     *
     * Pass All Multicast
     */
    inline bool get_MAC_PACKET_FILTER_PM() volatile
    {
        return MAC_PACKET_FILTER & (1u << 4u);
    }

    /**
     * Set MAC_PACKET_FILTER's PM bit.
     *
     * Pass All Multicast
     */
    inline void set_MAC_PACKET_FILTER_PM() volatile
    {
        MAC_PACKET_FILTER |= 1u << 4u;
    }

    /**
     * Clear MAC_PACKET_FILTER's PM bit.
     *
     * Pass All Multicast
     */
    inline void clear_MAC_PACKET_FILTER_PM() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's PM bit.
     *
     * Pass All Multicast
     */
    inline void toggle_MAC_PACKET_FILTER_PM() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 4u;
    }

    /**
     * Get MAC_PACKET_FILTER's DAIF bit.
     *
     * DA Inverse Filtering
     */
    inline bool get_MAC_PACKET_FILTER_DAIF() volatile
    {
        return MAC_PACKET_FILTER & (1u << 3u);
    }

    /**
     * Set MAC_PACKET_FILTER's DAIF bit.
     *
     * DA Inverse Filtering
     */
    inline void set_MAC_PACKET_FILTER_DAIF() volatile
    {
        MAC_PACKET_FILTER |= 1u << 3u;
    }

    /**
     * Clear MAC_PACKET_FILTER's DAIF bit.
     *
     * DA Inverse Filtering
     */
    inline void clear_MAC_PACKET_FILTER_DAIF() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's DAIF bit.
     *
     * DA Inverse Filtering
     */
    inline void toggle_MAC_PACKET_FILTER_DAIF() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 3u;
    }

    /**
     * Get MAC_PACKET_FILTER's HMC bit.
     *
     * Hash Multicast
     */
    inline bool get_MAC_PACKET_FILTER_HMC() volatile
    {
        return MAC_PACKET_FILTER & (1u << 2u);
    }

    /**
     * Set MAC_PACKET_FILTER's HMC bit.
     *
     * Hash Multicast
     */
    inline void set_MAC_PACKET_FILTER_HMC() volatile
    {
        MAC_PACKET_FILTER |= 1u << 2u;
    }

    /**
     * Clear MAC_PACKET_FILTER's HMC bit.
     *
     * Hash Multicast
     */
    inline void clear_MAC_PACKET_FILTER_HMC() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's HMC bit.
     *
     * Hash Multicast
     */
    inline void toggle_MAC_PACKET_FILTER_HMC() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 2u;
    }

    /**
     * Get MAC_PACKET_FILTER's HUC bit.
     *
     * Hash Unicast
     */
    inline bool get_MAC_PACKET_FILTER_HUC() volatile
    {
        return MAC_PACKET_FILTER & (1u << 1u);
    }

    /**
     * Set MAC_PACKET_FILTER's HUC bit.
     *
     * Hash Unicast
     */
    inline void set_MAC_PACKET_FILTER_HUC() volatile
    {
        MAC_PACKET_FILTER |= 1u << 1u;
    }

    /**
     * Clear MAC_PACKET_FILTER's HUC bit.
     *
     * Hash Unicast
     */
    inline void clear_MAC_PACKET_FILTER_HUC() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's HUC bit.
     *
     * Hash Unicast
     */
    inline void toggle_MAC_PACKET_FILTER_HUC() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 1u;
    }

    /**
     * Get MAC_PACKET_FILTER's PR bit.
     *
     * Promiscuous Mode
     */
    inline bool get_MAC_PACKET_FILTER_PR() volatile
    {
        return MAC_PACKET_FILTER & (1u << 0u);
    }

    /**
     * Set MAC_PACKET_FILTER's PR bit.
     *
     * Promiscuous Mode
     */
    inline void set_MAC_PACKET_FILTER_PR() volatile
    {
        MAC_PACKET_FILTER |= 1u << 0u;
    }

    /**
     * Clear MAC_PACKET_FILTER's PR bit.
     *
     * Promiscuous Mode
     */
    inline void clear_MAC_PACKET_FILTER_PR() volatile
    {
        MAC_PACKET_FILTER &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_PACKET_FILTER's PR bit.
     *
     * Promiscuous Mode
     */
    inline void toggle_MAC_PACKET_FILTER_PR() volatile
    {
        MAC_PACKET_FILTER ^= 1u << 0u;
    }

    /**
     * Get all of MAC_PACKET_FILTER's bit fields.
     *
     * (read-write) MAC Packet Filter
     */
    inline void get_MAC_PACKET_FILTER(bool &RA, bool &DNTU, bool &IPFE,
                                      bool &VTFE, bool &HPF, bool &SAF,
                                      bool &SAIF,
                                      ENET_QOS_MAC_PACKET_FILTER_PCF &PCF,
                                      bool &DBF, bool &PM, bool &DAIF,
                                      bool &HMC, bool &HUC, bool &PR) volatile
    {
        uint32_t curr = MAC_PACKET_FILTER;

        RA = curr & (1u << 31u);
        DNTU = curr & (1u << 21u);
        IPFE = curr & (1u << 20u);
        VTFE = curr & (1u << 16u);
        HPF = curr & (1u << 10u);
        SAF = curr & (1u << 9u);
        SAIF = curr & (1u << 8u);
        PCF = ENET_QOS_MAC_PACKET_FILTER_PCF((curr >> 6u) & 0b11u);
        DBF = curr & (1u << 5u);
        PM = curr & (1u << 4u);
        DAIF = curr & (1u << 3u);
        HMC = curr & (1u << 2u);
        HUC = curr & (1u << 1u);
        PR = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_PACKET_FILTER's bit fields.
     *
     * (read-write) MAC Packet Filter
     */
    inline void set_MAC_PACKET_FILTER(bool RA, bool DNTU, bool IPFE, bool VTFE,
                                      bool HPF, bool SAF, bool SAIF,
                                      ENET_QOS_MAC_PACKET_FILTER_PCF PCF,
                                      bool DBF, bool PM, bool DAIF, bool HMC,
                                      bool HUC, bool PR) volatile
    {
        uint32_t curr = MAC_PACKET_FILTER;

        curr &= ~(0b1u << 31u);
        curr |= (RA & 0b1u) << 31u;
        curr &= ~(0b1u << 21u);
        curr |= (DNTU & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (IPFE & 0b1u) << 20u;
        curr &= ~(0b1u << 16u);
        curr |= (VTFE & 0b1u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (HPF & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SAF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SAIF & 0b1u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(PCF) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DBF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (PM & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DAIF & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (HMC & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (HUC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PR & 0b1u) << 0u;

        MAC_PACKET_FILTER = curr;
    }

    /**
     * Get MAC_WATCHDOG_TIMEOUT's PWE bit.
     *
     * Programmable Watchdog Enable
     */
    inline bool get_MAC_WATCHDOG_TIMEOUT_PWE() volatile
    {
        return MAC_WATCHDOG_TIMEOUT & (1u << 8u);
    }

    /**
     * Set MAC_WATCHDOG_TIMEOUT's PWE bit.
     *
     * Programmable Watchdog Enable
     */
    inline void set_MAC_WATCHDOG_TIMEOUT_PWE() volatile
    {
        MAC_WATCHDOG_TIMEOUT |= 1u << 8u;
    }

    /**
     * Clear MAC_WATCHDOG_TIMEOUT's PWE bit.
     *
     * Programmable Watchdog Enable
     */
    inline void clear_MAC_WATCHDOG_TIMEOUT_PWE() volatile
    {
        MAC_WATCHDOG_TIMEOUT &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_WATCHDOG_TIMEOUT's PWE bit.
     *
     * Programmable Watchdog Enable
     */
    inline void toggle_MAC_WATCHDOG_TIMEOUT_PWE() volatile
    {
        MAC_WATCHDOG_TIMEOUT ^= 1u << 8u;
    }

    /**
     * Get MAC_WATCHDOG_TIMEOUT's WTO field.
     *
     * Watchdog Timeout
     */
    inline ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO
    get_MAC_WATCHDOG_TIMEOUT_WTO() volatile
    {
        return ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO((MAC_WATCHDOG_TIMEOUT >> 0u) &
                                                 0b1111u);
    }

    /**
     * Set MAC_WATCHDOG_TIMEOUT's WTO field.
     *
     * Watchdog Timeout
     */
    inline void set_MAC_WATCHDOG_TIMEOUT_WTO(
        ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO value) volatile
    {
        uint32_t curr = MAC_WATCHDOG_TIMEOUT;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        MAC_WATCHDOG_TIMEOUT = curr;
    }

    /**
     * Get all of MAC_WATCHDOG_TIMEOUT's bit fields.
     *
     * (read-write) Watchdog Timeout
     */
    inline void get_MAC_WATCHDOG_TIMEOUT(
        bool &PWE, ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO &WTO) volatile
    {
        uint32_t curr = MAC_WATCHDOG_TIMEOUT;

        PWE = curr & (1u << 8u);
        WTO = ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of MAC_WATCHDOG_TIMEOUT's bit fields.
     *
     * (read-write) Watchdog Timeout
     */
    inline void set_MAC_WATCHDOG_TIMEOUT(
        bool PWE, ENET_QOS_MAC_WATCHDOG_TIMEOUT_WTO WTO) volatile
    {
        uint32_t curr = MAC_WATCHDOG_TIMEOUT;

        curr &= ~(0b1u << 8u);
        curr |= (PWE & 0b1u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(WTO) & 0b1111u) << 0u;

        MAC_WATCHDOG_TIMEOUT = curr;
    }

    /**
     * Get MAC_HASH_TABLE_REG0's HT31T0 field.
     *
     * MAC Hash Table First 32 Bits This field contains the first 32 Bits
     * [31:0] of the Hash table.
     */
    inline uint32_t get_MAC_HASH_TABLE_REG0_HT31T0() volatile
    {
        return (MAC_HASH_TABLE_REG0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_HASH_TABLE_REG0's HT31T0 field.
     *
     * MAC Hash Table First 32 Bits This field contains the first 32 Bits
     * [31:0] of the Hash table.
     */
    inline void set_MAC_HASH_TABLE_REG0_HT31T0(uint32_t value) volatile
    {
        uint32_t curr = MAC_HASH_TABLE_REG0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_HASH_TABLE_REG0 = curr;
    }

    /**
     * Get MAC_HASH_TABLE_REG1's HT63T32 field.
     *
     * MAC Hash Table Second 32 Bits This field contains the second 32 Bits
     * [63:32] of the Hash table.
     */
    inline uint32_t get_MAC_HASH_TABLE_REG1_HT63T32() volatile
    {
        return (MAC_HASH_TABLE_REG1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_HASH_TABLE_REG1's HT63T32 field.
     *
     * MAC Hash Table Second 32 Bits This field contains the second 32 Bits
     * [63:32] of the Hash table.
     */
    inline void set_MAC_HASH_TABLE_REG1_HT63T32(uint32_t value) volatile
    {
        uint32_t curr = MAC_HASH_TABLE_REG1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_HASH_TABLE_REG1 = curr;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's EIVLRXS bit.
     *
     * Enable Inner VLAN Tag in Rx Status
     */
    inline bool get_MAC_VLAN_TAG_CTRL_EIVLRXS() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 31u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's EIVLRXS bit.
     *
     * Enable Inner VLAN Tag in Rx Status
     */
    inline void set_MAC_VLAN_TAG_CTRL_EIVLRXS() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 31u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's EIVLRXS bit.
     *
     * Enable Inner VLAN Tag in Rx Status
     */
    inline void clear_MAC_VLAN_TAG_CTRL_EIVLRXS() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's EIVLRXS bit.
     *
     * Enable Inner VLAN Tag in Rx Status
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_EIVLRXS() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 31u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's EIVLS field.
     *
     * Enable Inner VLAN Tag Stripping on Receive This field indicates the
     * stripping operation on inner VLAN Tag in received packet.
     */
    inline ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS
    get_MAC_VLAN_TAG_CTRL_EIVLS() volatile
    {
        return ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS((MAC_VLAN_TAG_CTRL >> 28u) &
                                                0b11u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's EIVLS field.
     *
     * Enable Inner VLAN Tag Stripping on Receive This field indicates the
     * stripping operation on inner VLAN Tag in received packet.
     */
    inline void set_MAC_VLAN_TAG_CTRL_EIVLS(
        ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS value) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        MAC_VLAN_TAG_CTRL = curr;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's ERIVLT bit.
     *
     * ERIVLT
     */
    inline bool get_MAC_VLAN_TAG_CTRL_ERIVLT() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 27u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's ERIVLT bit.
     *
     * ERIVLT
     */
    inline void set_MAC_VLAN_TAG_CTRL_ERIVLT() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 27u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's ERIVLT bit.
     *
     * ERIVLT
     */
    inline void clear_MAC_VLAN_TAG_CTRL_ERIVLT() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 27u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's ERIVLT bit.
     *
     * ERIVLT
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_ERIVLT() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 27u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's EDVLP bit.
     *
     * Enable Double VLAN Processing
     */
    inline bool get_MAC_VLAN_TAG_CTRL_EDVLP() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 26u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's EDVLP bit.
     *
     * Enable Double VLAN Processing
     */
    inline void set_MAC_VLAN_TAG_CTRL_EDVLP() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 26u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's EDVLP bit.
     *
     * Enable Double VLAN Processing
     */
    inline void clear_MAC_VLAN_TAG_CTRL_EDVLP() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's EDVLP bit.
     *
     * Enable Double VLAN Processing
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_EDVLP() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 26u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's VTHM bit.
     *
     * VLAN Tag Hash Table Match Enable
     */
    inline bool get_MAC_VLAN_TAG_CTRL_VTHM() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 25u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's VTHM bit.
     *
     * VLAN Tag Hash Table Match Enable
     */
    inline void set_MAC_VLAN_TAG_CTRL_VTHM() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 25u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's VTHM bit.
     *
     * VLAN Tag Hash Table Match Enable
     */
    inline void clear_MAC_VLAN_TAG_CTRL_VTHM() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's VTHM bit.
     *
     * VLAN Tag Hash Table Match Enable
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_VTHM() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 25u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's EVLRXS bit.
     *
     * Enable VLAN Tag in Rx status
     */
    inline bool get_MAC_VLAN_TAG_CTRL_EVLRXS() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 24u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's EVLRXS bit.
     *
     * Enable VLAN Tag in Rx status
     */
    inline void set_MAC_VLAN_TAG_CTRL_EVLRXS() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 24u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's EVLRXS bit.
     *
     * Enable VLAN Tag in Rx status
     */
    inline void clear_MAC_VLAN_TAG_CTRL_EVLRXS() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's EVLRXS bit.
     *
     * Enable VLAN Tag in Rx status
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_EVLRXS() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 24u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's EVLS field.
     *
     * Enable VLAN Tag Stripping on Receive This field indicates the stripping
     * operation on the outer VLAN Tag in received packet.
     */
    inline ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS
    get_MAC_VLAN_TAG_CTRL_EVLS() volatile
    {
        return ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS((MAC_VLAN_TAG_CTRL >> 21u) &
                                               0b11u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's EVLS field.
     *
     * Enable VLAN Tag Stripping on Receive This field indicates the stripping
     * operation on the outer VLAN Tag in received packet.
     */
    inline void set_MAC_VLAN_TAG_CTRL_EVLS(
        ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS value) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_CTRL;

        curr &= ~(0b11u << 21u);
        curr |= (std::to_underlying(value) & 0b11u) << 21u;

        MAC_VLAN_TAG_CTRL = curr;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's ESVL bit.
     *
     * Enable S-VLAN When this bit is set, the MAC transmitter and receiver
     * consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged
     * packets.
     */
    inline bool get_MAC_VLAN_TAG_CTRL_ESVL() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 18u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's ESVL bit.
     *
     * Enable S-VLAN When this bit is set, the MAC transmitter and receiver
     * consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged
     * packets.
     */
    inline void set_MAC_VLAN_TAG_CTRL_ESVL() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 18u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's ESVL bit.
     *
     * Enable S-VLAN When this bit is set, the MAC transmitter and receiver
     * consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged
     * packets.
     */
    inline void clear_MAC_VLAN_TAG_CTRL_ESVL() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's ESVL bit.
     *
     * Enable S-VLAN When this bit is set, the MAC transmitter and receiver
     * consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged
     * packets.
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_ESVL() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 18u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's VTIM bit.
     *
     * VLAN Tag Inverse Match Enable
     */
    inline bool get_MAC_VLAN_TAG_CTRL_VTIM() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 17u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's VTIM bit.
     *
     * VLAN Tag Inverse Match Enable
     */
    inline void set_MAC_VLAN_TAG_CTRL_VTIM() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 17u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's VTIM bit.
     *
     * VLAN Tag Inverse Match Enable
     */
    inline void clear_MAC_VLAN_TAG_CTRL_VTIM() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's VTIM bit.
     *
     * VLAN Tag Inverse Match Enable
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_VTIM() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 17u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's OFS field.
     *
     * Offset
     */
    inline uint8_t get_MAC_VLAN_TAG_CTRL_OFS() volatile
    {
        return (MAC_VLAN_TAG_CTRL >> 2u) & 0b11111u;
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's OFS field.
     *
     * Offset
     */
    inline void set_MAC_VLAN_TAG_CTRL_OFS(uint8_t value) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_CTRL;

        curr &= ~(0b11111u << 2u);
        curr |= (value & 0b11111u) << 2u;

        MAC_VLAN_TAG_CTRL = curr;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's CT bit.
     *
     * Command Type
     */
    inline bool get_MAC_VLAN_TAG_CTRL_CT() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's CT bit.
     *
     * Command Type
     */
    inline void set_MAC_VLAN_TAG_CTRL_CT() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's CT bit.
     *
     * Command Type
     */
    inline void clear_MAC_VLAN_TAG_CTRL_CT() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's CT bit.
     *
     * Command Type
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_CT() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_VLAN_TAG_CTRL's OB bit.
     *
     * Operation Busy
     */
    inline bool get_MAC_VLAN_TAG_CTRL_OB() volatile
    {
        return MAC_VLAN_TAG_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_VLAN_TAG_CTRL's OB bit.
     *
     * Operation Busy
     */
    inline void set_MAC_VLAN_TAG_CTRL_OB() volatile
    {
        MAC_VLAN_TAG_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_VLAN_TAG_CTRL's OB bit.
     *
     * Operation Busy
     */
    inline void clear_MAC_VLAN_TAG_CTRL_OB() volatile
    {
        MAC_VLAN_TAG_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_VLAN_TAG_CTRL's OB bit.
     *
     * Operation Busy
     */
    inline void toggle_MAC_VLAN_TAG_CTRL_OB() volatile
    {
        MAC_VLAN_TAG_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_VLAN_TAG_CTRL's bit fields.
     *
     * (read-write) MAC VLAN Tag Control
     */
    inline void get_MAC_VLAN_TAG_CTRL(bool &EIVLRXS,
                                      ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS &EIVLS,
                                      bool &ERIVLT, bool &EDVLP, bool &VTHM,
                                      bool &EVLRXS,
                                      ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS &EVLS,
                                      bool &ESVL, bool &VTIM, uint8_t &OFS,
                                      bool &CT, bool &OB) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_CTRL;

        EIVLRXS = curr & (1u << 31u);
        EIVLS = ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS((curr >> 28u) & 0b11u);
        ERIVLT = curr & (1u << 27u);
        EDVLP = curr & (1u << 26u);
        VTHM = curr & (1u << 25u);
        EVLRXS = curr & (1u << 24u);
        EVLS = ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS((curr >> 21u) & 0b11u);
        ESVL = curr & (1u << 18u);
        VTIM = curr & (1u << 17u);
        OFS = (curr >> 2u) & 0b11111u;
        CT = curr & (1u << 1u);
        OB = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_VLAN_TAG_CTRL's bit fields.
     *
     * (read-write) MAC VLAN Tag Control
     */
    inline void set_MAC_VLAN_TAG_CTRL(bool EIVLRXS,
                                      ENET_QOS_MAC_VLAN_TAG_CTRL_EIVLS EIVLS,
                                      bool ERIVLT, bool EDVLP, bool VTHM,
                                      bool EVLRXS,
                                      ENET_QOS_MAC_VLAN_TAG_CTRL_EVLS EVLS,
                                      bool ESVL, bool VTIM, uint8_t OFS,
                                      bool CT, bool OB) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (EIVLRXS & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(EIVLS) & 0b11u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (ERIVLT & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (EDVLP & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (VTHM & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (EVLRXS & 0b1u) << 24u;
        curr &= ~(0b11u << 21u);
        curr |= (std::to_underlying(EVLS) & 0b11u) << 21u;
        curr &= ~(0b1u << 18u);
        curr |= (ESVL & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (VTIM & 0b1u) << 17u;
        curr &= ~(0b11111u << 2u);
        curr |= (OFS & 0b11111u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OB & 0b1u) << 0u;

        MAC_VLAN_TAG_CTRL = curr;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's DMACHN field.
     *
     * DMA Channel Number
     */
    inline uint8_t get_MAC_VLAN_TAG_DATA_DMACHN() volatile
    {
        return (MAC_VLAN_TAG_DATA >> 25u) & 0b111u;
    }

    /**
     * Set MAC_VLAN_TAG_DATA's DMACHN field.
     *
     * DMA Channel Number
     */
    inline void set_MAC_VLAN_TAG_DATA_DMACHN(uint8_t value) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_DATA;

        curr &= ~(0b111u << 25u);
        curr |= (value & 0b111u) << 25u;

        MAC_VLAN_TAG_DATA = curr;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's DMACHEN bit.
     *
     * DMA Channel Number Enable
     */
    inline bool get_MAC_VLAN_TAG_DATA_DMACHEN() volatile
    {
        return MAC_VLAN_TAG_DATA & (1u << 24u);
    }

    /**
     * Set MAC_VLAN_TAG_DATA's DMACHEN bit.
     *
     * DMA Channel Number Enable
     */
    inline void set_MAC_VLAN_TAG_DATA_DMACHEN() volatile
    {
        MAC_VLAN_TAG_DATA |= 1u << 24u;
    }

    /**
     * Clear MAC_VLAN_TAG_DATA's DMACHEN bit.
     *
     * DMA Channel Number Enable
     */
    inline void clear_MAC_VLAN_TAG_DATA_DMACHEN() volatile
    {
        MAC_VLAN_TAG_DATA &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_VLAN_TAG_DATA's DMACHEN bit.
     *
     * DMA Channel Number Enable
     */
    inline void toggle_MAC_VLAN_TAG_DATA_DMACHEN() volatile
    {
        MAC_VLAN_TAG_DATA ^= 1u << 24u;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's ERIVLT bit.
     *
     * Enable Inner VLAN Tag Comparison
     */
    inline bool get_MAC_VLAN_TAG_DATA_ERIVLT() volatile
    {
        return MAC_VLAN_TAG_DATA & (1u << 20u);
    }

    /**
     * Set MAC_VLAN_TAG_DATA's ERIVLT bit.
     *
     * Enable Inner VLAN Tag Comparison
     */
    inline void set_MAC_VLAN_TAG_DATA_ERIVLT() volatile
    {
        MAC_VLAN_TAG_DATA |= 1u << 20u;
    }

    /**
     * Clear MAC_VLAN_TAG_DATA's ERIVLT bit.
     *
     * Enable Inner VLAN Tag Comparison
     */
    inline void clear_MAC_VLAN_TAG_DATA_ERIVLT() volatile
    {
        MAC_VLAN_TAG_DATA &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_VLAN_TAG_DATA's ERIVLT bit.
     *
     * Enable Inner VLAN Tag Comparison
     */
    inline void toggle_MAC_VLAN_TAG_DATA_ERIVLT() volatile
    {
        MAC_VLAN_TAG_DATA ^= 1u << 20u;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's ERSVLM bit.
     *
     * Enable S-VLAN Match for received Frames
     */
    inline bool get_MAC_VLAN_TAG_DATA_ERSVLM() volatile
    {
        return MAC_VLAN_TAG_DATA & (1u << 19u);
    }

    /**
     * Set MAC_VLAN_TAG_DATA's ERSVLM bit.
     *
     * Enable S-VLAN Match for received Frames
     */
    inline void set_MAC_VLAN_TAG_DATA_ERSVLM() volatile
    {
        MAC_VLAN_TAG_DATA |= 1u << 19u;
    }

    /**
     * Clear MAC_VLAN_TAG_DATA's ERSVLM bit.
     *
     * Enable S-VLAN Match for received Frames
     */
    inline void clear_MAC_VLAN_TAG_DATA_ERSVLM() volatile
    {
        MAC_VLAN_TAG_DATA &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_VLAN_TAG_DATA's ERSVLM bit.
     *
     * Enable S-VLAN Match for received Frames
     */
    inline void toggle_MAC_VLAN_TAG_DATA_ERSVLM() volatile
    {
        MAC_VLAN_TAG_DATA ^= 1u << 19u;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's DOVLTC bit.
     *
     * Disable VLAN Type Comparison
     */
    inline bool get_MAC_VLAN_TAG_DATA_DOVLTC() volatile
    {
        return MAC_VLAN_TAG_DATA & (1u << 18u);
    }

    /**
     * Set MAC_VLAN_TAG_DATA's DOVLTC bit.
     *
     * Disable VLAN Type Comparison
     */
    inline void set_MAC_VLAN_TAG_DATA_DOVLTC() volatile
    {
        MAC_VLAN_TAG_DATA |= 1u << 18u;
    }

    /**
     * Clear MAC_VLAN_TAG_DATA's DOVLTC bit.
     *
     * Disable VLAN Type Comparison
     */
    inline void clear_MAC_VLAN_TAG_DATA_DOVLTC() volatile
    {
        MAC_VLAN_TAG_DATA &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_VLAN_TAG_DATA's DOVLTC bit.
     *
     * Disable VLAN Type Comparison
     */
    inline void toggle_MAC_VLAN_TAG_DATA_DOVLTC() volatile
    {
        MAC_VLAN_TAG_DATA ^= 1u << 18u;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's ETV bit.
     *
     * 12bits or 16bits VLAN comparison
     */
    inline bool get_MAC_VLAN_TAG_DATA_ETV() volatile
    {
        return MAC_VLAN_TAG_DATA & (1u << 17u);
    }

    /**
     * Set MAC_VLAN_TAG_DATA's ETV bit.
     *
     * 12bits or 16bits VLAN comparison
     */
    inline void set_MAC_VLAN_TAG_DATA_ETV() volatile
    {
        MAC_VLAN_TAG_DATA |= 1u << 17u;
    }

    /**
     * Clear MAC_VLAN_TAG_DATA's ETV bit.
     *
     * 12bits or 16bits VLAN comparison
     */
    inline void clear_MAC_VLAN_TAG_DATA_ETV() volatile
    {
        MAC_VLAN_TAG_DATA &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_VLAN_TAG_DATA's ETV bit.
     *
     * 12bits or 16bits VLAN comparison
     */
    inline void toggle_MAC_VLAN_TAG_DATA_ETV() volatile
    {
        MAC_VLAN_TAG_DATA ^= 1u << 17u;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's VEN bit.
     *
     * VLAN Tag Enable
     */
    inline bool get_MAC_VLAN_TAG_DATA_VEN() volatile
    {
        return MAC_VLAN_TAG_DATA & (1u << 16u);
    }

    /**
     * Set MAC_VLAN_TAG_DATA's VEN bit.
     *
     * VLAN Tag Enable
     */
    inline void set_MAC_VLAN_TAG_DATA_VEN() volatile
    {
        MAC_VLAN_TAG_DATA |= 1u << 16u;
    }

    /**
     * Clear MAC_VLAN_TAG_DATA's VEN bit.
     *
     * VLAN Tag Enable
     */
    inline void clear_MAC_VLAN_TAG_DATA_VEN() volatile
    {
        MAC_VLAN_TAG_DATA &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_VLAN_TAG_DATA's VEN bit.
     *
     * VLAN Tag Enable
     */
    inline void toggle_MAC_VLAN_TAG_DATA_VEN() volatile
    {
        MAC_VLAN_TAG_DATA ^= 1u << 16u;
    }

    /**
     * Get MAC_VLAN_TAG_DATA's VID field.
     *
     * VLAN Tag ID
     */
    inline uint16_t get_MAC_VLAN_TAG_DATA_VID() volatile
    {
        return (MAC_VLAN_TAG_DATA >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_VLAN_TAG_DATA's VID field.
     *
     * VLAN Tag ID
     */
    inline void set_MAC_VLAN_TAG_DATA_VID(uint16_t value) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_DATA;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_VLAN_TAG_DATA = curr;
    }

    /**
     * Get all of MAC_VLAN_TAG_DATA's bit fields.
     *
     * (read-write) MAC VLAN Tag Data
     */
    inline void get_MAC_VLAN_TAG_DATA(uint8_t &DMACHN, bool &DMACHEN,
                                      bool &ERIVLT, bool &ERSVLM, bool &DOVLTC,
                                      bool &ETV, bool &VEN,
                                      uint16_t &VID) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_DATA;

        DMACHN = (curr >> 25u) & 0b111u;
        DMACHEN = curr & (1u << 24u);
        ERIVLT = curr & (1u << 20u);
        ERSVLM = curr & (1u << 19u);
        DOVLTC = curr & (1u << 18u);
        ETV = curr & (1u << 17u);
        VEN = curr & (1u << 16u);
        VID = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_VLAN_TAG_DATA's bit fields.
     *
     * (read-write) MAC VLAN Tag Data
     */
    inline void set_MAC_VLAN_TAG_DATA(uint8_t DMACHN, bool DMACHEN,
                                      bool ERIVLT, bool ERSVLM, bool DOVLTC,
                                      bool ETV, bool VEN,
                                      uint16_t VID) volatile
    {
        uint32_t curr = MAC_VLAN_TAG_DATA;

        curr &= ~(0b111u << 25u);
        curr |= (DMACHN & 0b111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (DMACHEN & 0b1u) << 24u;
        curr &= ~(0b1u << 20u);
        curr |= (ERIVLT & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ERSVLM & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (DOVLTC & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (ETV & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (VEN & 0b1u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (VID & 0b1111111111111111u) << 0u;

        MAC_VLAN_TAG_DATA = curr;
    }

    /**
     * Get MAC_VLAN_HASH_TABLE's VLHT field.
     *
     * VLAN Hash Table This field contains the 16-bit VLAN Hash Table.
     */
    inline uint16_t get_MAC_VLAN_HASH_TABLE_VLHT() volatile
    {
        return (MAC_VLAN_HASH_TABLE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_VLAN_HASH_TABLE's VLHT field.
     *
     * VLAN Hash Table This field contains the 16-bit VLAN Hash Table.
     */
    inline void set_MAC_VLAN_HASH_TABLE_VLHT(uint16_t value) volatile
    {
        uint32_t curr = MAC_VLAN_HASH_TABLE;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_VLAN_HASH_TABLE = curr;
    }

    /**
     * Get MAC_VLAN_INCL's BUSY bit.
     *
     * Busy
     */
    inline bool get_MAC_VLAN_INCL_BUSY() volatile
    {
        return MAC_VLAN_INCL & (1u << 31u);
    }

    /**
     * Get MAC_VLAN_INCL's RDWR bit.
     *
     * Read write control
     */
    inline bool get_MAC_VLAN_INCL_RDWR() volatile
    {
        return MAC_VLAN_INCL & (1u << 30u);
    }

    /**
     * Set MAC_VLAN_INCL's RDWR bit.
     *
     * Read write control
     */
    inline void set_MAC_VLAN_INCL_RDWR() volatile
    {
        MAC_VLAN_INCL |= 1u << 30u;
    }

    /**
     * Clear MAC_VLAN_INCL's RDWR bit.
     *
     * Read write control
     */
    inline void clear_MAC_VLAN_INCL_RDWR() volatile
    {
        MAC_VLAN_INCL &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_VLAN_INCL's RDWR bit.
     *
     * Read write control
     */
    inline void toggle_MAC_VLAN_INCL_RDWR() volatile
    {
        MAC_VLAN_INCL ^= 1u << 30u;
    }

    /**
     * Get MAC_VLAN_INCL's ADDR field.
     *
     * Address
     */
    inline uint8_t get_MAC_VLAN_INCL_ADDR() volatile
    {
        return (MAC_VLAN_INCL >> 24u) & 0b111u;
    }

    /**
     * Set MAC_VLAN_INCL's ADDR field.
     *
     * Address
     */
    inline void set_MAC_VLAN_INCL_ADDR(uint8_t value) volatile
    {
        uint32_t curr = MAC_VLAN_INCL;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_VLAN_INCL = curr;
    }

    /**
     * Get MAC_VLAN_INCL's CBTI bit.
     *
     * Channel based tag insertion
     */
    inline bool get_MAC_VLAN_INCL_CBTI() volatile
    {
        return MAC_VLAN_INCL & (1u << 21u);
    }

    /**
     * Set MAC_VLAN_INCL's CBTI bit.
     *
     * Channel based tag insertion
     */
    inline void set_MAC_VLAN_INCL_CBTI() volatile
    {
        MAC_VLAN_INCL |= 1u << 21u;
    }

    /**
     * Clear MAC_VLAN_INCL's CBTI bit.
     *
     * Channel based tag insertion
     */
    inline void clear_MAC_VLAN_INCL_CBTI() volatile
    {
        MAC_VLAN_INCL &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_VLAN_INCL's CBTI bit.
     *
     * Channel based tag insertion
     */
    inline void toggle_MAC_VLAN_INCL_CBTI() volatile
    {
        MAC_VLAN_INCL ^= 1u << 21u;
    }

    /**
     * Get MAC_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline bool get_MAC_VLAN_INCL_VLTI() volatile
    {
        return MAC_VLAN_INCL & (1u << 20u);
    }

    /**
     * Set MAC_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline void set_MAC_VLAN_INCL_VLTI() volatile
    {
        MAC_VLAN_INCL |= 1u << 20u;
    }

    /**
     * Clear MAC_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline void clear_MAC_VLAN_INCL_VLTI() volatile
    {
        MAC_VLAN_INCL &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline void toggle_MAC_VLAN_INCL_VLTI() volatile
    {
        MAC_VLAN_INCL ^= 1u << 20u;
    }

    /**
     * Get MAC_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline bool get_MAC_VLAN_INCL_CSVL() volatile
    {
        return MAC_VLAN_INCL & (1u << 19u);
    }

    /**
     * Set MAC_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline void set_MAC_VLAN_INCL_CSVL() volatile
    {
        MAC_VLAN_INCL |= 1u << 19u;
    }

    /**
     * Clear MAC_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline void clear_MAC_VLAN_INCL_CSVL() volatile
    {
        MAC_VLAN_INCL &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline void toggle_MAC_VLAN_INCL_CSVL() volatile
    {
        MAC_VLAN_INCL ^= 1u << 19u;
    }

    /**
     * Get MAC_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline bool get_MAC_VLAN_INCL_VLP() volatile
    {
        return MAC_VLAN_INCL & (1u << 18u);
    }

    /**
     * Set MAC_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline void set_MAC_VLAN_INCL_VLP() volatile
    {
        MAC_VLAN_INCL |= 1u << 18u;
    }

    /**
     * Clear MAC_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline void clear_MAC_VLAN_INCL_VLP() volatile
    {
        MAC_VLAN_INCL &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline void toggle_MAC_VLAN_INCL_VLP() volatile
    {
        MAC_VLAN_INCL ^= 1u << 18u;
    }

    /**
     * Get MAC_VLAN_INCL's VLC field.
     *
     * VLAN Tag Control in Transmit Packets - 2'b00: No VLAN tag deletion,
     * insertion, or replacement - 2'b01: VLAN tag deletion The MAC removes the
     * VLAN type (bytes 13 and 14) and VLAN tag (bytes 15 and 16) of all
     * transmitted packets with VLAN tags.
     */
    inline ENET_QOS_MAC_VLAN_INCL_VLC get_MAC_VLAN_INCL_VLC() volatile
    {
        return ENET_QOS_MAC_VLAN_INCL_VLC((MAC_VLAN_INCL >> 16u) & 0b11u);
    }

    /**
     * Set MAC_VLAN_INCL's VLC field.
     *
     * VLAN Tag Control in Transmit Packets - 2'b00: No VLAN tag deletion,
     * insertion, or replacement - 2'b01: VLAN tag deletion The MAC removes the
     * VLAN type (bytes 13 and 14) and VLAN tag (bytes 15 and 16) of all
     * transmitted packets with VLAN tags.
     */
    inline void set_MAC_VLAN_INCL_VLC(
        ENET_QOS_MAC_VLAN_INCL_VLC value) volatile
    {
        uint32_t curr = MAC_VLAN_INCL;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        MAC_VLAN_INCL = curr;
    }

    /**
     * Get MAC_VLAN_INCL's VLT field.
     *
     * VLAN Tag for Transmit Packets
     */
    inline uint16_t get_MAC_VLAN_INCL_VLT() volatile
    {
        return (MAC_VLAN_INCL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_VLAN_INCL's VLT field.
     *
     * VLAN Tag for Transmit Packets
     */
    inline void set_MAC_VLAN_INCL_VLT(uint16_t value) volatile
    {
        uint32_t curr = MAC_VLAN_INCL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_VLAN_INCL = curr;
    }

    /**
     * Get all of MAC_VLAN_INCL's bit fields.
     *
     * (read-write) VLAN Tag Inclusion or Replacement
     */
    inline void get_MAC_VLAN_INCL(bool &BUSY, bool &RDWR, uint8_t &ADDR,
                                  bool &CBTI, bool &VLTI, bool &CSVL,
                                  bool &VLP, ENET_QOS_MAC_VLAN_INCL_VLC &VLC,
                                  uint16_t &VLT) volatile
    {
        uint32_t curr = MAC_VLAN_INCL;

        BUSY = curr & (1u << 31u);
        RDWR = curr & (1u << 30u);
        ADDR = (curr >> 24u) & 0b111u;
        CBTI = curr & (1u << 21u);
        VLTI = curr & (1u << 20u);
        CSVL = curr & (1u << 19u);
        VLP = curr & (1u << 18u);
        VLC = ENET_QOS_MAC_VLAN_INCL_VLC((curr >> 16u) & 0b11u);
        VLT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_VLAN_INCL's bit fields.
     *
     * (read-write) VLAN Tag Inclusion or Replacement
     */
    inline void set_MAC_VLAN_INCL(bool RDWR, uint8_t ADDR, bool CBTI,
                                  bool VLTI, bool CSVL, bool VLP,
                                  ENET_QOS_MAC_VLAN_INCL_VLC VLC,
                                  uint16_t VLT) volatile
    {
        uint32_t curr = MAC_VLAN_INCL;

        curr &= ~(0b1u << 30u);
        curr |= (RDWR & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (ADDR & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (CBTI & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (VLTI & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CSVL & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (VLP & 0b1u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(VLC) & 0b11u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (VLT & 0b1111111111111111u) << 0u;

        MAC_VLAN_INCL = curr;
    }

    /**
     * Get MAC_INNER_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline bool get_MAC_INNER_VLAN_INCL_VLTI() volatile
    {
        return MAC_INNER_VLAN_INCL & (1u << 20u);
    }

    /**
     * Set MAC_INNER_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline void set_MAC_INNER_VLAN_INCL_VLTI() volatile
    {
        MAC_INNER_VLAN_INCL |= 1u << 20u;
    }

    /**
     * Clear MAC_INNER_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline void clear_MAC_INNER_VLAN_INCL_VLTI() volatile
    {
        MAC_INNER_VLAN_INCL &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_INNER_VLAN_INCL's VLTI bit.
     *
     * VLAN Tag Input When this bit is set, it indicates that the VLAN tag to
     * be inserted or replaced in Tx packet should be taken from: - The Tx
     * descriptor
     */
    inline void toggle_MAC_INNER_VLAN_INCL_VLTI() volatile
    {
        MAC_INNER_VLAN_INCL ^= 1u << 20u;
    }

    /**
     * Get MAC_INNER_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline bool get_MAC_INNER_VLAN_INCL_CSVL() volatile
    {
        return MAC_INNER_VLAN_INCL & (1u << 19u);
    }

    /**
     * Set MAC_INNER_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline void set_MAC_INNER_VLAN_INCL_CSVL() volatile
    {
        MAC_INNER_VLAN_INCL |= 1u << 19u;
    }

    /**
     * Clear MAC_INNER_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline void clear_MAC_INNER_VLAN_INCL_CSVL() volatile
    {
        MAC_INNER_VLAN_INCL &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_INNER_VLAN_INCL's CSVL bit.
     *
     * C-VLAN or S-VLAN
     */
    inline void toggle_MAC_INNER_VLAN_INCL_CSVL() volatile
    {
        MAC_INNER_VLAN_INCL ^= 1u << 19u;
    }

    /**
     * Get MAC_INNER_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline bool get_MAC_INNER_VLAN_INCL_VLP() volatile
    {
        return MAC_INNER_VLAN_INCL & (1u << 18u);
    }

    /**
     * Set MAC_INNER_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline void set_MAC_INNER_VLAN_INCL_VLP() volatile
    {
        MAC_INNER_VLAN_INCL |= 1u << 18u;
    }

    /**
     * Clear MAC_INNER_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline void clear_MAC_INNER_VLAN_INCL_VLP() volatile
    {
        MAC_INNER_VLAN_INCL &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_INNER_VLAN_INCL's VLP bit.
     *
     * VLAN Priority Control
     */
    inline void toggle_MAC_INNER_VLAN_INCL_VLP() volatile
    {
        MAC_INNER_VLAN_INCL ^= 1u << 18u;
    }

    /**
     * Get MAC_INNER_VLAN_INCL's VLC field.
     *
     * VLAN Tag Control in Transmit Packets
     */
    inline ENET_QOS_MAC_INNER_VLAN_INCL_VLC
    get_MAC_INNER_VLAN_INCL_VLC() volatile
    {
        return ENET_QOS_MAC_INNER_VLAN_INCL_VLC((MAC_INNER_VLAN_INCL >> 16u) &
                                                0b11u);
    }

    /**
     * Set MAC_INNER_VLAN_INCL's VLC field.
     *
     * VLAN Tag Control in Transmit Packets
     */
    inline void set_MAC_INNER_VLAN_INCL_VLC(
        ENET_QOS_MAC_INNER_VLAN_INCL_VLC value) volatile
    {
        uint32_t curr = MAC_INNER_VLAN_INCL;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        MAC_INNER_VLAN_INCL = curr;
    }

    /**
     * Get MAC_INNER_VLAN_INCL's VLT field.
     *
     * VLAN Tag for Transmit Packets
     */
    inline uint16_t get_MAC_INNER_VLAN_INCL_VLT() volatile
    {
        return (MAC_INNER_VLAN_INCL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_INNER_VLAN_INCL's VLT field.
     *
     * VLAN Tag for Transmit Packets
     */
    inline void set_MAC_INNER_VLAN_INCL_VLT(uint16_t value) volatile
    {
        uint32_t curr = MAC_INNER_VLAN_INCL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_INNER_VLAN_INCL = curr;
    }

    /**
     * Get all of MAC_INNER_VLAN_INCL's bit fields.
     *
     * (read-write) MAC Inner VLAN Tag Inclusion or Replacement
     */
    inline void get_MAC_INNER_VLAN_INCL(bool &VLTI, bool &CSVL, bool &VLP,
                                        ENET_QOS_MAC_INNER_VLAN_INCL_VLC &VLC,
                                        uint16_t &VLT) volatile
    {
        uint32_t curr = MAC_INNER_VLAN_INCL;

        VLTI = curr & (1u << 20u);
        CSVL = curr & (1u << 19u);
        VLP = curr & (1u << 18u);
        VLC = ENET_QOS_MAC_INNER_VLAN_INCL_VLC((curr >> 16u) & 0b11u);
        VLT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_INNER_VLAN_INCL's bit fields.
     *
     * (read-write) MAC Inner VLAN Tag Inclusion or Replacement
     */
    inline void set_MAC_INNER_VLAN_INCL(bool VLTI, bool CSVL, bool VLP,
                                        ENET_QOS_MAC_INNER_VLAN_INCL_VLC VLC,
                                        uint16_t VLT) volatile
    {
        uint32_t curr = MAC_INNER_VLAN_INCL;

        curr &= ~(0b1u << 20u);
        curr |= (VLTI & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CSVL & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (VLP & 0b1u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(VLC) & 0b11u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (VLT & 0b1111111111111111u) << 0u;

        MAC_INNER_VLAN_INCL = curr;
    }

    /**
     * Get MAC_Q0_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline uint16_t get_MAC_Q0_TX_FLOW_CTRL_PT() volatile
    {
        return (MAC_Q0_TX_FLOW_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_Q0_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline void set_MAC_Q0_TX_FLOW_CTRL_PT(uint16_t value) volatile
    {
        uint32_t curr = MAC_Q0_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_Q0_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q0_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline bool get_MAC_Q0_TX_FLOW_CTRL_DZPQ() volatile
    {
        return MAC_Q0_TX_FLOW_CTRL & (1u << 7u);
    }

    /**
     * Set MAC_Q0_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void set_MAC_Q0_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q0_TX_FLOW_CTRL |= 1u << 7u;
    }

    /**
     * Clear MAC_Q0_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void clear_MAC_Q0_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q0_TX_FLOW_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_Q0_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void toggle_MAC_Q0_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q0_TX_FLOW_CTRL ^= 1u << 7u;
    }

    /**
     * Get MAC_Q0_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT
    get_MAC_Q0_TX_FLOW_CTRL_PLT() volatile
    {
        return ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT((MAC_Q0_TX_FLOW_CTRL >> 4u) &
                                                0b111u);
    }

    /**
     * Set MAC_Q0_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline void set_MAC_Q0_TX_FLOW_CTRL_PLT(
        ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT value) volatile
    {
        uint32_t curr = MAC_Q0_TX_FLOW_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MAC_Q0_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q0_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline bool get_MAC_Q0_TX_FLOW_CTRL_TFE() volatile
    {
        return MAC_Q0_TX_FLOW_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_Q0_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void set_MAC_Q0_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q0_TX_FLOW_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_Q0_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void clear_MAC_Q0_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q0_TX_FLOW_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_Q0_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void toggle_MAC_Q0_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q0_TX_FLOW_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_Q0_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy or Backpressure Activate
     */
    inline bool get_MAC_Q0_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        return MAC_Q0_TX_FLOW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_Q0_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy or Backpressure Activate
     */
    inline void set_MAC_Q0_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q0_TX_FLOW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_Q0_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy or Backpressure Activate
     */
    inline void clear_MAC_Q0_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q0_TX_FLOW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_Q0_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy or Backpressure Activate
     */
    inline void toggle_MAC_Q0_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q0_TX_FLOW_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_Q0_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q0 Tx Flow Control
     */
    inline void get_MAC_Q0_TX_FLOW_CTRL(uint16_t &PT, bool &DZPQ,
                                        ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT &PLT,
                                        bool &TFE, bool &FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q0_TX_FLOW_CTRL;

        PT = (curr >> 16u) & 0b1111111111111111u;
        DZPQ = curr & (1u << 7u);
        PLT = ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT((curr >> 4u) & 0b111u);
        TFE = curr & (1u << 1u);
        FCB_BPA = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_Q0_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q0 Tx Flow Control
     */
    inline void set_MAC_Q0_TX_FLOW_CTRL(uint16_t PT, bool DZPQ,
                                        ENET_QOS_MAC_Q0_TX_FLOW_CTRL_PLT PLT,
                                        bool TFE, bool FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q0_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (PT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (DZPQ & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(PLT) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TFE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FCB_BPA & 0b1u) << 0u;

        MAC_Q0_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q1_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline uint16_t get_MAC_Q1_TX_FLOW_CTRL_PT() volatile
    {
        return (MAC_Q1_TX_FLOW_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_Q1_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline void set_MAC_Q1_TX_FLOW_CTRL_PT(uint16_t value) volatile
    {
        uint32_t curr = MAC_Q1_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_Q1_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q1_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline bool get_MAC_Q1_TX_FLOW_CTRL_DZPQ() volatile
    {
        return MAC_Q1_TX_FLOW_CTRL & (1u << 7u);
    }

    /**
     * Set MAC_Q1_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void set_MAC_Q1_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q1_TX_FLOW_CTRL |= 1u << 7u;
    }

    /**
     * Clear MAC_Q1_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void clear_MAC_Q1_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q1_TX_FLOW_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_Q1_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void toggle_MAC_Q1_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q1_TX_FLOW_CTRL ^= 1u << 7u;
    }

    /**
     * Get MAC_Q1_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT
    get_MAC_Q1_TX_FLOW_CTRL_PLT() volatile
    {
        return ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT((MAC_Q1_TX_FLOW_CTRL >> 4u) &
                                                0b111u);
    }

    /**
     * Set MAC_Q1_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline void set_MAC_Q1_TX_FLOW_CTRL_PLT(
        ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT value) volatile
    {
        uint32_t curr = MAC_Q1_TX_FLOW_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MAC_Q1_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q1_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline bool get_MAC_Q1_TX_FLOW_CTRL_TFE() volatile
    {
        return MAC_Q1_TX_FLOW_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_Q1_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void set_MAC_Q1_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q1_TX_FLOW_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_Q1_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void clear_MAC_Q1_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q1_TX_FLOW_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_Q1_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void toggle_MAC_Q1_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q1_TX_FLOW_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_Q1_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline bool get_MAC_Q1_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        return MAC_Q1_TX_FLOW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_Q1_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void set_MAC_Q1_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q1_TX_FLOW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_Q1_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void clear_MAC_Q1_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q1_TX_FLOW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_Q1_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void toggle_MAC_Q1_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q1_TX_FLOW_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_Q1_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q1 Tx Flow Control
     */
    inline void get_MAC_Q1_TX_FLOW_CTRL(uint16_t &PT, bool &DZPQ,
                                        ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT &PLT,
                                        bool &TFE, bool &FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q1_TX_FLOW_CTRL;

        PT = (curr >> 16u) & 0b1111111111111111u;
        DZPQ = curr & (1u << 7u);
        PLT = ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT((curr >> 4u) & 0b111u);
        TFE = curr & (1u << 1u);
        FCB_BPA = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_Q1_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q1 Tx Flow Control
     */
    inline void set_MAC_Q1_TX_FLOW_CTRL(uint16_t PT, bool DZPQ,
                                        ENET_QOS_MAC_Q1_TX_FLOW_CTRL_PLT PLT,
                                        bool TFE, bool FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q1_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (PT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (DZPQ & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(PLT) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TFE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FCB_BPA & 0b1u) << 0u;

        MAC_Q1_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q2_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline uint16_t get_MAC_Q2_TX_FLOW_CTRL_PT() volatile
    {
        return (MAC_Q2_TX_FLOW_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_Q2_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline void set_MAC_Q2_TX_FLOW_CTRL_PT(uint16_t value) volatile
    {
        uint32_t curr = MAC_Q2_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_Q2_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q2_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline bool get_MAC_Q2_TX_FLOW_CTRL_DZPQ() volatile
    {
        return MAC_Q2_TX_FLOW_CTRL & (1u << 7u);
    }

    /**
     * Set MAC_Q2_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void set_MAC_Q2_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q2_TX_FLOW_CTRL |= 1u << 7u;
    }

    /**
     * Clear MAC_Q2_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void clear_MAC_Q2_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q2_TX_FLOW_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_Q2_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void toggle_MAC_Q2_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q2_TX_FLOW_CTRL ^= 1u << 7u;
    }

    /**
     * Get MAC_Q2_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT
    get_MAC_Q2_TX_FLOW_CTRL_PLT() volatile
    {
        return ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT((MAC_Q2_TX_FLOW_CTRL >> 4u) &
                                                0b111u);
    }

    /**
     * Set MAC_Q2_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline void set_MAC_Q2_TX_FLOW_CTRL_PLT(
        ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT value) volatile
    {
        uint32_t curr = MAC_Q2_TX_FLOW_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MAC_Q2_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q2_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline bool get_MAC_Q2_TX_FLOW_CTRL_TFE() volatile
    {
        return MAC_Q2_TX_FLOW_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_Q2_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void set_MAC_Q2_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q2_TX_FLOW_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_Q2_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void clear_MAC_Q2_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q2_TX_FLOW_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_Q2_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void toggle_MAC_Q2_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q2_TX_FLOW_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_Q2_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline bool get_MAC_Q2_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        return MAC_Q2_TX_FLOW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_Q2_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void set_MAC_Q2_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q2_TX_FLOW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_Q2_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void clear_MAC_Q2_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q2_TX_FLOW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_Q2_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void toggle_MAC_Q2_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q2_TX_FLOW_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_Q2_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q2 Tx Flow Control
     */
    inline void get_MAC_Q2_TX_FLOW_CTRL(uint16_t &PT, bool &DZPQ,
                                        ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT &PLT,
                                        bool &TFE, bool &FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q2_TX_FLOW_CTRL;

        PT = (curr >> 16u) & 0b1111111111111111u;
        DZPQ = curr & (1u << 7u);
        PLT = ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT((curr >> 4u) & 0b111u);
        TFE = curr & (1u << 1u);
        FCB_BPA = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_Q2_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q2 Tx Flow Control
     */
    inline void set_MAC_Q2_TX_FLOW_CTRL(uint16_t PT, bool DZPQ,
                                        ENET_QOS_MAC_Q2_TX_FLOW_CTRL_PLT PLT,
                                        bool TFE, bool FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q2_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (PT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (DZPQ & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(PLT) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TFE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FCB_BPA & 0b1u) << 0u;

        MAC_Q2_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q3_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline uint16_t get_MAC_Q3_TX_FLOW_CTRL_PT() volatile
    {
        return (MAC_Q3_TX_FLOW_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_Q3_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline void set_MAC_Q3_TX_FLOW_CTRL_PT(uint16_t value) volatile
    {
        uint32_t curr = MAC_Q3_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_Q3_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q3_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline bool get_MAC_Q3_TX_FLOW_CTRL_DZPQ() volatile
    {
        return MAC_Q3_TX_FLOW_CTRL & (1u << 7u);
    }

    /**
     * Set MAC_Q3_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void set_MAC_Q3_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q3_TX_FLOW_CTRL |= 1u << 7u;
    }

    /**
     * Clear MAC_Q3_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void clear_MAC_Q3_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q3_TX_FLOW_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_Q3_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void toggle_MAC_Q3_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q3_TX_FLOW_CTRL ^= 1u << 7u;
    }

    /**
     * Get MAC_Q3_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT
    get_MAC_Q3_TX_FLOW_CTRL_PLT() volatile
    {
        return ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT((MAC_Q3_TX_FLOW_CTRL >> 4u) &
                                                0b111u);
    }

    /**
     * Set MAC_Q3_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline void set_MAC_Q3_TX_FLOW_CTRL_PLT(
        ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT value) volatile
    {
        uint32_t curr = MAC_Q3_TX_FLOW_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MAC_Q3_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q3_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline bool get_MAC_Q3_TX_FLOW_CTRL_TFE() volatile
    {
        return MAC_Q3_TX_FLOW_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_Q3_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void set_MAC_Q3_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q3_TX_FLOW_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_Q3_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void clear_MAC_Q3_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q3_TX_FLOW_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_Q3_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void toggle_MAC_Q3_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q3_TX_FLOW_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_Q3_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline bool get_MAC_Q3_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        return MAC_Q3_TX_FLOW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_Q3_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void set_MAC_Q3_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q3_TX_FLOW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_Q3_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void clear_MAC_Q3_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q3_TX_FLOW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_Q3_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void toggle_MAC_Q3_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q3_TX_FLOW_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_Q3_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q3 Tx Flow Control
     */
    inline void get_MAC_Q3_TX_FLOW_CTRL(uint16_t &PT, bool &DZPQ,
                                        ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT &PLT,
                                        bool &TFE, bool &FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q3_TX_FLOW_CTRL;

        PT = (curr >> 16u) & 0b1111111111111111u;
        DZPQ = curr & (1u << 7u);
        PLT = ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT((curr >> 4u) & 0b111u);
        TFE = curr & (1u << 1u);
        FCB_BPA = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_Q3_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q3 Tx Flow Control
     */
    inline void set_MAC_Q3_TX_FLOW_CTRL(uint16_t PT, bool DZPQ,
                                        ENET_QOS_MAC_Q3_TX_FLOW_CTRL_PLT PLT,
                                        bool TFE, bool FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q3_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (PT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (DZPQ & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(PLT) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TFE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FCB_BPA & 0b1u) << 0u;

        MAC_Q3_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q4_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline uint16_t get_MAC_Q4_TX_FLOW_CTRL_PT() volatile
    {
        return (MAC_Q4_TX_FLOW_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_Q4_TX_FLOW_CTRL's PT field.
     *
     * Pause Time
     */
    inline void set_MAC_Q4_TX_FLOW_CTRL_PT(uint16_t value) volatile
    {
        uint32_t curr = MAC_Q4_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_Q4_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q4_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline bool get_MAC_Q4_TX_FLOW_CTRL_DZPQ() volatile
    {
        return MAC_Q4_TX_FLOW_CTRL & (1u << 7u);
    }

    /**
     * Set MAC_Q4_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void set_MAC_Q4_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q4_TX_FLOW_CTRL |= 1u << 7u;
    }

    /**
     * Clear MAC_Q4_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void clear_MAC_Q4_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q4_TX_FLOW_CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_Q4_TX_FLOW_CTRL's DZPQ bit.
     *
     * Disable Zero-Quanta Pause
     */
    inline void toggle_MAC_Q4_TX_FLOW_CTRL_DZPQ() volatile
    {
        MAC_Q4_TX_FLOW_CTRL ^= 1u << 7u;
    }

    /**
     * Get MAC_Q4_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT
    get_MAC_Q4_TX_FLOW_CTRL_PLT() volatile
    {
        return ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT((MAC_Q4_TX_FLOW_CTRL >> 4u) &
                                                0b111u);
    }

    /**
     * Set MAC_Q4_TX_FLOW_CTRL's PLT field.
     *
     * Pause Low Threshold
     */
    inline void set_MAC_Q4_TX_FLOW_CTRL_PLT(
        ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT value) volatile
    {
        uint32_t curr = MAC_Q4_TX_FLOW_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MAC_Q4_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_Q4_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline bool get_MAC_Q4_TX_FLOW_CTRL_TFE() volatile
    {
        return MAC_Q4_TX_FLOW_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_Q4_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void set_MAC_Q4_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q4_TX_FLOW_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_Q4_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void clear_MAC_Q4_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q4_TX_FLOW_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_Q4_TX_FLOW_CTRL's TFE bit.
     *
     * Transmit Flow Control Enable
     */
    inline void toggle_MAC_Q4_TX_FLOW_CTRL_TFE() volatile
    {
        MAC_Q4_TX_FLOW_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_Q4_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline bool get_MAC_Q4_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        return MAC_Q4_TX_FLOW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_Q4_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void set_MAC_Q4_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q4_TX_FLOW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_Q4_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void clear_MAC_Q4_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q4_TX_FLOW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_Q4_TX_FLOW_CTRL's FCB_BPA bit.
     *
     * Flow Control Busy
     */
    inline void toggle_MAC_Q4_TX_FLOW_CTRL_FCB_BPA() volatile
    {
        MAC_Q4_TX_FLOW_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_Q4_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q4 Tx Flow Control
     */
    inline void get_MAC_Q4_TX_FLOW_CTRL(uint16_t &PT, bool &DZPQ,
                                        ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT &PLT,
                                        bool &TFE, bool &FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q4_TX_FLOW_CTRL;

        PT = (curr >> 16u) & 0b1111111111111111u;
        DZPQ = curr & (1u << 7u);
        PLT = ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT((curr >> 4u) & 0b111u);
        TFE = curr & (1u << 1u);
        FCB_BPA = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_Q4_TX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Q4 Tx Flow Control
     */
    inline void set_MAC_Q4_TX_FLOW_CTRL(uint16_t PT, bool DZPQ,
                                        ENET_QOS_MAC_Q4_TX_FLOW_CTRL_PLT PLT,
                                        bool TFE, bool FCB_BPA) volatile
    {
        uint32_t curr = MAC_Q4_TX_FLOW_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (PT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (DZPQ & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(PLT) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TFE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FCB_BPA & 0b1u) << 0u;

        MAC_Q4_TX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_RX_FLOW_CTRL's PFCE bit.
     *
     * Priority Based Flow Control Enable
     */
    inline bool get_MAC_RX_FLOW_CTRL_PFCE() volatile
    {
        return MAC_RX_FLOW_CTRL & (1u << 8u);
    }

    /**
     * Set MAC_RX_FLOW_CTRL's PFCE bit.
     *
     * Priority Based Flow Control Enable
     */
    inline void set_MAC_RX_FLOW_CTRL_PFCE() volatile
    {
        MAC_RX_FLOW_CTRL |= 1u << 8u;
    }

    /**
     * Clear MAC_RX_FLOW_CTRL's PFCE bit.
     *
     * Priority Based Flow Control Enable
     */
    inline void clear_MAC_RX_FLOW_CTRL_PFCE() volatile
    {
        MAC_RX_FLOW_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_RX_FLOW_CTRL's PFCE bit.
     *
     * Priority Based Flow Control Enable
     */
    inline void toggle_MAC_RX_FLOW_CTRL_PFCE() volatile
    {
        MAC_RX_FLOW_CTRL ^= 1u << 8u;
    }

    /**
     * Get MAC_RX_FLOW_CTRL's UP bit.
     *
     * Unicast Pause Packet Detect
     */
    inline bool get_MAC_RX_FLOW_CTRL_UP() volatile
    {
        return MAC_RX_FLOW_CTRL & (1u << 1u);
    }

    /**
     * Set MAC_RX_FLOW_CTRL's UP bit.
     *
     * Unicast Pause Packet Detect
     */
    inline void set_MAC_RX_FLOW_CTRL_UP() volatile
    {
        MAC_RX_FLOW_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAC_RX_FLOW_CTRL's UP bit.
     *
     * Unicast Pause Packet Detect
     */
    inline void clear_MAC_RX_FLOW_CTRL_UP() volatile
    {
        MAC_RX_FLOW_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_RX_FLOW_CTRL's UP bit.
     *
     * Unicast Pause Packet Detect
     */
    inline void toggle_MAC_RX_FLOW_CTRL_UP() volatile
    {
        MAC_RX_FLOW_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAC_RX_FLOW_CTRL's RFE bit.
     *
     * Receive Flow Control Enable
     */
    inline bool get_MAC_RX_FLOW_CTRL_RFE() volatile
    {
        return MAC_RX_FLOW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_RX_FLOW_CTRL's RFE bit.
     *
     * Receive Flow Control Enable
     */
    inline void set_MAC_RX_FLOW_CTRL_RFE() volatile
    {
        MAC_RX_FLOW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_RX_FLOW_CTRL's RFE bit.
     *
     * Receive Flow Control Enable
     */
    inline void clear_MAC_RX_FLOW_CTRL_RFE() volatile
    {
        MAC_RX_FLOW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_RX_FLOW_CTRL's RFE bit.
     *
     * Receive Flow Control Enable
     */
    inline void toggle_MAC_RX_FLOW_CTRL_RFE() volatile
    {
        MAC_RX_FLOW_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_RX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Rx Flow Control
     */
    inline void get_MAC_RX_FLOW_CTRL(bool &PFCE, bool &UP, bool &RFE) volatile
    {
        uint32_t curr = MAC_RX_FLOW_CTRL;

        PFCE = curr & (1u << 8u);
        UP = curr & (1u << 1u);
        RFE = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_RX_FLOW_CTRL's bit fields.
     *
     * (read-write) MAC Rx Flow Control
     */
    inline void set_MAC_RX_FLOW_CTRL(bool PFCE, bool UP, bool RFE) volatile
    {
        uint32_t curr = MAC_RX_FLOW_CTRL;

        curr &= ~(0b1u << 8u);
        curr |= (PFCE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (UP & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RFE & 0b1u) << 0u;

        MAC_RX_FLOW_CTRL = curr;
    }

    /**
     * Get MAC_RXQ_CTRL4's VFFQ field.
     *
     * VLAN Tag Filter Fail Packets Queue
     */
    inline uint8_t get_MAC_RXQ_CTRL4_VFFQ() volatile
    {
        return (MAC_RXQ_CTRL4 >> 17u) & 0b111u;
    }

    /**
     * Set MAC_RXQ_CTRL4's VFFQ field.
     *
     * VLAN Tag Filter Fail Packets Queue
     */
    inline void set_MAC_RXQ_CTRL4_VFFQ(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL4;

        curr &= ~(0b111u << 17u);
        curr |= (value & 0b111u) << 17u;

        MAC_RXQ_CTRL4 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL4's VFFQE bit.
     *
     * VLAN Tag Filter Fail Packets Queuing Enable
     */
    inline bool get_MAC_RXQ_CTRL4_VFFQE() volatile
    {
        return MAC_RXQ_CTRL4 & (1u << 16u);
    }

    /**
     * Set MAC_RXQ_CTRL4's VFFQE bit.
     *
     * VLAN Tag Filter Fail Packets Queuing Enable
     */
    inline void set_MAC_RXQ_CTRL4_VFFQE() volatile
    {
        MAC_RXQ_CTRL4 |= 1u << 16u;
    }

    /**
     * Clear MAC_RXQ_CTRL4's VFFQE bit.
     *
     * VLAN Tag Filter Fail Packets Queuing Enable
     */
    inline void clear_MAC_RXQ_CTRL4_VFFQE() volatile
    {
        MAC_RXQ_CTRL4 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_RXQ_CTRL4's VFFQE bit.
     *
     * VLAN Tag Filter Fail Packets Queuing Enable
     */
    inline void toggle_MAC_RXQ_CTRL4_VFFQE() volatile
    {
        MAC_RXQ_CTRL4 ^= 1u << 16u;
    }

    /**
     * Get MAC_RXQ_CTRL4's MFFQ field.
     *
     * Multicast Address Filter Fail Packets Queue.
     */
    inline uint8_t get_MAC_RXQ_CTRL4_MFFQ() volatile
    {
        return (MAC_RXQ_CTRL4 >> 9u) & 0b111u;
    }

    /**
     * Set MAC_RXQ_CTRL4's MFFQ field.
     *
     * Multicast Address Filter Fail Packets Queue.
     */
    inline void set_MAC_RXQ_CTRL4_MFFQ(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL4;

        curr &= ~(0b111u << 9u);
        curr |= (value & 0b111u) << 9u;

        MAC_RXQ_CTRL4 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL4's MFFQE bit.
     *
     * Multicast Address Filter Fail Packets Queuing Enable.
     */
    inline bool get_MAC_RXQ_CTRL4_MFFQE() volatile
    {
        return MAC_RXQ_CTRL4 & (1u << 8u);
    }

    /**
     * Set MAC_RXQ_CTRL4's MFFQE bit.
     *
     * Multicast Address Filter Fail Packets Queuing Enable.
     */
    inline void set_MAC_RXQ_CTRL4_MFFQE() volatile
    {
        MAC_RXQ_CTRL4 |= 1u << 8u;
    }

    /**
     * Clear MAC_RXQ_CTRL4's MFFQE bit.
     *
     * Multicast Address Filter Fail Packets Queuing Enable.
     */
    inline void clear_MAC_RXQ_CTRL4_MFFQE() volatile
    {
        MAC_RXQ_CTRL4 &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_RXQ_CTRL4's MFFQE bit.
     *
     * Multicast Address Filter Fail Packets Queuing Enable.
     */
    inline void toggle_MAC_RXQ_CTRL4_MFFQE() volatile
    {
        MAC_RXQ_CTRL4 ^= 1u << 8u;
    }

    /**
     * Get MAC_RXQ_CTRL4's UFFQ field.
     *
     * Unicast Address Filter Fail Packets Queue.
     */
    inline uint8_t get_MAC_RXQ_CTRL4_UFFQ() volatile
    {
        return (MAC_RXQ_CTRL4 >> 1u) & 0b111u;
    }

    /**
     * Set MAC_RXQ_CTRL4's UFFQ field.
     *
     * Unicast Address Filter Fail Packets Queue.
     */
    inline void set_MAC_RXQ_CTRL4_UFFQ(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL4;

        curr &= ~(0b111u << 1u);
        curr |= (value & 0b111u) << 1u;

        MAC_RXQ_CTRL4 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL4's UFFQE bit.
     *
     * Unicast Address Filter Fail Packets Queuing Enable.
     */
    inline bool get_MAC_RXQ_CTRL4_UFFQE() volatile
    {
        return MAC_RXQ_CTRL4 & (1u << 0u);
    }

    /**
     * Set MAC_RXQ_CTRL4's UFFQE bit.
     *
     * Unicast Address Filter Fail Packets Queuing Enable.
     */
    inline void set_MAC_RXQ_CTRL4_UFFQE() volatile
    {
        MAC_RXQ_CTRL4 |= 1u << 0u;
    }

    /**
     * Clear MAC_RXQ_CTRL4's UFFQE bit.
     *
     * Unicast Address Filter Fail Packets Queuing Enable.
     */
    inline void clear_MAC_RXQ_CTRL4_UFFQE() volatile
    {
        MAC_RXQ_CTRL4 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_RXQ_CTRL4's UFFQE bit.
     *
     * Unicast Address Filter Fail Packets Queuing Enable.
     */
    inline void toggle_MAC_RXQ_CTRL4_UFFQE() volatile
    {
        MAC_RXQ_CTRL4 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_RXQ_CTRL4's bit fields.
     *
     * (read-write) Receive Queue Control 4
     */
    inline void get_MAC_RXQ_CTRL4(uint8_t &VFFQ, bool &VFFQE, uint8_t &MFFQ,
                                  bool &MFFQE, uint8_t &UFFQ,
                                  bool &UFFQE) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL4;

        VFFQ = (curr >> 17u) & 0b111u;
        VFFQE = curr & (1u << 16u);
        MFFQ = (curr >> 9u) & 0b111u;
        MFFQE = curr & (1u << 8u);
        UFFQ = (curr >> 1u) & 0b111u;
        UFFQE = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_RXQ_CTRL4's bit fields.
     *
     * (read-write) Receive Queue Control 4
     */
    inline void set_MAC_RXQ_CTRL4(uint8_t VFFQ, bool VFFQE, uint8_t MFFQ,
                                  bool MFFQE, uint8_t UFFQ,
                                  bool UFFQE) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL4;

        curr &= ~(0b111u << 17u);
        curr |= (VFFQ & 0b111u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (VFFQE & 0b1u) << 16u;
        curr &= ~(0b111u << 9u);
        curr |= (MFFQ & 0b111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (MFFQE & 0b1u) << 8u;
        curr &= ~(0b111u << 1u);
        curr |= (UFFQ & 0b111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (UFFQE & 0b1u) << 0u;

        MAC_RXQ_CTRL4 = curr;
    }

    /**
     * Get MAC_TXQ_PRTY_MAP0's PSTQ3 field.
     *
     * Priorities Selected in Transmit Queue 3 This bit is similar to the PSTQ0
     * bit.
     */
    inline uint8_t get_MAC_TXQ_PRTY_MAP0_PSTQ3() volatile
    {
        return (MAC_TXQ_PRTY_MAP0 >> 24u) & 0b11111111u;
    }

    /**
     * Set MAC_TXQ_PRTY_MAP0's PSTQ3 field.
     *
     * Priorities Selected in Transmit Queue 3 This bit is similar to the PSTQ0
     * bit.
     */
    inline void set_MAC_TXQ_PRTY_MAP0_PSTQ3(uint8_t value) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP0;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        MAC_TXQ_PRTY_MAP0 = curr;
    }

    /**
     * Get MAC_TXQ_PRTY_MAP0's PSTQ2 field.
     *
     * Priorities Selected in Transmit Queue 2 This bit is similar to the PSTQ0
     * bit.
     */
    inline uint8_t get_MAC_TXQ_PRTY_MAP0_PSTQ2() volatile
    {
        return (MAC_TXQ_PRTY_MAP0 >> 16u) & 0b11111111u;
    }

    /**
     * Set MAC_TXQ_PRTY_MAP0's PSTQ2 field.
     *
     * Priorities Selected in Transmit Queue 2 This bit is similar to the PSTQ0
     * bit.
     */
    inline void set_MAC_TXQ_PRTY_MAP0_PSTQ2(uint8_t value) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MAC_TXQ_PRTY_MAP0 = curr;
    }

    /**
     * Get MAC_TXQ_PRTY_MAP0's PSTQ1 field.
     *
     * Priorities Selected in Transmit Queue 1 This bit is similar to the PSTQ0
     * bit.
     */
    inline uint8_t get_MAC_TXQ_PRTY_MAP0_PSTQ1() volatile
    {
        return (MAC_TXQ_PRTY_MAP0 >> 8u) & 0b11111111u;
    }

    /**
     * Set MAC_TXQ_PRTY_MAP0's PSTQ1 field.
     *
     * Priorities Selected in Transmit Queue 1 This bit is similar to the PSTQ0
     * bit.
     */
    inline void set_MAC_TXQ_PRTY_MAP0_PSTQ1(uint8_t value) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP0;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MAC_TXQ_PRTY_MAP0 = curr;
    }

    /**
     * Get MAC_TXQ_PRTY_MAP0's PSTQ0 field.
     *
     * Priorities Selected in Transmit Queue 0
     */
    inline uint8_t get_MAC_TXQ_PRTY_MAP0_PSTQ0() volatile
    {
        return (MAC_TXQ_PRTY_MAP0 >> 0u) & 0b11111111u;
    }

    /**
     * Set MAC_TXQ_PRTY_MAP0's PSTQ0 field.
     *
     * Priorities Selected in Transmit Queue 0
     */
    inline void set_MAC_TXQ_PRTY_MAP0_PSTQ0(uint8_t value) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP0;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MAC_TXQ_PRTY_MAP0 = curr;
    }

    /**
     * Get all of MAC_TXQ_PRTY_MAP0's bit fields.
     *
     * (read-write) Transmit Queue Priority Mapping 0
     */
    inline void get_MAC_TXQ_PRTY_MAP0(uint8_t &PSTQ3, uint8_t &PSTQ2,
                                      uint8_t &PSTQ1, uint8_t &PSTQ0) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP0;

        PSTQ3 = (curr >> 24u) & 0b11111111u;
        PSTQ2 = (curr >> 16u) & 0b11111111u;
        PSTQ1 = (curr >> 8u) & 0b11111111u;
        PSTQ0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of MAC_TXQ_PRTY_MAP0's bit fields.
     *
     * (read-write) Transmit Queue Priority Mapping 0
     */
    inline void set_MAC_TXQ_PRTY_MAP0(uint8_t PSTQ3, uint8_t PSTQ2,
                                      uint8_t PSTQ1, uint8_t PSTQ0) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP0;

        curr &= ~(0b11111111u << 24u);
        curr |= (PSTQ3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PSTQ2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PSTQ1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PSTQ0 & 0b11111111u) << 0u;

        MAC_TXQ_PRTY_MAP0 = curr;
    }

    /**
     * Get MAC_TXQ_PRTY_MAP1's PSTQ4 field.
     *
     * Priorities Selected in Transmit Queue 4
     */
    inline uint8_t get_MAC_TXQ_PRTY_MAP1_PSTQ4() volatile
    {
        return (MAC_TXQ_PRTY_MAP1 >> 0u) & 0b11111111u;
    }

    /**
     * Set MAC_TXQ_PRTY_MAP1's PSTQ4 field.
     *
     * Priorities Selected in Transmit Queue 4
     */
    inline void set_MAC_TXQ_PRTY_MAP1_PSTQ4(uint8_t value) volatile
    {
        uint32_t curr = MAC_TXQ_PRTY_MAP1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MAC_TXQ_PRTY_MAP1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL0's RXQ4EN field.
     *
     * Receive Queue 4 Enable This field is similar to the RXQ0EN field.
     */
    inline ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN get_MAC_RXQ_CTRL0_RXQ4EN() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN((MAC_RXQ_CTRL0 >> 8u) & 0b11u);
    }

    /**
     * Set MAC_RXQ_CTRL0's RXQ4EN field.
     *
     * Receive Queue 4 Enable This field is similar to the RXQ0EN field.
     */
    inline void set_MAC_RXQ_CTRL0_RXQ4EN(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        MAC_RXQ_CTRL0 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL0's RXQ3EN field.
     *
     * Receive Queue 3 Enable This field is similar to the RXQ0EN field.
     */
    inline ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN get_MAC_RXQ_CTRL0_RXQ3EN() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN((MAC_RXQ_CTRL0 >> 6u) & 0b11u);
    }

    /**
     * Set MAC_RXQ_CTRL0's RXQ3EN field.
     *
     * Receive Queue 3 Enable This field is similar to the RXQ0EN field.
     */
    inline void set_MAC_RXQ_CTRL0_RXQ3EN(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        MAC_RXQ_CTRL0 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL0's RXQ2EN field.
     *
     * Receive Queue 2 Enable This field is similar to the RXQ0EN field.
     */
    inline ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN get_MAC_RXQ_CTRL0_RXQ2EN() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN((MAC_RXQ_CTRL0 >> 4u) & 0b11u);
    }

    /**
     * Set MAC_RXQ_CTRL0's RXQ2EN field.
     *
     * Receive Queue 2 Enable This field is similar to the RXQ0EN field.
     */
    inline void set_MAC_RXQ_CTRL0_RXQ2EN(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        MAC_RXQ_CTRL0 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL0's RXQ1EN field.
     *
     * Receive Queue 1 Enable This field is similar to the RXQ0EN field.
     */
    inline ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN get_MAC_RXQ_CTRL0_RXQ1EN() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN((MAC_RXQ_CTRL0 >> 2u) & 0b11u);
    }

    /**
     * Set MAC_RXQ_CTRL0's RXQ1EN field.
     *
     * Receive Queue 1 Enable This field is similar to the RXQ0EN field.
     */
    inline void set_MAC_RXQ_CTRL0_RXQ1EN(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MAC_RXQ_CTRL0 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL0's RXQ0EN field.
     *
     * Receive Queue 0 Enable This field indicates whether Rx Queue 0 is
     * enabled for AV or DCB.
     */
    inline ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN get_MAC_RXQ_CTRL0_RXQ0EN() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN((MAC_RXQ_CTRL0 >> 0u) & 0b11u);
    }

    /**
     * Set MAC_RXQ_CTRL0's RXQ0EN field.
     *
     * Receive Queue 0 Enable This field indicates whether Rx Queue 0 is
     * enabled for AV or DCB.
     */
    inline void set_MAC_RXQ_CTRL0_RXQ0EN(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        MAC_RXQ_CTRL0 = curr;
    }

    /**
     * Get all of MAC_RXQ_CTRL0's bit fields.
     *
     * (read-write) Receive Queue Control 0
     */
    inline void get_MAC_RXQ_CTRL0(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN &RXQ4EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN &RXQ3EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN &RXQ2EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN &RXQ1EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN &RXQ0EN) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        RXQ4EN = ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN((curr >> 8u) & 0b11u);
        RXQ3EN = ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN((curr >> 6u) & 0b11u);
        RXQ2EN = ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN((curr >> 4u) & 0b11u);
        RXQ1EN = ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN((curr >> 2u) & 0b11u);
        RXQ0EN = ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of MAC_RXQ_CTRL0's bit fields.
     *
     * (read-write) Receive Queue Control 0
     */
    inline void set_MAC_RXQ_CTRL0(
        ENET_QOS_MAC_RXQ_CTRL0_RXQ4EN RXQ4EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ3EN RXQ3EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ2EN RXQ2EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ1EN RXQ1EN,
        ENET_QOS_MAC_RXQ_CTRL0_RXQ0EN RXQ0EN) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL0;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(RXQ4EN) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(RXQ3EN) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(RXQ2EN) & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(RXQ1EN) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RXQ0EN) & 0b11u) << 0u;

        MAC_RXQ_CTRL0 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's FPRQ field.
     *
     * Frame Preemption Residue Queue
     */
    inline uint8_t get_MAC_RXQ_CTRL1_FPRQ() volatile
    {
        return (MAC_RXQ_CTRL1 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_RXQ_CTRL1's FPRQ field.
     *
     * Frame Preemption Residue Queue
     */
    inline void set_MAC_RXQ_CTRL1_FPRQ(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's TPQC field.
     *
     * Tagged PTP over Ethernet Packets Queuing Control.
     */
    inline uint8_t get_MAC_RXQ_CTRL1_TPQC() volatile
    {
        return (MAC_RXQ_CTRL1 >> 22u) & 0b11u;
    }

    /**
     * Set MAC_RXQ_CTRL1's TPQC field.
     *
     * Tagged PTP over Ethernet Packets Queuing Control.
     */
    inline void set_MAC_RXQ_CTRL1_TPQC(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's TACPQE bit.
     *
     * Tagged AV Control Packets Queuing Enable.
     */
    inline bool get_MAC_RXQ_CTRL1_TACPQE() volatile
    {
        return MAC_RXQ_CTRL1 & (1u << 21u);
    }

    /**
     * Set MAC_RXQ_CTRL1's TACPQE bit.
     *
     * Tagged AV Control Packets Queuing Enable.
     */
    inline void set_MAC_RXQ_CTRL1_TACPQE() volatile
    {
        MAC_RXQ_CTRL1 |= 1u << 21u;
    }

    /**
     * Clear MAC_RXQ_CTRL1's TACPQE bit.
     *
     * Tagged AV Control Packets Queuing Enable.
     */
    inline void clear_MAC_RXQ_CTRL1_TACPQE() volatile
    {
        MAC_RXQ_CTRL1 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_RXQ_CTRL1's TACPQE bit.
     *
     * Tagged AV Control Packets Queuing Enable.
     */
    inline void toggle_MAC_RXQ_CTRL1_TACPQE() volatile
    {
        MAC_RXQ_CTRL1 ^= 1u << 21u;
    }

    /**
     * Get MAC_RXQ_CTRL1's MCBCQEN bit.
     *
     * Multicast and Broadcast Queue Enable This bit specifies that Multicast
     * or Broadcast packets routing to the Rx Queue is enabled and the
     * Multicast or Broadcast packets must be routed to Rx Queue specified in
     * MCBCQ field.
     */
    inline bool get_MAC_RXQ_CTRL1_MCBCQEN() volatile
    {
        return MAC_RXQ_CTRL1 & (1u << 20u);
    }

    /**
     * Set MAC_RXQ_CTRL1's MCBCQEN bit.
     *
     * Multicast and Broadcast Queue Enable This bit specifies that Multicast
     * or Broadcast packets routing to the Rx Queue is enabled and the
     * Multicast or Broadcast packets must be routed to Rx Queue specified in
     * MCBCQ field.
     */
    inline void set_MAC_RXQ_CTRL1_MCBCQEN() volatile
    {
        MAC_RXQ_CTRL1 |= 1u << 20u;
    }

    /**
     * Clear MAC_RXQ_CTRL1's MCBCQEN bit.
     *
     * Multicast and Broadcast Queue Enable This bit specifies that Multicast
     * or Broadcast packets routing to the Rx Queue is enabled and the
     * Multicast or Broadcast packets must be routed to Rx Queue specified in
     * MCBCQ field.
     */
    inline void clear_MAC_RXQ_CTRL1_MCBCQEN() volatile
    {
        MAC_RXQ_CTRL1 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_RXQ_CTRL1's MCBCQEN bit.
     *
     * Multicast and Broadcast Queue Enable This bit specifies that Multicast
     * or Broadcast packets routing to the Rx Queue is enabled and the
     * Multicast or Broadcast packets must be routed to Rx Queue specified in
     * MCBCQ field.
     */
    inline void toggle_MAC_RXQ_CTRL1_MCBCQEN() volatile
    {
        MAC_RXQ_CTRL1 ^= 1u << 20u;
    }

    /**
     * Get MAC_RXQ_CTRL1's MCBCQ field.
     *
     * Multicast and Broadcast Queue
     */
    inline ENET_QOS_MAC_RXQ_CTRL1_MCBCQ get_MAC_RXQ_CTRL1_MCBCQ() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL1_MCBCQ((MAC_RXQ_CTRL1 >> 16u) & 0b111u);
    }

    /**
     * Set MAC_RXQ_CTRL1's MCBCQ field.
     *
     * Multicast and Broadcast Queue
     */
    inline void set_MAC_RXQ_CTRL1_MCBCQ(
        ENET_QOS_MAC_RXQ_CTRL1_MCBCQ value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's UPQ field.
     *
     * Untagged Packet Queue
     */
    inline ENET_QOS_MAC_RXQ_CTRL1_UPQ get_MAC_RXQ_CTRL1_UPQ() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL1_UPQ((MAC_RXQ_CTRL1 >> 12u) & 0b111u);
    }

    /**
     * Set MAC_RXQ_CTRL1's UPQ field.
     *
     * Untagged Packet Queue
     */
    inline void set_MAC_RXQ_CTRL1_UPQ(
        ENET_QOS_MAC_RXQ_CTRL1_UPQ value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's DCBCPQ field.
     *
     * DCB Control Packets Queue
     */
    inline ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ get_MAC_RXQ_CTRL1_DCBCPQ() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ((MAC_RXQ_CTRL1 >> 8u) & 0b111u);
    }

    /**
     * Set MAC_RXQ_CTRL1's DCBCPQ field.
     *
     * DCB Control Packets Queue
     */
    inline void set_MAC_RXQ_CTRL1_DCBCPQ(
        ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's PTPQ field.
     *
     * PTP Packets Queue
     */
    inline ENET_QOS_MAC_RXQ_CTRL1_PTPQ get_MAC_RXQ_CTRL1_PTPQ() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL1_PTPQ((MAC_RXQ_CTRL1 >> 4u) & 0b111u);
    }

    /**
     * Set MAC_RXQ_CTRL1's PTPQ field.
     *
     * PTP Packets Queue
     */
    inline void set_MAC_RXQ_CTRL1_PTPQ(
        ENET_QOS_MAC_RXQ_CTRL1_PTPQ value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL1's AVCPQ field.
     *
     * AV Untagged Control Packets Queue
     */
    inline ENET_QOS_MAC_RXQ_CTRL1_AVCPQ get_MAC_RXQ_CTRL1_AVCPQ() volatile
    {
        return ENET_QOS_MAC_RXQ_CTRL1_AVCPQ((MAC_RXQ_CTRL1 >> 0u) & 0b111u);
    }

    /**
     * Set MAC_RXQ_CTRL1's AVCPQ field.
     *
     * AV Untagged Control Packets Queue
     */
    inline void set_MAC_RXQ_CTRL1_AVCPQ(
        ENET_QOS_MAC_RXQ_CTRL1_AVCPQ value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get all of MAC_RXQ_CTRL1's bit fields.
     *
     * (read-write) Receive Queue Control 1
     */
    inline void get_MAC_RXQ_CTRL1(uint8_t &FPRQ, uint8_t &TPQC, bool &TACPQE,
                                  bool &MCBCQEN,
                                  ENET_QOS_MAC_RXQ_CTRL1_MCBCQ &MCBCQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_UPQ &UPQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ &DCBCPQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_PTPQ &PTPQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_AVCPQ &AVCPQ) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        FPRQ = (curr >> 24u) & 0b111u;
        TPQC = (curr >> 22u) & 0b11u;
        TACPQE = curr & (1u << 21u);
        MCBCQEN = curr & (1u << 20u);
        MCBCQ = ENET_QOS_MAC_RXQ_CTRL1_MCBCQ((curr >> 16u) & 0b111u);
        UPQ = ENET_QOS_MAC_RXQ_CTRL1_UPQ((curr >> 12u) & 0b111u);
        DCBCPQ = ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ((curr >> 8u) & 0b111u);
        PTPQ = ENET_QOS_MAC_RXQ_CTRL1_PTPQ((curr >> 4u) & 0b111u);
        AVCPQ = ENET_QOS_MAC_RXQ_CTRL1_AVCPQ((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of MAC_RXQ_CTRL1's bit fields.
     *
     * (read-write) Receive Queue Control 1
     */
    inline void set_MAC_RXQ_CTRL1(uint8_t FPRQ, uint8_t TPQC, bool TACPQE,
                                  bool MCBCQEN,
                                  ENET_QOS_MAC_RXQ_CTRL1_MCBCQ MCBCQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_UPQ UPQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_DCBCPQ DCBCPQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_PTPQ PTPQ,
                                  ENET_QOS_MAC_RXQ_CTRL1_AVCPQ AVCPQ) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL1;

        curr &= ~(0b111u << 24u);
        curr |= (FPRQ & 0b111u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (TPQC & 0b11u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (TACPQE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (MCBCQEN & 0b1u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(MCBCQ) & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(UPQ) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(DCBCPQ) & 0b111u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(PTPQ) & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(AVCPQ) & 0b111u) << 0u;

        MAC_RXQ_CTRL1 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL2's PSRQ3 field.
     *
     * Priorities Selected in the Receive Queue 3
     */
    inline uint8_t get_MAC_RXQ_CTRL2_PSRQ3() volatile
    {
        return (MAC_RXQ_CTRL2 >> 24u) & 0b11111111u;
    }

    /**
     * Set MAC_RXQ_CTRL2's PSRQ3 field.
     *
     * Priorities Selected in the Receive Queue 3
     */
    inline void set_MAC_RXQ_CTRL2_PSRQ3(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL2;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        MAC_RXQ_CTRL2 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL2's PSRQ2 field.
     *
     * Priorities Selected in the Receive Queue 2
     */
    inline uint8_t get_MAC_RXQ_CTRL2_PSRQ2() volatile
    {
        return (MAC_RXQ_CTRL2 >> 16u) & 0b11111111u;
    }

    /**
     * Set MAC_RXQ_CTRL2's PSRQ2 field.
     *
     * Priorities Selected in the Receive Queue 2
     */
    inline void set_MAC_RXQ_CTRL2_PSRQ2(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL2;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MAC_RXQ_CTRL2 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL2's PSRQ1 field.
     *
     * Priorities Selected in the Receive Queue 1
     */
    inline uint8_t get_MAC_RXQ_CTRL2_PSRQ1() volatile
    {
        return (MAC_RXQ_CTRL2 >> 8u) & 0b11111111u;
    }

    /**
     * Set MAC_RXQ_CTRL2's PSRQ1 field.
     *
     * Priorities Selected in the Receive Queue 1
     */
    inline void set_MAC_RXQ_CTRL2_PSRQ1(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL2;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MAC_RXQ_CTRL2 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL2's PSRQ0 field.
     *
     * Priorities Selected in the Receive Queue 0
     */
    inline uint8_t get_MAC_RXQ_CTRL2_PSRQ0() volatile
    {
        return (MAC_RXQ_CTRL2 >> 0u) & 0b11111111u;
    }

    /**
     * Set MAC_RXQ_CTRL2's PSRQ0 field.
     *
     * Priorities Selected in the Receive Queue 0
     */
    inline void set_MAC_RXQ_CTRL2_PSRQ0(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL2;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MAC_RXQ_CTRL2 = curr;
    }

    /**
     * Get all of MAC_RXQ_CTRL2's bit fields.
     *
     * (read-write) Receive Queue Control 2
     */
    inline void get_MAC_RXQ_CTRL2(uint8_t &PSRQ3, uint8_t &PSRQ2,
                                  uint8_t &PSRQ1, uint8_t &PSRQ0) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL2;

        PSRQ3 = (curr >> 24u) & 0b11111111u;
        PSRQ2 = (curr >> 16u) & 0b11111111u;
        PSRQ1 = (curr >> 8u) & 0b11111111u;
        PSRQ0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of MAC_RXQ_CTRL2's bit fields.
     *
     * (read-write) Receive Queue Control 2
     */
    inline void set_MAC_RXQ_CTRL2(uint8_t PSRQ3, uint8_t PSRQ2, uint8_t PSRQ1,
                                  uint8_t PSRQ0) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL2;

        curr &= ~(0b11111111u << 24u);
        curr |= (PSRQ3 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PSRQ2 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PSRQ1 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PSRQ0 & 0b11111111u) << 0u;

        MAC_RXQ_CTRL2 = curr;
    }

    /**
     * Get MAC_RXQ_CTRL3's PSRQ4 field.
     *
     * Priorities Selected in the Receive Queue 4
     */
    inline uint8_t get_MAC_RXQ_CTRL3_PSRQ4() volatile
    {
        return (MAC_RXQ_CTRL3 >> 0u) & 0b11111111u;
    }

    /**
     * Set MAC_RXQ_CTRL3's PSRQ4 field.
     *
     * Priorities Selected in the Receive Queue 4
     */
    inline void set_MAC_RXQ_CTRL3_PSRQ4(uint8_t value) volatile
    {
        uint32_t curr = MAC_RXQ_CTRL3;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MAC_RXQ_CTRL3 = curr;
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MFRIS bit.
     *
     * MMC FPE Receive Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MFRIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 20u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MFTIS bit.
     *
     * MMC FPE Transmit Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MFTIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 19u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MDIOIS bit.
     *
     * MDIO Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MDIOIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 18u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's FPEIS bit.
     *
     * Frame Preemption Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_FPEIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 17u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's RXSTSIS bit.
     *
     * Receive Status Interrupt
     */
    inline bool get_MAC_INTERRUPT_STATUS_RXSTSIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 14u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's TXSTSIS bit.
     *
     * Transmit Status Interrupt
     */
    inline bool get_MAC_INTERRUPT_STATUS_TXSTSIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 13u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's TSIS bit.
     *
     * Timestamp Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_TSIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 12u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MMCRXIPIS bit.
     *
     * MMC Receive Checksum Offload Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MMCRXIPIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 11u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MMCTXIS bit.
     *
     * MMC Transmit Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MMCTXIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 10u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MMCRXIS bit.
     *
     * MMC Receive Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MMCRXIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 9u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's MMCIS bit.
     *
     * MMC Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_MMCIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 8u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's LPIIS bit.
     *
     * LPI Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_LPIIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 5u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's PMTIS bit.
     *
     * PMT Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_PMTIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 4u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's PHYIS bit.
     *
     * PHY Interrupt
     */
    inline bool get_MAC_INTERRUPT_STATUS_PHYIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 3u);
    }

    /**
     * Get MAC_INTERRUPT_STATUS's RGSMIIIS bit.
     *
     * RGMII or SMII Interrupt Status
     */
    inline bool get_MAC_INTERRUPT_STATUS_RGSMIIIS() volatile
    {
        return MAC_INTERRUPT_STATUS & (1u << 0u);
    }

    /**
     * Get all of MAC_INTERRUPT_STATUS's bit fields.
     *
     * (read-write) Interrupt Status
     */
    inline void get_MAC_INTERRUPT_STATUS(bool &MFRIS, bool &MFTIS,
                                         bool &MDIOIS, bool &FPEIS,
                                         bool &RXSTSIS, bool &TXSTSIS,
                                         bool &TSIS, bool &MMCRXIPIS,
                                         bool &MMCTXIS, bool &MMCRXIS,
                                         bool &MMCIS, bool &LPIIS, bool &PMTIS,
                                         bool &PHYIS, bool &RGSMIIIS) volatile
    {
        uint32_t curr = MAC_INTERRUPT_STATUS;

        MFRIS = curr & (1u << 20u);
        MFTIS = curr & (1u << 19u);
        MDIOIS = curr & (1u << 18u);
        FPEIS = curr & (1u << 17u);
        RXSTSIS = curr & (1u << 14u);
        TXSTSIS = curr & (1u << 13u);
        TSIS = curr & (1u << 12u);
        MMCRXIPIS = curr & (1u << 11u);
        MMCTXIS = curr & (1u << 10u);
        MMCRXIS = curr & (1u << 9u);
        MMCIS = curr & (1u << 8u);
        LPIIS = curr & (1u << 5u);
        PMTIS = curr & (1u << 4u);
        PHYIS = curr & (1u << 3u);
        RGSMIIIS = curr & (1u << 0u);
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's MDIOIE bit.
     *
     * MDIO Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt when MDIOIS field is set in the MAC_INTERRUPT_STATUS
     * register.
     */
    inline bool get_MAC_INTERRUPT_ENABLE_MDIOIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 18u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's MDIOIE bit.
     *
     * MDIO Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt when MDIOIS field is set in the MAC_INTERRUPT_STATUS
     * register.
     */
    inline void set_MAC_INTERRUPT_ENABLE_MDIOIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 18u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's MDIOIE bit.
     *
     * MDIO Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt when MDIOIS field is set in the MAC_INTERRUPT_STATUS
     * register.
     */
    inline void clear_MAC_INTERRUPT_ENABLE_MDIOIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's MDIOIE bit.
     *
     * MDIO Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt when MDIOIS field is set in the MAC_INTERRUPT_STATUS
     * register.
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_MDIOIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 18u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's FPEIE bit.
     *
     * Frame Preemption Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt when FPEIS field is set in the
     * MAC_INTERRUPT_STATUS.
     */
    inline bool get_MAC_INTERRUPT_ENABLE_FPEIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 17u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's FPEIE bit.
     *
     * Frame Preemption Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt when FPEIS field is set in the
     * MAC_INTERRUPT_STATUS.
     */
    inline void set_MAC_INTERRUPT_ENABLE_FPEIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 17u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's FPEIE bit.
     *
     * Frame Preemption Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt when FPEIS field is set in the
     * MAC_INTERRUPT_STATUS.
     */
    inline void clear_MAC_INTERRUPT_ENABLE_FPEIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's FPEIE bit.
     *
     * Frame Preemption Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt when FPEIS field is set in the
     * MAC_INTERRUPT_STATUS.
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_FPEIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 17u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's RXSTSIE bit.
     *
     * Receive Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[RXSTSIS].
     */
    inline bool get_MAC_INTERRUPT_ENABLE_RXSTSIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 14u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's RXSTSIE bit.
     *
     * Receive Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[RXSTSIS].
     */
    inline void set_MAC_INTERRUPT_ENABLE_RXSTSIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 14u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's RXSTSIE bit.
     *
     * Receive Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[RXSTSIS].
     */
    inline void clear_MAC_INTERRUPT_ENABLE_RXSTSIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 14u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's RXSTSIE bit.
     *
     * Receive Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[RXSTSIS].
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_RXSTSIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 14u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's TXSTSIE bit.
     *
     * Transmit Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TXSTSIS].
     */
    inline bool get_MAC_INTERRUPT_ENABLE_TXSTSIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 13u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's TXSTSIE bit.
     *
     * Transmit Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TXSTSIS].
     */
    inline void set_MAC_INTERRUPT_ENABLE_TXSTSIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 13u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's TXSTSIE bit.
     *
     * Transmit Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TXSTSIS].
     */
    inline void clear_MAC_INTERRUPT_ENABLE_TXSTSIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 13u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's TXSTSIE bit.
     *
     * Transmit Status Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TXSTSIS].
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_TXSTSIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 13u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's TSIE bit.
     *
     * Timestamp Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TSIS].
     */
    inline bool get_MAC_INTERRUPT_ENABLE_TSIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 12u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's TSIE bit.
     *
     * Timestamp Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TSIS].
     */
    inline void set_MAC_INTERRUPT_ENABLE_TSIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 12u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's TSIE bit.
     *
     * Timestamp Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TSIS].
     */
    inline void clear_MAC_INTERRUPT_ENABLE_TSIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 12u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's TSIE bit.
     *
     * Timestamp Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[TSIS].
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_TSIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 12u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's LPIIE bit.
     *
     * LPI Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[LPIIS].
     */
    inline bool get_MAC_INTERRUPT_ENABLE_LPIIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 5u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's LPIIE bit.
     *
     * LPI Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[LPIIS].
     */
    inline void set_MAC_INTERRUPT_ENABLE_LPIIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 5u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's LPIIE bit.
     *
     * LPI Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[LPIIS].
     */
    inline void clear_MAC_INTERRUPT_ENABLE_LPIIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's LPIIE bit.
     *
     * LPI Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[LPIIS].
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_LPIIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 5u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's PMTIE bit.
     *
     * PMT Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PMTIS].
     */
    inline bool get_MAC_INTERRUPT_ENABLE_PMTIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 4u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's PMTIE bit.
     *
     * PMT Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PMTIS].
     */
    inline void set_MAC_INTERRUPT_ENABLE_PMTIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 4u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's PMTIE bit.
     *
     * PMT Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PMTIS].
     */
    inline void clear_MAC_INTERRUPT_ENABLE_PMTIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's PMTIE bit.
     *
     * PMT Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PMTIS].
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_PMTIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 4u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's PHYIE bit.
     *
     * PHY Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PHYIS].
     */
    inline bool get_MAC_INTERRUPT_ENABLE_PHYIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 3u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's PHYIE bit.
     *
     * PHY Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PHYIS].
     */
    inline void set_MAC_INTERRUPT_ENABLE_PHYIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 3u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's PHYIE bit.
     *
     * PHY Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PHYIS].
     */
    inline void clear_MAC_INTERRUPT_ENABLE_PHYIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's PHYIE bit.
     *
     * PHY Interrupt Enable When this bit is set, it enables the assertion of
     * the interrupt signal because of the setting of
     * MAC_INTERRUPT_STATUS[PHYIS].
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_PHYIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 3u;
    }

    /**
     * Get MAC_INTERRUPT_ENABLE's RGSMIIIE bit.
     *
     * RGMII or SMII Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of RGSMIIIS bit
     * in MAC_INTERRUPT_STATUS register.
     */
    inline bool get_MAC_INTERRUPT_ENABLE_RGSMIIIE() volatile
    {
        return MAC_INTERRUPT_ENABLE & (1u << 0u);
    }

    /**
     * Set MAC_INTERRUPT_ENABLE's RGSMIIIE bit.
     *
     * RGMII or SMII Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of RGSMIIIS bit
     * in MAC_INTERRUPT_STATUS register.
     */
    inline void set_MAC_INTERRUPT_ENABLE_RGSMIIIE() volatile
    {
        MAC_INTERRUPT_ENABLE |= 1u << 0u;
    }

    /**
     * Clear MAC_INTERRUPT_ENABLE's RGSMIIIE bit.
     *
     * RGMII or SMII Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of RGSMIIIS bit
     * in MAC_INTERRUPT_STATUS register.
     */
    inline void clear_MAC_INTERRUPT_ENABLE_RGSMIIIE() volatile
    {
        MAC_INTERRUPT_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_INTERRUPT_ENABLE's RGSMIIIE bit.
     *
     * RGMII or SMII Interrupt Enable When this bit is set, it enables the
     * assertion of the interrupt signal because of the setting of RGSMIIIS bit
     * in MAC_INTERRUPT_STATUS register.
     */
    inline void toggle_MAC_INTERRUPT_ENABLE_RGSMIIIE() volatile
    {
        MAC_INTERRUPT_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of MAC_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void get_MAC_INTERRUPT_ENABLE(bool &MDIOIE, bool &FPEIE,
                                         bool &RXSTSIE, bool &TXSTSIE,
                                         bool &TSIE, bool &LPIIE, bool &PMTIE,
                                         bool &PHYIE, bool &RGSMIIIE) volatile
    {
        uint32_t curr = MAC_INTERRUPT_ENABLE;

        MDIOIE = curr & (1u << 18u);
        FPEIE = curr & (1u << 17u);
        RXSTSIE = curr & (1u << 14u);
        TXSTSIE = curr & (1u << 13u);
        TSIE = curr & (1u << 12u);
        LPIIE = curr & (1u << 5u);
        PMTIE = curr & (1u << 4u);
        PHYIE = curr & (1u << 3u);
        RGSMIIIE = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void set_MAC_INTERRUPT_ENABLE(bool MDIOIE, bool FPEIE, bool RXSTSIE,
                                         bool TXSTSIE, bool TSIE, bool LPIIE,
                                         bool PMTIE, bool PHYIE,
                                         bool RGSMIIIE) volatile
    {
        uint32_t curr = MAC_INTERRUPT_ENABLE;

        curr &= ~(0b1u << 18u);
        curr |= (MDIOIE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (FPEIE & 0b1u) << 17u;
        curr &= ~(0b1u << 14u);
        curr |= (RXSTSIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TXSTSIE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TSIE & 0b1u) << 12u;
        curr &= ~(0b1u << 5u);
        curr |= (LPIIE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (PMTIE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PHYIE & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (RGSMIIIE & 0b1u) << 0u;

        MAC_INTERRUPT_ENABLE = curr;
    }

    /**
     * Get MAC_RX_TX_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is set when a packet with length
     * greater than 2,048 bytes is received (10, 240 bytes when Jumbo Packet
     * mode is enabled) and the WD bit is reset in the MAC_CONFIGURATION
     * register.
     */
    inline bool get_MAC_RX_TX_STATUS_RWT() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 8u);
    }

    /**
     * Get MAC_RX_TX_STATUS's EXCOL bit.
     *
     * Excessive Collisions When the DTXSTS bit is set in the
     * MAC_OPERATION_MODE register, this bit indicates that the transmission
     * aborted after 16 successive collisions while attempting to transmit the
     * current packet.
     */
    inline bool get_MAC_RX_TX_STATUS_EXCOL() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 5u);
    }

    /**
     * Get MAC_RX_TX_STATUS's LCOL bit.
     *
     * Late Collision When the DTXSTS bit is set in the MAC_OPERATION_MODE
     * register, this bit indicates that the packet transmission aborted
     * because a collision occurred after the collision window (64 bytes
     * including Preamble in MII mode; 512 bytes including Preamble and Carrier
     * Extension in GMII mode).
     */
    inline bool get_MAC_RX_TX_STATUS_LCOL() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 4u);
    }

    /**
     * Get MAC_RX_TX_STATUS's EXDEF bit.
     *
     * Excessive Deferral When the DTXSTS bit is set in the MAC_OPERATION_MODE
     * register and the DC bit is set in the MAC_CONFIGURATION register, this
     * bit indicates that the transmission ended because of excessive deferral
     * of over 24,288 bit times (155,680 in 1000/2500 Mbps mode or when Jumbo
     * packet is enabled).
     */
    inline bool get_MAC_RX_TX_STATUS_EXDEF() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 3u);
    }

    /**
     * Get MAC_RX_TX_STATUS's LCARR bit.
     *
     * Loss of Carrier When the DTXSTS bit is set in the MAC_OPERATION_MODE
     * register, this bit indicates that the loss of carrier occurred during
     * packet transmission, that is, the phy_crs_i signal was inactive for one
     * or more transmission clock periods during packet transmission.
     */
    inline bool get_MAC_RX_TX_STATUS_LCARR() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 2u);
    }

    /**
     * Get MAC_RX_TX_STATUS's NCARR bit.
     *
     * No Carrier When the DTXSTS bit is set in the MAC_OPERATION_MODE
     * register, this bit indicates that the carrier signal from the PHY is not
     * present at the end of preamble transmission.
     */
    inline bool get_MAC_RX_TX_STATUS_NCARR() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 1u);
    }

    /**
     * Get MAC_RX_TX_STATUS's TJT bit.
     *
     * Transmit Jabber Timeout This bit indicates that the Transmit Jabber
     * Timer expired which happens when the packet size exceeds 2,048 bytes
     * (10,240 bytes when the Jumbo packet is enabled) and JD bit is reset in
     * the MAC_CONFIGURATION register.
     */
    inline bool get_MAC_RX_TX_STATUS_TJT() volatile
    {
        return MAC_RX_TX_STATUS & (1u << 0u);
    }

    /**
     * Get all of MAC_RX_TX_STATUS's bit fields.
     *
     * (read-write) Receive Transmit Status
     */
    inline void get_MAC_RX_TX_STATUS(bool &RWT, bool &EXCOL, bool &LCOL,
                                     bool &EXDEF, bool &LCARR, bool &NCARR,
                                     bool &TJT) volatile
    {
        uint32_t curr = MAC_RX_TX_STATUS;

        RWT = curr & (1u << 8u);
        EXCOL = curr & (1u << 5u);
        LCOL = curr & (1u << 4u);
        EXDEF = curr & (1u << 3u);
        LCARR = curr & (1u << 2u);
        NCARR = curr & (1u << 1u);
        TJT = curr & (1u << 0u);
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's RWKFILTRST bit.
     *
     * Remote Wake-Up Packet Filter Register Pointer Reset When this bit is
     * set, the remote wake-up packet filter register pointer is reset to
     * 3'b000.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_RWKFILTRST() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 31u);
    }

    /**
     * Set MAC_PMT_CONTROL_STATUS's RWKFILTRST bit.
     *
     * Remote Wake-Up Packet Filter Register Pointer Reset When this bit is
     * set, the remote wake-up packet filter register pointer is reset to
     * 3'b000.
     */
    inline void set_MAC_PMT_CONTROL_STATUS_RWKFILTRST() volatile
    {
        MAC_PMT_CONTROL_STATUS |= 1u << 31u;
    }

    /**
     * Clear MAC_PMT_CONTROL_STATUS's RWKFILTRST bit.
     *
     * Remote Wake-Up Packet Filter Register Pointer Reset When this bit is
     * set, the remote wake-up packet filter register pointer is reset to
     * 3'b000.
     */
    inline void clear_MAC_PMT_CONTROL_STATUS_RWKFILTRST() volatile
    {
        MAC_PMT_CONTROL_STATUS &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PMT_CONTROL_STATUS's RWKFILTRST bit.
     *
     * Remote Wake-Up Packet Filter Register Pointer Reset When this bit is
     * set, the remote wake-up packet filter register pointer is reset to
     * 3'b000.
     */
    inline void toggle_MAC_PMT_CONTROL_STATUS_RWKFILTRST() volatile
    {
        MAC_PMT_CONTROL_STATUS ^= 1u << 31u;
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's RWKPTR field.
     *
     * Remote Wake-up FIFO Pointer This field gives the current value (0 to 7,
     * 15, or 31 when 4, 8, or 16 Remote Wake-up Packet Filters are selected)
     * of the Remote Wake-up Packet Filter register pointer.
     */
    inline uint8_t get_MAC_PMT_CONTROL_STATUS_RWKPTR() volatile
    {
        return (MAC_PMT_CONTROL_STATUS >> 24u) & 0b11111u;
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's RWKPFE bit.
     *
     * Remote Wake-up Packet Forwarding Enable When this bit is set along with
     * RWKPKTEN, the MAC receiver drops all received frames until it receives
     * the expected Wake-up frame.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_RWKPFE() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 10u);
    }

    /**
     * Set MAC_PMT_CONTROL_STATUS's RWKPFE bit.
     *
     * Remote Wake-up Packet Forwarding Enable When this bit is set along with
     * RWKPKTEN, the MAC receiver drops all received frames until it receives
     * the expected Wake-up frame.
     */
    inline void set_MAC_PMT_CONTROL_STATUS_RWKPFE() volatile
    {
        MAC_PMT_CONTROL_STATUS |= 1u << 10u;
    }

    /**
     * Clear MAC_PMT_CONTROL_STATUS's RWKPFE bit.
     *
     * Remote Wake-up Packet Forwarding Enable When this bit is set along with
     * RWKPKTEN, the MAC receiver drops all received frames until it receives
     * the expected Wake-up frame.
     */
    inline void clear_MAC_PMT_CONTROL_STATUS_RWKPFE() volatile
    {
        MAC_PMT_CONTROL_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_PMT_CONTROL_STATUS's RWKPFE bit.
     *
     * Remote Wake-up Packet Forwarding Enable When this bit is set along with
     * RWKPKTEN, the MAC receiver drops all received frames until it receives
     * the expected Wake-up frame.
     */
    inline void toggle_MAC_PMT_CONTROL_STATUS_RWKPFE() volatile
    {
        MAC_PMT_CONTROL_STATUS ^= 1u << 10u;
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's GLBLUCAST bit.
     *
     * Global Unicast When this bit set, any unicast packet filtered by the MAC
     * (DAF) address recognition is detected as a remote wake-up packet.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_GLBLUCAST() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Set MAC_PMT_CONTROL_STATUS's GLBLUCAST bit.
     *
     * Global Unicast When this bit set, any unicast packet filtered by the MAC
     * (DAF) address recognition is detected as a remote wake-up packet.
     */
    inline void set_MAC_PMT_CONTROL_STATUS_GLBLUCAST() volatile
    {
        MAC_PMT_CONTROL_STATUS |= 1u << 9u;
    }

    /**
     * Clear MAC_PMT_CONTROL_STATUS's GLBLUCAST bit.
     *
     * Global Unicast When this bit set, any unicast packet filtered by the MAC
     * (DAF) address recognition is detected as a remote wake-up packet.
     */
    inline void clear_MAC_PMT_CONTROL_STATUS_GLBLUCAST() volatile
    {
        MAC_PMT_CONTROL_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_PMT_CONTROL_STATUS's GLBLUCAST bit.
     *
     * Global Unicast When this bit set, any unicast packet filtered by the MAC
     * (DAF) address recognition is detected as a remote wake-up packet.
     */
    inline void toggle_MAC_PMT_CONTROL_STATUS_GLBLUCAST() volatile
    {
        MAC_PMT_CONTROL_STATUS ^= 1u << 9u;
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's RWKPRCVD bit.
     *
     * Remote Wake-Up Packet Received When this bit is set, it indicates that
     * the power management event is generated because of the reception of a
     * remote wake-up packet.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_RWKPRCVD() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 6u);
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's MGKPRCVD bit.
     *
     * Magic Packet Received When this bit is set, it indicates that the power
     * management event is generated because of the reception of a magic
     * packet.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_MGKPRCVD() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 5u);
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's RWKPKTEN bit.
     *
     * Remote Wake-Up Packet Enable When this bit is set, a power management
     * event is generated when the MAC receives a remote wake-up packet.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_RWKPKTEN() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 2u);
    }

    /**
     * Set MAC_PMT_CONTROL_STATUS's RWKPKTEN bit.
     *
     * Remote Wake-Up Packet Enable When this bit is set, a power management
     * event is generated when the MAC receives a remote wake-up packet.
     */
    inline void set_MAC_PMT_CONTROL_STATUS_RWKPKTEN() volatile
    {
        MAC_PMT_CONTROL_STATUS |= 1u << 2u;
    }

    /**
     * Clear MAC_PMT_CONTROL_STATUS's RWKPKTEN bit.
     *
     * Remote Wake-Up Packet Enable When this bit is set, a power management
     * event is generated when the MAC receives a remote wake-up packet.
     */
    inline void clear_MAC_PMT_CONTROL_STATUS_RWKPKTEN() volatile
    {
        MAC_PMT_CONTROL_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_PMT_CONTROL_STATUS's RWKPKTEN bit.
     *
     * Remote Wake-Up Packet Enable When this bit is set, a power management
     * event is generated when the MAC receives a remote wake-up packet.
     */
    inline void toggle_MAC_PMT_CONTROL_STATUS_RWKPKTEN() volatile
    {
        MAC_PMT_CONTROL_STATUS ^= 1u << 2u;
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's MGKPKTEN bit.
     *
     * Magic Packet Enable When this bit is set, a power management event is
     * generated when the MAC receives a magic packet.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_MGKPKTEN() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MAC_PMT_CONTROL_STATUS's MGKPKTEN bit.
     *
     * Magic Packet Enable When this bit is set, a power management event is
     * generated when the MAC receives a magic packet.
     */
    inline void set_MAC_PMT_CONTROL_STATUS_MGKPKTEN() volatile
    {
        MAC_PMT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MAC_PMT_CONTROL_STATUS's MGKPKTEN bit.
     *
     * Magic Packet Enable When this bit is set, a power management event is
     * generated when the MAC receives a magic packet.
     */
    inline void clear_MAC_PMT_CONTROL_STATUS_MGKPKTEN() volatile
    {
        MAC_PMT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_PMT_CONTROL_STATUS's MGKPKTEN bit.
     *
     * Magic Packet Enable When this bit is set, a power management event is
     * generated when the MAC receives a magic packet.
     */
    inline void toggle_MAC_PMT_CONTROL_STATUS_MGKPKTEN() volatile
    {
        MAC_PMT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MAC_PMT_CONTROL_STATUS's PWRDWN bit.
     *
     * Power Down When this bit is set, the MAC receiver drops all received
     * packets until it receives the expected magic packet or remote wake-up
     * packet.
     */
    inline bool get_MAC_PMT_CONTROL_STATUS_PWRDWN() volatile
    {
        return MAC_PMT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MAC_PMT_CONTROL_STATUS's PWRDWN bit.
     *
     * Power Down When this bit is set, the MAC receiver drops all received
     * packets until it receives the expected magic packet or remote wake-up
     * packet.
     */
    inline void set_MAC_PMT_CONTROL_STATUS_PWRDWN() volatile
    {
        MAC_PMT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MAC_PMT_CONTROL_STATUS's PWRDWN bit.
     *
     * Power Down When this bit is set, the MAC receiver drops all received
     * packets until it receives the expected magic packet or remote wake-up
     * packet.
     */
    inline void clear_MAC_PMT_CONTROL_STATUS_PWRDWN() volatile
    {
        MAC_PMT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_PMT_CONTROL_STATUS's PWRDWN bit.
     *
     * Power Down When this bit is set, the MAC receiver drops all received
     * packets until it receives the expected magic packet or remote wake-up
     * packet.
     */
    inline void toggle_MAC_PMT_CONTROL_STATUS_PWRDWN() volatile
    {
        MAC_PMT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MAC_PMT_CONTROL_STATUS's bit fields.
     *
     * (read-write) PMT Control and Status
     */
    inline void get_MAC_PMT_CONTROL_STATUS(bool &RWKFILTRST, uint8_t &RWKPTR,
                                           bool &RWKPFE, bool &GLBLUCAST,
                                           bool &RWKPRCVD, bool &MGKPRCVD,
                                           bool &RWKPKTEN, bool &MGKPKTEN,
                                           bool &PWRDWN) volatile
    {
        uint32_t curr = MAC_PMT_CONTROL_STATUS;

        RWKFILTRST = curr & (1u << 31u);
        RWKPTR = (curr >> 24u) & 0b11111u;
        RWKPFE = curr & (1u << 10u);
        GLBLUCAST = curr & (1u << 9u);
        RWKPRCVD = curr & (1u << 6u);
        MGKPRCVD = curr & (1u << 5u);
        RWKPKTEN = curr & (1u << 2u);
        MGKPKTEN = curr & (1u << 1u);
        PWRDWN = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_PMT_CONTROL_STATUS's bit fields.
     *
     * (read-write) PMT Control and Status
     */
    inline void set_MAC_PMT_CONTROL_STATUS(bool RWKFILTRST, bool RWKPFE,
                                           bool GLBLUCAST, bool RWKPKTEN,
                                           bool MGKPKTEN, bool PWRDWN) volatile
    {
        uint32_t curr = MAC_PMT_CONTROL_STATUS;

        curr &= ~(0b1u << 31u);
        curr |= (RWKFILTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 10u);
        curr |= (RWKPFE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (GLBLUCAST & 0b1u) << 9u;
        curr &= ~(0b1u << 2u);
        curr |= (RWKPKTEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (MGKPKTEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PWRDWN & 0b1u) << 0u;

        MAC_PMT_CONTROL_STATUS = curr;
    }

    /**
     * Get MAC_RWK_PACKET_FILTER's WKUPFRMFTR field.
     *
     * RWK Packet Filter This field contains the various controls of RWK Packet
     * filter.
     */
    inline uint32_t get_MAC_RWK_PACKET_FILTER_WKUPFRMFTR() volatile
    {
        return (MAC_RWK_PACKET_FILTER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_RWK_PACKET_FILTER's WKUPFRMFTR field.
     *
     * RWK Packet Filter This field contains the various controls of RWK Packet
     * filter.
     */
    inline void set_MAC_RWK_PACKET_FILTER_WKUPFRMFTR(uint32_t value) volatile
    {
        uint32_t curr = MAC_RWK_PACKET_FILTER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_RWK_PACKET_FILTER = curr;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's LPITCSE bit.
     *
     * LPI Tx Clock Stop Enable When this bit is set, the MAC asserts
     * sbd_tx_clk_gating_ctrl_o signal high after it enters Tx LPI mode to
     * indicate that the Tx clock to MAC can be stopped.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_LPITCSE() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 21u);
    }

    /**
     * Set MAC_LPI_CONTROL_STATUS's LPITCSE bit.
     *
     * LPI Tx Clock Stop Enable When this bit is set, the MAC asserts
     * sbd_tx_clk_gating_ctrl_o signal high after it enters Tx LPI mode to
     * indicate that the Tx clock to MAC can be stopped.
     */
    inline void set_MAC_LPI_CONTROL_STATUS_LPITCSE() volatile
    {
        MAC_LPI_CONTROL_STATUS |= 1u << 21u;
    }

    /**
     * Clear MAC_LPI_CONTROL_STATUS's LPITCSE bit.
     *
     * LPI Tx Clock Stop Enable When this bit is set, the MAC asserts
     * sbd_tx_clk_gating_ctrl_o signal high after it enters Tx LPI mode to
     * indicate that the Tx clock to MAC can be stopped.
     */
    inline void clear_MAC_LPI_CONTROL_STATUS_LPITCSE() volatile
    {
        MAC_LPI_CONTROL_STATUS &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_LPI_CONTROL_STATUS's LPITCSE bit.
     *
     * LPI Tx Clock Stop Enable When this bit is set, the MAC asserts
     * sbd_tx_clk_gating_ctrl_o signal high after it enters Tx LPI mode to
     * indicate that the Tx clock to MAC can be stopped.
     */
    inline void toggle_MAC_LPI_CONTROL_STATUS_LPITCSE() volatile
    {
        MAC_LPI_CONTROL_STATUS ^= 1u << 21u;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's LPIATE bit.
     *
     * LPI Timer Enable This bit controls the automatic entry of the MAC
     * Transmitter into and exit out of the LPI state.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_LPIATE() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 20u);
    }

    /**
     * Set MAC_LPI_CONTROL_STATUS's LPIATE bit.
     *
     * LPI Timer Enable This bit controls the automatic entry of the MAC
     * Transmitter into and exit out of the LPI state.
     */
    inline void set_MAC_LPI_CONTROL_STATUS_LPIATE() volatile
    {
        MAC_LPI_CONTROL_STATUS |= 1u << 20u;
    }

    /**
     * Clear MAC_LPI_CONTROL_STATUS's LPIATE bit.
     *
     * LPI Timer Enable This bit controls the automatic entry of the MAC
     * Transmitter into and exit out of the LPI state.
     */
    inline void clear_MAC_LPI_CONTROL_STATUS_LPIATE() volatile
    {
        MAC_LPI_CONTROL_STATUS &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_LPI_CONTROL_STATUS's LPIATE bit.
     *
     * LPI Timer Enable This bit controls the automatic entry of the MAC
     * Transmitter into and exit out of the LPI state.
     */
    inline void toggle_MAC_LPI_CONTROL_STATUS_LPIATE() volatile
    {
        MAC_LPI_CONTROL_STATUS ^= 1u << 20u;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's LPITXA bit.
     *
     * LPI Tx Automate This bit controls the behavior of the MAC when it is
     * entering or coming out of the LPI mode on the Transmit side.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_LPITXA() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 19u);
    }

    /**
     * Set MAC_LPI_CONTROL_STATUS's LPITXA bit.
     *
     * LPI Tx Automate This bit controls the behavior of the MAC when it is
     * entering or coming out of the LPI mode on the Transmit side.
     */
    inline void set_MAC_LPI_CONTROL_STATUS_LPITXA() volatile
    {
        MAC_LPI_CONTROL_STATUS |= 1u << 19u;
    }

    /**
     * Clear MAC_LPI_CONTROL_STATUS's LPITXA bit.
     *
     * LPI Tx Automate This bit controls the behavior of the MAC when it is
     * entering or coming out of the LPI mode on the Transmit side.
     */
    inline void clear_MAC_LPI_CONTROL_STATUS_LPITXA() volatile
    {
        MAC_LPI_CONTROL_STATUS &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_LPI_CONTROL_STATUS's LPITXA bit.
     *
     * LPI Tx Automate This bit controls the behavior of the MAC when it is
     * entering or coming out of the LPI mode on the Transmit side.
     */
    inline void toggle_MAC_LPI_CONTROL_STATUS_LPITXA() volatile
    {
        MAC_LPI_CONTROL_STATUS ^= 1u << 19u;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's PLSEN bit.
     *
     * PHY Link Status Enable This bit enables the link status received on the
     * RGMII, SGMII, or SMII Receive paths to be used for activating the LPI LS
     * TIMER.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_PLSEN() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 18u);
    }

    /**
     * Set MAC_LPI_CONTROL_STATUS's PLSEN bit.
     *
     * PHY Link Status Enable This bit enables the link status received on the
     * RGMII, SGMII, or SMII Receive paths to be used for activating the LPI LS
     * TIMER.
     */
    inline void set_MAC_LPI_CONTROL_STATUS_PLSEN() volatile
    {
        MAC_LPI_CONTROL_STATUS |= 1u << 18u;
    }

    /**
     * Clear MAC_LPI_CONTROL_STATUS's PLSEN bit.
     *
     * PHY Link Status Enable This bit enables the link status received on the
     * RGMII, SGMII, or SMII Receive paths to be used for activating the LPI LS
     * TIMER.
     */
    inline void clear_MAC_LPI_CONTROL_STATUS_PLSEN() volatile
    {
        MAC_LPI_CONTROL_STATUS &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_LPI_CONTROL_STATUS's PLSEN bit.
     *
     * PHY Link Status Enable This bit enables the link status received on the
     * RGMII, SGMII, or SMII Receive paths to be used for activating the LPI LS
     * TIMER.
     */
    inline void toggle_MAC_LPI_CONTROL_STATUS_PLSEN() volatile
    {
        MAC_LPI_CONTROL_STATUS ^= 1u << 18u;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's PLS bit.
     *
     * PHY Link Status This bit indicates the link status of the PHY.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_PLS() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 17u);
    }

    /**
     * Set MAC_LPI_CONTROL_STATUS's PLS bit.
     *
     * PHY Link Status This bit indicates the link status of the PHY.
     */
    inline void set_MAC_LPI_CONTROL_STATUS_PLS() volatile
    {
        MAC_LPI_CONTROL_STATUS |= 1u << 17u;
    }

    /**
     * Clear MAC_LPI_CONTROL_STATUS's PLS bit.
     *
     * PHY Link Status This bit indicates the link status of the PHY.
     */
    inline void clear_MAC_LPI_CONTROL_STATUS_PLS() volatile
    {
        MAC_LPI_CONTROL_STATUS &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_LPI_CONTROL_STATUS's PLS bit.
     *
     * PHY Link Status This bit indicates the link status of the PHY.
     */
    inline void toggle_MAC_LPI_CONTROL_STATUS_PLS() volatile
    {
        MAC_LPI_CONTROL_STATUS ^= 1u << 17u;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's LPIEN bit.
     *
     * LPI Enable When this bit is set, it instructs the MAC Transmitter to
     * enter the LPI state.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_LPIEN() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MAC_LPI_CONTROL_STATUS's LPIEN bit.
     *
     * LPI Enable When this bit is set, it instructs the MAC Transmitter to
     * enter the LPI state.
     */
    inline void set_MAC_LPI_CONTROL_STATUS_LPIEN() volatile
    {
        MAC_LPI_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MAC_LPI_CONTROL_STATUS's LPIEN bit.
     *
     * LPI Enable When this bit is set, it instructs the MAC Transmitter to
     * enter the LPI state.
     */
    inline void clear_MAC_LPI_CONTROL_STATUS_LPIEN() volatile
    {
        MAC_LPI_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_LPI_CONTROL_STATUS's LPIEN bit.
     *
     * LPI Enable When this bit is set, it instructs the MAC Transmitter to
     * enter the LPI state.
     */
    inline void toggle_MAC_LPI_CONTROL_STATUS_LPIEN() volatile
    {
        MAC_LPI_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's RLPIST bit.
     *
     * Receive LPI State When this bit is set, it indicates that the MAC is
     * receiving the LPI pattern on the GMII or MII interface.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_RLPIST() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's TLPIST bit.
     *
     * Transmit LPI State When this bit is set, it indicates that the MAC is
     * transmitting the LPI pattern on the GMII or MII interface.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_TLPIST() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 8u);
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's RLPIEX bit.
     *
     * Receive LPI Exit When this bit is set, it indicates that the MAC
     * Receiver has stopped receiving the LPI pattern on the GMII or MII
     * interface, exited the LPI state, and resumed the normal reception.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_RLPIEX() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 3u);
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's RLPIEN bit.
     *
     * Receive LPI Entry When this bit is set, it indicates that the MAC
     * Receiver has received an LPI pattern and entered the LPI state.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_RLPIEN() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 2u);
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's TLPIEX bit.
     *
     * Transmit LPI Exit When this bit is set, it indicates that the MAC
     * transmitter exited the LPI state after the application cleared the LPIEN
     * bit and the LPI TW Timer has expired.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_TLPIEX() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Get MAC_LPI_CONTROL_STATUS's TLPIEN bit.
     *
     * Transmit LPI Entry When this bit is set, it indicates that the MAC
     * Transmitter has entered the LPI state because of the setting of the
     * LPIEN bit.
     */
    inline bool get_MAC_LPI_CONTROL_STATUS_TLPIEN() volatile
    {
        return MAC_LPI_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Get all of MAC_LPI_CONTROL_STATUS's bit fields.
     *
     * (read-write) LPI Control and Status
     */
    inline void get_MAC_LPI_CONTROL_STATUS(bool &LPITCSE, bool &LPIATE,
                                           bool &LPITXA, bool &PLSEN,
                                           bool &PLS, bool &LPIEN,
                                           bool &RLPIST, bool &TLPIST,
                                           bool &RLPIEX, bool &RLPIEN,
                                           bool &TLPIEX, bool &TLPIEN) volatile
    {
        uint32_t curr = MAC_LPI_CONTROL_STATUS;

        LPITCSE = curr & (1u << 21u);
        LPIATE = curr & (1u << 20u);
        LPITXA = curr & (1u << 19u);
        PLSEN = curr & (1u << 18u);
        PLS = curr & (1u << 17u);
        LPIEN = curr & (1u << 16u);
        RLPIST = curr & (1u << 9u);
        TLPIST = curr & (1u << 8u);
        RLPIEX = curr & (1u << 3u);
        RLPIEN = curr & (1u << 2u);
        TLPIEX = curr & (1u << 1u);
        TLPIEN = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_LPI_CONTROL_STATUS's bit fields.
     *
     * (read-write) LPI Control and Status
     */
    inline void set_MAC_LPI_CONTROL_STATUS(bool LPITCSE, bool LPIATE,
                                           bool LPITXA, bool PLSEN, bool PLS,
                                           bool LPIEN) volatile
    {
        uint32_t curr = MAC_LPI_CONTROL_STATUS;

        curr &= ~(0b1u << 21u);
        curr |= (LPITCSE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (LPIATE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (LPITXA & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (PLSEN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (PLS & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (LPIEN & 0b1u) << 16u;

        MAC_LPI_CONTROL_STATUS = curr;
    }

    /**
     * Get MAC_LPI_TIMERS_CONTROL's LST field.
     *
     * LPI LS Timer This field specifies the minimum time (in milliseconds) for
     * which the link status from the PHY should be up (OKAY) before the LPI
     * pattern can be transmitted to the PHY.
     */
    inline uint16_t get_MAC_LPI_TIMERS_CONTROL_LST() volatile
    {
        return (MAC_LPI_TIMERS_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set MAC_LPI_TIMERS_CONTROL's LST field.
     *
     * LPI LS Timer This field specifies the minimum time (in milliseconds) for
     * which the link status from the PHY should be up (OKAY) before the LPI
     * pattern can be transmitted to the PHY.
     */
    inline void set_MAC_LPI_TIMERS_CONTROL_LST(uint16_t value) volatile
    {
        uint32_t curr = MAC_LPI_TIMERS_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        MAC_LPI_TIMERS_CONTROL = curr;
    }

    /**
     * Get MAC_LPI_TIMERS_CONTROL's TWT field.
     *
     * LPI TW Timer This field specifies the minimum time (in microseconds) for
     * which the MAC waits after it stops transmitting the LPI pattern to the
     * PHY and before it resumes the normal transmission.
     */
    inline uint16_t get_MAC_LPI_TIMERS_CONTROL_TWT() volatile
    {
        return (MAC_LPI_TIMERS_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LPI_TIMERS_CONTROL's TWT field.
     *
     * LPI TW Timer This field specifies the minimum time (in microseconds) for
     * which the MAC waits after it stops transmitting the LPI pattern to the
     * PHY and before it resumes the normal transmission.
     */
    inline void set_MAC_LPI_TIMERS_CONTROL_TWT(uint16_t value) volatile
    {
        uint32_t curr = MAC_LPI_TIMERS_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LPI_TIMERS_CONTROL = curr;
    }

    /**
     * Get all of MAC_LPI_TIMERS_CONTROL's bit fields.
     *
     * (read-write) LPI Timers Control
     */
    inline void get_MAC_LPI_TIMERS_CONTROL(uint16_t &LST,
                                           uint16_t &TWT) volatile
    {
        uint32_t curr = MAC_LPI_TIMERS_CONTROL;

        LST = (curr >> 16u) & 0b1111111111u;
        TWT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LPI_TIMERS_CONTROL's bit fields.
     *
     * (read-write) LPI Timers Control
     */
    inline void set_MAC_LPI_TIMERS_CONTROL(uint16_t LST, uint16_t TWT) volatile
    {
        uint32_t curr = MAC_LPI_TIMERS_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (LST & 0b1111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (TWT & 0b1111111111111111u) << 0u;

        MAC_LPI_TIMERS_CONTROL = curr;
    }

    /**
     * Get MAC_LPI_ENTRY_TIMER's LPIET field.
     *
     * LPI Entry Timer This field specifies the time in microseconds the MAC
     * waits to enter LPI mode, after it has transmitted all the frames.
     */
    inline uint32_t get_MAC_LPI_ENTRY_TIMER_LPIET() volatile
    {
        return (MAC_LPI_ENTRY_TIMER >> 3u) & 0b11111111111111111u;
    }

    /**
     * Set MAC_LPI_ENTRY_TIMER's LPIET field.
     *
     * LPI Entry Timer This field specifies the time in microseconds the MAC
     * waits to enter LPI mode, after it has transmitted all the frames.
     */
    inline void set_MAC_LPI_ENTRY_TIMER_LPIET(uint32_t value) volatile
    {
        uint32_t curr = MAC_LPI_ENTRY_TIMER;

        curr &= ~(0b11111111111111111u << 3u);
        curr |= (value & 0b11111111111111111u) << 3u;

        MAC_LPI_ENTRY_TIMER = curr;
    }

    /**
     * Get MAC_ONEUS_TIC_COUNTER's TIC_1US_CNTR field.
     *
     * 1US TIC Counter The application must program this counter so that the
     * number of clock cycles of CSR clock is 1us.
     */
    inline uint16_t get_MAC_ONEUS_TIC_COUNTER_TIC_1US_CNTR() volatile
    {
        return (MAC_ONEUS_TIC_COUNTER >> 0u) & 0b111111111111u;
    }

    /**
     * Set MAC_ONEUS_TIC_COUNTER's TIC_1US_CNTR field.
     *
     * 1US TIC Counter The application must program this counter so that the
     * number of clock cycles of CSR clock is 1us.
     */
    inline void set_MAC_ONEUS_TIC_COUNTER_TIC_1US_CNTR(uint16_t value) volatile
    {
        uint32_t curr = MAC_ONEUS_TIC_COUNTER;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        MAC_ONEUS_TIC_COUNTER = curr;
    }

    /**
     * Get MAC_PHYIF_CONTROL_STATUS's LNKSTS bit.
     *
     * Link Status This bit indicates whether the link is up (1'b1) or down
     * (1'b0).
     */
    inline bool get_MAC_PHYIF_CONTROL_STATUS_LNKSTS() volatile
    {
        return MAC_PHYIF_CONTROL_STATUS & (1u << 19u);
    }

    /**
     * Get MAC_PHYIF_CONTROL_STATUS's LNKSPEED field.
     *
     * Link Speed This bit indicates the current speed of the link.
     */
    inline ENET_QOS_MAC_PHYIF_CONTROL_STATUS_LNKSPEED
    get_MAC_PHYIF_CONTROL_STATUS_LNKSPEED() volatile
    {
        return ENET_QOS_MAC_PHYIF_CONTROL_STATUS_LNKSPEED(
            (MAC_PHYIF_CONTROL_STATUS >> 17u) & 0b11u);
    }

    /**
     * Get MAC_PHYIF_CONTROL_STATUS's LNKMOD bit.
     *
     * Link Mode This bit indicates the current mode of operation of the link.
     */
    inline bool get_MAC_PHYIF_CONTROL_STATUS_LNKMOD() volatile
    {
        return MAC_PHYIF_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Get MAC_PHYIF_CONTROL_STATUS's LUD bit.
     *
     * Link Up or Down This bit indicates whether the link is up or down during
     * transmission of configuration in the RGMII, SGMII, or SMII interface.
     */
    inline bool get_MAC_PHYIF_CONTROL_STATUS_LUD() volatile
    {
        return MAC_PHYIF_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MAC_PHYIF_CONTROL_STATUS's LUD bit.
     *
     * Link Up or Down This bit indicates whether the link is up or down during
     * transmission of configuration in the RGMII, SGMII, or SMII interface.
     */
    inline void set_MAC_PHYIF_CONTROL_STATUS_LUD() volatile
    {
        MAC_PHYIF_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MAC_PHYIF_CONTROL_STATUS's LUD bit.
     *
     * Link Up or Down This bit indicates whether the link is up or down during
     * transmission of configuration in the RGMII, SGMII, or SMII interface.
     */
    inline void clear_MAC_PHYIF_CONTROL_STATUS_LUD() volatile
    {
        MAC_PHYIF_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_PHYIF_CONTROL_STATUS's LUD bit.
     *
     * Link Up or Down This bit indicates whether the link is up or down during
     * transmission of configuration in the RGMII, SGMII, or SMII interface.
     */
    inline void toggle_MAC_PHYIF_CONTROL_STATUS_LUD() volatile
    {
        MAC_PHYIF_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MAC_PHYIF_CONTROL_STATUS's TC bit.
     *
     * Transmit Configuration in RGMII, SGMII, or SMII When set, this bit
     * enables the transmission of duplex mode, link speed, and link up or down
     * information to the PHY in the RGMII, SMII, or SGMII port.
     */
    inline bool get_MAC_PHYIF_CONTROL_STATUS_TC() volatile
    {
        return MAC_PHYIF_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MAC_PHYIF_CONTROL_STATUS's TC bit.
     *
     * Transmit Configuration in RGMII, SGMII, or SMII When set, this bit
     * enables the transmission of duplex mode, link speed, and link up or down
     * information to the PHY in the RGMII, SMII, or SGMII port.
     */
    inline void set_MAC_PHYIF_CONTROL_STATUS_TC() volatile
    {
        MAC_PHYIF_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MAC_PHYIF_CONTROL_STATUS's TC bit.
     *
     * Transmit Configuration in RGMII, SGMII, or SMII When set, this bit
     * enables the transmission of duplex mode, link speed, and link up or down
     * information to the PHY in the RGMII, SMII, or SGMII port.
     */
    inline void clear_MAC_PHYIF_CONTROL_STATUS_TC() volatile
    {
        MAC_PHYIF_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_PHYIF_CONTROL_STATUS's TC bit.
     *
     * Transmit Configuration in RGMII, SGMII, or SMII When set, this bit
     * enables the transmission of duplex mode, link speed, and link up or down
     * information to the PHY in the RGMII, SMII, or SGMII port.
     */
    inline void toggle_MAC_PHYIF_CONTROL_STATUS_TC() volatile
    {
        MAC_PHYIF_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MAC_PHYIF_CONTROL_STATUS's bit fields.
     *
     * (read-write) PHY Interface Control and Status
     */
    inline void get_MAC_PHYIF_CONTROL_STATUS(
        bool &LNKSTS, ENET_QOS_MAC_PHYIF_CONTROL_STATUS_LNKSPEED &LNKSPEED,
        bool &LNKMOD, bool &LUD, bool &TC) volatile
    {
        uint32_t curr = MAC_PHYIF_CONTROL_STATUS;

        LNKSTS = curr & (1u << 19u);
        LNKSPEED =
            ENET_QOS_MAC_PHYIF_CONTROL_STATUS_LNKSPEED((curr >> 17u) & 0b11u);
        LNKMOD = curr & (1u << 16u);
        LUD = curr & (1u << 1u);
        TC = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_PHYIF_CONTROL_STATUS's bit fields.
     *
     * (read-write) PHY Interface Control and Status
     */
    inline void set_MAC_PHYIF_CONTROL_STATUS(bool LUD, bool TC) volatile
    {
        uint32_t curr = MAC_PHYIF_CONTROL_STATUS;

        curr &= ~(0b1u << 1u);
        curr |= (LUD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TC & 0b1u) << 0u;

        MAC_PHYIF_CONTROL_STATUS = curr;
    }

    /**
     * Get MAC_VERSION's USERVER field.
     *
     * User-defined Version (8'h10)
     */
    inline uint8_t get_MAC_VERSION_USERVER() volatile
    {
        return (MAC_VERSION >> 8u) & 0b11111111u;
    }

    /**
     * Get MAC_VERSION's SNPSVER field.
     *
     * Synopsys-defined Version
     */
    inline uint8_t get_MAC_VERSION_SNPSVER() volatile
    {
        return (MAC_VERSION >> 0u) & 0b11111111u;
    }

    /**
     * Get all of MAC_VERSION's bit fields.
     *
     * (read-write) MAC Version
     */
    inline void get_MAC_VERSION(uint8_t &USERVER, uint8_t &SNPSVER) volatile
    {
        uint32_t curr = MAC_VERSION;

        USERVER = (curr >> 8u) & 0b11111111u;
        SNPSVER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get MAC_DEBUG's TFCSTS field.
     *
     * MAC Transmit Packet Controller Status This field indicates the state of
     * the MAC Transmit Packet Controller module.
     */
    inline ENET_QOS_MAC_DEBUG_TFCSTS get_MAC_DEBUG_TFCSTS() volatile
    {
        return ENET_QOS_MAC_DEBUG_TFCSTS((MAC_DEBUG >> 17u) & 0b11u);
    }

    /**
     * Get MAC_DEBUG's TPESTS bit.
     *
     * MAC GMII or MII Transmit Protocol Engine Status When this bit is set, it
     * indicates that the MAC GMII or MII transmit protocol engine is actively
     * transmitting data, and it is not in the Idle state.
     */
    inline bool get_MAC_DEBUG_TPESTS() volatile
    {
        return MAC_DEBUG & (1u << 16u);
    }

    /**
     * Get MAC_DEBUG's RFCFCSTS field.
     *
     * MAC Receive Packet Controller FIFO Status When this bit is set, this
     * field indicates the active state of the small FIFO Read and Write
     * controllers of the MAC Receive Packet Controller module.
     */
    inline uint8_t get_MAC_DEBUG_RFCFCSTS() volatile
    {
        return (MAC_DEBUG >> 1u) & 0b11u;
    }

    /**
     * Get MAC_DEBUG's RPESTS bit.
     *
     * MAC GMII or MII Receive Protocol Engine Status When this bit is set, it
     * indicates that the MAC GMII or MII receive protocol engine is actively
     * receiving data, and it is not in the Idle state.
     */
    inline bool get_MAC_DEBUG_RPESTS() volatile
    {
        return MAC_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MAC_DEBUG's bit fields.
     *
     * (read-write) MAC Debug
     */
    inline void get_MAC_DEBUG(ENET_QOS_MAC_DEBUG_TFCSTS &TFCSTS, bool &TPESTS,
                              uint8_t &RFCFCSTS, bool &RPESTS) volatile
    {
        uint32_t curr = MAC_DEBUG;

        TFCSTS = ENET_QOS_MAC_DEBUG_TFCSTS((curr >> 17u) & 0b11u);
        TPESTS = curr & (1u << 16u);
        RFCFCSTS = (curr >> 1u) & 0b11u;
        RPESTS = curr & (1u << 0u);
    }

    /**
     * Get MAC_HW_FEATURE0's ACTPHYSEL field.
     *
     * Active PHY Selected When you have multiple PHY interfaces in your
     * configuration, this field indicates the sampled value of phy_intf_sel_i
     * during reset de-assertion.
     */
    inline ENET_QOS_MAC_HW_FEATURE0_ACTPHYSEL
    get_MAC_HW_FEATURE0_ACTPHYSEL() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE0_ACTPHYSEL((MAC_HW_FEATURE0 >> 28u) &
                                                  0b111u);
    }

    /**
     * Get MAC_HW_FEATURE0's SAVLANINS bit.
     *
     * Source Address or VLAN Insertion Enable This bit is set to 1 when the
     * Enable SA and VLAN Insertion on Tx option is selected
     */
    inline bool get_MAC_HW_FEATURE0_SAVLANINS() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 27u);
    }

    /**
     * Get MAC_HW_FEATURE0's TSSTSSEL field.
     *
     * Timestamp System Time Source This bit indicates the source of the
     * Timestamp system time: This bit is set to 1 when the Enable IEEE 1588
     * Timestamp Support option is selected
     */
    inline ENET_QOS_MAC_HW_FEATURE0_TSSTSSEL
    get_MAC_HW_FEATURE0_TSSTSSEL() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE0_TSSTSSEL((MAC_HW_FEATURE0 >> 25u) &
                                                 0b11u);
    }

    /**
     * Get MAC_HW_FEATURE0's MACADR64SEL bit.
     *
     * MAC Addresses 64-127 Selected This bit is set to 1 when the Enable
     * Additional 64 MAC Address Registers (64-127) option is selected
     */
    inline bool get_MAC_HW_FEATURE0_MACADR64SEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 24u);
    }

    /**
     * Get MAC_HW_FEATURE0's MACADR32SEL bit.
     *
     * MAC Addresses 32-63 Selected This bit is set to 1 when the Enable
     * Additional 32 MAC Address Registers (32-63) option is selected
     */
    inline bool get_MAC_HW_FEATURE0_MACADR32SEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 23u);
    }

    /**
     * Get MAC_HW_FEATURE0's ADDMACADRSEL field.
     *
     * MAC Addresses 1-31 Selected This bit is set to 1 when the non-zero value
     * is selected for Enable Additional 1-31 MAC Address Registers option
     */
    inline uint8_t get_MAC_HW_FEATURE0_ADDMACADRSEL() volatile
    {
        return (MAC_HW_FEATURE0 >> 18u) & 0b11111u;
    }

    /**
     * Get MAC_HW_FEATURE0's RXCOESEL bit.
     *
     * Receive Checksum Offload Enabled This bit is set to 1 when the Enable
     * Receive TCP/IP Checksum Check option is selected
     */
    inline bool get_MAC_HW_FEATURE0_RXCOESEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 16u);
    }

    /**
     * Get MAC_HW_FEATURE0's TXCOESEL bit.
     *
     * Transmit Checksum Offload Enabled This bit is set to 1 when the Enable
     * Transmit TCP/IP Checksum Insertion option is selected
     */
    inline bool get_MAC_HW_FEATURE0_TXCOESEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 14u);
    }

    /**
     * Get MAC_HW_FEATURE0's EEESEL bit.
     *
     * Energy Efficient Ethernet Enabled This bit is set to 1 when the Enable
     * Energy Efficient Ethernet (EEE) option is selected
     */
    inline bool get_MAC_HW_FEATURE0_EEESEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 13u);
    }

    /**
     * Get MAC_HW_FEATURE0's TSSEL bit.
     *
     * IEEE 1588-2008 Timestamp Enabled This bit is set to 1 when the Enable
     * IEEE 1588 Timestamp Support option is selected
     */
    inline bool get_MAC_HW_FEATURE0_TSSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 12u);
    }

    /**
     * Get MAC_HW_FEATURE0's ARPOFFSEL bit.
     *
     * ARP Offload Enabled This bit is set to 1 when the Enable IPv4 ARP
     * Offload option is selected
     */
    inline bool get_MAC_HW_FEATURE0_ARPOFFSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 9u);
    }

    /**
     * Get MAC_HW_FEATURE0's MMCSEL bit.
     *
     * RMON Module Enable This bit is set to 1 when the Enable MAC Management
     * Counters (MMC) option is selected
     */
    inline bool get_MAC_HW_FEATURE0_MMCSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 8u);
    }

    /**
     * Get MAC_HW_FEATURE0's MGKSEL bit.
     *
     * PMT Magic Packet Enable This bit is set to 1 when the Enable Magic
     * Packet Detection option is selected
     */
    inline bool get_MAC_HW_FEATURE0_MGKSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 7u);
    }

    /**
     * Get MAC_HW_FEATURE0's RWKSEL bit.
     *
     * PMT Remote Wake-up Packet Enable This bit is set to 1 when the Enable
     * Remote Wake-Up Packet Detection option is selected
     */
    inline bool get_MAC_HW_FEATURE0_RWKSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 6u);
    }

    /**
     * Get MAC_HW_FEATURE0's SMASEL bit.
     *
     * SMA (MDIO) Interface This bit is set to 1 when the Enable Station
     * Management (MDIO Interface) option is selected
     */
    inline bool get_MAC_HW_FEATURE0_SMASEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 5u);
    }

    /**
     * Get MAC_HW_FEATURE0's VLHASH bit.
     *
     * VLAN Hash Filter Selected This bit is set to 1 when the Enable VLAN Hash
     * Table Based Filtering option is selected
     */
    inline bool get_MAC_HW_FEATURE0_VLHASH() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 4u);
    }

    /**
     * Get MAC_HW_FEATURE0's PCSSEL bit.
     *
     * PCS Registers (TBI, SGMII, or RTBI PHY interface) This bit is set to 1
     * when the TBI, SGMII, or RTBI PHY interface option is selected
     */
    inline bool get_MAC_HW_FEATURE0_PCSSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 3u);
    }

    /**
     * Get MAC_HW_FEATURE0's HDSEL bit.
     *
     * Half-duplex Support This bit is set to 1 when the half-duplex mode is
     * selected
     */
    inline bool get_MAC_HW_FEATURE0_HDSEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 2u);
    }

    /**
     * Get MAC_HW_FEATURE0's GMIISEL bit.
     *
     * 1000 Mbps Support This bit is set to 1 when 1000 Mbps is selected as the
     * Mode of Operation
     */
    inline bool get_MAC_HW_FEATURE0_GMIISEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 1u);
    }

    /**
     * Get MAC_HW_FEATURE0's MIISEL bit.
     *
     * 10 or 100 Mbps Support This bit is set to 1 when 10/100 Mbps is selected
     * as the Mode of Operation
     */
    inline bool get_MAC_HW_FEATURE0_MIISEL() volatile
    {
        return MAC_HW_FEATURE0 & (1u << 0u);
    }

    /**
     * Get all of MAC_HW_FEATURE0's bit fields.
     *
     * (read-write) Optional Features or Functions 0
     */
    inline void get_MAC_HW_FEATURE0(
        ENET_QOS_MAC_HW_FEATURE0_ACTPHYSEL &ACTPHYSEL, bool &SAVLANINS,
        ENET_QOS_MAC_HW_FEATURE0_TSSTSSEL &TSSTSSEL, bool &MACADR64SEL,
        bool &MACADR32SEL, uint8_t &ADDMACADRSEL, bool &RXCOESEL,
        bool &TXCOESEL, bool &EEESEL, bool &TSSEL, bool &ARPOFFSEL,
        bool &MMCSEL, bool &MGKSEL, bool &RWKSEL, bool &SMASEL, bool &VLHASH,
        bool &PCSSEL, bool &HDSEL, bool &GMIISEL, bool &MIISEL) volatile
    {
        uint32_t curr = MAC_HW_FEATURE0;

        ACTPHYSEL = ENET_QOS_MAC_HW_FEATURE0_ACTPHYSEL((curr >> 28u) & 0b111u);
        SAVLANINS = curr & (1u << 27u);
        TSSTSSEL = ENET_QOS_MAC_HW_FEATURE0_TSSTSSEL((curr >> 25u) & 0b11u);
        MACADR64SEL = curr & (1u << 24u);
        MACADR32SEL = curr & (1u << 23u);
        ADDMACADRSEL = (curr >> 18u) & 0b11111u;
        RXCOESEL = curr & (1u << 16u);
        TXCOESEL = curr & (1u << 14u);
        EEESEL = curr & (1u << 13u);
        TSSEL = curr & (1u << 12u);
        ARPOFFSEL = curr & (1u << 9u);
        MMCSEL = curr & (1u << 8u);
        MGKSEL = curr & (1u << 7u);
        RWKSEL = curr & (1u << 6u);
        SMASEL = curr & (1u << 5u);
        VLHASH = curr & (1u << 4u);
        PCSSEL = curr & (1u << 3u);
        HDSEL = curr & (1u << 2u);
        GMIISEL = curr & (1u << 1u);
        MIISEL = curr & (1u << 0u);
    }

    /**
     * Get MAC_HW_FEATURE1's L3L4FNUM field.
     *
     * Total number of L3 or L4 Filters This field indicates the total number
     * of L3 or L4 filters:
     */
    inline ENET_QOS_MAC_HW_FEATURE1_L3L4FNUM
    get_MAC_HW_FEATURE1_L3L4FNUM() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE1_L3L4FNUM((MAC_HW_FEATURE1 >> 27u) &
                                                 0b1111u);
    }

    /**
     * Get MAC_HW_FEATURE1's HASHTBLSZ field.
     *
     * Hash Table Size This field indicates the size of the hash table:
     */
    inline ENET_QOS_MAC_HW_FEATURE1_HASHTBLSZ
    get_MAC_HW_FEATURE1_HASHTBLSZ() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE1_HASHTBLSZ((MAC_HW_FEATURE1 >> 24u) &
                                                  0b11u);
    }

    /**
     * Get MAC_HW_FEATURE1's POUOST bit.
     *
     * One Step for PTP over UDP/IP Feature Enable This bit is set to 1 when
     * the Enable One step timestamp for PTP over UDP/IP feature is selected.
     */
    inline bool get_MAC_HW_FEATURE1_POUOST() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 23u);
    }

    /**
     * Get MAC_HW_FEATURE1's RAVSEL bit.
     *
     * Rx Side Only AV Feature Enable This bit is set to 1 when the Enable
     * Audio Video Bridging option on Rx Side Only is selected.
     */
    inline bool get_MAC_HW_FEATURE1_RAVSEL() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 21u);
    }

    /**
     * Get MAC_HW_FEATURE1's AVSEL bit.
     *
     * AV Feature Enable This bit is set to 1 when the Enable Audio Video
     * Bridging option is selected.
     */
    inline bool get_MAC_HW_FEATURE1_AVSEL() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 20u);
    }

    /**
     * Get MAC_HW_FEATURE1's DBGMEMA bit.
     *
     * DMA Debug Registers Enable This bit is set to 1 when the Debug Mode
     * Enable option is selected
     */
    inline bool get_MAC_HW_FEATURE1_DBGMEMA() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 19u);
    }

    /**
     * Get MAC_HW_FEATURE1's TSOEN bit.
     *
     * TCP Segmentation Offload Enable This bit is set to 1 when the Enable TCP
     * Segmentation Offloading for TCP/IP Packets option is selected
     */
    inline bool get_MAC_HW_FEATURE1_TSOEN() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 18u);
    }

    /**
     * Get MAC_HW_FEATURE1's SPHEN bit.
     *
     * Split Header Feature Enable This bit is set to 1 when the Enable Split
     * Header Structure option is selected
     */
    inline bool get_MAC_HW_FEATURE1_SPHEN() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 17u);
    }

    /**
     * Get MAC_HW_FEATURE1's DCBEN bit.
     *
     * DCB Feature Enable This bit is set to 1 when the Enable Data Center
     * Bridging option is selected
     */
    inline bool get_MAC_HW_FEATURE1_DCBEN() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 16u);
    }

    /**
     * Get MAC_HW_FEATURE1's ADDR64 field.
     *
     * Address Width.
     */
    inline ENET_QOS_MAC_HW_FEATURE1_ADDR64
    get_MAC_HW_FEATURE1_ADDR64() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE1_ADDR64((MAC_HW_FEATURE1 >> 14u) &
                                               0b11u);
    }

    /**
     * Get MAC_HW_FEATURE1's ADVTHWORD bit.
     *
     * IEEE 1588 High Word Register Enable This bit is set to 1 when the Add
     * IEEE 1588 Higher Word Register option is selected
     */
    inline bool get_MAC_HW_FEATURE1_ADVTHWORD() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 13u);
    }

    /**
     * Get MAC_HW_FEATURE1's PTOEN bit.
     *
     * PTP Offload Enable This bit is set to 1 when the Enable PTP Timestamp
     * Offload Feature is selected.
     */
    inline bool get_MAC_HW_FEATURE1_PTOEN() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 12u);
    }

    /**
     * Get MAC_HW_FEATURE1's OSTEN bit.
     *
     * One-Step Timestamping Enable This bit is set to 1 when the Enable
     * One-Step Timestamp Feature is selected.
     */
    inline bool get_MAC_HW_FEATURE1_OSTEN() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 11u);
    }

    /**
     * Get MAC_HW_FEATURE1's TXFIFOSIZE field.
     *
     * MTL Transmit FIFO Size This field contains the configured value of MTL
     * Tx FIFO in bytes expressed as Log to base 2 minus 7, that is,
     * Log2(TXFIFO_SIZE) -7:
     */
    inline ENET_QOS_MAC_HW_FEATURE1_TXFIFOSIZE
    get_MAC_HW_FEATURE1_TXFIFOSIZE() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE1_TXFIFOSIZE((MAC_HW_FEATURE1 >> 6u) &
                                                   0b11111u);
    }

    /**
     * Get MAC_HW_FEATURE1's SPRAM bit.
     *
     * Single Port RAM Enable This bit is set to 1 when the Use single port RAM
     * Feature is selected.
     */
    inline bool get_MAC_HW_FEATURE1_SPRAM() volatile
    {
        return MAC_HW_FEATURE1 & (1u << 5u);
    }

    /**
     * Get MAC_HW_FEATURE1's RXFIFOSIZE field.
     *
     * MTL Receive FIFO Size This field contains the configured value of MTL Rx
     * FIFO in bytes expressed as Log to base 2 minus 7, that is,
     * Log2(RXFIFO_SIZE) -7:
     */
    inline ENET_QOS_MAC_HW_FEATURE1_RXFIFOSIZE
    get_MAC_HW_FEATURE1_RXFIFOSIZE() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE1_RXFIFOSIZE((MAC_HW_FEATURE1 >> 0u) &
                                                   0b11111u);
    }

    /**
     * Get all of MAC_HW_FEATURE1's bit fields.
     *
     * (read-write) Optional Features or Functions 1
     */
    inline void get_MAC_HW_FEATURE1(
        ENET_QOS_MAC_HW_FEATURE1_L3L4FNUM &L3L4FNUM,
        ENET_QOS_MAC_HW_FEATURE1_HASHTBLSZ &HASHTBLSZ, bool &POUOST,
        bool &RAVSEL, bool &AVSEL, bool &DBGMEMA, bool &TSOEN, bool &SPHEN,
        bool &DCBEN, ENET_QOS_MAC_HW_FEATURE1_ADDR64 &ADDR64, bool &ADVTHWORD,
        bool &PTOEN, bool &OSTEN,
        ENET_QOS_MAC_HW_FEATURE1_TXFIFOSIZE &TXFIFOSIZE, bool &SPRAM,
        ENET_QOS_MAC_HW_FEATURE1_RXFIFOSIZE &RXFIFOSIZE) volatile
    {
        uint32_t curr = MAC_HW_FEATURE1;

        L3L4FNUM = ENET_QOS_MAC_HW_FEATURE1_L3L4FNUM((curr >> 27u) & 0b1111u);
        HASHTBLSZ = ENET_QOS_MAC_HW_FEATURE1_HASHTBLSZ((curr >> 24u) & 0b11u);
        POUOST = curr & (1u << 23u);
        RAVSEL = curr & (1u << 21u);
        AVSEL = curr & (1u << 20u);
        DBGMEMA = curr & (1u << 19u);
        TSOEN = curr & (1u << 18u);
        SPHEN = curr & (1u << 17u);
        DCBEN = curr & (1u << 16u);
        ADDR64 = ENET_QOS_MAC_HW_FEATURE1_ADDR64((curr >> 14u) & 0b11u);
        ADVTHWORD = curr & (1u << 13u);
        PTOEN = curr & (1u << 12u);
        OSTEN = curr & (1u << 11u);
        TXFIFOSIZE =
            ENET_QOS_MAC_HW_FEATURE1_TXFIFOSIZE((curr >> 6u) & 0b11111u);
        SPRAM = curr & (1u << 5u);
        RXFIFOSIZE =
            ENET_QOS_MAC_HW_FEATURE1_RXFIFOSIZE((curr >> 0u) & 0b11111u);
    }

    /**
     * Get MAC_HW_FEATURE2's AUXSNAPNUM field.
     *
     * Number of Auxiliary Snapshot Inputs This field indicates the number of
     * auxiliary snapshot inputs:
     */
    inline ENET_QOS_MAC_HW_FEATURE2_AUXSNAPNUM
    get_MAC_HW_FEATURE2_AUXSNAPNUM() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE2_AUXSNAPNUM((MAC_HW_FEATURE2 >> 28u) &
                                                   0b111u);
    }

    /**
     * Get MAC_HW_FEATURE2's PPSOUTNUM field.
     *
     * Number of PPS Outputs This field indicates the number of PPS outputs:
     */
    inline ENET_QOS_MAC_HW_FEATURE2_PPSOUTNUM
    get_MAC_HW_FEATURE2_PPSOUTNUM() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE2_PPSOUTNUM((MAC_HW_FEATURE2 >> 24u) &
                                                  0b111u);
    }

    /**
     * Get MAC_HW_FEATURE2's TXCHCNT field.
     *
     * Number of DMA Transmit Channels This field indicates the number of DMA
     * Transmit channels:
     */
    inline ENET_QOS_MAC_HW_FEATURE2_TXCHCNT
    get_MAC_HW_FEATURE2_TXCHCNT() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE2_TXCHCNT((MAC_HW_FEATURE2 >> 18u) &
                                                0b1111u);
    }

    /**
     * Get MAC_HW_FEATURE2's RXCHCNT field.
     *
     * Number of DMA Receive Channels This field indicates the number of DMA
     * Receive channels:
     */
    inline ENET_QOS_MAC_HW_FEATURE2_RXCHCNT
    get_MAC_HW_FEATURE2_RXCHCNT() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE2_RXCHCNT((MAC_HW_FEATURE2 >> 12u) &
                                                0b1111u);
    }

    /**
     * Get MAC_HW_FEATURE2's TXQCNT field.
     *
     * Number of MTL Transmit Queues This field indicates the number of MTL
     * Transmit queues:
     */
    inline ENET_QOS_MAC_HW_FEATURE2_TXQCNT
    get_MAC_HW_FEATURE2_TXQCNT() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE2_TXQCNT((MAC_HW_FEATURE2 >> 6u) &
                                               0b1111u);
    }

    /**
     * Get MAC_HW_FEATURE2's RXQCNT field.
     *
     * Number of MTL Receive Queues This field indicates the number of MTL
     * Receive queues:
     */
    inline ENET_QOS_MAC_HW_FEATURE2_RXQCNT
    get_MAC_HW_FEATURE2_RXQCNT() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE2_RXQCNT((MAC_HW_FEATURE2 >> 0u) &
                                               0b1111u);
    }

    /**
     * Get all of MAC_HW_FEATURE2's bit fields.
     *
     * (read-write) Optional Features or Functions 2
     */
    inline void get_MAC_HW_FEATURE2(
        ENET_QOS_MAC_HW_FEATURE2_AUXSNAPNUM &AUXSNAPNUM,
        ENET_QOS_MAC_HW_FEATURE2_PPSOUTNUM &PPSOUTNUM,
        ENET_QOS_MAC_HW_FEATURE2_TXCHCNT &TXCHCNT,
        ENET_QOS_MAC_HW_FEATURE2_RXCHCNT &RXCHCNT,
        ENET_QOS_MAC_HW_FEATURE2_TXQCNT &TXQCNT,
        ENET_QOS_MAC_HW_FEATURE2_RXQCNT &RXQCNT) volatile
    {
        uint32_t curr = MAC_HW_FEATURE2;

        AUXSNAPNUM =
            ENET_QOS_MAC_HW_FEATURE2_AUXSNAPNUM((curr >> 28u) & 0b111u);
        PPSOUTNUM = ENET_QOS_MAC_HW_FEATURE2_PPSOUTNUM((curr >> 24u) & 0b111u);
        TXCHCNT = ENET_QOS_MAC_HW_FEATURE2_TXCHCNT((curr >> 18u) & 0b1111u);
        RXCHCNT = ENET_QOS_MAC_HW_FEATURE2_RXCHCNT((curr >> 12u) & 0b1111u);
        TXQCNT = ENET_QOS_MAC_HW_FEATURE2_TXQCNT((curr >> 6u) & 0b1111u);
        RXQCNT = ENET_QOS_MAC_HW_FEATURE2_RXQCNT((curr >> 0u) & 0b1111u);
    }

    /**
     * Get MAC_HW_FEATURE3's ASP field.
     *
     * Automotive Safety Package Following are the encoding for the different
     * Safety features
     */
    inline ENET_QOS_MAC_HW_FEATURE3_ASP get_MAC_HW_FEATURE3_ASP() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE3_ASP((MAC_HW_FEATURE3 >> 28u) & 0b11u);
    }

    /**
     * Get MAC_HW_FEATURE3's TBSSEL bit.
     *
     * Time Based Scheduling Enable This bit is set to 1 when the Time Based
     * Scheduling feature is selected.
     */
    inline bool get_MAC_HW_FEATURE3_TBSSEL() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 27u);
    }

    /**
     * Get MAC_HW_FEATURE3's FPESEL bit.
     *
     * Frame Preemption Enable This bit is set to 1 when the Enable Frame
     * preemption feature is selected.
     */
    inline bool get_MAC_HW_FEATURE3_FPESEL() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 26u);
    }

    /**
     * Get MAC_HW_FEATURE3's ESTWID field.
     *
     * Width of the Time Interval field in the Gate Control List This field
     * indicates the width of the Configured Time Interval Field
     */
    inline ENET_QOS_MAC_HW_FEATURE3_ESTWID
    get_MAC_HW_FEATURE3_ESTWID() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE3_ESTWID((MAC_HW_FEATURE3 >> 20u) &
                                               0b11u);
    }

    /**
     * Get MAC_HW_FEATURE3's ESTDEP field.
     *
     * Depth of the Gate Control List This field indicates the depth of Gate
     * Control list expressed as Log2(DWC_EQOS_EST_DEP)-5
     */
    inline ENET_QOS_MAC_HW_FEATURE3_ESTDEP
    get_MAC_HW_FEATURE3_ESTDEP() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE3_ESTDEP((MAC_HW_FEATURE3 >> 17u) &
                                               0b111u);
    }

    /**
     * Get MAC_HW_FEATURE3's ESTSEL bit.
     *
     * Enhancements to Scheduling Traffic Enable This bit is set to 1 when the
     * Enable Enhancements to Scheduling Traffic feature is selected.
     */
    inline bool get_MAC_HW_FEATURE3_ESTSEL() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 16u);
    }

    /**
     * Get MAC_HW_FEATURE3's FRPES field.
     *
     * Flexible Receive Parser Table Entries size This field indicates the Max
     * Number of Parser Entries supported by Flexible Receive Parser.
     */
    inline ENET_QOS_MAC_HW_FEATURE3_FRPES get_MAC_HW_FEATURE3_FRPES() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE3_FRPES((MAC_HW_FEATURE3 >> 13u) &
                                              0b11u);
    }

    /**
     * Get MAC_HW_FEATURE3's FRPBS field.
     *
     * Flexible Receive Parser Buffer size This field indicates the supported
     * Max Number of bytes of the packet data to be Parsed by Flexible Receive
     * Parser.
     */
    inline ENET_QOS_MAC_HW_FEATURE3_FRPBS get_MAC_HW_FEATURE3_FRPBS() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE3_FRPBS((MAC_HW_FEATURE3 >> 11u) &
                                              0b11u);
    }

    /**
     * Get MAC_HW_FEATURE3's FRPSEL bit.
     *
     * Flexible Receive Parser Selected This bit is set to 1 when the Enable
     * Flexible Programmable Receive Parser option is selected.
     */
    inline bool get_MAC_HW_FEATURE3_FRPSEL() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 10u);
    }

    /**
     * Get MAC_HW_FEATURE3's PDUPSEL bit.
     *
     * Broadcast/Multicast Packet Duplication This bit is set to 1 when the
     * Broadcast/Multicast Packet Duplication feature is selected.
     */
    inline bool get_MAC_HW_FEATURE3_PDUPSEL() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 9u);
    }

    /**
     * Get MAC_HW_FEATURE3's DVLAN bit.
     *
     * Double VLAN Tag Processing Selected This bit is set to 1 when the Enable
     * Double VLAN Processing Feature is selected.
     */
    inline bool get_MAC_HW_FEATURE3_DVLAN() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 5u);
    }

    /**
     * Get MAC_HW_FEATURE3's CBTISEL bit.
     *
     * Queue/Channel based VLAN tag insertion on Tx Enable This bit is set to 1
     * when the Enable Queue/Channel based VLAN tag insertion on Tx Feature is
     * selected.
     */
    inline bool get_MAC_HW_FEATURE3_CBTISEL() volatile
    {
        return MAC_HW_FEATURE3 & (1u << 4u);
    }

    /**
     * Get MAC_HW_FEATURE3's NRVF field.
     *
     * Number of Extended VLAN Tag Filters Enabled This field indicates the
     * Number of Extended VLAN Tag Filters selected:
     */
    inline ENET_QOS_MAC_HW_FEATURE3_NRVF get_MAC_HW_FEATURE3_NRVF() volatile
    {
        return ENET_QOS_MAC_HW_FEATURE3_NRVF((MAC_HW_FEATURE3 >> 0u) & 0b111u);
    }

    /**
     * Get all of MAC_HW_FEATURE3's bit fields.
     *
     * (read-write) Optional Features or Functions 3
     */
    inline void get_MAC_HW_FEATURE3(
        ENET_QOS_MAC_HW_FEATURE3_ASP &ASP, bool &TBSSEL, bool &FPESEL,
        ENET_QOS_MAC_HW_FEATURE3_ESTWID &ESTWID,
        ENET_QOS_MAC_HW_FEATURE3_ESTDEP &ESTDEP, bool &ESTSEL,
        ENET_QOS_MAC_HW_FEATURE3_FRPES &FRPES,
        ENET_QOS_MAC_HW_FEATURE3_FRPBS &FRPBS, bool &FRPSEL, bool &PDUPSEL,
        bool &DVLAN, bool &CBTISEL,
        ENET_QOS_MAC_HW_FEATURE3_NRVF &NRVF) volatile
    {
        uint32_t curr = MAC_HW_FEATURE3;

        ASP = ENET_QOS_MAC_HW_FEATURE3_ASP((curr >> 28u) & 0b11u);
        TBSSEL = curr & (1u << 27u);
        FPESEL = curr & (1u << 26u);
        ESTWID = ENET_QOS_MAC_HW_FEATURE3_ESTWID((curr >> 20u) & 0b11u);
        ESTDEP = ENET_QOS_MAC_HW_FEATURE3_ESTDEP((curr >> 17u) & 0b111u);
        ESTSEL = curr & (1u << 16u);
        FRPES = ENET_QOS_MAC_HW_FEATURE3_FRPES((curr >> 13u) & 0b11u);
        FRPBS = ENET_QOS_MAC_HW_FEATURE3_FRPBS((curr >> 11u) & 0b11u);
        FRPSEL = curr & (1u << 10u);
        PDUPSEL = curr & (1u << 9u);
        DVLAN = curr & (1u << 5u);
        CBTISEL = curr & (1u << 4u);
        NRVF = ENET_QOS_MAC_HW_FEATURE3_NRVF((curr >> 0u) & 0b111u);
    }

    /**
     * Get MAC_MDIO_ADDRESS's PSE bit.
     *
     * Preamble Suppression Enable When this bit is set, the SMA suppresses the
     * 32-bit preamble and transmits MDIO frames with only 1 preamble bit.
     */
    inline bool get_MAC_MDIO_ADDRESS_PSE() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 27u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's PSE bit.
     *
     * Preamble Suppression Enable When this bit is set, the SMA suppresses the
     * 32-bit preamble and transmits MDIO frames with only 1 preamble bit.
     */
    inline void set_MAC_MDIO_ADDRESS_PSE() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 27u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's PSE bit.
     *
     * Preamble Suppression Enable When this bit is set, the SMA suppresses the
     * 32-bit preamble and transmits MDIO frames with only 1 preamble bit.
     */
    inline void clear_MAC_MDIO_ADDRESS_PSE() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 27u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's PSE bit.
     *
     * Preamble Suppression Enable When this bit is set, the SMA suppresses the
     * 32-bit preamble and transmits MDIO frames with only 1 preamble bit.
     */
    inline void toggle_MAC_MDIO_ADDRESS_PSE() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 27u;
    }

    /**
     * Get MAC_MDIO_ADDRESS's BTB bit.
     *
     * Back to Back transactions When this bit is set and the NTC has value
     * greater than 0, then the MAC informs the completion of a read or write
     * command at the end of frame transfer (before the trailing clocks are
     * transmitted).
     */
    inline bool get_MAC_MDIO_ADDRESS_BTB() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 26u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's BTB bit.
     *
     * Back to Back transactions When this bit is set and the NTC has value
     * greater than 0, then the MAC informs the completion of a read or write
     * command at the end of frame transfer (before the trailing clocks are
     * transmitted).
     */
    inline void set_MAC_MDIO_ADDRESS_BTB() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 26u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's BTB bit.
     *
     * Back to Back transactions When this bit is set and the NTC has value
     * greater than 0, then the MAC informs the completion of a read or write
     * command at the end of frame transfer (before the trailing clocks are
     * transmitted).
     */
    inline void clear_MAC_MDIO_ADDRESS_BTB() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 26u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's BTB bit.
     *
     * Back to Back transactions When this bit is set and the NTC has value
     * greater than 0, then the MAC informs the completion of a read or write
     * command at the end of frame transfer (before the trailing clocks are
     * transmitted).
     */
    inline void toggle_MAC_MDIO_ADDRESS_BTB() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 26u;
    }

    /**
     * Get MAC_MDIO_ADDRESS's PA field.
     *
     * Physical Layer Address This field indicates which Clause 22 PHY devices
     * (out of 32 devices) the MAC is accessing.
     */
    inline uint8_t get_MAC_MDIO_ADDRESS_PA() volatile
    {
        return (MAC_MDIO_ADDRESS >> 21u) & 0b11111u;
    }

    /**
     * Set MAC_MDIO_ADDRESS's PA field.
     *
     * Physical Layer Address This field indicates which Clause 22 PHY devices
     * (out of 32 devices) the MAC is accessing.
     */
    inline void set_MAC_MDIO_ADDRESS_PA(uint8_t value) volatile
    {
        uint32_t curr = MAC_MDIO_ADDRESS;

        curr &= ~(0b11111u << 21u);
        curr |= (value & 0b11111u) << 21u;

        MAC_MDIO_ADDRESS = curr;
    }

    /**
     * Get MAC_MDIO_ADDRESS's RDA field.
     *
     * Register/Device Address These bits select the PHY register in selected
     * Clause 22 PHY device.
     */
    inline uint8_t get_MAC_MDIO_ADDRESS_RDA() volatile
    {
        return (MAC_MDIO_ADDRESS >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_MDIO_ADDRESS's RDA field.
     *
     * Register/Device Address These bits select the PHY register in selected
     * Clause 22 PHY device.
     */
    inline void set_MAC_MDIO_ADDRESS_RDA(uint8_t value) volatile
    {
        uint32_t curr = MAC_MDIO_ADDRESS;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_MDIO_ADDRESS = curr;
    }

    /**
     * Get MAC_MDIO_ADDRESS's NTC field.
     *
     * Number of Trailing Clocks This field controls the number of trailing
     * clock cycles generated on gmii_mdc_o (MDC) after the end of transmission
     * of MDIO frame.
     */
    inline uint8_t get_MAC_MDIO_ADDRESS_NTC() volatile
    {
        return (MAC_MDIO_ADDRESS >> 12u) & 0b111u;
    }

    /**
     * Set MAC_MDIO_ADDRESS's NTC field.
     *
     * Number of Trailing Clocks This field controls the number of trailing
     * clock cycles generated on gmii_mdc_o (MDC) after the end of transmission
     * of MDIO frame.
     */
    inline void set_MAC_MDIO_ADDRESS_NTC(uint8_t value) volatile
    {
        uint32_t curr = MAC_MDIO_ADDRESS;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        MAC_MDIO_ADDRESS = curr;
    }

    /**
     * Get MAC_MDIO_ADDRESS's CR field.
     *
     * CSR Clock Range The CSR Clock Range selection determines the frequency
     * of the MDC clock according to the CSR clock frequency used in your
     * design: - 0000: CSR clock = 60-100 MHz; MDC clock = CSR clock/42 - 0001:
     * CSR clock = 100-150 MHz; MDC clock = CSR clock/62 - 0010: CSR clock =
     * 20-35 MHz; MDC clock = CSR clock/16 - 0011: CSR clock = 35-60 MHz; MDC
     * clock = CSR clock/26 - 0100: CSR clock = 150-250 MHz; MDC clock = CSR
     * clock/102 - 0101: CSR clock = 250-300 MHz; MDC clock = CSR clock/124 -
     * 0110: CSR clock = 300-500 MHz; MDC clock = CSR clock/204 - 0111: CSR
     * clock = 500-800 MHz; MDC clock = CSR clock/324 The suggested range of
     * CSR clock frequency applicable for each value (when Bit 11 = 0) ensures
     * that the MDC clock is approximately between 1.
     */
    inline uint8_t get_MAC_MDIO_ADDRESS_CR() volatile
    {
        return (MAC_MDIO_ADDRESS >> 8u) & 0b1111u;
    }

    /**
     * Set MAC_MDIO_ADDRESS's CR field.
     *
     * CSR Clock Range The CSR Clock Range selection determines the frequency
     * of the MDC clock according to the CSR clock frequency used in your
     * design: - 0000: CSR clock = 60-100 MHz; MDC clock = CSR clock/42 - 0001:
     * CSR clock = 100-150 MHz; MDC clock = CSR clock/62 - 0010: CSR clock =
     * 20-35 MHz; MDC clock = CSR clock/16 - 0011: CSR clock = 35-60 MHz; MDC
     * clock = CSR clock/26 - 0100: CSR clock = 150-250 MHz; MDC clock = CSR
     * clock/102 - 0101: CSR clock = 250-300 MHz; MDC clock = CSR clock/124 -
     * 0110: CSR clock = 300-500 MHz; MDC clock = CSR clock/204 - 0111: CSR
     * clock = 500-800 MHz; MDC clock = CSR clock/324 The suggested range of
     * CSR clock frequency applicable for each value (when Bit 11 = 0) ensures
     * that the MDC clock is approximately between 1.
     */
    inline void set_MAC_MDIO_ADDRESS_CR(uint8_t value) volatile
    {
        uint32_t curr = MAC_MDIO_ADDRESS;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MAC_MDIO_ADDRESS = curr;
    }

    /**
     * Get MAC_MDIO_ADDRESS's SKAP bit.
     *
     * Skip Address Packet When this bit is set, the SMA does not send the
     * address packets before read, write, or post-read increment address
     * packets.
     */
    inline bool get_MAC_MDIO_ADDRESS_SKAP() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 4u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's SKAP bit.
     *
     * Skip Address Packet When this bit is set, the SMA does not send the
     * address packets before read, write, or post-read increment address
     * packets.
     */
    inline void set_MAC_MDIO_ADDRESS_SKAP() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 4u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's SKAP bit.
     *
     * Skip Address Packet When this bit is set, the SMA does not send the
     * address packets before read, write, or post-read increment address
     * packets.
     */
    inline void clear_MAC_MDIO_ADDRESS_SKAP() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's SKAP bit.
     *
     * Skip Address Packet When this bit is set, the SMA does not send the
     * address packets before read, write, or post-read increment address
     * packets.
     */
    inline void toggle_MAC_MDIO_ADDRESS_SKAP() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 4u;
    }

    /**
     * Get MAC_MDIO_ADDRESS's GOC_1 bit.
     *
     * GMII Operation Command 1 This bit is higher bit of the operation command
     * to the PHY or RevMII, GOC_1 and GOC_O is encoded as follows: - 00:
     * Reserved - 01: Write - 10: Post Read Increment Address for Clause 45 PHY
     * - 11: Read When Clause 22 PHY or RevMII is enabled, only Write and Read
     * commands are valid.
     */
    inline bool get_MAC_MDIO_ADDRESS_GOC_1() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 3u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's GOC_1 bit.
     *
     * GMII Operation Command 1 This bit is higher bit of the operation command
     * to the PHY or RevMII, GOC_1 and GOC_O is encoded as follows: - 00:
     * Reserved - 01: Write - 10: Post Read Increment Address for Clause 45 PHY
     * - 11: Read When Clause 22 PHY or RevMII is enabled, only Write and Read
     * commands are valid.
     */
    inline void set_MAC_MDIO_ADDRESS_GOC_1() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 3u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's GOC_1 bit.
     *
     * GMII Operation Command 1 This bit is higher bit of the operation command
     * to the PHY or RevMII, GOC_1 and GOC_O is encoded as follows: - 00:
     * Reserved - 01: Write - 10: Post Read Increment Address for Clause 45 PHY
     * - 11: Read When Clause 22 PHY or RevMII is enabled, only Write and Read
     * commands are valid.
     */
    inline void clear_MAC_MDIO_ADDRESS_GOC_1() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's GOC_1 bit.
     *
     * GMII Operation Command 1 This bit is higher bit of the operation command
     * to the PHY or RevMII, GOC_1 and GOC_O is encoded as follows: - 00:
     * Reserved - 01: Write - 10: Post Read Increment Address for Clause 45 PHY
     * - 11: Read When Clause 22 PHY or RevMII is enabled, only Write and Read
     * commands are valid.
     */
    inline void toggle_MAC_MDIO_ADDRESS_GOC_1() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 3u;
    }

    /**
     * Get MAC_MDIO_ADDRESS's GOC_0 bit.
     *
     * GMII Operation Command 0 This is the lower bit of the operation command
     * to the PHY or RevMII.
     */
    inline bool get_MAC_MDIO_ADDRESS_GOC_0() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 2u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's GOC_0 bit.
     *
     * GMII Operation Command 0 This is the lower bit of the operation command
     * to the PHY or RevMII.
     */
    inline void set_MAC_MDIO_ADDRESS_GOC_0() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 2u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's GOC_0 bit.
     *
     * GMII Operation Command 0 This is the lower bit of the operation command
     * to the PHY or RevMII.
     */
    inline void clear_MAC_MDIO_ADDRESS_GOC_0() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's GOC_0 bit.
     *
     * GMII Operation Command 0 This is the lower bit of the operation command
     * to the PHY or RevMII.
     */
    inline void toggle_MAC_MDIO_ADDRESS_GOC_0() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 2u;
    }

    /**
     * Get MAC_MDIO_ADDRESS's C45E bit.
     *
     * Clause 45 PHY Enable When this bit is set, Clause 45 capable PHY is
     * connected to MDIO.
     */
    inline bool get_MAC_MDIO_ADDRESS_C45E() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 1u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's C45E bit.
     *
     * Clause 45 PHY Enable When this bit is set, Clause 45 capable PHY is
     * connected to MDIO.
     */
    inline void set_MAC_MDIO_ADDRESS_C45E() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 1u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's C45E bit.
     *
     * Clause 45 PHY Enable When this bit is set, Clause 45 capable PHY is
     * connected to MDIO.
     */
    inline void clear_MAC_MDIO_ADDRESS_C45E() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's C45E bit.
     *
     * Clause 45 PHY Enable When this bit is set, Clause 45 capable PHY is
     * connected to MDIO.
     */
    inline void toggle_MAC_MDIO_ADDRESS_C45E() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 1u;
    }

    /**
     * Get MAC_MDIO_ADDRESS's GB bit.
     *
     * GMII Busy The application sets this bit to instruct the SMA to initiate
     * a Read or Write access to the MDIO slave.
     */
    inline bool get_MAC_MDIO_ADDRESS_GB() volatile
    {
        return MAC_MDIO_ADDRESS & (1u << 0u);
    }

    /**
     * Set MAC_MDIO_ADDRESS's GB bit.
     *
     * GMII Busy The application sets this bit to instruct the SMA to initiate
     * a Read or Write access to the MDIO slave.
     */
    inline void set_MAC_MDIO_ADDRESS_GB() volatile
    {
        MAC_MDIO_ADDRESS |= 1u << 0u;
    }

    /**
     * Clear MAC_MDIO_ADDRESS's GB bit.
     *
     * GMII Busy The application sets this bit to instruct the SMA to initiate
     * a Read or Write access to the MDIO slave.
     */
    inline void clear_MAC_MDIO_ADDRESS_GB() volatile
    {
        MAC_MDIO_ADDRESS &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MDIO_ADDRESS's GB bit.
     *
     * GMII Busy The application sets this bit to instruct the SMA to initiate
     * a Read or Write access to the MDIO slave.
     */
    inline void toggle_MAC_MDIO_ADDRESS_GB() volatile
    {
        MAC_MDIO_ADDRESS ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MDIO_ADDRESS's bit fields.
     *
     * (read-write) MDIO Address
     */
    inline void get_MAC_MDIO_ADDRESS(bool &PSE, bool &BTB, uint8_t &PA,
                                     uint8_t &RDA, uint8_t &NTC, uint8_t &CR,
                                     bool &SKAP, bool &GOC_1, bool &GOC_0,
                                     bool &C45E, bool &GB) volatile
    {
        uint32_t curr = MAC_MDIO_ADDRESS;

        PSE = curr & (1u << 27u);
        BTB = curr & (1u << 26u);
        PA = (curr >> 21u) & 0b11111u;
        RDA = (curr >> 16u) & 0b11111u;
        NTC = (curr >> 12u) & 0b111u;
        CR = (curr >> 8u) & 0b1111u;
        SKAP = curr & (1u << 4u);
        GOC_1 = curr & (1u << 3u);
        GOC_0 = curr & (1u << 2u);
        C45E = curr & (1u << 1u);
        GB = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MDIO_ADDRESS's bit fields.
     *
     * (read-write) MDIO Address
     */
    inline void set_MAC_MDIO_ADDRESS(bool PSE, bool BTB, uint8_t PA,
                                     uint8_t RDA, uint8_t NTC, uint8_t CR,
                                     bool SKAP, bool GOC_1, bool GOC_0,
                                     bool C45E, bool GB) volatile
    {
        uint32_t curr = MAC_MDIO_ADDRESS;

        curr &= ~(0b1u << 27u);
        curr |= (PSE & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (BTB & 0b1u) << 26u;
        curr &= ~(0b11111u << 21u);
        curr |= (PA & 0b11111u) << 21u;
        curr &= ~(0b11111u << 16u);
        curr |= (RDA & 0b11111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (NTC & 0b111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (CR & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (SKAP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GOC_1 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GOC_0 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (C45E & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GB & 0b1u) << 0u;

        MAC_MDIO_ADDRESS = curr;
    }

    /**
     * Get MAC_MDIO_DATA's RA field.
     *
     * Register Address This field is valid only when C45E is set.
     */
    inline uint16_t get_MAC_MDIO_DATA_RA() volatile
    {
        return (MAC_MDIO_DATA >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_MDIO_DATA's RA field.
     *
     * Register Address This field is valid only when C45E is set.
     */
    inline void set_MAC_MDIO_DATA_RA(uint16_t value) volatile
    {
        uint32_t curr = MAC_MDIO_DATA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_MDIO_DATA = curr;
    }

    /**
     * Get MAC_MDIO_DATA's GD field.
     *
     * GMII Data This field contains the 16-bit data value read from the PHY or
     * RevMII after a Management Read operation or the 16-bit data value to be
     * written to the PHY or RevMII before a Management Write operation.
     */
    inline uint16_t get_MAC_MDIO_DATA_GD() volatile
    {
        return (MAC_MDIO_DATA >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_MDIO_DATA's GD field.
     *
     * GMII Data This field contains the 16-bit data value read from the PHY or
     * RevMII after a Management Read operation or the 16-bit data value to be
     * written to the PHY or RevMII before a Management Write operation.
     */
    inline void set_MAC_MDIO_DATA_GD(uint16_t value) volatile
    {
        uint32_t curr = MAC_MDIO_DATA;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_MDIO_DATA = curr;
    }

    /**
     * Get all of MAC_MDIO_DATA's bit fields.
     *
     * (read-write) MAC MDIO Data
     */
    inline void get_MAC_MDIO_DATA(uint16_t &RA, uint16_t &GD) volatile
    {
        uint32_t curr = MAC_MDIO_DATA;

        RA = (curr >> 16u) & 0b1111111111111111u;
        GD = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_MDIO_DATA's bit fields.
     *
     * (read-write) MAC MDIO Data
     */
    inline void set_MAC_MDIO_DATA(uint16_t RA, uint16_t GD) volatile
    {
        uint32_t curr = MAC_MDIO_DATA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (RA & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (GD & 0b1111111111111111u) << 0u;

        MAC_MDIO_DATA = curr;
    }

    /**
     * Get MAC_CSR_SW_CTRL's RCWE bit.
     *
     * Register Clear on Write 1 Enable When this bit is set, the access mode
     * of some register fields changes to Clear on Write 1, the application
     * needs to set that respective bit to 1 to clear it.
     */
    inline bool get_MAC_CSR_SW_CTRL_RCWE() volatile
    {
        return MAC_CSR_SW_CTRL & (1u << 0u);
    }

    /**
     * Set MAC_CSR_SW_CTRL's RCWE bit.
     *
     * Register Clear on Write 1 Enable When this bit is set, the access mode
     * of some register fields changes to Clear on Write 1, the application
     * needs to set that respective bit to 1 to clear it.
     */
    inline void set_MAC_CSR_SW_CTRL_RCWE() volatile
    {
        MAC_CSR_SW_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAC_CSR_SW_CTRL's RCWE bit.
     *
     * Register Clear on Write 1 Enable When this bit is set, the access mode
     * of some register fields changes to Clear on Write 1, the application
     * needs to set that respective bit to 1 to clear it.
     */
    inline void clear_MAC_CSR_SW_CTRL_RCWE() volatile
    {
        MAC_CSR_SW_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_CSR_SW_CTRL's RCWE bit.
     *
     * Register Clear on Write 1 Enable When this bit is set, the access mode
     * of some register fields changes to Clear on Write 1, the application
     * needs to set that respective bit to 1 to clear it.
     */
    inline void toggle_MAC_CSR_SW_CTRL_RCWE() volatile
    {
        MAC_CSR_SW_CTRL ^= 1u << 0u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's TRSP bit.
     *
     * Transmitted Respond Frame Set when a Respond mPacket is transmitted
     * (triggered by setting SRSP field).
     */
    inline bool get_MAC_FPE_CTRL_STS_TRSP() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 19u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's TRSP bit.
     *
     * Transmitted Respond Frame Set when a Respond mPacket is transmitted
     * (triggered by setting SRSP field).
     */
    inline void set_MAC_FPE_CTRL_STS_TRSP() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 19u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's TRSP bit.
     *
     * Transmitted Respond Frame Set when a Respond mPacket is transmitted
     * (triggered by setting SRSP field).
     */
    inline void clear_MAC_FPE_CTRL_STS_TRSP() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's TRSP bit.
     *
     * Transmitted Respond Frame Set when a Respond mPacket is transmitted
     * (triggered by setting SRSP field).
     */
    inline void toggle_MAC_FPE_CTRL_STS_TRSP() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 19u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's TVER bit.
     *
     * Transmitted Verify Frame Set when a Verify mPacket is transmitted
     * (triggered by setting SVER field).
     */
    inline bool get_MAC_FPE_CTRL_STS_TVER() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 18u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's TVER bit.
     *
     * Transmitted Verify Frame Set when a Verify mPacket is transmitted
     * (triggered by setting SVER field).
     */
    inline void set_MAC_FPE_CTRL_STS_TVER() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 18u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's TVER bit.
     *
     * Transmitted Verify Frame Set when a Verify mPacket is transmitted
     * (triggered by setting SVER field).
     */
    inline void clear_MAC_FPE_CTRL_STS_TVER() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's TVER bit.
     *
     * Transmitted Verify Frame Set when a Verify mPacket is transmitted
     * (triggered by setting SVER field).
     */
    inline void toggle_MAC_FPE_CTRL_STS_TVER() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 18u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's RRSP bit.
     *
     * Received Respond Frame Set when a Respond mPacket is received.
     */
    inline bool get_MAC_FPE_CTRL_STS_RRSP() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 17u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's RRSP bit.
     *
     * Received Respond Frame Set when a Respond mPacket is received.
     */
    inline void set_MAC_FPE_CTRL_STS_RRSP() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 17u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's RRSP bit.
     *
     * Received Respond Frame Set when a Respond mPacket is received.
     */
    inline void clear_MAC_FPE_CTRL_STS_RRSP() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's RRSP bit.
     *
     * Received Respond Frame Set when a Respond mPacket is received.
     */
    inline void toggle_MAC_FPE_CTRL_STS_RRSP() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 17u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's RVER bit.
     *
     * Received Verify Frame Set when a Verify mPacket is received.
     */
    inline bool get_MAC_FPE_CTRL_STS_RVER() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 16u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's RVER bit.
     *
     * Received Verify Frame Set when a Verify mPacket is received.
     */
    inline void set_MAC_FPE_CTRL_STS_RVER() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 16u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's RVER bit.
     *
     * Received Verify Frame Set when a Verify mPacket is received.
     */
    inline void clear_MAC_FPE_CTRL_STS_RVER() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's RVER bit.
     *
     * Received Verify Frame Set when a Verify mPacket is received.
     */
    inline void toggle_MAC_FPE_CTRL_STS_RVER() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 16u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's S1_SET_0 bit.
     *
     * Synopsys Reserved, Must be set to "0".
     */
    inline bool get_MAC_FPE_CTRL_STS_S1_SET_0() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 3u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's S1_SET_0 bit.
     *
     * Synopsys Reserved, Must be set to "0".
     */
    inline void set_MAC_FPE_CTRL_STS_S1_SET_0() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 3u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's S1_SET_0 bit.
     *
     * Synopsys Reserved, Must be set to "0".
     */
    inline void clear_MAC_FPE_CTRL_STS_S1_SET_0() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's S1_SET_0 bit.
     *
     * Synopsys Reserved, Must be set to "0".
     */
    inline void toggle_MAC_FPE_CTRL_STS_S1_SET_0() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 3u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's SRSP bit.
     *
     * Send Respond mPacket When set indicates hardware to send a Respond
     * mPacket.
     */
    inline bool get_MAC_FPE_CTRL_STS_SRSP() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 2u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's SRSP bit.
     *
     * Send Respond mPacket When set indicates hardware to send a Respond
     * mPacket.
     */
    inline void set_MAC_FPE_CTRL_STS_SRSP() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 2u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's SRSP bit.
     *
     * Send Respond mPacket When set indicates hardware to send a Respond
     * mPacket.
     */
    inline void clear_MAC_FPE_CTRL_STS_SRSP() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's SRSP bit.
     *
     * Send Respond mPacket When set indicates hardware to send a Respond
     * mPacket.
     */
    inline void toggle_MAC_FPE_CTRL_STS_SRSP() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 2u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's SVER bit.
     *
     * Send Verify mPacket When set indicates hardware to send a verify
     * mPacket.
     */
    inline bool get_MAC_FPE_CTRL_STS_SVER() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 1u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's SVER bit.
     *
     * Send Verify mPacket When set indicates hardware to send a verify
     * mPacket.
     */
    inline void set_MAC_FPE_CTRL_STS_SVER() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 1u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's SVER bit.
     *
     * Send Verify mPacket When set indicates hardware to send a verify
     * mPacket.
     */
    inline void clear_MAC_FPE_CTRL_STS_SVER() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's SVER bit.
     *
     * Send Verify mPacket When set indicates hardware to send a verify
     * mPacket.
     */
    inline void toggle_MAC_FPE_CTRL_STS_SVER() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 1u;
    }

    /**
     * Get MAC_FPE_CTRL_STS's EFPE bit.
     *
     * Enable Tx Frame Preemption When set Frame Preemption Tx functionality is
     * enabled.
     */
    inline bool get_MAC_FPE_CTRL_STS_EFPE() volatile
    {
        return MAC_FPE_CTRL_STS & (1u << 0u);
    }

    /**
     * Set MAC_FPE_CTRL_STS's EFPE bit.
     *
     * Enable Tx Frame Preemption When set Frame Preemption Tx functionality is
     * enabled.
     */
    inline void set_MAC_FPE_CTRL_STS_EFPE() volatile
    {
        MAC_FPE_CTRL_STS |= 1u << 0u;
    }

    /**
     * Clear MAC_FPE_CTRL_STS's EFPE bit.
     *
     * Enable Tx Frame Preemption When set Frame Preemption Tx functionality is
     * enabled.
     */
    inline void clear_MAC_FPE_CTRL_STS_EFPE() volatile
    {
        MAC_FPE_CTRL_STS &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_FPE_CTRL_STS's EFPE bit.
     *
     * Enable Tx Frame Preemption When set Frame Preemption Tx functionality is
     * enabled.
     */
    inline void toggle_MAC_FPE_CTRL_STS_EFPE() volatile
    {
        MAC_FPE_CTRL_STS ^= 1u << 0u;
    }

    /**
     * Get all of MAC_FPE_CTRL_STS's bit fields.
     *
     * (read-write) Frame Preemption Control
     */
    inline void get_MAC_FPE_CTRL_STS(bool &TRSP, bool &TVER, bool &RRSP,
                                     bool &RVER, bool &S1_SET_0, bool &SRSP,
                                     bool &SVER, bool &EFPE) volatile
    {
        uint32_t curr = MAC_FPE_CTRL_STS;

        TRSP = curr & (1u << 19u);
        TVER = curr & (1u << 18u);
        RRSP = curr & (1u << 17u);
        RVER = curr & (1u << 16u);
        S1_SET_0 = curr & (1u << 3u);
        SRSP = curr & (1u << 2u);
        SVER = curr & (1u << 1u);
        EFPE = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_FPE_CTRL_STS's bit fields.
     *
     * (read-write) Frame Preemption Control
     */
    inline void set_MAC_FPE_CTRL_STS(bool TRSP, bool TVER, bool RRSP,
                                     bool RVER, bool S1_SET_0, bool SRSP,
                                     bool SVER, bool EFPE) volatile
    {
        uint32_t curr = MAC_FPE_CTRL_STS;

        curr &= ~(0b1u << 19u);
        curr |= (TRSP & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (TVER & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RRSP & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RVER & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (S1_SET_0 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SRSP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SVER & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EFPE & 0b1u) << 0u;

        MAC_FPE_CTRL_STS = curr;
    }

    /**
     * Get MAC_PRESN_TIME_NS's MPTN field.
     *
     * MAC 1722 Presentation Time in ns These bits indicate the value of the
     * 32-bit binary rollover equivalent time of the PTP System Time in ns
     */
    inline uint32_t get_MAC_PRESN_TIME_NS_MPTN() volatile
    {
        return (MAC_PRESN_TIME_NS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_PRESN_TIME_UPDT's MPTU field.
     *
     * MAC 1722 Presentation Time Update This field holds the init value or the
     * update value for the presentation time.
     */
    inline uint32_t get_MAC_PRESN_TIME_UPDT_MPTU() volatile
    {
        return (MAC_PRESN_TIME_UPDT >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PRESN_TIME_UPDT's MPTU field.
     *
     * MAC 1722 Presentation Time Update This field holds the init value or the
     * update value for the presentation time.
     */
    inline void set_MAC_PRESN_TIME_UPDT_MPTU(uint32_t value) volatile
    {
        uint32_t curr = MAC_PRESN_TIME_UPDT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PRESN_TIME_UPDT = curr;
    }

    /**
     * Get MAC_ADDRESS0_HIGH's AE bit.
     *
     * Address Enable This bit is always set to 1.
     */
    inline bool get_MAC_ADDRESS0_HIGH_AE() volatile
    {
        return MAC_ADDRESS0_HIGH & (1u << 31u);
    }

    /**
     * Get MAC_ADDRESS0_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC Address0
     * content is routed.
     */
    inline uint8_t get_MAC_ADDRESS0_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS0_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS0_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC Address0
     * content is routed.
     */
    inline void set_MAC_ADDRESS0_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS0_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS0_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS0_HIGH's ADDRHI field.
     *
     * MAC Address0[47:32] This field contains the upper 16 bits [47:32] of the
     * first 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS0_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS0_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS0_HIGH's ADDRHI field.
     *
     * MAC Address0[47:32] This field contains the upper 16 bits [47:32] of the
     * first 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS0_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS0_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS0_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS0_HIGH's bit fields.
     *
     * (read-write) MAC Address0 High
     */
    inline void get_MAC_ADDRESS0_HIGH(bool &AE, uint8_t &DCS,
                                      uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS0_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS0_HIGH's bit fields.
     *
     * (read-write) MAC Address0 High
     */
    inline void set_MAC_ADDRESS0_HIGH(uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS0_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS0_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS0_LOW's ADDRLO field.
     *
     * MAC Address0[31:0] This field contains the lower 32 bits of the first
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS0_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS0_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS0_LOW's ADDRLO field.
     *
     * MAC Address0[31:0] This field contains the lower 32 bits of the first
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS0_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS0_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS0_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS1_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS1_HIGH_AE() volatile
    {
        return MAC_ADDRESS1_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS1_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS1_HIGH_AE() volatile
    {
        MAC_ADDRESS1_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS1_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS1_HIGH_AE() volatile
    {
        MAC_ADDRESS1_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS1_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS1_HIGH_AE() volatile
    {
        MAC_ADDRESS1_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS1_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS1_HIGH_SA() volatile
    {
        return MAC_ADDRESS1_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS1_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS1_HIGH_SA() volatile
    {
        MAC_ADDRESS1_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS1_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS1_HIGH_SA() volatile
    {
        MAC_ADDRESS1_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS1_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS1_HIGH_SA() volatile
    {
        MAC_ADDRESS1_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS1_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS1_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS1_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS1_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS1_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS1_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS1_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS1_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS1_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS1_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS1_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS1_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS1_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS1_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS1_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS1_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS1_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS1_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS1_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS1_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS1_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS1_HIGH's bit fields.
     *
     * (read-write) MAC Address1 High
     */
    inline void get_MAC_ADDRESS1_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS1_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS1_HIGH's bit fields.
     *
     * (read-write) MAC Address1 High
     */
    inline void set_MAC_ADDRESS1_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS1_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS1_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS1_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS1_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS1_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS1_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS1_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS1_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS1_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS2_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS2_HIGH_AE() volatile
    {
        return MAC_ADDRESS2_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS2_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS2_HIGH_AE() volatile
    {
        MAC_ADDRESS2_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS2_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS2_HIGH_AE() volatile
    {
        MAC_ADDRESS2_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS2_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS2_HIGH_AE() volatile
    {
        MAC_ADDRESS2_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS2_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS2_HIGH_SA() volatile
    {
        return MAC_ADDRESS2_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS2_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS2_HIGH_SA() volatile
    {
        MAC_ADDRESS2_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS2_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS2_HIGH_SA() volatile
    {
        MAC_ADDRESS2_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS2_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS2_HIGH_SA() volatile
    {
        MAC_ADDRESS2_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS2_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS2_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS2_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS2_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS2_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS2_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS2_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS2_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS2_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS2_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS2_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS2_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS2_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS2_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS2_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS2_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS2_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS2_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS2_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS2_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS2_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS2_HIGH's bit fields.
     *
     * (read-write) MAC Address2 High
     */
    inline void get_MAC_ADDRESS2_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS2_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS2_HIGH's bit fields.
     *
     * (read-write) MAC Address2 High
     */
    inline void set_MAC_ADDRESS2_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS2_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS2_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS2_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS2_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS2_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS2_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS2_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS2_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS2_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS3_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS3_HIGH_AE() volatile
    {
        return MAC_ADDRESS3_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS3_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS3_HIGH_AE() volatile
    {
        MAC_ADDRESS3_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS3_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS3_HIGH_AE() volatile
    {
        MAC_ADDRESS3_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS3_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS3_HIGH_AE() volatile
    {
        MAC_ADDRESS3_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS3_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS3_HIGH_SA() volatile
    {
        return MAC_ADDRESS3_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS3_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS3_HIGH_SA() volatile
    {
        MAC_ADDRESS3_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS3_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS3_HIGH_SA() volatile
    {
        MAC_ADDRESS3_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS3_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS3_HIGH_SA() volatile
    {
        MAC_ADDRESS3_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS3_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS3_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS3_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS3_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS3_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS3_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS3_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS3_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS3_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS3_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS3_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS3_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS3_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS3_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS3_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS3_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS3_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS3_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS3_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS3_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS3_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS3_HIGH's bit fields.
     *
     * (read-write) MAC Address3 High
     */
    inline void get_MAC_ADDRESS3_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS3_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS3_HIGH's bit fields.
     *
     * (read-write) MAC Address3 High
     */
    inline void set_MAC_ADDRESS3_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS3_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS3_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS3_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS3_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS3_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS3_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS3_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS3_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS3_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS4_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS4_HIGH_AE() volatile
    {
        return MAC_ADDRESS4_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS4_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS4_HIGH_AE() volatile
    {
        MAC_ADDRESS4_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS4_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS4_HIGH_AE() volatile
    {
        MAC_ADDRESS4_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS4_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS4_HIGH_AE() volatile
    {
        MAC_ADDRESS4_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS4_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS4_HIGH_SA() volatile
    {
        return MAC_ADDRESS4_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS4_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS4_HIGH_SA() volatile
    {
        MAC_ADDRESS4_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS4_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS4_HIGH_SA() volatile
    {
        MAC_ADDRESS4_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS4_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS4_HIGH_SA() volatile
    {
        MAC_ADDRESS4_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS4_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS4_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS4_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS4_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS4_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS4_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS4_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS4_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS4_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS4_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS4_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS4_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS4_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS4_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS4_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS4_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS4_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS4_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS4_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS4_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS4_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS4_HIGH's bit fields.
     *
     * (read-write) MAC Address4 High
     */
    inline void get_MAC_ADDRESS4_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS4_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS4_HIGH's bit fields.
     *
     * (read-write) MAC Address4 High
     */
    inline void set_MAC_ADDRESS4_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS4_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS4_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS4_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS4_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS4_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS4_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS4_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS4_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS4_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS5_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS5_HIGH_AE() volatile
    {
        return MAC_ADDRESS5_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS5_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS5_HIGH_AE() volatile
    {
        MAC_ADDRESS5_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS5_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS5_HIGH_AE() volatile
    {
        MAC_ADDRESS5_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS5_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS5_HIGH_AE() volatile
    {
        MAC_ADDRESS5_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS5_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS5_HIGH_SA() volatile
    {
        return MAC_ADDRESS5_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS5_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS5_HIGH_SA() volatile
    {
        MAC_ADDRESS5_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS5_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS5_HIGH_SA() volatile
    {
        MAC_ADDRESS5_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS5_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS5_HIGH_SA() volatile
    {
        MAC_ADDRESS5_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS5_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS5_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS5_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS5_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS5_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS5_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS5_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS5_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS5_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS5_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS5_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS5_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS5_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS5_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS5_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS5_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS5_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS5_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS5_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS5_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS5_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS5_HIGH's bit fields.
     *
     * (read-write) MAC Address5 High
     */
    inline void get_MAC_ADDRESS5_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS5_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS5_HIGH's bit fields.
     *
     * (read-write) MAC Address5 High
     */
    inline void set_MAC_ADDRESS5_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS5_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS5_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS5_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS5_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS5_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS5_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS5_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS5_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS5_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS6_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS6_HIGH_AE() volatile
    {
        return MAC_ADDRESS6_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS6_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS6_HIGH_AE() volatile
    {
        MAC_ADDRESS6_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS6_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS6_HIGH_AE() volatile
    {
        MAC_ADDRESS6_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS6_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS6_HIGH_AE() volatile
    {
        MAC_ADDRESS6_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS6_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS6_HIGH_SA() volatile
    {
        return MAC_ADDRESS6_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS6_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS6_HIGH_SA() volatile
    {
        MAC_ADDRESS6_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS6_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS6_HIGH_SA() volatile
    {
        MAC_ADDRESS6_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS6_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS6_HIGH_SA() volatile
    {
        MAC_ADDRESS6_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS6_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS6_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS6_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS6_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS6_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS6_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS6_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS6_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS6_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS6_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS6_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS6_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS6_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS6_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS6_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS6_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS6_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS6_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS6_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS6_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS6_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS6_HIGH's bit fields.
     *
     * (read-write) MAC Address6 High
     */
    inline void get_MAC_ADDRESS6_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS6_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS6_HIGH's bit fields.
     *
     * (read-write) MAC Address6 High
     */
    inline void set_MAC_ADDRESS6_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS6_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS6_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS6_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS6_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS6_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS6_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS6_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS6_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS6_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS7_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS7_HIGH_AE() volatile
    {
        return MAC_ADDRESS7_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS7_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS7_HIGH_AE() volatile
    {
        MAC_ADDRESS7_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS7_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS7_HIGH_AE() volatile
    {
        MAC_ADDRESS7_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS7_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS7_HIGH_AE() volatile
    {
        MAC_ADDRESS7_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS7_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS7_HIGH_SA() volatile
    {
        return MAC_ADDRESS7_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS7_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS7_HIGH_SA() volatile
    {
        MAC_ADDRESS7_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS7_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS7_HIGH_SA() volatile
    {
        MAC_ADDRESS7_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS7_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS7_HIGH_SA() volatile
    {
        MAC_ADDRESS7_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS7_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS7_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS7_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS7_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS7_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS7_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS7_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS7_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS7_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS7_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS7_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS7_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS7_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS7_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS7_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS7_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS7_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS7_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS7_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS7_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS7_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS7_HIGH's bit fields.
     *
     * (read-write) MAC Address7 High
     */
    inline void get_MAC_ADDRESS7_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS7_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS7_HIGH's bit fields.
     *
     * (read-write) MAC Address7 High
     */
    inline void set_MAC_ADDRESS7_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS7_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS7_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS7_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS7_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS7_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS7_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS7_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS7_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS7_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS8_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS8_HIGH_AE() volatile
    {
        return MAC_ADDRESS8_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS8_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS8_HIGH_AE() volatile
    {
        MAC_ADDRESS8_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS8_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS8_HIGH_AE() volatile
    {
        MAC_ADDRESS8_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS8_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS8_HIGH_AE() volatile
    {
        MAC_ADDRESS8_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS8_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS8_HIGH_SA() volatile
    {
        return MAC_ADDRESS8_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS8_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS8_HIGH_SA() volatile
    {
        MAC_ADDRESS8_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS8_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS8_HIGH_SA() volatile
    {
        MAC_ADDRESS8_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS8_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS8_HIGH_SA() volatile
    {
        MAC_ADDRESS8_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS8_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS8_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS8_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS8_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS8_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS8_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS8_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS8_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS8_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS8_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS8_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS8_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS8_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS8_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS8_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS8_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS8_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS8_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS8_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS8_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS8_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS8_HIGH's bit fields.
     *
     * (read-write) MAC Address8 High
     */
    inline void get_MAC_ADDRESS8_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS8_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS8_HIGH's bit fields.
     *
     * (read-write) MAC Address8 High
     */
    inline void set_MAC_ADDRESS8_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS8_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS8_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS8_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS8_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS8_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS8_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS8_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS8_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS8_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS9_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS9_HIGH_AE() volatile
    {
        return MAC_ADDRESS9_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS9_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS9_HIGH_AE() volatile
    {
        MAC_ADDRESS9_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS9_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS9_HIGH_AE() volatile
    {
        MAC_ADDRESS9_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS9_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS9_HIGH_AE() volatile
    {
        MAC_ADDRESS9_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS9_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS9_HIGH_SA() volatile
    {
        return MAC_ADDRESS9_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS9_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS9_HIGH_SA() volatile
    {
        MAC_ADDRESS9_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS9_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS9_HIGH_SA() volatile
    {
        MAC_ADDRESS9_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS9_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS9_HIGH_SA() volatile
    {
        MAC_ADDRESS9_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS9_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS9_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS9_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS9_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS9_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS9_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS9_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS9_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS9_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS9_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS9_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS9_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS9_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS9_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS9_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS9_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS9_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS9_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS9_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS9_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS9_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS9_HIGH's bit fields.
     *
     * (read-write) MAC Address9 High
     */
    inline void get_MAC_ADDRESS9_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                      uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS9_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS9_HIGH's bit fields.
     *
     * (read-write) MAC Address9 High
     */
    inline void set_MAC_ADDRESS9_HIGH(bool AE, bool SA, uint8_t MBC,
                                      uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS9_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS9_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS9_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS9_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS9_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS9_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS9_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS9_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS9_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS10_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS10_HIGH_AE() volatile
    {
        return MAC_ADDRESS10_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS10_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS10_HIGH_AE() volatile
    {
        MAC_ADDRESS10_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS10_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS10_HIGH_AE() volatile
    {
        MAC_ADDRESS10_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS10_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS10_HIGH_AE() volatile
    {
        MAC_ADDRESS10_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS10_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS10_HIGH_SA() volatile
    {
        return MAC_ADDRESS10_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS10_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS10_HIGH_SA() volatile
    {
        MAC_ADDRESS10_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS10_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS10_HIGH_SA() volatile
    {
        MAC_ADDRESS10_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS10_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS10_HIGH_SA() volatile
    {
        MAC_ADDRESS10_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS10_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS10_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS10_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS10_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS10_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS10_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS10_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS10_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS10_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS10_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS10_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS10_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS10_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS10_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS10_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS10_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS10_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS10_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS10_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS10_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS10_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS10_HIGH's bit fields.
     *
     * (read-write) MAC Address10 High
     */
    inline void get_MAC_ADDRESS10_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS10_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS10_HIGH's bit fields.
     *
     * (read-write) MAC Address10 High
     */
    inline void set_MAC_ADDRESS10_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS10_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS10_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS10_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS10_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS10_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS10_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS10_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS10_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS10_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS11_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS11_HIGH_AE() volatile
    {
        return MAC_ADDRESS11_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS11_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS11_HIGH_AE() volatile
    {
        MAC_ADDRESS11_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS11_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS11_HIGH_AE() volatile
    {
        MAC_ADDRESS11_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS11_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS11_HIGH_AE() volatile
    {
        MAC_ADDRESS11_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS11_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS11_HIGH_SA() volatile
    {
        return MAC_ADDRESS11_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS11_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS11_HIGH_SA() volatile
    {
        MAC_ADDRESS11_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS11_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS11_HIGH_SA() volatile
    {
        MAC_ADDRESS11_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS11_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS11_HIGH_SA() volatile
    {
        MAC_ADDRESS11_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS11_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS11_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS11_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS11_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS11_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS11_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS11_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS11_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS11_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS11_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS11_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS11_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS11_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS11_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS11_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS11_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS11_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS11_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS11_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS11_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS11_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS11_HIGH's bit fields.
     *
     * (read-write) MAC Address11 High
     */
    inline void get_MAC_ADDRESS11_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS11_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS11_HIGH's bit fields.
     *
     * (read-write) MAC Address11 High
     */
    inline void set_MAC_ADDRESS11_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS11_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS11_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS11_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS11_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS11_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS11_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS11_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS11_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS11_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS12_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS12_HIGH_AE() volatile
    {
        return MAC_ADDRESS12_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS12_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS12_HIGH_AE() volatile
    {
        MAC_ADDRESS12_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS12_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS12_HIGH_AE() volatile
    {
        MAC_ADDRESS12_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS12_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS12_HIGH_AE() volatile
    {
        MAC_ADDRESS12_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS12_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS12_HIGH_SA() volatile
    {
        return MAC_ADDRESS12_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS12_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS12_HIGH_SA() volatile
    {
        MAC_ADDRESS12_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS12_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS12_HIGH_SA() volatile
    {
        MAC_ADDRESS12_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS12_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS12_HIGH_SA() volatile
    {
        MAC_ADDRESS12_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS12_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS12_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS12_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS12_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS12_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS12_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS12_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS12_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS12_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS12_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS12_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS12_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS12_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS12_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS12_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS12_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS12_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS12_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS12_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS12_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS12_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS12_HIGH's bit fields.
     *
     * (read-write) MAC Address12 High
     */
    inline void get_MAC_ADDRESS12_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS12_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS12_HIGH's bit fields.
     *
     * (read-write) MAC Address12 High
     */
    inline void set_MAC_ADDRESS12_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS12_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS12_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS12_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS12_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS12_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS12_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS12_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS12_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS12_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS13_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS13_HIGH_AE() volatile
    {
        return MAC_ADDRESS13_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS13_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS13_HIGH_AE() volatile
    {
        MAC_ADDRESS13_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS13_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS13_HIGH_AE() volatile
    {
        MAC_ADDRESS13_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS13_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS13_HIGH_AE() volatile
    {
        MAC_ADDRESS13_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS13_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS13_HIGH_SA() volatile
    {
        return MAC_ADDRESS13_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS13_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS13_HIGH_SA() volatile
    {
        MAC_ADDRESS13_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS13_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS13_HIGH_SA() volatile
    {
        MAC_ADDRESS13_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS13_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS13_HIGH_SA() volatile
    {
        MAC_ADDRESS13_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS13_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS13_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS13_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS13_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS13_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS13_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS13_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS13_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS13_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS13_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS13_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS13_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS13_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS13_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS13_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS13_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS13_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS13_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS13_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS13_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS13_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS13_HIGH's bit fields.
     *
     * (read-write) MAC Address13 High
     */
    inline void get_MAC_ADDRESS13_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS13_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS13_HIGH's bit fields.
     *
     * (read-write) MAC Address13 High
     */
    inline void set_MAC_ADDRESS13_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS13_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS13_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS13_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS13_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS13_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS13_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS13_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS13_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS13_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS14_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS14_HIGH_AE() volatile
    {
        return MAC_ADDRESS14_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS14_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS14_HIGH_AE() volatile
    {
        MAC_ADDRESS14_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS14_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS14_HIGH_AE() volatile
    {
        MAC_ADDRESS14_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS14_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS14_HIGH_AE() volatile
    {
        MAC_ADDRESS14_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS14_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS14_HIGH_SA() volatile
    {
        return MAC_ADDRESS14_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS14_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS14_HIGH_SA() volatile
    {
        MAC_ADDRESS14_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS14_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS14_HIGH_SA() volatile
    {
        MAC_ADDRESS14_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS14_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS14_HIGH_SA() volatile
    {
        MAC_ADDRESS14_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS14_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS14_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS14_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS14_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS14_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS14_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS14_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS14_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS14_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS14_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS14_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS14_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS14_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS14_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS14_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS14_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS14_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS14_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS14_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS14_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS14_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS14_HIGH's bit fields.
     *
     * (read-write) MAC Address14 High
     */
    inline void get_MAC_ADDRESS14_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS14_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS14_HIGH's bit fields.
     *
     * (read-write) MAC Address14 High
     */
    inline void set_MAC_ADDRESS14_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS14_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS14_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS14_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS14_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS14_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS14_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS14_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS14_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS14_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS15_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS15_HIGH_AE() volatile
    {
        return MAC_ADDRESS15_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS15_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS15_HIGH_AE() volatile
    {
        MAC_ADDRESS15_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS15_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS15_HIGH_AE() volatile
    {
        MAC_ADDRESS15_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS15_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS15_HIGH_AE() volatile
    {
        MAC_ADDRESS15_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS15_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS15_HIGH_SA() volatile
    {
        return MAC_ADDRESS15_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS15_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS15_HIGH_SA() volatile
    {
        MAC_ADDRESS15_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS15_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS15_HIGH_SA() volatile
    {
        MAC_ADDRESS15_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS15_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS15_HIGH_SA() volatile
    {
        MAC_ADDRESS15_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS15_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS15_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS15_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS15_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS15_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS15_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS15_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS15_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS15_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS15_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS15_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS15_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS15_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS15_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS15_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS15_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS15_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS15_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS15_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS15_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS15_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS15_HIGH's bit fields.
     *
     * (read-write) MAC Address15 High
     */
    inline void get_MAC_ADDRESS15_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS15_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS15_HIGH's bit fields.
     *
     * (read-write) MAC Address15 High
     */
    inline void set_MAC_ADDRESS15_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS15_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS15_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS15_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS15_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS15_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS15_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS15_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS15_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS15_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS16_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS16_HIGH_AE() volatile
    {
        return MAC_ADDRESS16_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS16_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS16_HIGH_AE() volatile
    {
        MAC_ADDRESS16_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS16_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS16_HIGH_AE() volatile
    {
        MAC_ADDRESS16_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS16_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS16_HIGH_AE() volatile
    {
        MAC_ADDRESS16_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS16_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS16_HIGH_SA() volatile
    {
        return MAC_ADDRESS16_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS16_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS16_HIGH_SA() volatile
    {
        MAC_ADDRESS16_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS16_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS16_HIGH_SA() volatile
    {
        MAC_ADDRESS16_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS16_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS16_HIGH_SA() volatile
    {
        MAC_ADDRESS16_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS16_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS16_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS16_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS16_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS16_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS16_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS16_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS16_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS16_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS16_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS16_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS16_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS16_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS16_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS16_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS16_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS16_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS16_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS16_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS16_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS16_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS16_HIGH's bit fields.
     *
     * (read-write) MAC Address16 High
     */
    inline void get_MAC_ADDRESS16_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS16_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS16_HIGH's bit fields.
     *
     * (read-write) MAC Address16 High
     */
    inline void set_MAC_ADDRESS16_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS16_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS16_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS16_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS16_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS16_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS16_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS16_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS16_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS16_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS17_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS17_HIGH_AE() volatile
    {
        return MAC_ADDRESS17_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS17_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS17_HIGH_AE() volatile
    {
        MAC_ADDRESS17_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS17_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS17_HIGH_AE() volatile
    {
        MAC_ADDRESS17_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS17_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS17_HIGH_AE() volatile
    {
        MAC_ADDRESS17_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS17_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS17_HIGH_SA() volatile
    {
        return MAC_ADDRESS17_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS17_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS17_HIGH_SA() volatile
    {
        MAC_ADDRESS17_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS17_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS17_HIGH_SA() volatile
    {
        MAC_ADDRESS17_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS17_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS17_HIGH_SA() volatile
    {
        MAC_ADDRESS17_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS17_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS17_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS17_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS17_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS17_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS17_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS17_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS17_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS17_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS17_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS17_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS17_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS17_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS17_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS17_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS17_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS17_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS17_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS17_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS17_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS17_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS17_HIGH's bit fields.
     *
     * (read-write) MAC Address17 High
     */
    inline void get_MAC_ADDRESS17_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS17_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS17_HIGH's bit fields.
     *
     * (read-write) MAC Address17 High
     */
    inline void set_MAC_ADDRESS17_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS17_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS17_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS17_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS17_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS17_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS17_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS17_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS17_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS17_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS18_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS18_HIGH_AE() volatile
    {
        return MAC_ADDRESS18_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS18_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS18_HIGH_AE() volatile
    {
        MAC_ADDRESS18_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS18_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS18_HIGH_AE() volatile
    {
        MAC_ADDRESS18_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS18_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS18_HIGH_AE() volatile
    {
        MAC_ADDRESS18_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS18_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS18_HIGH_SA() volatile
    {
        return MAC_ADDRESS18_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS18_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS18_HIGH_SA() volatile
    {
        MAC_ADDRESS18_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS18_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS18_HIGH_SA() volatile
    {
        MAC_ADDRESS18_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS18_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS18_HIGH_SA() volatile
    {
        MAC_ADDRESS18_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS18_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS18_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS18_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS18_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS18_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS18_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS18_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS18_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS18_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS18_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS18_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS18_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS18_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS18_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS18_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS18_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS18_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS18_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS18_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS18_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS18_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS18_HIGH's bit fields.
     *
     * (read-write) MAC Address18 High
     */
    inline void get_MAC_ADDRESS18_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS18_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS18_HIGH's bit fields.
     *
     * (read-write) MAC Address18 High
     */
    inline void set_MAC_ADDRESS18_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS18_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS18_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS18_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS18_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS18_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS18_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS18_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS18_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS18_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS19_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS19_HIGH_AE() volatile
    {
        return MAC_ADDRESS19_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS19_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS19_HIGH_AE() volatile
    {
        MAC_ADDRESS19_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS19_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS19_HIGH_AE() volatile
    {
        MAC_ADDRESS19_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS19_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS19_HIGH_AE() volatile
    {
        MAC_ADDRESS19_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS19_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS19_HIGH_SA() volatile
    {
        return MAC_ADDRESS19_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS19_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS19_HIGH_SA() volatile
    {
        MAC_ADDRESS19_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS19_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS19_HIGH_SA() volatile
    {
        MAC_ADDRESS19_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS19_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS19_HIGH_SA() volatile
    {
        MAC_ADDRESS19_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS19_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS19_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS19_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS19_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS19_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS19_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS19_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS19_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS19_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS19_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS19_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS19_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS19_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS19_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS19_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS19_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS19_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS19_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS19_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS19_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS19_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS19_HIGH's bit fields.
     *
     * (read-write) MAC Address19 High
     */
    inline void get_MAC_ADDRESS19_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS19_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS19_HIGH's bit fields.
     *
     * (read-write) MAC Address19 High
     */
    inline void set_MAC_ADDRESS19_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS19_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS19_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS19_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS19_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS19_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS19_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS19_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS19_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS19_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS20_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS20_HIGH_AE() volatile
    {
        return MAC_ADDRESS20_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS20_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS20_HIGH_AE() volatile
    {
        MAC_ADDRESS20_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS20_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS20_HIGH_AE() volatile
    {
        MAC_ADDRESS20_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS20_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS20_HIGH_AE() volatile
    {
        MAC_ADDRESS20_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS20_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS20_HIGH_SA() volatile
    {
        return MAC_ADDRESS20_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS20_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS20_HIGH_SA() volatile
    {
        MAC_ADDRESS20_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS20_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS20_HIGH_SA() volatile
    {
        MAC_ADDRESS20_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS20_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS20_HIGH_SA() volatile
    {
        MAC_ADDRESS20_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS20_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS20_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS20_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS20_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS20_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS20_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS20_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS20_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS20_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS20_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS20_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS20_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS20_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS20_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS20_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS20_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS20_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS20_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS20_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS20_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS20_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS20_HIGH's bit fields.
     *
     * (read-write) MAC Address20 High
     */
    inline void get_MAC_ADDRESS20_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS20_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS20_HIGH's bit fields.
     *
     * (read-write) MAC Address20 High
     */
    inline void set_MAC_ADDRESS20_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS20_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS20_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS20_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS20_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS20_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS20_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS20_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS20_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS20_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS21_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS21_HIGH_AE() volatile
    {
        return MAC_ADDRESS21_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS21_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS21_HIGH_AE() volatile
    {
        MAC_ADDRESS21_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS21_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS21_HIGH_AE() volatile
    {
        MAC_ADDRESS21_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS21_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS21_HIGH_AE() volatile
    {
        MAC_ADDRESS21_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS21_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS21_HIGH_SA() volatile
    {
        return MAC_ADDRESS21_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS21_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS21_HIGH_SA() volatile
    {
        MAC_ADDRESS21_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS21_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS21_HIGH_SA() volatile
    {
        MAC_ADDRESS21_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS21_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS21_HIGH_SA() volatile
    {
        MAC_ADDRESS21_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS21_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS21_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS21_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS21_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS21_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS21_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS21_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS21_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS21_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS21_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS21_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS21_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS21_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS21_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS21_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS21_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS21_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS21_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS21_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS21_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS21_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS21_HIGH's bit fields.
     *
     * (read-write) MAC Address21 High
     */
    inline void get_MAC_ADDRESS21_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS21_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS21_HIGH's bit fields.
     *
     * (read-write) MAC Address21 High
     */
    inline void set_MAC_ADDRESS21_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS21_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS21_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS21_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS21_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS21_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS21_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS21_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS21_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS21_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS22_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS22_HIGH_AE() volatile
    {
        return MAC_ADDRESS22_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS22_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS22_HIGH_AE() volatile
    {
        MAC_ADDRESS22_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS22_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS22_HIGH_AE() volatile
    {
        MAC_ADDRESS22_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS22_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS22_HIGH_AE() volatile
    {
        MAC_ADDRESS22_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS22_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS22_HIGH_SA() volatile
    {
        return MAC_ADDRESS22_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS22_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS22_HIGH_SA() volatile
    {
        MAC_ADDRESS22_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS22_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS22_HIGH_SA() volatile
    {
        MAC_ADDRESS22_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS22_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS22_HIGH_SA() volatile
    {
        MAC_ADDRESS22_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS22_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS22_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS22_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS22_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS22_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS22_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS22_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS22_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS22_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS22_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS22_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS22_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS22_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS22_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS22_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS22_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS22_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS22_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS22_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS22_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS22_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS22_HIGH's bit fields.
     *
     * (read-write) MAC Address22 High
     */
    inline void get_MAC_ADDRESS22_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS22_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS22_HIGH's bit fields.
     *
     * (read-write) MAC Address22 High
     */
    inline void set_MAC_ADDRESS22_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS22_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS22_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS22_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS22_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS22_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS22_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS22_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS22_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS22_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS23_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS23_HIGH_AE() volatile
    {
        return MAC_ADDRESS23_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS23_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS23_HIGH_AE() volatile
    {
        MAC_ADDRESS23_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS23_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS23_HIGH_AE() volatile
    {
        MAC_ADDRESS23_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS23_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS23_HIGH_AE() volatile
    {
        MAC_ADDRESS23_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS23_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS23_HIGH_SA() volatile
    {
        return MAC_ADDRESS23_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS23_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS23_HIGH_SA() volatile
    {
        MAC_ADDRESS23_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS23_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS23_HIGH_SA() volatile
    {
        MAC_ADDRESS23_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS23_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS23_HIGH_SA() volatile
    {
        MAC_ADDRESS23_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS23_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS23_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS23_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS23_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS23_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS23_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS23_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS23_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS23_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS23_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS23_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS23_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS23_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS23_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS23_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS23_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS23_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS23_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS23_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS23_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS23_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS23_HIGH's bit fields.
     *
     * (read-write) MAC Address23 High
     */
    inline void get_MAC_ADDRESS23_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS23_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS23_HIGH's bit fields.
     *
     * (read-write) MAC Address23 High
     */
    inline void set_MAC_ADDRESS23_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS23_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS23_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS23_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS23_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS23_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS23_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS23_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS23_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS23_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS24_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS24_HIGH_AE() volatile
    {
        return MAC_ADDRESS24_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS24_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS24_HIGH_AE() volatile
    {
        MAC_ADDRESS24_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS24_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS24_HIGH_AE() volatile
    {
        MAC_ADDRESS24_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS24_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS24_HIGH_AE() volatile
    {
        MAC_ADDRESS24_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS24_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS24_HIGH_SA() volatile
    {
        return MAC_ADDRESS24_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS24_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS24_HIGH_SA() volatile
    {
        MAC_ADDRESS24_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS24_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS24_HIGH_SA() volatile
    {
        MAC_ADDRESS24_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS24_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS24_HIGH_SA() volatile
    {
        MAC_ADDRESS24_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS24_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS24_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS24_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS24_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS24_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS24_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS24_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS24_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS24_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS24_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS24_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS24_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS24_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS24_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS24_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS24_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS24_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS24_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS24_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS24_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS24_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS24_HIGH's bit fields.
     *
     * (read-write) MAC Address24 High
     */
    inline void get_MAC_ADDRESS24_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS24_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS24_HIGH's bit fields.
     *
     * (read-write) MAC Address24 High
     */
    inline void set_MAC_ADDRESS24_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS24_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS24_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS24_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS24_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS24_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS24_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS24_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS24_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS24_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS25_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS25_HIGH_AE() volatile
    {
        return MAC_ADDRESS25_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS25_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS25_HIGH_AE() volatile
    {
        MAC_ADDRESS25_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS25_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS25_HIGH_AE() volatile
    {
        MAC_ADDRESS25_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS25_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS25_HIGH_AE() volatile
    {
        MAC_ADDRESS25_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS25_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS25_HIGH_SA() volatile
    {
        return MAC_ADDRESS25_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS25_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS25_HIGH_SA() volatile
    {
        MAC_ADDRESS25_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS25_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS25_HIGH_SA() volatile
    {
        MAC_ADDRESS25_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS25_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS25_HIGH_SA() volatile
    {
        MAC_ADDRESS25_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS25_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS25_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS25_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS25_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS25_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS25_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS25_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS25_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS25_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS25_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS25_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS25_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS25_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS25_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS25_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS25_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS25_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS25_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS25_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS25_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS25_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS25_HIGH's bit fields.
     *
     * (read-write) MAC Address25 High
     */
    inline void get_MAC_ADDRESS25_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS25_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS25_HIGH's bit fields.
     *
     * (read-write) MAC Address25 High
     */
    inline void set_MAC_ADDRESS25_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS25_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS25_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS25_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS25_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS25_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS25_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS25_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS25_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS25_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS26_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS26_HIGH_AE() volatile
    {
        return MAC_ADDRESS26_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS26_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS26_HIGH_AE() volatile
    {
        MAC_ADDRESS26_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS26_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS26_HIGH_AE() volatile
    {
        MAC_ADDRESS26_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS26_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS26_HIGH_AE() volatile
    {
        MAC_ADDRESS26_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS26_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS26_HIGH_SA() volatile
    {
        return MAC_ADDRESS26_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS26_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS26_HIGH_SA() volatile
    {
        MAC_ADDRESS26_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS26_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS26_HIGH_SA() volatile
    {
        MAC_ADDRESS26_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS26_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS26_HIGH_SA() volatile
    {
        MAC_ADDRESS26_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS26_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS26_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS26_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS26_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS26_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS26_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS26_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS26_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS26_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS26_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS26_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS26_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS26_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS26_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS26_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS26_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS26_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS26_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS26_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS26_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS26_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS26_HIGH's bit fields.
     *
     * (read-write) MAC Address26 High
     */
    inline void get_MAC_ADDRESS26_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS26_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS26_HIGH's bit fields.
     *
     * (read-write) MAC Address26 High
     */
    inline void set_MAC_ADDRESS26_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS26_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS26_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS26_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS26_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS26_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS26_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS26_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS26_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS26_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS27_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS27_HIGH_AE() volatile
    {
        return MAC_ADDRESS27_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS27_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS27_HIGH_AE() volatile
    {
        MAC_ADDRESS27_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS27_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS27_HIGH_AE() volatile
    {
        MAC_ADDRESS27_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS27_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS27_HIGH_AE() volatile
    {
        MAC_ADDRESS27_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS27_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS27_HIGH_SA() volatile
    {
        return MAC_ADDRESS27_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS27_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS27_HIGH_SA() volatile
    {
        MAC_ADDRESS27_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS27_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS27_HIGH_SA() volatile
    {
        MAC_ADDRESS27_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS27_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS27_HIGH_SA() volatile
    {
        MAC_ADDRESS27_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS27_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS27_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS27_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS27_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS27_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS27_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS27_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS27_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS27_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS27_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS27_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS27_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS27_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS27_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS27_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS27_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS27_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS27_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS27_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS27_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS27_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS27_HIGH's bit fields.
     *
     * (read-write) MAC Address27 High
     */
    inline void get_MAC_ADDRESS27_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS27_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS27_HIGH's bit fields.
     *
     * (read-write) MAC Address27 High
     */
    inline void set_MAC_ADDRESS27_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS27_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS27_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS27_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS27_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS27_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS27_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS27_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS27_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS27_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS28_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS28_HIGH_AE() volatile
    {
        return MAC_ADDRESS28_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS28_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS28_HIGH_AE() volatile
    {
        MAC_ADDRESS28_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS28_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS28_HIGH_AE() volatile
    {
        MAC_ADDRESS28_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS28_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS28_HIGH_AE() volatile
    {
        MAC_ADDRESS28_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS28_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS28_HIGH_SA() volatile
    {
        return MAC_ADDRESS28_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS28_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS28_HIGH_SA() volatile
    {
        MAC_ADDRESS28_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS28_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS28_HIGH_SA() volatile
    {
        MAC_ADDRESS28_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS28_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS28_HIGH_SA() volatile
    {
        MAC_ADDRESS28_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS28_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS28_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS28_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS28_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS28_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS28_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS28_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS28_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS28_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS28_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS28_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS28_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS28_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS28_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS28_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS28_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS28_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS28_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS28_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS28_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS28_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS28_HIGH's bit fields.
     *
     * (read-write) MAC Address28 High
     */
    inline void get_MAC_ADDRESS28_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS28_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS28_HIGH's bit fields.
     *
     * (read-write) MAC Address28 High
     */
    inline void set_MAC_ADDRESS28_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS28_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS28_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS28_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS28_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS28_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS28_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS28_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS28_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS28_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS29_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS29_HIGH_AE() volatile
    {
        return MAC_ADDRESS29_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS29_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS29_HIGH_AE() volatile
    {
        MAC_ADDRESS29_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS29_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS29_HIGH_AE() volatile
    {
        MAC_ADDRESS29_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS29_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS29_HIGH_AE() volatile
    {
        MAC_ADDRESS29_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS29_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS29_HIGH_SA() volatile
    {
        return MAC_ADDRESS29_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS29_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS29_HIGH_SA() volatile
    {
        MAC_ADDRESS29_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS29_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS29_HIGH_SA() volatile
    {
        MAC_ADDRESS29_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS29_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS29_HIGH_SA() volatile
    {
        MAC_ADDRESS29_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS29_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS29_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS29_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS29_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS29_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS29_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS29_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS29_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS29_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS29_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS29_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS29_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS29_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS29_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS29_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS29_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS29_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS29_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS29_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS29_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS29_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS29_HIGH's bit fields.
     *
     * (read-write) MAC Address29 High
     */
    inline void get_MAC_ADDRESS29_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS29_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS29_HIGH's bit fields.
     *
     * (read-write) MAC Address29 High
     */
    inline void set_MAC_ADDRESS29_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS29_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS29_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS29_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS29_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS29_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS29_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS29_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS29_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS29_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS30_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS30_HIGH_AE() volatile
    {
        return MAC_ADDRESS30_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS30_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS30_HIGH_AE() volatile
    {
        MAC_ADDRESS30_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS30_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS30_HIGH_AE() volatile
    {
        MAC_ADDRESS30_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS30_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS30_HIGH_AE() volatile
    {
        MAC_ADDRESS30_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS30_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS30_HIGH_SA() volatile
    {
        return MAC_ADDRESS30_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS30_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS30_HIGH_SA() volatile
    {
        MAC_ADDRESS30_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS30_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS30_HIGH_SA() volatile
    {
        MAC_ADDRESS30_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS30_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS30_HIGH_SA() volatile
    {
        MAC_ADDRESS30_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS30_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS30_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS30_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS30_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS30_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS30_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS30_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS30_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS30_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS30_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS30_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS30_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS30_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS30_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS30_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS30_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS30_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS30_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS30_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS30_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS30_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS30_HIGH's bit fields.
     *
     * (read-write) MAC Address30 High
     */
    inline void get_MAC_ADDRESS30_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS30_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS30_HIGH's bit fields.
     *
     * (read-write) MAC Address30 High
     */
    inline void set_MAC_ADDRESS30_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS30_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS30_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS30_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS30_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS30_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS30_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS30_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS30_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS30_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS31_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS31_HIGH_AE() volatile
    {
        return MAC_ADDRESS31_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS31_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS31_HIGH_AE() volatile
    {
        MAC_ADDRESS31_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS31_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS31_HIGH_AE() volatile
    {
        MAC_ADDRESS31_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS31_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the address filter module uses the
     * second MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS31_HIGH_AE() volatile
    {
        MAC_ADDRESS31_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS31_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline bool get_MAC_ADDRESS31_HIGH_SA() volatile
    {
        return MAC_ADDRESS31_HIGH & (1u << 30u);
    }

    /**
     * Set MAC_ADDRESS31_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void set_MAC_ADDRESS31_HIGH_SA() volatile
    {
        MAC_ADDRESS31_HIGH |= 1u << 30u;
    }

    /**
     * Clear MAC_ADDRESS31_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void clear_MAC_ADDRESS31_HIGH_SA() volatile
    {
        MAC_ADDRESS31_HIGH &= ~(1u << 30u);
    }

    /**
     * Toggle MAC_ADDRESS31_HIGH's SA bit.
     *
     * Source Address When this bit is set, the MAC ADDRESS1[47:0] is used to
     * compare with the SA fields of the received packet.
     */
    inline void toggle_MAC_ADDRESS31_HIGH_SA() volatile
    {
        MAC_ADDRESS31_HIGH ^= 1u << 30u;
    }

    /**
     * Get MAC_ADDRESS31_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline uint8_t get_MAC_ADDRESS31_HIGH_MBC() volatile
    {
        return (MAC_ADDRESS31_HIGH >> 24u) & 0b111111u;
    }

    /**
     * Set MAC_ADDRESS31_HIGH's MBC field.
     *
     * Mask Byte Control These bits are mask control bits for comparing each of
     * the MAC Address bytes.
     */
    inline void set_MAC_ADDRESS31_HIGH_MBC(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS31_HIGH;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        MAC_ADDRESS31_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS31_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline uint8_t get_MAC_ADDRESS31_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS31_HIGH >> 16u) & 0b11111u;
    }

    /**
     * Set MAC_ADDRESS31_HIGH's DCS field.
     *
     * DMA Channel Select If the PDC bit of MAC_EXT_CONFIGURATION register is
     * not set: This field contains the binary representation of the DMA
     * Channel number to which an Rx packet whose DA matches the MAC
     * Address(#i) content is routed.
     */
    inline void set_MAC_ADDRESS31_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS31_HIGH;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MAC_ADDRESS31_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS31_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS31_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS31_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS31_HIGH's ADDRHI field.
     *
     * MAC ADDRESS1 [47:32] This field contains the upper 16 bits[47:32] of the
     * second 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS31_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS31_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS31_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS31_HIGH's bit fields.
     *
     * (read-write) MAC Address31 High
     */
    inline void get_MAC_ADDRESS31_HIGH(bool &AE, bool &SA, uint8_t &MBC,
                                       uint8_t &DCS, uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS31_HIGH;

        AE = curr & (1u << 31u);
        SA = curr & (1u << 30u);
        MBC = (curr >> 24u) & 0b111111u;
        DCS = (curr >> 16u) & 0b11111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS31_HIGH's bit fields.
     *
     * (read-write) MAC Address31 High
     */
    inline void set_MAC_ADDRESS31_HIGH(bool AE, bool SA, uint8_t MBC,
                                       uint8_t DCS, uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS31_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SA & 0b1u) << 30u;
        curr &= ~(0b111111u << 24u);
        curr |= (MBC & 0b111111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (DCS & 0b11111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS31_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS31_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS31_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS31_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS31_LOW's ADDRLO field.
     *
     * MAC ADDRESS1 [31:0] This field contains the lower 32 bits of second
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS31_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS31_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS31_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS32_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS32_HIGH_AE() volatile
    {
        return MAC_ADDRESS32_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS32_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS32_HIGH_AE() volatile
    {
        MAC_ADDRESS32_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS32_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS32_HIGH_AE() volatile
    {
        MAC_ADDRESS32_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS32_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS32_HIGH_AE() volatile
    {
        MAC_ADDRESS32_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS32_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS32_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS32_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS32_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS32_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS32_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS32_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS32_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS32_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS32_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS32_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS32_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS32_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS32_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS32_HIGH's bit fields.
     *
     * (read-write) MAC Address32 High
     */
    inline void get_MAC_ADDRESS32_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS32_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS32_HIGH's bit fields.
     *
     * (read-write) MAC Address32 High
     */
    inline void set_MAC_ADDRESS32_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS32_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS32_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS32_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS32_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS32_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS32_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS32_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS32_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS32_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS33_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS33_HIGH_AE() volatile
    {
        return MAC_ADDRESS33_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS33_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS33_HIGH_AE() volatile
    {
        MAC_ADDRESS33_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS33_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS33_HIGH_AE() volatile
    {
        MAC_ADDRESS33_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS33_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS33_HIGH_AE() volatile
    {
        MAC_ADDRESS33_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS33_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS33_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS33_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS33_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS33_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS33_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS33_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS33_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS33_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS33_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS33_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS33_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS33_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS33_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS33_HIGH's bit fields.
     *
     * (read-write) MAC Address33 High
     */
    inline void get_MAC_ADDRESS33_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS33_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS33_HIGH's bit fields.
     *
     * (read-write) MAC Address33 High
     */
    inline void set_MAC_ADDRESS33_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS33_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS33_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS33_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS33_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS33_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS33_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS33_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS33_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS33_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS34_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS34_HIGH_AE() volatile
    {
        return MAC_ADDRESS34_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS34_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS34_HIGH_AE() volatile
    {
        MAC_ADDRESS34_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS34_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS34_HIGH_AE() volatile
    {
        MAC_ADDRESS34_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS34_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS34_HIGH_AE() volatile
    {
        MAC_ADDRESS34_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS34_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS34_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS34_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS34_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS34_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS34_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS34_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS34_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS34_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS34_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS34_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS34_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS34_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS34_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS34_HIGH's bit fields.
     *
     * (read-write) MAC Address34 High
     */
    inline void get_MAC_ADDRESS34_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS34_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS34_HIGH's bit fields.
     *
     * (read-write) MAC Address34 High
     */
    inline void set_MAC_ADDRESS34_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS34_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS34_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS34_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS34_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS34_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS34_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS34_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS34_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS34_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS35_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS35_HIGH_AE() volatile
    {
        return MAC_ADDRESS35_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS35_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS35_HIGH_AE() volatile
    {
        MAC_ADDRESS35_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS35_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS35_HIGH_AE() volatile
    {
        MAC_ADDRESS35_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS35_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS35_HIGH_AE() volatile
    {
        MAC_ADDRESS35_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS35_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS35_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS35_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS35_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS35_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS35_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS35_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS35_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS35_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS35_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS35_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS35_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS35_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS35_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS35_HIGH's bit fields.
     *
     * (read-write) MAC Address35 High
     */
    inline void get_MAC_ADDRESS35_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS35_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS35_HIGH's bit fields.
     *
     * (read-write) MAC Address35 High
     */
    inline void set_MAC_ADDRESS35_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS35_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS35_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS35_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS35_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS35_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS35_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS35_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS35_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS35_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS36_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS36_HIGH_AE() volatile
    {
        return MAC_ADDRESS36_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS36_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS36_HIGH_AE() volatile
    {
        MAC_ADDRESS36_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS36_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS36_HIGH_AE() volatile
    {
        MAC_ADDRESS36_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS36_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS36_HIGH_AE() volatile
    {
        MAC_ADDRESS36_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS36_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS36_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS36_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS36_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS36_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS36_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS36_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS36_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS36_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS36_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS36_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS36_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS36_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS36_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS36_HIGH's bit fields.
     *
     * (read-write) MAC Address36 High
     */
    inline void get_MAC_ADDRESS36_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS36_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS36_HIGH's bit fields.
     *
     * (read-write) MAC Address36 High
     */
    inline void set_MAC_ADDRESS36_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS36_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS36_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS36_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS36_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS36_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS36_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS36_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS36_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS36_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS37_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS37_HIGH_AE() volatile
    {
        return MAC_ADDRESS37_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS37_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS37_HIGH_AE() volatile
    {
        MAC_ADDRESS37_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS37_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS37_HIGH_AE() volatile
    {
        MAC_ADDRESS37_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS37_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS37_HIGH_AE() volatile
    {
        MAC_ADDRESS37_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS37_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS37_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS37_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS37_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS37_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS37_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS37_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS37_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS37_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS37_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS37_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS37_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS37_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS37_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS37_HIGH's bit fields.
     *
     * (read-write) MAC Address37 High
     */
    inline void get_MAC_ADDRESS37_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS37_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS37_HIGH's bit fields.
     *
     * (read-write) MAC Address37 High
     */
    inline void set_MAC_ADDRESS37_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS37_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS37_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS37_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS37_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS37_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS37_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS37_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS37_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS37_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS38_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS38_HIGH_AE() volatile
    {
        return MAC_ADDRESS38_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS38_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS38_HIGH_AE() volatile
    {
        MAC_ADDRESS38_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS38_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS38_HIGH_AE() volatile
    {
        MAC_ADDRESS38_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS38_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS38_HIGH_AE() volatile
    {
        MAC_ADDRESS38_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS38_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS38_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS38_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS38_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS38_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS38_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS38_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS38_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS38_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS38_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS38_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS38_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS38_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS38_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS38_HIGH's bit fields.
     *
     * (read-write) MAC Address38 High
     */
    inline void get_MAC_ADDRESS38_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS38_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS38_HIGH's bit fields.
     *
     * (read-write) MAC Address38 High
     */
    inline void set_MAC_ADDRESS38_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS38_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS38_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS38_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS38_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS38_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS38_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS38_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS38_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS38_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS39_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS39_HIGH_AE() volatile
    {
        return MAC_ADDRESS39_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS39_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS39_HIGH_AE() volatile
    {
        MAC_ADDRESS39_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS39_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS39_HIGH_AE() volatile
    {
        MAC_ADDRESS39_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS39_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS39_HIGH_AE() volatile
    {
        MAC_ADDRESS39_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS39_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS39_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS39_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS39_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS39_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS39_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS39_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS39_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS39_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS39_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS39_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS39_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS39_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS39_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS39_HIGH's bit fields.
     *
     * (read-write) MAC Address39 High
     */
    inline void get_MAC_ADDRESS39_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS39_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS39_HIGH's bit fields.
     *
     * (read-write) MAC Address39 High
     */
    inline void set_MAC_ADDRESS39_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS39_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS39_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS39_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS39_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS39_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS39_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS39_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS39_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS39_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS40_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS40_HIGH_AE() volatile
    {
        return MAC_ADDRESS40_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS40_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS40_HIGH_AE() volatile
    {
        MAC_ADDRESS40_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS40_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS40_HIGH_AE() volatile
    {
        MAC_ADDRESS40_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS40_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS40_HIGH_AE() volatile
    {
        MAC_ADDRESS40_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS40_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS40_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS40_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS40_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS40_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS40_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS40_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS40_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS40_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS40_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS40_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS40_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS40_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS40_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS40_HIGH's bit fields.
     *
     * (read-write) MAC Address40 High
     */
    inline void get_MAC_ADDRESS40_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS40_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS40_HIGH's bit fields.
     *
     * (read-write) MAC Address40 High
     */
    inline void set_MAC_ADDRESS40_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS40_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS40_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS40_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS40_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS40_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS40_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS40_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS40_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS40_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS41_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS41_HIGH_AE() volatile
    {
        return MAC_ADDRESS41_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS41_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS41_HIGH_AE() volatile
    {
        MAC_ADDRESS41_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS41_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS41_HIGH_AE() volatile
    {
        MAC_ADDRESS41_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS41_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS41_HIGH_AE() volatile
    {
        MAC_ADDRESS41_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS41_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS41_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS41_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS41_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS41_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS41_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS41_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS41_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS41_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS41_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS41_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS41_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS41_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS41_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS41_HIGH's bit fields.
     *
     * (read-write) MAC Address41 High
     */
    inline void get_MAC_ADDRESS41_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS41_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS41_HIGH's bit fields.
     *
     * (read-write) MAC Address41 High
     */
    inline void set_MAC_ADDRESS41_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS41_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS41_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS41_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS41_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS41_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS41_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS41_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS41_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS41_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS42_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS42_HIGH_AE() volatile
    {
        return MAC_ADDRESS42_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS42_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS42_HIGH_AE() volatile
    {
        MAC_ADDRESS42_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS42_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS42_HIGH_AE() volatile
    {
        MAC_ADDRESS42_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS42_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS42_HIGH_AE() volatile
    {
        MAC_ADDRESS42_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS42_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS42_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS42_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS42_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS42_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS42_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS42_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS42_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS42_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS42_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS42_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS42_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS42_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS42_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS42_HIGH's bit fields.
     *
     * (read-write) MAC Address42 High
     */
    inline void get_MAC_ADDRESS42_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS42_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS42_HIGH's bit fields.
     *
     * (read-write) MAC Address42 High
     */
    inline void set_MAC_ADDRESS42_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS42_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS42_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS42_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS42_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS42_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS42_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS42_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS42_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS42_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS43_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS43_HIGH_AE() volatile
    {
        return MAC_ADDRESS43_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS43_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS43_HIGH_AE() volatile
    {
        MAC_ADDRESS43_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS43_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS43_HIGH_AE() volatile
    {
        MAC_ADDRESS43_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS43_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS43_HIGH_AE() volatile
    {
        MAC_ADDRESS43_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS43_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS43_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS43_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS43_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS43_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS43_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS43_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS43_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS43_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS43_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS43_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS43_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS43_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS43_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS43_HIGH's bit fields.
     *
     * (read-write) MAC Address43 High
     */
    inline void get_MAC_ADDRESS43_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS43_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS43_HIGH's bit fields.
     *
     * (read-write) MAC Address43 High
     */
    inline void set_MAC_ADDRESS43_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS43_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS43_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS43_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS43_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS43_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS43_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS43_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS43_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS43_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS44_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS44_HIGH_AE() volatile
    {
        return MAC_ADDRESS44_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS44_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS44_HIGH_AE() volatile
    {
        MAC_ADDRESS44_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS44_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS44_HIGH_AE() volatile
    {
        MAC_ADDRESS44_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS44_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS44_HIGH_AE() volatile
    {
        MAC_ADDRESS44_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS44_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS44_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS44_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS44_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS44_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS44_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS44_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS44_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS44_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS44_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS44_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS44_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS44_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS44_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS44_HIGH's bit fields.
     *
     * (read-write) MAC Address44 High
     */
    inline void get_MAC_ADDRESS44_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS44_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS44_HIGH's bit fields.
     *
     * (read-write) MAC Address44 High
     */
    inline void set_MAC_ADDRESS44_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS44_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS44_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS44_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS44_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS44_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS44_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS44_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS44_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS44_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS45_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS45_HIGH_AE() volatile
    {
        return MAC_ADDRESS45_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS45_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS45_HIGH_AE() volatile
    {
        MAC_ADDRESS45_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS45_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS45_HIGH_AE() volatile
    {
        MAC_ADDRESS45_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS45_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS45_HIGH_AE() volatile
    {
        MAC_ADDRESS45_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS45_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS45_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS45_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS45_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS45_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS45_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS45_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS45_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS45_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS45_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS45_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS45_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS45_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS45_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS45_HIGH's bit fields.
     *
     * (read-write) MAC Address45 High
     */
    inline void get_MAC_ADDRESS45_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS45_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS45_HIGH's bit fields.
     *
     * (read-write) MAC Address45 High
     */
    inline void set_MAC_ADDRESS45_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS45_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS45_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS45_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS45_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS45_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS45_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS45_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS45_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS45_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS46_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS46_HIGH_AE() volatile
    {
        return MAC_ADDRESS46_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS46_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS46_HIGH_AE() volatile
    {
        MAC_ADDRESS46_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS46_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS46_HIGH_AE() volatile
    {
        MAC_ADDRESS46_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS46_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS46_HIGH_AE() volatile
    {
        MAC_ADDRESS46_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS46_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS46_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS46_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS46_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS46_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS46_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS46_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS46_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS46_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS46_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS46_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS46_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS46_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS46_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS46_HIGH's bit fields.
     *
     * (read-write) MAC Address46 High
     */
    inline void get_MAC_ADDRESS46_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS46_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS46_HIGH's bit fields.
     *
     * (read-write) MAC Address46 High
     */
    inline void set_MAC_ADDRESS46_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS46_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS46_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS46_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS46_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS46_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS46_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS46_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS46_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS46_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS47_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS47_HIGH_AE() volatile
    {
        return MAC_ADDRESS47_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS47_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS47_HIGH_AE() volatile
    {
        MAC_ADDRESS47_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS47_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS47_HIGH_AE() volatile
    {
        MAC_ADDRESS47_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS47_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS47_HIGH_AE() volatile
    {
        MAC_ADDRESS47_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS47_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS47_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS47_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS47_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS47_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS47_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS47_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS47_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS47_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS47_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS47_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS47_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS47_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS47_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS47_HIGH's bit fields.
     *
     * (read-write) MAC Address47 High
     */
    inline void get_MAC_ADDRESS47_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS47_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS47_HIGH's bit fields.
     *
     * (read-write) MAC Address47 High
     */
    inline void set_MAC_ADDRESS47_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS47_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS47_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS47_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS47_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS47_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS47_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS47_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS47_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS47_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS48_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS48_HIGH_AE() volatile
    {
        return MAC_ADDRESS48_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS48_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS48_HIGH_AE() volatile
    {
        MAC_ADDRESS48_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS48_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS48_HIGH_AE() volatile
    {
        MAC_ADDRESS48_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS48_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS48_HIGH_AE() volatile
    {
        MAC_ADDRESS48_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS48_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS48_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS48_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS48_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS48_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS48_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS48_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS48_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS48_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS48_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS48_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS48_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS48_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS48_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS48_HIGH's bit fields.
     *
     * (read-write) MAC Address48 High
     */
    inline void get_MAC_ADDRESS48_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS48_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS48_HIGH's bit fields.
     *
     * (read-write) MAC Address48 High
     */
    inline void set_MAC_ADDRESS48_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS48_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS48_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS48_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS48_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS48_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS48_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS48_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS48_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS48_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS49_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS49_HIGH_AE() volatile
    {
        return MAC_ADDRESS49_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS49_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS49_HIGH_AE() volatile
    {
        MAC_ADDRESS49_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS49_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS49_HIGH_AE() volatile
    {
        MAC_ADDRESS49_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS49_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS49_HIGH_AE() volatile
    {
        MAC_ADDRESS49_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS49_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS49_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS49_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS49_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS49_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS49_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS49_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS49_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS49_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS49_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS49_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS49_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS49_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS49_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS49_HIGH's bit fields.
     *
     * (read-write) MAC Address49 High
     */
    inline void get_MAC_ADDRESS49_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS49_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS49_HIGH's bit fields.
     *
     * (read-write) MAC Address49 High
     */
    inline void set_MAC_ADDRESS49_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS49_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS49_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS49_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS49_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS49_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS49_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS49_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS49_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS49_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS50_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS50_HIGH_AE() volatile
    {
        return MAC_ADDRESS50_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS50_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS50_HIGH_AE() volatile
    {
        MAC_ADDRESS50_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS50_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS50_HIGH_AE() volatile
    {
        MAC_ADDRESS50_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS50_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS50_HIGH_AE() volatile
    {
        MAC_ADDRESS50_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS50_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS50_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS50_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS50_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS50_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS50_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS50_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS50_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS50_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS50_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS50_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS50_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS50_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS50_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS50_HIGH's bit fields.
     *
     * (read-write) MAC Address50 High
     */
    inline void get_MAC_ADDRESS50_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS50_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS50_HIGH's bit fields.
     *
     * (read-write) MAC Address50 High
     */
    inline void set_MAC_ADDRESS50_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS50_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS50_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS50_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS50_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS50_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS50_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS50_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS50_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS50_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS51_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS51_HIGH_AE() volatile
    {
        return MAC_ADDRESS51_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS51_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS51_HIGH_AE() volatile
    {
        MAC_ADDRESS51_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS51_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS51_HIGH_AE() volatile
    {
        MAC_ADDRESS51_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS51_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS51_HIGH_AE() volatile
    {
        MAC_ADDRESS51_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS51_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS51_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS51_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS51_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS51_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS51_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS51_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS51_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS51_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS51_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS51_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS51_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS51_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS51_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS51_HIGH's bit fields.
     *
     * (read-write) MAC Address51 High
     */
    inline void get_MAC_ADDRESS51_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS51_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS51_HIGH's bit fields.
     *
     * (read-write) MAC Address51 High
     */
    inline void set_MAC_ADDRESS51_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS51_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS51_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS51_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS51_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS51_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS51_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS51_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS51_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS51_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS52_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS52_HIGH_AE() volatile
    {
        return MAC_ADDRESS52_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS52_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS52_HIGH_AE() volatile
    {
        MAC_ADDRESS52_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS52_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS52_HIGH_AE() volatile
    {
        MAC_ADDRESS52_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS52_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS52_HIGH_AE() volatile
    {
        MAC_ADDRESS52_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS52_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS52_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS52_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS52_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS52_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS52_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS52_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS52_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS52_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS52_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS52_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS52_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS52_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS52_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS52_HIGH's bit fields.
     *
     * (read-write) MAC Address52 High
     */
    inline void get_MAC_ADDRESS52_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS52_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS52_HIGH's bit fields.
     *
     * (read-write) MAC Address52 High
     */
    inline void set_MAC_ADDRESS52_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS52_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS52_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS52_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS52_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS52_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS52_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS52_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS52_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS52_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS53_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS53_HIGH_AE() volatile
    {
        return MAC_ADDRESS53_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS53_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS53_HIGH_AE() volatile
    {
        MAC_ADDRESS53_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS53_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS53_HIGH_AE() volatile
    {
        MAC_ADDRESS53_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS53_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS53_HIGH_AE() volatile
    {
        MAC_ADDRESS53_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS53_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS53_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS53_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS53_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS53_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS53_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS53_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS53_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS53_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS53_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS53_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS53_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS53_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS53_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS53_HIGH's bit fields.
     *
     * (read-write) MAC Address53 High
     */
    inline void get_MAC_ADDRESS53_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS53_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS53_HIGH's bit fields.
     *
     * (read-write) MAC Address53 High
     */
    inline void set_MAC_ADDRESS53_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS53_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS53_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS53_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS53_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS53_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS53_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS53_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS53_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS53_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS54_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS54_HIGH_AE() volatile
    {
        return MAC_ADDRESS54_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS54_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS54_HIGH_AE() volatile
    {
        MAC_ADDRESS54_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS54_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS54_HIGH_AE() volatile
    {
        MAC_ADDRESS54_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS54_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS54_HIGH_AE() volatile
    {
        MAC_ADDRESS54_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS54_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS54_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS54_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS54_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS54_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS54_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS54_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS54_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS54_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS54_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS54_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS54_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS54_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS54_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS54_HIGH's bit fields.
     *
     * (read-write) MAC Address54 High
     */
    inline void get_MAC_ADDRESS54_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS54_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS54_HIGH's bit fields.
     *
     * (read-write) MAC Address54 High
     */
    inline void set_MAC_ADDRESS54_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS54_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS54_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS54_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS54_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS54_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS54_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS54_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS54_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS54_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS55_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS55_HIGH_AE() volatile
    {
        return MAC_ADDRESS55_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS55_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS55_HIGH_AE() volatile
    {
        MAC_ADDRESS55_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS55_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS55_HIGH_AE() volatile
    {
        MAC_ADDRESS55_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS55_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS55_HIGH_AE() volatile
    {
        MAC_ADDRESS55_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS55_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS55_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS55_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS55_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS55_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS55_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS55_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS55_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS55_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS55_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS55_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS55_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS55_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS55_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS55_HIGH's bit fields.
     *
     * (read-write) MAC Address55 High
     */
    inline void get_MAC_ADDRESS55_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS55_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS55_HIGH's bit fields.
     *
     * (read-write) MAC Address55 High
     */
    inline void set_MAC_ADDRESS55_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS55_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS55_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS55_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS55_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS55_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS55_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS55_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS55_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS55_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS56_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS56_HIGH_AE() volatile
    {
        return MAC_ADDRESS56_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS56_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS56_HIGH_AE() volatile
    {
        MAC_ADDRESS56_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS56_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS56_HIGH_AE() volatile
    {
        MAC_ADDRESS56_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS56_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS56_HIGH_AE() volatile
    {
        MAC_ADDRESS56_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS56_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS56_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS56_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS56_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS56_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS56_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS56_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS56_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS56_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS56_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS56_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS56_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS56_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS56_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS56_HIGH's bit fields.
     *
     * (read-write) MAC Address56 High
     */
    inline void get_MAC_ADDRESS56_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS56_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS56_HIGH's bit fields.
     *
     * (read-write) MAC Address56 High
     */
    inline void set_MAC_ADDRESS56_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS56_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS56_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS56_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS56_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS56_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS56_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS56_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS56_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS56_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS57_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS57_HIGH_AE() volatile
    {
        return MAC_ADDRESS57_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS57_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS57_HIGH_AE() volatile
    {
        MAC_ADDRESS57_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS57_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS57_HIGH_AE() volatile
    {
        MAC_ADDRESS57_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS57_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS57_HIGH_AE() volatile
    {
        MAC_ADDRESS57_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS57_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS57_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS57_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS57_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS57_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS57_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS57_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS57_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS57_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS57_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS57_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS57_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS57_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS57_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS57_HIGH's bit fields.
     *
     * (read-write) MAC Address57 High
     */
    inline void get_MAC_ADDRESS57_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS57_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS57_HIGH's bit fields.
     *
     * (read-write) MAC Address57 High
     */
    inline void set_MAC_ADDRESS57_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS57_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS57_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS57_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS57_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS57_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS57_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS57_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS57_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS57_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS58_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS58_HIGH_AE() volatile
    {
        return MAC_ADDRESS58_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS58_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS58_HIGH_AE() volatile
    {
        MAC_ADDRESS58_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS58_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS58_HIGH_AE() volatile
    {
        MAC_ADDRESS58_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS58_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS58_HIGH_AE() volatile
    {
        MAC_ADDRESS58_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS58_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS58_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS58_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS58_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS58_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS58_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS58_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS58_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS58_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS58_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS58_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS58_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS58_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS58_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS58_HIGH's bit fields.
     *
     * (read-write) MAC Address58 High
     */
    inline void get_MAC_ADDRESS58_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS58_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS58_HIGH's bit fields.
     *
     * (read-write) MAC Address58 High
     */
    inline void set_MAC_ADDRESS58_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS58_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS58_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS58_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS58_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS58_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS58_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS58_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS58_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS58_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS59_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS59_HIGH_AE() volatile
    {
        return MAC_ADDRESS59_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS59_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS59_HIGH_AE() volatile
    {
        MAC_ADDRESS59_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS59_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS59_HIGH_AE() volatile
    {
        MAC_ADDRESS59_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS59_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS59_HIGH_AE() volatile
    {
        MAC_ADDRESS59_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS59_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS59_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS59_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS59_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS59_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS59_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS59_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS59_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS59_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS59_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS59_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS59_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS59_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS59_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS59_HIGH's bit fields.
     *
     * (read-write) MAC Address59 High
     */
    inline void get_MAC_ADDRESS59_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS59_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS59_HIGH's bit fields.
     *
     * (read-write) MAC Address59 High
     */
    inline void set_MAC_ADDRESS59_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS59_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS59_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS59_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS59_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS59_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS59_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS59_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS59_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS59_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS60_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS60_HIGH_AE() volatile
    {
        return MAC_ADDRESS60_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS60_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS60_HIGH_AE() volatile
    {
        MAC_ADDRESS60_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS60_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS60_HIGH_AE() volatile
    {
        MAC_ADDRESS60_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS60_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS60_HIGH_AE() volatile
    {
        MAC_ADDRESS60_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS60_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS60_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS60_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS60_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS60_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS60_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS60_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS60_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS60_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS60_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS60_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS60_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS60_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS60_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS60_HIGH's bit fields.
     *
     * (read-write) MAC Address60 High
     */
    inline void get_MAC_ADDRESS60_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS60_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS60_HIGH's bit fields.
     *
     * (read-write) MAC Address60 High
     */
    inline void set_MAC_ADDRESS60_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS60_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS60_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS60_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS60_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS60_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS60_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS60_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS60_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS60_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS61_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS61_HIGH_AE() volatile
    {
        return MAC_ADDRESS61_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS61_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS61_HIGH_AE() volatile
    {
        MAC_ADDRESS61_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS61_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS61_HIGH_AE() volatile
    {
        MAC_ADDRESS61_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS61_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS61_HIGH_AE() volatile
    {
        MAC_ADDRESS61_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS61_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS61_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS61_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS61_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS61_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS61_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS61_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS61_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS61_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS61_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS61_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS61_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS61_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS61_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS61_HIGH's bit fields.
     *
     * (read-write) MAC Address61 High
     */
    inline void get_MAC_ADDRESS61_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS61_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS61_HIGH's bit fields.
     *
     * (read-write) MAC Address61 High
     */
    inline void set_MAC_ADDRESS61_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS61_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS61_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS61_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS61_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS61_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS61_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS61_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS61_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS61_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS62_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS62_HIGH_AE() volatile
    {
        return MAC_ADDRESS62_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS62_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS62_HIGH_AE() volatile
    {
        MAC_ADDRESS62_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS62_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS62_HIGH_AE() volatile
    {
        MAC_ADDRESS62_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS62_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS62_HIGH_AE() volatile
    {
        MAC_ADDRESS62_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS62_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS62_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS62_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS62_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS62_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS62_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS62_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS62_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS62_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS62_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS62_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS62_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS62_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS62_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS62_HIGH's bit fields.
     *
     * (read-write) MAC Address62 High
     */
    inline void get_MAC_ADDRESS62_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS62_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS62_HIGH's bit fields.
     *
     * (read-write) MAC Address62 High
     */
    inline void set_MAC_ADDRESS62_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS62_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS62_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS62_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS62_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS62_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS62_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS62_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS62_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS62_LOW = curr;
    }

    /**
     * Get MAC_ADDRESS63_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline bool get_MAC_ADDRESS63_HIGH_AE() volatile
    {
        return MAC_ADDRESS63_HIGH & (1u << 31u);
    }

    /**
     * Set MAC_ADDRESS63_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void set_MAC_ADDRESS63_HIGH_AE() volatile
    {
        MAC_ADDRESS63_HIGH |= 1u << 31u;
    }

    /**
     * Clear MAC_ADDRESS63_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void clear_MAC_ADDRESS63_HIGH_AE() volatile
    {
        MAC_ADDRESS63_HIGH &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_ADDRESS63_HIGH's AE bit.
     *
     * Address Enable When this bit is set, the Address filter module uses the
     * 33rd MAC address for perfect filtering.
     */
    inline void toggle_MAC_ADDRESS63_HIGH_AE() volatile
    {
        MAC_ADDRESS63_HIGH ^= 1u << 31u;
    }

    /**
     * Get MAC_ADDRESS63_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline uint8_t get_MAC_ADDRESS63_HIGH_DCS() volatile
    {
        return (MAC_ADDRESS63_HIGH >> 16u) & 0b111u;
    }

    /**
     * Set MAC_ADDRESS63_HIGH's DCS field.
     *
     * DMA Channel Select This field contains the DMA Channel number to which
     * an Rx packet whose DA matches the MAC ADDRESS32 content is routed.
     */
    inline void set_MAC_ADDRESS63_HIGH_DCS(uint8_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS63_HIGH;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MAC_ADDRESS63_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS63_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline uint16_t get_MAC_ADDRESS63_HIGH_ADDRHI() volatile
    {
        return (MAC_ADDRESS63_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_ADDRESS63_HIGH's ADDRHI field.
     *
     * MAC ADDRESS32 [47:32] This field contains the upper 16 bits (47:32) of
     * the 33rd 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS63_HIGH_ADDRHI(uint16_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS63_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_ADDRESS63_HIGH = curr;
    }

    /**
     * Get all of MAC_ADDRESS63_HIGH's bit fields.
     *
     * (read-write) MAC Address63 High
     */
    inline void get_MAC_ADDRESS63_HIGH(bool &AE, uint8_t &DCS,
                                       uint16_t &ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS63_HIGH;

        AE = curr & (1u << 31u);
        DCS = (curr >> 16u) & 0b111u;
        ADDRHI = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_ADDRESS63_HIGH's bit fields.
     *
     * (read-write) MAC Address63 High
     */
    inline void set_MAC_ADDRESS63_HIGH(bool AE, uint8_t DCS,
                                       uint16_t ADDRHI) volatile
    {
        uint32_t curr = MAC_ADDRESS63_HIGH;

        curr &= ~(0b1u << 31u);
        curr |= (AE & 0b1u) << 31u;
        curr &= ~(0b111u << 16u);
        curr |= (DCS & 0b111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (ADDRHI & 0b1111111111111111u) << 0u;

        MAC_ADDRESS63_HIGH = curr;
    }

    /**
     * Get MAC_ADDRESS63_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline uint32_t get_MAC_ADDRESS63_LOW_ADDRLO() volatile
    {
        return (MAC_ADDRESS63_LOW >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_ADDRESS63_LOW's ADDRLO field.
     *
     * MAC ADDRESS32 [31:0] This field contains the lower 32 bits of the 33rd
     * 6-byte MAC address.
     */
    inline void set_MAC_ADDRESS63_LOW_ADDRLO(uint32_t value) volatile
    {
        uint32_t curr = MAC_ADDRESS63_LOW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_ADDRESS63_LOW = curr;
    }

    /**
     * Get MAC_MMC_CONTROL's UCDBC bit.
     *
     * Update MMC Counters for Dropped Broadcast Packets Note: The CNTRST bit
     * has a higher priority than the CNTPRST bit.
     */
    inline bool get_MAC_MMC_CONTROL_UCDBC() volatile
    {
        return MAC_MMC_CONTROL & (1u << 8u);
    }

    /**
     * Set MAC_MMC_CONTROL's UCDBC bit.
     *
     * Update MMC Counters for Dropped Broadcast Packets Note: The CNTRST bit
     * has a higher priority than the CNTPRST bit.
     */
    inline void set_MAC_MMC_CONTROL_UCDBC() volatile
    {
        MAC_MMC_CONTROL |= 1u << 8u;
    }

    /**
     * Clear MAC_MMC_CONTROL's UCDBC bit.
     *
     * Update MMC Counters for Dropped Broadcast Packets Note: The CNTRST bit
     * has a higher priority than the CNTPRST bit.
     */
    inline void clear_MAC_MMC_CONTROL_UCDBC() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's UCDBC bit.
     *
     * Update MMC Counters for Dropped Broadcast Packets Note: The CNTRST bit
     * has a higher priority than the CNTPRST bit.
     */
    inline void toggle_MAC_MMC_CONTROL_UCDBC() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 8u;
    }

    /**
     * Get MAC_MMC_CONTROL's CNTPRSTLVL bit.
     *
     * Full-Half Preset When this bit is low and the CNTPRST bit is set, all
     * MMC counters get preset to almost-half value.
     */
    inline bool get_MAC_MMC_CONTROL_CNTPRSTLVL() volatile
    {
        return MAC_MMC_CONTROL & (1u << 5u);
    }

    /**
     * Set MAC_MMC_CONTROL's CNTPRSTLVL bit.
     *
     * Full-Half Preset When this bit is low and the CNTPRST bit is set, all
     * MMC counters get preset to almost-half value.
     */
    inline void set_MAC_MMC_CONTROL_CNTPRSTLVL() volatile
    {
        MAC_MMC_CONTROL |= 1u << 5u;
    }

    /**
     * Clear MAC_MMC_CONTROL's CNTPRSTLVL bit.
     *
     * Full-Half Preset When this bit is low and the CNTPRST bit is set, all
     * MMC counters get preset to almost-half value.
     */
    inline void clear_MAC_MMC_CONTROL_CNTPRSTLVL() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's CNTPRSTLVL bit.
     *
     * Full-Half Preset When this bit is low and the CNTPRST bit is set, all
     * MMC counters get preset to almost-half value.
     */
    inline void toggle_MAC_MMC_CONTROL_CNTPRSTLVL() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 5u;
    }

    /**
     * Get MAC_MMC_CONTROL's CNTPRST bit.
     *
     * Counters Preset When this bit is set, all counters are initialized or
     * preset to almost full or almost half according to the CNTPRSTLVL bit.
     */
    inline bool get_MAC_MMC_CONTROL_CNTPRST() volatile
    {
        return MAC_MMC_CONTROL & (1u << 4u);
    }

    /**
     * Set MAC_MMC_CONTROL's CNTPRST bit.
     *
     * Counters Preset When this bit is set, all counters are initialized or
     * preset to almost full or almost half according to the CNTPRSTLVL bit.
     */
    inline void set_MAC_MMC_CONTROL_CNTPRST() volatile
    {
        MAC_MMC_CONTROL |= 1u << 4u;
    }

    /**
     * Clear MAC_MMC_CONTROL's CNTPRST bit.
     *
     * Counters Preset When this bit is set, all counters are initialized or
     * preset to almost full or almost half according to the CNTPRSTLVL bit.
     */
    inline void clear_MAC_MMC_CONTROL_CNTPRST() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's CNTPRST bit.
     *
     * Counters Preset When this bit is set, all counters are initialized or
     * preset to almost full or almost half according to the CNTPRSTLVL bit.
     */
    inline void toggle_MAC_MMC_CONTROL_CNTPRST() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 4u;
    }

    /**
     * Get MAC_MMC_CONTROL's CNTFREEZ bit.
     *
     * MMC Counter Freeze When this bit is set, it freezes all MMC counters to
     * their current value.
     */
    inline bool get_MAC_MMC_CONTROL_CNTFREEZ() volatile
    {
        return MAC_MMC_CONTROL & (1u << 3u);
    }

    /**
     * Set MAC_MMC_CONTROL's CNTFREEZ bit.
     *
     * MMC Counter Freeze When this bit is set, it freezes all MMC counters to
     * their current value.
     */
    inline void set_MAC_MMC_CONTROL_CNTFREEZ() volatile
    {
        MAC_MMC_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MAC_MMC_CONTROL's CNTFREEZ bit.
     *
     * MMC Counter Freeze When this bit is set, it freezes all MMC counters to
     * their current value.
     */
    inline void clear_MAC_MMC_CONTROL_CNTFREEZ() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's CNTFREEZ bit.
     *
     * MMC Counter Freeze When this bit is set, it freezes all MMC counters to
     * their current value.
     */
    inline void toggle_MAC_MMC_CONTROL_CNTFREEZ() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MAC_MMC_CONTROL's RSTONRD bit.
     *
     * Reset on Read When this bit is set, the MMC counters are reset to zero
     * after Read (self-clearing after reset).
     */
    inline bool get_MAC_MMC_CONTROL_RSTONRD() volatile
    {
        return MAC_MMC_CONTROL & (1u << 2u);
    }

    /**
     * Set MAC_MMC_CONTROL's RSTONRD bit.
     *
     * Reset on Read When this bit is set, the MMC counters are reset to zero
     * after Read (self-clearing after reset).
     */
    inline void set_MAC_MMC_CONTROL_RSTONRD() volatile
    {
        MAC_MMC_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MAC_MMC_CONTROL's RSTONRD bit.
     *
     * Reset on Read When this bit is set, the MMC counters are reset to zero
     * after Read (self-clearing after reset).
     */
    inline void clear_MAC_MMC_CONTROL_RSTONRD() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's RSTONRD bit.
     *
     * Reset on Read When this bit is set, the MMC counters are reset to zero
     * after Read (self-clearing after reset).
     */
    inline void toggle_MAC_MMC_CONTROL_RSTONRD() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 2u;
    }

    /**
     * Get MAC_MMC_CONTROL's CNTSTOPRO bit.
     *
     * Counter Stop Rollover When this bit is set, the counter does not roll
     * over to zero after reaching the maximum value.
     */
    inline bool get_MAC_MMC_CONTROL_CNTSTOPRO() volatile
    {
        return MAC_MMC_CONTROL & (1u << 1u);
    }

    /**
     * Set MAC_MMC_CONTROL's CNTSTOPRO bit.
     *
     * Counter Stop Rollover When this bit is set, the counter does not roll
     * over to zero after reaching the maximum value.
     */
    inline void set_MAC_MMC_CONTROL_CNTSTOPRO() volatile
    {
        MAC_MMC_CONTROL |= 1u << 1u;
    }

    /**
     * Clear MAC_MMC_CONTROL's CNTSTOPRO bit.
     *
     * Counter Stop Rollover When this bit is set, the counter does not roll
     * over to zero after reaching the maximum value.
     */
    inline void clear_MAC_MMC_CONTROL_CNTSTOPRO() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's CNTSTOPRO bit.
     *
     * Counter Stop Rollover When this bit is set, the counter does not roll
     * over to zero after reaching the maximum value.
     */
    inline void toggle_MAC_MMC_CONTROL_CNTSTOPRO() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 1u;
    }

    /**
     * Get MAC_MMC_CONTROL's CNTRST bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline bool get_MAC_MMC_CONTROL_CNTRST() volatile
    {
        return MAC_MMC_CONTROL & (1u << 0u);
    }

    /**
     * Set MAC_MMC_CONTROL's CNTRST bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline void set_MAC_MMC_CONTROL_CNTRST() volatile
    {
        MAC_MMC_CONTROL |= 1u << 0u;
    }

    /**
     * Clear MAC_MMC_CONTROL's CNTRST bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline void clear_MAC_MMC_CONTROL_CNTRST() volatile
    {
        MAC_MMC_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MMC_CONTROL's CNTRST bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline void toggle_MAC_MMC_CONTROL_CNTRST() volatile
    {
        MAC_MMC_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MMC_CONTROL's bit fields.
     *
     * (read-write) MMC Control
     */
    inline void get_MAC_MMC_CONTROL(bool &UCDBC, bool &CNTPRSTLVL,
                                    bool &CNTPRST, bool &CNTFREEZ,
                                    bool &RSTONRD, bool &CNTSTOPRO,
                                    bool &CNTRST) volatile
    {
        uint32_t curr = MAC_MMC_CONTROL;

        UCDBC = curr & (1u << 8u);
        CNTPRSTLVL = curr & (1u << 5u);
        CNTPRST = curr & (1u << 4u);
        CNTFREEZ = curr & (1u << 3u);
        RSTONRD = curr & (1u << 2u);
        CNTSTOPRO = curr & (1u << 1u);
        CNTRST = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MMC_CONTROL's bit fields.
     *
     * (read-write) MMC Control
     */
    inline void set_MAC_MMC_CONTROL(bool UCDBC, bool CNTPRSTLVL, bool CNTPRST,
                                    bool CNTFREEZ, bool RSTONRD,
                                    bool CNTSTOPRO, bool CNTRST) volatile
    {
        uint32_t curr = MAC_MMC_CONTROL;

        curr &= ~(0b1u << 8u);
        curr |= (UCDBC & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (CNTPRSTLVL & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CNTPRST & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CNTFREEZ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RSTONRD & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CNTSTOPRO & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CNTRST & 0b1u) << 0u;

        MAC_MMC_CONTROL = curr;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXLPITRCIS bit.
     *
     * MMC Receive LPI transition counter interrupt status This bit is set when
     * the Rx_LPI_Tran_Cntr counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXLPITRCIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 27u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXLPIUSCIS bit.
     *
     * MMC Receive LPI microsecond counter interrupt status This bit is set
     * when the Rx_LPI_USEC_Cntr counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 26u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXCTRLPIS bit.
     *
     * MMC Receive Control Packet Counter Interrupt Status This bit is set when
     * the rxctrlpackets_g counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXCTRLPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 25u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXRCVERRPIS bit.
     *
     * MMC Receive Error Packet Counter Interrupt Status This bit is set when
     * the rxrcverror counter reaches half of the maximum value or the maximum
     * value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXRCVERRPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 24u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXWDOGPIS bit.
     *
     * MMC Receive Watchdog Error Packet Counter Interrupt Status This bit is
     * set when the rxwatchdog error counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXWDOGPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 23u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXVLANGBPIS bit.
     *
     * MMC Receive VLAN Good Bad Packet Counter Interrupt Status This bit is
     * set when the rxvlanpackets_gb counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXVLANGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 22u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXFOVPIS bit.
     *
     * MMC Receive FIFO Overflow Packet Counter Interrupt Status This bit is
     * set when the rxfifooverflow counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXFOVPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 21u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXPAUSPIS bit.
     *
     * MMC Receive Pause Packet Counter Interrupt Status This bit is set when
     * the rxpausepackets counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXPAUSPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 20u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXORANGEPIS bit.
     *
     * MMC Receive Out Of Range Error Packet Counter Interrupt Status.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXORANGEPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 19u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXLENERPIS bit.
     *
     * MMC Receive Length Error Packet Counter Interrupt Status This bit is set
     * when the rxlengtherror counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXLENERPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 18u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXUCGPIS bit.
     *
     * MMC Receive Unicast Good Packet Counter Interrupt Status This bit is set
     * when the rxunicastpackets_g counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXUCGPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 17u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RX1024TMAXOCTGBPIS bit.
     *
     * MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Status This bit is set when the rx1024tomaxoctets_gb counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 16u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RX512T1023OCTGBPIS bit.
     *
     * MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the rx512to1023octets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 15u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RX256T511OCTGBPIS bit.
     *
     * MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the rx256to511octets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RX256T511OCTGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 14u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RX128T255OCTGBPIS bit.
     *
     * MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the rx128to255octets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RX128T255OCTGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 13u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RX65T127OCTGBPIS bit.
     *
     * MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the rx65to127octets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RX65T127OCTGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 12u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RX64OCTGBPIS bit.
     *
     * MMC Receive 64 Octet Good Bad Packet Counter Interrupt Status This bit
     * is set when the rx64octets_gb counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RX64OCTGBPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 11u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXOSIZEGPIS bit.
     *
     * MMC Receive Oversize Good Packet Counter Interrupt Status This bit is
     * set when the rxoversize_g counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXOSIZEGPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 10u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXUSIZEGPIS bit.
     *
     * MMC Receive Undersize Good Packet Counter Interrupt Status This bit is
     * set when the rxundersize_g counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXUSIZEGPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 9u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXJABERPIS bit.
     *
     * MMC Receive Jabber Error Packet Counter Interrupt Status This bit is set
     * when the rxjabbererror counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXJABERPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 8u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXRUNTPIS bit.
     *
     * MMC Receive Runt Packet Counter Interrupt Status This bit is set when
     * the rxrunterror counter reaches half of the maximum value or the maximum
     * value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXRUNTPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 7u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXALGNERPIS bit.
     *
     * MMC Receive Alignment Error Packet Counter Interrupt Status This bit is
     * set when the rxalignmenterror counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXALGNERPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 6u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXCRCERPIS bit.
     *
     * MMC Receive CRC Error Packet Counter Interrupt Status This bit is set
     * when the rxcrcerror counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXCRCERPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 5u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXMCGPIS bit.
     *
     * MMC Receive Multicast Good Packet Counter Interrupt Status This bit is
     * set when the rxmulticastpackets_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXMCGPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 4u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXBCGPIS bit.
     *
     * MMC Receive Broadcast Good Packet Counter Interrupt Status This bit is
     * set when the rxbroadcastpackets_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXBCGPIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 3u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXGOCTIS bit.
     *
     * MMC Receive Good Octet Counter Interrupt Status This bit is set when the
     * rxoctetcount_g counter reaches half of the maximum value or the maximum
     * value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXGOCTIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 2u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXGBOCTIS bit.
     *
     * MMC Receive Good Bad Octet Counter Interrupt Status This bit is set when
     * the rxoctetcount_gb counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXGBOCTIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 1u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT's RXGBPKTIS bit.
     *
     * MMC Receive Good Bad Packet Counter Interrupt Status This bit is set
     * when the rxpacketcount_gb counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_RXGBPKTIS() volatile
    {
        return MAC_MMC_RX_INTERRUPT & (1u << 0u);
    }

    /**
     * Get all of MAC_MMC_RX_INTERRUPT's bit fields.
     *
     * (read-write) MMC Rx Interrupt
     */
    inline void get_MAC_MMC_RX_INTERRUPT(
        bool &RXLPITRCIS, bool &RXLPIUSCIS, bool &RXCTRLPIS, bool &RXRCVERRPIS,
        bool &RXWDOGPIS, bool &RXVLANGBPIS, bool &RXFOVPIS, bool &RXPAUSPIS,
        bool &RXORANGEPIS, bool &RXLENERPIS, bool &RXUCGPIS,
        bool &RX1024TMAXOCTGBPIS, bool &RX512T1023OCTGBPIS,
        bool &RX256T511OCTGBPIS, bool &RX128T255OCTGBPIS,
        bool &RX65T127OCTGBPIS, bool &RX64OCTGBPIS, bool &RXOSIZEGPIS,
        bool &RXUSIZEGPIS, bool &RXJABERPIS, bool &RXRUNTPIS,
        bool &RXALGNERPIS, bool &RXCRCERPIS, bool &RXMCGPIS, bool &RXBCGPIS,
        bool &RXGOCTIS, bool &RXGBOCTIS, bool &RXGBPKTIS) volatile
    {
        uint32_t curr = MAC_MMC_RX_INTERRUPT;

        RXLPITRCIS = curr & (1u << 27u);
        RXLPIUSCIS = curr & (1u << 26u);
        RXCTRLPIS = curr & (1u << 25u);
        RXRCVERRPIS = curr & (1u << 24u);
        RXWDOGPIS = curr & (1u << 23u);
        RXVLANGBPIS = curr & (1u << 22u);
        RXFOVPIS = curr & (1u << 21u);
        RXPAUSPIS = curr & (1u << 20u);
        RXORANGEPIS = curr & (1u << 19u);
        RXLENERPIS = curr & (1u << 18u);
        RXUCGPIS = curr & (1u << 17u);
        RX1024TMAXOCTGBPIS = curr & (1u << 16u);
        RX512T1023OCTGBPIS = curr & (1u << 15u);
        RX256T511OCTGBPIS = curr & (1u << 14u);
        RX128T255OCTGBPIS = curr & (1u << 13u);
        RX65T127OCTGBPIS = curr & (1u << 12u);
        RX64OCTGBPIS = curr & (1u << 11u);
        RXOSIZEGPIS = curr & (1u << 10u);
        RXUSIZEGPIS = curr & (1u << 9u);
        RXJABERPIS = curr & (1u << 8u);
        RXRUNTPIS = curr & (1u << 7u);
        RXALGNERPIS = curr & (1u << 6u);
        RXCRCERPIS = curr & (1u << 5u);
        RXMCGPIS = curr & (1u << 4u);
        RXBCGPIS = curr & (1u << 3u);
        RXGOCTIS = curr & (1u << 2u);
        RXGBOCTIS = curr & (1u << 1u);
        RXGBPKTIS = curr & (1u << 0u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXLPITRCIS bit.
     *
     * MMC Transmit LPI transition counter interrupt status This bit is set
     * when the Tx_LPI_Tran_Cntr counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXLPITRCIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 27u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXLPIUSCIS bit.
     *
     * MMC Transmit LPI microsecond counter interrupt status This bit is set
     * when the Tx_LPI_USEC_Cntr counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 26u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXOSIZEGPIS bit.
     *
     * MMC Transmit Oversize Good Packet Counter Interrupt Status This bit is
     * set when the txoversize_g counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXOSIZEGPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 25u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXVLANGPIS bit.
     *
     * MMC Transmit VLAN Good Packet Counter Interrupt Status This bit is set
     * when the txvlanpackets_g counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXVLANGPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 24u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXPAUSPIS bit.
     *
     * MMC Transmit Pause Packet Counter Interrupt Status This bit is set when
     * the txpausepacketserror counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXPAUSPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 23u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXEXDEFPIS bit.
     *
     * MMC Transmit Excessive Deferral Packet Counter Interrupt Status This bit
     * is set when the txexcessdef counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXEXDEFPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 22u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXGPKTIS bit.
     *
     * MMC Transmit Good Packet Counter Interrupt Status This bit is set when
     * the txpacketcount_g counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXGPKTIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 21u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXGOCTIS bit.
     *
     * MMC Transmit Good Octet Counter Interrupt Status This bit is set when
     * the txoctetcount_g counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXGOCTIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 20u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXCARERPIS bit.
     *
     * MMC Transmit Carrier Error Packet Counter Interrupt Status This bit is
     * set when the txcarriererror counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXCARERPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 19u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXEXCOLPIS bit.
     *
     * MMC Transmit Excessive Collision Packet Counter Interrupt Status This
     * bit is set when the txexesscol counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXEXCOLPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 18u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXLATCOLPIS bit.
     *
     * MMC Transmit Late Collision Packet Counter Interrupt Status This bit is
     * set when the txlatecol counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXLATCOLPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 17u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXDEFPIS bit.
     *
     * MMC Transmit Deferred Packet Counter Interrupt Status This bit is set
     * when the txdeferred counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXDEFPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 16u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXMCOLGPIS bit.
     *
     * MMC Transmit Multiple Collision Good Packet Counter Interrupt Status
     * This bit is set when the txmulticol_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 15u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXSCOLGPIS bit.
     *
     * MMC Transmit Single Collision Good Packet Counter Interrupt Status This
     * bit is set when the txsinglecol_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 14u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXUFLOWERPIS bit.
     *
     * MMC Transmit Underflow Error Packet Counter Interrupt Status This bit is
     * set when the txunderflowerror counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXUFLOWERPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 13u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXBCGBPIS bit.
     *
     * MMC Transmit Broadcast Good Bad Packet Counter Interrupt Status This bit
     * is set when the txbroadcastpackets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXBCGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 12u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXMCGBPIS bit.
     *
     * MMC Transmit Multicast Good Bad Packet Counter Interrupt Status The bit
     * is set when the txmulticastpackets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXMCGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 11u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXUCGBPIS bit.
     *
     * MMC Transmit Unicast Good Bad Packet Counter Interrupt Status This bit
     * is set when the txunicastpackets_gb counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXUCGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 10u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TX1024TMAXOCTGBPIS bit.
     *
     * MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Status This bit is set when the tx1024tomaxoctets_gb counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 9u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TX512T1023OCTGBPIS bit.
     *
     * MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the tx512to1023octets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 8u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TX256T511OCTGBPIS bit.
     *
     * MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the tx256to511octets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TX256T511OCTGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 7u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TX128T255OCTGBPIS bit.
     *
     * MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the tx128to255octets_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TX128T255OCTGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 6u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TX65T127OCTGBPIS bit.
     *
     * MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Status
     * This bit is set when the tx65to127octets_gb counter reaches half the
     * maximum value, and also when it reaches the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TX65T127OCTGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 5u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TX64OCTGBPIS bit.
     *
     * MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Status This bit
     * is set when the tx64octets_gb counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TX64OCTGBPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 4u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXMCGPIS bit.
     *
     * MMC Transmit Multicast Good Packet Counter Interrupt Status This bit is
     * set when the txmulticastpackets_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXMCGPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 3u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXBCGPIS bit.
     *
     * MMC Transmit Broadcast Good Packet Counter Interrupt Status This bit is
     * set when the txbroadcastpackets_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXBCGPIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 2u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXGBPKTIS bit.
     *
     * MMC Transmit Good Bad Packet Counter Interrupt Status This bit is set
     * when the txpacketcount_gb counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXGBPKTIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 1u);
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT's TXGBOCTIS bit.
     *
     * MMC Transmit Good Bad Octet Counter Interrupt Status This bit is set
     * when the txoctetcount_gb counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_TXGBOCTIS() volatile
    {
        return MAC_MMC_TX_INTERRUPT & (1u << 0u);
    }

    /**
     * Get all of MAC_MMC_TX_INTERRUPT's bit fields.
     *
     * (read-write) MMC Tx Interrupt
     */
    inline void get_MAC_MMC_TX_INTERRUPT(
        bool &TXLPITRCIS, bool &TXLPIUSCIS, bool &TXOSIZEGPIS,
        bool &TXVLANGPIS, bool &TXPAUSPIS, bool &TXEXDEFPIS, bool &TXGPKTIS,
        bool &TXGOCTIS, bool &TXCARERPIS, bool &TXEXCOLPIS, bool &TXLATCOLPIS,
        bool &TXDEFPIS, bool &TXMCOLGPIS, bool &TXSCOLGPIS, bool &TXUFLOWERPIS,
        bool &TXBCGBPIS, bool &TXMCGBPIS, bool &TXUCGBPIS,
        bool &TX1024TMAXOCTGBPIS, bool &TX512T1023OCTGBPIS,
        bool &TX256T511OCTGBPIS, bool &TX128T255OCTGBPIS,
        bool &TX65T127OCTGBPIS, bool &TX64OCTGBPIS, bool &TXMCGPIS,
        bool &TXBCGPIS, bool &TXGBPKTIS, bool &TXGBOCTIS) volatile
    {
        uint32_t curr = MAC_MMC_TX_INTERRUPT;

        TXLPITRCIS = curr & (1u << 27u);
        TXLPIUSCIS = curr & (1u << 26u);
        TXOSIZEGPIS = curr & (1u << 25u);
        TXVLANGPIS = curr & (1u << 24u);
        TXPAUSPIS = curr & (1u << 23u);
        TXEXDEFPIS = curr & (1u << 22u);
        TXGPKTIS = curr & (1u << 21u);
        TXGOCTIS = curr & (1u << 20u);
        TXCARERPIS = curr & (1u << 19u);
        TXEXCOLPIS = curr & (1u << 18u);
        TXLATCOLPIS = curr & (1u << 17u);
        TXDEFPIS = curr & (1u << 16u);
        TXMCOLGPIS = curr & (1u << 15u);
        TXSCOLGPIS = curr & (1u << 14u);
        TXUFLOWERPIS = curr & (1u << 13u);
        TXBCGBPIS = curr & (1u << 12u);
        TXMCGBPIS = curr & (1u << 11u);
        TXUCGBPIS = curr & (1u << 10u);
        TX1024TMAXOCTGBPIS = curr & (1u << 9u);
        TX512T1023OCTGBPIS = curr & (1u << 8u);
        TX256T511OCTGBPIS = curr & (1u << 7u);
        TX128T255OCTGBPIS = curr & (1u << 6u);
        TX65T127OCTGBPIS = curr & (1u << 5u);
        TX64OCTGBPIS = curr & (1u << 4u);
        TXMCGPIS = curr & (1u << 3u);
        TXBCGPIS = curr & (1u << 2u);
        TXGBPKTIS = curr & (1u << 1u);
        TXGBOCTIS = curr & (1u << 0u);
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXLPITRCIM bit.
     *
     * MMC Receive LPI transition counter interrupt Mask Setting this bit masks
     * the interrupt when the Rx_LPI_Tran_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 27u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXLPITRCIM bit.
     *
     * MMC Receive LPI transition counter interrupt Mask Setting this bit masks
     * the interrupt when the Rx_LPI_Tran_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 27u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXLPITRCIM bit.
     *
     * MMC Receive LPI transition counter interrupt Mask Setting this bit masks
     * the interrupt when the Rx_LPI_Tran_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 27u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXLPITRCIM bit.
     *
     * MMC Receive LPI transition counter interrupt Mask Setting this bit masks
     * the interrupt when the Rx_LPI_Tran_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 27u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXLPIUSCIM bit.
     *
     * MMC Receive LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Rx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 26u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXLPIUSCIM bit.
     *
     * MMC Receive LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Rx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 26u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXLPIUSCIM bit.
     *
     * MMC Receive LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Rx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 26u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXLPIUSCIM bit.
     *
     * MMC Receive LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Rx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 26u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXCTRLPIM bit.
     *
     * MMC Receive Control Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxctrlpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXCTRLPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 25u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXCTRLPIM bit.
     *
     * MMC Receive Control Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxctrlpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXCTRLPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 25u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXCTRLPIM bit.
     *
     * MMC Receive Control Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxctrlpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXCTRLPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 25u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXCTRLPIM bit.
     *
     * MMC Receive Control Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxctrlpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXCTRLPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 25u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXRCVERRPIM bit.
     *
     * MMC Receive Error Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrcverror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXRCVERRPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 24u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXRCVERRPIM bit.
     *
     * MMC Receive Error Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrcverror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXRCVERRPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 24u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXRCVERRPIM bit.
     *
     * MMC Receive Error Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrcverror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXRCVERRPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXRCVERRPIM bit.
     *
     * MMC Receive Error Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrcverror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXRCVERRPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 24u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXWDOGPIM bit.
     *
     * MMC Receive Watchdog Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxwatchdog counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXWDOGPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 23u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXWDOGPIM bit.
     *
     * MMC Receive Watchdog Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxwatchdog counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXWDOGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 23u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXWDOGPIM bit.
     *
     * MMC Receive Watchdog Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxwatchdog counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXWDOGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 23u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXWDOGPIM bit.
     *
     * MMC Receive Watchdog Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxwatchdog counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXWDOGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 23u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXVLANGBPIM bit.
     *
     * MMC Receive VLAN Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxvlanpackets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXVLANGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 22u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXVLANGBPIM bit.
     *
     * MMC Receive VLAN Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxvlanpackets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXVLANGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 22u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXVLANGBPIM bit.
     *
     * MMC Receive VLAN Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxvlanpackets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXVLANGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 22u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXVLANGBPIM bit.
     *
     * MMC Receive VLAN Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxvlanpackets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXVLANGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 22u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXFOVPIM bit.
     *
     * MMC Receive FIFO Overflow Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxfifooverflow counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXFOVPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 21u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXFOVPIM bit.
     *
     * MMC Receive FIFO Overflow Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxfifooverflow counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXFOVPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 21u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXFOVPIM bit.
     *
     * MMC Receive FIFO Overflow Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxfifooverflow counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXFOVPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXFOVPIM bit.
     *
     * MMC Receive FIFO Overflow Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxfifooverflow counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXFOVPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 21u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXPAUSPIM bit.
     *
     * MMC Receive Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXPAUSPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 20u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXPAUSPIM bit.
     *
     * MMC Receive Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXPAUSPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 20u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXPAUSPIM bit.
     *
     * MMC Receive Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXPAUSPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXPAUSPIM bit.
     *
     * MMC Receive Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXPAUSPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 20u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXORANGEPIM bit.
     *
     * MMC Receive Out Of Range Error Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the rxoutofrangetype counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXORANGEPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 19u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXORANGEPIM bit.
     *
     * MMC Receive Out Of Range Error Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the rxoutofrangetype counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXORANGEPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 19u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXORANGEPIM bit.
     *
     * MMC Receive Out Of Range Error Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the rxoutofrangetype counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXORANGEPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXORANGEPIM bit.
     *
     * MMC Receive Out Of Range Error Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the rxoutofrangetype counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXORANGEPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 19u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXLENERPIM bit.
     *
     * MMC Receive Length Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxlengtherror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXLENERPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 18u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXLENERPIM bit.
     *
     * MMC Receive Length Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxlengtherror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXLENERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 18u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXLENERPIM bit.
     *
     * MMC Receive Length Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxlengtherror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXLENERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXLENERPIM bit.
     *
     * MMC Receive Length Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxlengtherror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXLENERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 18u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXUCGPIM bit.
     *
     * MMC Receive Unicast Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxunicastpackets_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 17u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXUCGPIM bit.
     *
     * MMC Receive Unicast Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxunicastpackets_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 17u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXUCGPIM bit.
     *
     * MMC Receive Unicast Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxunicastpackets_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXUCGPIM bit.
     *
     * MMC Receive Unicast Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxunicastpackets_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 17u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RX1024TMAXOCTGBPIM bit.
     *
     * MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RX1024TMAXOCTGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 16u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RX1024TMAXOCTGBPIM bit.
     *
     * MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RX1024TMAXOCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 16u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RX1024TMAXOCTGBPIM bit.
     *
     * MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RX1024TMAXOCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RX1024TMAXOCTGBPIM bit.
     *
     * MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RX1024TMAXOCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 16u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RX512T1023OCTGBPIM bit.
     *
     * MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RX512T1023OCTGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 15u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RX512T1023OCTGBPIM bit.
     *
     * MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RX512T1023OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 15u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RX512T1023OCTGBPIM bit.
     *
     * MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RX512T1023OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 15u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RX512T1023OCTGBPIM bit.
     *
     * MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RX512T1023OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 15u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RX256T511OCTGBPIM bit.
     *
     * MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RX256T511OCTGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 14u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RX256T511OCTGBPIM bit.
     *
     * MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RX256T511OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 14u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RX256T511OCTGBPIM bit.
     *
     * MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RX256T511OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 14u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RX256T511OCTGBPIM bit.
     *
     * MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RX256T511OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 14u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RX128T255OCTGBPIM bit.
     *
     * MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RX128T255OCTGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 13u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RX128T255OCTGBPIM bit.
     *
     * MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RX128T255OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 13u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RX128T255OCTGBPIM bit.
     *
     * MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RX128T255OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 13u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RX128T255OCTGBPIM bit.
     *
     * MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RX128T255OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 13u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RX65T127OCTGBPIM bit.
     *
     * MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RX65T127OCTGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 12u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RX65T127OCTGBPIM bit.
     *
     * MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RX65T127OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 12u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RX65T127OCTGBPIM bit.
     *
     * MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RX65T127OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 12u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RX65T127OCTGBPIM bit.
     *
     * MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RX65T127OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 12u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RX64OCTGBPIM bit.
     *
     * MMC Receive 64 Octet Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rx64octets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RX64OCTGBPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 11u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RX64OCTGBPIM bit.
     *
     * MMC Receive 64 Octet Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rx64octets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RX64OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 11u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RX64OCTGBPIM bit.
     *
     * MMC Receive 64 Octet Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rx64octets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RX64OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 11u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RX64OCTGBPIM bit.
     *
     * MMC Receive 64 Octet Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rx64octets_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RX64OCTGBPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 11u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXOSIZEGPIM bit.
     *
     * MMC Receive Oversize Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxoversize_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXOSIZEGPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 10u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXOSIZEGPIM bit.
     *
     * MMC Receive Oversize Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxoversize_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXOSIZEGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 10u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXOSIZEGPIM bit.
     *
     * MMC Receive Oversize Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxoversize_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXOSIZEGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXOSIZEGPIM bit.
     *
     * MMC Receive Oversize Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxoversize_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXOSIZEGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 10u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXUSIZEGPIM bit.
     *
     * MMC Receive Undersize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxundersize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXUSIZEGPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 9u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXUSIZEGPIM bit.
     *
     * MMC Receive Undersize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxundersize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXUSIZEGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 9u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXUSIZEGPIM bit.
     *
     * MMC Receive Undersize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxundersize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXUSIZEGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXUSIZEGPIM bit.
     *
     * MMC Receive Undersize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxundersize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXUSIZEGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 9u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXJABERPIM bit.
     *
     * MMC Receive Jabber Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxjabbererror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXJABERPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 8u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXJABERPIM bit.
     *
     * MMC Receive Jabber Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxjabbererror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXJABERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 8u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXJABERPIM bit.
     *
     * MMC Receive Jabber Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxjabbererror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXJABERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXJABERPIM bit.
     *
     * MMC Receive Jabber Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxjabbererror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXJABERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 8u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXRUNTPIM bit.
     *
     * MMC Receive Runt Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrunterror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXRUNTPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 7u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXRUNTPIM bit.
     *
     * MMC Receive Runt Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrunterror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXRUNTPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 7u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXRUNTPIM bit.
     *
     * MMC Receive Runt Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrunterror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXRUNTPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXRUNTPIM bit.
     *
     * MMC Receive Runt Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxrunterror counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXRUNTPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 7u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXALGNERPIM bit.
     *
     * MMC Receive Alignment Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxalignmenterror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 6u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXALGNERPIM bit.
     *
     * MMC Receive Alignment Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxalignmenterror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 6u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXALGNERPIM bit.
     *
     * MMC Receive Alignment Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxalignmenterror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 6u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXALGNERPIM bit.
     *
     * MMC Receive Alignment Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxalignmenterror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 6u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXCRCERPIM bit.
     *
     * MMC Receive CRC Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxcrcerror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 5u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXCRCERPIM bit.
     *
     * MMC Receive CRC Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxcrcerror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 5u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXCRCERPIM bit.
     *
     * MMC Receive CRC Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxcrcerror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXCRCERPIM bit.
     *
     * MMC Receive CRC Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxcrcerror counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 5u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXMCGPIM bit.
     *
     * MMC Receive Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXMCGPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 4u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXMCGPIM bit.
     *
     * MMC Receive Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXMCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 4u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXMCGPIM bit.
     *
     * MMC Receive Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXMCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXMCGPIM bit.
     *
     * MMC Receive Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXMCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 4u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXBCGPIM bit.
     *
     * MMC Receive Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXBCGPIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 3u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXBCGPIM bit.
     *
     * MMC Receive Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXBCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 3u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXBCGPIM bit.
     *
     * MMC Receive Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXBCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXBCGPIM bit.
     *
     * MMC Receive Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXBCGPIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 3u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXGOCTIM bit.
     *
     * MMC Receive Good Octet Counter Interrupt Mask Setting this bit masks the
     * interrupt when the rxoctetcount_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXGOCTIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 2u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXGOCTIM bit.
     *
     * MMC Receive Good Octet Counter Interrupt Mask Setting this bit masks the
     * interrupt when the rxoctetcount_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXGOCTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 2u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXGOCTIM bit.
     *
     * MMC Receive Good Octet Counter Interrupt Mask Setting this bit masks the
     * interrupt when the rxoctetcount_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXGOCTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXGOCTIM bit.
     *
     * MMC Receive Good Octet Counter Interrupt Mask Setting this bit masks the
     * interrupt when the rxoctetcount_g counter reaches half of the maximum
     * value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXGOCTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 2u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXGBOCTIM bit.
     *
     * MMC Receive Good Bad Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXGBOCTIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 1u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXGBOCTIM bit.
     *
     * MMC Receive Good Bad Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXGBOCTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 1u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXGBOCTIM bit.
     *
     * MMC Receive Good Bad Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXGBOCTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXGBOCTIM bit.
     *
     * MMC Receive Good Bad Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXGBOCTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 1u;
    }

    /**
     * Get MAC_MMC_RX_INTERRUPT_MASK's RXGBPKTIM bit.
     *
     * MMC Receive Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_RX_INTERRUPT_MASK_RXGBPKTIM() volatile
    {
        return MAC_MMC_RX_INTERRUPT_MASK & (1u << 0u);
    }

    /**
     * Set MAC_MMC_RX_INTERRUPT_MASK's RXGBPKTIM bit.
     *
     * MMC Receive Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK_RXGBPKTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK |= 1u << 0u;
    }

    /**
     * Clear MAC_MMC_RX_INTERRUPT_MASK's RXGBPKTIM bit.
     *
     * MMC Receive Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_RX_INTERRUPT_MASK_RXGBPKTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MMC_RX_INTERRUPT_MASK's RXGBPKTIM bit.
     *
     * MMC Receive Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_RX_INTERRUPT_MASK_RXGBPKTIM() volatile
    {
        MAC_MMC_RX_INTERRUPT_MASK ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MMC_RX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC Rx Interrupt Mask
     */
    inline void get_MAC_MMC_RX_INTERRUPT_MASK(
        bool &RXLPITRCIM, bool &RXLPIUSCIM, bool &RXCTRLPIM, bool &RXRCVERRPIM,
        bool &RXWDOGPIM, bool &RXVLANGBPIM, bool &RXFOVPIM, bool &RXPAUSPIM,
        bool &RXORANGEPIM, bool &RXLENERPIM, bool &RXUCGPIM,
        bool &RX1024TMAXOCTGBPIM, bool &RX512T1023OCTGBPIM,
        bool &RX256T511OCTGBPIM, bool &RX128T255OCTGBPIM,
        bool &RX65T127OCTGBPIM, bool &RX64OCTGBPIM, bool &RXOSIZEGPIM,
        bool &RXUSIZEGPIM, bool &RXJABERPIM, bool &RXRUNTPIM,
        bool &RXALGNERPIM, bool &RXCRCERPIM, bool &RXMCGPIM, bool &RXBCGPIM,
        bool &RXGOCTIM, bool &RXGBOCTIM, bool &RXGBPKTIM) volatile
    {
        uint32_t curr = MAC_MMC_RX_INTERRUPT_MASK;

        RXLPITRCIM = curr & (1u << 27u);
        RXLPIUSCIM = curr & (1u << 26u);
        RXCTRLPIM = curr & (1u << 25u);
        RXRCVERRPIM = curr & (1u << 24u);
        RXWDOGPIM = curr & (1u << 23u);
        RXVLANGBPIM = curr & (1u << 22u);
        RXFOVPIM = curr & (1u << 21u);
        RXPAUSPIM = curr & (1u << 20u);
        RXORANGEPIM = curr & (1u << 19u);
        RXLENERPIM = curr & (1u << 18u);
        RXUCGPIM = curr & (1u << 17u);
        RX1024TMAXOCTGBPIM = curr & (1u << 16u);
        RX512T1023OCTGBPIM = curr & (1u << 15u);
        RX256T511OCTGBPIM = curr & (1u << 14u);
        RX128T255OCTGBPIM = curr & (1u << 13u);
        RX65T127OCTGBPIM = curr & (1u << 12u);
        RX64OCTGBPIM = curr & (1u << 11u);
        RXOSIZEGPIM = curr & (1u << 10u);
        RXUSIZEGPIM = curr & (1u << 9u);
        RXJABERPIM = curr & (1u << 8u);
        RXRUNTPIM = curr & (1u << 7u);
        RXALGNERPIM = curr & (1u << 6u);
        RXCRCERPIM = curr & (1u << 5u);
        RXMCGPIM = curr & (1u << 4u);
        RXBCGPIM = curr & (1u << 3u);
        RXGOCTIM = curr & (1u << 2u);
        RXGBOCTIM = curr & (1u << 1u);
        RXGBPKTIM = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MMC_RX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC Rx Interrupt Mask
     */
    inline void set_MAC_MMC_RX_INTERRUPT_MASK(
        bool RXLPITRCIM, bool RXLPIUSCIM, bool RXCTRLPIM, bool RXRCVERRPIM,
        bool RXWDOGPIM, bool RXVLANGBPIM, bool RXFOVPIM, bool RXPAUSPIM,
        bool RXORANGEPIM, bool RXLENERPIM, bool RXUCGPIM,
        bool RX1024TMAXOCTGBPIM, bool RX512T1023OCTGBPIM,
        bool RX256T511OCTGBPIM, bool RX128T255OCTGBPIM, bool RX65T127OCTGBPIM,
        bool RX64OCTGBPIM, bool RXOSIZEGPIM, bool RXUSIZEGPIM, bool RXJABERPIM,
        bool RXRUNTPIM, bool RXALGNERPIM, bool RXCRCERPIM, bool RXMCGPIM,
        bool RXBCGPIM, bool RXGOCTIM, bool RXGBOCTIM, bool RXGBPKTIM) volatile
    {
        uint32_t curr = MAC_MMC_RX_INTERRUPT_MASK;

        curr &= ~(0b1u << 27u);
        curr |= (RXLPITRCIM & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (RXLPIUSCIM & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (RXCTRLPIM & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RXRCVERRPIM & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (RXWDOGPIM & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (RXVLANGBPIM & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (RXFOVPIM & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (RXPAUSPIM & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXORANGEPIM & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXLENERPIM & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RXUCGPIM & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RX1024TMAXOCTGBPIM & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (RX512T1023OCTGBPIM & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (RX256T511OCTGBPIM & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (RX128T255OCTGBPIM & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (RX65T127OCTGBPIM & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (RX64OCTGBPIM & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RXOSIZEGPIM & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RXUSIZEGPIM & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RXJABERPIM & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RXRUNTPIM & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RXALGNERPIM & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RXCRCERPIM & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (RXMCGPIM & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (RXBCGPIM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RXGOCTIM & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RXGBOCTIM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RXGBPKTIM & 0b1u) << 0u;

        MAC_MMC_RX_INTERRUPT_MASK = curr;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXLPITRCIM bit.
     *
     * MMC Transmit LPI transition counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_Tran_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 27u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXLPITRCIM bit.
     *
     * MMC Transmit LPI transition counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_Tran_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 27u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXLPITRCIM bit.
     *
     * MMC Transmit LPI transition counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_Tran_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 27u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXLPITRCIM bit.
     *
     * MMC Transmit LPI transition counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_Tran_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 27u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXLPIUSCIM bit.
     *
     * MMC Transmit LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 26u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXLPIUSCIM bit.
     *
     * MMC Transmit LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 26u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXLPIUSCIM bit.
     *
     * MMC Transmit LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 26u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXLPIUSCIM bit.
     *
     * MMC Transmit LPI microsecond counter interrupt Mask Setting this bit
     * masks the interrupt when the Tx_LPI_USEC_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 26u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXOSIZEGPIM bit.
     *
     * MMC Transmit Oversize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txoversize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXOSIZEGPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 25u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXOSIZEGPIM bit.
     *
     * MMC Transmit Oversize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txoversize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXOSIZEGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 25u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXOSIZEGPIM bit.
     *
     * MMC Transmit Oversize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txoversize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXOSIZEGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 25u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXOSIZEGPIM bit.
     *
     * MMC Transmit Oversize Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txoversize_g counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXOSIZEGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 25u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXVLANGPIM bit.
     *
     * MMC Transmit VLAN Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txvlanpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXVLANGPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 24u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXVLANGPIM bit.
     *
     * MMC Transmit VLAN Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txvlanpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXVLANGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 24u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXVLANGPIM bit.
     *
     * MMC Transmit VLAN Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txvlanpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXVLANGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXVLANGPIM bit.
     *
     * MMC Transmit VLAN Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txvlanpackets_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXVLANGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 24u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXPAUSPIM bit.
     *
     * MMC Transmit Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXPAUSPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 23u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXPAUSPIM bit.
     *
     * MMC Transmit Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXPAUSPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 23u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXPAUSPIM bit.
     *
     * MMC Transmit Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXPAUSPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 23u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXPAUSPIM bit.
     *
     * MMC Transmit Pause Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpausepackets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXPAUSPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 23u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXEXDEFPIM bit.
     *
     * MMC Transmit Excessive Deferral Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcessdef counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXEXDEFPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 22u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXEXDEFPIM bit.
     *
     * MMC Transmit Excessive Deferral Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcessdef counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXEXDEFPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 22u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXEXDEFPIM bit.
     *
     * MMC Transmit Excessive Deferral Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcessdef counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXEXDEFPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 22u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXEXDEFPIM bit.
     *
     * MMC Transmit Excessive Deferral Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcessdef counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXEXDEFPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 22u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXGPKTIM bit.
     *
     * MMC Transmit Good Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpacketcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 21u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXGPKTIM bit.
     *
     * MMC Transmit Good Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpacketcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 21u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXGPKTIM bit.
     *
     * MMC Transmit Good Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpacketcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXGPKTIM bit.
     *
     * MMC Transmit Good Packet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txpacketcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 21u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXGOCTIM bit.
     *
     * MMC Transmit Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txoctetcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXGOCTIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 20u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXGOCTIM bit.
     *
     * MMC Transmit Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txoctetcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXGOCTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 20u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXGOCTIM bit.
     *
     * MMC Transmit Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txoctetcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXGOCTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXGOCTIM bit.
     *
     * MMC Transmit Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the txoctetcount_g counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXGOCTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 20u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXCARERPIM bit.
     *
     * MMC Transmit Carrier Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txcarriererror counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXCARERPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 19u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXCARERPIM bit.
     *
     * MMC Transmit Carrier Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txcarriererror counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXCARERPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 19u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXCARERPIM bit.
     *
     * MMC Transmit Carrier Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txcarriererror counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXCARERPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXCARERPIM bit.
     *
     * MMC Transmit Carrier Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txcarriererror counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXCARERPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 19u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXEXCOLPIM bit.
     *
     * MMC Transmit Excessive Collision Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcesscol counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXEXCOLPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 18u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXEXCOLPIM bit.
     *
     * MMC Transmit Excessive Collision Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcesscol counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXEXCOLPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 18u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXEXCOLPIM bit.
     *
     * MMC Transmit Excessive Collision Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcesscol counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXEXCOLPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXEXCOLPIM bit.
     *
     * MMC Transmit Excessive Collision Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txexcesscol counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXEXCOLPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 18u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXLATCOLPIM bit.
     *
     * MMC Transmit Late Collision Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txlatecol counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXLATCOLPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 17u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXLATCOLPIM bit.
     *
     * MMC Transmit Late Collision Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txlatecol counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXLATCOLPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 17u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXLATCOLPIM bit.
     *
     * MMC Transmit Late Collision Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txlatecol counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXLATCOLPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXLATCOLPIM bit.
     *
     * MMC Transmit Late Collision Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txlatecol counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXLATCOLPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 17u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXDEFPIM bit.
     *
     * MMC Transmit Deferred Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txdeferred counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXDEFPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 16u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXDEFPIM bit.
     *
     * MMC Transmit Deferred Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txdeferred counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXDEFPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 16u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXDEFPIM bit.
     *
     * MMC Transmit Deferred Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txdeferred counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXDEFPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXDEFPIM bit.
     *
     * MMC Transmit Deferred Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txdeferred counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXDEFPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 16u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXMCOLGPIM bit.
     *
     * MMC Transmit Multiple Collision Good Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the txmulticol_g counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 15u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXMCOLGPIM bit.
     *
     * MMC Transmit Multiple Collision Good Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the txmulticol_g counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 15u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXMCOLGPIM bit.
     *
     * MMC Transmit Multiple Collision Good Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the txmulticol_g counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 15u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXMCOLGPIM bit.
     *
     * MMC Transmit Multiple Collision Good Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the txmulticol_g counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 15u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXSCOLGPIM bit.
     *
     * MMC Transmit Single Collision Good Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txsinglecol_g counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 14u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXSCOLGPIM bit.
     *
     * MMC Transmit Single Collision Good Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txsinglecol_g counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 14u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXSCOLGPIM bit.
     *
     * MMC Transmit Single Collision Good Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txsinglecol_g counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 14u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXSCOLGPIM bit.
     *
     * MMC Transmit Single Collision Good Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txsinglecol_g counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 14u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXUFLOWERPIM bit.
     *
     * MMC Transmit Underflow Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunderflowerror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXUFLOWERPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 13u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXUFLOWERPIM bit.
     *
     * MMC Transmit Underflow Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunderflowerror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXUFLOWERPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 13u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXUFLOWERPIM bit.
     *
     * MMC Transmit Underflow Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunderflowerror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXUFLOWERPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 13u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXUFLOWERPIM bit.
     *
     * MMC Transmit Underflow Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunderflowerror counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXUFLOWERPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 13u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXBCGBPIM bit.
     *
     * MMC Transmit Broadcast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txbroadcastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXBCGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 12u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXBCGBPIM bit.
     *
     * MMC Transmit Broadcast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txbroadcastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXBCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 12u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXBCGBPIM bit.
     *
     * MMC Transmit Broadcast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txbroadcastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXBCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 12u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXBCGBPIM bit.
     *
     * MMC Transmit Broadcast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txbroadcastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXBCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 12u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXMCGBPIM bit.
     *
     * MMC Transmit Multicast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txmulticastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXMCGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 11u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXMCGBPIM bit.
     *
     * MMC Transmit Multicast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txmulticastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXMCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 11u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXMCGBPIM bit.
     *
     * MMC Transmit Multicast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txmulticastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXMCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 11u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXMCGBPIM bit.
     *
     * MMC Transmit Multicast Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the txmulticastpackets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXMCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 11u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXUCGBPIM bit.
     *
     * MMC Transmit Unicast Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunicastpackets_gb counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXUCGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 10u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXUCGBPIM bit.
     *
     * MMC Transmit Unicast Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunicastpackets_gb counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXUCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 10u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXUCGBPIM bit.
     *
     * MMC Transmit Unicast Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunicastpackets_gb counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXUCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXUCGBPIM bit.
     *
     * MMC Transmit Unicast Good Bad Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txunicastpackets_gb counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXUCGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 10u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TX1024TMAXOCTGBPIM bit.
     *
     * MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask Setting this bit masks the interrupt when the tx1024tomaxoctets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TX1024TMAXOCTGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 9u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TX1024TMAXOCTGBPIM bit.
     *
     * MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask Setting this bit masks the interrupt when the tx1024tomaxoctets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TX1024TMAXOCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 9u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TX1024TMAXOCTGBPIM bit.
     *
     * MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask Setting this bit masks the interrupt when the tx1024tomaxoctets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TX1024TMAXOCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TX1024TMAXOCTGBPIM bit.
     *
     * MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt
     * Mask Setting this bit masks the interrupt when the tx1024tomaxoctets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TX1024TMAXOCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 9u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TX512T1023OCTGBPIM bit.
     *
     * MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TX512T1023OCTGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 8u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TX512T1023OCTGBPIM bit.
     *
     * MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TX512T1023OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 8u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TX512T1023OCTGBPIM bit.
     *
     * MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TX512T1023OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TX512T1023OCTGBPIM bit.
     *
     * MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx512to1023octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TX512T1023OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 8u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TX256T511OCTGBPIM bit.
     *
     * MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TX256T511OCTGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 7u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TX256T511OCTGBPIM bit.
     *
     * MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TX256T511OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 7u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TX256T511OCTGBPIM bit.
     *
     * MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TX256T511OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TX256T511OCTGBPIM bit.
     *
     * MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx256to511octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TX256T511OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 7u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TX128T255OCTGBPIM bit.
     *
     * MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TX128T255OCTGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 6u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TX128T255OCTGBPIM bit.
     *
     * MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TX128T255OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 6u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TX128T255OCTGBPIM bit.
     *
     * MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TX128T255OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 6u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TX128T255OCTGBPIM bit.
     *
     * MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx128to255octets_gb
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TX128T255OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 6u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TX65T127OCTGBPIM bit.
     *
     * MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TX65T127OCTGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 5u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TX65T127OCTGBPIM bit.
     *
     * MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TX65T127OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 5u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TX65T127OCTGBPIM bit.
     *
     * MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TX65T127OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TX65T127OCTGBPIM bit.
     *
     * MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the tx65to127octets_gb counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TX65T127OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 5u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TX64OCTGBPIM bit.
     *
     * MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the tx64octets_gb counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TX64OCTGBPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 4u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TX64OCTGBPIM bit.
     *
     * MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the tx64octets_gb counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TX64OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 4u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TX64OCTGBPIM bit.
     *
     * MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the tx64octets_gb counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TX64OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TX64OCTGBPIM bit.
     *
     * MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Mask Setting
     * this bit masks the interrupt when the tx64octets_gb counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TX64OCTGBPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 4u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXMCGPIM bit.
     *
     * MMC Transmit Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXMCGPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 3u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXMCGPIM bit.
     *
     * MMC Transmit Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXMCGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 3u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXMCGPIM bit.
     *
     * MMC Transmit Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXMCGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXMCGPIM bit.
     *
     * MMC Transmit Multicast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txmulticastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXMCGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 3u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXBCGPIM bit.
     *
     * MMC Transmit Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXBCGPIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 2u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXBCGPIM bit.
     *
     * MMC Transmit Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXBCGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 2u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXBCGPIM bit.
     *
     * MMC Transmit Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXBCGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXBCGPIM bit.
     *
     * MMC Transmit Broadcast Good Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the txbroadcastpackets_g counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXBCGPIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 2u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXGBPKTIM bit.
     *
     * MMC Transmit Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXGBPKTIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 1u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXGBPKTIM bit.
     *
     * MMC Transmit Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXGBPKTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 1u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXGBPKTIM bit.
     *
     * MMC Transmit Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXGBPKTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXGBPKTIM bit.
     *
     * MMC Transmit Good Bad Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txpacketcount_gb counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXGBPKTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 1u;
    }

    /**
     * Get MAC_MMC_TX_INTERRUPT_MASK's TXGBOCTIM bit.
     *
     * MMC Transmit Good Bad Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_TX_INTERRUPT_MASK_TXGBOCTIM() volatile
    {
        return MAC_MMC_TX_INTERRUPT_MASK & (1u << 0u);
    }

    /**
     * Set MAC_MMC_TX_INTERRUPT_MASK's TXGBOCTIM bit.
     *
     * MMC Transmit Good Bad Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK_TXGBOCTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK |= 1u << 0u;
    }

    /**
     * Clear MAC_MMC_TX_INTERRUPT_MASK's TXGBOCTIM bit.
     *
     * MMC Transmit Good Bad Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_TX_INTERRUPT_MASK_TXGBOCTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MMC_TX_INTERRUPT_MASK's TXGBOCTIM bit.
     *
     * MMC Transmit Good Bad Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the txoctetcount_gb counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_TX_INTERRUPT_MASK_TXGBOCTIM() volatile
    {
        MAC_MMC_TX_INTERRUPT_MASK ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MMC_TX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC Tx Interrupt Mask
     */
    inline void get_MAC_MMC_TX_INTERRUPT_MASK(
        bool &TXLPITRCIM, bool &TXLPIUSCIM, bool &TXOSIZEGPIM,
        bool &TXVLANGPIM, bool &TXPAUSPIM, bool &TXEXDEFPIM, bool &TXGPKTIM,
        bool &TXGOCTIM, bool &TXCARERPIM, bool &TXEXCOLPIM, bool &TXLATCOLPIM,
        bool &TXDEFPIM, bool &TXMCOLGPIM, bool &TXSCOLGPIM, bool &TXUFLOWERPIM,
        bool &TXBCGBPIM, bool &TXMCGBPIM, bool &TXUCGBPIM,
        bool &TX1024TMAXOCTGBPIM, bool &TX512T1023OCTGBPIM,
        bool &TX256T511OCTGBPIM, bool &TX128T255OCTGBPIM,
        bool &TX65T127OCTGBPIM, bool &TX64OCTGBPIM, bool &TXMCGPIM,
        bool &TXBCGPIM, bool &TXGBPKTIM, bool &TXGBOCTIM) volatile
    {
        uint32_t curr = MAC_MMC_TX_INTERRUPT_MASK;

        TXLPITRCIM = curr & (1u << 27u);
        TXLPIUSCIM = curr & (1u << 26u);
        TXOSIZEGPIM = curr & (1u << 25u);
        TXVLANGPIM = curr & (1u << 24u);
        TXPAUSPIM = curr & (1u << 23u);
        TXEXDEFPIM = curr & (1u << 22u);
        TXGPKTIM = curr & (1u << 21u);
        TXGOCTIM = curr & (1u << 20u);
        TXCARERPIM = curr & (1u << 19u);
        TXEXCOLPIM = curr & (1u << 18u);
        TXLATCOLPIM = curr & (1u << 17u);
        TXDEFPIM = curr & (1u << 16u);
        TXMCOLGPIM = curr & (1u << 15u);
        TXSCOLGPIM = curr & (1u << 14u);
        TXUFLOWERPIM = curr & (1u << 13u);
        TXBCGBPIM = curr & (1u << 12u);
        TXMCGBPIM = curr & (1u << 11u);
        TXUCGBPIM = curr & (1u << 10u);
        TX1024TMAXOCTGBPIM = curr & (1u << 9u);
        TX512T1023OCTGBPIM = curr & (1u << 8u);
        TX256T511OCTGBPIM = curr & (1u << 7u);
        TX128T255OCTGBPIM = curr & (1u << 6u);
        TX65T127OCTGBPIM = curr & (1u << 5u);
        TX64OCTGBPIM = curr & (1u << 4u);
        TXMCGPIM = curr & (1u << 3u);
        TXBCGPIM = curr & (1u << 2u);
        TXGBPKTIM = curr & (1u << 1u);
        TXGBOCTIM = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MMC_TX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC Tx Interrupt Mask
     */
    inline void set_MAC_MMC_TX_INTERRUPT_MASK(
        bool TXLPITRCIM, bool TXLPIUSCIM, bool TXOSIZEGPIM, bool TXVLANGPIM,
        bool TXPAUSPIM, bool TXEXDEFPIM, bool TXGPKTIM, bool TXGOCTIM,
        bool TXCARERPIM, bool TXEXCOLPIM, bool TXLATCOLPIM, bool TXDEFPIM,
        bool TXMCOLGPIM, bool TXSCOLGPIM, bool TXUFLOWERPIM, bool TXBCGBPIM,
        bool TXMCGBPIM, bool TXUCGBPIM, bool TX1024TMAXOCTGBPIM,
        bool TX512T1023OCTGBPIM, bool TX256T511OCTGBPIM,
        bool TX128T255OCTGBPIM, bool TX65T127OCTGBPIM, bool TX64OCTGBPIM,
        bool TXMCGPIM, bool TXBCGPIM, bool TXGBPKTIM, bool TXGBOCTIM) volatile
    {
        uint32_t curr = MAC_MMC_TX_INTERRUPT_MASK;

        curr &= ~(0b1u << 27u);
        curr |= (TXLPITRCIM & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (TXLPIUSCIM & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (TXOSIZEGPIM & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (TXVLANGPIM & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (TXPAUSPIM & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (TXEXDEFPIM & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (TXGPKTIM & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (TXGOCTIM & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (TXCARERPIM & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (TXEXCOLPIM & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (TXLATCOLPIM & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (TXDEFPIM & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TXMCOLGPIM & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TXSCOLGPIM & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TXUFLOWERPIM & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TXBCGBPIM & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TXMCGBPIM & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TXUCGBPIM & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (TX1024TMAXOCTGBPIM & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TX512T1023OCTGBPIM & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (TX256T511OCTGBPIM & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TX128T255OCTGBPIM & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TX65T127OCTGBPIM & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TX64OCTGBPIM & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TXMCGPIM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TXBCGPIM & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXGBPKTIM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXGBOCTIM & 0b1u) << 0u;

        MAC_MMC_TX_INTERRUPT_MASK = curr;
    }

    /**
     * Get MAC_TX_OCTET_COUNT_GOOD_BAD's TXOCTGB field.
     *
     * Tx Octet Count Good Bad This field indicates the number of bytes
     * transmitted, exclusive of preamble and retried bytes, in good and bad
     * packets.
     */
    inline uint32_t get_MAC_TX_OCTET_COUNT_GOOD_BAD_TXOCTGB() volatile
    {
        return (MAC_TX_OCTET_COUNT_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_PACKET_COUNT_GOOD_BAD's TXPKTGB field.
     *
     * Tx Packet Count Good Bad This field indicates the number of good and bad
     * packets transmitted, exclusive of retried packets.
     */
    inline uint32_t get_MAC_TX_PACKET_COUNT_GOOD_BAD_TXPKTGB() volatile
    {
        return (MAC_TX_PACKET_COUNT_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_BROADCAST_PACKETS_GOOD's TXBCASTG field.
     *
     * Tx Broadcast Packets Good This field indicates the number of good
     * broadcast packets transmitted.
     */
    inline uint32_t get_MAC_TX_BROADCAST_PACKETS_GOOD_TXBCASTG() volatile
    {
        return (MAC_TX_BROADCAST_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_MULTICAST_PACKETS_GOOD's TXMCASTG field.
     *
     * Tx Multicast Packets Good This field indicates the number of good
     * multicast packets transmitted.
     */
    inline uint32_t get_MAC_TX_MULTICAST_PACKETS_GOOD_TXMCASTG() volatile
    {
        return (MAC_TX_MULTICAST_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_64OCTETS_PACKETS_GOOD_BAD's TX64OCTGB field.
     *
     * Tx 64Octets Packets Good_Bad This field indicates the number of good and
     * bad packets transmitted with length 64 bytes, exclusive of preamble and
     * retried packets.
     */
    inline uint32_t get_MAC_TX_64OCTETS_PACKETS_GOOD_BAD_TX64OCTGB() volatile
    {
        return (MAC_TX_64OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_65TO127OCTETS_PACKETS_GOOD_BAD's TX65_127OCTGB field.
     *
     * Tx 65To127Octets Packets Good Bad This field indicates the number of
     * good and bad packets transmitted with length between 65 and 127
     * (inclusive) bytes, exclusive of preamble and retried packets.
     */
    inline uint32_t
    get_MAC_TX_65TO127OCTETS_PACKETS_GOOD_BAD_TX65_127OCTGB() volatile
    {
        return (MAC_TX_65TO127OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_128TO255OCTETS_PACKETS_GOOD_BAD's TX128_255OCTGB field.
     *
     * Tx 128To255Octets Packets Good Bad This field indicates the number of
     * good and bad packets transmitted with length between 128 and 255
     * (inclusive) bytes, exclusive of preamble and retried packets.
     */
    inline uint32_t
    get_MAC_TX_128TO255OCTETS_PACKETS_GOOD_BAD_TX128_255OCTGB() volatile
    {
        return (MAC_TX_128TO255OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_256TO511OCTETS_PACKETS_GOOD_BAD's TX256_511OCTGB field.
     *
     * Tx 256To511Octets Packets Good Bad This field indicates the number of
     * good and bad packets transmitted with length between 256 and 511
     * (inclusive) bytes, exclusive of preamble and retried packets.
     */
    inline uint32_t
    get_MAC_TX_256TO511OCTETS_PACKETS_GOOD_BAD_TX256_511OCTGB() volatile
    {
        return (MAC_TX_256TO511OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_512TO1023OCTETS_PACKETS_GOOD_BAD's TX512_1023OCTGB field.
     *
     * Tx 512To1023Octets Packets Good Bad This field indicates the number of
     * good and bad packets transmitted with length between 512 and 1023
     * (inclusive) bytes, exclusive of preamble and retried packets.
     */
    inline uint32_t
    get_MAC_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_TX512_1023OCTGB() volatile
    {
        return (MAC_TX_512TO1023OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD's TX1024_MAXOCTGB field.
     *
     * Tx 1024ToMaxOctets Packets Good Bad This field indicates the number of
     * good and bad packets transmitted with length between 1024 and maxsize
     * (inclusive) bytes, exclusive of preamble and retried packets.
     */
    inline uint32_t
    get_MAC_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_TX1024_MAXOCTGB() volatile
    {
        return (MAC_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_UNICAST_PACKETS_GOOD_BAD's TXUCASTGB field.
     *
     * Tx Unicast Packets Good Bad This field indicates the number of good and
     * bad unicast packets transmitted.
     */
    inline uint32_t get_MAC_TX_UNICAST_PACKETS_GOOD_BAD_TXUCASTGB() volatile
    {
        return (MAC_TX_UNICAST_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_MULTICAST_PACKETS_GOOD_BAD's TXMCASTGB field.
     *
     * Tx Multicast Packets Good Bad This field indicates the number of good
     * and bad multicast packets transmitted.
     */
    inline uint32_t get_MAC_TX_MULTICAST_PACKETS_GOOD_BAD_TXMCASTGB() volatile
    {
        return (MAC_TX_MULTICAST_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_BROADCAST_PACKETS_GOOD_BAD's TXBCASTGB field.
     *
     * Tx Broadcast Packets Good Bad This field indicates the number of good
     * and bad broadcast packets transmitted.
     */
    inline uint32_t get_MAC_TX_BROADCAST_PACKETS_GOOD_BAD_TXBCASTGB() volatile
    {
        return (MAC_TX_BROADCAST_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_UNDERFLOW_ERROR_PACKETS's TXUNDRFLW field.
     *
     * Tx Underflow Error Packets This field indicates the number of packets
     * aborted because of packets underflow error.
     */
    inline uint32_t get_MAC_TX_UNDERFLOW_ERROR_PACKETS_TXUNDRFLW() volatile
    {
        return (MAC_TX_UNDERFLOW_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_SINGLE_COLLISION_GOOD_PACKETS's TXSNGLCOLG field.
     *
     * Tx Single Collision Good Packets This field indicates the number of
     * successfully transmitted packets after a single collision in the
     * half-duplex mode.
     */
    inline uint32_t
    get_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG() volatile
    {
        return (MAC_TX_SINGLE_COLLISION_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS's TXMULTCOLG field.
     *
     * Tx Multiple Collision Good Packets This field indicates the number of
     * successfully transmitted packets after multiple collisions in the
     * half-duplex mode.
     */
    inline uint32_t
    get_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG() volatile
    {
        return (MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_DEFERRED_PACKETS's TXDEFRD field.
     *
     * Tx Deferred Packets This field indicates the number of successfully
     * transmitted after a deferral in the half-duplex mode.
     */
    inline uint32_t get_MAC_TX_DEFERRED_PACKETS_TXDEFRD() volatile
    {
        return (MAC_TX_DEFERRED_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_LATE_COLLISION_PACKETS's TXLATECOL field.
     *
     * Tx Late Collision Packets This field indicates the number of packets
     * aborted because of late collision error.
     */
    inline uint32_t get_MAC_TX_LATE_COLLISION_PACKETS_TXLATECOL() volatile
    {
        return (MAC_TX_LATE_COLLISION_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_EXCESSIVE_COLLISION_PACKETS's TXEXSCOL field.
     *
     * Tx Excessive Collision Packets This field indicates the number of
     * packets aborted because of excessive (16) collision errors.
     */
    inline uint32_t get_MAC_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL() volatile
    {
        return (MAC_TX_EXCESSIVE_COLLISION_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_CARRIER_ERROR_PACKETS's TXCARR field.
     *
     * Tx Carrier Error Packets This field indicates the number of packets
     * aborted because of carrier sense error (no carrier or loss of carrier).
     */
    inline uint32_t get_MAC_TX_CARRIER_ERROR_PACKETS_TXCARR() volatile
    {
        return (MAC_TX_CARRIER_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_OCTET_COUNT_GOOD's TXOCTG field.
     *
     * Tx Octet Count Good This field indicates the number of bytes
     * transmitted, exclusive of preamble, only in good packets.
     */
    inline uint32_t get_MAC_TX_OCTET_COUNT_GOOD_TXOCTG() volatile
    {
        return (MAC_TX_OCTET_COUNT_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_PACKET_COUNT_GOOD's TXPKTG field.
     *
     * Tx Packet Count Good This field indicates the number of good packets
     * transmitted.
     */
    inline uint32_t get_MAC_TX_PACKET_COUNT_GOOD_TXPKTG() volatile
    {
        return (MAC_TX_PACKET_COUNT_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_EXCESSIVE_DEFERRAL_ERROR's TXEXSDEF field.
     *
     * Tx Excessive Deferral Error This field indicates the number of packets
     * aborted because of excessive deferral error (deferred for more than two
     * max-sized packet times).
     */
    inline uint32_t get_MAC_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF() volatile
    {
        return (MAC_TX_EXCESSIVE_DEFERRAL_ERROR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_PAUSE_PACKETS's TXPAUSE field.
     *
     * Tx Pause Packets This field indicates the number of good Pause packets
     * transmitted.
     */
    inline uint32_t get_MAC_TX_PAUSE_PACKETS_TXPAUSE() volatile
    {
        return (MAC_TX_PAUSE_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_VLAN_PACKETS_GOOD's TXVLANG field.
     *
     * Tx VLAN Packets Good This field provides the number of good VLAN packets
     * transmitted.
     */
    inline uint32_t get_MAC_TX_VLAN_PACKETS_GOOD_TXVLANG() volatile
    {
        return (MAC_TX_VLAN_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_OSIZE_PACKETS_GOOD's TXOSIZG field.
     *
     * Tx OSize Packets Good This field indicates the number of packets
     * transmitted without errors and with length greater than the maxsize
     * (1,518 or 1,522 bytes for VLAN tagged packets; 2000 bytes if enabled in
     * S2KP bit of the CONFIGURATION register).
     */
    inline uint32_t get_MAC_TX_OSIZE_PACKETS_GOOD_TXOSIZG() volatile
    {
        return (MAC_TX_OSIZE_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_PACKETS_COUNT_GOOD_BAD's RXPKTGB field.
     *
     * Rx Packets Count Good Bad This field indicates the number of good and
     * bad packets received.
     */
    inline uint32_t get_MAC_RX_PACKETS_COUNT_GOOD_BAD_RXPKTGB() volatile
    {
        return (MAC_RX_PACKETS_COUNT_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_OCTET_COUNT_GOOD_BAD's RXOCTGB field.
     *
     * Rx Octet Count Good Bad This field indicates the number of bytes
     * received, exclusive of preamble, in good and bad packets.
     */
    inline uint32_t get_MAC_RX_OCTET_COUNT_GOOD_BAD_RXOCTGB() volatile
    {
        return (MAC_RX_OCTET_COUNT_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_OCTET_COUNT_GOOD's RXOCTG field.
     *
     * Rx Octet Count Good This field indicates the number of bytes received,
     * exclusive of preamble, only in good packets.
     */
    inline uint32_t get_MAC_RX_OCTET_COUNT_GOOD_RXOCTG() volatile
    {
        return (MAC_RX_OCTET_COUNT_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_BROADCAST_PACKETS_GOOD's RXBCASTG field.
     *
     * Rx Broadcast Packets Good This field indicates the number of good
     * broadcast packets received.
     */
    inline uint32_t get_MAC_RX_BROADCAST_PACKETS_GOOD_RXBCASTG() volatile
    {
        return (MAC_RX_BROADCAST_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_MULTICAST_PACKETS_GOOD's RXMCASTG field.
     *
     * Rx Multicast Packets Good This field indicates the number of good
     * multicast packets received.
     */
    inline uint32_t get_MAC_RX_MULTICAST_PACKETS_GOOD_RXMCASTG() volatile
    {
        return (MAC_RX_MULTICAST_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_CRC_ERROR_PACKETS's RXCRCERR field.
     *
     * Rx CRC Error Packets This field indicates the number of packets received
     * with CRC error.
     */
    inline uint32_t get_MAC_RX_CRC_ERROR_PACKETS_RXCRCERR() volatile
    {
        return (MAC_RX_CRC_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_ALIGNMENT_ERROR_PACKETS's RXALGNERR field.
     *
     * Rx Alignment Error Packets This field indicates the number of packets
     * received with alignment (dribble) error.
     */
    inline uint32_t get_MAC_RX_ALIGNMENT_ERROR_PACKETS_RXALGNERR() volatile
    {
        return (MAC_RX_ALIGNMENT_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_RUNT_ERROR_PACKETS's RXRUNTERR field.
     *
     * Rx Runt Error Packets This field indicates the number of packets
     * received with runt (length less than 64 bytes and CRC error) error.
     */
    inline uint32_t get_MAC_RX_RUNT_ERROR_PACKETS_RXRUNTERR() volatile
    {
        return (MAC_RX_RUNT_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_JABBER_ERROR_PACKETS's RXJABERR field.
     *
     * Rx Jabber Error Packets This field indicates the number of giant packets
     * received with length (including CRC) greater than 1,518 bytes (1,522
     * bytes for VLAN tagged) and with CRC error.
     */
    inline uint32_t get_MAC_RX_JABBER_ERROR_PACKETS_RXJABERR() volatile
    {
        return (MAC_RX_JABBER_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_UNDERSIZE_PACKETS_GOOD's RXUNDERSZG field.
     *
     * Rx Undersize Packets Good This field indicates the number of packets
     * received with length less than 64 bytes, without any errors.
     */
    inline uint32_t get_MAC_RX_UNDERSIZE_PACKETS_GOOD_RXUNDERSZG() volatile
    {
        return (MAC_RX_UNDERSIZE_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_OVERSIZE_PACKETS_GOOD's RXOVERSZG field.
     *
     * Rx Oversize Packets Good This field indicates the number of packets
     * received without errors, with length greater than the maxsize (1,518
     * bytes or 1,522 bytes for VLAN tagged packets; 2000 bytes if enabled in
     * the S2KP bit of the MAC_CONFIGURATION register).
     */
    inline uint32_t get_MAC_RX_OVERSIZE_PACKETS_GOOD_RXOVERSZG() volatile
    {
        return (MAC_RX_OVERSIZE_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_64OCTETS_PACKETS_GOOD_BAD's RX64OCTGB field.
     *
     * Rx 64 Octets Packets Good Bad This field indicates the number of good
     * and bad packets received with length 64 bytes, exclusive of the
     * preamble.
     */
    inline uint32_t get_MAC_RX_64OCTETS_PACKETS_GOOD_BAD_RX64OCTGB() volatile
    {
        return (MAC_RX_64OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_65TO127OCTETS_PACKETS_GOOD_BAD's RX65_127OCTGB field.
     *
     * Rx 65-127 Octets Packets Good Bad This field indicates the number of
     * good and bad packets received with length between 65 and 127 (inclusive)
     * bytes, exclusive of the preamble.
     */
    inline uint32_t
    get_MAC_RX_65TO127OCTETS_PACKETS_GOOD_BAD_RX65_127OCTGB() volatile
    {
        return (MAC_RX_65TO127OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_128TO255OCTETS_PACKETS_GOOD_BAD's RX128_255OCTGB field.
     *
     * Rx 128-255 Octets Packets Good Bad This field indicates the number of
     * good and bad packets received with length between 128 and 255
     * (inclusive) bytes, exclusive of the preamble.
     */
    inline uint32_t
    get_MAC_RX_128TO255OCTETS_PACKETS_GOOD_BAD_RX128_255OCTGB() volatile
    {
        return (MAC_RX_128TO255OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_256TO511OCTETS_PACKETS_GOOD_BAD's RX256_511OCTGB field.
     *
     * Rx 256-511 Octets Packets Good Bad This field indicates the number of
     * good and bad packets received with length between 256 and 511
     * (inclusive) bytes, exclusive of the preamble.
     */
    inline uint32_t
    get_MAC_RX_256TO511OCTETS_PACKETS_GOOD_BAD_RX256_511OCTGB() volatile
    {
        return (MAC_RX_256TO511OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_512TO1023OCTETS_PACKETS_GOOD_BAD's RX512_1023OCTGB field.
     *
     * RX 512-1023 Octets Packets Good Bad This field indicates the number of
     * good and bad packets received with length between 512 and 1023
     * (inclusive) bytes, exclusive of the preamble.
     */
    inline uint32_t
    get_MAC_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_RX512_1023OCTGB() volatile
    {
        return (MAC_RX_512TO1023OCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD's RX1024_MAXOCTGB field.
     *
     * Rx 1024-Max Octets Good Bad This field indicates the number of good and
     * bad packets received with length between 1024 and maxsize (inclusive)
     * bytes, exclusive of the preamble.
     */
    inline uint32_t
    get_MAC_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_RX1024_MAXOCTGB() volatile
    {
        return (MAC_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_UNICAST_PACKETS_GOOD's RXUCASTG field.
     *
     * Rx Unicast Packets Good This field indicates the number of good unicast
     * packets received.
     */
    inline uint32_t get_MAC_RX_UNICAST_PACKETS_GOOD_RXUCASTG() volatile
    {
        return (MAC_RX_UNICAST_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_LENGTH_ERROR_PACKETS's RXLENERR field.
     *
     * Rx Length Error Packets This field indicates the number of packets
     * received with length error (Length Type field not equal to packet size),
     * for all packets with valid length field.
     */
    inline uint32_t get_MAC_RX_LENGTH_ERROR_PACKETS_RXLENERR() volatile
    {
        return (MAC_RX_LENGTH_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_OUT_OF_RANGE_TYPE_PACKETS's RXOUTOFRNG field.
     *
     * Rx Out of Range Type Packet This field indicates the number of packets
     * received with length field not equal to the valid packet size (greater
     * than 1,500 but less than 1,536).
     */
    inline uint32_t get_MAC_RX_OUT_OF_RANGE_TYPE_PACKETS_RXOUTOFRNG() volatile
    {
        return (MAC_RX_OUT_OF_RANGE_TYPE_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_PAUSE_PACKETS's RXPAUSEPKT field.
     *
     * Rx Pause Packets This field indicates the number of good and valid Pause
     * packets received.
     */
    inline uint32_t get_MAC_RX_PAUSE_PACKETS_RXPAUSEPKT() volatile
    {
        return (MAC_RX_PAUSE_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_FIFO_OVERFLOW_PACKETS's RXFIFOOVFL field.
     *
     * Rx FIFO Overflow Packets This field indicates the number of missed
     * received packets because of FIFO overflow.
     */
    inline uint32_t get_MAC_RX_FIFO_OVERFLOW_PACKETS_RXFIFOOVFL() volatile
    {
        return (MAC_RX_FIFO_OVERFLOW_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_VLAN_PACKETS_GOOD_BAD's RXVLANPKTGB field.
     *
     * Rx VLAN Packets Good Bad This field indicates the number of good and bad
     * VLAN packets received.
     */
    inline uint32_t get_MAC_RX_VLAN_PACKETS_GOOD_BAD_RXVLANPKTGB() volatile
    {
        return (MAC_RX_VLAN_PACKETS_GOOD_BAD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_WATCHDOG_ERROR_PACKETS's RXWDGERR field.
     *
     * Rx Watchdog Error Packets This field indicates the number of packets
     * received with error because of watchdog timeout error (packets with a
     * data load larger than 2,048 bytes (when JE and WD bits are reset in
     * MAC_CONFIGURATION register), 10,240 bytes (when JE bit is set and WD bit
     * is reset in MAC_CONFIGURATION register), 16,384 bytes (when WD bit is
     * set in MAC_CONFIGURATION register) or the value programmed in the
     * MAC_WATCHDOG_TIMEOUT register).
     */
    inline uint32_t get_MAC_RX_WATCHDOG_ERROR_PACKETS_RXWDGERR() volatile
    {
        return (MAC_RX_WATCHDOG_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_RECEIVE_ERROR_PACKETS's RXRCVERR field.
     *
     * Rx Receive Error Packets This field indicates the number of packets
     * received with Receive error or Packet Extension error on the GMII or MII
     * interface.
     */
    inline uint32_t get_MAC_RX_RECEIVE_ERROR_PACKETS_RXRCVERR() volatile
    {
        return (MAC_RX_RECEIVE_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_CONTROL_PACKETS_GOOD's RXCTRLG field.
     *
     * Rx Control Packets Good This field indicates the number of good control
     * packets received.
     */
    inline uint32_t get_MAC_RX_CONTROL_PACKETS_GOOD_RXCTRLG() volatile
    {
        return (MAC_RX_CONTROL_PACKETS_GOOD >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_LPI_USEC_CNTR's TXLPIUSC field.
     *
     * Tx LPI Microseconds Counter This field indicates the number of
     * microseconds Tx LPI is asserted.
     */
    inline uint32_t get_MAC_TX_LPI_USEC_CNTR_TXLPIUSC() volatile
    {
        return (MAC_TX_LPI_USEC_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_LPI_TRAN_CNTR's TXLPITRC field.
     *
     * Tx LPI Transition counter This field indicates the number of times Tx
     * LPI Entry has occurred.
     */
    inline uint32_t get_MAC_TX_LPI_TRAN_CNTR_TXLPITRC() volatile
    {
        return (MAC_TX_LPI_TRAN_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_LPI_USEC_CNTR's RXLPIUSC field.
     *
     * Rx LPI Microseconds Counter This field indicates the number of
     * microseconds Rx LPI is asserted.
     */
    inline uint32_t get_MAC_RX_LPI_USEC_CNTR_RXLPIUSC() volatile
    {
        return (MAC_RX_LPI_USEC_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RX_LPI_TRAN_CNTR's RXLPITRC field.
     *
     * Rx LPI Transition counter This field indicates the number of times Rx
     * LPI Entry has occurred.
     */
    inline uint32_t get_MAC_RX_LPI_TRAN_CNTR_RXLPITRC() volatile
    {
        return (MAC_RX_LPI_TRAN_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPEROIM bit.
     *
     * MMC Receive ICMP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 29u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPEROIM bit.
     *
     * MMC Receive ICMP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 29u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPEROIM bit.
     *
     * MMC Receive ICMP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 29u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPEROIM bit.
     *
     * MMC Receive ICMP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 29u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGOIM bit.
     *
     * MMC Receive ICMP Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 28u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGOIM bit.
     *
     * MMC Receive ICMP Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 28u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGOIM bit.
     *
     * MMC Receive ICMP Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGOIM bit.
     *
     * MMC Receive ICMP Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 28u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPEROIM bit.
     *
     * MMC Receive TCP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 27u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPEROIM bit.
     *
     * MMC Receive TCP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 27u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPEROIM bit.
     *
     * MMC Receive TCP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 27u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPEROIM bit.
     *
     * MMC Receive TCP Error Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 27u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGOIM bit.
     *
     * MMC Receive TCP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxtcp_gd_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 26u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGOIM bit.
     *
     * MMC Receive TCP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxtcp_gd_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 26u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGOIM bit.
     *
     * MMC Receive TCP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxtcp_gd_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 26u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGOIM bit.
     *
     * MMC Receive TCP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxtcp_gd_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 26u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPEROIM bit.
     *
     * MMC Receive UDP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxudp_err_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 25u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPEROIM bit.
     *
     * MMC Receive UDP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxudp_err_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 25u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPEROIM bit.
     *
     * MMC Receive UDP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxudp_err_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 25u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPEROIM bit.
     *
     * MMC Receive UDP Good Octet Counter Interrupt Mask Setting this bit masks
     * the interrupt when the rxudp_err_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 25u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGOIM bit.
     *
     * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxudp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 24u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGOIM bit.
     *
     * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxudp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 24u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGOIM bit.
     *
     * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxudp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGOIM bit.
     *
     * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxudp_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 24u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYOIM bit.
     *
     * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 23u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYOIM bit.
     *
     * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 23u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYOIM bit.
     *
     * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 23u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYOIM bit.
     *
     * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 23u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HEROIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_hdrerr_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 22u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HEROIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_hdrerr_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 22u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HEROIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_hdrerr_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 22u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HEROIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_hdrerr_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 22u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GOIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 21u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GOIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 21u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GOIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GOIM bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 21u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLOIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_octets
     * counter reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 20u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLOIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_octets
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 20u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLOIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_octets
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLOIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_octets
     * counter reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 20u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGOIM bit.
     *
     * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 19u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGOIM bit.
     *
     * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 19u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGOIM bit.
     *
     * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGOIM bit.
     *
     * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_octets counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 19u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYOIM bit.
     *
     * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 18u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYOIM bit.
     *
     * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 18u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYOIM bit.
     *
     * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYOIM bit.
     *
     * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 18u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HEROIM bit.
     *
     * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 17u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HEROIM bit.
     *
     * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 17u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HEROIM bit.
     *
     * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 17u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HEROIM bit.
     *
     * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_octets counter reaches
     * half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 17u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GOIM bit.
     *
     * MMC Receive IPV4 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 16u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GOIM bit.
     *
     * MMC Receive IPV4 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 16u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GOIM bit.
     *
     * MMC Receive IPV4 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GOIM bit.
     *
     * MMC Receive IPV4 Good Octet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_octets counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 16u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPERPIM bit.
     *
     * MMC Receive ICMP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 13u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPERPIM bit.
     *
     * MMC Receive ICMP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 13u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPERPIM bit.
     *
     * MMC Receive ICMP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 13u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPERPIM bit.
     *
     * MMC Receive ICMP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 13u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGPIM bit.
     *
     * MMC Receive ICMP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 12u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGPIM bit.
     *
     * MMC Receive ICMP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 12u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGPIM bit.
     *
     * MMC Receive ICMP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 12u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXICMPGPIM bit.
     *
     * MMC Receive ICMP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxicmp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 12u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPERPIM bit.
     *
     * MMC Receive TCP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 11u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPERPIM bit.
     *
     * MMC Receive TCP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 11u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPERPIM bit.
     *
     * MMC Receive TCP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 11u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPERPIM bit.
     *
     * MMC Receive TCP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 11u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGPIM bit.
     *
     * MMC Receive TCP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 10u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGPIM bit.
     *
     * MMC Receive TCP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 10u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGPIM bit.
     *
     * MMC Receive TCP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXTCPGPIM bit.
     *
     * MMC Receive TCP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxtcp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 10u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPERPIM bit.
     *
     * MMC Receive UDP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 9u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPERPIM bit.
     *
     * MMC Receive UDP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 9u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPERPIM bit.
     *
     * MMC Receive UDP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPERPIM bit.
     *
     * MMC Receive UDP Error Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_err_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 9u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGPIM bit.
     *
     * MMC Receive UDP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 8u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGPIM bit.
     *
     * MMC Receive UDP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 8u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGPIM bit.
     *
     * MMC Receive UDP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXUDPGPIM bit.
     *
     * MMC Receive UDP Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxudp_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 8u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYPIM bit.
     *
     * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 7u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYPIM bit.
     *
     * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 7u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYPIM bit.
     *
     * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6NOPAYPIM bit.
     *
     * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 7u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HERPIM bit.
     *
     * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 6u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HERPIM bit.
     *
     * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 6u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HERPIM bit.
     *
     * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 6u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6HERPIM bit.
     *
     * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv6_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 6u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GPIM bit.
     *
     * MMC Receive IPV6 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 5u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GPIM bit.
     *
     * MMC Receive IPV6 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 5u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GPIM bit.
     *
     * MMC Receive IPV6 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV6GPIM bit.
     *
     * MMC Receive IPV6 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv6_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 5u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLPIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_pkts counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 4u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLPIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_pkts counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 4u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLPIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_pkts counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4UDSBLPIM bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask
     * Setting this bit masks the interrupt when the rxipv4_udsbl_pkts counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 4u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGPIM bit.
     *
     * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 3u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGPIM bit.
     *
     * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 3u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGPIM bit.
     *
     * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4FRAGPIM bit.
     *
     * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_frag_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 3u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYPIM bit.
     *
     * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 2u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYPIM bit.
     *
     * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 2u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYPIM bit.
     *
     * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4NOPAYPIM bit.
     *
     * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_nopay_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 2u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HERPIM bit.
     *
     * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 1u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HERPIM bit.
     *
     * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 1u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HERPIM bit.
     *
     * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4HERPIM bit.
     *
     * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask Setting this
     * bit masks the interrupt when the rxipv4_hdrerr_pkts counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 1u;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GPIM bit.
     *
     * MMC Receive IPV4 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT_MASK & (1u << 0u);
    }

    /**
     * Set MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GPIM bit.
     *
     * MMC Receive IPV4 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK |= 1u << 0u;
    }

    /**
     * Clear MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GPIM bit.
     *
     * MMC Receive IPV4 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MMC_IPC_RX_INTERRUPT_MASK's RXIPV4GPIM bit.
     *
     * MMC Receive IPV4 Good Packet Counter Interrupt Mask Setting this bit
     * masks the interrupt when the rxipv4_gd_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM() volatile
    {
        MAC_MMC_IPC_RX_INTERRUPT_MASK ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MMC_IPC_RX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC IPC Receive Interrupt Mask
     */
    inline void get_MAC_MMC_IPC_RX_INTERRUPT_MASK(
        bool &RXICMPEROIM, bool &RXICMPGOIM, bool &RXTCPEROIM, bool &RXTCPGOIM,
        bool &RXUDPEROIM, bool &RXUDPGOIM, bool &RXIPV6NOPAYOIM,
        bool &RXIPV6HEROIM, bool &RXIPV6GOIM, bool &RXIPV4UDSBLOIM,
        bool &RXIPV4FRAGOIM, bool &RXIPV4NOPAYOIM, bool &RXIPV4HEROIM,
        bool &RXIPV4GOIM, bool &RXICMPERPIM, bool &RXICMPGPIM,
        bool &RXTCPERPIM, bool &RXTCPGPIM, bool &RXUDPERPIM, bool &RXUDPGPIM,
        bool &RXIPV6NOPAYPIM, bool &RXIPV6HERPIM, bool &RXIPV6GPIM,
        bool &RXIPV4UDSBLPIM, bool &RXIPV4FRAGPIM, bool &RXIPV4NOPAYPIM,
        bool &RXIPV4HERPIM, bool &RXIPV4GPIM) volatile
    {
        uint32_t curr = MAC_MMC_IPC_RX_INTERRUPT_MASK;

        RXICMPEROIM = curr & (1u << 29u);
        RXICMPGOIM = curr & (1u << 28u);
        RXTCPEROIM = curr & (1u << 27u);
        RXTCPGOIM = curr & (1u << 26u);
        RXUDPEROIM = curr & (1u << 25u);
        RXUDPGOIM = curr & (1u << 24u);
        RXIPV6NOPAYOIM = curr & (1u << 23u);
        RXIPV6HEROIM = curr & (1u << 22u);
        RXIPV6GOIM = curr & (1u << 21u);
        RXIPV4UDSBLOIM = curr & (1u << 20u);
        RXIPV4FRAGOIM = curr & (1u << 19u);
        RXIPV4NOPAYOIM = curr & (1u << 18u);
        RXIPV4HEROIM = curr & (1u << 17u);
        RXIPV4GOIM = curr & (1u << 16u);
        RXICMPERPIM = curr & (1u << 13u);
        RXICMPGPIM = curr & (1u << 12u);
        RXTCPERPIM = curr & (1u << 11u);
        RXTCPGPIM = curr & (1u << 10u);
        RXUDPERPIM = curr & (1u << 9u);
        RXUDPGPIM = curr & (1u << 8u);
        RXIPV6NOPAYPIM = curr & (1u << 7u);
        RXIPV6HERPIM = curr & (1u << 6u);
        RXIPV6GPIM = curr & (1u << 5u);
        RXIPV4UDSBLPIM = curr & (1u << 4u);
        RXIPV4FRAGPIM = curr & (1u << 3u);
        RXIPV4NOPAYPIM = curr & (1u << 2u);
        RXIPV4HERPIM = curr & (1u << 1u);
        RXIPV4GPIM = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MMC_IPC_RX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC IPC Receive Interrupt Mask
     */
    inline void set_MAC_MMC_IPC_RX_INTERRUPT_MASK(
        bool RXICMPEROIM, bool RXICMPGOIM, bool RXTCPEROIM, bool RXTCPGOIM,
        bool RXUDPEROIM, bool RXUDPGOIM, bool RXIPV6NOPAYOIM,
        bool RXIPV6HEROIM, bool RXIPV6GOIM, bool RXIPV4UDSBLOIM,
        bool RXIPV4FRAGOIM, bool RXIPV4NOPAYOIM, bool RXIPV4HEROIM,
        bool RXIPV4GOIM, bool RXICMPERPIM, bool RXICMPGPIM, bool RXTCPERPIM,
        bool RXTCPGPIM, bool RXUDPERPIM, bool RXUDPGPIM, bool RXIPV6NOPAYPIM,
        bool RXIPV6HERPIM, bool RXIPV6GPIM, bool RXIPV4UDSBLPIM,
        bool RXIPV4FRAGPIM, bool RXIPV4NOPAYPIM, bool RXIPV4HERPIM,
        bool RXIPV4GPIM) volatile
    {
        uint32_t curr = MAC_MMC_IPC_RX_INTERRUPT_MASK;

        curr &= ~(0b1u << 29u);
        curr |= (RXICMPEROIM & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (RXICMPGOIM & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (RXTCPEROIM & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (RXTCPGOIM & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (RXUDPEROIM & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RXUDPGOIM & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (RXIPV6NOPAYOIM & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (RXIPV6HEROIM & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (RXIPV6GOIM & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (RXIPV4UDSBLOIM & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXIPV4FRAGOIM & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXIPV4NOPAYOIM & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RXIPV4HEROIM & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RXIPV4GOIM & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (RXICMPERPIM & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (RXICMPGPIM & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (RXTCPERPIM & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RXTCPGPIM & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RXUDPERPIM & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RXUDPGPIM & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RXIPV6NOPAYPIM & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RXIPV6HERPIM & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RXIPV6GPIM & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (RXIPV4UDSBLPIM & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (RXIPV4FRAGPIM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RXIPV4NOPAYPIM & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RXIPV4HERPIM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RXIPV4GPIM & 0b1u) << 0u;

        MAC_MMC_IPC_RX_INTERRUPT_MASK = curr;
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXICMPEROIS bit.
     *
     * MMC Receive ICMP Error Octet Counter Interrupt Status This bit is set
     * when the rxicmp_err_octets counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXICMPEROIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 29u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXICMPGOIS bit.
     *
     * MMC Receive ICMP Good Octet Counter Interrupt Status This bit is set
     * when the rxicmp_gd_octets counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXICMPGOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 28u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXTCPEROIS bit.
     *
     * MMC Receive TCP Error Octet Counter Interrupt Status This bit is set
     * when the rxtcp_err_octets counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXTCPEROIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 27u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXTCPGOIS bit.
     *
     * MMC Receive TCP Good Octet Counter Interrupt Status This bit is set when
     * the rxtcp_gd_octets counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXTCPGOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 26u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXUDPEROIS bit.
     *
     * MMC Receive UDP Error Octet Counter Interrupt Status This bit is set
     * when the rxudp_err_octets counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXUDPEROIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 25u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXUDPGOIS bit.
     *
     * MMC Receive UDP Good Octet Counter Interrupt Status This bit is set when
     * the rxudp_gd_octets counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXUDPGOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 24u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV6NOPAYOIS bit.
     *
     * MMC Receive IPV6 No Payload Octet Counter Interrupt Status This bit is
     * set when the rxipv6_nopay_octets counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 23u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV6HEROIS bit.
     *
     * MMC Receive IPV6 Header Error Octet Counter Interrupt Status This bit is
     * set when the rxipv6_hdrerr_octets counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 22u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV6GOIS bit.
     *
     * MMC Receive IPV6 Good Octet Counter Interrupt Status This bit is set
     * when the rxipv6_gd_octets counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 21u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4UDSBLOIS bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Status
     * This bit is set when the rxipv4_udsbl_octets counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 20u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4FRAGOIS bit.
     *
     * MMC Receive IPV4 Fragmented Octet Counter Interrupt Status This bit is
     * set when the rxipv4_frag_octets counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 19u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4NOPAYOIS bit.
     *
     * MMC Receive IPV4 No Payload Octet Counter Interrupt Status This bit is
     * set when the rxipv4_nopay_octets counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 18u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4HEROIS bit.
     *
     * MMC Receive IPV4 Header Error Octet Counter Interrupt Status This bit is
     * set when the rxipv4_hdrerr_octets counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 17u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4GOIS bit.
     *
     * MMC Receive IPV4 Good Octet Counter Interrupt Status This bit is set
     * when the rxipv4_gd_octets counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 16u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXICMPERPIS bit.
     *
     * MMC Receive ICMP Error Packet Counter Interrupt Status This bit is set
     * when the rxicmp_err_pkts counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXICMPERPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 13u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXICMPGPIS bit.
     *
     * MMC Receive ICMP Good Packet Counter Interrupt Status This bit is set
     * when the rxicmp_gd_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXICMPGPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 12u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXTCPERPIS bit.
     *
     * MMC Receive TCP Error Packet Counter Interrupt Status This bit is set
     * when the rxtcp_err_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXTCPERPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 11u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXTCPGPIS bit.
     *
     * MMC Receive TCP Good Packet Counter Interrupt Status This bit is set
     * when the rxtcp_gd_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXTCPGPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 10u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXUDPERPIS bit.
     *
     * MMC Receive UDP Error Packet Counter Interrupt Status This bit is set
     * when the rxudp_err_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXUDPERPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 9u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXUDPGPIS bit.
     *
     * MC Receive UDP Good Packet Counter Interrupt Status This bit is set when
     * the rxudp_gd_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXUDPGPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 8u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV6NOPAYPIS bit.
     *
     * MMC Receive IPV6 No Payload Packet Counter Interrupt Status This bit is
     * set when the rxipv6_nopay_pkts counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 7u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV6HERPIS bit.
     *
     * MMC Receive IPV6 Header Error Packet Counter Interrupt Status This bit
     * is set when the rxipv6_hdrerr_pkts counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 6u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV6GPIS bit.
     *
     * MMC Receive IPV6 Good Packet Counter Interrupt Status This bit is set
     * when the rxipv6_gd_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 5u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4UDSBLPIS bit.
     *
     * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Status
     * This bit is set when the rxipv4_udsbl_pkts counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 4u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4FRAGPIS bit.
     *
     * MMC Receive IPV4 Fragmented Packet Counter Interrupt Status This bit is
     * set when the rxipv4_frag_pkts counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 3u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4NOPAYPIS bit.
     *
     * MMC Receive IPV4 No Payload Packet Counter Interrupt Status This bit is
     * set when the rxipv4_nopay_pkts counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 2u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4HERPIS bit.
     *
     * MMC Receive IPV4 Header Error Packet Counter Interrupt Status This bit
     * is set when the rxipv4_hdrerr_pkts counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 1u);
    }

    /**
     * Get MAC_MMC_IPC_RX_INTERRUPT's RXIPV4GPIS bit.
     *
     * MMC Receive IPV4 Good Packet Counter Interrupt Status This bit is set
     * when the rxipv4_gd_pkts counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS() volatile
    {
        return MAC_MMC_IPC_RX_INTERRUPT & (1u << 0u);
    }

    /**
     * Get all of MAC_MMC_IPC_RX_INTERRUPT's bit fields.
     *
     * (read-write) MMC IPC Receive Interrupt
     */
    inline void get_MAC_MMC_IPC_RX_INTERRUPT(
        bool &RXICMPEROIS, bool &RXICMPGOIS, bool &RXTCPEROIS, bool &RXTCPGOIS,
        bool &RXUDPEROIS, bool &RXUDPGOIS, bool &RXIPV6NOPAYOIS,
        bool &RXIPV6HEROIS, bool &RXIPV6GOIS, bool &RXIPV4UDSBLOIS,
        bool &RXIPV4FRAGOIS, bool &RXIPV4NOPAYOIS, bool &RXIPV4HEROIS,
        bool &RXIPV4GOIS, bool &RXICMPERPIS, bool &RXICMPGPIS,
        bool &RXTCPERPIS, bool &RXTCPGPIS, bool &RXUDPERPIS, bool &RXUDPGPIS,
        bool &RXIPV6NOPAYPIS, bool &RXIPV6HERPIS, bool &RXIPV6GPIS,
        bool &RXIPV4UDSBLPIS, bool &RXIPV4FRAGPIS, bool &RXIPV4NOPAYPIS,
        bool &RXIPV4HERPIS, bool &RXIPV4GPIS) volatile
    {
        uint32_t curr = MAC_MMC_IPC_RX_INTERRUPT;

        RXICMPEROIS = curr & (1u << 29u);
        RXICMPGOIS = curr & (1u << 28u);
        RXTCPEROIS = curr & (1u << 27u);
        RXTCPGOIS = curr & (1u << 26u);
        RXUDPEROIS = curr & (1u << 25u);
        RXUDPGOIS = curr & (1u << 24u);
        RXIPV6NOPAYOIS = curr & (1u << 23u);
        RXIPV6HEROIS = curr & (1u << 22u);
        RXIPV6GOIS = curr & (1u << 21u);
        RXIPV4UDSBLOIS = curr & (1u << 20u);
        RXIPV4FRAGOIS = curr & (1u << 19u);
        RXIPV4NOPAYOIS = curr & (1u << 18u);
        RXIPV4HEROIS = curr & (1u << 17u);
        RXIPV4GOIS = curr & (1u << 16u);
        RXICMPERPIS = curr & (1u << 13u);
        RXICMPGPIS = curr & (1u << 12u);
        RXTCPERPIS = curr & (1u << 11u);
        RXTCPGPIS = curr & (1u << 10u);
        RXUDPERPIS = curr & (1u << 9u);
        RXUDPGPIS = curr & (1u << 8u);
        RXIPV6NOPAYPIS = curr & (1u << 7u);
        RXIPV6HERPIS = curr & (1u << 6u);
        RXIPV6GPIS = curr & (1u << 5u);
        RXIPV4UDSBLPIS = curr & (1u << 4u);
        RXIPV4FRAGPIS = curr & (1u << 3u);
        RXIPV4NOPAYPIS = curr & (1u << 2u);
        RXIPV4HERPIS = curr & (1u << 1u);
        RXIPV4GPIS = curr & (1u << 0u);
    }

    /**
     * Get MAC_RXIPV4_GOOD_PACKETS's RXIPV4GDPKT field.
     *
     * RxIPv4 Good Packets This field indicates the number of good IPv4
     * datagrams received with the TCP, UDP, or ICMP payload.
     */
    inline uint32_t get_MAC_RXIPV4_GOOD_PACKETS_RXIPV4GDPKT() volatile
    {
        return (MAC_RXIPV4_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_HEADER_ERROR_PACKETS's RXIPV4HDRERRPKT field.
     *
     * RxIPv4 Header Error Packets This field indicates the number of IPv4
     * datagrams received with header (checksum, length, or version mismatch)
     * errors.
     */
    inline uint32_t
    get_MAC_RXIPV4_HEADER_ERROR_PACKETS_RXIPV4HDRERRPKT() volatile
    {
        return (MAC_RXIPV4_HEADER_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_NO_PAYLOAD_PACKETS's RXIPV4NOPAYPKT field.
     *
     * RxIPv4 Payload Packets This field indicates the number of IPv4 datagram
     * packets received that did not have a TCP, UDP, or ICMP payload.
     */
    inline uint32_t get_MAC_RXIPV4_NO_PAYLOAD_PACKETS_RXIPV4NOPAYPKT() volatile
    {
        return (MAC_RXIPV4_NO_PAYLOAD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_FRAGMENTED_PACKETS's RXIPV4FRAGPKT field.
     *
     * RxIPv4 Fragmented Packets This field indicates the number of good IPv4
     * datagrams received with fragmentation.
     */
    inline uint32_t get_MAC_RXIPV4_FRAGMENTED_PACKETS_RXIPV4FRAGPKT() volatile
    {
        return (MAC_RXIPV4_FRAGMENTED_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS's RXIPV4UDSBLPKT field.
     *
     * RxIPv4 UDP Checksum Disabled Packets This field indicates the number of
     * good IPv4 datagrams received that had a UDP payload with checksum
     * disabled.
     */
    inline uint32_t
    get_MAC_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_RXIPV4UDSBLPKT() volatile
    {
        return (MAC_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV6_GOOD_PACKETS's RXIPV6GDPKT field.
     *
     * RxIPv6 Good Packets This field indicates the number of good IPv6
     * datagrams received with the TCP, UDP, or ICMP payload.
     */
    inline uint32_t get_MAC_RXIPV6_GOOD_PACKETS_RXIPV6GDPKT() volatile
    {
        return (MAC_RXIPV6_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV6_HEADER_ERROR_PACKETS's RXIPV6HDRERRPKT field.
     *
     * RxIPv6 Header Error Packets This field indicates the number of IPv6
     * datagrams received with header (length or version mismatch) errors.
     */
    inline uint32_t
    get_MAC_RXIPV6_HEADER_ERROR_PACKETS_RXIPV6HDRERRPKT() volatile
    {
        return (MAC_RXIPV6_HEADER_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV6_NO_PAYLOAD_PACKETS's RXIPV6NOPAYPKT field.
     *
     * RxIPv6 Payload Packets This field indicates the number of IPv6 datagram
     * packets received that did not have a TCP, UDP, or ICMP payload.
     */
    inline uint32_t get_MAC_RXIPV6_NO_PAYLOAD_PACKETS_RXIPV6NOPAYPKT() volatile
    {
        return (MAC_RXIPV6_NO_PAYLOAD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXUDP_GOOD_PACKETS's RXUDPGDPKT field.
     *
     * RxUDP Good Packets This field indicates the number of good IP datagrams
     * received with a good UDP payload.
     */
    inline uint32_t get_MAC_RXUDP_GOOD_PACKETS_RXUDPGDPKT() volatile
    {
        return (MAC_RXUDP_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXUDP_ERROR_PACKETS's RXUDPERRPKT field.
     *
     * RxUDP Error Packets This field indicates the number of good IP datagrams
     * received whose UDP payload has a checksum error.
     */
    inline uint32_t get_MAC_RXUDP_ERROR_PACKETS_RXUDPERRPKT() volatile
    {
        return (MAC_RXUDP_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXTCP_GOOD_PACKETS's RXTCPGDPKT field.
     *
     * RxTCP Good Packets This field indicates the number of good IP datagrams
     * received with a good TCP payload.
     */
    inline uint32_t get_MAC_RXTCP_GOOD_PACKETS_RXTCPGDPKT() volatile
    {
        return (MAC_RXTCP_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXTCP_ERROR_PACKETS's RXTCPERRPKT field.
     *
     * RxTCP Error Packets This field indicates the number of good IP datagrams
     * received whose TCP payload has a checksum error.
     */
    inline uint32_t get_MAC_RXTCP_ERROR_PACKETS_RXTCPERRPKT() volatile
    {
        return (MAC_RXTCP_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXICMP_GOOD_PACKETS's RXICMPGDPKT field.
     *
     * RxICMP Good Packets This field indicates the number of good IP datagrams
     * received with a good ICMP payload.
     */
    inline uint32_t get_MAC_RXICMP_GOOD_PACKETS_RXICMPGDPKT() volatile
    {
        return (MAC_RXICMP_GOOD_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXICMP_ERROR_PACKETS's RXICMPERRPKT field.
     *
     * RxICMP Error Packets This field indicates the number of good IP
     * datagrams received whose ICMP payload has a checksum error.
     */
    inline uint32_t get_MAC_RXICMP_ERROR_PACKETS_RXICMPERRPKT() volatile
    {
        return (MAC_RXICMP_ERROR_PACKETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_GOOD_OCTETS's RXIPV4GDOCT field.
     *
     * RxIPv4 Good Octets This field indicates the number of bytes received in
     * good IPv4 datagrams encapsulating TCP, UDP, or ICMP data.
     */
    inline uint32_t get_MAC_RXIPV4_GOOD_OCTETS_RXIPV4GDOCT() volatile
    {
        return (MAC_RXIPV4_GOOD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_HEADER_ERROR_OCTETS's RXIPV4HDRERROCT field.
     *
     * RxIPv4 Header Error Octets This field indicates the number of bytes
     * received in IPv4 datagrams with header errors (checksum, length, version
     * mismatch).
     */
    inline uint32_t
    get_MAC_RXIPV4_HEADER_ERROR_OCTETS_RXIPV4HDRERROCT() volatile
    {
        return (MAC_RXIPV4_HEADER_ERROR_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_NO_PAYLOAD_OCTETS's RXIPV4NOPAYOCT field.
     *
     * RxIPv4 Payload Octets This field indicates the number of bytes received
     * in IPv4 datagrams that did not have a TCP, UDP, or ICMP payload.
     */
    inline uint32_t get_MAC_RXIPV4_NO_PAYLOAD_OCTETS_RXIPV4NOPAYOCT() volatile
    {
        return (MAC_RXIPV4_NO_PAYLOAD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_FRAGMENTED_OCTETS's RXIPV4FRAGOCT field.
     *
     * RxIPv4 Fragmented Octets This field indicates the number of bytes
     * received in fragmented IPv4 datagrams.
     */
    inline uint32_t get_MAC_RXIPV4_FRAGMENTED_OCTETS_RXIPV4FRAGOCT() volatile
    {
        return (MAC_RXIPV4_FRAGMENTED_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS's RXIPV4UDSBLOCT field.
     *
     * RxIPv4 UDP Checksum Disable Octets This field indicates the number of
     * bytes received in a UDP segment that had the UDP checksum disabled.
     */
    inline uint32_t
    get_MAC_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_RXIPV4UDSBLOCT() volatile
    {
        return (MAC_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV6_GOOD_OCTETS's RXIPV6GDOCT field.
     *
     * RxIPv6 Good Octets This field indicates the number of bytes received in
     * good IPv6 datagrams encapsulating TCP, UDP, or ICMP data.
     */
    inline uint32_t get_MAC_RXIPV6_GOOD_OCTETS_RXIPV6GDOCT() volatile
    {
        return (MAC_RXIPV6_GOOD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV6_HEADER_ERROR_OCTETS's RXIPV6HDRERROCT field.
     *
     * RxIPv6 Header Error Octets This field indicates the number of bytes
     * received in IPv6 datagrams with header errors (length, version
     * mismatch).
     */
    inline uint32_t
    get_MAC_RXIPV6_HEADER_ERROR_OCTETS_RXIPV6HDRERROCT() volatile
    {
        return (MAC_RXIPV6_HEADER_ERROR_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXIPV6_NO_PAYLOAD_OCTETS's RXIPV6NOPAYOCT field.
     *
     * RxIPv6 Payload Octets This field indicates the number of bytes received
     * in IPv6 datagrams that did not have a TCP, UDP, or ICMP payload.
     */
    inline uint32_t get_MAC_RXIPV6_NO_PAYLOAD_OCTETS_RXIPV6NOPAYOCT() volatile
    {
        return (MAC_RXIPV6_NO_PAYLOAD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXUDP_GOOD_OCTETS's RXUDPGDOCT field.
     *
     * RxUDP Good Octets This field indicates the number of bytes received in a
     * good UDP segment.
     */
    inline uint32_t get_MAC_RXUDP_GOOD_OCTETS_RXUDPGDOCT() volatile
    {
        return (MAC_RXUDP_GOOD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXUDP_ERROR_OCTETS's RXUDPERROCT field.
     *
     * RxUDP Error Octets This field indicates the number of bytes received in
     * a UDP segment that had checksum errors.
     */
    inline uint32_t get_MAC_RXUDP_ERROR_OCTETS_RXUDPERROCT() volatile
    {
        return (MAC_RXUDP_ERROR_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXTCP_GOOD_OCTETS's RXTCPGDOCT field.
     *
     * RxTCP Good Octets This field indicates the number of bytes received in a
     * good TCP segment.
     */
    inline uint32_t get_MAC_RXTCP_GOOD_OCTETS_RXTCPGDOCT() volatile
    {
        return (MAC_RXTCP_GOOD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXTCP_ERROR_OCTETS's RXTCPERROCT field.
     *
     * RxTCP Error Octets This field indicates the number of bytes received in
     * a TCP segment that had checksum errors.
     */
    inline uint32_t get_MAC_RXTCP_ERROR_OCTETS_RXTCPERROCT() volatile
    {
        return (MAC_RXTCP_ERROR_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXICMP_GOOD_OCTETS's RXICMPGDOCT field.
     *
     * RxICMP Good Octets This field indicates the number of bytes received in
     * a good ICMP segment.
     */
    inline uint32_t get_MAC_RXICMP_GOOD_OCTETS_RXICMPGDOCT() volatile
    {
        return (MAC_RXICMP_GOOD_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_RXICMP_ERROR_OCTETS's RXICMPERROCT field.
     *
     * RxICMP Error Octets This field indicates the number of bytes received in
     * a ICMP segment that had checksum errors.
     */
    inline uint32_t get_MAC_RXICMP_ERROR_OCTETS_RXICMPERROCT() volatile
    {
        return (MAC_RXICMP_ERROR_OCTETS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_FPE_TX_INTERRUPT's HRCIS bit.
     *
     * MMC Tx Hold Request Counter Interrupt Status This bit is set when the
     * Tx_Hold_Req_Cntr counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_FPE_TX_INTERRUPT_HRCIS() volatile
    {
        return MAC_MMC_FPE_TX_INTERRUPT & (1u << 1u);
    }

    /**
     * Get MAC_MMC_FPE_TX_INTERRUPT's FCIS bit.
     *
     * MMC Tx FPE Fragment Counter Interrupt status This bit is set when the
     * Tx_FPE_Fragment_Cntr counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_FPE_TX_INTERRUPT_FCIS() volatile
    {
        return MAC_MMC_FPE_TX_INTERRUPT & (1u << 0u);
    }

    /**
     * Get all of MAC_MMC_FPE_TX_INTERRUPT's bit fields.
     *
     * (read-write) MMC FPE Transmit Interrupt
     */
    inline void get_MAC_MMC_FPE_TX_INTERRUPT(bool &HRCIS, bool &FCIS) volatile
    {
        uint32_t curr = MAC_MMC_FPE_TX_INTERRUPT;

        HRCIS = curr & (1u << 1u);
        FCIS = curr & (1u << 0u);
    }

    /**
     * Get MAC_MMC_FPE_TX_INTERRUPT_MASK's HRCIM bit.
     *
     * MMC Transmit Hold Request Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Tx_Hold_Req_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_TX_INTERRUPT_MASK_HRCIM() volatile
    {
        return MAC_MMC_FPE_TX_INTERRUPT_MASK & (1u << 1u);
    }

    /**
     * Set MAC_MMC_FPE_TX_INTERRUPT_MASK's HRCIM bit.
     *
     * MMC Transmit Hold Request Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Tx_Hold_Req_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_FPE_TX_INTERRUPT_MASK_HRCIM() volatile
    {
        MAC_MMC_FPE_TX_INTERRUPT_MASK |= 1u << 1u;
    }

    /**
     * Clear MAC_MMC_FPE_TX_INTERRUPT_MASK's HRCIM bit.
     *
     * MMC Transmit Hold Request Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Tx_Hold_Req_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_FPE_TX_INTERRUPT_MASK_HRCIM() volatile
    {
        MAC_MMC_FPE_TX_INTERRUPT_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MMC_FPE_TX_INTERRUPT_MASK's HRCIM bit.
     *
     * MMC Transmit Hold Request Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Tx_Hold_Req_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_FPE_TX_INTERRUPT_MASK_HRCIM() volatile
    {
        MAC_MMC_FPE_TX_INTERRUPT_MASK ^= 1u << 1u;
    }

    /**
     * Get MAC_MMC_FPE_TX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Transmit Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_TX_INTERRUPT_MASK_FCIM() volatile
    {
        return MAC_MMC_FPE_TX_INTERRUPT_MASK & (1u << 0u);
    }

    /**
     * Set MAC_MMC_FPE_TX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Transmit Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_FPE_TX_INTERRUPT_MASK_FCIM() volatile
    {
        MAC_MMC_FPE_TX_INTERRUPT_MASK |= 1u << 0u;
    }

    /**
     * Clear MAC_MMC_FPE_TX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Transmit Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_FPE_TX_INTERRUPT_MASK_FCIM() volatile
    {
        MAC_MMC_FPE_TX_INTERRUPT_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MMC_FPE_TX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Transmit Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_FPE_TX_INTERRUPT_MASK_FCIM() volatile
    {
        MAC_MMC_FPE_TX_INTERRUPT_MASK ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MMC_FPE_TX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC FPE Transmit Mask Interrupt
     */
    inline void get_MAC_MMC_FPE_TX_INTERRUPT_MASK(bool &HRCIM,
                                                  bool &FCIM) volatile
    {
        uint32_t curr = MAC_MMC_FPE_TX_INTERRUPT_MASK;

        HRCIM = curr & (1u << 1u);
        FCIM = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MMC_FPE_TX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC FPE Transmit Mask Interrupt
     */
    inline void set_MAC_MMC_FPE_TX_INTERRUPT_MASK(bool HRCIM,
                                                  bool FCIM) volatile
    {
        uint32_t curr = MAC_MMC_FPE_TX_INTERRUPT_MASK;

        curr &= ~(0b1u << 1u);
        curr |= (HRCIM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FCIM & 0b1u) << 0u;

        MAC_MMC_FPE_TX_INTERRUPT_MASK = curr;
    }

    /**
     * Get MAC_MMC_TX_FPE_FRAGMENT_CNTR's TXFFC field.
     *
     * Tx FPE Fragment counter This field indicates the number of additional
     * mPackets that has been transmitted due to preemption Exists when any one
     * of the RX/TX MMC counters are enabled during FPE Enabled configuration.
     */
    inline uint32_t get_MAC_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC() volatile
    {
        return (MAC_MMC_TX_FPE_FRAGMENT_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_TX_HOLD_REQ_CNTR's TXHRC field.
     *
     * Tx Hold Request Counter This field indicates count of number of a hold
     * request is given to MAC.
     */
    inline uint32_t get_MAC_MMC_TX_HOLD_REQ_CNTR_TXHRC() volatile
    {
        return (MAC_MMC_TX_HOLD_REQ_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT's FCIS bit.
     *
     * MMC Rx FPE Fragment Counter Interrupt Status This bit is set when the
     * Rx_FPE_Fragment_Cntr counter reaches half of the maximum value or the
     * maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_FCIS() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT & (1u << 3u);
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT's PAOCIS bit.
     *
     * MMC Rx Packet Assembly OK Counter Interrupt Status This bit is set when
     * the Rx_Packet_Assemble_Ok_Cntr counter reaches half of the maximum value
     * or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_PAOCIS() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT & (1u << 2u);
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT's PSECIS bit.
     *
     * MMC Rx Packet SMD Error Counter Interrupt Status This bit is set when
     * the Rx_Packet_SMD_Err_Cntr counter reaches half of the maximum value or
     * the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_PSECIS() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT & (1u << 1u);
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT's PAECIS bit.
     *
     * MMC Rx Packet Assembly Error Counter Interrupt Status This bit is set
     * when the Rx_Packet_Assemble_Err_Cntr counter reaches half of the maximum
     * value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_PAECIS() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT & (1u << 0u);
    }

    /**
     * Get all of MAC_MMC_FPE_RX_INTERRUPT's bit fields.
     *
     * (read-write) MMC FPE Receive Interrupt
     */
    inline void get_MAC_MMC_FPE_RX_INTERRUPT(bool &FCIS, bool &PAOCIS,
                                             bool &PSECIS,
                                             bool &PAECIS) volatile
    {
        uint32_t curr = MAC_MMC_FPE_RX_INTERRUPT;

        FCIS = curr & (1u << 3u);
        PAOCIS = curr & (1u << 2u);
        PSECIS = curr & (1u << 1u);
        PAECIS = curr & (1u << 0u);
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Rx FPE Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_MASK_FCIM() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT_MASK & (1u << 3u);
    }

    /**
     * Set MAC_MMC_FPE_RX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Rx FPE Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void set_MAC_MMC_FPE_RX_INTERRUPT_MASK_FCIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK |= 1u << 3u;
    }

    /**
     * Clear MAC_MMC_FPE_RX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Rx FPE Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_FPE_RX_INTERRUPT_MASK_FCIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_MMC_FPE_RX_INTERRUPT_MASK's FCIM bit.
     *
     * MMC Rx FPE Fragment Counter Interrupt Mask Setting this bit masks the
     * interrupt when the Tx_FPE_Fragment_Cntr counter reaches half of the
     * maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_FPE_RX_INTERRUPT_MASK_FCIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK ^= 1u << 3u;
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT_MASK's PAOCIM bit.
     *
     * MMC Rx Packet Assembly OK Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Rx_Packet_Assemble_Ok_Cntr counter reaches half
     * of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT_MASK & (1u << 2u);
    }

    /**
     * Set MAC_MMC_FPE_RX_INTERRUPT_MASK's PAOCIM bit.
     *
     * MMC Rx Packet Assembly OK Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Rx_Packet_Assemble_Ok_Cntr counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK |= 1u << 2u;
    }

    /**
     * Clear MAC_MMC_FPE_RX_INTERRUPT_MASK's PAOCIM bit.
     *
     * MMC Rx Packet Assembly OK Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Rx_Packet_Assemble_Ok_Cntr counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_MMC_FPE_RX_INTERRUPT_MASK's PAOCIM bit.
     *
     * MMC Rx Packet Assembly OK Counter Interrupt Mask Setting this bit masks
     * the interrupt when the Rx_Packet_Assemble_Ok_Cntr counter reaches half
     * of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK ^= 1u << 2u;
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT_MASK's PSECIM bit.
     *
     * MMC Rx Packet SMD Error Counter Interrupt Mask Setting this bit masks
     * the interrupt when the R Rx_Packet_SMD_Err_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_MASK_PSECIM() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT_MASK & (1u << 1u);
    }

    /**
     * Set MAC_MMC_FPE_RX_INTERRUPT_MASK's PSECIM bit.
     *
     * MMC Rx Packet SMD Error Counter Interrupt Mask Setting this bit masks
     * the interrupt when the R Rx_Packet_SMD_Err_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_FPE_RX_INTERRUPT_MASK_PSECIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK |= 1u << 1u;
    }

    /**
     * Clear MAC_MMC_FPE_RX_INTERRUPT_MASK's PSECIM bit.
     *
     * MMC Rx Packet SMD Error Counter Interrupt Mask Setting this bit masks
     * the interrupt when the R Rx_Packet_SMD_Err_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_FPE_RX_INTERRUPT_MASK_PSECIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_MMC_FPE_RX_INTERRUPT_MASK's PSECIM bit.
     *
     * MMC Rx Packet SMD Error Counter Interrupt Mask Setting this bit masks
     * the interrupt when the R Rx_Packet_SMD_Err_Cntr counter reaches half of
     * the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_FPE_RX_INTERRUPT_MASK_PSECIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK ^= 1u << 1u;
    }

    /**
     * Get MAC_MMC_FPE_RX_INTERRUPT_MASK's PAECIM bit.
     *
     * MMC Rx Packet Assembly Error Counter Interrupt Mask Setting this bit
     * masks the interrupt when the R Rx_Packet_Assemble_Err_Cntr counter
     * reaches half of the maximum value or the maximum value.
     */
    inline bool get_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAECIM() volatile
    {
        return MAC_MMC_FPE_RX_INTERRUPT_MASK & (1u << 0u);
    }

    /**
     * Set MAC_MMC_FPE_RX_INTERRUPT_MASK's PAECIM bit.
     *
     * MMC Rx Packet Assembly Error Counter Interrupt Mask Setting this bit
     * masks the interrupt when the R Rx_Packet_Assemble_Err_Cntr counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void set_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAECIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK |= 1u << 0u;
    }

    /**
     * Clear MAC_MMC_FPE_RX_INTERRUPT_MASK's PAECIM bit.
     *
     * MMC Rx Packet Assembly Error Counter Interrupt Mask Setting this bit
     * masks the interrupt when the R Rx_Packet_Assemble_Err_Cntr counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void clear_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAECIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_MMC_FPE_RX_INTERRUPT_MASK's PAECIM bit.
     *
     * MMC Rx Packet Assembly Error Counter Interrupt Mask Setting this bit
     * masks the interrupt when the R Rx_Packet_Assemble_Err_Cntr counter
     * reaches half of the maximum value or the maximum value.
     */
    inline void toggle_MAC_MMC_FPE_RX_INTERRUPT_MASK_PAECIM() volatile
    {
        MAC_MMC_FPE_RX_INTERRUPT_MASK ^= 1u << 0u;
    }

    /**
     * Get all of MAC_MMC_FPE_RX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC FPE Receive Interrupt Mask
     */
    inline void get_MAC_MMC_FPE_RX_INTERRUPT_MASK(bool &FCIM, bool &PAOCIM,
                                                  bool &PSECIM,
                                                  bool &PAECIM) volatile
    {
        uint32_t curr = MAC_MMC_FPE_RX_INTERRUPT_MASK;

        FCIM = curr & (1u << 3u);
        PAOCIM = curr & (1u << 2u);
        PSECIM = curr & (1u << 1u);
        PAECIM = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_MMC_FPE_RX_INTERRUPT_MASK's bit fields.
     *
     * (read-write) MMC FPE Receive Interrupt Mask
     */
    inline void set_MAC_MMC_FPE_RX_INTERRUPT_MASK(bool FCIM, bool PAOCIM,
                                                  bool PSECIM,
                                                  bool PAECIM) volatile
    {
        uint32_t curr = MAC_MMC_FPE_RX_INTERRUPT_MASK;

        curr &= ~(0b1u << 3u);
        curr |= (FCIM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PAOCIM & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PSECIM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PAECIM & 0b1u) << 0u;

        MAC_MMC_FPE_RX_INTERRUPT_MASK = curr;
    }

    /**
     * Get MAC_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR's PAEC field.
     *
     * Rx Packet Assembly Error Counter This field indicates the number of MAC
     * frames with reassembly errors on the Receiver, due to mismatch in the
     * Fragment Count value.
     */
    inline uint32_t get_MAC_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC() volatile
    {
        return (MAC_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_RX_PACKET_SMD_ERR_CNTR's PSEC field.
     *
     * Rx Packet SMD Error Counter This field indicates the number of MAC
     * frames rejected due to unknown SMD value and MAC frame fragments
     * rejected due to arriving with an SMD-C when there was no preceding
     * preempted frame.
     */
    inline uint32_t get_MAC_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC() volatile
    {
        return (MAC_MMC_RX_PACKET_SMD_ERR_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_RX_PACKET_ASSEMBLY_OK_CNTR's PAOC field.
     *
     * Rx Packet Assembly OK Counter This field indicates the number of MAC
     * frames that were successfully reassembled and delivered to MAC.
     */
    inline uint32_t get_MAC_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC() volatile
    {
        return (MAC_MMC_RX_PACKET_ASSEMBLY_OK_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_MMC_RX_FPE_FRAGMENT_CNTR's FFC field.
     *
     * Rx FPE Fragment Counter This field indicates the number of additional
     * mPackets received due to preemption Exists when at least one of the
     * RX/TX MMC counters are enabled during FPE Enabled configuration.
     */
    inline uint32_t get_MAC_MMC_RX_FPE_FRAGMENT_CNTR_FFC() volatile
    {
        return (MAC_MMC_RX_FPE_FRAGMENT_CNTR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's DMCHEN0 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL0_DMCHEN0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's DMCHEN0 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL0_DMCHEN0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's DMCHEN0 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL0_DMCHEN0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's DMCHEN0 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_DMCHEN0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's DMCHN0 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL0_DMCHN0() volatile
    {
        return (MAC_L3_L4_CONTROL0 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL0's DMCHN0 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL0_DMCHN0(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL0 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L4DPIM0 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L4DPIM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L4DPIM0 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L4DPIM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L4DPIM0 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L4DPIM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L4DPIM0 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L4DPIM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L4DPM0 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L4DPM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L4DPM0 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L4DPM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L4DPM0 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L4DPM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L4DPM0 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L4DPM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L4SPIM0 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L4SPIM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L4SPIM0 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L4SPIM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L4SPIM0 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L4SPIM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L4SPIM0 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L4SPIM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L4SPM0 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L4SPM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L4SPM0 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L4SPM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L4SPM0 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L4SPM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L4SPM0 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L4SPM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L4PEN0 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L4PEN0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L4PEN0 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L4PEN0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L4PEN0 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L4PEN0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L4PEN0 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L4PEN0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3HDBM0 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL0_L3HDBM0() volatile
    {
        return (MAC_L3_L4_CONTROL0 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3HDBM0 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3HDBM0(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL0;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL0 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3HSBM0 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL0_L3HSBM0() volatile
    {
        return (MAC_L3_L4_CONTROL0 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3HSBM0 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3HSBM0(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL0;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL0 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3DAIM0 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L3DAIM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3DAIM0 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3DAIM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L3DAIM0 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L3DAIM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L3DAIM0 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L3DAIM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3DAM0 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L3DAM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3DAM0 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3DAM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L3DAM0 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L3DAM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L3DAM0 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L3DAM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3SAIM0 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L3SAIM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3SAIM0 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3SAIM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L3SAIM0 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L3SAIM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L3SAIM0 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L3SAIM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3SAM0 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L3SAM0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3SAM0 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3SAM0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L3SAM0 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L3SAM0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L3SAM0 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L3SAM0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL0's L3PEN0 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL0_L3PEN0() volatile
    {
        return MAC_L3_L4_CONTROL0 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL0's L3PEN0 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL0_L3PEN0() volatile
    {
        MAC_L3_L4_CONTROL0 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL0's L3PEN0 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL0_L3PEN0() volatile
    {
        MAC_L3_L4_CONTROL0 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL0's L3PEN0 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL0_L3PEN0() volatile
    {
        MAC_L3_L4_CONTROL0 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL0's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 0
     */
    inline void get_MAC_L3_L4_CONTROL0(bool &DMCHEN0, uint8_t &DMCHN0,
                                       bool &L4DPIM0, bool &L4DPM0,
                                       bool &L4SPIM0, bool &L4SPM0,
                                       bool &L4PEN0, uint8_t &L3HDBM0,
                                       uint8_t &L3HSBM0, bool &L3DAIM0,
                                       bool &L3DAM0, bool &L3SAIM0,
                                       bool &L3SAM0, bool &L3PEN0) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL0;

        DMCHEN0 = curr & (1u << 28u);
        DMCHN0 = (curr >> 24u) & 0b111u;
        L4DPIM0 = curr & (1u << 21u);
        L4DPM0 = curr & (1u << 20u);
        L4SPIM0 = curr & (1u << 19u);
        L4SPM0 = curr & (1u << 18u);
        L4PEN0 = curr & (1u << 16u);
        L3HDBM0 = (curr >> 11u) & 0b11111u;
        L3HSBM0 = (curr >> 6u) & 0b11111u;
        L3DAIM0 = curr & (1u << 5u);
        L3DAM0 = curr & (1u << 4u);
        L3SAIM0 = curr & (1u << 3u);
        L3SAM0 = curr & (1u << 2u);
        L3PEN0 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL0's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 0
     */
    inline void set_MAC_L3_L4_CONTROL0(bool DMCHEN0, uint8_t DMCHN0,
                                       bool L4DPIM0, bool L4DPM0, bool L4SPIM0,
                                       bool L4SPM0, bool L4PEN0,
                                       uint8_t L3HDBM0, uint8_t L3HSBM0,
                                       bool L3DAIM0, bool L3DAM0, bool L3SAIM0,
                                       bool L3SAM0, bool L3PEN0) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL0;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN0 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN0 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM0 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM0 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM0 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM0 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN0 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM0 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM0 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM0 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM0 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM0 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM0 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN0 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL0 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS0's L4DP0 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS0_L4DP0() volatile
    {
        return (MAC_LAYER4_ADDRESS0 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS0's L4DP0 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS0_L4DP0(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS0;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS0 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS0's L4SP0 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS0_L4SP0() volatile
    {
        return (MAC_LAYER4_ADDRESS0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS0's L4SP0 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS0_L4SP0(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS0 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS0's bit fields.
     *
     * (read-write) Layer 4 Address 0
     */
    inline void get_MAC_LAYER4_ADDRESS0(uint16_t &L4DP0,
                                        uint16_t &L4SP0) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS0;

        L4DP0 = (curr >> 16u) & 0b1111111111111111u;
        L4SP0 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS0's bit fields.
     *
     * (read-write) Layer 4 Address 0
     */
    inline void set_MAC_LAYER4_ADDRESS0(uint16_t L4DP0,
                                        uint16_t L4SP0) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS0;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP0 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP0 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS0 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG0's L3A00 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG0_L3A00() volatile
    {
        return (MAC_LAYER3_ADDR0_REG0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG0's L3A00 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG0_L3A00(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG0 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG0's L3A10 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG0_L3A10() volatile
    {
        return (MAC_LAYER3_ADDR1_REG0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG0's L3A10 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG0_L3A10(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG0 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG0's L3A20 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG0_L3A20() volatile
    {
        return (MAC_LAYER3_ADDR2_REG0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG0's L3A20 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG0_L3A20(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG0 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG0's L3A30 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG0_L3A30() volatile
    {
        return (MAC_LAYER3_ADDR3_REG0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG0's L3A30 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG0_L3A30(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG0 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's DMCHEN1 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL1_DMCHEN1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's DMCHEN1 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL1_DMCHEN1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's DMCHEN1 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL1_DMCHEN1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's DMCHEN1 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_DMCHEN1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's DMCHN1 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL1_DMCHN1() volatile
    {
        return (MAC_L3_L4_CONTROL1 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL1's DMCHN1 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL1_DMCHN1(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL1;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL1 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L4DPIM1 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L4DPIM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L4DPIM1 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L4DPIM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L4DPIM1 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L4DPIM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L4DPIM1 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L4DPIM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L4DPM1 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L4DPM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L4DPM1 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L4DPM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L4DPM1 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L4DPM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L4DPM1 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L4DPM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L4SPIM1 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L4SPIM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L4SPIM1 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L4SPIM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L4SPIM1 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L4SPIM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L4SPIM1 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L4SPIM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L4SPM1 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L4SPM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L4SPM1 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L4SPM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L4SPM1 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L4SPM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L4SPM1 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L4SPM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L4PEN1 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L4PEN1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L4PEN1 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L4PEN1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L4PEN1 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L4PEN1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L4PEN1 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L4PEN1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3HDBM1 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL1_L3HDBM1() volatile
    {
        return (MAC_L3_L4_CONTROL1 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3HDBM1 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3HDBM1(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL1;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL1 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3HSBM1 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL1_L3HSBM1() volatile
    {
        return (MAC_L3_L4_CONTROL1 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3HSBM1 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3HSBM1(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL1;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL1 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3DAIM1 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L3DAIM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3DAIM1 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3DAIM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L3DAIM1 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L3DAIM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L3DAIM1 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L3DAIM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3DAM1 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L3DAM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3DAM1 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3DAM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L3DAM1 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L3DAM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L3DAM1 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L3DAM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3SAIM1 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L3SAIM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3SAIM1 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3SAIM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L3SAIM1 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L3SAIM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L3SAIM1 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L3SAIM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3SAM1 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L3SAM1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3SAM1 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3SAM1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L3SAM1 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L3SAM1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L3SAM1 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L3SAM1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL1's L3PEN1 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL1_L3PEN1() volatile
    {
        return MAC_L3_L4_CONTROL1 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL1's L3PEN1 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL1_L3PEN1() volatile
    {
        MAC_L3_L4_CONTROL1 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL1's L3PEN1 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL1_L3PEN1() volatile
    {
        MAC_L3_L4_CONTROL1 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL1's L3PEN1 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL1_L3PEN1() volatile
    {
        MAC_L3_L4_CONTROL1 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL1's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 1
     */
    inline void get_MAC_L3_L4_CONTROL1(bool &DMCHEN1, uint8_t &DMCHN1,
                                       bool &L4DPIM1, bool &L4DPM1,
                                       bool &L4SPIM1, bool &L4SPM1,
                                       bool &L4PEN1, uint8_t &L3HDBM1,
                                       uint8_t &L3HSBM1, bool &L3DAIM1,
                                       bool &L3DAM1, bool &L3SAIM1,
                                       bool &L3SAM1, bool &L3PEN1) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL1;

        DMCHEN1 = curr & (1u << 28u);
        DMCHN1 = (curr >> 24u) & 0b111u;
        L4DPIM1 = curr & (1u << 21u);
        L4DPM1 = curr & (1u << 20u);
        L4SPIM1 = curr & (1u << 19u);
        L4SPM1 = curr & (1u << 18u);
        L4PEN1 = curr & (1u << 16u);
        L3HDBM1 = (curr >> 11u) & 0b11111u;
        L3HSBM1 = (curr >> 6u) & 0b11111u;
        L3DAIM1 = curr & (1u << 5u);
        L3DAM1 = curr & (1u << 4u);
        L3SAIM1 = curr & (1u << 3u);
        L3SAM1 = curr & (1u << 2u);
        L3PEN1 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL1's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 1
     */
    inline void set_MAC_L3_L4_CONTROL1(bool DMCHEN1, uint8_t DMCHN1,
                                       bool L4DPIM1, bool L4DPM1, bool L4SPIM1,
                                       bool L4SPM1, bool L4PEN1,
                                       uint8_t L3HDBM1, uint8_t L3HSBM1,
                                       bool L3DAIM1, bool L3DAM1, bool L3SAIM1,
                                       bool L3SAM1, bool L3PEN1) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL1;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN1 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN1 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM1 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM1 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM1 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM1 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN1 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM1 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM1 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM1 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM1 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM1 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM1 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN1 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL1 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS1's L4DP1 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS1_L4DP1() volatile
    {
        return (MAC_LAYER4_ADDRESS1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS1's L4DP1 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS1_L4DP1(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS1 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS1's L4SP1 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS1_L4SP1() volatile
    {
        return (MAC_LAYER4_ADDRESS1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS1's L4SP1 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS1_L4SP1(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS1 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS1's bit fields.
     *
     * (read-write) Layer 4 Address 0
     */
    inline void get_MAC_LAYER4_ADDRESS1(uint16_t &L4DP1,
                                        uint16_t &L4SP1) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS1;

        L4DP1 = (curr >> 16u) & 0b1111111111111111u;
        L4SP1 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS1's bit fields.
     *
     * (read-write) Layer 4 Address 0
     */
    inline void set_MAC_LAYER4_ADDRESS1(uint16_t L4DP1,
                                        uint16_t L4SP1) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP1 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP1 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS1 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG1's L3A01 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG1_L3A01() volatile
    {
        return (MAC_LAYER3_ADDR0_REG1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG1's L3A01 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG1_L3A01(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG1 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG1's L3A11 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG1_L3A11() volatile
    {
        return (MAC_LAYER3_ADDR1_REG1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG1's L3A11 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG1_L3A11(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG1 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG1's L3A21 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG1_L3A21() volatile
    {
        return (MAC_LAYER3_ADDR2_REG1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG1's L3A21 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG1_L3A21(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG1 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG1's L3A31 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG1_L3A31() volatile
    {
        return (MAC_LAYER3_ADDR3_REG1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG1's L3A31 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG1_L3A31(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG1 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's DMCHEN2 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL2_DMCHEN2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's DMCHEN2 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL2_DMCHEN2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's DMCHEN2 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL2_DMCHEN2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's DMCHEN2 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_DMCHEN2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's DMCHN2 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL2_DMCHN2() volatile
    {
        return (MAC_L3_L4_CONTROL2 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL2's DMCHN2 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL2_DMCHN2(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL2;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL2 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L4DPIM2 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L4DPIM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L4DPIM2 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L4DPIM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L4DPIM2 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L4DPIM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L4DPIM2 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L4DPIM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L4DPM2 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L4DPM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L4DPM2 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L4DPM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L4DPM2 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L4DPM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L4DPM2 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L4DPM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L4SPIM2 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L4SPIM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L4SPIM2 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L4SPIM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L4SPIM2 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L4SPIM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L4SPIM2 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L4SPIM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L4SPM2 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L4SPM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L4SPM2 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L4SPM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L4SPM2 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L4SPM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L4SPM2 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L4SPM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L4PEN2 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L4PEN2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L4PEN2 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L4PEN2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L4PEN2 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L4PEN2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L4PEN2 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L4PEN2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3HDBM2 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL2_L3HDBM2() volatile
    {
        return (MAC_L3_L4_CONTROL2 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3HDBM2 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3HDBM2(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL2;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL2 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3HSBM2 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL2_L3HSBM2() volatile
    {
        return (MAC_L3_L4_CONTROL2 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3HSBM2 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3HSBM2(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL2;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL2 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3DAIM2 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L3DAIM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3DAIM2 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3DAIM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L3DAIM2 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L3DAIM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L3DAIM2 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L3DAIM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3DAM2 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L3DAM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3DAM2 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3DAM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L3DAM2 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L3DAM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L3DAM2 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L3DAM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3SAIM2 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L3SAIM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3SAIM2 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3SAIM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L3SAIM2 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L3SAIM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L3SAIM2 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L3SAIM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3SAM2 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L3SAM2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3SAM2 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3SAM2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L3SAM2 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L3SAM2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L3SAM2 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L3SAM2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL2's L3PEN2 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL2_L3PEN2() volatile
    {
        return MAC_L3_L4_CONTROL2 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL2's L3PEN2 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL2_L3PEN2() volatile
    {
        MAC_L3_L4_CONTROL2 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL2's L3PEN2 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL2_L3PEN2() volatile
    {
        MAC_L3_L4_CONTROL2 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL2's L3PEN2 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL2_L3PEN2() volatile
    {
        MAC_L3_L4_CONTROL2 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL2's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 2
     */
    inline void get_MAC_L3_L4_CONTROL2(bool &DMCHEN2, uint8_t &DMCHN2,
                                       bool &L4DPIM2, bool &L4DPM2,
                                       bool &L4SPIM2, bool &L4SPM2,
                                       bool &L4PEN2, uint8_t &L3HDBM2,
                                       uint8_t &L3HSBM2, bool &L3DAIM2,
                                       bool &L3DAM2, bool &L3SAIM2,
                                       bool &L3SAM2, bool &L3PEN2) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL2;

        DMCHEN2 = curr & (1u << 28u);
        DMCHN2 = (curr >> 24u) & 0b111u;
        L4DPIM2 = curr & (1u << 21u);
        L4DPM2 = curr & (1u << 20u);
        L4SPIM2 = curr & (1u << 19u);
        L4SPM2 = curr & (1u << 18u);
        L4PEN2 = curr & (1u << 16u);
        L3HDBM2 = (curr >> 11u) & 0b11111u;
        L3HSBM2 = (curr >> 6u) & 0b11111u;
        L3DAIM2 = curr & (1u << 5u);
        L3DAM2 = curr & (1u << 4u);
        L3SAIM2 = curr & (1u << 3u);
        L3SAM2 = curr & (1u << 2u);
        L3PEN2 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL2's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 2
     */
    inline void set_MAC_L3_L4_CONTROL2(bool DMCHEN2, uint8_t DMCHN2,
                                       bool L4DPIM2, bool L4DPM2, bool L4SPIM2,
                                       bool L4SPM2, bool L4PEN2,
                                       uint8_t L3HDBM2, uint8_t L3HSBM2,
                                       bool L3DAIM2, bool L3DAM2, bool L3SAIM2,
                                       bool L3SAM2, bool L3PEN2) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL2;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN2 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN2 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM2 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM2 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM2 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM2 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN2 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM2 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM2 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM2 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM2 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM2 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM2 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN2 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL2 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS2's L4DP2 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS2_L4DP2() volatile
    {
        return (MAC_LAYER4_ADDRESS2 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS2's L4DP2 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS2_L4DP2(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS2;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS2 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS2's L4SP2 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS2_L4SP2() volatile
    {
        return (MAC_LAYER4_ADDRESS2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS2's L4SP2 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS2_L4SP2(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS2 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS2's bit fields.
     *
     * (read-write) Layer 4 Address 2
     */
    inline void get_MAC_LAYER4_ADDRESS2(uint16_t &L4DP2,
                                        uint16_t &L4SP2) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS2;

        L4DP2 = (curr >> 16u) & 0b1111111111111111u;
        L4SP2 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS2's bit fields.
     *
     * (read-write) Layer 4 Address 2
     */
    inline void set_MAC_LAYER4_ADDRESS2(uint16_t L4DP2,
                                        uint16_t L4SP2) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS2;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP2 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP2 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS2 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG2's L3A02 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG2_L3A02() volatile
    {
        return (MAC_LAYER3_ADDR0_REG2 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG2's L3A02 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG2_L3A02(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG2 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG2's L3A12 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG2_L3A12() volatile
    {
        return (MAC_LAYER3_ADDR1_REG2 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG2's L3A12 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG2_L3A12(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG2 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG2's L3A22 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG2_L3A22() volatile
    {
        return (MAC_LAYER3_ADDR2_REG2 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG2's L3A22 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG2_L3A22(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG2 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG2's L3A32 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG2_L3A32() volatile
    {
        return (MAC_LAYER3_ADDR3_REG2 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG2's L3A32 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG2_L3A32(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG2 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's DMCHEN3 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL3_DMCHEN3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's DMCHEN3 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL3_DMCHEN3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's DMCHEN3 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL3_DMCHEN3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's DMCHEN3 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_DMCHEN3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's DMCHN3 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL3_DMCHN3() volatile
    {
        return (MAC_L3_L4_CONTROL3 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL3's DMCHN3 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL3_DMCHN3(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL3;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL3 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L4DPIM3 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L4DPIM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L4DPIM3 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L4DPIM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L4DPIM3 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L4DPIM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L4DPIM3 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L4DPIM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L4DPM3 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L4DPM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L4DPM3 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L4DPM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L4DPM3 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L4DPM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L4DPM3 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L4DPM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L4SPIM3 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L4SPIM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L4SPIM3 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L4SPIM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L4SPIM3 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L4SPIM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L4SPIM3 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L4SPIM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L4SPM3 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L4SPM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L4SPM3 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L4SPM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L4SPM3 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L4SPM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L4SPM3 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L4SPM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L4PEN3 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L4PEN3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L4PEN3 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L4PEN3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L4PEN3 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L4PEN3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L4PEN3 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L4PEN3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3HDBM3 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL3_L3HDBM3() volatile
    {
        return (MAC_L3_L4_CONTROL3 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3HDBM3 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3HDBM3(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL3;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL3 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3HSBM3 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL3_L3HSBM3() volatile
    {
        return (MAC_L3_L4_CONTROL3 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3HSBM3 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3HSBM3(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL3;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL3 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3DAIM3 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L3DAIM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3DAIM3 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3DAIM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L3DAIM3 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L3DAIM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L3DAIM3 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L3DAIM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3DAM3 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L3DAM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3DAM3 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3DAM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L3DAM3 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L3DAM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L3DAM3 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L3DAM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3SAIM3 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L3SAIM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3SAIM3 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3SAIM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L3SAIM3 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L3SAIM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L3SAIM3 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L3SAIM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3SAM3 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L3SAM3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3SAM3 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3SAM3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L3SAM3 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L3SAM3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L3SAM3 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L3SAM3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL3's L3PEN3 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL3_L3PEN3() volatile
    {
        return MAC_L3_L4_CONTROL3 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL3's L3PEN3 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL3_L3PEN3() volatile
    {
        MAC_L3_L4_CONTROL3 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL3's L3PEN3 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL3_L3PEN3() volatile
    {
        MAC_L3_L4_CONTROL3 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL3's L3PEN3 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL3_L3PEN3() volatile
    {
        MAC_L3_L4_CONTROL3 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL3's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 3
     */
    inline void get_MAC_L3_L4_CONTROL3(bool &DMCHEN3, uint8_t &DMCHN3,
                                       bool &L4DPIM3, bool &L4DPM3,
                                       bool &L4SPIM3, bool &L4SPM3,
                                       bool &L4PEN3, uint8_t &L3HDBM3,
                                       uint8_t &L3HSBM3, bool &L3DAIM3,
                                       bool &L3DAM3, bool &L3SAIM3,
                                       bool &L3SAM3, bool &L3PEN3) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL3;

        DMCHEN3 = curr & (1u << 28u);
        DMCHN3 = (curr >> 24u) & 0b111u;
        L4DPIM3 = curr & (1u << 21u);
        L4DPM3 = curr & (1u << 20u);
        L4SPIM3 = curr & (1u << 19u);
        L4SPM3 = curr & (1u << 18u);
        L4PEN3 = curr & (1u << 16u);
        L3HDBM3 = (curr >> 11u) & 0b11111u;
        L3HSBM3 = (curr >> 6u) & 0b11111u;
        L3DAIM3 = curr & (1u << 5u);
        L3DAM3 = curr & (1u << 4u);
        L3SAIM3 = curr & (1u << 3u);
        L3SAM3 = curr & (1u << 2u);
        L3PEN3 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL3's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 3
     */
    inline void set_MAC_L3_L4_CONTROL3(bool DMCHEN3, uint8_t DMCHN3,
                                       bool L4DPIM3, bool L4DPM3, bool L4SPIM3,
                                       bool L4SPM3, bool L4PEN3,
                                       uint8_t L3HDBM3, uint8_t L3HSBM3,
                                       bool L3DAIM3, bool L3DAM3, bool L3SAIM3,
                                       bool L3SAM3, bool L3PEN3) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL3;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN3 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN3 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM3 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM3 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM3 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN3 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM3 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM3 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM3 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM3 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM3 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN3 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL3 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS3's L4DP3 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS3_L4DP3() volatile
    {
        return (MAC_LAYER4_ADDRESS3 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS3's L4DP3 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS3_L4DP3(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS3 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS3's L4SP3 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS3_L4SP3() volatile
    {
        return (MAC_LAYER4_ADDRESS3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS3's L4SP3 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS3_L4SP3(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS3 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS3's bit fields.
     *
     * (read-write) Layer 4 Address 3
     */
    inline void get_MAC_LAYER4_ADDRESS3(uint16_t &L4DP3,
                                        uint16_t &L4SP3) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS3;

        L4DP3 = (curr >> 16u) & 0b1111111111111111u;
        L4SP3 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS3's bit fields.
     *
     * (read-write) Layer 4 Address 3
     */
    inline void set_MAC_LAYER4_ADDRESS3(uint16_t L4DP3,
                                        uint16_t L4SP3) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP3 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP3 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS3 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG3's L3A03 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG3_L3A03() volatile
    {
        return (MAC_LAYER3_ADDR0_REG3 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG3's L3A03 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG3_L3A03(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG3 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG3's L3A13 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG3_L3A13() volatile
    {
        return (MAC_LAYER3_ADDR1_REG3 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG3's L3A13 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG3_L3A13(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG3 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG3's L3A23 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG3_L3A23() volatile
    {
        return (MAC_LAYER3_ADDR2_REG3 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG3's L3A23 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG3_L3A23(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG3 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG3's L3A33 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG3_L3A33() volatile
    {
        return (MAC_LAYER3_ADDR3_REG3 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG3's L3A33 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG3_L3A33(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG3 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's DMCHEN4 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL4_DMCHEN4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's DMCHEN4 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL4_DMCHEN4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's DMCHEN4 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL4_DMCHEN4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's DMCHEN4 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_DMCHEN4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's DMCHN4 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL4_DMCHN4() volatile
    {
        return (MAC_L3_L4_CONTROL4 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL4's DMCHN4 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL4_DMCHN4(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL4;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL4 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L4DPIM4 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L4DPIM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L4DPIM4 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L4DPIM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L4DPIM4 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L4DPIM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L4DPIM4 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L4DPIM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L4DPM4 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L4DPM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L4DPM4 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L4DPM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L4DPM4 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L4DPM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L4DPM4 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L4DPM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L4SPIM4 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L4SPIM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L4SPIM4 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L4SPIM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L4SPIM4 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L4SPIM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L4SPIM4 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L4SPIM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L4SPM4 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L4SPM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L4SPM4 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L4SPM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L4SPM4 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L4SPM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L4SPM4 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L4SPM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L4PEN4 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L4PEN4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L4PEN4 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L4PEN4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L4PEN4 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L4PEN4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L4PEN4 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L4PEN4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3HDBM4 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL4_L3HDBM4() volatile
    {
        return (MAC_L3_L4_CONTROL4 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3HDBM4 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3HDBM4(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL4;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL4 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3HSBM4 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL4_L3HSBM4() volatile
    {
        return (MAC_L3_L4_CONTROL4 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3HSBM4 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3HSBM4(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL4;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL4 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3DAIM4 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L3DAIM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3DAIM4 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3DAIM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L3DAIM4 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L3DAIM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L3DAIM4 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L3DAIM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3DAM4 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L3DAM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3DAM4 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3DAM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L3DAM4 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L3DAM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L3DAM4 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L3DAM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3SAIM4 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L3SAIM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3SAIM4 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3SAIM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L3SAIM4 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L3SAIM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L3SAIM4 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L3SAIM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3SAM4 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L3SAM4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3SAM4 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3SAM4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L3SAM4 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L3SAM4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L3SAM4 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L3SAM4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL4's L3PEN4 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL4_L3PEN4() volatile
    {
        return MAC_L3_L4_CONTROL4 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL4's L3PEN4 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL4_L3PEN4() volatile
    {
        MAC_L3_L4_CONTROL4 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL4's L3PEN4 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL4_L3PEN4() volatile
    {
        MAC_L3_L4_CONTROL4 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL4's L3PEN4 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL4_L3PEN4() volatile
    {
        MAC_L3_L4_CONTROL4 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL4's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 4
     */
    inline void get_MAC_L3_L4_CONTROL4(bool &DMCHEN4, uint8_t &DMCHN4,
                                       bool &L4DPIM4, bool &L4DPM4,
                                       bool &L4SPIM4, bool &L4SPM4,
                                       bool &L4PEN4, uint8_t &L3HDBM4,
                                       uint8_t &L3HSBM4, bool &L3DAIM4,
                                       bool &L3DAM4, bool &L3SAIM4,
                                       bool &L3SAM4, bool &L3PEN4) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL4;

        DMCHEN4 = curr & (1u << 28u);
        DMCHN4 = (curr >> 24u) & 0b111u;
        L4DPIM4 = curr & (1u << 21u);
        L4DPM4 = curr & (1u << 20u);
        L4SPIM4 = curr & (1u << 19u);
        L4SPM4 = curr & (1u << 18u);
        L4PEN4 = curr & (1u << 16u);
        L3HDBM4 = (curr >> 11u) & 0b11111u;
        L3HSBM4 = (curr >> 6u) & 0b11111u;
        L3DAIM4 = curr & (1u << 5u);
        L3DAM4 = curr & (1u << 4u);
        L3SAIM4 = curr & (1u << 3u);
        L3SAM4 = curr & (1u << 2u);
        L3PEN4 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL4's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 4
     */
    inline void set_MAC_L3_L4_CONTROL4(bool DMCHEN4, uint8_t DMCHN4,
                                       bool L4DPIM4, bool L4DPM4, bool L4SPIM4,
                                       bool L4SPM4, bool L4PEN4,
                                       uint8_t L3HDBM4, uint8_t L3HSBM4,
                                       bool L3DAIM4, bool L3DAM4, bool L3SAIM4,
                                       bool L3SAM4, bool L3PEN4) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL4;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN4 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN4 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM4 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM4 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM4 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM4 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN4 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM4 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM4 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM4 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM4 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM4 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN4 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL4 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS4's L4DP4 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS4_L4DP4() volatile
    {
        return (MAC_LAYER4_ADDRESS4 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS4's L4DP4 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS4_L4DP4(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS4;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS4 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS4's L4SP4 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS4_L4SP4() volatile
    {
        return (MAC_LAYER4_ADDRESS4 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS4's L4SP4 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS4_L4SP4(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS4;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS4 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS4's bit fields.
     *
     * (read-write) Layer 4 Address 4
     */
    inline void get_MAC_LAYER4_ADDRESS4(uint16_t &L4DP4,
                                        uint16_t &L4SP4) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS4;

        L4DP4 = (curr >> 16u) & 0b1111111111111111u;
        L4SP4 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS4's bit fields.
     *
     * (read-write) Layer 4 Address 4
     */
    inline void set_MAC_LAYER4_ADDRESS4(uint16_t L4DP4,
                                        uint16_t L4SP4) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS4;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP4 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP4 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS4 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG4's L3A04 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG4_L3A04() volatile
    {
        return (MAC_LAYER3_ADDR0_REG4 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG4's L3A04 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG4_L3A04(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG4;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG4 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG4's L3A14 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG4_L3A14() volatile
    {
        return (MAC_LAYER3_ADDR1_REG4 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG4's L3A14 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG4_L3A14(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG4;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG4 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG4's L3A24 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG4_L3A24() volatile
    {
        return (MAC_LAYER3_ADDR2_REG4 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG4's L3A24 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG4_L3A24(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG4;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG4 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG4's L3A34 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG4_L3A34() volatile
    {
        return (MAC_LAYER3_ADDR3_REG4 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG4's L3A34 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG4_L3A34(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG4;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG4 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's DMCHEN5 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL5_DMCHEN5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's DMCHEN5 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL5_DMCHEN5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's DMCHEN5 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL5_DMCHEN5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's DMCHEN5 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_DMCHEN5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's DMCHN5 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL5_DMCHN5() volatile
    {
        return (MAC_L3_L4_CONTROL5 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL5's DMCHN5 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL5_DMCHN5(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL5;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL5 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L4DPIM5 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L4DPIM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L4DPIM5 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L4DPIM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L4DPIM5 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L4DPIM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L4DPIM5 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L4DPIM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L4DPM5 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L4DPM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L4DPM5 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L4DPM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L4DPM5 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L4DPM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L4DPM5 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L4DPM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L4SPIM5 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L4SPIM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L4SPIM5 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L4SPIM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L4SPIM5 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L4SPIM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L4SPIM5 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L4SPIM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L4SPM5 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L4SPM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L4SPM5 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L4SPM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L4SPM5 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L4SPM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L4SPM5 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L4SPM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L4PEN5 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L4PEN5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L4PEN5 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L4PEN5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L4PEN5 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L4PEN5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L4PEN5 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L4PEN5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3HDBM5 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL5_L3HDBM5() volatile
    {
        return (MAC_L3_L4_CONTROL5 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3HDBM5 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3HDBM5(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL5;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL5 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3HSBM5 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL5_L3HSBM5() volatile
    {
        return (MAC_L3_L4_CONTROL5 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3HSBM5 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3HSBM5(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL5;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL5 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3DAIM5 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L3DAIM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3DAIM5 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3DAIM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L3DAIM5 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L3DAIM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L3DAIM5 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L3DAIM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3DAM5 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L3DAM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3DAM5 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3DAM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L3DAM5 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L3DAM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L3DAM5 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L3DAM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3SAIM5 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L3SAIM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3SAIM5 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3SAIM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L3SAIM5 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L3SAIM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L3SAIM5 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L3SAIM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3SAM5 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L3SAM5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3SAM5 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3SAM5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L3SAM5 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L3SAM5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L3SAM5 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L3SAM5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL5's L3PEN5 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL5_L3PEN5() volatile
    {
        return MAC_L3_L4_CONTROL5 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL5's L3PEN5 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL5_L3PEN5() volatile
    {
        MAC_L3_L4_CONTROL5 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL5's L3PEN5 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL5_L3PEN5() volatile
    {
        MAC_L3_L4_CONTROL5 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL5's L3PEN5 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL5_L3PEN5() volatile
    {
        MAC_L3_L4_CONTROL5 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL5's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 5
     */
    inline void get_MAC_L3_L4_CONTROL5(bool &DMCHEN5, uint8_t &DMCHN5,
                                       bool &L4DPIM5, bool &L4DPM5,
                                       bool &L4SPIM5, bool &L4SPM5,
                                       bool &L4PEN5, uint8_t &L3HDBM5,
                                       uint8_t &L3HSBM5, bool &L3DAIM5,
                                       bool &L3DAM5, bool &L3SAIM5,
                                       bool &L3SAM5, bool &L3PEN5) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL5;

        DMCHEN5 = curr & (1u << 28u);
        DMCHN5 = (curr >> 24u) & 0b111u;
        L4DPIM5 = curr & (1u << 21u);
        L4DPM5 = curr & (1u << 20u);
        L4SPIM5 = curr & (1u << 19u);
        L4SPM5 = curr & (1u << 18u);
        L4PEN5 = curr & (1u << 16u);
        L3HDBM5 = (curr >> 11u) & 0b11111u;
        L3HSBM5 = (curr >> 6u) & 0b11111u;
        L3DAIM5 = curr & (1u << 5u);
        L3DAM5 = curr & (1u << 4u);
        L3SAIM5 = curr & (1u << 3u);
        L3SAM5 = curr & (1u << 2u);
        L3PEN5 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL5's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 5
     */
    inline void set_MAC_L3_L4_CONTROL5(bool DMCHEN5, uint8_t DMCHN5,
                                       bool L4DPIM5, bool L4DPM5, bool L4SPIM5,
                                       bool L4SPM5, bool L4PEN5,
                                       uint8_t L3HDBM5, uint8_t L3HSBM5,
                                       bool L3DAIM5, bool L3DAM5, bool L3SAIM5,
                                       bool L3SAM5, bool L3PEN5) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL5;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN5 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN5 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM5 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM5 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM5 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM5 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN5 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM5 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM5 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM5 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM5 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM5 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN5 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL5 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS5's L4DP5 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS5_L4DP5() volatile
    {
        return (MAC_LAYER4_ADDRESS5 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS5's L4DP5 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS5_L4DP5(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS5;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS5 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS5's L4SP5 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS5_L4SP5() volatile
    {
        return (MAC_LAYER4_ADDRESS5 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS5's L4SP5 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS5_L4SP5(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS5;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS5 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS5's bit fields.
     *
     * (read-write) Layer 4 Address 5
     */
    inline void get_MAC_LAYER4_ADDRESS5(uint16_t &L4DP5,
                                        uint16_t &L4SP5) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS5;

        L4DP5 = (curr >> 16u) & 0b1111111111111111u;
        L4SP5 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS5's bit fields.
     *
     * (read-write) Layer 4 Address 5
     */
    inline void set_MAC_LAYER4_ADDRESS5(uint16_t L4DP5,
                                        uint16_t L4SP5) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS5;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP5 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP5 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS5 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG5's L3A05 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG5_L3A05() volatile
    {
        return (MAC_LAYER3_ADDR0_REG5 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG5's L3A05 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG5_L3A05(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG5;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG5 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG5's L3A15 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG5_L3A15() volatile
    {
        return (MAC_LAYER3_ADDR1_REG5 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG5's L3A15 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG5_L3A15(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG5;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG5 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG5's L3A25 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG5_L3A25() volatile
    {
        return (MAC_LAYER3_ADDR2_REG5 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG5's L3A25 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG5_L3A25(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG5;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG5 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG5's L3A35 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG5_L3A35() volatile
    {
        return (MAC_LAYER3_ADDR3_REG5 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG5's L3A35 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG5_L3A35(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG5;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG5 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's DMCHEN6 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL6_DMCHEN6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's DMCHEN6 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL6_DMCHEN6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's DMCHEN6 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL6_DMCHEN6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's DMCHEN6 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_DMCHEN6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's DMCHN6 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL6_DMCHN6() volatile
    {
        return (MAC_L3_L4_CONTROL6 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL6's DMCHN6 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL6_DMCHN6(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL6;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL6 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L4DPIM6 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L4DPIM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L4DPIM6 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L4DPIM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L4DPIM6 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L4DPIM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L4DPIM6 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L4DPIM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L4DPM6 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L4DPM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L4DPM6 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L4DPM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L4DPM6 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L4DPM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L4DPM6 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L4DPM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L4SPIM6 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L4SPIM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L4SPIM6 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L4SPIM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L4SPIM6 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L4SPIM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L4SPIM6 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L4SPIM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L4SPM6 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L4SPM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L4SPM6 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L4SPM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L4SPM6 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L4SPM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L4SPM6 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L4SPM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L4PEN6 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L4PEN6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L4PEN6 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L4PEN6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L4PEN6 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L4PEN6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L4PEN6 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L4PEN6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3HDBM6 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL6_L3HDBM6() volatile
    {
        return (MAC_L3_L4_CONTROL6 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3HDBM6 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3HDBM6(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL6;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL6 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3HSBM6 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL6_L3HSBM6() volatile
    {
        return (MAC_L3_L4_CONTROL6 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3HSBM6 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3HSBM6(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL6;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL6 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3DAIM6 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L3DAIM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3DAIM6 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3DAIM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L3DAIM6 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L3DAIM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L3DAIM6 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L3DAIM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3DAM6 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L3DAM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3DAM6 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3DAM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L3DAM6 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L3DAM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L3DAM6 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L3DAM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3SAIM6 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L3SAIM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3SAIM6 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3SAIM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L3SAIM6 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L3SAIM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L3SAIM6 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L3SAIM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3SAM6 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L3SAM6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3SAM6 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3SAM6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L3SAM6 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L3SAM6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L3SAM6 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L3SAM6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL6's L3PEN6 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL6_L3PEN6() volatile
    {
        return MAC_L3_L4_CONTROL6 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL6's L3PEN6 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL6_L3PEN6() volatile
    {
        MAC_L3_L4_CONTROL6 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL6's L3PEN6 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL6_L3PEN6() volatile
    {
        MAC_L3_L4_CONTROL6 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL6's L3PEN6 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL6_L3PEN6() volatile
    {
        MAC_L3_L4_CONTROL6 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL6's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 6
     */
    inline void get_MAC_L3_L4_CONTROL6(bool &DMCHEN6, uint8_t &DMCHN6,
                                       bool &L4DPIM6, bool &L4DPM6,
                                       bool &L4SPIM6, bool &L4SPM6,
                                       bool &L4PEN6, uint8_t &L3HDBM6,
                                       uint8_t &L3HSBM6, bool &L3DAIM6,
                                       bool &L3DAM6, bool &L3SAIM6,
                                       bool &L3SAM6, bool &L3PEN6) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL6;

        DMCHEN6 = curr & (1u << 28u);
        DMCHN6 = (curr >> 24u) & 0b111u;
        L4DPIM6 = curr & (1u << 21u);
        L4DPM6 = curr & (1u << 20u);
        L4SPIM6 = curr & (1u << 19u);
        L4SPM6 = curr & (1u << 18u);
        L4PEN6 = curr & (1u << 16u);
        L3HDBM6 = (curr >> 11u) & 0b11111u;
        L3HSBM6 = (curr >> 6u) & 0b11111u;
        L3DAIM6 = curr & (1u << 5u);
        L3DAM6 = curr & (1u << 4u);
        L3SAIM6 = curr & (1u << 3u);
        L3SAM6 = curr & (1u << 2u);
        L3PEN6 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL6's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 6
     */
    inline void set_MAC_L3_L4_CONTROL6(bool DMCHEN6, uint8_t DMCHN6,
                                       bool L4DPIM6, bool L4DPM6, bool L4SPIM6,
                                       bool L4SPM6, bool L4PEN6,
                                       uint8_t L3HDBM6, uint8_t L3HSBM6,
                                       bool L3DAIM6, bool L3DAM6, bool L3SAIM6,
                                       bool L3SAM6, bool L3PEN6) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL6;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN6 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN6 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM6 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM6 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM6 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM6 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN6 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM6 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM6 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM6 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM6 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM6 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM6 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN6 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL6 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS6's L4DP6 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS6_L4DP6() volatile
    {
        return (MAC_LAYER4_ADDRESS6 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS6's L4DP6 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS6_L4DP6(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS6;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS6 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS6's L4SP6 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS6_L4SP6() volatile
    {
        return (MAC_LAYER4_ADDRESS6 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS6's L4SP6 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS6_L4SP6(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS6;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS6 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS6's bit fields.
     *
     * (read-write) Layer 4 Address 6
     */
    inline void get_MAC_LAYER4_ADDRESS6(uint16_t &L4DP6,
                                        uint16_t &L4SP6) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS6;

        L4DP6 = (curr >> 16u) & 0b1111111111111111u;
        L4SP6 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS6's bit fields.
     *
     * (read-write) Layer 4 Address 6
     */
    inline void set_MAC_LAYER4_ADDRESS6(uint16_t L4DP6,
                                        uint16_t L4SP6) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS6;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP6 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP6 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS6 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG6's L3A06 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG6_L3A06() volatile
    {
        return (MAC_LAYER3_ADDR0_REG6 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG6's L3A06 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG6_L3A06(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG6;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG6 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG6's L3A16 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG6_L3A16() volatile
    {
        return (MAC_LAYER3_ADDR1_REG6 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG6's L3A16 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG6_L3A16(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG6;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG6 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG6's L3A26 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG6_L3A26() volatile
    {
        return (MAC_LAYER3_ADDR2_REG6 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG6's L3A26 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG6_L3A26(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG6;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG6 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG6's L3A36 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG6_L3A36() volatile
    {
        return (MAC_LAYER3_ADDR3_REG6 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG6's L3A36 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG6_L3A36(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG6;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG6 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's DMCHEN7 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline bool get_MAC_L3_L4_CONTROL7_DMCHEN7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 28u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's DMCHEN7 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void set_MAC_L3_L4_CONTROL7_DMCHEN7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 28u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's DMCHEN7 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void clear_MAC_L3_L4_CONTROL7_DMCHEN7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's DMCHEN7 bit.
     *
     * DMA Channel Select Enable When set, this bit enables the selection of
     * the DMA channel number for the packet that is passed by this L3_L4
     * filter.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_DMCHEN7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 28u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's DMCHN7 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL7_DMCHN7() volatile
    {
        return (MAC_L3_L4_CONTROL7 >> 24u) & 0b111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL7's DMCHN7 field.
     *
     * DMA Channel Number When DMCHEN is set high, this field selects the DMA
     * Channel number to which the packet passed by this filter is routed.
     */
    inline void set_MAC_L3_L4_CONTROL7_DMCHN7(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL7;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MAC_L3_L4_CONTROL7 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L4DPIM7 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L4DPIM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 21u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L4DPIM7 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L4DPIM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 21u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L4DPIM7 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L4DPIM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 21u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L4DPIM7 bit.
     *
     * Layer 4 Destination Port Inverse Match Enable When this bit is set, the
     * Layer 4 Destination Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L4DPIM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 21u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L4DPM7 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L4DPM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 20u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L4DPM7 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L4DPM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 20u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L4DPM7 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L4DPM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L4DPM7 bit.
     *
     * Layer 4 Destination Port Match Enable When this bit is set, the Layer 4
     * Destination Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L4DPM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 20u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L4SPIM7 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L4SPIM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 19u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L4SPIM7 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L4SPIM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 19u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L4SPIM7 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L4SPIM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L4SPIM7 bit.
     *
     * Layer 4 Source Port Inverse Match Enable When this bit is set, the Layer
     * 4 Source Port number field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L4SPIM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 19u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L4SPM7 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L4SPM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 18u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L4SPM7 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L4SPM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 18u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L4SPM7 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L4SPM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L4SPM7 bit.
     *
     * Layer 4 Source Port Match Enable When this bit is set, the Layer 4
     * Source Port number field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L4SPM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 18u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L4PEN7 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L4PEN7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 16u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L4PEN7 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L4PEN7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 16u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L4PEN7 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L4PEN7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 16u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L4PEN7 bit.
     *
     * Layer 4 Protocol Enable When this bit is set, the Source and Destination
     * Port number fields of UDP packets are used for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L4PEN7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 16u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3HDBM7 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL7_L3HDBM7() volatile
    {
        return (MAC_L3_L4_CONTROL7 >> 11u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3HDBM7 field.
     *
     * Layer 3 IP DA Higher Bits Match IPv4 Packets: This field contains the
     * number of higher bits of IP Destination Address that are matched in the
     * IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3HDBM7(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL7;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        MAC_L3_L4_CONTROL7 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3HSBM7 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline uint8_t get_MAC_L3_L4_CONTROL7_L3HSBM7() volatile
    {
        return (MAC_L3_L4_CONTROL7 >> 6u) & 0b11111u;
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3HSBM7 field.
     *
     * Layer 3 IP SA Higher Bits Match IPv4 Packets: This field contains the
     * number of lower bits of IP Source Address that are masked for matching
     * in the IPv4 packets.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3HSBM7(uint8_t value) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL7;

        curr &= ~(0b11111u << 6u);
        curr |= (value & 0b11111u) << 6u;

        MAC_L3_L4_CONTROL7 = curr;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3DAIM7 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L3DAIM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 5u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3DAIM7 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3DAIM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 5u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L3DAIM7 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L3DAIM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L3DAIM7 bit.
     *
     * Layer 3 IP DA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L3DAIM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 5u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3DAM7 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L3DAM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 4u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3DAM7 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3DAM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 4u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L3DAM7 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L3DAM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L3DAM7 bit.
     *
     * Layer 3 IP DA Match Enable When this bit is set, the Layer 3 IP
     * Destination Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L3DAM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 4u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3SAIM7 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L3SAIM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 3u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3SAIM7 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3SAIM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 3u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L3SAIM7 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L3SAIM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L3SAIM7 bit.
     *
     * Layer 3 IP SA Inverse Match Enable When this bit is set, the Layer 3 IP
     * Source Address field is enabled for inverse matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L3SAIM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 3u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3SAM7 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L3SAM7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 2u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3SAM7 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3SAM7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 2u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L3SAM7 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L3SAM7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L3SAM7 bit.
     *
     * Layer 3 IP SA Match Enable When this bit is set, the Layer 3 IP Source
     * Address field is enabled for matching.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L3SAM7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 2u;
    }

    /**
     * Get MAC_L3_L4_CONTROL7's L3PEN7 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline bool get_MAC_L3_L4_CONTROL7_L3PEN7() volatile
    {
        return MAC_L3_L4_CONTROL7 & (1u << 0u);
    }

    /**
     * Set MAC_L3_L4_CONTROL7's L3PEN7 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void set_MAC_L3_L4_CONTROL7_L3PEN7() volatile
    {
        MAC_L3_L4_CONTROL7 |= 1u << 0u;
    }

    /**
     * Clear MAC_L3_L4_CONTROL7's L3PEN7 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void clear_MAC_L3_L4_CONTROL7_L3PEN7() volatile
    {
        MAC_L3_L4_CONTROL7 &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_L3_L4_CONTROL7's L3PEN7 bit.
     *
     * Layer 3 Protocol Enable When this bit is set, the Layer 3 IP Source or
     * Destination Address matching is enabled for IPv6 packets.
     */
    inline void toggle_MAC_L3_L4_CONTROL7_L3PEN7() volatile
    {
        MAC_L3_L4_CONTROL7 ^= 1u << 0u;
    }

    /**
     * Get all of MAC_L3_L4_CONTROL7's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 0
     */
    inline void get_MAC_L3_L4_CONTROL7(bool &DMCHEN7, uint8_t &DMCHN7,
                                       bool &L4DPIM7, bool &L4DPM7,
                                       bool &L4SPIM7, bool &L4SPM7,
                                       bool &L4PEN7, uint8_t &L3HDBM7,
                                       uint8_t &L3HSBM7, bool &L3DAIM7,
                                       bool &L3DAM7, bool &L3SAIM7,
                                       bool &L3SAM7, bool &L3PEN7) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL7;

        DMCHEN7 = curr & (1u << 28u);
        DMCHN7 = (curr >> 24u) & 0b111u;
        L4DPIM7 = curr & (1u << 21u);
        L4DPM7 = curr & (1u << 20u);
        L4SPIM7 = curr & (1u << 19u);
        L4SPM7 = curr & (1u << 18u);
        L4PEN7 = curr & (1u << 16u);
        L3HDBM7 = (curr >> 11u) & 0b11111u;
        L3HSBM7 = (curr >> 6u) & 0b11111u;
        L3DAIM7 = curr & (1u << 5u);
        L3DAM7 = curr & (1u << 4u);
        L3SAIM7 = curr & (1u << 3u);
        L3SAM7 = curr & (1u << 2u);
        L3PEN7 = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_L3_L4_CONTROL7's bit fields.
     *
     * (read-write) Layer 3 and Layer 4 Control of Filter 0
     */
    inline void set_MAC_L3_L4_CONTROL7(bool DMCHEN7, uint8_t DMCHN7,
                                       bool L4DPIM7, bool L4DPM7, bool L4SPIM7,
                                       bool L4SPM7, bool L4PEN7,
                                       uint8_t L3HDBM7, uint8_t L3HSBM7,
                                       bool L3DAIM7, bool L3DAM7, bool L3SAIM7,
                                       bool L3SAM7, bool L3PEN7) volatile
    {
        uint32_t curr = MAC_L3_L4_CONTROL7;

        curr &= ~(0b1u << 28u);
        curr |= (DMCHEN7 & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (DMCHN7 & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (L4DPIM7 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (L4DPM7 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (L4SPIM7 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (L4SPM7 & 0b1u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (L4PEN7 & 0b1u) << 16u;
        curr &= ~(0b11111u << 11u);
        curr |= (L3HDBM7 & 0b11111u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (L3HSBM7 & 0b11111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (L3DAIM7 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (L3DAM7 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (L3SAIM7 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (L3SAM7 & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (L3PEN7 & 0b1u) << 0u;

        MAC_L3_L4_CONTROL7 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS7's L4DP7 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS7_L4DP7() volatile
    {
        return (MAC_LAYER4_ADDRESS7 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS7's L4DP7 field.
     *
     * Layer 4 Destination Port Number Field When the L4PEN0 bit is reset and
     * the L4DPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Destination Port Number
     * field in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS7_L4DP7(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS7;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MAC_LAYER4_ADDRESS7 = curr;
    }

    /**
     * Get MAC_LAYER4_ADDRESS7's L4SP7 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline uint16_t get_MAC_LAYER4_ADDRESS7_L4SP7() volatile
    {
        return (MAC_LAYER4_ADDRESS7 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_LAYER4_ADDRESS7's L4SP7 field.
     *
     * Layer 4 Source Port Number Field When the L4PEN0 bit is reset and the
     * L4SPM0 bit is set in the MAC_L3_L4_CONTROL0 register, this field
     * contains the value to be matched with the TCP Source Port Number field
     * in the IPv4 or IPv6 packets.
     */
    inline void set_MAC_LAYER4_ADDRESS7_L4SP7(uint16_t value) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS7;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS7 = curr;
    }

    /**
     * Get all of MAC_LAYER4_ADDRESS7's bit fields.
     *
     * (read-write) Layer 4 Address 7
     */
    inline void get_MAC_LAYER4_ADDRESS7(uint16_t &L4DP7,
                                        uint16_t &L4SP7) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS7;

        L4DP7 = (curr >> 16u) & 0b1111111111111111u;
        L4SP7 = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MAC_LAYER4_ADDRESS7's bit fields.
     *
     * (read-write) Layer 4 Address 7
     */
    inline void set_MAC_LAYER4_ADDRESS7(uint16_t L4DP7,
                                        uint16_t L4SP7) volatile
    {
        uint32_t curr = MAC_LAYER4_ADDRESS7;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (L4DP7 & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (L4SP7 & 0b1111111111111111u) << 0u;

        MAC_LAYER4_ADDRESS7 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR0_REG7's L3A07 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR0_REG7_L3A07() volatile
    {
        return (MAC_LAYER3_ADDR0_REG7 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR0_REG7's L3A07 field.
     *
     * Layer 3 Address 0 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[31:0] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR0_REG7_L3A07(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR0_REG7;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR0_REG7 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR1_REG7's L3A17 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR1_REG7_L3A17() volatile
    {
        return (MAC_LAYER3_ADDR1_REG7 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR1_REG7's L3A17 field.
     *
     * Layer 3 Address 1 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[63:32] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR1_REG7_L3A17(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR1_REG7;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR1_REG7 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR2_REG7's L3A27 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR2_REG7_L3A27() volatile
    {
        return (MAC_LAYER3_ADDR2_REG7 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR2_REG7's L3A27 field.
     *
     * Layer 3 Address 2 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[95:64] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR2_REG7_L3A27(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR2_REG7;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR2_REG7 = curr;
    }

    /**
     * Get MAC_LAYER3_ADDR3_REG7's L3A37 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline uint32_t get_MAC_LAYER3_ADDR3_REG7_L3A37() volatile
    {
        return (MAC_LAYER3_ADDR3_REG7 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_LAYER3_ADDR3_REG7's L3A37 field.
     *
     * Layer 3 Address 3 Field When the L3PEN0 and L3SAM0 bits are set in the
     * MAC_L3_L4_CONTROL0 register, this field contains the value to be matched
     * with Bits[127:96] of the IP Source Address field in the IPv6 packets.
     */
    inline void set_MAC_LAYER3_ADDR3_REG7_L3A37(uint32_t value) volatile
    {
        uint32_t curr = MAC_LAYER3_ADDR3_REG7;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_LAYER3_ADDR3_REG7 = curr;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's AV8021ASMEN bit.
     *
     * AV 802.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_AV8021ASMEN() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 28u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's AV8021ASMEN bit.
     *
     * AV 802.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_AV8021ASMEN() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 28u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's AV8021ASMEN bit.
     *
     * AV 802.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_AV8021ASMEN() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's AV8021ASMEN bit.
     *
     * AV 802.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_AV8021ASMEN() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 28u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TXTSSTSM bit.
     *
     * Transmit Timestamp Status Mode When this bit is set, the MAC overwrites
     * the earlier transmit timestamp status even if it is not read by the
     * software.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TXTSSTSM() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 24u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TXTSSTSM bit.
     *
     * Transmit Timestamp Status Mode When this bit is set, the MAC overwrites
     * the earlier transmit timestamp status even if it is not read by the
     * software.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TXTSSTSM() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 24u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TXTSSTSM bit.
     *
     * Transmit Timestamp Status Mode When this bit is set, the MAC overwrites
     * the earlier transmit timestamp status even if it is not read by the
     * software.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TXTSSTSM() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 24u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TXTSSTSM bit.
     *
     * Transmit Timestamp Status Mode When this bit is set, the MAC overwrites
     * the earlier transmit timestamp status even if it is not read by the
     * software.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TXTSSTSM() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 24u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's ESTI bit.
     *
     * External System Time Input When this bit is set, the MAC uses the
     * external 64-bit reference System Time input for the following: - To take
     * the timestamp provided as status - To insert the timestamp in transmit
     * PTP packets when One-step Timestamp or Timestamp Offload feature is
     * enabled.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_ESTI() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 20u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's ESTI bit.
     *
     * External System Time Input When this bit is set, the MAC uses the
     * external 64-bit reference System Time input for the following: - To take
     * the timestamp provided as status - To insert the timestamp in transmit
     * PTP packets when One-step Timestamp or Timestamp Offload feature is
     * enabled.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_ESTI() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 20u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's ESTI bit.
     *
     * External System Time Input When this bit is set, the MAC uses the
     * external 64-bit reference System Time input for the following: - To take
     * the timestamp provided as status - To insert the timestamp in transmit
     * PTP packets when One-step Timestamp or Timestamp Offload feature is
     * enabled.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_ESTI() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 20u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's ESTI bit.
     *
     * External System Time Input When this bit is set, the MAC uses the
     * external 64-bit reference System Time input for the following: - To take
     * the timestamp provided as status - To insert the timestamp in transmit
     * PTP packets when One-step Timestamp or Timestamp Offload feature is
     * enabled.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_ESTI() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 20u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's CSC bit.
     *
     * Enable checksum correction during OST for PTP over UDP/IPv4 packets When
     * this bit is set, the last two bytes of PTP message sent over UDP/IPv4 is
     * updated to keep the UDP checksum correct, for changes made to origin
     * timestamp and/or correction field as part of one step timestamp
     * operation.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_CSC() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 19u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's CSC bit.
     *
     * Enable checksum correction during OST for PTP over UDP/IPv4 packets When
     * this bit is set, the last two bytes of PTP message sent over UDP/IPv4 is
     * updated to keep the UDP checksum correct, for changes made to origin
     * timestamp and/or correction field as part of one step timestamp
     * operation.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_CSC() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 19u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's CSC bit.
     *
     * Enable checksum correction during OST for PTP over UDP/IPv4 packets When
     * this bit is set, the last two bytes of PTP message sent over UDP/IPv4 is
     * updated to keep the UDP checksum correct, for changes made to origin
     * timestamp and/or correction field as part of one step timestamp
     * operation.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_CSC() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 19u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's CSC bit.
     *
     * Enable checksum correction during OST for PTP over UDP/IPv4 packets When
     * this bit is set, the last two bytes of PTP message sent over UDP/IPv4 is
     * updated to keep the UDP checksum correct, for changes made to origin
     * timestamp and/or correction field as part of one step timestamp
     * operation.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_CSC() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 19u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSENMACADDR bit.
     *
     * Enable MAC Address for PTP Packet Filtering When this bit is set, the DA
     * MAC address (that matches any MAC Address register) is used to filter
     * the PTP packets when PTP is directly sent over Ethernet.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSENMACADDR() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 18u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSENMACADDR bit.
     *
     * Enable MAC Address for PTP Packet Filtering When this bit is set, the DA
     * MAC address (that matches any MAC Address register) is used to filter
     * the PTP packets when PTP is directly sent over Ethernet.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSENMACADDR() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 18u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSENMACADDR bit.
     *
     * Enable MAC Address for PTP Packet Filtering When this bit is set, the DA
     * MAC address (that matches any MAC Address register) is used to filter
     * the PTP packets when PTP is directly sent over Ethernet.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSENMACADDR() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 18u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSENMACADDR bit.
     *
     * Enable MAC Address for PTP Packet Filtering When this bit is set, the DA
     * MAC address (that matches any MAC Address register) is used to filter
     * the PTP packets when PTP is directly sent over Ethernet.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSENMACADDR() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 18u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's SNAPTYPSEL field.
     *
     * Select PTP packets for Taking Snapshots These bits, along with Bits 15
     * and 14, decide the set of PTP packet types for which snapshot needs to
     * be taken.
     */
    inline uint8_t get_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL() volatile
    {
        return (MAC_TIMESTAMP_CONTROL >> 16u) & 0b11u;
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's SNAPTYPSEL field.
     *
     * Select PTP packets for Taking Snapshots These bits, along with Bits 15
     * and 14, decide the set of PTP packet types for which snapshot needs to
     * be taken.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL(uint8_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_CONTROL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        MAC_TIMESTAMP_CONTROL = curr;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSMSTRENA bit.
     *
     * Enable Snapshot for Messages Relevant to Master When this bit is set,
     * the snapshot is taken only for the messages that are relevant to the
     * master node.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSMSTRENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 15u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSMSTRENA bit.
     *
     * Enable Snapshot for Messages Relevant to Master When this bit is set,
     * the snapshot is taken only for the messages that are relevant to the
     * master node.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSMSTRENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 15u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSMSTRENA bit.
     *
     * Enable Snapshot for Messages Relevant to Master When this bit is set,
     * the snapshot is taken only for the messages that are relevant to the
     * master node.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSMSTRENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSMSTRENA bit.
     *
     * Enable Snapshot for Messages Relevant to Master When this bit is set,
     * the snapshot is taken only for the messages that are relevant to the
     * master node.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSMSTRENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 15u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSEVNTENA bit.
     *
     * Enable Timestamp Snapshot for Event Messages When this bit is set, the
     * timestamp snapshot is taken only for event messages (SYNC, Delay_Req,
     * Pdelay_Req, or Pdelay_Resp).
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSEVNTENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 14u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSEVNTENA bit.
     *
     * Enable Timestamp Snapshot for Event Messages When this bit is set, the
     * timestamp snapshot is taken only for event messages (SYNC, Delay_Req,
     * Pdelay_Req, or Pdelay_Resp).
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSEVNTENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 14u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSEVNTENA bit.
     *
     * Enable Timestamp Snapshot for Event Messages When this bit is set, the
     * timestamp snapshot is taken only for event messages (SYNC, Delay_Req,
     * Pdelay_Req, or Pdelay_Resp).
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSEVNTENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSEVNTENA bit.
     *
     * Enable Timestamp Snapshot for Event Messages When this bit is set, the
     * timestamp snapshot is taken only for event messages (SYNC, Delay_Req,
     * Pdelay_Req, or Pdelay_Resp).
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSEVNTENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 14u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSIPV4ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv4-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP
     * packets.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSIPV4ENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 13u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSIPV4ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv4-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP
     * packets.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSIPV4ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 13u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSIPV4ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv4-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP
     * packets.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSIPV4ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSIPV4ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv4-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP
     * packets.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSIPV4ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 13u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSIPV6ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv6-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP
     * packets.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSIPV6ENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 12u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSIPV6ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv6-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP
     * packets.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSIPV6ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 12u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSIPV6ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv6-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP
     * packets.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSIPV6ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSIPV6ENA bit.
     *
     * Enable Processing of PTP Packets Sent over IPv6-UDP When this bit is
     * set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP
     * packets.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSIPV6ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 12u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSIPENA bit.
     *
     * Enable Processing of PTP over Ethernet Packets When this bit is set, the
     * MAC receiver processes the PTP packets encapsulated directly in the
     * Ethernet packets.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSIPENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 11u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSIPENA bit.
     *
     * Enable Processing of PTP over Ethernet Packets When this bit is set, the
     * MAC receiver processes the PTP packets encapsulated directly in the
     * Ethernet packets.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSIPENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 11u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSIPENA bit.
     *
     * Enable Processing of PTP over Ethernet Packets When this bit is set, the
     * MAC receiver processes the PTP packets encapsulated directly in the
     * Ethernet packets.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSIPENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSIPENA bit.
     *
     * Enable Processing of PTP over Ethernet Packets When this bit is set, the
     * MAC receiver processes the PTP packets encapsulated directly in the
     * Ethernet packets.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSIPENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 11u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSVER2ENA bit.
     *
     * Enable PTP Packet Processing for Version 2 Format When this bit is set,
     * the IEEE 1588 version 2 format is used to process the PTP packets.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSVER2ENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 10u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSVER2ENA bit.
     *
     * Enable PTP Packet Processing for Version 2 Format When this bit is set,
     * the IEEE 1588 version 2 format is used to process the PTP packets.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSVER2ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 10u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSVER2ENA bit.
     *
     * Enable PTP Packet Processing for Version 2 Format When this bit is set,
     * the IEEE 1588 version 2 format is used to process the PTP packets.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSVER2ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSVER2ENA bit.
     *
     * Enable PTP Packet Processing for Version 2 Format When this bit is set,
     * the IEEE 1588 version 2 format is used to process the PTP packets.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSVER2ENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 10u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSCTRLSSR bit.
     *
     * Timestamp Digital or Binary Rollover Control When this bit is set, the
     * Timestamp Low register rolls over after 0x3B9A_C9FF value (that is, 1
     * nanosecond accuracy) and increments the timestamp (High) seconds.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSCTRLSSR() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 9u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSCTRLSSR bit.
     *
     * Timestamp Digital or Binary Rollover Control When this bit is set, the
     * Timestamp Low register rolls over after 0x3B9A_C9FF value (that is, 1
     * nanosecond accuracy) and increments the timestamp (High) seconds.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSCTRLSSR() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 9u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSCTRLSSR bit.
     *
     * Timestamp Digital or Binary Rollover Control When this bit is set, the
     * Timestamp Low register rolls over after 0x3B9A_C9FF value (that is, 1
     * nanosecond accuracy) and increments the timestamp (High) seconds.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSCTRLSSR() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 9u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSCTRLSSR bit.
     *
     * Timestamp Digital or Binary Rollover Control When this bit is set, the
     * Timestamp Low register rolls over after 0x3B9A_C9FF value (that is, 1
     * nanosecond accuracy) and increments the timestamp (High) seconds.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSCTRLSSR() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 9u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSENALL bit.
     *
     * Enable Timestamp for All Packets When this bit is set, the timestamp
     * snapshot is enabled for all packets received by the MAC.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSENALL() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 8u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSENALL bit.
     *
     * Enable Timestamp for All Packets When this bit is set, the timestamp
     * snapshot is enabled for all packets received by the MAC.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSENALL() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 8u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSENALL bit.
     *
     * Enable Timestamp for All Packets When this bit is set, the timestamp
     * snapshot is enabled for all packets received by the MAC.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSENALL() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 8u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSENALL bit.
     *
     * Enable Timestamp for All Packets When this bit is set, the timestamp
     * snapshot is enabled for all packets received by the MAC.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSENALL() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 8u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's PTGE bit.
     *
     * Presentation Time Generation Enable When this bit is set the
     * Presentation Time generation will be enabled.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_PTGE() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 6u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's PTGE bit.
     *
     * Presentation Time Generation Enable When this bit is set the
     * Presentation Time generation will be enabled.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_PTGE() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 6u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's PTGE bit.
     *
     * Presentation Time Generation Enable When this bit is set the
     * Presentation Time generation will be enabled.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_PTGE() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 6u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's PTGE bit.
     *
     * Presentation Time Generation Enable When this bit is set the
     * Presentation Time generation will be enabled.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_PTGE() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 6u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSADDREG bit.
     *
     * Update Addend Register When this bit is set, the content of the
     * Timestamp Addend register is updated in the PTP block for fine
     * correction.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSADDREG() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 5u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSADDREG bit.
     *
     * Update Addend Register When this bit is set, the content of the
     * Timestamp Addend register is updated in the PTP block for fine
     * correction.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSADDREG() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 5u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSADDREG bit.
     *
     * Update Addend Register When this bit is set, the content of the
     * Timestamp Addend register is updated in the PTP block for fine
     * correction.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSADDREG() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSADDREG bit.
     *
     * Update Addend Register When this bit is set, the content of the
     * Timestamp Addend register is updated in the PTP block for fine
     * correction.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSADDREG() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 5u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSUPDT bit.
     *
     * Update Timestamp When this bit is set, the system time is updated (added
     * or subtracted) with the value specified in
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSUPDT() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 3u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSUPDT bit.
     *
     * Update Timestamp When this bit is set, the system time is updated (added
     * or subtracted) with the value specified in
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSUPDT() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSUPDT bit.
     *
     * Update Timestamp When this bit is set, the system time is updated (added
     * or subtracted) with the value specified in
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSUPDT() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSUPDT bit.
     *
     * Update Timestamp When this bit is set, the system time is updated (added
     * or subtracted) with the value specified in
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSUPDT() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSINIT bit.
     *
     * Initialize Timestamp When this bit is set, the system time is
     * initialized (overwritten) with the value specified in the
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSINIT() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 2u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSINIT bit.
     *
     * Initialize Timestamp When this bit is set, the system time is
     * initialized (overwritten) with the value specified in the
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSINIT() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSINIT bit.
     *
     * Initialize Timestamp When this bit is set, the system time is
     * initialized (overwritten) with the value specified in the
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSINIT() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSINIT bit.
     *
     * Initialize Timestamp When this bit is set, the system time is
     * initialized (overwritten) with the value specified in the
     * MAC_System_Time_Seconds_Update and MAC_System_Time_Nanoseconds_Update
     * registers.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSINIT() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 2u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSCFUPDT bit.
     *
     * Fine or Coarse Timestamp Update When this bit is set, the Fine method is
     * used to update system timestamp.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSCFUPDT() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 1u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSCFUPDT bit.
     *
     * Fine or Coarse Timestamp Update When this bit is set, the Fine method is
     * used to update system timestamp.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSCFUPDT() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 1u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSCFUPDT bit.
     *
     * Fine or Coarse Timestamp Update When this bit is set, the Fine method is
     * used to update system timestamp.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSCFUPDT() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSCFUPDT bit.
     *
     * Fine or Coarse Timestamp Update When this bit is set, the Fine method is
     * used to update system timestamp.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSCFUPDT() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 1u;
    }

    /**
     * Get MAC_TIMESTAMP_CONTROL's TSENA bit.
     *
     * Enable Timestamp When this bit is set, the timestamp is added for
     * Transmit and Receive packets.
     */
    inline bool get_MAC_TIMESTAMP_CONTROL_TSENA() volatile
    {
        return MAC_TIMESTAMP_CONTROL & (1u << 0u);
    }

    /**
     * Set MAC_TIMESTAMP_CONTROL's TSENA bit.
     *
     * Enable Timestamp When this bit is set, the timestamp is added for
     * Transmit and Receive packets.
     */
    inline void set_MAC_TIMESTAMP_CONTROL_TSENA() volatile
    {
        MAC_TIMESTAMP_CONTROL |= 1u << 0u;
    }

    /**
     * Clear MAC_TIMESTAMP_CONTROL's TSENA bit.
     *
     * Enable Timestamp When this bit is set, the timestamp is added for
     * Transmit and Receive packets.
     */
    inline void clear_MAC_TIMESTAMP_CONTROL_TSENA() volatile
    {
        MAC_TIMESTAMP_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_TIMESTAMP_CONTROL's TSENA bit.
     *
     * Enable Timestamp When this bit is set, the timestamp is added for
     * Transmit and Receive packets.
     */
    inline void toggle_MAC_TIMESTAMP_CONTROL_TSENA() volatile
    {
        MAC_TIMESTAMP_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_TIMESTAMP_CONTROL's bit fields.
     *
     * (read-write) Timestamp Control
     */
    inline void get_MAC_TIMESTAMP_CONTROL(
        bool &AV8021ASMEN, bool &TXTSSTSM, bool &ESTI, bool &CSC,
        bool &TSENMACADDR, uint8_t &SNAPTYPSEL, bool &TSMSTRENA,
        bool &TSEVNTENA, bool &TSIPV4ENA, bool &TSIPV6ENA, bool &TSIPENA,
        bool &TSVER2ENA, bool &TSCTRLSSR, bool &TSENALL, bool &PTGE,
        bool &TSADDREG, bool &TSUPDT, bool &TSINIT, bool &TSCFUPDT,
        bool &TSENA) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_CONTROL;

        AV8021ASMEN = curr & (1u << 28u);
        TXTSSTSM = curr & (1u << 24u);
        ESTI = curr & (1u << 20u);
        CSC = curr & (1u << 19u);
        TSENMACADDR = curr & (1u << 18u);
        SNAPTYPSEL = (curr >> 16u) & 0b11u;
        TSMSTRENA = curr & (1u << 15u);
        TSEVNTENA = curr & (1u << 14u);
        TSIPV4ENA = curr & (1u << 13u);
        TSIPV6ENA = curr & (1u << 12u);
        TSIPENA = curr & (1u << 11u);
        TSVER2ENA = curr & (1u << 10u);
        TSCTRLSSR = curr & (1u << 9u);
        TSENALL = curr & (1u << 8u);
        PTGE = curr & (1u << 6u);
        TSADDREG = curr & (1u << 5u);
        TSUPDT = curr & (1u << 3u);
        TSINIT = curr & (1u << 2u);
        TSCFUPDT = curr & (1u << 1u);
        TSENA = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_TIMESTAMP_CONTROL's bit fields.
     *
     * (read-write) Timestamp Control
     */
    inline void set_MAC_TIMESTAMP_CONTROL(
        bool AV8021ASMEN, bool TXTSSTSM, bool ESTI, bool CSC, bool TSENMACADDR,
        uint8_t SNAPTYPSEL, bool TSMSTRENA, bool TSEVNTENA, bool TSIPV4ENA,
        bool TSIPV6ENA, bool TSIPENA, bool TSVER2ENA, bool TSCTRLSSR,
        bool TSENALL, bool PTGE, bool TSADDREG, bool TSUPDT, bool TSINIT,
        bool TSCFUPDT, bool TSENA) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_CONTROL;

        curr &= ~(0b1u << 28u);
        curr |= (AV8021ASMEN & 0b1u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (TXTSSTSM & 0b1u) << 24u;
        curr &= ~(0b1u << 20u);
        curr |= (ESTI & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CSC & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (TSENMACADDR & 0b1u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (SNAPTYPSEL & 0b11u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TSMSTRENA & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TSEVNTENA & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TSIPV4ENA & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TSIPV6ENA & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TSIPENA & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TSVER2ENA & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (TSCTRLSSR & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TSENALL & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (PTGE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TSADDREG & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (TSUPDT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TSINIT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSCFUPDT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TSENA & 0b1u) << 0u;

        MAC_TIMESTAMP_CONTROL = curr;
    }

    /**
     * Get MAC_SUB_SECOND_INCREMENT's SSINC field.
     *
     * Sub-second Increment Value The value programmed in this field is
     * accumulated every clock cycle (of clk_ptp_i) with the contents of the
     * sub-second register.
     */
    inline uint8_t get_MAC_SUB_SECOND_INCREMENT_SSINC() volatile
    {
        return (MAC_SUB_SECOND_INCREMENT >> 16u) & 0b11111111u;
    }

    /**
     * Set MAC_SUB_SECOND_INCREMENT's SSINC field.
     *
     * Sub-second Increment Value The value programmed in this field is
     * accumulated every clock cycle (of clk_ptp_i) with the contents of the
     * sub-second register.
     */
    inline void set_MAC_SUB_SECOND_INCREMENT_SSINC(uint8_t value) volatile
    {
        uint32_t curr = MAC_SUB_SECOND_INCREMENT;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MAC_SUB_SECOND_INCREMENT = curr;
    }

    /**
     * Get MAC_SUB_SECOND_INCREMENT's SNSINC field.
     *
     * Sub-nanosecond Increment Value This field contains the sub-nanosecond
     * increment value, represented in nanoseconds multiplied by 2^8.
     */
    inline uint8_t get_MAC_SUB_SECOND_INCREMENT_SNSINC() volatile
    {
        return (MAC_SUB_SECOND_INCREMENT >> 8u) & 0b11111111u;
    }

    /**
     * Set MAC_SUB_SECOND_INCREMENT's SNSINC field.
     *
     * Sub-nanosecond Increment Value This field contains the sub-nanosecond
     * increment value, represented in nanoseconds multiplied by 2^8.
     */
    inline void set_MAC_SUB_SECOND_INCREMENT_SNSINC(uint8_t value) volatile
    {
        uint32_t curr = MAC_SUB_SECOND_INCREMENT;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MAC_SUB_SECOND_INCREMENT = curr;
    }

    /**
     * Get all of MAC_SUB_SECOND_INCREMENT's bit fields.
     *
     * (read-write) Subsecond Increment
     */
    inline void get_MAC_SUB_SECOND_INCREMENT(uint8_t &SSINC,
                                             uint8_t &SNSINC) volatile
    {
        uint32_t curr = MAC_SUB_SECOND_INCREMENT;

        SSINC = (curr >> 16u) & 0b11111111u;
        SNSINC = (curr >> 8u) & 0b11111111u;
    }

    /**
     * Set all of MAC_SUB_SECOND_INCREMENT's bit fields.
     *
     * (read-write) Subsecond Increment
     */
    inline void set_MAC_SUB_SECOND_INCREMENT(uint8_t SSINC,
                                             uint8_t SNSINC) volatile
    {
        uint32_t curr = MAC_SUB_SECOND_INCREMENT;

        curr &= ~(0b11111111u << 16u);
        curr |= (SSINC & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (SNSINC & 0b11111111u) << 8u;

        MAC_SUB_SECOND_INCREMENT = curr;
    }

    /**
     * Get MAC_SYSTEM_TIME_SECONDS's TSS field.
     *
     * Timestamp Second The value in this field indicates the current value in
     * seconds of the System Time maintained by the MAC.
     */
    inline uint32_t get_MAC_SYSTEM_TIME_SECONDS_TSS() volatile
    {
        return (MAC_SYSTEM_TIME_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_SYSTEM_TIME_NANOSECONDS's TSSS field.
     *
     * Timestamp Sub Seconds The value in this field has the sub-second
     * representation of time, with an accuracy of 0.
     */
    inline uint32_t get_MAC_SYSTEM_TIME_NANOSECONDS_TSSS() volatile
    {
        return (MAC_SYSTEM_TIME_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get MAC_SYSTEM_TIME_SECONDS_UPDATE's TSS field.
     *
     * Timestamp Seconds The value in this field is the seconds part of the
     * update.
     */
    inline uint32_t get_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS() volatile
    {
        return (MAC_SYSTEM_TIME_SECONDS_UPDATE >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_SYSTEM_TIME_SECONDS_UPDATE's TSS field.
     *
     * Timestamp Seconds The value in this field is the seconds part of the
     * update.
     */
    inline void set_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS(uint32_t value) volatile
    {
        uint32_t curr = MAC_SYSTEM_TIME_SECONDS_UPDATE;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_SYSTEM_TIME_SECONDS_UPDATE = curr;
    }

    /**
     * Get MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's ADDSUB bit.
     *
     * Add or Subtract Time When this bit is set, the time value is subtracted
     * with the contents of the update register.
     */
    inline bool get_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB() volatile
    {
        return MAC_SYSTEM_TIME_NANOSECONDS_UPDATE & (1u << 31u);
    }

    /**
     * Set MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's ADDSUB bit.
     *
     * Add or Subtract Time When this bit is set, the time value is subtracted
     * with the contents of the update register.
     */
    inline void set_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB() volatile
    {
        MAC_SYSTEM_TIME_NANOSECONDS_UPDATE |= 1u << 31u;
    }

    /**
     * Clear MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's ADDSUB bit.
     *
     * Add or Subtract Time When this bit is set, the time value is subtracted
     * with the contents of the update register.
     */
    inline void clear_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB() volatile
    {
        MAC_SYSTEM_TIME_NANOSECONDS_UPDATE &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's ADDSUB bit.
     *
     * Add or Subtract Time When this bit is set, the time value is subtracted
     * with the contents of the update register.
     */
    inline void toggle_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB() volatile
    {
        MAC_SYSTEM_TIME_NANOSECONDS_UPDATE ^= 1u << 31u;
    }

    /**
     * Get MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's TSSS field.
     *
     * Timestamp Sub Seconds The value in this field is the sub-seconds part of
     * the update.
     */
    inline uint32_t get_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS() volatile
    {
        return (MAC_SYSTEM_TIME_NANOSECONDS_UPDATE >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Set MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's TSSS field.
     *
     * Timestamp Sub Seconds The value in this field is the sub-seconds part of
     * the update.
     */
    inline void set_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_SYSTEM_TIME_NANOSECONDS_UPDATE;

        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111111111u) << 0u;

        MAC_SYSTEM_TIME_NANOSECONDS_UPDATE = curr;
    }

    /**
     * Get all of MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's bit fields.
     *
     * (read-write) System Time Nanoseconds Update
     */
    inline void get_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE(bool &ADDSUB,
                                                       uint32_t &TSSS) volatile
    {
        uint32_t curr = MAC_SYSTEM_TIME_NANOSECONDS_UPDATE;

        ADDSUB = curr & (1u << 31u);
        TSSS = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Set all of MAC_SYSTEM_TIME_NANOSECONDS_UPDATE's bit fields.
     *
     * (read-write) System Time Nanoseconds Update
     */
    inline void set_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE(bool ADDSUB,
                                                       uint32_t TSSS) volatile
    {
        uint32_t curr = MAC_SYSTEM_TIME_NANOSECONDS_UPDATE;

        curr &= ~(0b1u << 31u);
        curr |= (ADDSUB & 0b1u) << 31u;
        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (TSSS & 0b1111111111111111111111111111111u) << 0u;

        MAC_SYSTEM_TIME_NANOSECONDS_UPDATE = curr;
    }

    /**
     * Get MAC_TIMESTAMP_ADDEND's TSAR field.
     *
     * Timestamp Addend Register This field indicates the 32-bit time value to
     * be added to the Accumulator register to achieve time synchronization.
     */
    inline uint32_t get_MAC_TIMESTAMP_ADDEND_TSAR() volatile
    {
        return (MAC_TIMESTAMP_ADDEND >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_TIMESTAMP_ADDEND's TSAR field.
     *
     * Timestamp Addend Register This field indicates the 32-bit time value to
     * be added to the Accumulator register to achieve time synchronization.
     */
    inline void set_MAC_TIMESTAMP_ADDEND_TSAR(uint32_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_ADDEND;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_TIMESTAMP_ADDEND = curr;
    }

    /**
     * Get MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS's TSHWR field.
     *
     * Timestamp Higher Word Register This field contains the most-significant
     * 16-bits of timestamp seconds value.
     */
    inline uint16_t get_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR() volatile
    {
        return (MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS >> 0u) &
               0b1111111111111111u;
    }

    /**
     * Set MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS's TSHWR field.
     *
     * Timestamp Higher Word Register This field contains the most-significant
     * 16-bits of timestamp seconds value.
     */
    inline void set_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR(
        uint16_t value) volatile
    {
        uint32_t curr = MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS = curr;
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's ATSNS field.
     *
     * Number of Auxiliary Timestamp Snapshots This field indicates the number
     * of Snapshots available in the FIFO.
     */
    inline uint8_t get_MAC_TIMESTAMP_STATUS_ATSNS() volatile
    {
        return (MAC_TIMESTAMP_STATUS >> 25u) & 0b11111u;
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's ATSSTM bit.
     *
     * Auxiliary Timestamp Snapshot Trigger Missed This bit is set when the
     * Auxiliary timestamp snapshot FIFO is full and external trigger was set.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_ATSSTM() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 24u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's ATSSTN field.
     *
     * Auxiliary Timestamp Snapshot Trigger Identifier These bits identify the
     * Auxiliary trigger inputs for which the timestamp available in the
     * Auxiliary Snapshot Register is applicable.
     */
    inline uint8_t get_MAC_TIMESTAMP_STATUS_ATSSTN() volatile
    {
        return (MAC_TIMESTAMP_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TXTSSIS bit.
     *
     * Tx Timestamp Status Interrupt Status In non-EQOS_CORE configurations
     * when drop transmit status is enabled in MTL, this bit is set when the
     * captured transmit timestamp is updated in the
     * MAC_TX_TIMESTAMP_STATUS_NANOSECONDS and MAC_TX_TIMESTAMP_STATUS_SECONDS
     * registers.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TXTSSIS() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 15u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTRGTERR3 bit.
     *
     * Timestamp Target Time Error This bit is set when the latest target time
     * programmed in the MAC_PPS3_TARGET_TIME_SECONDS and
     * MAC_PPS3_TARGET_TIME_NANOSECONDS registers elapses.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTRGTERR3() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 9u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTARGT3 bit.
     *
     * Timestamp Target Time Reached for Target Time PPS3 When this bit is set,
     * it indicates that the value of system time is greater than or equal to
     * the value specified in the MAC_PPS3_TARGET_TIME_SECONDS and
     * MAC_PPS3_TARGET_TIME_NANOSECONDS registers.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTARGT3() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 8u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTRGTERR2 bit.
     *
     * Timestamp Target Time Error This bit is set when the latest target time
     * programmed in the MAC_PPS2_TARGET_TIME_SECONDS and
     * MAC_PPS2_TARGET_TIME_NANOSECONDS registers elapses.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTRGTERR2() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 7u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTARGT2 bit.
     *
     * Timestamp Target Time Reached for Target Time PPS2 When set, this bit
     * indicates that the value of system time is greater than or equal to the
     * value specified in the MAC_PPS2_TARGET_TIME_SECONDS and
     * MAC_PPS2_TARGET_TIME_NANOSECONDS registers.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTARGT2() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 6u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTRGTERR1 bit.
     *
     * Timestamp Target Time Error This bit is set when the latest target time
     * programmed in the MAC_PPS1_TARGET_TIME_SECONDS and
     * MAC_PPS1_TARGET_TIME_NANOSECONDS registers elapses.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTRGTERR1() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 5u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTARGT1 bit.
     *
     * Timestamp Target Time Reached for Target Time PPS1 When set, this bit
     * indicates that the value of system time is greater than or equal to the
     * value specified in the MAC_PPS1_TARGET_TIME_SECONDS and
     * MAC_PPS1_TARGET_TIME_NANOSECONDS registers.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTARGT1() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 4u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTRGTERR0 bit.
     *
     * Timestamp Target Time Error This bit is set when the latest target time
     * programmed in the MAC_PPS0_Target_Time_Seconds and
     * MAC_PPS0_Target_Time_Nanoseconds registers elapses.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTRGTERR0() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 3u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's AUXTSTRIG bit.
     *
     * Auxiliary Timestamp Trigger Snapshot This bit is set high when the
     * auxiliary snapshot is written to the FIFO.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_AUXTSTRIG() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 2u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSTARGT0 bit.
     *
     * Timestamp Target Time Reached When set, this bit indicates that the
     * value of system time is greater than or equal to the value specified in
     * the MAC_PPS0_Target_Time_Seconds and MAC_PPS0_Target_Time_Nanoseconds
     * registers.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSTARGT0() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 1u);
    }

    /**
     * Get MAC_TIMESTAMP_STATUS's TSSOVF bit.
     *
     * Timestamp Seconds Overflow When this bit is set, it indicates that the
     * seconds value of the timestamp (when supporting version 2 format) has
     * overflowed beyond 32'hFFFF_FFFF.
     */
    inline bool get_MAC_TIMESTAMP_STATUS_TSSOVF() volatile
    {
        return MAC_TIMESTAMP_STATUS & (1u << 0u);
    }

    /**
     * Get all of MAC_TIMESTAMP_STATUS's bit fields.
     *
     * (read-write) Timestamp Status
     */
    inline void get_MAC_TIMESTAMP_STATUS(uint8_t &ATSNS, bool &ATSSTM,
                                         uint8_t &ATSSTN, bool &TXTSSIS,
                                         bool &TSTRGTERR3, bool &TSTARGT3,
                                         bool &TSTRGTERR2, bool &TSTARGT2,
                                         bool &TSTRGTERR1, bool &TSTARGT1,
                                         bool &TSTRGTERR0, bool &AUXTSTRIG,
                                         bool &TSTARGT0, bool &TSSOVF) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_STATUS;

        ATSNS = (curr >> 25u) & 0b11111u;
        ATSSTM = curr & (1u << 24u);
        ATSSTN = (curr >> 16u) & 0b1111u;
        TXTSSIS = curr & (1u << 15u);
        TSTRGTERR3 = curr & (1u << 9u);
        TSTARGT3 = curr & (1u << 8u);
        TSTRGTERR2 = curr & (1u << 7u);
        TSTARGT2 = curr & (1u << 6u);
        TSTRGTERR1 = curr & (1u << 5u);
        TSTARGT1 = curr & (1u << 4u);
        TSTRGTERR0 = curr & (1u << 3u);
        AUXTSTRIG = curr & (1u << 2u);
        TSTARGT0 = curr & (1u << 1u);
        TSSOVF = curr & (1u << 0u);
    }

    /**
     * Get MAC_TX_TIMESTAMP_STATUS_NANOSECONDS's TXTSSMIS bit.
     *
     * Transmit Timestamp Status Missed When this bit is set, it indicates one
     * of the following: - The timestamp of the current packet is ignored if
     * TXTSSTSM bit of the TIMESTAMP_CONTROL register is reset - The timestamp
     * of the previous packet is overwritten with timestamp of the current
     * packet if TXTSSTSM bit of the MAC_TIMESTAMP_CONTROL register is set.
     */
    inline bool get_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS() volatile
    {
        return MAC_TX_TIMESTAMP_STATUS_NANOSECONDS & (1u << 31u);
    }

    /**
     * Get MAC_TX_TIMESTAMP_STATUS_NANOSECONDS's TXTSSLO field.
     *
     * Transmit Timestamp Status Low This field contains the 31 bits of the
     * Nanoseconds field of the Transmit packet's captured timestamp.
     */
    inline uint32_t get_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO() volatile
    {
        return (MAC_TX_TIMESTAMP_STATUS_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get all of MAC_TX_TIMESTAMP_STATUS_NANOSECONDS's bit fields.
     *
     * (read-write) Transmit Timestamp Status Nanoseconds
     */
    inline void get_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS(
        bool &TXTSSMIS, uint32_t &TXTSSLO) volatile
    {
        uint32_t curr = MAC_TX_TIMESTAMP_STATUS_NANOSECONDS;

        TXTSSMIS = curr & (1u << 31u);
        TXTSSLO = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get MAC_TX_TIMESTAMP_STATUS_SECONDS's TXTSSHI field.
     *
     * Transmit Timestamp Status High This field contains the lower 32 bits of
     * the Seconds field of Transmit packet's captured timestamp.
     */
    inline uint32_t get_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSHI() volatile
    {
        return (MAC_TX_TIMESTAMP_STATUS_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_AUXILIARY_CONTROL's ATSEN3 bit.
     *
     * Auxiliary Snapshot 3 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 3.
     */
    inline bool get_MAC_AUXILIARY_CONTROL_ATSEN3() volatile
    {
        return MAC_AUXILIARY_CONTROL & (1u << 7u);
    }

    /**
     * Set MAC_AUXILIARY_CONTROL's ATSEN3 bit.
     *
     * Auxiliary Snapshot 3 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 3.
     */
    inline void set_MAC_AUXILIARY_CONTROL_ATSEN3() volatile
    {
        MAC_AUXILIARY_CONTROL |= 1u << 7u;
    }

    /**
     * Clear MAC_AUXILIARY_CONTROL's ATSEN3 bit.
     *
     * Auxiliary Snapshot 3 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 3.
     */
    inline void clear_MAC_AUXILIARY_CONTROL_ATSEN3() volatile
    {
        MAC_AUXILIARY_CONTROL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_AUXILIARY_CONTROL's ATSEN3 bit.
     *
     * Auxiliary Snapshot 3 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 3.
     */
    inline void toggle_MAC_AUXILIARY_CONTROL_ATSEN3() volatile
    {
        MAC_AUXILIARY_CONTROL ^= 1u << 7u;
    }

    /**
     * Get MAC_AUXILIARY_CONTROL's ATSEN2 bit.
     *
     * Auxiliary Snapshot 2 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 2.
     */
    inline bool get_MAC_AUXILIARY_CONTROL_ATSEN2() volatile
    {
        return MAC_AUXILIARY_CONTROL & (1u << 6u);
    }

    /**
     * Set MAC_AUXILIARY_CONTROL's ATSEN2 bit.
     *
     * Auxiliary Snapshot 2 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 2.
     */
    inline void set_MAC_AUXILIARY_CONTROL_ATSEN2() volatile
    {
        MAC_AUXILIARY_CONTROL |= 1u << 6u;
    }

    /**
     * Clear MAC_AUXILIARY_CONTROL's ATSEN2 bit.
     *
     * Auxiliary Snapshot 2 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 2.
     */
    inline void clear_MAC_AUXILIARY_CONTROL_ATSEN2() volatile
    {
        MAC_AUXILIARY_CONTROL &= ~(1u << 6u);
    }

    /**
     * Toggle MAC_AUXILIARY_CONTROL's ATSEN2 bit.
     *
     * Auxiliary Snapshot 2 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 2.
     */
    inline void toggle_MAC_AUXILIARY_CONTROL_ATSEN2() volatile
    {
        MAC_AUXILIARY_CONTROL ^= 1u << 6u;
    }

    /**
     * Get MAC_AUXILIARY_CONTROL's ATSEN1 bit.
     *
     * Auxiliary Snapshot 1 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 1.
     */
    inline bool get_MAC_AUXILIARY_CONTROL_ATSEN1() volatile
    {
        return MAC_AUXILIARY_CONTROL & (1u << 5u);
    }

    /**
     * Set MAC_AUXILIARY_CONTROL's ATSEN1 bit.
     *
     * Auxiliary Snapshot 1 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 1.
     */
    inline void set_MAC_AUXILIARY_CONTROL_ATSEN1() volatile
    {
        MAC_AUXILIARY_CONTROL |= 1u << 5u;
    }

    /**
     * Clear MAC_AUXILIARY_CONTROL's ATSEN1 bit.
     *
     * Auxiliary Snapshot 1 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 1.
     */
    inline void clear_MAC_AUXILIARY_CONTROL_ATSEN1() volatile
    {
        MAC_AUXILIARY_CONTROL &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_AUXILIARY_CONTROL's ATSEN1 bit.
     *
     * Auxiliary Snapshot 1 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 1.
     */
    inline void toggle_MAC_AUXILIARY_CONTROL_ATSEN1() volatile
    {
        MAC_AUXILIARY_CONTROL ^= 1u << 5u;
    }

    /**
     * Get MAC_AUXILIARY_CONTROL's ATSEN0 bit.
     *
     * Auxiliary Snapshot 0 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 0.
     */
    inline bool get_MAC_AUXILIARY_CONTROL_ATSEN0() volatile
    {
        return MAC_AUXILIARY_CONTROL & (1u << 4u);
    }

    /**
     * Set MAC_AUXILIARY_CONTROL's ATSEN0 bit.
     *
     * Auxiliary Snapshot 0 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 0.
     */
    inline void set_MAC_AUXILIARY_CONTROL_ATSEN0() volatile
    {
        MAC_AUXILIARY_CONTROL |= 1u << 4u;
    }

    /**
     * Clear MAC_AUXILIARY_CONTROL's ATSEN0 bit.
     *
     * Auxiliary Snapshot 0 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 0.
     */
    inline void clear_MAC_AUXILIARY_CONTROL_ATSEN0() volatile
    {
        MAC_AUXILIARY_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_AUXILIARY_CONTROL's ATSEN0 bit.
     *
     * Auxiliary Snapshot 0 Enable This bit controls the capturing of Auxiliary
     * Snapshot Trigger 0.
     */
    inline void toggle_MAC_AUXILIARY_CONTROL_ATSEN0() volatile
    {
        MAC_AUXILIARY_CONTROL ^= 1u << 4u;
    }

    /**
     * Get MAC_AUXILIARY_CONTROL's ATSFC bit.
     *
     * Auxiliary Snapshot FIFO Clear When set, this bit resets the pointers of
     * the Auxiliary Snapshot FIFO.
     */
    inline bool get_MAC_AUXILIARY_CONTROL_ATSFC() volatile
    {
        return MAC_AUXILIARY_CONTROL & (1u << 0u);
    }

    /**
     * Set MAC_AUXILIARY_CONTROL's ATSFC bit.
     *
     * Auxiliary Snapshot FIFO Clear When set, this bit resets the pointers of
     * the Auxiliary Snapshot FIFO.
     */
    inline void set_MAC_AUXILIARY_CONTROL_ATSFC() volatile
    {
        MAC_AUXILIARY_CONTROL |= 1u << 0u;
    }

    /**
     * Clear MAC_AUXILIARY_CONTROL's ATSFC bit.
     *
     * Auxiliary Snapshot FIFO Clear When set, this bit resets the pointers of
     * the Auxiliary Snapshot FIFO.
     */
    inline void clear_MAC_AUXILIARY_CONTROL_ATSFC() volatile
    {
        MAC_AUXILIARY_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_AUXILIARY_CONTROL's ATSFC bit.
     *
     * Auxiliary Snapshot FIFO Clear When set, this bit resets the pointers of
     * the Auxiliary Snapshot FIFO.
     */
    inline void toggle_MAC_AUXILIARY_CONTROL_ATSFC() volatile
    {
        MAC_AUXILIARY_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_AUXILIARY_CONTROL's bit fields.
     *
     * (read-write) Auxiliary Timestamp Control
     */
    inline void get_MAC_AUXILIARY_CONTROL(bool &ATSEN3, bool &ATSEN2,
                                          bool &ATSEN1, bool &ATSEN0,
                                          bool &ATSFC) volatile
    {
        uint32_t curr = MAC_AUXILIARY_CONTROL;

        ATSEN3 = curr & (1u << 7u);
        ATSEN2 = curr & (1u << 6u);
        ATSEN1 = curr & (1u << 5u);
        ATSEN0 = curr & (1u << 4u);
        ATSFC = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_AUXILIARY_CONTROL's bit fields.
     *
     * (read-write) Auxiliary Timestamp Control
     */
    inline void set_MAC_AUXILIARY_CONTROL(bool ATSEN3, bool ATSEN2,
                                          bool ATSEN1, bool ATSEN0,
                                          bool ATSFC) volatile
    {
        uint32_t curr = MAC_AUXILIARY_CONTROL;

        curr &= ~(0b1u << 7u);
        curr |= (ATSEN3 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ATSEN2 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ATSEN1 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ATSEN0 & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (ATSFC & 0b1u) << 0u;

        MAC_AUXILIARY_CONTROL = curr;
    }

    /**
     * Get MAC_AUXILIARY_TIMESTAMP_NANOSECONDS's AUXTSLO field.
     *
     * Auxiliary Timestamp Contains the lower 31 bits (nanoseconds field) of
     * the auxiliary timestamp.
     */
    inline uint32_t get_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO() volatile
    {
        return (MAC_AUXILIARY_TIMESTAMP_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get MAC_AUXILIARY_TIMESTAMP_SECONDS's AUXTSHI field.
     *
     * Auxiliary Timestamp Contains the lower 32 bits of the Seconds field of
     * the auxiliary timestamp.
     */
    inline uint32_t get_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI() volatile
    {
        return (MAC_AUXILIARY_TIMESTAMP_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get MAC_TIMESTAMP_INGRESS_ASYM_CORR's OSTIAC field.
     *
     * One-Step Timestamp Ingress Asymmetry Correction This field contains the
     * ingress path asymmetry value to be added to correctionField of
     * Pdelay_Resp PTP packet.
     */
    inline uint32_t get_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC() volatile
    {
        return (MAC_TIMESTAMP_INGRESS_ASYM_CORR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_TIMESTAMP_INGRESS_ASYM_CORR's OSTIAC field.
     *
     * One-Step Timestamp Ingress Asymmetry Correction This field contains the
     * ingress path asymmetry value to be added to correctionField of
     * Pdelay_Resp PTP packet.
     */
    inline void set_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_INGRESS_ASYM_CORR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_TIMESTAMP_INGRESS_ASYM_CORR = curr;
    }

    /**
     * Get MAC_TIMESTAMP_EGRESS_ASYM_CORR's OSTEAC field.
     *
     * One-Step Timestamp Egress Asymmetry Correction This field contains the
     * egress path asymmetry value to be subtracted from correctionField of
     * Pdelay_Resp PTP packet.
     */
    inline uint32_t get_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC() volatile
    {
        return (MAC_TIMESTAMP_EGRESS_ASYM_CORR >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_TIMESTAMP_EGRESS_ASYM_CORR's OSTEAC field.
     *
     * One-Step Timestamp Egress Asymmetry Correction This field contains the
     * egress path asymmetry value to be subtracted from correctionField of
     * Pdelay_Resp PTP packet.
     */
    inline void set_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_EGRESS_ASYM_CORR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_TIMESTAMP_EGRESS_ASYM_CORR = curr;
    }

    /**
     * Get MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND's TSIC field.
     *
     * Timestamp Ingress Correction This field contains the ingress path
     * correction value as defined by the Ingress Correction expression.
     */
    inline uint32_t get_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC() volatile
    {
        return (MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND's TSIC field.
     *
     * Timestamp Ingress Correction This field contains the ingress path
     * correction value as defined by the Ingress Correction expression.
     */
    inline void set_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND = curr;
    }

    /**
     * Get MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND's TSEC field.
     *
     * Timestamp Egress Correction This field contains the nanoseconds part of
     * the egress path correction value as defined by the Egress Correction
     * expression.
     */
    inline uint32_t get_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC() volatile
    {
        return (MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND's TSEC field.
     *
     * Timestamp Egress Correction This field contains the nanoseconds part of
     * the egress path correction value as defined by the Egress Correction
     * expression.
     */
    inline void set_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND = curr;
    }

    /**
     * Get MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC's TSICSNS field.
     *
     * Timestamp Ingress Correction, sub-nanoseconds This field contains the
     * sub-nanoseconds part of the ingress path correction value as defined by
     * the "Ingress Correction" expression.
     */
    inline uint8_t get_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC_TSICSNS() volatile
    {
        return (MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC >> 8u) & 0b11111111u;
    }

    /**
     * Set MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC's TSICSNS field.
     *
     * Timestamp Ingress Correction, sub-nanoseconds This field contains the
     * sub-nanoseconds part of the ingress path correction value as defined by
     * the "Ingress Correction" expression.
     */
    inline void set_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC_TSICSNS(
        uint8_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSEC = curr;
    }

    /**
     * Get MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC's TSECSNS field.
     *
     * Timestamp Egress Correction, sub-nanoseconds This field contains the
     * sub-nanoseconds part of the egress path correction value as defined by
     * the "Egress Correction" expression.
     */
    inline uint8_t get_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC_TSECSNS() volatile
    {
        return (MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC >> 8u) & 0b11111111u;
    }

    /**
     * Set MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC's TSECSNS field.
     *
     * Timestamp Egress Correction, sub-nanoseconds This field contains the
     * sub-nanoseconds part of the egress path correction value as defined by
     * the "Egress Correction" expression.
     */
    inline void set_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC_TSECSNS(
        uint8_t value) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSEC = curr;
    }

    /**
     * Get MAC_TIMESTAMP_INGRESS_LATENCY's ITLNS field.
     *
     * Ingress Timestamp Latency, in sub-nanoseconds This register holds the
     * average latency in sub-nanoseconds between the input ports (phy_rxd_i)
     * of MAC and the actual point (GMII/MII) where the ingress timestamp is
     * taken.
     */
    inline uint16_t get_MAC_TIMESTAMP_INGRESS_LATENCY_ITLNS() volatile
    {
        return (MAC_TIMESTAMP_INGRESS_LATENCY >> 16u) & 0b111111111111u;
    }

    /**
     * Get MAC_TIMESTAMP_INGRESS_LATENCY's ITLSNS field.
     *
     * Ingress Timestamp Latency, in nanoseconds This register holds the
     * average latency in nanoseconds between the input ports (phy_rxd_i) of
     * MAC and the actual point (GMII/MII) where the ingress timestamp is
     * taken.
     */
    inline uint8_t get_MAC_TIMESTAMP_INGRESS_LATENCY_ITLSNS() volatile
    {
        return (MAC_TIMESTAMP_INGRESS_LATENCY >> 8u) & 0b11111111u;
    }

    /**
     * Get all of MAC_TIMESTAMP_INGRESS_LATENCY's bit fields.
     *
     * (read-write) Timestamp Ingress Latency
     */
    inline void get_MAC_TIMESTAMP_INGRESS_LATENCY(uint16_t &ITLNS,
                                                  uint8_t &ITLSNS) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_INGRESS_LATENCY;

        ITLNS = (curr >> 16u) & 0b111111111111u;
        ITLSNS = (curr >> 8u) & 0b11111111u;
    }

    /**
     * Get MAC_TIMESTAMP_EGRESS_LATENCY's ETLNS field.
     *
     * Egress Timestamp Latency, in nanoseconds This register holds the average
     * latency in nanoseconds between the actual point (GMII/MII) where the
     * egress timestamp is taken and the output ports (phy_txd_o) of the MAC.
     */
    inline uint16_t get_MAC_TIMESTAMP_EGRESS_LATENCY_ETLNS() volatile
    {
        return (MAC_TIMESTAMP_EGRESS_LATENCY >> 16u) & 0b111111111111u;
    }

    /**
     * Get MAC_TIMESTAMP_EGRESS_LATENCY's ETLSNS field.
     *
     * Egress Timestamp Latency, in sub-nanoseconds This register holds the
     * average latency in sub-nanoseconds between the actual point (GMII/MII)
     * where the egress timestamp is taken and the output ports (phy_txd_o) of
     * the MAC.
     */
    inline uint8_t get_MAC_TIMESTAMP_EGRESS_LATENCY_ETLSNS() volatile
    {
        return (MAC_TIMESTAMP_EGRESS_LATENCY >> 8u) & 0b11111111u;
    }

    /**
     * Get all of MAC_TIMESTAMP_EGRESS_LATENCY's bit fields.
     *
     * (read-write) Timestamp Egress Latency
     */
    inline void get_MAC_TIMESTAMP_EGRESS_LATENCY(uint16_t &ETLNS,
                                                 uint8_t &ETLSNS) volatile
    {
        uint32_t curr = MAC_TIMESTAMP_EGRESS_LATENCY;

        ETLNS = (curr >> 16u) & 0b111111111111u;
        ETLSNS = (curr >> 8u) & 0b11111111u;
    }

    /**
     * Get MAC_PPS_CONTROL's MCGREN3 bit.
     *
     * MCGR Mode Enable for PPS3 Output This field enables the 3rd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline bool get_MAC_PPS_CONTROL_MCGREN3() volatile
    {
        return MAC_PPS_CONTROL & (1u << 31u);
    }

    /**
     * Set MAC_PPS_CONTROL's MCGREN3 bit.
     *
     * MCGR Mode Enable for PPS3 Output This field enables the 3rd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void set_MAC_PPS_CONTROL_MCGREN3() volatile
    {
        MAC_PPS_CONTROL |= 1u << 31u;
    }

    /**
     * Clear MAC_PPS_CONTROL's MCGREN3 bit.
     *
     * MCGR Mode Enable for PPS3 Output This field enables the 3rd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void clear_MAC_PPS_CONTROL_MCGREN3() volatile
    {
        MAC_PPS_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PPS_CONTROL's MCGREN3 bit.
     *
     * MCGR Mode Enable for PPS3 Output This field enables the 3rd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void toggle_MAC_PPS_CONTROL_MCGREN3() volatile
    {
        MAC_PPS_CONTROL ^= 1u << 31u;
    }

    /**
     * Get MAC_PPS_CONTROL's TRGTMODSEL3 field.
     *
     * Target Time Register Mode for PPS3 Output This field indicates the
     * Target Time registers (MAC_PPS3_TARGET_TIME_SECONDS and
     * MAC_PPS3_TARGET_TIME_NANOSECONDS) mode for PPS3 output signal.
     */
    inline ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3
    get_MAC_PPS_CONTROL_TRGTMODSEL3() volatile
    {
        return ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3((MAC_PPS_CONTROL >> 29u) &
                                                    0b11u);
    }

    /**
     * Set MAC_PPS_CONTROL's TRGTMODSEL3 field.
     *
     * Target Time Register Mode for PPS3 Output This field indicates the
     * Target Time registers (MAC_PPS3_TARGET_TIME_SECONDS and
     * MAC_PPS3_TARGET_TIME_NANOSECONDS) mode for PPS3 output signal.
     */
    inline void set_MAC_PPS_CONTROL_TRGTMODSEL3(
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3 value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(value) & 0b11u) << 29u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's PPSCMD3 field.
     *
     * Flexible PPS3 Output Control This field controls the flexible PPS3
     * output (ptp_pps_o[3]) signal.
     */
    inline uint8_t get_MAC_PPS_CONTROL_PPSCMD3() volatile
    {
        return (MAC_PPS_CONTROL >> 24u) & 0b1111u;
    }

    /**
     * Set MAC_PPS_CONTROL's PPSCMD3 field.
     *
     * Flexible PPS3 Output Control This field controls the flexible PPS3
     * output (ptp_pps_o[3]) signal.
     */
    inline void set_MAC_PPS_CONTROL_PPSCMD3(uint8_t value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's MCGREN2 bit.
     *
     * MCGR Mode Enable for PPS2 Output This field enables the 2nd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline bool get_MAC_PPS_CONTROL_MCGREN2() volatile
    {
        return MAC_PPS_CONTROL & (1u << 23u);
    }

    /**
     * Set MAC_PPS_CONTROL's MCGREN2 bit.
     *
     * MCGR Mode Enable for PPS2 Output This field enables the 2nd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void set_MAC_PPS_CONTROL_MCGREN2() volatile
    {
        MAC_PPS_CONTROL |= 1u << 23u;
    }

    /**
     * Clear MAC_PPS_CONTROL's MCGREN2 bit.
     *
     * MCGR Mode Enable for PPS2 Output This field enables the 2nd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void clear_MAC_PPS_CONTROL_MCGREN2() volatile
    {
        MAC_PPS_CONTROL &= ~(1u << 23u);
    }

    /**
     * Toggle MAC_PPS_CONTROL's MCGREN2 bit.
     *
     * MCGR Mode Enable for PPS2 Output This field enables the 2nd PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void toggle_MAC_PPS_CONTROL_MCGREN2() volatile
    {
        MAC_PPS_CONTROL ^= 1u << 23u;
    }

    /**
     * Get MAC_PPS_CONTROL's TRGTMODSEL2 field.
     *
     * Target Time Register Mode for PPS2 Output This field indicates the
     * Target Time registers (MAC_PPS2_TARGET_TIME_SECONDS and
     * MAC_PPS2_TARGET_TIME_NANOSECONDS) mode for PPS2 output signal.
     */
    inline ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2
    get_MAC_PPS_CONTROL_TRGTMODSEL2() volatile
    {
        return ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2((MAC_PPS_CONTROL >> 21u) &
                                                    0b11u);
    }

    /**
     * Set MAC_PPS_CONTROL's TRGTMODSEL2 field.
     *
     * Target Time Register Mode for PPS2 Output This field indicates the
     * Target Time registers (MAC_PPS2_TARGET_TIME_SECONDS and
     * MAC_PPS2_TARGET_TIME_NANOSECONDS) mode for PPS2 output signal.
     */
    inline void set_MAC_PPS_CONTROL_TRGTMODSEL2(
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2 value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b11u << 21u);
        curr |= (std::to_underlying(value) & 0b11u) << 21u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's PPSCMD2 field.
     *
     * Flexible PPS2 Output Control This field controls the flexible PPS2
     * output (ptp_pps_o[2]) signal.
     */
    inline uint8_t get_MAC_PPS_CONTROL_PPSCMD2() volatile
    {
        return (MAC_PPS_CONTROL >> 16u) & 0b1111u;
    }

    /**
     * Set MAC_PPS_CONTROL's PPSCMD2 field.
     *
     * Flexible PPS2 Output Control This field controls the flexible PPS2
     * output (ptp_pps_o[2]) signal.
     */
    inline void set_MAC_PPS_CONTROL_PPSCMD2(uint8_t value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's MCGREN1 bit.
     *
     * MCGR Mode Enable for PPS1 Output This field enables the 1st PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline bool get_MAC_PPS_CONTROL_MCGREN1() volatile
    {
        return MAC_PPS_CONTROL & (1u << 15u);
    }

    /**
     * Set MAC_PPS_CONTROL's MCGREN1 bit.
     *
     * MCGR Mode Enable for PPS1 Output This field enables the 1st PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void set_MAC_PPS_CONTROL_MCGREN1() volatile
    {
        MAC_PPS_CONTROL |= 1u << 15u;
    }

    /**
     * Clear MAC_PPS_CONTROL's MCGREN1 bit.
     *
     * MCGR Mode Enable for PPS1 Output This field enables the 1st PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void clear_MAC_PPS_CONTROL_MCGREN1() volatile
    {
        MAC_PPS_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle MAC_PPS_CONTROL's MCGREN1 bit.
     *
     * MCGR Mode Enable for PPS1 Output This field enables the 1st PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void toggle_MAC_PPS_CONTROL_MCGREN1() volatile
    {
        MAC_PPS_CONTROL ^= 1u << 15u;
    }

    /**
     * Get MAC_PPS_CONTROL's TRGTMODSEL1 field.
     *
     * Target Time Register Mode for PPS1 Output This field indicates the
     * Target Time registers (MAC_PPS1_TARGET_TIME_SECONDS and
     * MAC_PPS1_TARGET_TIME_NANOSECONDS) mode for PPS1 output signal.
     */
    inline ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1
    get_MAC_PPS_CONTROL_TRGTMODSEL1() volatile
    {
        return ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1((MAC_PPS_CONTROL >> 13u) &
                                                    0b11u);
    }

    /**
     * Set MAC_PPS_CONTROL's TRGTMODSEL1 field.
     *
     * Target Time Register Mode for PPS1 Output This field indicates the
     * Target Time registers (MAC_PPS1_TARGET_TIME_SECONDS and
     * MAC_PPS1_TARGET_TIME_NANOSECONDS) mode for PPS1 output signal.
     */
    inline void set_MAC_PPS_CONTROL_TRGTMODSEL1(
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1 value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's PPSCMD1 field.
     *
     * Flexible PPS1 Output Control This field controls the flexible PPS1
     * output (ptp_pps_o[1]) signal.
     */
    inline uint8_t get_MAC_PPS_CONTROL_PPSCMD1() volatile
    {
        return (MAC_PPS_CONTROL >> 8u) & 0b1111u;
    }

    /**
     * Set MAC_PPS_CONTROL's PPSCMD1 field.
     *
     * Flexible PPS1 Output Control This field controls the flexible PPS1
     * output (ptp_pps_o[1]) signal.
     */
    inline void set_MAC_PPS_CONTROL_PPSCMD1(uint8_t value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's MCGREN0 bit.
     *
     * MCGR Mode Enable for PPS0 Output This field enables the 0th PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline bool get_MAC_PPS_CONTROL_MCGREN0() volatile
    {
        return MAC_PPS_CONTROL & (1u << 7u);
    }

    /**
     * Set MAC_PPS_CONTROL's MCGREN0 bit.
     *
     * MCGR Mode Enable for PPS0 Output This field enables the 0th PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void set_MAC_PPS_CONTROL_MCGREN0() volatile
    {
        MAC_PPS_CONTROL |= 1u << 7u;
    }

    /**
     * Clear MAC_PPS_CONTROL's MCGREN0 bit.
     *
     * MCGR Mode Enable for PPS0 Output This field enables the 0th PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void clear_MAC_PPS_CONTROL_MCGREN0() volatile
    {
        MAC_PPS_CONTROL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_PPS_CONTROL's MCGREN0 bit.
     *
     * MCGR Mode Enable for PPS0 Output This field enables the 0th PPS instance
     * to operate in PPS or MCGR mode.
     */
    inline void toggle_MAC_PPS_CONTROL_MCGREN0() volatile
    {
        MAC_PPS_CONTROL ^= 1u << 7u;
    }

    /**
     * Get MAC_PPS_CONTROL's TRGTMODSEL0 field.
     *
     * Target Time Register Mode for PPS0 Output This field indicates the
     * Target Time registers (MAC_PPS0_TARGET_TIME_SECONDS and
     * MAC_PPS0_TARGET_TIME_NANOSECONDS) mode for PPS0 output signal:
     */
    inline ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0
    get_MAC_PPS_CONTROL_TRGTMODSEL0() volatile
    {
        return ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0((MAC_PPS_CONTROL >> 5u) &
                                                    0b11u);
    }

    /**
     * Set MAC_PPS_CONTROL's TRGTMODSEL0 field.
     *
     * Target Time Register Mode for PPS0 Output This field indicates the
     * Target Time registers (MAC_PPS0_TARGET_TIME_SECONDS and
     * MAC_PPS0_TARGET_TIME_NANOSECONDS) mode for PPS0 output signal:
     */
    inline void set_MAC_PPS_CONTROL_TRGTMODSEL0(
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0 value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS_CONTROL's PPSEN0 bit.
     *
     * Flexible PPS Output Mode Enable When this bit is set, Bits[3:0] function
     * as PPSCMD.
     */
    inline bool get_MAC_PPS_CONTROL_PPSEN0() volatile
    {
        return MAC_PPS_CONTROL & (1u << 4u);
    }

    /**
     * Set MAC_PPS_CONTROL's PPSEN0 bit.
     *
     * Flexible PPS Output Mode Enable When this bit is set, Bits[3:0] function
     * as PPSCMD.
     */
    inline void set_MAC_PPS_CONTROL_PPSEN0() volatile
    {
        MAC_PPS_CONTROL |= 1u << 4u;
    }

    /**
     * Clear MAC_PPS_CONTROL's PPSEN0 bit.
     *
     * Flexible PPS Output Mode Enable When this bit is set, Bits[3:0] function
     * as PPSCMD.
     */
    inline void clear_MAC_PPS_CONTROL_PPSEN0() volatile
    {
        MAC_PPS_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_PPS_CONTROL's PPSEN0 bit.
     *
     * Flexible PPS Output Mode Enable When this bit is set, Bits[3:0] function
     * as PPSCMD.
     */
    inline void toggle_MAC_PPS_CONTROL_PPSEN0() volatile
    {
        MAC_PPS_CONTROL ^= 1u << 4u;
    }

    /**
     * Get MAC_PPS_CONTROL's PPSCTRL_PPSCMD field.
     *
     * PPS Output Frequency Control This field controls the frequency of the
     * PPS0 output (ptp_pps_o[0]) signal.
     */
    inline uint8_t get_MAC_PPS_CONTROL_PPSCTRL_PPSCMD() volatile
    {
        return (MAC_PPS_CONTROL >> 0u) & 0b1111u;
    }

    /**
     * Set MAC_PPS_CONTROL's PPSCTRL_PPSCMD field.
     *
     * PPS Output Frequency Control This field controls the frequency of the
     * PPS0 output (ptp_pps_o[0]) signal.
     */
    inline void set_MAC_PPS_CONTROL_PPSCTRL_PPSCMD(uint8_t value) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get all of MAC_PPS_CONTROL's bit fields.
     *
     * (read-write) PPS Control
     */
    inline void get_MAC_PPS_CONTROL(
        bool &MCGREN3, ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3 &TRGTMODSEL3,
        uint8_t &PPSCMD3, bool &MCGREN2,
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2 &TRGTMODSEL2, uint8_t &PPSCMD2,
        bool &MCGREN1, ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1 &TRGTMODSEL1,
        uint8_t &PPSCMD1, bool &MCGREN0,
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0 &TRGTMODSEL0, bool &PPSEN0,
        uint8_t &PPSCTRL_PPSCMD) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        MCGREN3 = curr & (1u << 31u);
        TRGTMODSEL3 =
            ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3((curr >> 29u) & 0b11u);
        PPSCMD3 = (curr >> 24u) & 0b1111u;
        MCGREN2 = curr & (1u << 23u);
        TRGTMODSEL2 =
            ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2((curr >> 21u) & 0b11u);
        PPSCMD2 = (curr >> 16u) & 0b1111u;
        MCGREN1 = curr & (1u << 15u);
        TRGTMODSEL1 =
            ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1((curr >> 13u) & 0b11u);
        PPSCMD1 = (curr >> 8u) & 0b1111u;
        MCGREN0 = curr & (1u << 7u);
        TRGTMODSEL0 =
            ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0((curr >> 5u) & 0b11u);
        PPSEN0 = curr & (1u << 4u);
        PPSCTRL_PPSCMD = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of MAC_PPS_CONTROL's bit fields.
     *
     * (read-write) PPS Control
     */
    inline void set_MAC_PPS_CONTROL(
        bool MCGREN3, ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL3 TRGTMODSEL3,
        uint8_t PPSCMD3, bool MCGREN2,
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL2 TRGTMODSEL2, uint8_t PPSCMD2,
        bool MCGREN1, ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL1 TRGTMODSEL1,
        uint8_t PPSCMD1, bool MCGREN0,
        ENET_QOS_MAC_PPS_CONTROL_TRGTMODSEL0 TRGTMODSEL0, bool PPSEN0,
        uint8_t PPSCTRL_PPSCMD) volatile
    {
        uint32_t curr = MAC_PPS_CONTROL;

        curr &= ~(0b1u << 31u);
        curr |= (MCGREN3 & 0b1u) << 31u;
        curr &= ~(0b11u << 29u);
        curr |= (std::to_underlying(TRGTMODSEL3) & 0b11u) << 29u;
        curr &= ~(0b1111u << 24u);
        curr |= (PPSCMD3 & 0b1111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (MCGREN2 & 0b1u) << 23u;
        curr &= ~(0b11u << 21u);
        curr |= (std::to_underlying(TRGTMODSEL2) & 0b11u) << 21u;
        curr &= ~(0b1111u << 16u);
        curr |= (PPSCMD2 & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (MCGREN1 & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(TRGTMODSEL1) & 0b11u) << 13u;
        curr &= ~(0b1111u << 8u);
        curr |= (PPSCMD1 & 0b1111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (MCGREN0 & 0b1u) << 7u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(TRGTMODSEL0) & 0b11u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (PPSEN0 & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (PPSCTRL_PPSCMD & 0b1111u) << 0u;

        MAC_PPS_CONTROL = curr;
    }

    /**
     * Get MAC_PPS0_TARGET_TIME_SECONDS's TSTRH0 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline uint32_t get_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0() volatile
    {
        return (MAC_PPS0_TARGET_TIME_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS0_TARGET_TIME_SECONDS's TSTRH0 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline void set_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS0_TARGET_TIME_SECONDS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS0_TARGET_TIME_SECONDS = curr;
    }

    /**
     * Get MAC_PPS0_TARGET_TIME_NANOSECONDS's TRGTBUSY0 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline bool get_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0() volatile
    {
        return MAC_PPS0_TARGET_TIME_NANOSECONDS & (1u << 31u);
    }

    /**
     * Set MAC_PPS0_TARGET_TIME_NANOSECONDS's TRGTBUSY0 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void set_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0() volatile
    {
        MAC_PPS0_TARGET_TIME_NANOSECONDS |= 1u << 31u;
    }

    /**
     * Clear MAC_PPS0_TARGET_TIME_NANOSECONDS's TRGTBUSY0 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void clear_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0() volatile
    {
        MAC_PPS0_TARGET_TIME_NANOSECONDS &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PPS0_TARGET_TIME_NANOSECONDS's TRGTBUSY0 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void toggle_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0() volatile
    {
        MAC_PPS0_TARGET_TIME_NANOSECONDS ^= 1u << 31u;
    }

    /**
     * Get MAC_PPS0_TARGET_TIME_NANOSECONDS's TTSL0 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline uint32_t get_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0() volatile
    {
        return (MAC_PPS0_TARGET_TIME_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS0_TARGET_TIME_NANOSECONDS's TTSL0 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline void set_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS0_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS0_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get all of MAC_PPS0_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS0 Target Time Nanoseconds
     */
    inline void get_MAC_PPS0_TARGET_TIME_NANOSECONDS(bool &TRGTBUSY0,
                                                     uint32_t &TTSL0) volatile
    {
        uint32_t curr = MAC_PPS0_TARGET_TIME_NANOSECONDS;

        TRGTBUSY0 = curr & (1u << 31u);
        TTSL0 = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Set all of MAC_PPS0_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS0 Target Time Nanoseconds
     */
    inline void set_MAC_PPS0_TARGET_TIME_NANOSECONDS(bool TRGTBUSY0,
                                                     uint32_t TTSL0) volatile
    {
        uint32_t curr = MAC_PPS0_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1u << 31u);
        curr |= (TRGTBUSY0 & 0b1u) << 31u;
        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (TTSL0 & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS0_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get MAC_PPS0_INTERVAL's PPSINT0 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS0_INTERVAL_PPSINT0() volatile
    {
        return (MAC_PPS0_INTERVAL >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS0_INTERVAL's PPSINT0 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline void set_MAC_PPS0_INTERVAL_PPSINT0(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS0_INTERVAL;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS0_INTERVAL = curr;
    }

    /**
     * Get MAC_PPS0_WIDTH's PPSWIDTH0 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS0_WIDTH_PPSWIDTH0() volatile
    {
        return (MAC_PPS0_WIDTH >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS0_WIDTH's PPSWIDTH0 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline void set_MAC_PPS0_WIDTH_PPSWIDTH0(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS0_WIDTH;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS0_WIDTH = curr;
    }

    /**
     * Get MAC_PPS1_TARGET_TIME_SECONDS's TSTRH1 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline uint32_t get_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1() volatile
    {
        return (MAC_PPS1_TARGET_TIME_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS1_TARGET_TIME_SECONDS's TSTRH1 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline void set_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS1_TARGET_TIME_SECONDS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS1_TARGET_TIME_SECONDS = curr;
    }

    /**
     * Get MAC_PPS1_TARGET_TIME_NANOSECONDS's TRGTBUSY1 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline bool get_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1() volatile
    {
        return MAC_PPS1_TARGET_TIME_NANOSECONDS & (1u << 31u);
    }

    /**
     * Set MAC_PPS1_TARGET_TIME_NANOSECONDS's TRGTBUSY1 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void set_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1() volatile
    {
        MAC_PPS1_TARGET_TIME_NANOSECONDS |= 1u << 31u;
    }

    /**
     * Clear MAC_PPS1_TARGET_TIME_NANOSECONDS's TRGTBUSY1 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void clear_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1() volatile
    {
        MAC_PPS1_TARGET_TIME_NANOSECONDS &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PPS1_TARGET_TIME_NANOSECONDS's TRGTBUSY1 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void toggle_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1() volatile
    {
        MAC_PPS1_TARGET_TIME_NANOSECONDS ^= 1u << 31u;
    }

    /**
     * Get MAC_PPS1_TARGET_TIME_NANOSECONDS's TTSL1 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline uint32_t get_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1() volatile
    {
        return (MAC_PPS1_TARGET_TIME_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS1_TARGET_TIME_NANOSECONDS's TTSL1 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline void set_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS1_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS1_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get all of MAC_PPS1_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS1 Target Time Nanoseconds
     */
    inline void get_MAC_PPS1_TARGET_TIME_NANOSECONDS(bool &TRGTBUSY1,
                                                     uint32_t &TTSL1) volatile
    {
        uint32_t curr = MAC_PPS1_TARGET_TIME_NANOSECONDS;

        TRGTBUSY1 = curr & (1u << 31u);
        TTSL1 = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Set all of MAC_PPS1_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS1 Target Time Nanoseconds
     */
    inline void set_MAC_PPS1_TARGET_TIME_NANOSECONDS(bool TRGTBUSY1,
                                                     uint32_t TTSL1) volatile
    {
        uint32_t curr = MAC_PPS1_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1u << 31u);
        curr |= (TRGTBUSY1 & 0b1u) << 31u;
        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (TTSL1 & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS1_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get MAC_PPS1_INTERVAL's PPSINT1 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS1_INTERVAL_PPSINT1() volatile
    {
        return (MAC_PPS1_INTERVAL >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS1_INTERVAL's PPSINT1 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline void set_MAC_PPS1_INTERVAL_PPSINT1(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS1_INTERVAL;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS1_INTERVAL = curr;
    }

    /**
     * Get MAC_PPS1_WIDTH's PPSWIDTH1 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS1_WIDTH_PPSWIDTH1() volatile
    {
        return (MAC_PPS1_WIDTH >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS1_WIDTH's PPSWIDTH1 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline void set_MAC_PPS1_WIDTH_PPSWIDTH1(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS1_WIDTH;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS1_WIDTH = curr;
    }

    /**
     * Get MAC_PPS2_TARGET_TIME_SECONDS's TSTRH2 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline uint32_t get_MAC_PPS2_TARGET_TIME_SECONDS_TSTRH2() volatile
    {
        return (MAC_PPS2_TARGET_TIME_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS2_TARGET_TIME_SECONDS's TSTRH2 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline void set_MAC_PPS2_TARGET_TIME_SECONDS_TSTRH2(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS2_TARGET_TIME_SECONDS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS2_TARGET_TIME_SECONDS = curr;
    }

    /**
     * Get MAC_PPS2_TARGET_TIME_NANOSECONDS's TRGTBUSY2 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline bool get_MAC_PPS2_TARGET_TIME_NANOSECONDS_TRGTBUSY2() volatile
    {
        return MAC_PPS2_TARGET_TIME_NANOSECONDS & (1u << 31u);
    }

    /**
     * Set MAC_PPS2_TARGET_TIME_NANOSECONDS's TRGTBUSY2 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void set_MAC_PPS2_TARGET_TIME_NANOSECONDS_TRGTBUSY2() volatile
    {
        MAC_PPS2_TARGET_TIME_NANOSECONDS |= 1u << 31u;
    }

    /**
     * Clear MAC_PPS2_TARGET_TIME_NANOSECONDS's TRGTBUSY2 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void clear_MAC_PPS2_TARGET_TIME_NANOSECONDS_TRGTBUSY2() volatile
    {
        MAC_PPS2_TARGET_TIME_NANOSECONDS &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PPS2_TARGET_TIME_NANOSECONDS's TRGTBUSY2 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void toggle_MAC_PPS2_TARGET_TIME_NANOSECONDS_TRGTBUSY2() volatile
    {
        MAC_PPS2_TARGET_TIME_NANOSECONDS ^= 1u << 31u;
    }

    /**
     * Get MAC_PPS2_TARGET_TIME_NANOSECONDS's TTSL2 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline uint32_t get_MAC_PPS2_TARGET_TIME_NANOSECONDS_TTSL2() volatile
    {
        return (MAC_PPS2_TARGET_TIME_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS2_TARGET_TIME_NANOSECONDS's TTSL2 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline void set_MAC_PPS2_TARGET_TIME_NANOSECONDS_TTSL2(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS2_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS2_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get all of MAC_PPS2_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS2 Target Time Nanoseconds
     */
    inline void get_MAC_PPS2_TARGET_TIME_NANOSECONDS(bool &TRGTBUSY2,
                                                     uint32_t &TTSL2) volatile
    {
        uint32_t curr = MAC_PPS2_TARGET_TIME_NANOSECONDS;

        TRGTBUSY2 = curr & (1u << 31u);
        TTSL2 = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Set all of MAC_PPS2_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS2 Target Time Nanoseconds
     */
    inline void set_MAC_PPS2_TARGET_TIME_NANOSECONDS(bool TRGTBUSY2,
                                                     uint32_t TTSL2) volatile
    {
        uint32_t curr = MAC_PPS2_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1u << 31u);
        curr |= (TRGTBUSY2 & 0b1u) << 31u;
        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (TTSL2 & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS2_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get MAC_PPS2_INTERVAL's PPSINT2 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS2_INTERVAL_PPSINT2() volatile
    {
        return (MAC_PPS2_INTERVAL >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS2_INTERVAL's PPSINT2 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline void set_MAC_PPS2_INTERVAL_PPSINT2(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS2_INTERVAL;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS2_INTERVAL = curr;
    }

    /**
     * Get MAC_PPS2_WIDTH's PPSWIDTH2 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS2_WIDTH_PPSWIDTH2() volatile
    {
        return (MAC_PPS2_WIDTH >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS2_WIDTH's PPSWIDTH2 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline void set_MAC_PPS2_WIDTH_PPSWIDTH2(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS2_WIDTH;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS2_WIDTH = curr;
    }

    /**
     * Get MAC_PPS3_TARGET_TIME_SECONDS's TSTRH3 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline uint32_t get_MAC_PPS3_TARGET_TIME_SECONDS_TSTRH3() volatile
    {
        return (MAC_PPS3_TARGET_TIME_SECONDS >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS3_TARGET_TIME_SECONDS's TSTRH3 field.
     *
     * PPS Target Time Seconds Register This field stores the time in seconds.
     */
    inline void set_MAC_PPS3_TARGET_TIME_SECONDS_TSTRH3(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS3_TARGET_TIME_SECONDS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS3_TARGET_TIME_SECONDS = curr;
    }

    /**
     * Get MAC_PPS3_TARGET_TIME_NANOSECONDS's TRGTBUSY3 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline bool get_MAC_PPS3_TARGET_TIME_NANOSECONDS_TRGTBUSY3() volatile
    {
        return MAC_PPS3_TARGET_TIME_NANOSECONDS & (1u << 31u);
    }

    /**
     * Set MAC_PPS3_TARGET_TIME_NANOSECONDS's TRGTBUSY3 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void set_MAC_PPS3_TARGET_TIME_NANOSECONDS_TRGTBUSY3() volatile
    {
        MAC_PPS3_TARGET_TIME_NANOSECONDS |= 1u << 31u;
    }

    /**
     * Clear MAC_PPS3_TARGET_TIME_NANOSECONDS's TRGTBUSY3 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void clear_MAC_PPS3_TARGET_TIME_NANOSECONDS_TRGTBUSY3() volatile
    {
        MAC_PPS3_TARGET_TIME_NANOSECONDS &= ~(1u << 31u);
    }

    /**
     * Toggle MAC_PPS3_TARGET_TIME_NANOSECONDS's TRGTBUSY3 bit.
     *
     * PPS Target Time Register Busy The MAC sets this bit when the PPSCMD0
     * field in the PPS_CONTROL register is programmed to 010 or 011.
     */
    inline void toggle_MAC_PPS3_TARGET_TIME_NANOSECONDS_TRGTBUSY3() volatile
    {
        MAC_PPS3_TARGET_TIME_NANOSECONDS ^= 1u << 31u;
    }

    /**
     * Get MAC_PPS3_TARGET_TIME_NANOSECONDS's TTSL3 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline uint32_t get_MAC_PPS3_TARGET_TIME_NANOSECONDS_TTSL3() volatile
    {
        return (MAC_PPS3_TARGET_TIME_NANOSECONDS >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS3_TARGET_TIME_NANOSECONDS's TTSL3 field.
     *
     * Target Time Low for PPS Register This register stores the time in
     * (signed) nanoseconds.
     */
    inline void set_MAC_PPS3_TARGET_TIME_NANOSECONDS_TTSL3(
        uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS3_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS3_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get all of MAC_PPS3_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS3 Target Time Nanoseconds
     */
    inline void get_MAC_PPS3_TARGET_TIME_NANOSECONDS(bool &TRGTBUSY3,
                                                     uint32_t &TTSL3) volatile
    {
        uint32_t curr = MAC_PPS3_TARGET_TIME_NANOSECONDS;

        TRGTBUSY3 = curr & (1u << 31u);
        TTSL3 = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Set all of MAC_PPS3_TARGET_TIME_NANOSECONDS's bit fields.
     *
     * (read-write) PPS3 Target Time Nanoseconds
     */
    inline void set_MAC_PPS3_TARGET_TIME_NANOSECONDS(bool TRGTBUSY3,
                                                     uint32_t TTSL3) volatile
    {
        uint32_t curr = MAC_PPS3_TARGET_TIME_NANOSECONDS;

        curr &= ~(0b1u << 31u);
        curr |= (TRGTBUSY3 & 0b1u) << 31u;
        curr &= ~(0b1111111111111111111111111111111u << 0u);
        curr |= (TTSL3 & 0b1111111111111111111111111111111u) << 0u;

        MAC_PPS3_TARGET_TIME_NANOSECONDS = curr;
    }

    /**
     * Get MAC_PPS3_INTERVAL's PPSINT3 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS3_INTERVAL_PPSINT3() volatile
    {
        return (MAC_PPS3_INTERVAL >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS3_INTERVAL's PPSINT3 field.
     *
     * PPS Output Signal Interval These bits store the interval between the
     * rising edges of PPS0 signal output.
     */
    inline void set_MAC_PPS3_INTERVAL_PPSINT3(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS3_INTERVAL;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS3_INTERVAL = curr;
    }

    /**
     * Get MAC_PPS3_WIDTH's PPSWIDTH3 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline uint32_t get_MAC_PPS3_WIDTH_PPSWIDTH3() volatile
    {
        return (MAC_PPS3_WIDTH >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_PPS3_WIDTH's PPSWIDTH3 field.
     *
     * PPS Output Signal Width These bits store the width between the rising
     * edge and corresponding falling edge of PPS0 signal output.
     */
    inline void set_MAC_PPS3_WIDTH_PPSWIDTH3(uint32_t value) volatile
    {
        uint32_t curr = MAC_PPS3_WIDTH;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_PPS3_WIDTH = curr;
    }

    /**
     * Get MAC_PTO_CONTROL's DN field.
     *
     * Domain Number This field indicates the domain Number in which the PTP
     * node is operating.
     */
    inline uint8_t get_MAC_PTO_CONTROL_DN() volatile
    {
        return (MAC_PTO_CONTROL >> 8u) & 0b11111111u;
    }

    /**
     * Set MAC_PTO_CONTROL's DN field.
     *
     * Domain Number This field indicates the domain Number in which the PTP
     * node is operating.
     */
    inline void set_MAC_PTO_CONTROL_DN(uint8_t value) volatile
    {
        uint32_t curr = MAC_PTO_CONTROL;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MAC_PTO_CONTROL = curr;
    }

    /**
     * Get MAC_PTO_CONTROL's PDRDIS bit.
     *
     * Disable Peer Delay Response response generation When this bit is set,
     * the Peer Delay Response (Pdelay_Resp) response is not be generated for
     * received Peer Delay Request (Pdelay_Req) request packet, as required by
     * the programmed mode.
     */
    inline bool get_MAC_PTO_CONTROL_PDRDIS() volatile
    {
        return MAC_PTO_CONTROL & (1u << 7u);
    }

    /**
     * Set MAC_PTO_CONTROL's PDRDIS bit.
     *
     * Disable Peer Delay Response response generation When this bit is set,
     * the Peer Delay Response (Pdelay_Resp) response is not be generated for
     * received Peer Delay Request (Pdelay_Req) request packet, as required by
     * the programmed mode.
     */
    inline void set_MAC_PTO_CONTROL_PDRDIS() volatile
    {
        MAC_PTO_CONTROL |= 1u << 7u;
    }

    /**
     * Clear MAC_PTO_CONTROL's PDRDIS bit.
     *
     * Disable Peer Delay Response response generation When this bit is set,
     * the Peer Delay Response (Pdelay_Resp) response is not be generated for
     * received Peer Delay Request (Pdelay_Req) request packet, as required by
     * the programmed mode.
     */
    inline void clear_MAC_PTO_CONTROL_PDRDIS() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 7u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's PDRDIS bit.
     *
     * Disable Peer Delay Response response generation When this bit is set,
     * the Peer Delay Response (Pdelay_Resp) response is not be generated for
     * received Peer Delay Request (Pdelay_Req) request packet, as required by
     * the programmed mode.
     */
    inline void toggle_MAC_PTO_CONTROL_PDRDIS() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 7u;
    }

    /**
     * Get MAC_PTO_CONTROL's DRRDIS bit.
     *
     * Disable PTO Delay Request/Response response generation When this bit is
     * set, the Delay Request and Delay response is not generated for received
     * SYNC and Delay request packet respectively, as required by the
     * programmed mode.
     */
    inline bool get_MAC_PTO_CONTROL_DRRDIS() volatile
    {
        return MAC_PTO_CONTROL & (1u << 6u);
    }

    /**
     * Set MAC_PTO_CONTROL's DRRDIS bit.
     *
     * Disable PTO Delay Request/Response response generation When this bit is
     * set, the Delay Request and Delay response is not generated for received
     * SYNC and Delay request packet respectively, as required by the
     * programmed mode.
     */
    inline void set_MAC_PTO_CONTROL_DRRDIS() volatile
    {
        MAC_PTO_CONTROL |= 1u << 6u;
    }

    /**
     * Clear MAC_PTO_CONTROL's DRRDIS bit.
     *
     * Disable PTO Delay Request/Response response generation When this bit is
     * set, the Delay Request and Delay response is not generated for received
     * SYNC and Delay request packet respectively, as required by the
     * programmed mode.
     */
    inline void clear_MAC_PTO_CONTROL_DRRDIS() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 6u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's DRRDIS bit.
     *
     * Disable PTO Delay Request/Response response generation When this bit is
     * set, the Delay Request and Delay response is not generated for received
     * SYNC and Delay request packet respectively, as required by the
     * programmed mode.
     */
    inline void toggle_MAC_PTO_CONTROL_DRRDIS() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 6u;
    }

    /**
     * Get MAC_PTO_CONTROL's APDREQTRIG bit.
     *
     * Automatic PTP Pdelay_Req message Trigger When this bit is set, one PTP
     * Pdelay_Req message is transmitted.
     */
    inline bool get_MAC_PTO_CONTROL_APDREQTRIG() volatile
    {
        return MAC_PTO_CONTROL & (1u << 5u);
    }

    /**
     * Set MAC_PTO_CONTROL's APDREQTRIG bit.
     *
     * Automatic PTP Pdelay_Req message Trigger When this bit is set, one PTP
     * Pdelay_Req message is transmitted.
     */
    inline void set_MAC_PTO_CONTROL_APDREQTRIG() volatile
    {
        MAC_PTO_CONTROL |= 1u << 5u;
    }

    /**
     * Clear MAC_PTO_CONTROL's APDREQTRIG bit.
     *
     * Automatic PTP Pdelay_Req message Trigger When this bit is set, one PTP
     * Pdelay_Req message is transmitted.
     */
    inline void clear_MAC_PTO_CONTROL_APDREQTRIG() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 5u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's APDREQTRIG bit.
     *
     * Automatic PTP Pdelay_Req message Trigger When this bit is set, one PTP
     * Pdelay_Req message is transmitted.
     */
    inline void toggle_MAC_PTO_CONTROL_APDREQTRIG() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 5u;
    }

    /**
     * Get MAC_PTO_CONTROL's ASYNCTRIG bit.
     *
     * Automatic PTP SYNC message Trigger When this bit is set, one PTP SYNC
     * message is transmitted.
     */
    inline bool get_MAC_PTO_CONTROL_ASYNCTRIG() volatile
    {
        return MAC_PTO_CONTROL & (1u << 4u);
    }

    /**
     * Set MAC_PTO_CONTROL's ASYNCTRIG bit.
     *
     * Automatic PTP SYNC message Trigger When this bit is set, one PTP SYNC
     * message is transmitted.
     */
    inline void set_MAC_PTO_CONTROL_ASYNCTRIG() volatile
    {
        MAC_PTO_CONTROL |= 1u << 4u;
    }

    /**
     * Clear MAC_PTO_CONTROL's ASYNCTRIG bit.
     *
     * Automatic PTP SYNC message Trigger When this bit is set, one PTP SYNC
     * message is transmitted.
     */
    inline void clear_MAC_PTO_CONTROL_ASYNCTRIG() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's ASYNCTRIG bit.
     *
     * Automatic PTP SYNC message Trigger When this bit is set, one PTP SYNC
     * message is transmitted.
     */
    inline void toggle_MAC_PTO_CONTROL_ASYNCTRIG() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 4u;
    }

    /**
     * Get MAC_PTO_CONTROL's APDREQEN bit.
     *
     * Automatic PTP Pdelay_Req message Enable When this bit is set, PTP
     * Pdelay_Req message is generated periodically based on interval
     * programmed or trigger from application, when the MAC is programmed to be
     * in Peer-to-Peer Transparent mode.
     */
    inline bool get_MAC_PTO_CONTROL_APDREQEN() volatile
    {
        return MAC_PTO_CONTROL & (1u << 2u);
    }

    /**
     * Set MAC_PTO_CONTROL's APDREQEN bit.
     *
     * Automatic PTP Pdelay_Req message Enable When this bit is set, PTP
     * Pdelay_Req message is generated periodically based on interval
     * programmed or trigger from application, when the MAC is programmed to be
     * in Peer-to-Peer Transparent mode.
     */
    inline void set_MAC_PTO_CONTROL_APDREQEN() volatile
    {
        MAC_PTO_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MAC_PTO_CONTROL's APDREQEN bit.
     *
     * Automatic PTP Pdelay_Req message Enable When this bit is set, PTP
     * Pdelay_Req message is generated periodically based on interval
     * programmed or trigger from application, when the MAC is programmed to be
     * in Peer-to-Peer Transparent mode.
     */
    inline void clear_MAC_PTO_CONTROL_APDREQEN() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's APDREQEN bit.
     *
     * Automatic PTP Pdelay_Req message Enable When this bit is set, PTP
     * Pdelay_Req message is generated periodically based on interval
     * programmed or trigger from application, when the MAC is programmed to be
     * in Peer-to-Peer Transparent mode.
     */
    inline void toggle_MAC_PTO_CONTROL_APDREQEN() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 2u;
    }

    /**
     * Get MAC_PTO_CONTROL's ASYNCEN bit.
     *
     * Automatic PTP SYNC message Enable When this bit is set, PTP SYNC message
     * is generated periodically based on interval programmed or trigger from
     * application, when the MAC is programmed to be in Clock Master mode.
     */
    inline bool get_MAC_PTO_CONTROL_ASYNCEN() volatile
    {
        return MAC_PTO_CONTROL & (1u << 1u);
    }

    /**
     * Set MAC_PTO_CONTROL's ASYNCEN bit.
     *
     * Automatic PTP SYNC message Enable When this bit is set, PTP SYNC message
     * is generated periodically based on interval programmed or trigger from
     * application, when the MAC is programmed to be in Clock Master mode.
     */
    inline void set_MAC_PTO_CONTROL_ASYNCEN() volatile
    {
        MAC_PTO_CONTROL |= 1u << 1u;
    }

    /**
     * Clear MAC_PTO_CONTROL's ASYNCEN bit.
     *
     * Automatic PTP SYNC message Enable When this bit is set, PTP SYNC message
     * is generated periodically based on interval programmed or trigger from
     * application, when the MAC is programmed to be in Clock Master mode.
     */
    inline void clear_MAC_PTO_CONTROL_ASYNCEN() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 1u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's ASYNCEN bit.
     *
     * Automatic PTP SYNC message Enable When this bit is set, PTP SYNC message
     * is generated periodically based on interval programmed or trigger from
     * application, when the MAC is programmed to be in Clock Master mode.
     */
    inline void toggle_MAC_PTO_CONTROL_ASYNCEN() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 1u;
    }

    /**
     * Get MAC_PTO_CONTROL's PTOEN bit.
     *
     * PTP Offload Enable When this bit is set, the PTP Offload feature is
     * enabled.
     */
    inline bool get_MAC_PTO_CONTROL_PTOEN() volatile
    {
        return MAC_PTO_CONTROL & (1u << 0u);
    }

    /**
     * Set MAC_PTO_CONTROL's PTOEN bit.
     *
     * PTP Offload Enable When this bit is set, the PTP Offload feature is
     * enabled.
     */
    inline void set_MAC_PTO_CONTROL_PTOEN() volatile
    {
        MAC_PTO_CONTROL |= 1u << 0u;
    }

    /**
     * Clear MAC_PTO_CONTROL's PTOEN bit.
     *
     * PTP Offload Enable When this bit is set, the PTP Offload feature is
     * enabled.
     */
    inline void clear_MAC_PTO_CONTROL_PTOEN() volatile
    {
        MAC_PTO_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle MAC_PTO_CONTROL's PTOEN bit.
     *
     * PTP Offload Enable When this bit is set, the PTP Offload feature is
     * enabled.
     */
    inline void toggle_MAC_PTO_CONTROL_PTOEN() volatile
    {
        MAC_PTO_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of MAC_PTO_CONTROL's bit fields.
     *
     * (read-write) PTP Offload Engine Control
     */
    inline void get_MAC_PTO_CONTROL(uint8_t &DN, bool &PDRDIS, bool &DRRDIS,
                                    bool &APDREQTRIG, bool &ASYNCTRIG,
                                    bool &APDREQEN, bool &ASYNCEN,
                                    bool &PTOEN) volatile
    {
        uint32_t curr = MAC_PTO_CONTROL;

        DN = (curr >> 8u) & 0b11111111u;
        PDRDIS = curr & (1u << 7u);
        DRRDIS = curr & (1u << 6u);
        APDREQTRIG = curr & (1u << 5u);
        ASYNCTRIG = curr & (1u << 4u);
        APDREQEN = curr & (1u << 2u);
        ASYNCEN = curr & (1u << 1u);
        PTOEN = curr & (1u << 0u);
    }

    /**
     * Set all of MAC_PTO_CONTROL's bit fields.
     *
     * (read-write) PTP Offload Engine Control
     */
    inline void set_MAC_PTO_CONTROL(uint8_t DN, bool PDRDIS, bool DRRDIS,
                                    bool APDREQTRIG, bool ASYNCTRIG,
                                    bool APDREQEN, bool ASYNCEN,
                                    bool PTOEN) volatile
    {
        uint32_t curr = MAC_PTO_CONTROL;

        curr &= ~(0b11111111u << 8u);
        curr |= (DN & 0b11111111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (PDRDIS & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DRRDIS & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (APDREQTRIG & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ASYNCTRIG & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (APDREQEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ASYNCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PTOEN & 0b1u) << 0u;

        MAC_PTO_CONTROL = curr;
    }

    /**
     * Get MAC_SOURCE_PORT_IDENTITY0's SPI0 field.
     *
     * Source Port Identity 0 This field indicates bits [31:0] of
     * sourcePortIdentity of PTP node.
     */
    inline uint32_t get_MAC_SOURCE_PORT_IDENTITY0_SPI0() volatile
    {
        return (MAC_SOURCE_PORT_IDENTITY0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_SOURCE_PORT_IDENTITY0's SPI0 field.
     *
     * Source Port Identity 0 This field indicates bits [31:0] of
     * sourcePortIdentity of PTP node.
     */
    inline void set_MAC_SOURCE_PORT_IDENTITY0_SPI0(uint32_t value) volatile
    {
        uint32_t curr = MAC_SOURCE_PORT_IDENTITY0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_SOURCE_PORT_IDENTITY0 = curr;
    }

    /**
     * Get MAC_SOURCE_PORT_IDENTITY1's SPI1 field.
     *
     * Source Port Identity 1 This field indicates bits [63:32] of
     * sourcePortIdentity of PTP node.
     */
    inline uint32_t get_MAC_SOURCE_PORT_IDENTITY1_SPI1() volatile
    {
        return (MAC_SOURCE_PORT_IDENTITY1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MAC_SOURCE_PORT_IDENTITY1's SPI1 field.
     *
     * Source Port Identity 1 This field indicates bits [63:32] of
     * sourcePortIdentity of PTP node.
     */
    inline void set_MAC_SOURCE_PORT_IDENTITY1_SPI1(uint32_t value) volatile
    {
        uint32_t curr = MAC_SOURCE_PORT_IDENTITY1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MAC_SOURCE_PORT_IDENTITY1 = curr;
    }

    /**
     * Get MAC_SOURCE_PORT_IDENTITY2's SPI2 field.
     *
     * Source Port Identity 2 This field indicates bits [79:64] of
     * sourcePortIdentity of PTP node.
     */
    inline uint16_t get_MAC_SOURCE_PORT_IDENTITY2_SPI2() volatile
    {
        return (MAC_SOURCE_PORT_IDENTITY2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MAC_SOURCE_PORT_IDENTITY2's SPI2 field.
     *
     * Source Port Identity 2 This field indicates bits [79:64] of
     * sourcePortIdentity of PTP node.
     */
    inline void set_MAC_SOURCE_PORT_IDENTITY2_SPI2(uint16_t value) volatile
    {
        uint32_t curr = MAC_SOURCE_PORT_IDENTITY2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MAC_SOURCE_PORT_IDENTITY2 = curr;
    }

    /**
     * Get MAC_LOG_MESSAGE_INTERVAL's LMPDRI field.
     *
     * Log Min Pdelay_Req Interval This field indicates logMinPdelayReqInterval
     * of PTP node.
     */
    inline uint8_t get_MAC_LOG_MESSAGE_INTERVAL_LMPDRI() volatile
    {
        return (MAC_LOG_MESSAGE_INTERVAL >> 24u) & 0b11111111u;
    }

    /**
     * Set MAC_LOG_MESSAGE_INTERVAL's LMPDRI field.
     *
     * Log Min Pdelay_Req Interval This field indicates logMinPdelayReqInterval
     * of PTP node.
     */
    inline void set_MAC_LOG_MESSAGE_INTERVAL_LMPDRI(uint8_t value) volatile
    {
        uint32_t curr = MAC_LOG_MESSAGE_INTERVAL;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        MAC_LOG_MESSAGE_INTERVAL = curr;
    }

    /**
     * Get MAC_LOG_MESSAGE_INTERVAL's DRSYNCR field.
     *
     * Delay_Req to SYNC Ratio In Slave mode, it is used for controlling
     * frequency of Delay_Req messages transmitted.
     */
    inline ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR
    get_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR() volatile
    {
        return ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR(
            (MAC_LOG_MESSAGE_INTERVAL >> 8u) & 0b111u);
    }

    /**
     * Set MAC_LOG_MESSAGE_INTERVAL's DRSYNCR field.
     *
     * Delay_Req to SYNC Ratio In Slave mode, it is used for controlling
     * frequency of Delay_Req messages transmitted.
     */
    inline void set_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR(
        ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR value) volatile
    {
        uint32_t curr = MAC_LOG_MESSAGE_INTERVAL;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        MAC_LOG_MESSAGE_INTERVAL = curr;
    }

    /**
     * Get MAC_LOG_MESSAGE_INTERVAL's LSI field.
     *
     * Log Sync Interval This field indicates the periodicity of the
     * automatically generated SYNC message when the PTP node is Master.
     */
    inline uint8_t get_MAC_LOG_MESSAGE_INTERVAL_LSI() volatile
    {
        return (MAC_LOG_MESSAGE_INTERVAL >> 0u) & 0b11111111u;
    }

    /**
     * Set MAC_LOG_MESSAGE_INTERVAL's LSI field.
     *
     * Log Sync Interval This field indicates the periodicity of the
     * automatically generated SYNC message when the PTP node is Master.
     */
    inline void set_MAC_LOG_MESSAGE_INTERVAL_LSI(uint8_t value) volatile
    {
        uint32_t curr = MAC_LOG_MESSAGE_INTERVAL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MAC_LOG_MESSAGE_INTERVAL = curr;
    }

    /**
     * Get all of MAC_LOG_MESSAGE_INTERVAL's bit fields.
     *
     * (read-write) Log Message Interval
     */
    inline void get_MAC_LOG_MESSAGE_INTERVAL(
        uint8_t &LMPDRI, ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR &DRSYNCR,
        uint8_t &LSI) volatile
    {
        uint32_t curr = MAC_LOG_MESSAGE_INTERVAL;

        LMPDRI = (curr >> 24u) & 0b11111111u;
        DRSYNCR =
            ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR((curr >> 8u) & 0b111u);
        LSI = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of MAC_LOG_MESSAGE_INTERVAL's bit fields.
     *
     * (read-write) Log Message Interval
     */
    inline void set_MAC_LOG_MESSAGE_INTERVAL(
        uint8_t LMPDRI, ENET_QOS_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR DRSYNCR,
        uint8_t LSI) volatile
    {
        uint32_t curr = MAC_LOG_MESSAGE_INTERVAL;

        curr &= ~(0b11111111u << 24u);
        curr |= (LMPDRI & 0b11111111u) << 24u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(DRSYNCR) & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (LSI & 0b11111111u) << 0u;

        MAC_LOG_MESSAGE_INTERVAL = curr;
    }

    /**
     * Get MTL_OPERATION_MODE's FRPE bit.
     *
     * Flexible Rx parser Enable When this bit is set to 1, the Programmable Rx
     * Parser functionality is enabled.
     */
    inline bool get_MTL_OPERATION_MODE_FRPE() volatile
    {
        return MTL_OPERATION_MODE & (1u << 15u);
    }

    /**
     * Set MTL_OPERATION_MODE's FRPE bit.
     *
     * Flexible Rx parser Enable When this bit is set to 1, the Programmable Rx
     * Parser functionality is enabled.
     */
    inline void set_MTL_OPERATION_MODE_FRPE() volatile
    {
        MTL_OPERATION_MODE |= 1u << 15u;
    }

    /**
     * Clear MTL_OPERATION_MODE's FRPE bit.
     *
     * Flexible Rx parser Enable When this bit is set to 1, the Programmable Rx
     * Parser functionality is enabled.
     */
    inline void clear_MTL_OPERATION_MODE_FRPE() volatile
    {
        MTL_OPERATION_MODE &= ~(1u << 15u);
    }

    /**
     * Toggle MTL_OPERATION_MODE's FRPE bit.
     *
     * Flexible Rx parser Enable When this bit is set to 1, the Programmable Rx
     * Parser functionality is enabled.
     */
    inline void toggle_MTL_OPERATION_MODE_FRPE() volatile
    {
        MTL_OPERATION_MODE ^= 1u << 15u;
    }

    /**
     * Get MTL_OPERATION_MODE's CNTCLR bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline bool get_MTL_OPERATION_MODE_CNTCLR() volatile
    {
        return MTL_OPERATION_MODE & (1u << 9u);
    }

    /**
     * Set MTL_OPERATION_MODE's CNTCLR bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline void set_MTL_OPERATION_MODE_CNTCLR() volatile
    {
        MTL_OPERATION_MODE |= 1u << 9u;
    }

    /**
     * Clear MTL_OPERATION_MODE's CNTCLR bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline void clear_MTL_OPERATION_MODE_CNTCLR() volatile
    {
        MTL_OPERATION_MODE &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_OPERATION_MODE's CNTCLR bit.
     *
     * Counters Reset When this bit is set, all counters are reset.
     */
    inline void toggle_MTL_OPERATION_MODE_CNTCLR() volatile
    {
        MTL_OPERATION_MODE ^= 1u << 9u;
    }

    /**
     * Get MTL_OPERATION_MODE's CNTPRST bit.
     *
     * Counters Preset When this bit is set, - MTL_TxQ[0-7]_Underflow register
     * is initialized/preset to 12'h7F0.
     */
    inline bool get_MTL_OPERATION_MODE_CNTPRST() volatile
    {
        return MTL_OPERATION_MODE & (1u << 8u);
    }

    /**
     * Set MTL_OPERATION_MODE's CNTPRST bit.
     *
     * Counters Preset When this bit is set, - MTL_TxQ[0-7]_Underflow register
     * is initialized/preset to 12'h7F0.
     */
    inline void set_MTL_OPERATION_MODE_CNTPRST() volatile
    {
        MTL_OPERATION_MODE |= 1u << 8u;
    }

    /**
     * Clear MTL_OPERATION_MODE's CNTPRST bit.
     *
     * Counters Preset When this bit is set, - MTL_TxQ[0-7]_Underflow register
     * is initialized/preset to 12'h7F0.
     */
    inline void clear_MTL_OPERATION_MODE_CNTPRST() volatile
    {
        MTL_OPERATION_MODE &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_OPERATION_MODE's CNTPRST bit.
     *
     * Counters Preset When this bit is set, - MTL_TxQ[0-7]_Underflow register
     * is initialized/preset to 12'h7F0.
     */
    inline void toggle_MTL_OPERATION_MODE_CNTPRST() volatile
    {
        MTL_OPERATION_MODE ^= 1u << 8u;
    }

    /**
     * Get MTL_OPERATION_MODE's SCHALG field.
     *
     * Tx Scheduling Algorithm This field indicates the algorithm for Tx
     * scheduling:
     */
    inline ENET_QOS_MTL_OPERATION_MODE_SCHALG
    get_MTL_OPERATION_MODE_SCHALG() volatile
    {
        return ENET_QOS_MTL_OPERATION_MODE_SCHALG((MTL_OPERATION_MODE >> 5u) &
                                                  0b11u);
    }

    /**
     * Set MTL_OPERATION_MODE's SCHALG field.
     *
     * Tx Scheduling Algorithm This field indicates the algorithm for Tx
     * scheduling:
     */
    inline void set_MTL_OPERATION_MODE_SCHALG(
        ENET_QOS_MTL_OPERATION_MODE_SCHALG value) volatile
    {
        uint32_t curr = MTL_OPERATION_MODE;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        MTL_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_OPERATION_MODE's RAA bit.
     *
     * Receive Arbitration Algorithm This field is used to select the
     * arbitration algorithm for the Rx side.
     */
    inline bool get_MTL_OPERATION_MODE_RAA() volatile
    {
        return MTL_OPERATION_MODE & (1u << 2u);
    }

    /**
     * Set MTL_OPERATION_MODE's RAA bit.
     *
     * Receive Arbitration Algorithm This field is used to select the
     * arbitration algorithm for the Rx side.
     */
    inline void set_MTL_OPERATION_MODE_RAA() volatile
    {
        MTL_OPERATION_MODE |= 1u << 2u;
    }

    /**
     * Clear MTL_OPERATION_MODE's RAA bit.
     *
     * Receive Arbitration Algorithm This field is used to select the
     * arbitration algorithm for the Rx side.
     */
    inline void clear_MTL_OPERATION_MODE_RAA() volatile
    {
        MTL_OPERATION_MODE &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_OPERATION_MODE's RAA bit.
     *
     * Receive Arbitration Algorithm This field is used to select the
     * arbitration algorithm for the Rx side.
     */
    inline void toggle_MTL_OPERATION_MODE_RAA() volatile
    {
        MTL_OPERATION_MODE ^= 1u << 2u;
    }

    /**
     * Get MTL_OPERATION_MODE's DTXSTS bit.
     *
     * Drop Transmit Status When this bit is set, the Tx packet status received
     * from the MAC is dropped in the MTL.
     */
    inline bool get_MTL_OPERATION_MODE_DTXSTS() volatile
    {
        return MTL_OPERATION_MODE & (1u << 1u);
    }

    /**
     * Set MTL_OPERATION_MODE's DTXSTS bit.
     *
     * Drop Transmit Status When this bit is set, the Tx packet status received
     * from the MAC is dropped in the MTL.
     */
    inline void set_MTL_OPERATION_MODE_DTXSTS() volatile
    {
        MTL_OPERATION_MODE |= 1u << 1u;
    }

    /**
     * Clear MTL_OPERATION_MODE's DTXSTS bit.
     *
     * Drop Transmit Status When this bit is set, the Tx packet status received
     * from the MAC is dropped in the MTL.
     */
    inline void clear_MTL_OPERATION_MODE_DTXSTS() volatile
    {
        MTL_OPERATION_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_OPERATION_MODE's DTXSTS bit.
     *
     * Drop Transmit Status When this bit is set, the Tx packet status received
     * from the MAC is dropped in the MTL.
     */
    inline void toggle_MTL_OPERATION_MODE_DTXSTS() volatile
    {
        MTL_OPERATION_MODE ^= 1u << 1u;
    }

    /**
     * Get all of MTL_OPERATION_MODE's bit fields.
     *
     * (read-write) MTL Operation Mode
     */
    inline void get_MTL_OPERATION_MODE(
        bool &FRPE, bool &CNTCLR, bool &CNTPRST,
        ENET_QOS_MTL_OPERATION_MODE_SCHALG &SCHALG, bool &RAA,
        bool &DTXSTS) volatile
    {
        uint32_t curr = MTL_OPERATION_MODE;

        FRPE = curr & (1u << 15u);
        CNTCLR = curr & (1u << 9u);
        CNTPRST = curr & (1u << 8u);
        SCHALG = ENET_QOS_MTL_OPERATION_MODE_SCHALG((curr >> 5u) & 0b11u);
        RAA = curr & (1u << 2u);
        DTXSTS = curr & (1u << 1u);
    }

    /**
     * Set all of MTL_OPERATION_MODE's bit fields.
     *
     * (read-write) MTL Operation Mode
     */
    inline void set_MTL_OPERATION_MODE(
        bool FRPE, bool CNTCLR, bool CNTPRST,
        ENET_QOS_MTL_OPERATION_MODE_SCHALG SCHALG, bool RAA,
        bool DTXSTS) volatile
    {
        uint32_t curr = MTL_OPERATION_MODE;

        curr &= ~(0b1u << 15u);
        curr |= (FRPE & 0b1u) << 15u;
        curr &= ~(0b1u << 9u);
        curr |= (CNTCLR & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CNTPRST & 0b1u) << 8u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(SCHALG) & 0b11u) << 5u;
        curr &= ~(0b1u << 2u);
        curr |= (RAA & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DTXSTS & 0b1u) << 1u;

        MTL_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_DBG_CTL's STSIE bit.
     *
     * Transmit Status Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when Transmit status is available in slave
     * mode.
     */
    inline bool get_MTL_DBG_CTL_STSIE() volatile
    {
        return MTL_DBG_CTL & (1u << 15u);
    }

    /**
     * Set MTL_DBG_CTL's STSIE bit.
     *
     * Transmit Status Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when Transmit status is available in slave
     * mode.
     */
    inline void set_MTL_DBG_CTL_STSIE() volatile
    {
        MTL_DBG_CTL |= 1u << 15u;
    }

    /**
     * Clear MTL_DBG_CTL's STSIE bit.
     *
     * Transmit Status Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when Transmit status is available in slave
     * mode.
     */
    inline void clear_MTL_DBG_CTL_STSIE() volatile
    {
        MTL_DBG_CTL &= ~(1u << 15u);
    }

    /**
     * Toggle MTL_DBG_CTL's STSIE bit.
     *
     * Transmit Status Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when Transmit status is available in slave
     * mode.
     */
    inline void toggle_MTL_DBG_CTL_STSIE() volatile
    {
        MTL_DBG_CTL ^= 1u << 15u;
    }

    /**
     * Get MTL_DBG_CTL's PKTIE bit.
     *
     * Receive Packet Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when EOP of received packet is written to the
     * Rx FIFO.
     */
    inline bool get_MTL_DBG_CTL_PKTIE() volatile
    {
        return MTL_DBG_CTL & (1u << 14u);
    }

    /**
     * Set MTL_DBG_CTL's PKTIE bit.
     *
     * Receive Packet Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when EOP of received packet is written to the
     * Rx FIFO.
     */
    inline void set_MTL_DBG_CTL_PKTIE() volatile
    {
        MTL_DBG_CTL |= 1u << 14u;
    }

    /**
     * Clear MTL_DBG_CTL's PKTIE bit.
     *
     * Receive Packet Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when EOP of received packet is written to the
     * Rx FIFO.
     */
    inline void clear_MTL_DBG_CTL_PKTIE() volatile
    {
        MTL_DBG_CTL &= ~(1u << 14u);
    }

    /**
     * Toggle MTL_DBG_CTL's PKTIE bit.
     *
     * Receive Packet Available Interrupt Status Enable When this bit is set,
     * an interrupt is generated when EOP of received packet is written to the
     * Rx FIFO.
     */
    inline void toggle_MTL_DBG_CTL_PKTIE() volatile
    {
        MTL_DBG_CTL ^= 1u << 14u;
    }

    /**
     * Get MTL_DBG_CTL's FIFOSEL field.
     *
     * FIFO Selected for Access This field indicates the FIFO selected for
     * debug access:
     */
    inline ENET_QOS_MTL_DBG_CTL_FIFOSEL get_MTL_DBG_CTL_FIFOSEL() volatile
    {
        return ENET_QOS_MTL_DBG_CTL_FIFOSEL((MTL_DBG_CTL >> 12u) & 0b11u);
    }

    /**
     * Set MTL_DBG_CTL's FIFOSEL field.
     *
     * FIFO Selected for Access This field indicates the FIFO selected for
     * debug access:
     */
    inline void set_MTL_DBG_CTL_FIFOSEL(
        ENET_QOS_MTL_DBG_CTL_FIFOSEL value) volatile
    {
        uint32_t curr = MTL_DBG_CTL;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        MTL_DBG_CTL = curr;
    }

    /**
     * Get MTL_DBG_CTL's FIFOWREN bit.
     *
     * FIFO Write Enable When this bit is set, it enables the Write operation
     * on selected FIFO when FIFO Debug Access is enabled.
     */
    inline bool get_MTL_DBG_CTL_FIFOWREN() volatile
    {
        return MTL_DBG_CTL & (1u << 11u);
    }

    /**
     * Set MTL_DBG_CTL's FIFOWREN bit.
     *
     * FIFO Write Enable When this bit is set, it enables the Write operation
     * on selected FIFO when FIFO Debug Access is enabled.
     */
    inline void set_MTL_DBG_CTL_FIFOWREN() volatile
    {
        MTL_DBG_CTL |= 1u << 11u;
    }

    /**
     * Clear MTL_DBG_CTL's FIFOWREN bit.
     *
     * FIFO Write Enable When this bit is set, it enables the Write operation
     * on selected FIFO when FIFO Debug Access is enabled.
     */
    inline void clear_MTL_DBG_CTL_FIFOWREN() volatile
    {
        MTL_DBG_CTL &= ~(1u << 11u);
    }

    /**
     * Toggle MTL_DBG_CTL's FIFOWREN bit.
     *
     * FIFO Write Enable When this bit is set, it enables the Write operation
     * on selected FIFO when FIFO Debug Access is enabled.
     */
    inline void toggle_MTL_DBG_CTL_FIFOWREN() volatile
    {
        MTL_DBG_CTL ^= 1u << 11u;
    }

    /**
     * Get MTL_DBG_CTL's FIFORDEN bit.
     *
     * FIFO Read Enable When this bit is set, it enables the Read operation on
     * selected FIFO when FIFO Debug Access is enabled.
     */
    inline bool get_MTL_DBG_CTL_FIFORDEN() volatile
    {
        return MTL_DBG_CTL & (1u << 10u);
    }

    /**
     * Set MTL_DBG_CTL's FIFORDEN bit.
     *
     * FIFO Read Enable When this bit is set, it enables the Read operation on
     * selected FIFO when FIFO Debug Access is enabled.
     */
    inline void set_MTL_DBG_CTL_FIFORDEN() volatile
    {
        MTL_DBG_CTL |= 1u << 10u;
    }

    /**
     * Clear MTL_DBG_CTL's FIFORDEN bit.
     *
     * FIFO Read Enable When this bit is set, it enables the Read operation on
     * selected FIFO when FIFO Debug Access is enabled.
     */
    inline void clear_MTL_DBG_CTL_FIFORDEN() volatile
    {
        MTL_DBG_CTL &= ~(1u << 10u);
    }

    /**
     * Toggle MTL_DBG_CTL's FIFORDEN bit.
     *
     * FIFO Read Enable When this bit is set, it enables the Read operation on
     * selected FIFO when FIFO Debug Access is enabled.
     */
    inline void toggle_MTL_DBG_CTL_FIFORDEN() volatile
    {
        MTL_DBG_CTL ^= 1u << 10u;
    }

    /**
     * Get MTL_DBG_CTL's RSTSEL bit.
     *
     * Reset Pointers of Selected FIFO When this bit is set, the pointers of
     * the currently-selected FIFO are reset when FIFO Debug Access is enabled.
     */
    inline bool get_MTL_DBG_CTL_RSTSEL() volatile
    {
        return MTL_DBG_CTL & (1u << 9u);
    }

    /**
     * Set MTL_DBG_CTL's RSTSEL bit.
     *
     * Reset Pointers of Selected FIFO When this bit is set, the pointers of
     * the currently-selected FIFO are reset when FIFO Debug Access is enabled.
     */
    inline void set_MTL_DBG_CTL_RSTSEL() volatile
    {
        MTL_DBG_CTL |= 1u << 9u;
    }

    /**
     * Clear MTL_DBG_CTL's RSTSEL bit.
     *
     * Reset Pointers of Selected FIFO When this bit is set, the pointers of
     * the currently-selected FIFO are reset when FIFO Debug Access is enabled.
     */
    inline void clear_MTL_DBG_CTL_RSTSEL() volatile
    {
        MTL_DBG_CTL &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_DBG_CTL's RSTSEL bit.
     *
     * Reset Pointers of Selected FIFO When this bit is set, the pointers of
     * the currently-selected FIFO are reset when FIFO Debug Access is enabled.
     */
    inline void toggle_MTL_DBG_CTL_RSTSEL() volatile
    {
        MTL_DBG_CTL ^= 1u << 9u;
    }

    /**
     * Get MTL_DBG_CTL's RSTALL bit.
     *
     * Reset All Pointers When this bit is set, the pointers of all FIFOs are
     * reset when FIFO Debug Access is enabled.
     */
    inline bool get_MTL_DBG_CTL_RSTALL() volatile
    {
        return MTL_DBG_CTL & (1u << 8u);
    }

    /**
     * Set MTL_DBG_CTL's RSTALL bit.
     *
     * Reset All Pointers When this bit is set, the pointers of all FIFOs are
     * reset when FIFO Debug Access is enabled.
     */
    inline void set_MTL_DBG_CTL_RSTALL() volatile
    {
        MTL_DBG_CTL |= 1u << 8u;
    }

    /**
     * Clear MTL_DBG_CTL's RSTALL bit.
     *
     * Reset All Pointers When this bit is set, the pointers of all FIFOs are
     * reset when FIFO Debug Access is enabled.
     */
    inline void clear_MTL_DBG_CTL_RSTALL() volatile
    {
        MTL_DBG_CTL &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_DBG_CTL's RSTALL bit.
     *
     * Reset All Pointers When this bit is set, the pointers of all FIFOs are
     * reset when FIFO Debug Access is enabled.
     */
    inline void toggle_MTL_DBG_CTL_RSTALL() volatile
    {
        MTL_DBG_CTL ^= 1u << 8u;
    }

    /**
     * Get MTL_DBG_CTL's PKTSTATE field.
     *
     * Encoded Packet State This field is used to write the control information
     * to the Tx FIFO or Rx FIFO.
     */
    inline ENET_QOS_MTL_DBG_CTL_PKTSTATE get_MTL_DBG_CTL_PKTSTATE() volatile
    {
        return ENET_QOS_MTL_DBG_CTL_PKTSTATE((MTL_DBG_CTL >> 5u) & 0b11u);
    }

    /**
     * Set MTL_DBG_CTL's PKTSTATE field.
     *
     * Encoded Packet State This field is used to write the control information
     * to the Tx FIFO or Rx FIFO.
     */
    inline void set_MTL_DBG_CTL_PKTSTATE(
        ENET_QOS_MTL_DBG_CTL_PKTSTATE value) volatile
    {
        uint32_t curr = MTL_DBG_CTL;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        MTL_DBG_CTL = curr;
    }

    /**
     * Get MTL_DBG_CTL's BYTEEN field.
     *
     * Byte Enables This field indicates the number of data bytes valid in the
     * data register during Write operation.
     */
    inline ENET_QOS_MTL_DBG_CTL_BYTEEN get_MTL_DBG_CTL_BYTEEN() volatile
    {
        return ENET_QOS_MTL_DBG_CTL_BYTEEN((MTL_DBG_CTL >> 2u) & 0b11u);
    }

    /**
     * Set MTL_DBG_CTL's BYTEEN field.
     *
     * Byte Enables This field indicates the number of data bytes valid in the
     * data register during Write operation.
     */
    inline void set_MTL_DBG_CTL_BYTEEN(
        ENET_QOS_MTL_DBG_CTL_BYTEEN value) volatile
    {
        uint32_t curr = MTL_DBG_CTL;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MTL_DBG_CTL = curr;
    }

    /**
     * Get MTL_DBG_CTL's DBGMOD bit.
     *
     * Debug Mode Access to FIFO When this bit is set, it indicates that the
     * current access to the FIFO is read, write, and debug access.
     */
    inline bool get_MTL_DBG_CTL_DBGMOD() volatile
    {
        return MTL_DBG_CTL & (1u << 1u);
    }

    /**
     * Set MTL_DBG_CTL's DBGMOD bit.
     *
     * Debug Mode Access to FIFO When this bit is set, it indicates that the
     * current access to the FIFO is read, write, and debug access.
     */
    inline void set_MTL_DBG_CTL_DBGMOD() volatile
    {
        MTL_DBG_CTL |= 1u << 1u;
    }

    /**
     * Clear MTL_DBG_CTL's DBGMOD bit.
     *
     * Debug Mode Access to FIFO When this bit is set, it indicates that the
     * current access to the FIFO is read, write, and debug access.
     */
    inline void clear_MTL_DBG_CTL_DBGMOD() volatile
    {
        MTL_DBG_CTL &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_DBG_CTL's DBGMOD bit.
     *
     * Debug Mode Access to FIFO When this bit is set, it indicates that the
     * current access to the FIFO is read, write, and debug access.
     */
    inline void toggle_MTL_DBG_CTL_DBGMOD() volatile
    {
        MTL_DBG_CTL ^= 1u << 1u;
    }

    /**
     * Get MTL_DBG_CTL's FDBGEN bit.
     *
     * FIFO Debug Access Enable When this bit is set, it indicates that the
     * debug mode access to the FIFO is enabled.
     */
    inline bool get_MTL_DBG_CTL_FDBGEN() volatile
    {
        return MTL_DBG_CTL & (1u << 0u);
    }

    /**
     * Set MTL_DBG_CTL's FDBGEN bit.
     *
     * FIFO Debug Access Enable When this bit is set, it indicates that the
     * debug mode access to the FIFO is enabled.
     */
    inline void set_MTL_DBG_CTL_FDBGEN() volatile
    {
        MTL_DBG_CTL |= 1u << 0u;
    }

    /**
     * Clear MTL_DBG_CTL's FDBGEN bit.
     *
     * FIFO Debug Access Enable When this bit is set, it indicates that the
     * debug mode access to the FIFO is enabled.
     */
    inline void clear_MTL_DBG_CTL_FDBGEN() volatile
    {
        MTL_DBG_CTL &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_DBG_CTL's FDBGEN bit.
     *
     * FIFO Debug Access Enable When this bit is set, it indicates that the
     * debug mode access to the FIFO is enabled.
     */
    inline void toggle_MTL_DBG_CTL_FDBGEN() volatile
    {
        MTL_DBG_CTL ^= 1u << 0u;
    }

    /**
     * Get all of MTL_DBG_CTL's bit fields.
     *
     * (read-write) FIFO Debug Access Control and Status
     */
    inline void get_MTL_DBG_CTL(bool &STSIE, bool &PKTIE,
                                ENET_QOS_MTL_DBG_CTL_FIFOSEL &FIFOSEL,
                                bool &FIFOWREN, bool &FIFORDEN, bool &RSTSEL,
                                bool &RSTALL,
                                ENET_QOS_MTL_DBG_CTL_PKTSTATE &PKTSTATE,
                                ENET_QOS_MTL_DBG_CTL_BYTEEN &BYTEEN,
                                bool &DBGMOD, bool &FDBGEN) volatile
    {
        uint32_t curr = MTL_DBG_CTL;

        STSIE = curr & (1u << 15u);
        PKTIE = curr & (1u << 14u);
        FIFOSEL = ENET_QOS_MTL_DBG_CTL_FIFOSEL((curr >> 12u) & 0b11u);
        FIFOWREN = curr & (1u << 11u);
        FIFORDEN = curr & (1u << 10u);
        RSTSEL = curr & (1u << 9u);
        RSTALL = curr & (1u << 8u);
        PKTSTATE = ENET_QOS_MTL_DBG_CTL_PKTSTATE((curr >> 5u) & 0b11u);
        BYTEEN = ENET_QOS_MTL_DBG_CTL_BYTEEN((curr >> 2u) & 0b11u);
        DBGMOD = curr & (1u << 1u);
        FDBGEN = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_DBG_CTL's bit fields.
     *
     * (read-write) FIFO Debug Access Control and Status
     */
    inline void set_MTL_DBG_CTL(bool STSIE, bool PKTIE,
                                ENET_QOS_MTL_DBG_CTL_FIFOSEL FIFOSEL,
                                bool FIFOWREN, bool FIFORDEN, bool RSTSEL,
                                bool RSTALL,
                                ENET_QOS_MTL_DBG_CTL_PKTSTATE PKTSTATE,
                                ENET_QOS_MTL_DBG_CTL_BYTEEN BYTEEN,
                                bool DBGMOD, bool FDBGEN) volatile
    {
        uint32_t curr = MTL_DBG_CTL;

        curr &= ~(0b1u << 15u);
        curr |= (STSIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (PKTIE & 0b1u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(FIFOSEL) & 0b11u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (FIFOWREN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (FIFORDEN & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RSTSEL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSTALL & 0b1u) << 8u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(PKTSTATE) & 0b11u) << 5u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(BYTEEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DBGMOD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FDBGEN & 0b1u) << 0u;

        MTL_DBG_CTL = curr;
    }

    /**
     * Get MTL_DBG_STS's LOCR field.
     *
     * Remaining Locations in the FIFO Slave Access Mode: This field indicates
     * the space available in selected FIFO.
     */
    inline uint32_t get_MTL_DBG_STS_LOCR() volatile
    {
        return (MTL_DBG_STS >> 15u) & 0b11111111111111111u;
    }

    /**
     * Get MTL_DBG_STS's STSI bit.
     *
     * Transmit Status Available Interrupt Status When set, this bit indicates
     * that the Slave mode Tx packet is transmitted, and the status is
     * available in Tx Status FIFO.
     */
    inline bool get_MTL_DBG_STS_STSI() volatile
    {
        return MTL_DBG_STS & (1u << 9u);
    }

    /**
     * Set MTL_DBG_STS's STSI bit.
     *
     * Transmit Status Available Interrupt Status When set, this bit indicates
     * that the Slave mode Tx packet is transmitted, and the status is
     * available in Tx Status FIFO.
     */
    inline void set_MTL_DBG_STS_STSI() volatile
    {
        MTL_DBG_STS |= 1u << 9u;
    }

    /**
     * Clear MTL_DBG_STS's STSI bit.
     *
     * Transmit Status Available Interrupt Status When set, this bit indicates
     * that the Slave mode Tx packet is transmitted, and the status is
     * available in Tx Status FIFO.
     */
    inline void clear_MTL_DBG_STS_STSI() volatile
    {
        MTL_DBG_STS &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_DBG_STS's STSI bit.
     *
     * Transmit Status Available Interrupt Status When set, this bit indicates
     * that the Slave mode Tx packet is transmitted, and the status is
     * available in Tx Status FIFO.
     */
    inline void toggle_MTL_DBG_STS_STSI() volatile
    {
        MTL_DBG_STS ^= 1u << 9u;
    }

    /**
     * Get MTL_DBG_STS's PKTI bit.
     *
     * Receive Packet Available Interrupt Status When set, this bit indicates
     * that MAC layer has written the EOP of received packet to the Rx FIFO.
     */
    inline bool get_MTL_DBG_STS_PKTI() volatile
    {
        return MTL_DBG_STS & (1u << 8u);
    }

    /**
     * Set MTL_DBG_STS's PKTI bit.
     *
     * Receive Packet Available Interrupt Status When set, this bit indicates
     * that MAC layer has written the EOP of received packet to the Rx FIFO.
     */
    inline void set_MTL_DBG_STS_PKTI() volatile
    {
        MTL_DBG_STS |= 1u << 8u;
    }

    /**
     * Clear MTL_DBG_STS's PKTI bit.
     *
     * Receive Packet Available Interrupt Status When set, this bit indicates
     * that MAC layer has written the EOP of received packet to the Rx FIFO.
     */
    inline void clear_MTL_DBG_STS_PKTI() volatile
    {
        MTL_DBG_STS &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_DBG_STS's PKTI bit.
     *
     * Receive Packet Available Interrupt Status When set, this bit indicates
     * that MAC layer has written the EOP of received packet to the Rx FIFO.
     */
    inline void toggle_MTL_DBG_STS_PKTI() volatile
    {
        MTL_DBG_STS ^= 1u << 8u;
    }

    /**
     * Get MTL_DBG_STS's BYTEEN field.
     *
     * Byte Enables This field indicates the number of data bytes valid in the
     * data register during Read operation.
     */
    inline ENET_QOS_MTL_DBG_STS_BYTEEN get_MTL_DBG_STS_BYTEEN() volatile
    {
        return ENET_QOS_MTL_DBG_STS_BYTEEN((MTL_DBG_STS >> 3u) & 0b11u);
    }

    /**
     * Get MTL_DBG_STS's PKTSTATE field.
     *
     * Encoded Packet State This field is used to get the control or status
     * information of the selected FIFO.
     */
    inline ENET_QOS_MTL_DBG_STS_PKTSTATE get_MTL_DBG_STS_PKTSTATE() volatile
    {
        return ENET_QOS_MTL_DBG_STS_PKTSTATE((MTL_DBG_STS >> 1u) & 0b11u);
    }

    /**
     * Get MTL_DBG_STS's FIFOBUSY bit.
     *
     * FIFO Busy When set, this bit indicates that a FIFO operation is in
     * progress in the MAC and content of the following fields is not valid: -
     * All other fields of this register - All fields of the
     * MTL_FIFO_DEBUG_DATA register
     */
    inline bool get_MTL_DBG_STS_FIFOBUSY() volatile
    {
        return MTL_DBG_STS & (1u << 0u);
    }

    /**
     * Get all of MTL_DBG_STS's bit fields.
     *
     * (read-write) FIFO Debug Status
     */
    inline void get_MTL_DBG_STS(uint32_t &LOCR, bool &STSI, bool &PKTI,
                                ENET_QOS_MTL_DBG_STS_BYTEEN &BYTEEN,
                                ENET_QOS_MTL_DBG_STS_PKTSTATE &PKTSTATE,
                                bool &FIFOBUSY) volatile
    {
        uint32_t curr = MTL_DBG_STS;

        LOCR = (curr >> 15u) & 0b11111111111111111u;
        STSI = curr & (1u << 9u);
        PKTI = curr & (1u << 8u);
        BYTEEN = ENET_QOS_MTL_DBG_STS_BYTEEN((curr >> 3u) & 0b11u);
        PKTSTATE = ENET_QOS_MTL_DBG_STS_PKTSTATE((curr >> 1u) & 0b11u);
        FIFOBUSY = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_DBG_STS's bit fields.
     *
     * (read-write) FIFO Debug Status
     */
    inline void set_MTL_DBG_STS(bool STSI, bool PKTI) volatile
    {
        uint32_t curr = MTL_DBG_STS;

        curr &= ~(0b1u << 9u);
        curr |= (STSI & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (PKTI & 0b1u) << 8u;

        MTL_DBG_STS = curr;
    }

    /**
     * Get MTL_FIFO_DEBUG_DATA's FDBGDATA field.
     *
     * FIFO Debug Data During debug or slave access write operation, this field
     * contains the data to be written to the Tx FIFO, Rx FIFO, or TSO FIFO.
     */
    inline uint32_t get_MTL_FIFO_DEBUG_DATA_FDBGDATA() volatile
    {
        return (MTL_FIFO_DEBUG_DATA >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MTL_FIFO_DEBUG_DATA's FDBGDATA field.
     *
     * FIFO Debug Data During debug or slave access write operation, this field
     * contains the data to be written to the Tx FIFO, Rx FIFO, or TSO FIFO.
     */
    inline void set_MTL_FIFO_DEBUG_DATA_FDBGDATA(uint32_t value) volatile
    {
        uint32_t curr = MTL_FIFO_DEBUG_DATA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MTL_FIFO_DEBUG_DATA = curr;
    }

    /**
     * Get MTL_INTERRUPT_STATUS's MTLPIS bit.
     *
     * MTL Rx Parser Interrupt Status This bit indicates that there is an
     * interrupt from Rx Parser Block.
     */
    inline bool get_MTL_INTERRUPT_STATUS_MTLPIS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 23u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's ESTIS bit.
     *
     * EST (TAS- 802.
     */
    inline bool get_MTL_INTERRUPT_STATUS_ESTIS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 18u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's DBGIS bit.
     *
     * Debug Interrupt status This bit indicates an interrupt event during the
     * slave access.
     */
    inline bool get_MTL_INTERRUPT_STATUS_DBGIS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 17u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's Q4IS bit.
     *
     * Queue 4 Interrupt status This bit indicates that there is an interrupt
     * from Queue 4.
     */
    inline bool get_MTL_INTERRUPT_STATUS_Q4IS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 4u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's Q3IS bit.
     *
     * Queue 3 Interrupt status This bit indicates that there is an interrupt
     * from Queue 3.
     */
    inline bool get_MTL_INTERRUPT_STATUS_Q3IS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 3u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's Q2IS bit.
     *
     * Queue 2 Interrupt status This bit indicates that there is an interrupt
     * from Queue 2.
     */
    inline bool get_MTL_INTERRUPT_STATUS_Q2IS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 2u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's Q1IS bit.
     *
     * Queue 1 Interrupt status This bit indicates that there is an interrupt
     * from Queue 1.
     */
    inline bool get_MTL_INTERRUPT_STATUS_Q1IS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 1u);
    }

    /**
     * Get MTL_INTERRUPT_STATUS's Q0IS bit.
     *
     * Queue 0 Interrupt status This bit indicates that there is an interrupt
     * from Queue 0.
     */
    inline bool get_MTL_INTERRUPT_STATUS_Q0IS() volatile
    {
        return MTL_INTERRUPT_STATUS & (1u << 0u);
    }

    /**
     * Get all of MTL_INTERRUPT_STATUS's bit fields.
     *
     * (read-write) MTL Interrupt Status
     */
    inline void get_MTL_INTERRUPT_STATUS(bool &MTLPIS, bool &ESTIS,
                                         bool &DBGIS, bool &Q4IS, bool &Q3IS,
                                         bool &Q2IS, bool &Q1IS,
                                         bool &Q0IS) volatile
    {
        uint32_t curr = MTL_INTERRUPT_STATUS;

        MTLPIS = curr & (1u << 23u);
        ESTIS = curr & (1u << 18u);
        DBGIS = curr & (1u << 17u);
        Q4IS = curr & (1u << 4u);
        Q3IS = curr & (1u << 3u);
        Q2IS = curr & (1u << 2u);
        Q1IS = curr & (1u << 1u);
        Q0IS = curr & (1u << 0u);
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q3DDMACH bit.
     *
     * Queue 3 Enabled for Dynamic (per packet) DMA Channel Selection When set,
     * this bit indicates that the packets received in Queue 3 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline bool get_MTL_RXQ_DMA_MAP0_Q3DDMACH() volatile
    {
        return MTL_RXQ_DMA_MAP0 & (1u << 28u);
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q3DDMACH bit.
     *
     * Queue 3 Enabled for Dynamic (per packet) DMA Channel Selection When set,
     * this bit indicates that the packets received in Queue 3 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q3DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 |= 1u << 28u;
    }

    /**
     * Clear MTL_RXQ_DMA_MAP0's Q3DDMACH bit.
     *
     * Queue 3 Enabled for Dynamic (per packet) DMA Channel Selection When set,
     * this bit indicates that the packets received in Queue 3 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void clear_MTL_RXQ_DMA_MAP0_Q3DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 &= ~(1u << 28u);
    }

    /**
     * Toggle MTL_RXQ_DMA_MAP0's Q3DDMACH bit.
     *
     * Queue 3 Enabled for Dynamic (per packet) DMA Channel Selection When set,
     * this bit indicates that the packets received in Queue 3 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void toggle_MTL_RXQ_DMA_MAP0_Q3DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 ^= 1u << 28u;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q3MDMACH field.
     *
     * Queue 3 Mapped to DMA Channel This field controls the routing of the
     * received packet in Queue 3 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q3DDMACH field is reset.
     */
    inline uint8_t get_MTL_RXQ_DMA_MAP0_Q3MDMACH() volatile
    {
        return (MTL_RXQ_DMA_MAP0 >> 24u) & 0b111u;
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q3MDMACH field.
     *
     * Queue 3 Mapped to DMA Channel This field controls the routing of the
     * received packet in Queue 3 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q3DDMACH field is reset.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q3MDMACH(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        MTL_RXQ_DMA_MAP0 = curr;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q2DDMACH bit.
     *
     * Queue 2 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 2 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline bool get_MTL_RXQ_DMA_MAP0_Q2DDMACH() volatile
    {
        return MTL_RXQ_DMA_MAP0 & (1u << 20u);
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q2DDMACH bit.
     *
     * Queue 2 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 2 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q2DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 |= 1u << 20u;
    }

    /**
     * Clear MTL_RXQ_DMA_MAP0's Q2DDMACH bit.
     *
     * Queue 2 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 2 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void clear_MTL_RXQ_DMA_MAP0_Q2DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 &= ~(1u << 20u);
    }

    /**
     * Toggle MTL_RXQ_DMA_MAP0's Q2DDMACH bit.
     *
     * Queue 2 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 2 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void toggle_MTL_RXQ_DMA_MAP0_Q2DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 ^= 1u << 20u;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q2MDMACH field.
     *
     * Queue 2 Mapped to DMA Channel This field controls the routing of the
     * received packet in Queue 2 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q2DDMACH field is reset.
     */
    inline uint8_t get_MTL_RXQ_DMA_MAP0_Q2MDMACH() volatile
    {
        return (MTL_RXQ_DMA_MAP0 >> 16u) & 0b111u;
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q2MDMACH field.
     *
     * Queue 2 Mapped to DMA Channel This field controls the routing of the
     * received packet in Queue 2 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q2DDMACH field is reset.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q2MDMACH(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP0;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        MTL_RXQ_DMA_MAP0 = curr;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q1DDMACH bit.
     *
     * Queue 1 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 1 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline bool get_MTL_RXQ_DMA_MAP0_Q1DDMACH() volatile
    {
        return MTL_RXQ_DMA_MAP0 & (1u << 12u);
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q1DDMACH bit.
     *
     * Queue 1 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 1 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q1DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 |= 1u << 12u;
    }

    /**
     * Clear MTL_RXQ_DMA_MAP0's Q1DDMACH bit.
     *
     * Queue 1 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 1 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void clear_MTL_RXQ_DMA_MAP0_Q1DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 &= ~(1u << 12u);
    }

    /**
     * Toggle MTL_RXQ_DMA_MAP0's Q1DDMACH bit.
     *
     * Queue 1 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 1 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void toggle_MTL_RXQ_DMA_MAP0_Q1DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 ^= 1u << 12u;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q1MDMACH field.
     *
     * Queue 1 Mapped to DMA Channel This field controls the routing of the
     * received packet in Queue 1 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q1DDMACH field is reset.
     */
    inline uint8_t get_MTL_RXQ_DMA_MAP0_Q1MDMACH() volatile
    {
        return (MTL_RXQ_DMA_MAP0 >> 8u) & 0b111u;
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q1MDMACH field.
     *
     * Queue 1 Mapped to DMA Channel This field controls the routing of the
     * received packet in Queue 1 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q1DDMACH field is reset.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q1MDMACH(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP0;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        MTL_RXQ_DMA_MAP0 = curr;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q0DDMACH bit.
     *
     * Queue 0 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 0 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline bool get_MTL_RXQ_DMA_MAP0_Q0DDMACH() volatile
    {
        return MTL_RXQ_DMA_MAP0 & (1u << 4u);
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q0DDMACH bit.
     *
     * Queue 0 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 0 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q0DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ_DMA_MAP0's Q0DDMACH bit.
     *
     * Queue 0 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 0 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void clear_MTL_RXQ_DMA_MAP0_Q0DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ_DMA_MAP0's Q0DDMACH bit.
     *
     * Queue 0 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 0 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void toggle_MTL_RXQ_DMA_MAP0_Q0DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP0 ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ_DMA_MAP0's Q0MDMACH field.
     *
     * Queue 0 Mapped to DMA Channel This field controls the routing of the
     * packet received in Queue 0 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q0DDMACH field is reset.
     */
    inline uint8_t get_MTL_RXQ_DMA_MAP0_Q0MDMACH() volatile
    {
        return (MTL_RXQ_DMA_MAP0 >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ_DMA_MAP0's Q0MDMACH field.
     *
     * Queue 0 Mapped to DMA Channel This field controls the routing of the
     * packet received in Queue 0 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q0DDMACH field is reset.
     */
    inline void set_MTL_RXQ_DMA_MAP0_Q0MDMACH(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP0;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ_DMA_MAP0 = curr;
    }

    /**
     * Get all of MTL_RXQ_DMA_MAP0's bit fields.
     *
     * (read-write) Receive Queue and DMA Channel Mapping 0
     */
    inline void get_MTL_RXQ_DMA_MAP0(bool &Q3DDMACH, uint8_t &Q3MDMACH,
                                     bool &Q2DDMACH, uint8_t &Q2MDMACH,
                                     bool &Q1DDMACH, uint8_t &Q1MDMACH,
                                     bool &Q0DDMACH,
                                     uint8_t &Q0MDMACH) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP0;

        Q3DDMACH = curr & (1u << 28u);
        Q3MDMACH = (curr >> 24u) & 0b111u;
        Q2DDMACH = curr & (1u << 20u);
        Q2MDMACH = (curr >> 16u) & 0b111u;
        Q1DDMACH = curr & (1u << 12u);
        Q1MDMACH = (curr >> 8u) & 0b111u;
        Q0DDMACH = curr & (1u << 4u);
        Q0MDMACH = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ_DMA_MAP0's bit fields.
     *
     * (read-write) Receive Queue and DMA Channel Mapping 0
     */
    inline void set_MTL_RXQ_DMA_MAP0(bool Q3DDMACH, uint8_t Q3MDMACH,
                                     bool Q2DDMACH, uint8_t Q2MDMACH,
                                     bool Q1DDMACH, uint8_t Q1MDMACH,
                                     bool Q0DDMACH, uint8_t Q0MDMACH) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP0;

        curr &= ~(0b1u << 28u);
        curr |= (Q3DDMACH & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (Q3MDMACH & 0b111u) << 24u;
        curr &= ~(0b1u << 20u);
        curr |= (Q2DDMACH & 0b1u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (Q2MDMACH & 0b111u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (Q1DDMACH & 0b1u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (Q1MDMACH & 0b111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (Q0DDMACH & 0b1u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (Q0MDMACH & 0b111u) << 0u;

        MTL_RXQ_DMA_MAP0 = curr;
    }

    /**
     * Get MTL_RXQ_DMA_MAP1's Q4DDMACH bit.
     *
     * Queue 4 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 4 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline bool get_MTL_RXQ_DMA_MAP1_Q4DDMACH() volatile
    {
        return MTL_RXQ_DMA_MAP1 & (1u << 4u);
    }

    /**
     * Set MTL_RXQ_DMA_MAP1's Q4DDMACH bit.
     *
     * Queue 4 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 4 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void set_MTL_RXQ_DMA_MAP1_Q4DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP1 |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ_DMA_MAP1's Q4DDMACH bit.
     *
     * Queue 4 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 4 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void clear_MTL_RXQ_DMA_MAP1_Q4DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP1 &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ_DMA_MAP1's Q4DDMACH bit.
     *
     * Queue 4 Enabled for DA-based DMA Channel Selection When set, this bit
     * indicates that the packets received in Queue 4 are routed to a
     * particular DMA channel as decided in the MAC Receiver based on the DMA
     * channel number programmed in the L3-L4 filter registers, or the Ethernet
     * DA address.
     */
    inline void toggle_MTL_RXQ_DMA_MAP1_Q4DDMACH() volatile
    {
        MTL_RXQ_DMA_MAP1 ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ_DMA_MAP1's Q4MDMACH field.
     *
     * Queue 4 Mapped to DMA Channel This field controls the routing of the
     * packet received in Queue 4 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q4DDMACH field is reset.
     */
    inline uint8_t get_MTL_RXQ_DMA_MAP1_Q4MDMACH() volatile
    {
        return (MTL_RXQ_DMA_MAP1 >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ_DMA_MAP1's Q4MDMACH field.
     *
     * Queue 4 Mapped to DMA Channel This field controls the routing of the
     * packet received in Queue 4 to the DMA channel: - 000: DMA Channel 0 -
     * 001: DMA Channel 1 - 010: DMA Channel 2 - 011: DMA Channel 3 - 100: DMA
     * Channel 4 - 101: Reserved - 110: Reserved - 111: Reserved This field is
     * valid when the Q4DDMACH field is reset.
     */
    inline void set_MTL_RXQ_DMA_MAP1_Q4MDMACH(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP1;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ_DMA_MAP1 = curr;
    }

    /**
     * Get all of MTL_RXQ_DMA_MAP1's bit fields.
     *
     * (read-write) Receive Queue and DMA Channel Mapping 1
     */
    inline void get_MTL_RXQ_DMA_MAP1(bool &Q4DDMACH,
                                     uint8_t &Q4MDMACH) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP1;

        Q4DDMACH = curr & (1u << 4u);
        Q4MDMACH = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ_DMA_MAP1's bit fields.
     *
     * (read-write) Receive Queue and DMA Channel Mapping 1
     */
    inline void set_MTL_RXQ_DMA_MAP1(bool Q4DDMACH, uint8_t Q4MDMACH) volatile
    {
        uint32_t curr = MTL_RXQ_DMA_MAP1;

        curr &= ~(0b1u << 4u);
        curr |= (Q4DDMACH & 0b1u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (Q4MDMACH & 0b111u) << 0u;

        MTL_RXQ_DMA_MAP1 = curr;
    }

    /**
     * Get MTL_TBS_CTRL's LEOS field.
     *
     * Launch Expiry Offset The value in units of 256 nanoseconds that has to
     * be added to the Launch time to compute the Launch Expiry time.
     */
    inline uint32_t get_MTL_TBS_CTRL_LEOS() volatile
    {
        return (MTL_TBS_CTRL >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set MTL_TBS_CTRL's LEOS field.
     *
     * Launch Expiry Offset The value in units of 256 nanoseconds that has to
     * be added to the Launch time to compute the Launch Expiry time.
     */
    inline void set_MTL_TBS_CTRL_LEOS(uint32_t value) volatile
    {
        uint32_t curr = MTL_TBS_CTRL;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        MTL_TBS_CTRL = curr;
    }

    /**
     * Get MTL_TBS_CTRL's LEGOS field.
     *
     * Launch Expiry GSN Offset The number GSN slots that has to be added to
     * the Launch GSN to compute the Launch Expiry time.
     */
    inline uint8_t get_MTL_TBS_CTRL_LEGOS() volatile
    {
        return (MTL_TBS_CTRL >> 4u) & 0b111u;
    }

    /**
     * Set MTL_TBS_CTRL's LEGOS field.
     *
     * Launch Expiry GSN Offset The number GSN slots that has to be added to
     * the Launch GSN to compute the Launch Expiry time.
     */
    inline void set_MTL_TBS_CTRL_LEGOS(uint8_t value) volatile
    {
        uint32_t curr = MTL_TBS_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        MTL_TBS_CTRL = curr;
    }

    /**
     * Get MTL_TBS_CTRL's LEOV bit.
     *
     * Launch Expiry Offset Valid When set indicates the LEOS field is valid.
     */
    inline bool get_MTL_TBS_CTRL_LEOV() volatile
    {
        return MTL_TBS_CTRL & (1u << 1u);
    }

    /**
     * Set MTL_TBS_CTRL's LEOV bit.
     *
     * Launch Expiry Offset Valid When set indicates the LEOS field is valid.
     */
    inline void set_MTL_TBS_CTRL_LEOV() volatile
    {
        MTL_TBS_CTRL |= 1u << 1u;
    }

    /**
     * Clear MTL_TBS_CTRL's LEOV bit.
     *
     * Launch Expiry Offset Valid When set indicates the LEOS field is valid.
     */
    inline void clear_MTL_TBS_CTRL_LEOV() volatile
    {
        MTL_TBS_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_TBS_CTRL's LEOV bit.
     *
     * Launch Expiry Offset Valid When set indicates the LEOS field is valid.
     */
    inline void toggle_MTL_TBS_CTRL_LEOV() volatile
    {
        MTL_TBS_CTRL ^= 1u << 1u;
    }

    /**
     * Get MTL_TBS_CTRL's ESTM bit.
     *
     * EST offset Mode When this bit is set, the Launch Time value used in Time
     * Based Scheduling is interpreted as an EST offset value and is added to
     * the Base Time Register (BTR) of the current list.
     */
    inline bool get_MTL_TBS_CTRL_ESTM() volatile
    {
        return MTL_TBS_CTRL & (1u << 0u);
    }

    /**
     * Set MTL_TBS_CTRL's ESTM bit.
     *
     * EST offset Mode When this bit is set, the Launch Time value used in Time
     * Based Scheduling is interpreted as an EST offset value and is added to
     * the Base Time Register (BTR) of the current list.
     */
    inline void set_MTL_TBS_CTRL_ESTM() volatile
    {
        MTL_TBS_CTRL |= 1u << 0u;
    }

    /**
     * Clear MTL_TBS_CTRL's ESTM bit.
     *
     * EST offset Mode When this bit is set, the Launch Time value used in Time
     * Based Scheduling is interpreted as an EST offset value and is added to
     * the Base Time Register (BTR) of the current list.
     */
    inline void clear_MTL_TBS_CTRL_ESTM() volatile
    {
        MTL_TBS_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_TBS_CTRL's ESTM bit.
     *
     * EST offset Mode When this bit is set, the Launch Time value used in Time
     * Based Scheduling is interpreted as an EST offset value and is added to
     * the Base Time Register (BTR) of the current list.
     */
    inline void toggle_MTL_TBS_CTRL_ESTM() volatile
    {
        MTL_TBS_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of MTL_TBS_CTRL's bit fields.
     *
     * (read-write) Time Based Scheduling Control
     */
    inline void get_MTL_TBS_CTRL(uint32_t &LEOS, uint8_t &LEGOS, bool &LEOV,
                                 bool &ESTM) volatile
    {
        uint32_t curr = MTL_TBS_CTRL;

        LEOS = (curr >> 8u) & 0b111111111111111111111111u;
        LEGOS = (curr >> 4u) & 0b111u;
        LEOV = curr & (1u << 1u);
        ESTM = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_TBS_CTRL's bit fields.
     *
     * (read-write) Time Based Scheduling Control
     */
    inline void set_MTL_TBS_CTRL(uint32_t LEOS, uint8_t LEGOS, bool LEOV,
                                 bool ESTM) volatile
    {
        uint32_t curr = MTL_TBS_CTRL;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (LEOS & 0b111111111111111111111111u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (LEGOS & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (LEOV & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ESTM & 0b1u) << 0u;

        MTL_TBS_CTRL = curr;
    }

    /**
     * Get MTL_EST_CONTROL's PTOV field.
     *
     * PTP Time Offset Value The value of PTP Clock period multiplied by 6 in
     * nanoseconds.
     */
    inline uint8_t get_MTL_EST_CONTROL_PTOV() volatile
    {
        return (MTL_EST_CONTROL >> 24u) & 0b11111111u;
    }

    /**
     * Set MTL_EST_CONTROL's PTOV field.
     *
     * PTP Time Offset Value The value of PTP Clock period multiplied by 6 in
     * nanoseconds.
     */
    inline void set_MTL_EST_CONTROL_PTOV(uint8_t value) volatile
    {
        uint32_t curr = MTL_EST_CONTROL;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        MTL_EST_CONTROL = curr;
    }

    /**
     * Get MTL_EST_CONTROL's CTOV field.
     *
     * Current Time Offset Value Provides a 12 bit time offset value in nano
     * second that is added to the current time to compensate for all the
     * implementation pipeline delays such as the CDC sync delay, buffering
     * delays, data path delays etc.
     */
    inline uint16_t get_MTL_EST_CONTROL_CTOV() volatile
    {
        return (MTL_EST_CONTROL >> 12u) & 0b111111111111u;
    }

    /**
     * Set MTL_EST_CONTROL's CTOV field.
     *
     * Current Time Offset Value Provides a 12 bit time offset value in nano
     * second that is added to the current time to compensate for all the
     * implementation pipeline delays such as the CDC sync delay, buffering
     * delays, data path delays etc.
     */
    inline void set_MTL_EST_CONTROL_CTOV(uint16_t value) volatile
    {
        uint32_t curr = MTL_EST_CONTROL;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        MTL_EST_CONTROL = curr;
    }

    /**
     * Get MTL_EST_CONTROL's TILS field.
     *
     * Time Interval Left Shift Amount This field provides the left shift
     * amount for the programmed Time Interval values used in the Gate Control
     * Lists.
     */
    inline uint8_t get_MTL_EST_CONTROL_TILS() volatile
    {
        return (MTL_EST_CONTROL >> 8u) & 0b111u;
    }

    /**
     * Set MTL_EST_CONTROL's TILS field.
     *
     * Time Interval Left Shift Amount This field provides the left shift
     * amount for the programmed Time Interval values used in the Gate Control
     * Lists.
     */
    inline void set_MTL_EST_CONTROL_TILS(uint8_t value) volatile
    {
        uint32_t curr = MTL_EST_CONTROL;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        MTL_EST_CONTROL = curr;
    }

    /**
     * Get MTL_EST_CONTROL's LCSE field.
     *
     * Loop Count to report Scheduling Error Programmable number of GCL list
     * iterations before reporting an HLBS error defined in EST_STATUS
     * register.
     */
    inline ENET_QOS_MTL_EST_CONTROL_LCSE get_MTL_EST_CONTROL_LCSE() volatile
    {
        return ENET_QOS_MTL_EST_CONTROL_LCSE((MTL_EST_CONTROL >> 6u) & 0b11u);
    }

    /**
     * Set MTL_EST_CONTROL's LCSE field.
     *
     * Loop Count to report Scheduling Error Programmable number of GCL list
     * iterations before reporting an HLBS error defined in EST_STATUS
     * register.
     */
    inline void set_MTL_EST_CONTROL_LCSE(
        ENET_QOS_MTL_EST_CONTROL_LCSE value) volatile
    {
        uint32_t curr = MTL_EST_CONTROL;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        MTL_EST_CONTROL = curr;
    }

    /**
     * Get MTL_EST_CONTROL's DFBS bit.
     *
     * Drop Frames causing Scheduling Error When set frames reported to cause
     * HOL Blocking due to not getting scheduled (HLBS field of EST_STATUS
     * register) after 4,8,16,32 (based on LCSE field of this register) GCL
     * iterations are dropped.
     */
    inline bool get_MTL_EST_CONTROL_DFBS() volatile
    {
        return MTL_EST_CONTROL & (1u << 5u);
    }

    /**
     * Set MTL_EST_CONTROL's DFBS bit.
     *
     * Drop Frames causing Scheduling Error When set frames reported to cause
     * HOL Blocking due to not getting scheduled (HLBS field of EST_STATUS
     * register) after 4,8,16,32 (based on LCSE field of this register) GCL
     * iterations are dropped.
     */
    inline void set_MTL_EST_CONTROL_DFBS() volatile
    {
        MTL_EST_CONTROL |= 1u << 5u;
    }

    /**
     * Clear MTL_EST_CONTROL's DFBS bit.
     *
     * Drop Frames causing Scheduling Error When set frames reported to cause
     * HOL Blocking due to not getting scheduled (HLBS field of EST_STATUS
     * register) after 4,8,16,32 (based on LCSE field of this register) GCL
     * iterations are dropped.
     */
    inline void clear_MTL_EST_CONTROL_DFBS() volatile
    {
        MTL_EST_CONTROL &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_EST_CONTROL's DFBS bit.
     *
     * Drop Frames causing Scheduling Error When set frames reported to cause
     * HOL Blocking due to not getting scheduled (HLBS field of EST_STATUS
     * register) after 4,8,16,32 (based on LCSE field of this register) GCL
     * iterations are dropped.
     */
    inline void toggle_MTL_EST_CONTROL_DFBS() volatile
    {
        MTL_EST_CONTROL ^= 1u << 5u;
    }

    /**
     * Get MTL_EST_CONTROL's DDBF bit.
     *
     * Do not Drop frames during Frame Size Error When set, frames are not be
     * dropped during Head-of-Line blocking due to Frame Size Error (HLBF field
     * of MTL_EST_STATUS register).
     */
    inline bool get_MTL_EST_CONTROL_DDBF() volatile
    {
        return MTL_EST_CONTROL & (1u << 4u);
    }

    /**
     * Set MTL_EST_CONTROL's DDBF bit.
     *
     * Do not Drop frames during Frame Size Error When set, frames are not be
     * dropped during Head-of-Line blocking due to Frame Size Error (HLBF field
     * of MTL_EST_STATUS register).
     */
    inline void set_MTL_EST_CONTROL_DDBF() volatile
    {
        MTL_EST_CONTROL |= 1u << 4u;
    }

    /**
     * Clear MTL_EST_CONTROL's DDBF bit.
     *
     * Do not Drop frames during Frame Size Error When set, frames are not be
     * dropped during Head-of-Line blocking due to Frame Size Error (HLBF field
     * of MTL_EST_STATUS register).
     */
    inline void clear_MTL_EST_CONTROL_DDBF() volatile
    {
        MTL_EST_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_EST_CONTROL's DDBF bit.
     *
     * Do not Drop frames during Frame Size Error When set, frames are not be
     * dropped during Head-of-Line blocking due to Frame Size Error (HLBF field
     * of MTL_EST_STATUS register).
     */
    inline void toggle_MTL_EST_CONTROL_DDBF() volatile
    {
        MTL_EST_CONTROL ^= 1u << 4u;
    }

    /**
     * Get MTL_EST_CONTROL's SSWL bit.
     *
     * Switch to S/W owned list When set indicates that the software has
     * programmed that list that it currently owns (SWOL) and the hardware
     * should switch to the new list based on the new BTR.
     */
    inline bool get_MTL_EST_CONTROL_SSWL() volatile
    {
        return MTL_EST_CONTROL & (1u << 1u);
    }

    /**
     * Set MTL_EST_CONTROL's SSWL bit.
     *
     * Switch to S/W owned list When set indicates that the software has
     * programmed that list that it currently owns (SWOL) and the hardware
     * should switch to the new list based on the new BTR.
     */
    inline void set_MTL_EST_CONTROL_SSWL() volatile
    {
        MTL_EST_CONTROL |= 1u << 1u;
    }

    /**
     * Clear MTL_EST_CONTROL's SSWL bit.
     *
     * Switch to S/W owned list When set indicates that the software has
     * programmed that list that it currently owns (SWOL) and the hardware
     * should switch to the new list based on the new BTR.
     */
    inline void clear_MTL_EST_CONTROL_SSWL() volatile
    {
        MTL_EST_CONTROL &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_EST_CONTROL's SSWL bit.
     *
     * Switch to S/W owned list When set indicates that the software has
     * programmed that list that it currently owns (SWOL) and the hardware
     * should switch to the new list based on the new BTR.
     */
    inline void toggle_MTL_EST_CONTROL_SSWL() volatile
    {
        MTL_EST_CONTROL ^= 1u << 1u;
    }

    /**
     * Get MTL_EST_CONTROL's EEST bit.
     *
     * Enable EST When reset, the gate control list processing is halted and
     * all gates are assumed to be in Open state.
     */
    inline bool get_MTL_EST_CONTROL_EEST() volatile
    {
        return MTL_EST_CONTROL & (1u << 0u);
    }

    /**
     * Set MTL_EST_CONTROL's EEST bit.
     *
     * Enable EST When reset, the gate control list processing is halted and
     * all gates are assumed to be in Open state.
     */
    inline void set_MTL_EST_CONTROL_EEST() volatile
    {
        MTL_EST_CONTROL |= 1u << 0u;
    }

    /**
     * Clear MTL_EST_CONTROL's EEST bit.
     *
     * Enable EST When reset, the gate control list processing is halted and
     * all gates are assumed to be in Open state.
     */
    inline void clear_MTL_EST_CONTROL_EEST() volatile
    {
        MTL_EST_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_EST_CONTROL's EEST bit.
     *
     * Enable EST When reset, the gate control list processing is halted and
     * all gates are assumed to be in Open state.
     */
    inline void toggle_MTL_EST_CONTROL_EEST() volatile
    {
        MTL_EST_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of MTL_EST_CONTROL's bit fields.
     *
     * (read-write) Enhancements to Scheduled Transmission Control
     */
    inline void get_MTL_EST_CONTROL(uint8_t &PTOV, uint16_t &CTOV,
                                    uint8_t &TILS,
                                    ENET_QOS_MTL_EST_CONTROL_LCSE &LCSE,
                                    bool &DFBS, bool &DDBF, bool &SSWL,
                                    bool &EEST) volatile
    {
        uint32_t curr = MTL_EST_CONTROL;

        PTOV = (curr >> 24u) & 0b11111111u;
        CTOV = (curr >> 12u) & 0b111111111111u;
        TILS = (curr >> 8u) & 0b111u;
        LCSE = ENET_QOS_MTL_EST_CONTROL_LCSE((curr >> 6u) & 0b11u);
        DFBS = curr & (1u << 5u);
        DDBF = curr & (1u << 4u);
        SSWL = curr & (1u << 1u);
        EEST = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_EST_CONTROL's bit fields.
     *
     * (read-write) Enhancements to Scheduled Transmission Control
     */
    inline void set_MTL_EST_CONTROL(uint8_t PTOV, uint16_t CTOV, uint8_t TILS,
                                    ENET_QOS_MTL_EST_CONTROL_LCSE LCSE,
                                    bool DFBS, bool DDBF, bool SSWL,
                                    bool EEST) volatile
    {
        uint32_t curr = MTL_EST_CONTROL;

        curr &= ~(0b11111111u << 24u);
        curr |= (PTOV & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (CTOV & 0b111111111111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (TILS & 0b111u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(LCSE) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DFBS & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DDBF & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (SSWL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EEST & 0b1u) << 0u;

        MTL_EST_CONTROL = curr;
    }

    /**
     * Get MTL_EST_STATUS's CGSN field.
     *
     * Current GCL Slot Number Indicates the slot number of the GCL list.
     */
    inline uint8_t get_MTL_EST_STATUS_CGSN() volatile
    {
        return (MTL_EST_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get MTL_EST_STATUS's BTRL field.
     *
     * BTR Error Loop Count Provides the minimum count (N) for which the
     * equation Current Time =< New BTR + (N * New Cycle Time) becomes true.
     */
    inline uint8_t get_MTL_EST_STATUS_BTRL() volatile
    {
        return (MTL_EST_STATUS >> 8u) & 0b1111u;
    }

    /**
     * Get MTL_EST_STATUS's SWOL bit.
     *
     * S/W owned list When '0' indicates Gate control list number "0" is owned
     * by software and when "1" indicates the Gate Control list "1" is owned by
     * the software.
     */
    inline bool get_MTL_EST_STATUS_SWOL() volatile
    {
        return MTL_EST_STATUS & (1u << 7u);
    }

    /**
     * Get MTL_EST_STATUS's CGCE bit.
     *
     * Constant Gate Control Error This error occurs when the list length (LLR)
     * is 1 and the programmed Time Interval (TI) value after the optional Left
     * Shifting is less than or equal to the Cycle Time (CTR).
     */
    inline bool get_MTL_EST_STATUS_CGCE() volatile
    {
        return MTL_EST_STATUS & (1u << 4u);
    }

    /**
     * Set MTL_EST_STATUS's CGCE bit.
     *
     * Constant Gate Control Error This error occurs when the list length (LLR)
     * is 1 and the programmed Time Interval (TI) value after the optional Left
     * Shifting is less than or equal to the Cycle Time (CTR).
     */
    inline void set_MTL_EST_STATUS_CGCE() volatile
    {
        MTL_EST_STATUS |= 1u << 4u;
    }

    /**
     * Clear MTL_EST_STATUS's CGCE bit.
     *
     * Constant Gate Control Error This error occurs when the list length (LLR)
     * is 1 and the programmed Time Interval (TI) value after the optional Left
     * Shifting is less than or equal to the Cycle Time (CTR).
     */
    inline void clear_MTL_EST_STATUS_CGCE() volatile
    {
        MTL_EST_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_EST_STATUS's CGCE bit.
     *
     * Constant Gate Control Error This error occurs when the list length (LLR)
     * is 1 and the programmed Time Interval (TI) value after the optional Left
     * Shifting is less than or equal to the Cycle Time (CTR).
     */
    inline void toggle_MTL_EST_STATUS_CGCE() volatile
    {
        MTL_EST_STATUS ^= 1u << 4u;
    }

    /**
     * Get MTL_EST_STATUS's HLBS bit.
     *
     * Head-Of-Line Blocking due to Scheduling Set when the frame is not able
     * to win arbitration and get scheduled even after 4 iterations of the GCL.
     */
    inline bool get_MTL_EST_STATUS_HLBS() volatile
    {
        return MTL_EST_STATUS & (1u << 3u);
    }

    /**
     * Get MTL_EST_STATUS's HLBF bit.
     *
     * Head-Of-Line Blocking due to Frame Size Set when HOL Blocking is noticed
     * on one or more Queues as a result of none of the Time Intervals of gate
     * open in the GCL being greater than or equal to the duration needed for
     * frame size (or frame fragment size when preemption is enabled)
     * transmission.
     */
    inline bool get_MTL_EST_STATUS_HLBF() volatile
    {
        return MTL_EST_STATUS & (1u << 2u);
    }

    /**
     * Get MTL_EST_STATUS's BTRE bit.
     *
     * BTR Error When "1" indicates a programming error in the BTR of SWOL
     * where the programmed value is less than current time.
     */
    inline bool get_MTL_EST_STATUS_BTRE() volatile
    {
        return MTL_EST_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_EST_STATUS's BTRE bit.
     *
     * BTR Error When "1" indicates a programming error in the BTR of SWOL
     * where the programmed value is less than current time.
     */
    inline void set_MTL_EST_STATUS_BTRE() volatile
    {
        MTL_EST_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_EST_STATUS's BTRE bit.
     *
     * BTR Error When "1" indicates a programming error in the BTR of SWOL
     * where the programmed value is less than current time.
     */
    inline void clear_MTL_EST_STATUS_BTRE() volatile
    {
        MTL_EST_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_EST_STATUS's BTRE bit.
     *
     * BTR Error When "1" indicates a programming error in the BTR of SWOL
     * where the programmed value is less than current time.
     */
    inline void toggle_MTL_EST_STATUS_BTRE() volatile
    {
        MTL_EST_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_EST_STATUS's SWLC bit.
     *
     * Switch to S/W owned list Complete When "1" indicates the hardware has
     * successfully switched to the SWOL, and the SWOL bit has been updated to
     * that effect.
     */
    inline bool get_MTL_EST_STATUS_SWLC() volatile
    {
        return MTL_EST_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_EST_STATUS's SWLC bit.
     *
     * Switch to S/W owned list Complete When "1" indicates the hardware has
     * successfully switched to the SWOL, and the SWOL bit has been updated to
     * that effect.
     */
    inline void set_MTL_EST_STATUS_SWLC() volatile
    {
        MTL_EST_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_EST_STATUS's SWLC bit.
     *
     * Switch to S/W owned list Complete When "1" indicates the hardware has
     * successfully switched to the SWOL, and the SWOL bit has been updated to
     * that effect.
     */
    inline void clear_MTL_EST_STATUS_SWLC() volatile
    {
        MTL_EST_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_EST_STATUS's SWLC bit.
     *
     * Switch to S/W owned list Complete When "1" indicates the hardware has
     * successfully switched to the SWOL, and the SWOL bit has been updated to
     * that effect.
     */
    inline void toggle_MTL_EST_STATUS_SWLC() volatile
    {
        MTL_EST_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_EST_STATUS's bit fields.
     *
     * (read-write) Enhancements to Scheduled Transmission Status
     */
    inline void get_MTL_EST_STATUS(uint8_t &CGSN, uint8_t &BTRL, bool &SWOL,
                                   bool &CGCE, bool &HLBS, bool &HLBF,
                                   bool &BTRE, bool &SWLC) volatile
    {
        uint32_t curr = MTL_EST_STATUS;

        CGSN = (curr >> 16u) & 0b1111u;
        BTRL = (curr >> 8u) & 0b1111u;
        SWOL = curr & (1u << 7u);
        CGCE = curr & (1u << 4u);
        HLBS = curr & (1u << 3u);
        HLBF = curr & (1u << 2u);
        BTRE = curr & (1u << 1u);
        SWLC = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_EST_STATUS's bit fields.
     *
     * (read-write) Enhancements to Scheduled Transmission Status
     */
    inline void set_MTL_EST_STATUS(bool CGCE, bool BTRE, bool SWLC) volatile
    {
        uint32_t curr = MTL_EST_STATUS;

        curr &= ~(0b1u << 4u);
        curr |= (CGCE & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (BTRE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SWLC & 0b1u) << 0u;

        MTL_EST_STATUS = curr;
    }

    /**
     * Get MTL_EST_SCH_ERROR's SEQN field.
     *
     * Schedule Error Queue Number The One Hot Encoded Queue Numbers that have
     * experienced error/timeout described in HLBS field of status register.
     */
    inline uint8_t get_MTL_EST_SCH_ERROR_SEQN() volatile
    {
        return (MTL_EST_SCH_ERROR >> 0u) & 0b11111u;
    }

    /**
     * Set MTL_EST_SCH_ERROR's SEQN field.
     *
     * Schedule Error Queue Number The One Hot Encoded Queue Numbers that have
     * experienced error/timeout described in HLBS field of status register.
     */
    inline void set_MTL_EST_SCH_ERROR_SEQN(uint8_t value) volatile
    {
        uint32_t curr = MTL_EST_SCH_ERROR;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        MTL_EST_SCH_ERROR = curr;
    }

    /**
     * Get MTL_EST_FRM_SIZE_ERROR's FEQN field.
     *
     * Frame Size Error Queue Number The One Hot Encoded Queue Numbers that
     * have experienced error described in HLBF field of status register.
     */
    inline uint8_t get_MTL_EST_FRM_SIZE_ERROR_FEQN() volatile
    {
        return (MTL_EST_FRM_SIZE_ERROR >> 0u) & 0b11111u;
    }

    /**
     * Set MTL_EST_FRM_SIZE_ERROR's FEQN field.
     *
     * Frame Size Error Queue Number The One Hot Encoded Queue Numbers that
     * have experienced error described in HLBF field of status register.
     */
    inline void set_MTL_EST_FRM_SIZE_ERROR_FEQN(uint8_t value) volatile
    {
        uint32_t curr = MTL_EST_FRM_SIZE_ERROR;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        MTL_EST_FRM_SIZE_ERROR = curr;
    }

    /**
     * Get MTL_EST_FRM_SIZE_CAPTURE's HBFQ field.
     *
     * Queue Number of HLBF Captures the binary value of the of the first Queue
     * (number) experiencing HLBF error (see HLBF field of status register).
     */
    inline uint8_t get_MTL_EST_FRM_SIZE_CAPTURE_HBFQ() volatile
    {
        return (MTL_EST_FRM_SIZE_CAPTURE >> 16u) & 0b111u;
    }

    /**
     * Get MTL_EST_FRM_SIZE_CAPTURE's HBFS field.
     *
     * Frame Size of HLBF Captures the Frame Size of the dropped frame related
     * to queue number indicated in HBFQ field of this register.
     */
    inline uint16_t get_MTL_EST_FRM_SIZE_CAPTURE_HBFS() volatile
    {
        return (MTL_EST_FRM_SIZE_CAPTURE >> 0u) & 0b111111111111111u;
    }

    /**
     * Get all of MTL_EST_FRM_SIZE_CAPTURE's bit fields.
     *
     * (read-write) EST Frame Size Capture
     */
    inline void get_MTL_EST_FRM_SIZE_CAPTURE(uint8_t &HBFQ,
                                             uint16_t &HBFS) volatile
    {
        uint32_t curr = MTL_EST_FRM_SIZE_CAPTURE;

        HBFQ = (curr >> 16u) & 0b111u;
        HBFS = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Get MTL_EST_INTR_ENABLE's CGCE bit.
     *
     * Interrupt Enable for CGCE When set, generates interrupt when the
     * Constant Gate Control Error occurs and is indicated in the status.
     */
    inline bool get_MTL_EST_INTR_ENABLE_CGCE() volatile
    {
        return MTL_EST_INTR_ENABLE & (1u << 4u);
    }

    /**
     * Set MTL_EST_INTR_ENABLE's CGCE bit.
     *
     * Interrupt Enable for CGCE When set, generates interrupt when the
     * Constant Gate Control Error occurs and is indicated in the status.
     */
    inline void set_MTL_EST_INTR_ENABLE_CGCE() volatile
    {
        MTL_EST_INTR_ENABLE |= 1u << 4u;
    }

    /**
     * Clear MTL_EST_INTR_ENABLE's CGCE bit.
     *
     * Interrupt Enable for CGCE When set, generates interrupt when the
     * Constant Gate Control Error occurs and is indicated in the status.
     */
    inline void clear_MTL_EST_INTR_ENABLE_CGCE() volatile
    {
        MTL_EST_INTR_ENABLE &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_EST_INTR_ENABLE's CGCE bit.
     *
     * Interrupt Enable for CGCE When set, generates interrupt when the
     * Constant Gate Control Error occurs and is indicated in the status.
     */
    inline void toggle_MTL_EST_INTR_ENABLE_CGCE() volatile
    {
        MTL_EST_INTR_ENABLE ^= 1u << 4u;
    }

    /**
     * Get MTL_EST_INTR_ENABLE's IEHS bit.
     *
     * Interrupt Enable for HLBS When set, generates interrupt when the
     * Head-of-Line Blocking due to Scheduling issue and is indicated in the
     * status.
     */
    inline bool get_MTL_EST_INTR_ENABLE_IEHS() volatile
    {
        return MTL_EST_INTR_ENABLE & (1u << 3u);
    }

    /**
     * Set MTL_EST_INTR_ENABLE's IEHS bit.
     *
     * Interrupt Enable for HLBS When set, generates interrupt when the
     * Head-of-Line Blocking due to Scheduling issue and is indicated in the
     * status.
     */
    inline void set_MTL_EST_INTR_ENABLE_IEHS() volatile
    {
        MTL_EST_INTR_ENABLE |= 1u << 3u;
    }

    /**
     * Clear MTL_EST_INTR_ENABLE's IEHS bit.
     *
     * Interrupt Enable for HLBS When set, generates interrupt when the
     * Head-of-Line Blocking due to Scheduling issue and is indicated in the
     * status.
     */
    inline void clear_MTL_EST_INTR_ENABLE_IEHS() volatile
    {
        MTL_EST_INTR_ENABLE &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_EST_INTR_ENABLE's IEHS bit.
     *
     * Interrupt Enable for HLBS When set, generates interrupt when the
     * Head-of-Line Blocking due to Scheduling issue and is indicated in the
     * status.
     */
    inline void toggle_MTL_EST_INTR_ENABLE_IEHS() volatile
    {
        MTL_EST_INTR_ENABLE ^= 1u << 3u;
    }

    /**
     * Get MTL_EST_INTR_ENABLE's IEHF bit.
     *
     * Interrupt Enable for HLBF When set, generates interrupt when the
     * Head-of-Line Blocking due to Frame Size error occurs and is indicated in
     * the status.
     */
    inline bool get_MTL_EST_INTR_ENABLE_IEHF() volatile
    {
        return MTL_EST_INTR_ENABLE & (1u << 2u);
    }

    /**
     * Set MTL_EST_INTR_ENABLE's IEHF bit.
     *
     * Interrupt Enable for HLBF When set, generates interrupt when the
     * Head-of-Line Blocking due to Frame Size error occurs and is indicated in
     * the status.
     */
    inline void set_MTL_EST_INTR_ENABLE_IEHF() volatile
    {
        MTL_EST_INTR_ENABLE |= 1u << 2u;
    }

    /**
     * Clear MTL_EST_INTR_ENABLE's IEHF bit.
     *
     * Interrupt Enable for HLBF When set, generates interrupt when the
     * Head-of-Line Blocking due to Frame Size error occurs and is indicated in
     * the status.
     */
    inline void clear_MTL_EST_INTR_ENABLE_IEHF() volatile
    {
        MTL_EST_INTR_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_EST_INTR_ENABLE's IEHF bit.
     *
     * Interrupt Enable for HLBF When set, generates interrupt when the
     * Head-of-Line Blocking due to Frame Size error occurs and is indicated in
     * the status.
     */
    inline void toggle_MTL_EST_INTR_ENABLE_IEHF() volatile
    {
        MTL_EST_INTR_ENABLE ^= 1u << 2u;
    }

    /**
     * Get MTL_EST_INTR_ENABLE's IEBE bit.
     *
     * Interrupt Enable for BTR Error When set, generates interrupt when the
     * BTR Error occurs and is indicated in the status.
     */
    inline bool get_MTL_EST_INTR_ENABLE_IEBE() volatile
    {
        return MTL_EST_INTR_ENABLE & (1u << 1u);
    }

    /**
     * Set MTL_EST_INTR_ENABLE's IEBE bit.
     *
     * Interrupt Enable for BTR Error When set, generates interrupt when the
     * BTR Error occurs and is indicated in the status.
     */
    inline void set_MTL_EST_INTR_ENABLE_IEBE() volatile
    {
        MTL_EST_INTR_ENABLE |= 1u << 1u;
    }

    /**
     * Clear MTL_EST_INTR_ENABLE's IEBE bit.
     *
     * Interrupt Enable for BTR Error When set, generates interrupt when the
     * BTR Error occurs and is indicated in the status.
     */
    inline void clear_MTL_EST_INTR_ENABLE_IEBE() volatile
    {
        MTL_EST_INTR_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_EST_INTR_ENABLE's IEBE bit.
     *
     * Interrupt Enable for BTR Error When set, generates interrupt when the
     * BTR Error occurs and is indicated in the status.
     */
    inline void toggle_MTL_EST_INTR_ENABLE_IEBE() volatile
    {
        MTL_EST_INTR_ENABLE ^= 1u << 1u;
    }

    /**
     * Get MTL_EST_INTR_ENABLE's IECC bit.
     *
     * Interrupt Enable for Switch List When set, generates interrupt when the
     * configuration change is successful and the hardware has switched to the
     * new list.
     */
    inline bool get_MTL_EST_INTR_ENABLE_IECC() volatile
    {
        return MTL_EST_INTR_ENABLE & (1u << 0u);
    }

    /**
     * Set MTL_EST_INTR_ENABLE's IECC bit.
     *
     * Interrupt Enable for Switch List When set, generates interrupt when the
     * configuration change is successful and the hardware has switched to the
     * new list.
     */
    inline void set_MTL_EST_INTR_ENABLE_IECC() volatile
    {
        MTL_EST_INTR_ENABLE |= 1u << 0u;
    }

    /**
     * Clear MTL_EST_INTR_ENABLE's IECC bit.
     *
     * Interrupt Enable for Switch List When set, generates interrupt when the
     * configuration change is successful and the hardware has switched to the
     * new list.
     */
    inline void clear_MTL_EST_INTR_ENABLE_IECC() volatile
    {
        MTL_EST_INTR_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_EST_INTR_ENABLE's IECC bit.
     *
     * Interrupt Enable for Switch List When set, generates interrupt when the
     * configuration change is successful and the hardware has switched to the
     * new list.
     */
    inline void toggle_MTL_EST_INTR_ENABLE_IECC() volatile
    {
        MTL_EST_INTR_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of MTL_EST_INTR_ENABLE's bit fields.
     *
     * (read-write) EST Interrupt Enable
     */
    inline void get_MTL_EST_INTR_ENABLE(bool &CGCE, bool &IEHS, bool &IEHF,
                                        bool &IEBE, bool &IECC) volatile
    {
        uint32_t curr = MTL_EST_INTR_ENABLE;

        CGCE = curr & (1u << 4u);
        IEHS = curr & (1u << 3u);
        IEHF = curr & (1u << 2u);
        IEBE = curr & (1u << 1u);
        IECC = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_EST_INTR_ENABLE's bit fields.
     *
     * (read-write) EST Interrupt Enable
     */
    inline void set_MTL_EST_INTR_ENABLE(bool CGCE, bool IEHS, bool IEHF,
                                        bool IEBE, bool IECC) volatile
    {
        uint32_t curr = MTL_EST_INTR_ENABLE;

        curr &= ~(0b1u << 4u);
        curr |= (CGCE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IEHS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (IEHF & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IEBE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IECC & 0b1u) << 0u;

        MTL_EST_INTR_ENABLE = curr;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's ESTEIEC field.
     *
     * ECC Inject Error Control for EST Memory When EIEE bit of this register
     * is set, following are the errors inserted based on the value encoded in
     * this field.
     */
    inline ENET_QOS_MTL_EST_GCL_CONTROL_ESTEIEC
    get_MTL_EST_GCL_CONTROL_ESTEIEC() volatile
    {
        return ENET_QOS_MTL_EST_GCL_CONTROL_ESTEIEC(
            (MTL_EST_GCL_CONTROL >> 22u) & 0b11u);
    }

    /**
     * Get MTL_EST_GCL_CONTROL's ESTEIEE bit.
     *
     * EST ECC Inject Error Enable When set along with EEST bit of
     * MTL_EST_CONTROL register, enables the ECC error injection feature.
     */
    inline bool get_MTL_EST_GCL_CONTROL_ESTEIEE() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 21u);
    }

    /**
     * Get MTL_EST_GCL_CONTROL's ERR0 bit.
     *
     * When set indicates the last write operation was aborted as software
     * writes to GCL and GCL registers is prohibited when SSWL bit of
     * MTL_EST_CONTROL Register is set.
     */
    inline bool get_MTL_EST_GCL_CONTROL_ERR0() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 20u);
    }

    /**
     * Set MTL_EST_GCL_CONTROL's ERR0 bit.
     *
     * When set indicates the last write operation was aborted as software
     * writes to GCL and GCL registers is prohibited when SSWL bit of
     * MTL_EST_CONTROL Register is set.
     */
    inline void set_MTL_EST_GCL_CONTROL_ERR0() volatile
    {
        MTL_EST_GCL_CONTROL |= 1u << 20u;
    }

    /**
     * Clear MTL_EST_GCL_CONTROL's ERR0 bit.
     *
     * When set indicates the last write operation was aborted as software
     * writes to GCL and GCL registers is prohibited when SSWL bit of
     * MTL_EST_CONTROL Register is set.
     */
    inline void clear_MTL_EST_GCL_CONTROL_ERR0() volatile
    {
        MTL_EST_GCL_CONTROL &= ~(1u << 20u);
    }

    /**
     * Toggle MTL_EST_GCL_CONTROL's ERR0 bit.
     *
     * When set indicates the last write operation was aborted as software
     * writes to GCL and GCL registers is prohibited when SSWL bit of
     * MTL_EST_CONTROL Register is set.
     */
    inline void toggle_MTL_EST_GCL_CONTROL_ERR0() volatile
    {
        MTL_EST_GCL_CONTROL ^= 1u << 20u;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's ADDR field.
     *
     * Gate Control List Address: (GCLA when GCRR is "0").
     */
    inline uint16_t get_MTL_EST_GCL_CONTROL_ADDR() volatile
    {
        return (MTL_EST_GCL_CONTROL >> 8u) & 0b111111111u;
    }

    /**
     * Set MTL_EST_GCL_CONTROL's ADDR field.
     *
     * Gate Control List Address: (GCLA when GCRR is "0").
     */
    inline void set_MTL_EST_GCL_CONTROL_ADDR(uint16_t value) volatile
    {
        uint32_t curr = MTL_EST_GCL_CONTROL;

        curr &= ~(0b111111111u << 8u);
        curr |= (value & 0b111111111u) << 8u;

        MTL_EST_GCL_CONTROL = curr;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's DBGB bit.
     *
     * Debug Mode Bank Select When set to "0" indicates R/W in debug mode
     * should be directed to Bank 0 (GCL0 and corresponding Time related
     * registers).
     */
    inline bool get_MTL_EST_GCL_CONTROL_DBGB() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 5u);
    }

    /**
     * Set MTL_EST_GCL_CONTROL's DBGB bit.
     *
     * Debug Mode Bank Select When set to "0" indicates R/W in debug mode
     * should be directed to Bank 0 (GCL0 and corresponding Time related
     * registers).
     */
    inline void set_MTL_EST_GCL_CONTROL_DBGB() volatile
    {
        MTL_EST_GCL_CONTROL |= 1u << 5u;
    }

    /**
     * Clear MTL_EST_GCL_CONTROL's DBGB bit.
     *
     * Debug Mode Bank Select When set to "0" indicates R/W in debug mode
     * should be directed to Bank 0 (GCL0 and corresponding Time related
     * registers).
     */
    inline void clear_MTL_EST_GCL_CONTROL_DBGB() volatile
    {
        MTL_EST_GCL_CONTROL &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_EST_GCL_CONTROL's DBGB bit.
     *
     * Debug Mode Bank Select When set to "0" indicates R/W in debug mode
     * should be directed to Bank 0 (GCL0 and corresponding Time related
     * registers).
     */
    inline void toggle_MTL_EST_GCL_CONTROL_DBGB() volatile
    {
        MTL_EST_GCL_CONTROL ^= 1u << 5u;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's DBGM bit.
     *
     * Debug Mode When set to "1" indicates R/W in debug mode where the memory
     * bank (for GCL and Time related registers) is explicitly provided by DBGB
     * value, when set to "0" SWOL bit is used to determine which bank to use.
     */
    inline bool get_MTL_EST_GCL_CONTROL_DBGM() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 4u);
    }

    /**
     * Set MTL_EST_GCL_CONTROL's DBGM bit.
     *
     * Debug Mode When set to "1" indicates R/W in debug mode where the memory
     * bank (for GCL and Time related registers) is explicitly provided by DBGB
     * value, when set to "0" SWOL bit is used to determine which bank to use.
     */
    inline void set_MTL_EST_GCL_CONTROL_DBGM() volatile
    {
        MTL_EST_GCL_CONTROL |= 1u << 4u;
    }

    /**
     * Clear MTL_EST_GCL_CONTROL's DBGM bit.
     *
     * Debug Mode When set to "1" indicates R/W in debug mode where the memory
     * bank (for GCL and Time related registers) is explicitly provided by DBGB
     * value, when set to "0" SWOL bit is used to determine which bank to use.
     */
    inline void clear_MTL_EST_GCL_CONTROL_DBGM() volatile
    {
        MTL_EST_GCL_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_EST_GCL_CONTROL's DBGM bit.
     *
     * Debug Mode When set to "1" indicates R/W in debug mode where the memory
     * bank (for GCL and Time related registers) is explicitly provided by DBGB
     * value, when set to "0" SWOL bit is used to determine which bank to use.
     */
    inline void toggle_MTL_EST_GCL_CONTROL_DBGM() volatile
    {
        MTL_EST_GCL_CONTROL ^= 1u << 4u;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's GCRR bit.
     *
     * Gate Control Related Registers When set to "1" indicates the R/W access
     * is for the GCL related registers (BTR, CTR, TER, LLR) whose address is
     * provided by GCRA.
     */
    inline bool get_MTL_EST_GCL_CONTROL_GCRR() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 2u);
    }

    /**
     * Set MTL_EST_GCL_CONTROL's GCRR bit.
     *
     * Gate Control Related Registers When set to "1" indicates the R/W access
     * is for the GCL related registers (BTR, CTR, TER, LLR) whose address is
     * provided by GCRA.
     */
    inline void set_MTL_EST_GCL_CONTROL_GCRR() volatile
    {
        MTL_EST_GCL_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MTL_EST_GCL_CONTROL's GCRR bit.
     *
     * Gate Control Related Registers When set to "1" indicates the R/W access
     * is for the GCL related registers (BTR, CTR, TER, LLR) whose address is
     * provided by GCRA.
     */
    inline void clear_MTL_EST_GCL_CONTROL_GCRR() volatile
    {
        MTL_EST_GCL_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_EST_GCL_CONTROL's GCRR bit.
     *
     * Gate Control Related Registers When set to "1" indicates the R/W access
     * is for the GCL related registers (BTR, CTR, TER, LLR) whose address is
     * provided by GCRA.
     */
    inline void toggle_MTL_EST_GCL_CONTROL_GCRR() volatile
    {
        MTL_EST_GCL_CONTROL ^= 1u << 2u;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's R1W0 bit.
     *
     * Read '1', Write '0': When set to '1': Read Operation When set to '0':
     * Write Operation.
     */
    inline bool get_MTL_EST_GCL_CONTROL_R1W0() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 1u);
    }

    /**
     * Set MTL_EST_GCL_CONTROL's R1W0 bit.
     *
     * Read '1', Write '0': When set to '1': Read Operation When set to '0':
     * Write Operation.
     */
    inline void set_MTL_EST_GCL_CONTROL_R1W0() volatile
    {
        MTL_EST_GCL_CONTROL |= 1u << 1u;
    }

    /**
     * Clear MTL_EST_GCL_CONTROL's R1W0 bit.
     *
     * Read '1', Write '0': When set to '1': Read Operation When set to '0':
     * Write Operation.
     */
    inline void clear_MTL_EST_GCL_CONTROL_R1W0() volatile
    {
        MTL_EST_GCL_CONTROL &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_EST_GCL_CONTROL's R1W0 bit.
     *
     * Read '1', Write '0': When set to '1': Read Operation When set to '0':
     * Write Operation.
     */
    inline void toggle_MTL_EST_GCL_CONTROL_R1W0() volatile
    {
        MTL_EST_GCL_CONTROL ^= 1u << 1u;
    }

    /**
     * Get MTL_EST_GCL_CONTROL's SRWO bit.
     *
     * Start Read/Write Op When set indicates a Read/Write Op has started and
     * is in progress.
     */
    inline bool get_MTL_EST_GCL_CONTROL_SRWO() volatile
    {
        return MTL_EST_GCL_CONTROL & (1u << 0u);
    }

    /**
     * Set MTL_EST_GCL_CONTROL's SRWO bit.
     *
     * Start Read/Write Op When set indicates a Read/Write Op has started and
     * is in progress.
     */
    inline void set_MTL_EST_GCL_CONTROL_SRWO() volatile
    {
        MTL_EST_GCL_CONTROL |= 1u << 0u;
    }

    /**
     * Clear MTL_EST_GCL_CONTROL's SRWO bit.
     *
     * Start Read/Write Op When set indicates a Read/Write Op has started and
     * is in progress.
     */
    inline void clear_MTL_EST_GCL_CONTROL_SRWO() volatile
    {
        MTL_EST_GCL_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_EST_GCL_CONTROL's SRWO bit.
     *
     * Start Read/Write Op When set indicates a Read/Write Op has started and
     * is in progress.
     */
    inline void toggle_MTL_EST_GCL_CONTROL_SRWO() volatile
    {
        MTL_EST_GCL_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of MTL_EST_GCL_CONTROL's bit fields.
     *
     * (read-write) EST GCL Control
     */
    inline void get_MTL_EST_GCL_CONTROL(
        ENET_QOS_MTL_EST_GCL_CONTROL_ESTEIEC &ESTEIEC, bool &ESTEIEE,
        bool &ERR0, uint16_t &ADDR, bool &DBGB, bool &DBGM, bool &GCRR,
        bool &R1W0, bool &SRWO) volatile
    {
        uint32_t curr = MTL_EST_GCL_CONTROL;

        ESTEIEC = ENET_QOS_MTL_EST_GCL_CONTROL_ESTEIEC((curr >> 22u) & 0b11u);
        ESTEIEE = curr & (1u << 21u);
        ERR0 = curr & (1u << 20u);
        ADDR = (curr >> 8u) & 0b111111111u;
        DBGB = curr & (1u << 5u);
        DBGM = curr & (1u << 4u);
        GCRR = curr & (1u << 2u);
        R1W0 = curr & (1u << 1u);
        SRWO = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_EST_GCL_CONTROL's bit fields.
     *
     * (read-write) EST GCL Control
     */
    inline void set_MTL_EST_GCL_CONTROL(bool ERR0, uint16_t ADDR, bool DBGB,
                                        bool DBGM, bool GCRR, bool R1W0,
                                        bool SRWO) volatile
    {
        uint32_t curr = MTL_EST_GCL_CONTROL;

        curr &= ~(0b1u << 20u);
        curr |= (ERR0 & 0b1u) << 20u;
        curr &= ~(0b111111111u << 8u);
        curr |= (ADDR & 0b111111111u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (DBGB & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DBGM & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (GCRR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (R1W0 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRWO & 0b1u) << 0u;

        MTL_EST_GCL_CONTROL = curr;
    }

    /**
     * Get MTL_EST_GCL_DATA's GCD field.
     *
     * Gate Control Data The data corresponding to the address selected in the
     * MTL_GCL_CONTROL register.
     */
    inline uint32_t get_MTL_EST_GCL_DATA_GCD() volatile
    {
        return (MTL_EST_GCL_DATA >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MTL_EST_GCL_DATA's GCD field.
     *
     * Gate Control Data The data corresponding to the address selected in the
     * MTL_GCL_CONTROL register.
     */
    inline void set_MTL_EST_GCL_DATA_GCD(uint32_t value) volatile
    {
        uint32_t curr = MTL_EST_GCL_DATA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MTL_EST_GCL_DATA = curr;
    }

    /**
     * Get MTL_FPE_CTRL_STS's HRS bit.
     *
     * Hold/Release Status - 1: Indicates a Set-and-Hold-MAC operation was last
     * executed and the pMAC is in Hold State.
     */
    inline bool get_MTL_FPE_CTRL_STS_HRS() volatile
    {
        return MTL_FPE_CTRL_STS & (1u << 28u);
    }

    /**
     * Get MTL_FPE_CTRL_STS's PEC field.
     *
     * Preemption Classification When set indicates the corresponding Queue
     * must be classified as preemptable, when '0' Queue is classified as
     * express.
     */
    inline uint8_t get_MTL_FPE_CTRL_STS_PEC() volatile
    {
        return (MTL_FPE_CTRL_STS >> 8u) & 0b11111u;
    }

    /**
     * Set MTL_FPE_CTRL_STS's PEC field.
     *
     * Preemption Classification When set indicates the corresponding Queue
     * must be classified as preemptable, when '0' Queue is classified as
     * express.
     */
    inline void set_MTL_FPE_CTRL_STS_PEC(uint8_t value) volatile
    {
        uint32_t curr = MTL_FPE_CTRL_STS;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        MTL_FPE_CTRL_STS = curr;
    }

    /**
     * Get MTL_FPE_CTRL_STS's AFSZ field.
     *
     * Additional Fragment Size used to indicate, in units of 64 bytes, the
     * minimum number of bytes over 64 bytes required in non-final fragments of
     * preempted frames.
     */
    inline uint8_t get_MTL_FPE_CTRL_STS_AFSZ() volatile
    {
        return (MTL_FPE_CTRL_STS >> 0u) & 0b11u;
    }

    /**
     * Set MTL_FPE_CTRL_STS's AFSZ field.
     *
     * Additional Fragment Size used to indicate, in units of 64 bytes, the
     * minimum number of bytes over 64 bytes required in non-final fragments of
     * preempted frames.
     */
    inline void set_MTL_FPE_CTRL_STS_AFSZ(uint8_t value) volatile
    {
        uint32_t curr = MTL_FPE_CTRL_STS;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        MTL_FPE_CTRL_STS = curr;
    }

    /**
     * Get all of MTL_FPE_CTRL_STS's bit fields.
     *
     * (read-write) Frame Preemption Control and Status
     */
    inline void get_MTL_FPE_CTRL_STS(bool &HRS, uint8_t &PEC,
                                     uint8_t &AFSZ) volatile
    {
        uint32_t curr = MTL_FPE_CTRL_STS;

        HRS = curr & (1u << 28u);
        PEC = (curr >> 8u) & 0b11111u;
        AFSZ = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of MTL_FPE_CTRL_STS's bit fields.
     *
     * (read-write) Frame Preemption Control and Status
     */
    inline void set_MTL_FPE_CTRL_STS(uint8_t PEC, uint8_t AFSZ) volatile
    {
        uint32_t curr = MTL_FPE_CTRL_STS;

        curr &= ~(0b11111u << 8u);
        curr |= (PEC & 0b11111u) << 8u;
        curr &= ~(0b11u << 0u);
        curr |= (AFSZ & 0b11u) << 0u;

        MTL_FPE_CTRL_STS = curr;
    }

    /**
     * Get MTL_FPE_ADVANCE's RADV field.
     *
     * Release Advance The maximum time in nanoseconds that can elapse between
     * issuing a RELEASE to the MAC and the MAC being ready to resume
     * transmission of preemptable frames, in the absence of there being any
     * express frames available for transmission.
     */
    inline uint16_t get_MTL_FPE_ADVANCE_RADV() volatile
    {
        return (MTL_FPE_ADVANCE >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MTL_FPE_ADVANCE's RADV field.
     *
     * Release Advance The maximum time in nanoseconds that can elapse between
     * issuing a RELEASE to the MAC and the MAC being ready to resume
     * transmission of preemptable frames, in the absence of there being any
     * express frames available for transmission.
     */
    inline void set_MTL_FPE_ADVANCE_RADV(uint16_t value) volatile
    {
        uint32_t curr = MTL_FPE_ADVANCE;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MTL_FPE_ADVANCE = curr;
    }

    /**
     * Get MTL_FPE_ADVANCE's HADV field.
     *
     * Hold Advance The maximum time in nanoseconds that can elapse between
     * issuing a HOLD to the MAC and the MAC ceasing to transmit any
     * preemptable frame that is in the process of transmission or any
     * preemptable frames that are queued for transmission.
     */
    inline uint16_t get_MTL_FPE_ADVANCE_HADV() volatile
    {
        return (MTL_FPE_ADVANCE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MTL_FPE_ADVANCE's HADV field.
     *
     * Hold Advance The maximum time in nanoseconds that can elapse between
     * issuing a HOLD to the MAC and the MAC ceasing to transmit any
     * preemptable frame that is in the process of transmission or any
     * preemptable frames that are queued for transmission.
     */
    inline void set_MTL_FPE_ADVANCE_HADV(uint16_t value) volatile
    {
        uint32_t curr = MTL_FPE_ADVANCE;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MTL_FPE_ADVANCE = curr;
    }

    /**
     * Get all of MTL_FPE_ADVANCE's bit fields.
     *
     * (read-write) Frame Preemption Hold and Release Advance
     */
    inline void get_MTL_FPE_ADVANCE(uint16_t &RADV, uint16_t &HADV) volatile
    {
        uint32_t curr = MTL_FPE_ADVANCE;

        RADV = (curr >> 16u) & 0b1111111111111111u;
        HADV = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MTL_FPE_ADVANCE's bit fields.
     *
     * (read-write) Frame Preemption Hold and Release Advance
     */
    inline void set_MTL_FPE_ADVANCE(uint16_t RADV, uint16_t HADV) volatile
    {
        uint32_t curr = MTL_FPE_ADVANCE;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (RADV & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (HADV & 0b1111111111111111u) << 0u;

        MTL_FPE_ADVANCE = curr;
    }

    /**
     * Get MTL_RXP_CONTROL_STATUS's RXPI bit.
     *
     * RX Parser in Idle state This status bit is set to 1 when the Rx parser
     * is in Idle State and waiting for a new packet for processing.
     */
    inline bool get_MTL_RXP_CONTROL_STATUS_RXPI() volatile
    {
        return MTL_RXP_CONTROL_STATUS & (1u << 31u);
    }

    /**
     * Get MTL_RXP_CONTROL_STATUS's NPE field.
     *
     * Number of parsable entries in the Instruction table This control
     * indicates the number of parsable entries in the Instruction Memory.
     */
    inline uint8_t get_MTL_RXP_CONTROL_STATUS_NPE() volatile
    {
        return (MTL_RXP_CONTROL_STATUS >> 16u) & 0b11111111u;
    }

    /**
     * Set MTL_RXP_CONTROL_STATUS's NPE field.
     *
     * Number of parsable entries in the Instruction table This control
     * indicates the number of parsable entries in the Instruction Memory.
     */
    inline void set_MTL_RXP_CONTROL_STATUS_NPE(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXP_CONTROL_STATUS;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MTL_RXP_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXP_CONTROL_STATUS's NVE field.
     *
     * Number of valid entries in the Instruction table This control indicates
     * the number of valid entries in the Instruction Memory.
     */
    inline uint8_t get_MTL_RXP_CONTROL_STATUS_NVE() volatile
    {
        return (MTL_RXP_CONTROL_STATUS >> 0u) & 0b11111111u;
    }

    /**
     * Set MTL_RXP_CONTROL_STATUS's NVE field.
     *
     * Number of valid entries in the Instruction table This control indicates
     * the number of valid entries in the Instruction Memory.
     */
    inline void set_MTL_RXP_CONTROL_STATUS_NVE(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXP_CONTROL_STATUS;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        MTL_RXP_CONTROL_STATUS = curr;
    }

    /**
     * Get all of MTL_RXP_CONTROL_STATUS's bit fields.
     *
     * (read-write) RXP Control Status
     */
    inline void get_MTL_RXP_CONTROL_STATUS(bool &RXPI, uint8_t &NPE,
                                           uint8_t &NVE) volatile
    {
        uint32_t curr = MTL_RXP_CONTROL_STATUS;

        RXPI = curr & (1u << 31u);
        NPE = (curr >> 16u) & 0b11111111u;
        NVE = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of MTL_RXP_CONTROL_STATUS's bit fields.
     *
     * (read-write) RXP Control Status
     */
    inline void set_MTL_RXP_CONTROL_STATUS(uint8_t NPE, uint8_t NVE) volatile
    {
        uint32_t curr = MTL_RXP_CONTROL_STATUS;

        curr &= ~(0b11111111u << 16u);
        curr |= (NPE & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (NVE & 0b11111111u) << 0u;

        MTL_RXP_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIE bit.
     *
     * Packet Drop due to RF Interrupt Enable When this bit is set, the PDRFIS
     * interrupt is enabled.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIE() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 19u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIE bit.
     *
     * Packet Drop due to RF Interrupt Enable When this bit is set, the PDRFIS
     * interrupt is enabled.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 19u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIE bit.
     *
     * Packet Drop due to RF Interrupt Enable When this bit is set, the PDRFIS
     * interrupt is enabled.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 19u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIE bit.
     *
     * Packet Drop due to RF Interrupt Enable When this bit is set, the PDRFIS
     * interrupt is enabled.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 19u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIE bit.
     *
     * Frame Offset Overflow Interrupt Enable When this bit is set, the FOOVIS
     * interrupt is enabled.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIE() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 18u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIE bit.
     *
     * Frame Offset Overflow Interrupt Enable When this bit is set, the FOOVIS
     * interrupt is enabled.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 18u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIE bit.
     *
     * Frame Offset Overflow Interrupt Enable When this bit is set, the FOOVIS
     * interrupt is enabled.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 18u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIE bit.
     *
     * Frame Offset Overflow Interrupt Enable When this bit is set, the FOOVIS
     * interrupt is enabled.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 18u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIE bit.
     *
     * Number of Parsable Entries Overflow Interrupt Enable When this bit is
     * set, the NPEOVIS interrupt is enabled.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIE() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 17u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIE bit.
     *
     * Number of Parsable Entries Overflow Interrupt Enable When this bit is
     * set, the NPEOVIS interrupt is enabled.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 17u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIE bit.
     *
     * Number of Parsable Entries Overflow Interrupt Enable When this bit is
     * set, the NPEOVIS interrupt is enabled.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 17u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIE bit.
     *
     * Number of Parsable Entries Overflow Interrupt Enable When this bit is
     * set, the NPEOVIS interrupt is enabled.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 17u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIE bit.
     *
     * Number of Valid Entries Overflow Interrupt Enable When this bit is set,
     * the NVEOVIS interrupt is enabled.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIE() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIE bit.
     *
     * Number of Valid Entries Overflow Interrupt Enable When this bit is set,
     * the NVEOVIS interrupt is enabled.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIE bit.
     *
     * Number of Valid Entries Overflow Interrupt Enable When this bit is set,
     * the NVEOVIS interrupt is enabled.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIE bit.
     *
     * Number of Valid Entries Overflow Interrupt Enable When this bit is set,
     * the NVEOVIS interrupt is enabled.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIE() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIS bit.
     *
     * Packet Dropped due to RF Interrupt Status If the Rx Parser result says
     * to drop the packet by setting RF=1 in the instruction memory, then this
     * bit is set to 1.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIS() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 3u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIS bit.
     *
     * Packet Dropped due to RF Interrupt Status If the Rx Parser result says
     * to drop the packet by setting RF=1 in the instruction memory, then this
     * bit is set to 1.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 3u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIS bit.
     *
     * Packet Dropped due to RF Interrupt Status If the Rx Parser result says
     * to drop the packet by setting RF=1 in the instruction memory, then this
     * bit is set to 1.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's PDRFIS bit.
     *
     * Packet Dropped due to RF Interrupt Status If the Rx Parser result says
     * to drop the packet by setting RF=1 in the instruction memory, then this
     * bit is set to 1.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_PDRFIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 3u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIS bit.
     *
     * Frame Offset Overflow Interrupt Status While parsing if the Instruction
     * table entry's 'Frame Offset' found to be more than EOF offset, then then
     * this bit is set.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIS() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 2u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIS bit.
     *
     * Frame Offset Overflow Interrupt Status While parsing if the Instruction
     * table entry's 'Frame Offset' found to be more than EOF offset, then then
     * this bit is set.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 2u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIS bit.
     *
     * Frame Offset Overflow Interrupt Status While parsing if the Instruction
     * table entry's 'Frame Offset' found to be more than EOF offset, then then
     * this bit is set.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's FOOVIS bit.
     *
     * Frame Offset Overflow Interrupt Status While parsing if the Instruction
     * table entry's 'Frame Offset' found to be more than EOF offset, then then
     * this bit is set.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_FOOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 2u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIS bit.
     *
     * Number of Parsable Entries Overflow Interrupt Status While parsing a
     * packet if the number of parsed entries found to be more than NPE[]
     * (Number of Parseable Entries in MTL_RXP_CONTROL register),then this bit
     * is set to 1.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIS() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIS bit.
     *
     * Number of Parsable Entries Overflow Interrupt Status While parsing a
     * packet if the number of parsed entries found to be more than NPE[]
     * (Number of Parseable Entries in MTL_RXP_CONTROL register),then this bit
     * is set to 1.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIS bit.
     *
     * Number of Parsable Entries Overflow Interrupt Status While parsing a
     * packet if the number of parsed entries found to be more than NPE[]
     * (Number of Parseable Entries in MTL_RXP_CONTROL register),then this bit
     * is set to 1.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's NPEOVIS bit.
     *
     * Number of Parsable Entries Overflow Interrupt Status While parsing a
     * packet if the number of parsed entries found to be more than NPE[]
     * (Number of Parseable Entries in MTL_RXP_CONTROL register),then this bit
     * is set to 1.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_NPEOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIS bit.
     *
     * Number of Valid Entries Overflow Interrupt Status While parsing if the
     * Instruction address found to be more than NVE (Number of Valid Entries
     * in MTL_RXP_CONTROL register), then this bit is set to 1.
     */
    inline bool get_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIS() volatile
    {
        return MTL_RXP_INTERRUPT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIS bit.
     *
     * Number of Valid Entries Overflow Interrupt Status While parsing if the
     * Instruction address found to be more than NVE (Number of Valid Entries
     * in MTL_RXP_CONTROL register), then this bit is set to 1.
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIS bit.
     *
     * Number of Valid Entries Overflow Interrupt Status While parsing if the
     * Instruction address found to be more than NVE (Number of Valid Entries
     * in MTL_RXP_CONTROL register), then this bit is set to 1.
     */
    inline void clear_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_RXP_INTERRUPT_CONTROL_STATUS's NVEOVIS bit.
     *
     * Number of Valid Entries Overflow Interrupt Status While parsing if the
     * Instruction address found to be more than NVE (Number of Valid Entries
     * in MTL_RXP_CONTROL register), then this bit is set to 1.
     */
    inline void toggle_MTL_RXP_INTERRUPT_CONTROL_STATUS_NVEOVIS() volatile
    {
        MTL_RXP_INTERRUPT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_RXP_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) RXP Interrupt Control Status
     */
    inline void get_MTL_RXP_INTERRUPT_CONTROL_STATUS(
        bool &PDRFIE, bool &FOOVIE, bool &NPEOVIE, bool &NVEOVIE, bool &PDRFIS,
        bool &FOOVIS, bool &NPEOVIS, bool &NVEOVIS) volatile
    {
        uint32_t curr = MTL_RXP_INTERRUPT_CONTROL_STATUS;

        PDRFIE = curr & (1u << 19u);
        FOOVIE = curr & (1u << 18u);
        NPEOVIE = curr & (1u << 17u);
        NVEOVIE = curr & (1u << 16u);
        PDRFIS = curr & (1u << 3u);
        FOOVIS = curr & (1u << 2u);
        NPEOVIS = curr & (1u << 1u);
        NVEOVIS = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_RXP_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) RXP Interrupt Control Status
     */
    inline void set_MTL_RXP_INTERRUPT_CONTROL_STATUS(bool PDRFIE, bool FOOVIE,
                                                     bool NPEOVIE,
                                                     bool NVEOVIE, bool PDRFIS,
                                                     bool FOOVIS, bool NPEOVIS,
                                                     bool NVEOVIS) volatile
    {
        uint32_t curr = MTL_RXP_INTERRUPT_CONTROL_STATUS;

        curr &= ~(0b1u << 19u);
        curr |= (PDRFIE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (FOOVIE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (NPEOVIE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (NVEOVIE & 0b1u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (PDRFIS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FOOVIS & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (NPEOVIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (NVEOVIS & 0b1u) << 0u;

        MTL_RXP_INTERRUPT_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXP_DROP_CNT's RXPDCOVF bit.
     *
     * Rx Parser Drop Counter Overflow Bit When set, this bit indicates that
     * the MTL_RXP_DROP_CNT (RXPDC) Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXP_DROP_CNT_RXPDCOVF() volatile
    {
        return MTL_RXP_DROP_CNT & (1u << 31u);
    }

    /**
     * Get MTL_RXP_DROP_CNT's RXPDC field.
     *
     * Rx Parser Drop count This 31-bit counter is implemented whenever a Rx
     * Parser Drops a packet due to RF =1.
     */
    inline uint32_t get_MTL_RXP_DROP_CNT_RXPDC() volatile
    {
        return (MTL_RXP_DROP_CNT >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get all of MTL_RXP_DROP_CNT's bit fields.
     *
     * (read-write) RXP Drop Count
     */
    inline void get_MTL_RXP_DROP_CNT(bool &RXPDCOVF, uint32_t &RXPDC) volatile
    {
        uint32_t curr = MTL_RXP_DROP_CNT;

        RXPDCOVF = curr & (1u << 31u);
        RXPDC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get MTL_RXP_ERROR_CNT's RXPECOVF bit.
     *
     * Rx Parser Error Counter Overflow Bit When set, this bit indicates that
     * the MTL_RXP_ERROR_CNT (RXPEC) Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXP_ERROR_CNT_RXPECOVF() volatile
    {
        return MTL_RXP_ERROR_CNT & (1u << 31u);
    }

    /**
     * Get MTL_RXP_ERROR_CNT's RXPEC field.
     *
     * Rx Parser Error count This 31-bit counter is implemented whenever a Rx
     * Parser encounters following Error scenarios - Entry address >= NVE[] -
     * Number Parsed Entries >= NPE[] - Entry address > EOF data entry address
     * The counter is cleared when the register is read.
     */
    inline uint32_t get_MTL_RXP_ERROR_CNT_RXPEC() volatile
    {
        return (MTL_RXP_ERROR_CNT >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get all of MTL_RXP_ERROR_CNT's bit fields.
     *
     * (read-write) RXP Error Count
     */
    inline void get_MTL_RXP_ERROR_CNT(bool &RXPECOVF, uint32_t &RXPEC) volatile
    {
        uint32_t curr = MTL_RXP_ERROR_CNT;

        RXPECOVF = curr & (1u << 31u);
        RXPEC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's STARTBUSY bit.
     *
     * FRP Instruction Table Access Busy When this bit is set to 1 by the
     * software then it indicates to start the Read/Write operation from/to the
     * Rx Parser Memory.
     */
    inline bool get_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_STARTBUSY() volatile
    {
        return MTL_RXP_INDIRECT_ACC_CONTROL_STATUS & (1u << 31u);
    }

    /**
     * Set MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's STARTBUSY bit.
     *
     * FRP Instruction Table Access Busy When this bit is set to 1 by the
     * software then it indicates to start the Read/Write operation from/to the
     * Rx Parser Memory.
     */
    inline void set_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_STARTBUSY() volatile
    {
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS |= 1u << 31u;
    }

    /**
     * Clear MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's STARTBUSY bit.
     *
     * FRP Instruction Table Access Busy When this bit is set to 1 by the
     * software then it indicates to start the Read/Write operation from/to the
     * Rx Parser Memory.
     */
    inline void clear_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_STARTBUSY() volatile
    {
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS &= ~(1u << 31u);
    }

    /**
     * Toggle MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's STARTBUSY bit.
     *
     * FRP Instruction Table Access Busy When this bit is set to 1 by the
     * software then it indicates to start the Read/Write operation from/to the
     * Rx Parser Memory.
     */
    inline void toggle_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_STARTBUSY() volatile
    {
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS ^= 1u << 31u;
    }

    /**
     * Get MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's WRRDN bit.
     *
     * Read Write Control When this bit is set to 1 indicates the write
     * operation to the Rx Parser Memory.
     */
    inline bool get_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_WRRDN() volatile
    {
        return MTL_RXP_INDIRECT_ACC_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's WRRDN bit.
     *
     * Read Write Control When this bit is set to 1 indicates the write
     * operation to the Rx Parser Memory.
     */
    inline void set_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_WRRDN() volatile
    {
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's WRRDN bit.
     *
     * Read Write Control When this bit is set to 1 indicates the write
     * operation to the Rx Parser Memory.
     */
    inline void clear_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_WRRDN() volatile
    {
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's WRRDN bit.
     *
     * Read Write Control When this bit is set to 1 indicates the write
     * operation to the Rx Parser Memory.
     */
    inline void toggle_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_WRRDN() volatile
    {
        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's ADDR field.
     *
     * FRP Instruction Table Offset Address This field indicates the ADDR of
     * the 32-bit entry in Rx parser instruction table.
     */
    inline uint16_t get_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_ADDR() volatile
    {
        return (MTL_RXP_INDIRECT_ACC_CONTROL_STATUS >> 0u) & 0b1111111111u;
    }

    /**
     * Set MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's ADDR field.
     *
     * FRP Instruction Table Offset Address This field indicates the ADDR of
     * the 32-bit entry in Rx parser instruction table.
     */
    inline void set_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS_ADDR(
        uint16_t value) volatile
    {
        uint32_t curr = MTL_RXP_INDIRECT_ACC_CONTROL_STATUS;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS = curr;
    }

    /**
     * Get all of MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's bit fields.
     *
     * (read-write) RXP Indirect Access Control and Status
     */
    inline void get_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS(
        bool &STARTBUSY, bool &WRRDN, uint16_t &ADDR) volatile
    {
        uint32_t curr = MTL_RXP_INDIRECT_ACC_CONTROL_STATUS;

        STARTBUSY = curr & (1u << 31u);
        WRRDN = curr & (1u << 16u);
        ADDR = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of MTL_RXP_INDIRECT_ACC_CONTROL_STATUS's bit fields.
     *
     * (read-write) RXP Indirect Access Control and Status
     */
    inline void set_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS(bool STARTBUSY,
                                                        bool WRRDN,
                                                        uint16_t ADDR) volatile
    {
        uint32_t curr = MTL_RXP_INDIRECT_ACC_CONTROL_STATUS;

        curr &= ~(0b1u << 31u);
        curr |= (STARTBUSY & 0b1u) << 31u;
        curr &= ~(0b1u << 16u);
        curr |= (WRRDN & 0b1u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (ADDR & 0b1111111111u) << 0u;

        MTL_RXP_INDIRECT_ACC_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXP_INDIRECT_ACC_DATA's DATA field.
     *
     * FRP Instruction Table Write/Read Data Software should write this
     * register before issuing any write command.
     */
    inline uint32_t get_MTL_RXP_INDIRECT_ACC_DATA_DATA() volatile
    {
        return (MTL_RXP_INDIRECT_ACC_DATA >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set MTL_RXP_INDIRECT_ACC_DATA's DATA field.
     *
     * FRP Instruction Table Write/Read Data Software should write this
     * register before issuing any write command.
     */
    inline void set_MTL_RXP_INDIRECT_ACC_DATA_DATA(uint32_t value) volatile
    {
        uint32_t curr = MTL_RXP_INDIRECT_ACC_DATA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MTL_RXP_INDIRECT_ACC_DATA = curr;
    }

    /**
     * Get MTL_TXQ0_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_TXQ0_OPERATION_MODE_TQS() volatile
    {
        return (MTL_TXQ0_OPERATION_MODE >> 16u) & 0b11111u;
    }

    /**
     * Set MTL_TXQ0_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline void set_MTL_TXQ0_OPERATION_MODE_TQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_TXQ0_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MTL_TXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ0_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC
    get_MTL_TXQ0_OPERATION_MODE_TTC() volatile
    {
        return ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC(
            (MTL_TXQ0_OPERATION_MODE >> 4u) & 0b111u);
    }

    /**
     * Set MTL_TXQ0_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline void set_MTL_TXQ0_OPERATION_MODE_TTC(
        ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC value) volatile
    {
        uint32_t curr = MTL_TXQ0_OPERATION_MODE;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ0_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN
    get_MTL_TXQ0_OPERATION_MODE_TXQEN() volatile
    {
        return ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN(
            (MTL_TXQ0_OPERATION_MODE >> 2u) & 0b11u);
    }

    /**
     * Set MTL_TXQ0_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline void set_MTL_TXQ0_OPERATION_MODE_TXQEN(
        ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN value) volatile
    {
        uint32_t curr = MTL_TXQ0_OPERATION_MODE;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MTL_TXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ0_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline bool get_MTL_TXQ0_OPERATION_MODE_TSF() volatile
    {
        return MTL_TXQ0_OPERATION_MODE & (1u << 1u);
    }

    /**
     * Set MTL_TXQ0_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void set_MTL_TXQ0_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ0_OPERATION_MODE |= 1u << 1u;
    }

    /**
     * Clear MTL_TXQ0_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void clear_MTL_TXQ0_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ0_OPERATION_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_TXQ0_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void toggle_MTL_TXQ0_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ0_OPERATION_MODE ^= 1u << 1u;
    }

    /**
     * Get MTL_TXQ0_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline bool get_MTL_TXQ0_OPERATION_MODE_FTQ() volatile
    {
        return MTL_TXQ0_OPERATION_MODE & (1u << 0u);
    }

    /**
     * Set MTL_TXQ0_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void set_MTL_TXQ0_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ0_OPERATION_MODE |= 1u << 0u;
    }

    /**
     * Clear MTL_TXQ0_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void clear_MTL_TXQ0_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ0_OPERATION_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_TXQ0_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void toggle_MTL_TXQ0_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ0_OPERATION_MODE ^= 1u << 0u;
    }

    /**
     * Get all of MTL_TXQ0_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 0 Transmit Operation Mode
     */
    inline void get_MTL_TXQ0_OPERATION_MODE(
        uint8_t &TQS, ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC &TTC,
        ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN &TXQEN, bool &TSF,
        bool &FTQ) volatile
    {
        uint32_t curr = MTL_TXQ0_OPERATION_MODE;

        TQS = (curr >> 16u) & 0b11111u;
        TTC = ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC((curr >> 4u) & 0b111u);
        TXQEN = ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN((curr >> 2u) & 0b11u);
        TSF = curr & (1u << 1u);
        FTQ = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_TXQ0_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 0 Transmit Operation Mode
     */
    inline void set_MTL_TXQ0_OPERATION_MODE(
        uint8_t TQS, ENET_QOS_MTL_TXQ0_OPERATION_MODE_TTC TTC,
        ENET_QOS_MTL_TXQ0_OPERATION_MODE_TXQEN TXQEN, bool TSF,
        bool FTQ) volatile
    {
        uint32_t curr = MTL_TXQ0_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (TQS & 0b11111u) << 16u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(TTC) & 0b111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(TXQEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FTQ & 0b1u) << 0u;

        MTL_TXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ0_UNDERFLOW's UFCNTOVF bit.
     *
     * Overflow Bit for Underflow Packet Counter This bit is set every time the
     * Tx queue Underflow Packet Counter field overflows, that is, it has
     * crossed the maximum count.
     */
    inline bool get_MTL_TXQ0_UNDERFLOW_UFCNTOVF() volatile
    {
        return MTL_TXQ0_UNDERFLOW & (1u << 11u);
    }

    /**
     * Get MTL_TXQ0_UNDERFLOW's UFFRMCNT field.
     *
     * Underflow Packet Counter This field indicates the number of packets
     * aborted by the controller because of Tx Queue Underflow.
     */
    inline uint16_t get_MTL_TXQ0_UNDERFLOW_UFFRMCNT() volatile
    {
        return (MTL_TXQ0_UNDERFLOW >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_TXQ0_UNDERFLOW's bit fields.
     *
     * (read-write) Queue 0 Underflow Counter
     */
    inline void get_MTL_TXQ0_UNDERFLOW(bool &UFCNTOVF,
                                       uint16_t &UFFRMCNT) volatile
    {
        uint32_t curr = MTL_TXQ0_UNDERFLOW;

        UFCNTOVF = curr & (1u << 11u);
        UFFRMCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_TXQ0_DEBUG's STXSTSF field.
     *
     * Number of Status Words in Tx Status FIFO of Queue This field indicates
     * the current number of status in the Tx Status FIFO of this queue.
     */
    inline uint8_t get_MTL_TXQ0_DEBUG_STXSTSF() volatile
    {
        return (MTL_TXQ0_DEBUG >> 20u) & 0b111u;
    }

    /**
     * Get MTL_TXQ0_DEBUG's PTXQ field.
     *
     * Number of Packets in the Transmit Queue This field indicates the current
     * number of packets in the Tx Queue.
     */
    inline uint8_t get_MTL_TXQ0_DEBUG_PTXQ() volatile
    {
        return (MTL_TXQ0_DEBUG >> 16u) & 0b111u;
    }

    /**
     * Get MTL_TXQ0_DEBUG's TXSTSFSTS bit.
     *
     * MTL Tx Status FIFO Full Status When high, this bit indicates that the
     * MTL Tx Status FIFO is full.
     */
    inline bool get_MTL_TXQ0_DEBUG_TXSTSFSTS() volatile
    {
        return MTL_TXQ0_DEBUG & (1u << 5u);
    }

    /**
     * Get MTL_TXQ0_DEBUG's TXQSTS bit.
     *
     * MTL Tx Queue Not Empty Status When this bit is high, it indicates that
     * the MTL Tx Queue is not empty and some data is left for transmission.
     */
    inline bool get_MTL_TXQ0_DEBUG_TXQSTS() volatile
    {
        return MTL_TXQ0_DEBUG & (1u << 4u);
    }

    /**
     * Get MTL_TXQ0_DEBUG's TWCSTS bit.
     *
     * MTL Tx Queue Write Controller Status When high, this bit indicates that
     * the MTL Tx Queue Write Controller is active, and it is transferring the
     * data to the Tx Queue.
     */
    inline bool get_MTL_TXQ0_DEBUG_TWCSTS() volatile
    {
        return MTL_TXQ0_DEBUG & (1u << 3u);
    }

    /**
     * Get MTL_TXQ0_DEBUG's TRCSTS field.
     *
     * MTL Tx Queue Read Controller Status This field indicates the state of
     * the Tx Queue Read Controller:
     */
    inline ENET_QOS_MTL_TXQ0_DEBUG_TRCSTS get_MTL_TXQ0_DEBUG_TRCSTS() volatile
    {
        return ENET_QOS_MTL_TXQ0_DEBUG_TRCSTS((MTL_TXQ0_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_TXQ0_DEBUG's TXQPAUSED bit.
     *
     * Transmit Queue in Pause When this bit is high and the Rx flow control is
     * enabled, it indicates that the Tx Queue is in the Pause condition (in
     * the full-duplex only mode) because of the following: - Reception of the
     * PFC packet for the priorities assigned to the Tx Queue when PFC is
     * enabled - Reception of 802.
     */
    inline bool get_MTL_TXQ0_DEBUG_TXQPAUSED() volatile
    {
        return MTL_TXQ0_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_TXQ0_DEBUG's bit fields.
     *
     * (read-write) Queue 0 Transmit Debug
     */
    inline void get_MTL_TXQ0_DEBUG(uint8_t &STXSTSF, uint8_t &PTXQ,
                                   bool &TXSTSFSTS, bool &TXQSTS, bool &TWCSTS,
                                   ENET_QOS_MTL_TXQ0_DEBUG_TRCSTS &TRCSTS,
                                   bool &TXQPAUSED) volatile
    {
        uint32_t curr = MTL_TXQ0_DEBUG;

        STXSTSF = (curr >> 20u) & 0b111u;
        PTXQ = (curr >> 16u) & 0b111u;
        TXSTSFSTS = curr & (1u << 5u);
        TXQSTS = curr & (1u << 4u);
        TWCSTS = curr & (1u << 3u);
        TRCSTS = ENET_QOS_MTL_TXQ0_DEBUG_TRCSTS((curr >> 1u) & 0b11u);
        TXQPAUSED = curr & (1u << 0u);
    }

    /**
     * Get MTL_TXQ0_ETS_STATUS's ABS field.
     *
     * Average Bits per Slot This field contains the average transmitted bits
     * per slot.
     */
    inline uint32_t get_MTL_TXQ0_ETS_STATUS_ABS() volatile
    {
        return (MTL_TXQ0_ETS_STATUS >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get MTL_TXQ0_QUANTUM_WEIGHT's ISCQW field.
     *
     * Quantum or Weights When the DCB operation is enabled with DWRR algorithm
     * for Queue 0 traffic, this field contains the quantum value in bytes to
     * be added to credit during every queue scanning cycle.
     */
    inline uint32_t get_MTL_TXQ0_QUANTUM_WEIGHT_ISCQW() volatile
    {
        return (MTL_TXQ0_QUANTUM_WEIGHT >> 0u) & 0b111111111111111111111u;
    }

    /**
     * Set MTL_TXQ0_QUANTUM_WEIGHT's ISCQW field.
     *
     * Quantum or Weights When the DCB operation is enabled with DWRR algorithm
     * for Queue 0 traffic, this field contains the quantum value in bytes to
     * be added to credit during every queue scanning cycle.
     */
    inline void set_MTL_TXQ0_QUANTUM_WEIGHT_ISCQW(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ0_QUANTUM_WEIGHT;

        curr &= ~(0b111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111u) << 0u;

        MTL_TXQ0_QUANTUM_WEIGHT = curr;
    }

    /**
     * Get MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline bool get_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        return MTL_Q0_INTERRUPT_CONTROL_STATUS & (1u << 24u);
    }

    /**
     * Set MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS |= 1u << 24u;
    }

    /**
     * Clear MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void clear_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void toggle_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS ^= 1u << 24u;
    }

    /**
     * Get MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline bool get_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        return MTL_Q0_INTERRUPT_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void clear_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_Q0_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void toggle_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline bool get_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        return MTL_Q0_INTERRUPT_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Set MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS |= 1u << 9u;
    }

    /**
     * Clear MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void clear_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void toggle_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS ^= 1u << 9u;
    }

    /**
     * Get MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline bool get_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        return MTL_Q0_INTERRUPT_CONTROL_STATUS & (1u << 8u);
    }

    /**
     * Set MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS |= 1u << 8u;
    }

    /**
     * Clear MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void clear_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void toggle_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS ^= 1u << 8u;
    }

    /**
     * Get MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline bool get_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        return MTL_Q0_INTERRUPT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void clear_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_Q0_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void toggle_MTL_Q0_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline bool get_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        return MTL_Q0_INTERRUPT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void clear_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_Q0_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void toggle_MTL_Q0_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q0_INTERRUPT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_Q0_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 0 Interrupt Control Status
     */
    inline void get_MTL_Q0_INTERRUPT_CONTROL_STATUS(bool &RXOIE, bool &RXOVFIS,
                                                    bool &ABPSIE, bool &TXUIE,
                                                    bool &ABPSIS,
                                                    bool &TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q0_INTERRUPT_CONTROL_STATUS;

        RXOIE = curr & (1u << 24u);
        RXOVFIS = curr & (1u << 16u);
        ABPSIE = curr & (1u << 9u);
        TXUIE = curr & (1u << 8u);
        ABPSIS = curr & (1u << 1u);
        TXUNFIS = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_Q0_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 0 Interrupt Control Status
     */
    inline void set_MTL_Q0_INTERRUPT_CONTROL_STATUS(bool RXOIE, bool RXOVFIS,
                                                    bool ABPSIE, bool TXUIE,
                                                    bool ABPSIS,
                                                    bool TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q0_INTERRUPT_CONTROL_STATUS;

        curr &= ~(0b1u << 24u);
        curr |= (RXOIE & 0b1u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (RXOVFIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (ABPSIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TXUIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (ABPSIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXUNFIS & 0b1u) << 0u;

        MTL_Q0_INTERRUPT_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_RXQ0_OPERATION_MODE_RQS() volatile
    {
        return (MTL_RXQ0_OPERATION_MODE >> 20u) & 0b11111u;
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_RQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ0_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        MTL_RXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline uint8_t get_MTL_RXQ0_OPERATION_MODE_RFD() volatile
    {
        return (MTL_RXQ0_OPERATION_MODE >> 14u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_RFD(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ0_OPERATION_MODE;

        curr &= ~(0b1111u << 14u);
        curr |= (value & 0b1111u) << 14u;

        MTL_RXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline uint8_t get_MTL_RXQ0_OPERATION_MODE_RFA() volatile
    {
        return (MTL_RXQ0_OPERATION_MODE >> 8u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_RFA(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ0_OPERATION_MODE;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MTL_RXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline bool get_MTL_RXQ0_OPERATION_MODE_EHFC() volatile
    {
        return MTL_RXQ0_OPERATION_MODE & (1u << 7u);
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ0_OPERATION_MODE |= 1u << 7u;
    }

    /**
     * Clear MTL_RXQ0_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void clear_MTL_RXQ0_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ0_OPERATION_MODE &= ~(1u << 7u);
    }

    /**
     * Toggle MTL_RXQ0_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void toggle_MTL_RXQ0_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ0_OPERATION_MODE ^= 1u << 7u;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline bool get_MTL_RXQ0_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        return MTL_RXQ0_OPERATION_MODE & (1u << 6u);
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ0_OPERATION_MODE |= 1u << 6u;
    }

    /**
     * Clear MTL_RXQ0_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void clear_MTL_RXQ0_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ0_OPERATION_MODE &= ~(1u << 6u);
    }

    /**
     * Toggle MTL_RXQ0_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void toggle_MTL_RXQ0_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ0_OPERATION_MODE ^= 1u << 6u;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline bool get_MTL_RXQ0_OPERATION_MODE_RSF() volatile
    {
        return MTL_RXQ0_OPERATION_MODE & (1u << 5u);
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ0_OPERATION_MODE |= 1u << 5u;
    }

    /**
     * Clear MTL_RXQ0_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void clear_MTL_RXQ0_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ0_OPERATION_MODE &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_RXQ0_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void toggle_MTL_RXQ0_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ0_OPERATION_MODE ^= 1u << 5u;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline bool get_MTL_RXQ0_OPERATION_MODE_FEP() volatile
    {
        return MTL_RXQ0_OPERATION_MODE & (1u << 4u);
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ0_OPERATION_MODE |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ0_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void clear_MTL_RXQ0_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ0_OPERATION_MODE &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ0_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void toggle_MTL_RXQ0_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ0_OPERATION_MODE ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline bool get_MTL_RXQ0_OPERATION_MODE_FUP() volatile
    {
        return MTL_RXQ0_OPERATION_MODE & (1u << 3u);
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ0_OPERATION_MODE |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ0_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void clear_MTL_RXQ0_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ0_OPERATION_MODE &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ0_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void toggle_MTL_RXQ0_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ0_OPERATION_MODE ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ0_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC
    get_MTL_RXQ0_OPERATION_MODE_RTC() volatile
    {
        return ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC(
            (MTL_RXQ0_OPERATION_MODE >> 0u) & 0b11u);
    }

    /**
     * Set MTL_RXQ0_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline void set_MTL_RXQ0_OPERATION_MODE_RTC(
        ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC value) volatile
    {
        uint32_t curr = MTL_RXQ0_OPERATION_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        MTL_RXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get all of MTL_RXQ0_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 0 Receive Operation Mode
     */
    inline void get_MTL_RXQ0_OPERATION_MODE(
        uint8_t &RQS, uint8_t &RFD, uint8_t &RFA, bool &EHFC, bool &DIS_TCP_EF,
        bool &RSF, bool &FEP, bool &FUP,
        ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC &RTC) volatile
    {
        uint32_t curr = MTL_RXQ0_OPERATION_MODE;

        RQS = (curr >> 20u) & 0b11111u;
        RFD = (curr >> 14u) & 0b1111u;
        RFA = (curr >> 8u) & 0b1111u;
        EHFC = curr & (1u << 7u);
        DIS_TCP_EF = curr & (1u << 6u);
        RSF = curr & (1u << 5u);
        FEP = curr & (1u << 4u);
        FUP = curr & (1u << 3u);
        RTC = ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of MTL_RXQ0_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 0 Receive Operation Mode
     */
    inline void set_MTL_RXQ0_OPERATION_MODE(
        uint8_t RQS, uint8_t RFD, uint8_t RFA, bool EHFC, bool DIS_TCP_EF,
        bool RSF, bool FEP, bool FUP,
        ENET_QOS_MTL_RXQ0_OPERATION_MODE_RTC RTC) volatile
    {
        uint32_t curr = MTL_RXQ0_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (RQS & 0b11111u) << 20u;
        curr &= ~(0b1111u << 14u);
        curr |= (RFD & 0b1111u) << 14u;
        curr &= ~(0b1111u << 8u);
        curr |= (RFA & 0b1111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (EHFC & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DIS_TCP_EF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RSF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (FEP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FUP & 0b1u) << 3u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RTC) & 0b11u) << 0u;

        MTL_RXQ0_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT's MISCNTOVF bit.
     *
     * Missed Packet Counter Overflow Bit When set, this bit indicates that the
     * Rx Queue Missed Packet Counter crossed the maximum limit.
     */
    inline bool get_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT_MISCNTOVF() volatile
    {
        return MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT & (1u << 27u);
    }

    /**
     * Get MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT's MISPKTCNT field.
     *
     * Missed Packet Counter This field indicates the number of packets missed
     * by the DWC_ether_qos because the application asserted ari_pkt_flush_i[]
     * for this queue.
     */
    inline uint16_t
    get_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT_MISPKTCNT() volatile
    {
        return (MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT >> 16u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT's OVFCNTOVF bit.
     *
     * Overflow Counter Overflow Bit When set, this bit indicates that the Rx
     * Queue Overflow Packet Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT_OVFCNTOVF() volatile
    {
        return MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT & (1u << 11u);
    }

    /**
     * Get MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT's OVFPKTCNT field.
     *
     * Overflow Packet Counter This field indicates the number of packets
     * discarded by the DWC_ether_qos because of Receive queue overflow.
     */
    inline uint16_t
    get_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT_OVFPKTCNT() volatile
    {
        return (MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT's bit fields.
     *
     * (read-write) Queue 0 Missed Packet and Overflow Counter
     */
    inline void get_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT(
        bool &MISCNTOVF, uint16_t &MISPKTCNT, bool &OVFCNTOVF,
        uint16_t &OVFPKTCNT) volatile
    {
        uint32_t curr = MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT;

        MISCNTOVF = curr & (1u << 27u);
        MISPKTCNT = (curr >> 16u) & 0b11111111111u;
        OVFCNTOVF = curr & (1u << 11u);
        OVFPKTCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ0_DEBUG's PRXQ field.
     *
     * Number of Packets in Receive Queue This field indicates the current
     * number of packets in the Rx Queue.
     */
    inline uint16_t get_MTL_RXQ0_DEBUG_PRXQ() volatile
    {
        return (MTL_RXQ0_DEBUG >> 16u) & 0b11111111111111u;
    }

    /**
     * Get MTL_RXQ0_DEBUG's RXQSTS field.
     *
     * MTL Rx Queue Fill-Level Status This field gives the status of the
     * fill-level of the Rx Queue:
     */
    inline ENET_QOS_MTL_RXQ0_DEBUG_RXQSTS get_MTL_RXQ0_DEBUG_RXQSTS() volatile
    {
        return ENET_QOS_MTL_RXQ0_DEBUG_RXQSTS((MTL_RXQ0_DEBUG >> 4u) & 0b11u);
    }

    /**
     * Get MTL_RXQ0_DEBUG's RRCSTS field.
     *
     * MTL Rx Queue Read Controller State This field gives the state of the Rx
     * queue Read controller:
     */
    inline ENET_QOS_MTL_RXQ0_DEBUG_RRCSTS get_MTL_RXQ0_DEBUG_RRCSTS() volatile
    {
        return ENET_QOS_MTL_RXQ0_DEBUG_RRCSTS((MTL_RXQ0_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_RXQ0_DEBUG's RWCSTS bit.
     *
     * MTL Rx Queue Write Controller Active Status When high, this bit
     * indicates that the MTL Rx queue Write controller is active, and it is
     * transferring a received packet to the Rx Queue.
     */
    inline bool get_MTL_RXQ0_DEBUG_RWCSTS() volatile
    {
        return MTL_RXQ0_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_RXQ0_DEBUG's bit fields.
     *
     * (read-write) Queue 0 Receive Debug
     */
    inline void get_MTL_RXQ0_DEBUG(uint16_t &PRXQ,
                                   ENET_QOS_MTL_RXQ0_DEBUG_RXQSTS &RXQSTS,
                                   ENET_QOS_MTL_RXQ0_DEBUG_RRCSTS &RRCSTS,
                                   bool &RWCSTS) volatile
    {
        uint32_t curr = MTL_RXQ0_DEBUG;

        PRXQ = (curr >> 16u) & 0b11111111111111u;
        RXQSTS = ENET_QOS_MTL_RXQ0_DEBUG_RXQSTS((curr >> 4u) & 0b11u);
        RRCSTS = ENET_QOS_MTL_RXQ0_DEBUG_RRCSTS((curr >> 1u) & 0b11u);
        RWCSTS = curr & (1u << 0u);
    }

    /**
     * Get MTL_RXQ0_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline bool get_MTL_RXQ0_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        return MTL_RXQ0_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_RXQ0_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void set_MTL_RXQ0_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ0_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ0_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void clear_MTL_RXQ0_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ0_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ0_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void toggle_MTL_RXQ0_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ0_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ0_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline uint8_t get_MTL_RXQ0_CONTROL_RXQ_WEGT() volatile
    {
        return (MTL_RXQ0_CONTROL >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ0_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline void set_MTL_RXQ0_CONTROL_RXQ_WEGT(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ0_CONTROL;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ0_CONTROL = curr;
    }

    /**
     * Get all of MTL_RXQ0_CONTROL's bit fields.
     *
     * (read-write) Queue 0 Receive Control
     */
    inline void get_MTL_RXQ0_CONTROL(bool &RXQ_FRM_ARBIT,
                                     uint8_t &RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ0_CONTROL;

        RXQ_FRM_ARBIT = curr & (1u << 3u);
        RXQ_WEGT = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ0_CONTROL's bit fields.
     *
     * (read-write) Queue 0 Receive Control
     */
    inline void set_MTL_RXQ0_CONTROL(bool RXQ_FRM_ARBIT,
                                     uint8_t RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ0_CONTROL;

        curr &= ~(0b1u << 3u);
        curr |= (RXQ_FRM_ARBIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (RXQ_WEGT & 0b111u) << 0u;

        MTL_RXQ0_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ1_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_TXQ1_OPERATION_MODE_TQS() volatile
    {
        return (MTL_TXQ1_OPERATION_MODE >> 16u) & 0b11111u;
    }

    /**
     * Set MTL_TXQ1_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline void set_MTL_TXQ1_OPERATION_MODE_TQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_TXQ1_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MTL_TXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ1_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC
    get_MTL_TXQ1_OPERATION_MODE_TTC() volatile
    {
        return ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC(
            (MTL_TXQ1_OPERATION_MODE >> 4u) & 0b111u);
    }

    /**
     * Set MTL_TXQ1_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline void set_MTL_TXQ1_OPERATION_MODE_TTC(
        ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC value) volatile
    {
        uint32_t curr = MTL_TXQ1_OPERATION_MODE;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ1_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN
    get_MTL_TXQ1_OPERATION_MODE_TXQEN() volatile
    {
        return ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN(
            (MTL_TXQ1_OPERATION_MODE >> 2u) & 0b11u);
    }

    /**
     * Set MTL_TXQ1_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline void set_MTL_TXQ1_OPERATION_MODE_TXQEN(
        ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN value) volatile
    {
        uint32_t curr = MTL_TXQ1_OPERATION_MODE;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MTL_TXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ1_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline bool get_MTL_TXQ1_OPERATION_MODE_TSF() volatile
    {
        return MTL_TXQ1_OPERATION_MODE & (1u << 1u);
    }

    /**
     * Set MTL_TXQ1_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void set_MTL_TXQ1_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ1_OPERATION_MODE |= 1u << 1u;
    }

    /**
     * Clear MTL_TXQ1_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void clear_MTL_TXQ1_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ1_OPERATION_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_TXQ1_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void toggle_MTL_TXQ1_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ1_OPERATION_MODE ^= 1u << 1u;
    }

    /**
     * Get MTL_TXQ1_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline bool get_MTL_TXQ1_OPERATION_MODE_FTQ() volatile
    {
        return MTL_TXQ1_OPERATION_MODE & (1u << 0u);
    }

    /**
     * Set MTL_TXQ1_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void set_MTL_TXQ1_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ1_OPERATION_MODE |= 1u << 0u;
    }

    /**
     * Clear MTL_TXQ1_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void clear_MTL_TXQ1_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ1_OPERATION_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_TXQ1_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void toggle_MTL_TXQ1_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ1_OPERATION_MODE ^= 1u << 0u;
    }

    /**
     * Get all of MTL_TXQ1_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 1 Transmit Operation Mode
     */
    inline void get_MTL_TXQ1_OPERATION_MODE(
        uint8_t &TQS, ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC &TTC,
        ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN &TXQEN, bool &TSF,
        bool &FTQ) volatile
    {
        uint32_t curr = MTL_TXQ1_OPERATION_MODE;

        TQS = (curr >> 16u) & 0b11111u;
        TTC = ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC((curr >> 4u) & 0b111u);
        TXQEN = ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN((curr >> 2u) & 0b11u);
        TSF = curr & (1u << 1u);
        FTQ = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_TXQ1_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 1 Transmit Operation Mode
     */
    inline void set_MTL_TXQ1_OPERATION_MODE(
        uint8_t TQS, ENET_QOS_MTL_TXQ1_OPERATION_MODE_TTC TTC,
        ENET_QOS_MTL_TXQ1_OPERATION_MODE_TXQEN TXQEN, bool TSF,
        bool FTQ) volatile
    {
        uint32_t curr = MTL_TXQ1_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (TQS & 0b11111u) << 16u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(TTC) & 0b111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(TXQEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FTQ & 0b1u) << 0u;

        MTL_TXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ1_UNDERFLOW's UFCNTOVF bit.
     *
     * Overflow Bit for Underflow Packet Counter This bit is set every time the
     * Tx queue Underflow Packet Counter field overflows, that is, it has
     * crossed the maximum count.
     */
    inline bool get_MTL_TXQ1_UNDERFLOW_UFCNTOVF() volatile
    {
        return MTL_TXQ1_UNDERFLOW & (1u << 11u);
    }

    /**
     * Get MTL_TXQ1_UNDERFLOW's UFFRMCNT field.
     *
     * Underflow Packet Counter This field indicates the number of packets
     * aborted by the controller because of Tx Queue Underflow.
     */
    inline uint16_t get_MTL_TXQ1_UNDERFLOW_UFFRMCNT() volatile
    {
        return (MTL_TXQ1_UNDERFLOW >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_TXQ1_UNDERFLOW's bit fields.
     *
     * (read-write) Queue 1 Underflow Counter
     */
    inline void get_MTL_TXQ1_UNDERFLOW(bool &UFCNTOVF,
                                       uint16_t &UFFRMCNT) volatile
    {
        uint32_t curr = MTL_TXQ1_UNDERFLOW;

        UFCNTOVF = curr & (1u << 11u);
        UFFRMCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_TXQ1_DEBUG's STXSTSF field.
     *
     * Number of Status Words in Tx Status FIFO of Queue This field indicates
     * the current number of status in the Tx Status FIFO of this queue.
     */
    inline uint8_t get_MTL_TXQ1_DEBUG_STXSTSF() volatile
    {
        return (MTL_TXQ1_DEBUG >> 20u) & 0b111u;
    }

    /**
     * Get MTL_TXQ1_DEBUG's PTXQ field.
     *
     * Number of Packets in the Transmit Queue This field indicates the current
     * number of packets in the Tx Queue.
     */
    inline uint8_t get_MTL_TXQ1_DEBUG_PTXQ() volatile
    {
        return (MTL_TXQ1_DEBUG >> 16u) & 0b111u;
    }

    /**
     * Get MTL_TXQ1_DEBUG's TXSTSFSTS bit.
     *
     * MTL Tx Status FIFO Full Status When high, this bit indicates that the
     * MTL Tx Status FIFO is full.
     */
    inline bool get_MTL_TXQ1_DEBUG_TXSTSFSTS() volatile
    {
        return MTL_TXQ1_DEBUG & (1u << 5u);
    }

    /**
     * Get MTL_TXQ1_DEBUG's TXQSTS bit.
     *
     * MTL Tx Queue Not Empty Status When this bit is high, it indicates that
     * the MTL Tx Queue is not empty and some data is left for transmission.
     */
    inline bool get_MTL_TXQ1_DEBUG_TXQSTS() volatile
    {
        return MTL_TXQ1_DEBUG & (1u << 4u);
    }

    /**
     * Get MTL_TXQ1_DEBUG's TWCSTS bit.
     *
     * MTL Tx Queue Write Controller Status When high, this bit indicates that
     * the MTL Tx Queue Write Controller is active, and it is transferring the
     * data to the Tx Queue.
     */
    inline bool get_MTL_TXQ1_DEBUG_TWCSTS() volatile
    {
        return MTL_TXQ1_DEBUG & (1u << 3u);
    }

    /**
     * Get MTL_TXQ1_DEBUG's TRCSTS field.
     *
     * MTL Tx Queue Read Controller Status This field indicates the state of
     * the Tx Queue Read Controller:
     */
    inline ENET_QOS_MTL_TXQ1_DEBUG_TRCSTS get_MTL_TXQ1_DEBUG_TRCSTS() volatile
    {
        return ENET_QOS_MTL_TXQ1_DEBUG_TRCSTS((MTL_TXQ1_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_TXQ1_DEBUG's TXQPAUSED bit.
     *
     * Transmit Queue in Pause When this bit is high and the Rx flow control is
     * enabled, it indicates that the Tx Queue is in the Pause condition (in
     * the full-duplex only mode) because of the following: - Reception of the
     * PFC packet for the priorities assigned to the Tx Queue when PFC is
     * enabled - Reception of 802.
     */
    inline bool get_MTL_TXQ1_DEBUG_TXQPAUSED() volatile
    {
        return MTL_TXQ1_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_TXQ1_DEBUG's bit fields.
     *
     * (read-write) Queue 1 Transmit Debug
     */
    inline void get_MTL_TXQ1_DEBUG(uint8_t &STXSTSF, uint8_t &PTXQ,
                                   bool &TXSTSFSTS, bool &TXQSTS, bool &TWCSTS,
                                   ENET_QOS_MTL_TXQ1_DEBUG_TRCSTS &TRCSTS,
                                   bool &TXQPAUSED) volatile
    {
        uint32_t curr = MTL_TXQ1_DEBUG;

        STXSTSF = (curr >> 20u) & 0b111u;
        PTXQ = (curr >> 16u) & 0b111u;
        TXSTSFSTS = curr & (1u << 5u);
        TXQSTS = curr & (1u << 4u);
        TWCSTS = curr & (1u << 3u);
        TRCSTS = ENET_QOS_MTL_TXQ1_DEBUG_TRCSTS((curr >> 1u) & 0b11u);
        TXQPAUSED = curr & (1u << 0u);
    }

    /**
     * Get MTL_TXQ1_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[n]_Slot_Interval register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC
    get_MTL_TXQ1_ETS_CONTROL_SLC() volatile
    {
        return ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC((MTL_TXQ1_ETS_CONTROL >> 4u) &
                                                 0b111u);
    }

    /**
     * Set MTL_TXQ1_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[n]_Slot_Interval register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline void set_MTL_TXQ1_ETS_CONTROL_SLC(
        ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC value) volatile
    {
        uint32_t curr = MTL_TXQ1_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ1_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ1_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline bool get_MTL_TXQ1_ETS_CONTROL_CC() volatile
    {
        return MTL_TXQ1_ETS_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_TXQ1_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void set_MTL_TXQ1_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ1_ETS_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_TXQ1_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void clear_MTL_TXQ1_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ1_ETS_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_TXQ1_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void toggle_MTL_TXQ1_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ1_ETS_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_TXQ1_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline bool get_MTL_TXQ1_ETS_CONTROL_AVALG() volatile
    {
        return MTL_TXQ1_ETS_CONTROL & (1u << 2u);
    }

    /**
     * Set MTL_TXQ1_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void set_MTL_TXQ1_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ1_ETS_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MTL_TXQ1_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void clear_MTL_TXQ1_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ1_ETS_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_TXQ1_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void toggle_MTL_TXQ1_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ1_ETS_CONTROL ^= 1u << 2u;
    }

    /**
     * Get all of MTL_TXQ1_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 1 ETS Control
     */
    inline void get_MTL_TXQ1_ETS_CONTROL(
        ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC &SLC, bool &CC, bool &AVALG) volatile
    {
        uint32_t curr = MTL_TXQ1_ETS_CONTROL;

        SLC = ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC((curr >> 4u) & 0b111u);
        CC = curr & (1u << 3u);
        AVALG = curr & (1u << 2u);
    }

    /**
     * Set all of MTL_TXQ1_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 1 ETS Control
     */
    inline void set_MTL_TXQ1_ETS_CONTROL(ENET_QOS_MTL_TXQ1_ETS_CONTROL_SLC SLC,
                                         bool CC, bool AVALG) volatile
    {
        uint32_t curr = MTL_TXQ1_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(SLC) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CC & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AVALG & 0b1u) << 2u;

        MTL_TXQ1_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ1_ETS_STATUS's ABS field.
     *
     * Average Bits per Slot This field contains the average transmitted bits
     * per slot.
     */
    inline uint32_t get_MTL_TXQ1_ETS_STATUS_ABS() volatile
    {
        return (MTL_TXQ1_ETS_STATUS >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get MTL_TXQ1_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline uint32_t get_MTL_TXQ1_QUANTUM_WEIGHT_ISCQW() volatile
    {
        return (MTL_TXQ1_QUANTUM_WEIGHT >> 0u) & 0b111111111111111111111u;
    }

    /**
     * Set MTL_TXQ1_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline void set_MTL_TXQ1_QUANTUM_WEIGHT_ISCQW(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ1_QUANTUM_WEIGHT;

        curr &= ~(0b111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111u) << 0u;

        MTL_TXQ1_QUANTUM_WEIGHT = curr;
    }

    /**
     * Get MTL_TXQ1_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline uint16_t get_MTL_TXQ1_SENDSLOPECREDIT_SSC() volatile
    {
        return (MTL_TXQ1_SENDSLOPECREDIT >> 0u) & 0b11111111111111u;
    }

    /**
     * Set MTL_TXQ1_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline void set_MTL_TXQ1_SENDSLOPECREDIT_SSC(uint16_t value) volatile
    {
        uint32_t curr = MTL_TXQ1_SENDSLOPECREDIT;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        MTL_TXQ1_SENDSLOPECREDIT = curr;
    }

    /**
     * Get MTL_TXQ1_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ1_HICREDIT_HC() volatile
    {
        return (MTL_TXQ1_HICREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ1_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ1_HICREDIT_HC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ1_HICREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ1_HICREDIT = curr;
    }

    /**
     * Get MTL_TXQ1_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ1_LOCREDIT_LC() volatile
    {
        return (MTL_TXQ1_LOCREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ1_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ1_LOCREDIT_LC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ1_LOCREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ1_LOCREDIT = curr;
    }

    /**
     * Get MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline bool get_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        return MTL_Q1_INTERRUPT_CONTROL_STATUS & (1u << 24u);
    }

    /**
     * Set MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS |= 1u << 24u;
    }

    /**
     * Clear MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void clear_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void toggle_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS ^= 1u << 24u;
    }

    /**
     * Get MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline bool get_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        return MTL_Q1_INTERRUPT_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void clear_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_Q1_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void toggle_MTL_Q1_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline bool get_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        return MTL_Q1_INTERRUPT_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Set MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS |= 1u << 9u;
    }

    /**
     * Clear MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void clear_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void toggle_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS ^= 1u << 9u;
    }

    /**
     * Get MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline bool get_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        return MTL_Q1_INTERRUPT_CONTROL_STATUS & (1u << 8u);
    }

    /**
     * Set MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS |= 1u << 8u;
    }

    /**
     * Clear MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void clear_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void toggle_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS ^= 1u << 8u;
    }

    /**
     * Get MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline bool get_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        return MTL_Q1_INTERRUPT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void clear_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_Q1_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void toggle_MTL_Q1_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline bool get_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        return MTL_Q1_INTERRUPT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void clear_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_Q1_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void toggle_MTL_Q1_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q1_INTERRUPT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_Q1_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 1 Interrupt Control Status
     */
    inline void get_MTL_Q1_INTERRUPT_CONTROL_STATUS(bool &RXOIE, bool &RXOVFIS,
                                                    bool &ABPSIE, bool &TXUIE,
                                                    bool &ABPSIS,
                                                    bool &TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q1_INTERRUPT_CONTROL_STATUS;

        RXOIE = curr & (1u << 24u);
        RXOVFIS = curr & (1u << 16u);
        ABPSIE = curr & (1u << 9u);
        TXUIE = curr & (1u << 8u);
        ABPSIS = curr & (1u << 1u);
        TXUNFIS = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_Q1_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 1 Interrupt Control Status
     */
    inline void set_MTL_Q1_INTERRUPT_CONTROL_STATUS(bool RXOIE, bool RXOVFIS,
                                                    bool ABPSIE, bool TXUIE,
                                                    bool ABPSIS,
                                                    bool TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q1_INTERRUPT_CONTROL_STATUS;

        curr &= ~(0b1u << 24u);
        curr |= (RXOIE & 0b1u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (RXOVFIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (ABPSIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TXUIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (ABPSIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXUNFIS & 0b1u) << 0u;

        MTL_Q1_INTERRUPT_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_RXQ1_OPERATION_MODE_RQS() volatile
    {
        return (MTL_RXQ1_OPERATION_MODE >> 20u) & 0b11111u;
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_RQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ1_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        MTL_RXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline uint8_t get_MTL_RXQ1_OPERATION_MODE_RFD() volatile
    {
        return (MTL_RXQ1_OPERATION_MODE >> 14u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_RFD(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ1_OPERATION_MODE;

        curr &= ~(0b1111u << 14u);
        curr |= (value & 0b1111u) << 14u;

        MTL_RXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline uint8_t get_MTL_RXQ1_OPERATION_MODE_RFA() volatile
    {
        return (MTL_RXQ1_OPERATION_MODE >> 8u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_RFA(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ1_OPERATION_MODE;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MTL_RXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline bool get_MTL_RXQ1_OPERATION_MODE_EHFC() volatile
    {
        return MTL_RXQ1_OPERATION_MODE & (1u << 7u);
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ1_OPERATION_MODE |= 1u << 7u;
    }

    /**
     * Clear MTL_RXQ1_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void clear_MTL_RXQ1_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ1_OPERATION_MODE &= ~(1u << 7u);
    }

    /**
     * Toggle MTL_RXQ1_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void toggle_MTL_RXQ1_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ1_OPERATION_MODE ^= 1u << 7u;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline bool get_MTL_RXQ1_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        return MTL_RXQ1_OPERATION_MODE & (1u << 6u);
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ1_OPERATION_MODE |= 1u << 6u;
    }

    /**
     * Clear MTL_RXQ1_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void clear_MTL_RXQ1_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ1_OPERATION_MODE &= ~(1u << 6u);
    }

    /**
     * Toggle MTL_RXQ1_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void toggle_MTL_RXQ1_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ1_OPERATION_MODE ^= 1u << 6u;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline bool get_MTL_RXQ1_OPERATION_MODE_RSF() volatile
    {
        return MTL_RXQ1_OPERATION_MODE & (1u << 5u);
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ1_OPERATION_MODE |= 1u << 5u;
    }

    /**
     * Clear MTL_RXQ1_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void clear_MTL_RXQ1_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ1_OPERATION_MODE &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_RXQ1_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void toggle_MTL_RXQ1_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ1_OPERATION_MODE ^= 1u << 5u;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline bool get_MTL_RXQ1_OPERATION_MODE_FEP() volatile
    {
        return MTL_RXQ1_OPERATION_MODE & (1u << 4u);
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ1_OPERATION_MODE |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ1_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void clear_MTL_RXQ1_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ1_OPERATION_MODE &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ1_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void toggle_MTL_RXQ1_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ1_OPERATION_MODE ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline bool get_MTL_RXQ1_OPERATION_MODE_FUP() volatile
    {
        return MTL_RXQ1_OPERATION_MODE & (1u << 3u);
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ1_OPERATION_MODE |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ1_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void clear_MTL_RXQ1_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ1_OPERATION_MODE &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ1_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void toggle_MTL_RXQ1_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ1_OPERATION_MODE ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ1_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC
    get_MTL_RXQ1_OPERATION_MODE_RTC() volatile
    {
        return ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC(
            (MTL_RXQ1_OPERATION_MODE >> 0u) & 0b11u);
    }

    /**
     * Set MTL_RXQ1_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline void set_MTL_RXQ1_OPERATION_MODE_RTC(
        ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC value) volatile
    {
        uint32_t curr = MTL_RXQ1_OPERATION_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        MTL_RXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get all of MTL_RXQ1_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 1 Receive Operation Mode
     */
    inline void get_MTL_RXQ1_OPERATION_MODE(
        uint8_t &RQS, uint8_t &RFD, uint8_t &RFA, bool &EHFC, bool &DIS_TCP_EF,
        bool &RSF, bool &FEP, bool &FUP,
        ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC &RTC) volatile
    {
        uint32_t curr = MTL_RXQ1_OPERATION_MODE;

        RQS = (curr >> 20u) & 0b11111u;
        RFD = (curr >> 14u) & 0b1111u;
        RFA = (curr >> 8u) & 0b1111u;
        EHFC = curr & (1u << 7u);
        DIS_TCP_EF = curr & (1u << 6u);
        RSF = curr & (1u << 5u);
        FEP = curr & (1u << 4u);
        FUP = curr & (1u << 3u);
        RTC = ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of MTL_RXQ1_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 1 Receive Operation Mode
     */
    inline void set_MTL_RXQ1_OPERATION_MODE(
        uint8_t RQS, uint8_t RFD, uint8_t RFA, bool EHFC, bool DIS_TCP_EF,
        bool RSF, bool FEP, bool FUP,
        ENET_QOS_MTL_RXQ1_OPERATION_MODE_RTC RTC) volatile
    {
        uint32_t curr = MTL_RXQ1_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (RQS & 0b11111u) << 20u;
        curr &= ~(0b1111u << 14u);
        curr |= (RFD & 0b1111u) << 14u;
        curr &= ~(0b1111u << 8u);
        curr |= (RFA & 0b1111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (EHFC & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DIS_TCP_EF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RSF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (FEP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FUP & 0b1u) << 3u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RTC) & 0b11u) << 0u;

        MTL_RXQ1_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT's MISCNTOVF bit.
     *
     * Missed Packet Counter Overflow Bit When set, this bit indicates that the
     * Rx Queue Missed Packet Counter crossed the maximum limit.
     */
    inline bool get_MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT_MISCNTOVF() volatile
    {
        return MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT & (1u << 27u);
    }

    /**
     * Get MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT's MISPKTCNT field.
     *
     * Missed Packet Counter This field indicates the number of packets missed
     * by the DWC_ether_qos because the application asserted ari_pkt_flush_i[]
     * for this queue.
     */
    inline uint16_t
    get_MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT_MISPKTCNT() volatile
    {
        return (MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT >> 16u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT's OVFCNTOVF bit.
     *
     * Overflow Counter Overflow Bit When set, this bit indicates that the Rx
     * Queue Overflow Packet Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT_OVFCNTOVF() volatile
    {
        return MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT & (1u << 11u);
    }

    /**
     * Get MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT's OVFPKTCNT field.
     *
     * Overflow Packet Counter This field indicates the number of packets
     * discarded by the DWC_ether_qos because of Receive queue overflow.
     */
    inline uint16_t
    get_MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT_OVFPKTCNT() volatile
    {
        return (MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT's bit fields.
     *
     * (read-write) Queue 1 Missed Packet and Overflow Counter
     */
    inline void get_MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT(
        bool &MISCNTOVF, uint16_t &MISPKTCNT, bool &OVFCNTOVF,
        uint16_t &OVFPKTCNT) volatile
    {
        uint32_t curr = MTL_RXQ1_MISSED_PACKET_OVERFLOW_CNT;

        MISCNTOVF = curr & (1u << 27u);
        MISPKTCNT = (curr >> 16u) & 0b11111111111u;
        OVFCNTOVF = curr & (1u << 11u);
        OVFPKTCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ1_DEBUG's PRXQ field.
     *
     * Number of Packets in Receive Queue This field indicates the current
     * number of packets in the Rx Queue.
     */
    inline uint16_t get_MTL_RXQ1_DEBUG_PRXQ() volatile
    {
        return (MTL_RXQ1_DEBUG >> 16u) & 0b11111111111111u;
    }

    /**
     * Get MTL_RXQ1_DEBUG's RXQSTS field.
     *
     * MTL Rx Queue Fill-Level Status This field gives the status of the
     * fill-level of the Rx Queue:
     */
    inline ENET_QOS_MTL_RXQ1_DEBUG_RXQSTS get_MTL_RXQ1_DEBUG_RXQSTS() volatile
    {
        return ENET_QOS_MTL_RXQ1_DEBUG_RXQSTS((MTL_RXQ1_DEBUG >> 4u) & 0b11u);
    }

    /**
     * Get MTL_RXQ1_DEBUG's RRCSTS field.
     *
     * MTL Rx Queue Read Controller State This field gives the state of the Rx
     * queue Read controller:
     */
    inline ENET_QOS_MTL_RXQ1_DEBUG_RRCSTS get_MTL_RXQ1_DEBUG_RRCSTS() volatile
    {
        return ENET_QOS_MTL_RXQ1_DEBUG_RRCSTS((MTL_RXQ1_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_RXQ1_DEBUG's RWCSTS bit.
     *
     * MTL Rx Queue Write Controller Active Status When high, this bit
     * indicates that the MTL Rx queue Write controller is active, and it is
     * transferring a received packet to the Rx Queue.
     */
    inline bool get_MTL_RXQ1_DEBUG_RWCSTS() volatile
    {
        return MTL_RXQ1_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_RXQ1_DEBUG's bit fields.
     *
     * (read-write) Queue 1 Receive Debug
     */
    inline void get_MTL_RXQ1_DEBUG(uint16_t &PRXQ,
                                   ENET_QOS_MTL_RXQ1_DEBUG_RXQSTS &RXQSTS,
                                   ENET_QOS_MTL_RXQ1_DEBUG_RRCSTS &RRCSTS,
                                   bool &RWCSTS) volatile
    {
        uint32_t curr = MTL_RXQ1_DEBUG;

        PRXQ = (curr >> 16u) & 0b11111111111111u;
        RXQSTS = ENET_QOS_MTL_RXQ1_DEBUG_RXQSTS((curr >> 4u) & 0b11u);
        RRCSTS = ENET_QOS_MTL_RXQ1_DEBUG_RRCSTS((curr >> 1u) & 0b11u);
        RWCSTS = curr & (1u << 0u);
    }

    /**
     * Get MTL_RXQ1_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline bool get_MTL_RXQ1_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        return MTL_RXQ1_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_RXQ1_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void set_MTL_RXQ1_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ1_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ1_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void clear_MTL_RXQ1_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ1_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ1_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void toggle_MTL_RXQ1_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ1_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ1_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline uint8_t get_MTL_RXQ1_CONTROL_RXQ_WEGT() volatile
    {
        return (MTL_RXQ1_CONTROL >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ1_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline void set_MTL_RXQ1_CONTROL_RXQ_WEGT(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ1_CONTROL;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ1_CONTROL = curr;
    }

    /**
     * Get all of MTL_RXQ1_CONTROL's bit fields.
     *
     * (read-write) Queue 1 Receive Control
     */
    inline void get_MTL_RXQ1_CONTROL(bool &RXQ_FRM_ARBIT,
                                     uint8_t &RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ1_CONTROL;

        RXQ_FRM_ARBIT = curr & (1u << 3u);
        RXQ_WEGT = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ1_CONTROL's bit fields.
     *
     * (read-write) Queue 1 Receive Control
     */
    inline void set_MTL_RXQ1_CONTROL(bool RXQ_FRM_ARBIT,
                                     uint8_t RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ1_CONTROL;

        curr &= ~(0b1u << 3u);
        curr |= (RXQ_FRM_ARBIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (RXQ_WEGT & 0b111u) << 0u;

        MTL_RXQ1_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ2_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_TXQ2_OPERATION_MODE_TQS() volatile
    {
        return (MTL_TXQ2_OPERATION_MODE >> 16u) & 0b11111u;
    }

    /**
     * Set MTL_TXQ2_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline void set_MTL_TXQ2_OPERATION_MODE_TQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_TXQ2_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MTL_TXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ2_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC
    get_MTL_TXQ2_OPERATION_MODE_TTC() volatile
    {
        return ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC(
            (MTL_TXQ2_OPERATION_MODE >> 4u) & 0b111u);
    }

    /**
     * Set MTL_TXQ2_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline void set_MTL_TXQ2_OPERATION_MODE_TTC(
        ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC value) volatile
    {
        uint32_t curr = MTL_TXQ2_OPERATION_MODE;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ2_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN
    get_MTL_TXQ2_OPERATION_MODE_TXQEN() volatile
    {
        return ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN(
            (MTL_TXQ2_OPERATION_MODE >> 2u) & 0b11u);
    }

    /**
     * Set MTL_TXQ2_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline void set_MTL_TXQ2_OPERATION_MODE_TXQEN(
        ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN value) volatile
    {
        uint32_t curr = MTL_TXQ2_OPERATION_MODE;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MTL_TXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ2_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline bool get_MTL_TXQ2_OPERATION_MODE_TSF() volatile
    {
        return MTL_TXQ2_OPERATION_MODE & (1u << 1u);
    }

    /**
     * Set MTL_TXQ2_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void set_MTL_TXQ2_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ2_OPERATION_MODE |= 1u << 1u;
    }

    /**
     * Clear MTL_TXQ2_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void clear_MTL_TXQ2_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ2_OPERATION_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_TXQ2_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void toggle_MTL_TXQ2_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ2_OPERATION_MODE ^= 1u << 1u;
    }

    /**
     * Get MTL_TXQ2_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline bool get_MTL_TXQ2_OPERATION_MODE_FTQ() volatile
    {
        return MTL_TXQ2_OPERATION_MODE & (1u << 0u);
    }

    /**
     * Set MTL_TXQ2_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void set_MTL_TXQ2_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ2_OPERATION_MODE |= 1u << 0u;
    }

    /**
     * Clear MTL_TXQ2_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void clear_MTL_TXQ2_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ2_OPERATION_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_TXQ2_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void toggle_MTL_TXQ2_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ2_OPERATION_MODE ^= 1u << 0u;
    }

    /**
     * Get all of MTL_TXQ2_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 2 Transmit Operation Mode
     */
    inline void get_MTL_TXQ2_OPERATION_MODE(
        uint8_t &TQS, ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC &TTC,
        ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN &TXQEN, bool &TSF,
        bool &FTQ) volatile
    {
        uint32_t curr = MTL_TXQ2_OPERATION_MODE;

        TQS = (curr >> 16u) & 0b11111u;
        TTC = ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC((curr >> 4u) & 0b111u);
        TXQEN = ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN((curr >> 2u) & 0b11u);
        TSF = curr & (1u << 1u);
        FTQ = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_TXQ2_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 2 Transmit Operation Mode
     */
    inline void set_MTL_TXQ2_OPERATION_MODE(
        uint8_t TQS, ENET_QOS_MTL_TXQ2_OPERATION_MODE_TTC TTC,
        ENET_QOS_MTL_TXQ2_OPERATION_MODE_TXQEN TXQEN, bool TSF,
        bool FTQ) volatile
    {
        uint32_t curr = MTL_TXQ2_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (TQS & 0b11111u) << 16u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(TTC) & 0b111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(TXQEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FTQ & 0b1u) << 0u;

        MTL_TXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ2_UNDERFLOW's UFCNTOVF bit.
     *
     * Overflow Bit for Underflow Packet Counter This bit is set every time the
     * Tx queue Underflow Packet Counter field overflows, that is, it has
     * crossed the maximum count.
     */
    inline bool get_MTL_TXQ2_UNDERFLOW_UFCNTOVF() volatile
    {
        return MTL_TXQ2_UNDERFLOW & (1u << 11u);
    }

    /**
     * Get MTL_TXQ2_UNDERFLOW's UFFRMCNT field.
     *
     * Underflow Packet Counter This field indicates the number of packets
     * aborted by the controller because of Tx Queue Underflow.
     */
    inline uint16_t get_MTL_TXQ2_UNDERFLOW_UFFRMCNT() volatile
    {
        return (MTL_TXQ2_UNDERFLOW >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_TXQ2_UNDERFLOW's bit fields.
     *
     * (read-write) Queue 2 Underflow Counter
     */
    inline void get_MTL_TXQ2_UNDERFLOW(bool &UFCNTOVF,
                                       uint16_t &UFFRMCNT) volatile
    {
        uint32_t curr = MTL_TXQ2_UNDERFLOW;

        UFCNTOVF = curr & (1u << 11u);
        UFFRMCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_TXQ2_DEBUG's STXSTSF field.
     *
     * Number of Status Words in Tx Status FIFO of Queue This field indicates
     * the current number of status in the Tx Status FIFO of this queue.
     */
    inline uint8_t get_MTL_TXQ2_DEBUG_STXSTSF() volatile
    {
        return (MTL_TXQ2_DEBUG >> 20u) & 0b111u;
    }

    /**
     * Get MTL_TXQ2_DEBUG's PTXQ field.
     *
     * Number of Packets in the Transmit Queue This field indicates the current
     * number of packets in the Tx Queue.
     */
    inline uint8_t get_MTL_TXQ2_DEBUG_PTXQ() volatile
    {
        return (MTL_TXQ2_DEBUG >> 16u) & 0b111u;
    }

    /**
     * Get MTL_TXQ2_DEBUG's TXSTSFSTS bit.
     *
     * MTL Tx Status FIFO Full Status When high, this bit indicates that the
     * MTL Tx Status FIFO is full.
     */
    inline bool get_MTL_TXQ2_DEBUG_TXSTSFSTS() volatile
    {
        return MTL_TXQ2_DEBUG & (1u << 5u);
    }

    /**
     * Get MTL_TXQ2_DEBUG's TXQSTS bit.
     *
     * MTL Tx Queue Not Empty Status When this bit is high, it indicates that
     * the MTL Tx Queue is not empty and some data is left for transmission.
     */
    inline bool get_MTL_TXQ2_DEBUG_TXQSTS() volatile
    {
        return MTL_TXQ2_DEBUG & (1u << 4u);
    }

    /**
     * Get MTL_TXQ2_DEBUG's TWCSTS bit.
     *
     * MTL Tx Queue Write Controller Status When high, this bit indicates that
     * the MTL Tx Queue Write Controller is active, and it is transferring the
     * data to the Tx Queue.
     */
    inline bool get_MTL_TXQ2_DEBUG_TWCSTS() volatile
    {
        return MTL_TXQ2_DEBUG & (1u << 3u);
    }

    /**
     * Get MTL_TXQ2_DEBUG's TRCSTS field.
     *
     * MTL Tx Queue Read Controller Status This field indicates the state of
     * the Tx Queue Read Controller:
     */
    inline ENET_QOS_MTL_TXQ2_DEBUG_TRCSTS get_MTL_TXQ2_DEBUG_TRCSTS() volatile
    {
        return ENET_QOS_MTL_TXQ2_DEBUG_TRCSTS((MTL_TXQ2_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_TXQ2_DEBUG's TXQPAUSED bit.
     *
     * Transmit Queue in Pause When this bit is high and the Rx flow control is
     * enabled, it indicates that the Tx Queue is in the Pause condition (in
     * the full-duplex only mode) because of the following: - Reception of the
     * PFC packet for the priorities assigned to the Tx Queue when PFC is
     * enabled - Reception of 802.
     */
    inline bool get_MTL_TXQ2_DEBUG_TXQPAUSED() volatile
    {
        return MTL_TXQ2_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_TXQ2_DEBUG's bit fields.
     *
     * (read-write) Queue 2 Transmit Debug
     */
    inline void get_MTL_TXQ2_DEBUG(uint8_t &STXSTSF, uint8_t &PTXQ,
                                   bool &TXSTSFSTS, bool &TXQSTS, bool &TWCSTS,
                                   ENET_QOS_MTL_TXQ2_DEBUG_TRCSTS &TRCSTS,
                                   bool &TXQPAUSED) volatile
    {
        uint32_t curr = MTL_TXQ2_DEBUG;

        STXSTSF = (curr >> 20u) & 0b111u;
        PTXQ = (curr >> 16u) & 0b111u;
        TXSTSFSTS = curr & (1u << 5u);
        TXQSTS = curr & (1u << 4u);
        TWCSTS = curr & (1u << 3u);
        TRCSTS = ENET_QOS_MTL_TXQ2_DEBUG_TRCSTS((curr >> 1u) & 0b11u);
        TXQPAUSED = curr & (1u << 0u);
    }

    /**
     * Get MTL_TXQ2_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[N]_SLOT_INTERVAL register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC
    get_MTL_TXQ2_ETS_CONTROL_SLC() volatile
    {
        return ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC((MTL_TXQ2_ETS_CONTROL >> 4u) &
                                                 0b111u);
    }

    /**
     * Set MTL_TXQ2_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[N]_SLOT_INTERVAL register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline void set_MTL_TXQ2_ETS_CONTROL_SLC(
        ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC value) volatile
    {
        uint32_t curr = MTL_TXQ2_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ2_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ2_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline bool get_MTL_TXQ2_ETS_CONTROL_CC() volatile
    {
        return MTL_TXQ2_ETS_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_TXQ2_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void set_MTL_TXQ2_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ2_ETS_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_TXQ2_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void clear_MTL_TXQ2_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ2_ETS_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_TXQ2_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void toggle_MTL_TXQ2_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ2_ETS_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_TXQ2_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline bool get_MTL_TXQ2_ETS_CONTROL_AVALG() volatile
    {
        return MTL_TXQ2_ETS_CONTROL & (1u << 2u);
    }

    /**
     * Set MTL_TXQ2_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void set_MTL_TXQ2_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ2_ETS_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MTL_TXQ2_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void clear_MTL_TXQ2_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ2_ETS_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_TXQ2_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void toggle_MTL_TXQ2_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ2_ETS_CONTROL ^= 1u << 2u;
    }

    /**
     * Get all of MTL_TXQ2_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 2 ETS Control
     */
    inline void get_MTL_TXQ2_ETS_CONTROL(
        ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC &SLC, bool &CC, bool &AVALG) volatile
    {
        uint32_t curr = MTL_TXQ2_ETS_CONTROL;

        SLC = ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC((curr >> 4u) & 0b111u);
        CC = curr & (1u << 3u);
        AVALG = curr & (1u << 2u);
    }

    /**
     * Set all of MTL_TXQ2_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 2 ETS Control
     */
    inline void set_MTL_TXQ2_ETS_CONTROL(ENET_QOS_MTL_TXQ2_ETS_CONTROL_SLC SLC,
                                         bool CC, bool AVALG) volatile
    {
        uint32_t curr = MTL_TXQ2_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(SLC) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CC & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AVALG & 0b1u) << 2u;

        MTL_TXQ2_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ2_ETS_STATUS's ABS field.
     *
     * Average Bits per Slot This field contains the average transmitted bits
     * per slot.
     */
    inline uint32_t get_MTL_TXQ2_ETS_STATUS_ABS() volatile
    {
        return (MTL_TXQ2_ETS_STATUS >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get MTL_TXQ2_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline uint32_t get_MTL_TXQ2_QUANTUM_WEIGHT_ISCQW() volatile
    {
        return (MTL_TXQ2_QUANTUM_WEIGHT >> 0u) & 0b111111111111111111111u;
    }

    /**
     * Set MTL_TXQ2_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline void set_MTL_TXQ2_QUANTUM_WEIGHT_ISCQW(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ2_QUANTUM_WEIGHT;

        curr &= ~(0b111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111u) << 0u;

        MTL_TXQ2_QUANTUM_WEIGHT = curr;
    }

    /**
     * Get MTL_TXQ2_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline uint16_t get_MTL_TXQ2_SENDSLOPECREDIT_SSC() volatile
    {
        return (MTL_TXQ2_SENDSLOPECREDIT >> 0u) & 0b11111111111111u;
    }

    /**
     * Set MTL_TXQ2_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline void set_MTL_TXQ2_SENDSLOPECREDIT_SSC(uint16_t value) volatile
    {
        uint32_t curr = MTL_TXQ2_SENDSLOPECREDIT;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        MTL_TXQ2_SENDSLOPECREDIT = curr;
    }

    /**
     * Get MTL_TXQ2_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ2_HICREDIT_HC() volatile
    {
        return (MTL_TXQ2_HICREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ2_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ2_HICREDIT_HC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ2_HICREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ2_HICREDIT = curr;
    }

    /**
     * Get MTL_TXQ2_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ2_LOCREDIT_LC() volatile
    {
        return (MTL_TXQ2_LOCREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ2_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ2_LOCREDIT_LC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ2_LOCREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ2_LOCREDIT = curr;
    }

    /**
     * Get MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline bool get_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        return MTL_Q2_INTERRUPT_CONTROL_STATUS & (1u << 24u);
    }

    /**
     * Set MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS |= 1u << 24u;
    }

    /**
     * Clear MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void clear_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void toggle_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS ^= 1u << 24u;
    }

    /**
     * Get MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline bool get_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        return MTL_Q2_INTERRUPT_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void clear_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_Q2_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void toggle_MTL_Q2_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline bool get_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        return MTL_Q2_INTERRUPT_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Set MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS |= 1u << 9u;
    }

    /**
     * Clear MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void clear_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void toggle_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS ^= 1u << 9u;
    }

    /**
     * Get MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline bool get_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        return MTL_Q2_INTERRUPT_CONTROL_STATUS & (1u << 8u);
    }

    /**
     * Set MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS |= 1u << 8u;
    }

    /**
     * Clear MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void clear_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void toggle_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS ^= 1u << 8u;
    }

    /**
     * Get MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline bool get_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        return MTL_Q2_INTERRUPT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void clear_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_Q2_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void toggle_MTL_Q2_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline bool get_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        return MTL_Q2_INTERRUPT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void clear_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_Q2_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void toggle_MTL_Q2_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q2_INTERRUPT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_Q2_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 2 Interrupt Control Status
     */
    inline void get_MTL_Q2_INTERRUPT_CONTROL_STATUS(bool &RXOIE, bool &RXOVFIS,
                                                    bool &ABPSIE, bool &TXUIE,
                                                    bool &ABPSIS,
                                                    bool &TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q2_INTERRUPT_CONTROL_STATUS;

        RXOIE = curr & (1u << 24u);
        RXOVFIS = curr & (1u << 16u);
        ABPSIE = curr & (1u << 9u);
        TXUIE = curr & (1u << 8u);
        ABPSIS = curr & (1u << 1u);
        TXUNFIS = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_Q2_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 2 Interrupt Control Status
     */
    inline void set_MTL_Q2_INTERRUPT_CONTROL_STATUS(bool RXOIE, bool RXOVFIS,
                                                    bool ABPSIE, bool TXUIE,
                                                    bool ABPSIS,
                                                    bool TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q2_INTERRUPT_CONTROL_STATUS;

        curr &= ~(0b1u << 24u);
        curr |= (RXOIE & 0b1u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (RXOVFIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (ABPSIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TXUIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (ABPSIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXUNFIS & 0b1u) << 0u;

        MTL_Q2_INTERRUPT_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_RXQ2_OPERATION_MODE_RQS() volatile
    {
        return (MTL_RXQ2_OPERATION_MODE >> 20u) & 0b11111u;
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_RQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ2_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        MTL_RXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline uint8_t get_MTL_RXQ2_OPERATION_MODE_RFD() volatile
    {
        return (MTL_RXQ2_OPERATION_MODE >> 14u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_RFD(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ2_OPERATION_MODE;

        curr &= ~(0b1111u << 14u);
        curr |= (value & 0b1111u) << 14u;

        MTL_RXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline uint8_t get_MTL_RXQ2_OPERATION_MODE_RFA() volatile
    {
        return (MTL_RXQ2_OPERATION_MODE >> 8u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_RFA(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ2_OPERATION_MODE;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MTL_RXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline bool get_MTL_RXQ2_OPERATION_MODE_EHFC() volatile
    {
        return MTL_RXQ2_OPERATION_MODE & (1u << 7u);
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ2_OPERATION_MODE |= 1u << 7u;
    }

    /**
     * Clear MTL_RXQ2_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void clear_MTL_RXQ2_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ2_OPERATION_MODE &= ~(1u << 7u);
    }

    /**
     * Toggle MTL_RXQ2_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void toggle_MTL_RXQ2_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ2_OPERATION_MODE ^= 1u << 7u;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline bool get_MTL_RXQ2_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        return MTL_RXQ2_OPERATION_MODE & (1u << 6u);
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ2_OPERATION_MODE |= 1u << 6u;
    }

    /**
     * Clear MTL_RXQ2_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void clear_MTL_RXQ2_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ2_OPERATION_MODE &= ~(1u << 6u);
    }

    /**
     * Toggle MTL_RXQ2_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void toggle_MTL_RXQ2_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ2_OPERATION_MODE ^= 1u << 6u;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline bool get_MTL_RXQ2_OPERATION_MODE_RSF() volatile
    {
        return MTL_RXQ2_OPERATION_MODE & (1u << 5u);
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ2_OPERATION_MODE |= 1u << 5u;
    }

    /**
     * Clear MTL_RXQ2_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void clear_MTL_RXQ2_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ2_OPERATION_MODE &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_RXQ2_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void toggle_MTL_RXQ2_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ2_OPERATION_MODE ^= 1u << 5u;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline bool get_MTL_RXQ2_OPERATION_MODE_FEP() volatile
    {
        return MTL_RXQ2_OPERATION_MODE & (1u << 4u);
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ2_OPERATION_MODE |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ2_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void clear_MTL_RXQ2_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ2_OPERATION_MODE &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ2_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void toggle_MTL_RXQ2_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ2_OPERATION_MODE ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline bool get_MTL_RXQ2_OPERATION_MODE_FUP() volatile
    {
        return MTL_RXQ2_OPERATION_MODE & (1u << 3u);
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ2_OPERATION_MODE |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ2_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void clear_MTL_RXQ2_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ2_OPERATION_MODE &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ2_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void toggle_MTL_RXQ2_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ2_OPERATION_MODE ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ2_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC
    get_MTL_RXQ2_OPERATION_MODE_RTC() volatile
    {
        return ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC(
            (MTL_RXQ2_OPERATION_MODE >> 0u) & 0b11u);
    }

    /**
     * Set MTL_RXQ2_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline void set_MTL_RXQ2_OPERATION_MODE_RTC(
        ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC value) volatile
    {
        uint32_t curr = MTL_RXQ2_OPERATION_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        MTL_RXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get all of MTL_RXQ2_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 2 Receive Operation Mode
     */
    inline void get_MTL_RXQ2_OPERATION_MODE(
        uint8_t &RQS, uint8_t &RFD, uint8_t &RFA, bool &EHFC, bool &DIS_TCP_EF,
        bool &RSF, bool &FEP, bool &FUP,
        ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC &RTC) volatile
    {
        uint32_t curr = MTL_RXQ2_OPERATION_MODE;

        RQS = (curr >> 20u) & 0b11111u;
        RFD = (curr >> 14u) & 0b1111u;
        RFA = (curr >> 8u) & 0b1111u;
        EHFC = curr & (1u << 7u);
        DIS_TCP_EF = curr & (1u << 6u);
        RSF = curr & (1u << 5u);
        FEP = curr & (1u << 4u);
        FUP = curr & (1u << 3u);
        RTC = ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of MTL_RXQ2_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 2 Receive Operation Mode
     */
    inline void set_MTL_RXQ2_OPERATION_MODE(
        uint8_t RQS, uint8_t RFD, uint8_t RFA, bool EHFC, bool DIS_TCP_EF,
        bool RSF, bool FEP, bool FUP,
        ENET_QOS_MTL_RXQ2_OPERATION_MODE_RTC RTC) volatile
    {
        uint32_t curr = MTL_RXQ2_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (RQS & 0b11111u) << 20u;
        curr &= ~(0b1111u << 14u);
        curr |= (RFD & 0b1111u) << 14u;
        curr &= ~(0b1111u << 8u);
        curr |= (RFA & 0b1111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (EHFC & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DIS_TCP_EF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RSF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (FEP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FUP & 0b1u) << 3u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RTC) & 0b11u) << 0u;

        MTL_RXQ2_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT's MISCNTOVF bit.
     *
     * Missed Packet Counter Overflow Bit When set, this bit indicates that the
     * Rx Queue Missed Packet Counter crossed the maximum limit.
     */
    inline bool get_MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT_MISCNTOVF() volatile
    {
        return MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT & (1u << 27u);
    }

    /**
     * Get MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT's MISPKTCNT field.
     *
     * Missed Packet Counter This field indicates the number of packets missed
     * by the DWC_ether_qos because the application asserted ari_pkt_flush_i[]
     * for this queue.
     */
    inline uint16_t
    get_MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT_MISPKTCNT() volatile
    {
        return (MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT >> 16u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT's OVFCNTOVF bit.
     *
     * Overflow Counter Overflow Bit When set, this bit indicates that the Rx
     * Queue Overflow Packet Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT_OVFCNTOVF() volatile
    {
        return MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT & (1u << 11u);
    }

    /**
     * Get MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT's OVFPKTCNT field.
     *
     * Overflow Packet Counter This field indicates the number of packets
     * discarded by the DWC_ether_qos because of Receive queue overflow.
     */
    inline uint16_t
    get_MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT_OVFPKTCNT() volatile
    {
        return (MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT's bit fields.
     *
     * (read-write) Queue 2 Missed Packet and Overflow Counter
     */
    inline void get_MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT(
        bool &MISCNTOVF, uint16_t &MISPKTCNT, bool &OVFCNTOVF,
        uint16_t &OVFPKTCNT) volatile
    {
        uint32_t curr = MTL_RXQ2_MISSED_PACKET_OVERFLOW_CNT;

        MISCNTOVF = curr & (1u << 27u);
        MISPKTCNT = (curr >> 16u) & 0b11111111111u;
        OVFCNTOVF = curr & (1u << 11u);
        OVFPKTCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ2_DEBUG's PRXQ field.
     *
     * Number of Packets in Receive Queue This field indicates the current
     * number of packets in the Rx Queue.
     */
    inline uint16_t get_MTL_RXQ2_DEBUG_PRXQ() volatile
    {
        return (MTL_RXQ2_DEBUG >> 16u) & 0b11111111111111u;
    }

    /**
     * Get MTL_RXQ2_DEBUG's RXQSTS field.
     *
     * MTL Rx Queue Fill-Level Status This field gives the status of the
     * fill-level of the Rx Queue:
     */
    inline ENET_QOS_MTL_RXQ2_DEBUG_RXQSTS get_MTL_RXQ2_DEBUG_RXQSTS() volatile
    {
        return ENET_QOS_MTL_RXQ2_DEBUG_RXQSTS((MTL_RXQ2_DEBUG >> 4u) & 0b11u);
    }

    /**
     * Get MTL_RXQ2_DEBUG's RRCSTS field.
     *
     * MTL Rx Queue Read Controller State This field gives the state of the Rx
     * queue Read controller:
     */
    inline ENET_QOS_MTL_RXQ2_DEBUG_RRCSTS get_MTL_RXQ2_DEBUG_RRCSTS() volatile
    {
        return ENET_QOS_MTL_RXQ2_DEBUG_RRCSTS((MTL_RXQ2_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_RXQ2_DEBUG's RWCSTS bit.
     *
     * MTL Rx Queue Write Controller Active Status When high, this bit
     * indicates that the MTL Rx queue Write controller is active, and it is
     * transferring a received packet to the Rx Queue.
     */
    inline bool get_MTL_RXQ2_DEBUG_RWCSTS() volatile
    {
        return MTL_RXQ2_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_RXQ2_DEBUG's bit fields.
     *
     * (read-write) Queue 2 Receive Debug
     */
    inline void get_MTL_RXQ2_DEBUG(uint16_t &PRXQ,
                                   ENET_QOS_MTL_RXQ2_DEBUG_RXQSTS &RXQSTS,
                                   ENET_QOS_MTL_RXQ2_DEBUG_RRCSTS &RRCSTS,
                                   bool &RWCSTS) volatile
    {
        uint32_t curr = MTL_RXQ2_DEBUG;

        PRXQ = (curr >> 16u) & 0b11111111111111u;
        RXQSTS = ENET_QOS_MTL_RXQ2_DEBUG_RXQSTS((curr >> 4u) & 0b11u);
        RRCSTS = ENET_QOS_MTL_RXQ2_DEBUG_RRCSTS((curr >> 1u) & 0b11u);
        RWCSTS = curr & (1u << 0u);
    }

    /**
     * Get MTL_RXQ2_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline bool get_MTL_RXQ2_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        return MTL_RXQ2_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_RXQ2_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void set_MTL_RXQ2_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ2_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ2_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void clear_MTL_RXQ2_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ2_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ2_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void toggle_MTL_RXQ2_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ2_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ2_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline uint8_t get_MTL_RXQ2_CONTROL_RXQ_WEGT() volatile
    {
        return (MTL_RXQ2_CONTROL >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ2_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline void set_MTL_RXQ2_CONTROL_RXQ_WEGT(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ2_CONTROL;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ2_CONTROL = curr;
    }

    /**
     * Get all of MTL_RXQ2_CONTROL's bit fields.
     *
     * (read-write) Queue 2 Receive Control
     */
    inline void get_MTL_RXQ2_CONTROL(bool &RXQ_FRM_ARBIT,
                                     uint8_t &RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ2_CONTROL;

        RXQ_FRM_ARBIT = curr & (1u << 3u);
        RXQ_WEGT = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ2_CONTROL's bit fields.
     *
     * (read-write) Queue 2 Receive Control
     */
    inline void set_MTL_RXQ2_CONTROL(bool RXQ_FRM_ARBIT,
                                     uint8_t RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ2_CONTROL;

        curr &= ~(0b1u << 3u);
        curr |= (RXQ_FRM_ARBIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (RXQ_WEGT & 0b111u) << 0u;

        MTL_RXQ2_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ3_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_TXQ3_OPERATION_MODE_TQS() volatile
    {
        return (MTL_TXQ3_OPERATION_MODE >> 16u) & 0b11111u;
    }

    /**
     * Set MTL_TXQ3_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline void set_MTL_TXQ3_OPERATION_MODE_TQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_TXQ3_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MTL_TXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ3_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC
    get_MTL_TXQ3_OPERATION_MODE_TTC() volatile
    {
        return ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC(
            (MTL_TXQ3_OPERATION_MODE >> 4u) & 0b111u);
    }

    /**
     * Set MTL_TXQ3_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline void set_MTL_TXQ3_OPERATION_MODE_TTC(
        ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC value) volatile
    {
        uint32_t curr = MTL_TXQ3_OPERATION_MODE;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ3_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN
    get_MTL_TXQ3_OPERATION_MODE_TXQEN() volatile
    {
        return ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN(
            (MTL_TXQ3_OPERATION_MODE >> 2u) & 0b11u);
    }

    /**
     * Set MTL_TXQ3_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline void set_MTL_TXQ3_OPERATION_MODE_TXQEN(
        ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN value) volatile
    {
        uint32_t curr = MTL_TXQ3_OPERATION_MODE;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MTL_TXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ3_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline bool get_MTL_TXQ3_OPERATION_MODE_TSF() volatile
    {
        return MTL_TXQ3_OPERATION_MODE & (1u << 1u);
    }

    /**
     * Set MTL_TXQ3_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void set_MTL_TXQ3_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ3_OPERATION_MODE |= 1u << 1u;
    }

    /**
     * Clear MTL_TXQ3_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void clear_MTL_TXQ3_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ3_OPERATION_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_TXQ3_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void toggle_MTL_TXQ3_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ3_OPERATION_MODE ^= 1u << 1u;
    }

    /**
     * Get MTL_TXQ3_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline bool get_MTL_TXQ3_OPERATION_MODE_FTQ() volatile
    {
        return MTL_TXQ3_OPERATION_MODE & (1u << 0u);
    }

    /**
     * Set MTL_TXQ3_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void set_MTL_TXQ3_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ3_OPERATION_MODE |= 1u << 0u;
    }

    /**
     * Clear MTL_TXQ3_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void clear_MTL_TXQ3_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ3_OPERATION_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_TXQ3_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void toggle_MTL_TXQ3_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ3_OPERATION_MODE ^= 1u << 0u;
    }

    /**
     * Get all of MTL_TXQ3_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 3 Transmit Operation Mode
     */
    inline void get_MTL_TXQ3_OPERATION_MODE(
        uint8_t &TQS, ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC &TTC,
        ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN &TXQEN, bool &TSF,
        bool &FTQ) volatile
    {
        uint32_t curr = MTL_TXQ3_OPERATION_MODE;

        TQS = (curr >> 16u) & 0b11111u;
        TTC = ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC((curr >> 4u) & 0b111u);
        TXQEN = ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN((curr >> 2u) & 0b11u);
        TSF = curr & (1u << 1u);
        FTQ = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_TXQ3_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 3 Transmit Operation Mode
     */
    inline void set_MTL_TXQ3_OPERATION_MODE(
        uint8_t TQS, ENET_QOS_MTL_TXQ3_OPERATION_MODE_TTC TTC,
        ENET_QOS_MTL_TXQ3_OPERATION_MODE_TXQEN TXQEN, bool TSF,
        bool FTQ) volatile
    {
        uint32_t curr = MTL_TXQ3_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (TQS & 0b11111u) << 16u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(TTC) & 0b111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(TXQEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FTQ & 0b1u) << 0u;

        MTL_TXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ3_UNDERFLOW's UFCNTOVF bit.
     *
     * Overflow Bit for Underflow Packet Counter This bit is set every time the
     * Tx queue Underflow Packet Counter field overflows, that is, it has
     * crossed the maximum count.
     */
    inline bool get_MTL_TXQ3_UNDERFLOW_UFCNTOVF() volatile
    {
        return MTL_TXQ3_UNDERFLOW & (1u << 11u);
    }

    /**
     * Get MTL_TXQ3_UNDERFLOW's UFFRMCNT field.
     *
     * Underflow Packet Counter This field indicates the number of packets
     * aborted by the controller because of Tx Queue Underflow.
     */
    inline uint16_t get_MTL_TXQ3_UNDERFLOW_UFFRMCNT() volatile
    {
        return (MTL_TXQ3_UNDERFLOW >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_TXQ3_UNDERFLOW's bit fields.
     *
     * (read-write) Queue 3 Underflow Counter
     */
    inline void get_MTL_TXQ3_UNDERFLOW(bool &UFCNTOVF,
                                       uint16_t &UFFRMCNT) volatile
    {
        uint32_t curr = MTL_TXQ3_UNDERFLOW;

        UFCNTOVF = curr & (1u << 11u);
        UFFRMCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_TXQ3_DEBUG's STXSTSF field.
     *
     * Number of Status Words in Tx Status FIFO of Queue This field indicates
     * the current number of status in the Tx Status FIFO of this queue.
     */
    inline uint8_t get_MTL_TXQ3_DEBUG_STXSTSF() volatile
    {
        return (MTL_TXQ3_DEBUG >> 20u) & 0b111u;
    }

    /**
     * Get MTL_TXQ3_DEBUG's PTXQ field.
     *
     * Number of Packets in the Transmit Queue This field indicates the current
     * number of packets in the Tx Queue.
     */
    inline uint8_t get_MTL_TXQ3_DEBUG_PTXQ() volatile
    {
        return (MTL_TXQ3_DEBUG >> 16u) & 0b111u;
    }

    /**
     * Get MTL_TXQ3_DEBUG's TXSTSFSTS bit.
     *
     * MTL Tx Status FIFO Full Status When high, this bit indicates that the
     * MTL Tx Status FIFO is full.
     */
    inline bool get_MTL_TXQ3_DEBUG_TXSTSFSTS() volatile
    {
        return MTL_TXQ3_DEBUG & (1u << 5u);
    }

    /**
     * Get MTL_TXQ3_DEBUG's TXQSTS bit.
     *
     * MTL Tx Queue Not Empty Status When this bit is high, it indicates that
     * the MTL Tx Queue is not empty and some data is left for transmission.
     */
    inline bool get_MTL_TXQ3_DEBUG_TXQSTS() volatile
    {
        return MTL_TXQ3_DEBUG & (1u << 4u);
    }

    /**
     * Get MTL_TXQ3_DEBUG's TWCSTS bit.
     *
     * MTL Tx Queue Write Controller Status When high, this bit indicates that
     * the MTL Tx Queue Write Controller is active, and it is transferring the
     * data to the Tx Queue.
     */
    inline bool get_MTL_TXQ3_DEBUG_TWCSTS() volatile
    {
        return MTL_TXQ3_DEBUG & (1u << 3u);
    }

    /**
     * Get MTL_TXQ3_DEBUG's TRCSTS field.
     *
     * MTL Tx Queue Read Controller Status This field indicates the state of
     * the Tx Queue Read Controller:
     */
    inline ENET_QOS_MTL_TXQ3_DEBUG_TRCSTS get_MTL_TXQ3_DEBUG_TRCSTS() volatile
    {
        return ENET_QOS_MTL_TXQ3_DEBUG_TRCSTS((MTL_TXQ3_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_TXQ3_DEBUG's TXQPAUSED bit.
     *
     * Transmit Queue in Pause When this bit is high and the Rx flow control is
     * enabled, it indicates that the Tx Queue is in the Pause condition (in
     * the full-duplex only mode) because of the following: - Reception of the
     * PFC packet for the priorities assigned to the Tx Queue when PFC is
     * enabled - Reception of 802.
     */
    inline bool get_MTL_TXQ3_DEBUG_TXQPAUSED() volatile
    {
        return MTL_TXQ3_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_TXQ3_DEBUG's bit fields.
     *
     * (read-write) Queue 3 Transmit Debug
     */
    inline void get_MTL_TXQ3_DEBUG(uint8_t &STXSTSF, uint8_t &PTXQ,
                                   bool &TXSTSFSTS, bool &TXQSTS, bool &TWCSTS,
                                   ENET_QOS_MTL_TXQ3_DEBUG_TRCSTS &TRCSTS,
                                   bool &TXQPAUSED) volatile
    {
        uint32_t curr = MTL_TXQ3_DEBUG;

        STXSTSF = (curr >> 20u) & 0b111u;
        PTXQ = (curr >> 16u) & 0b111u;
        TXSTSFSTS = curr & (1u << 5u);
        TXQSTS = curr & (1u << 4u);
        TWCSTS = curr & (1u << 3u);
        TRCSTS = ENET_QOS_MTL_TXQ3_DEBUG_TRCSTS((curr >> 1u) & 0b11u);
        TXQPAUSED = curr & (1u << 0u);
    }

    /**
     * Get MTL_TXQ3_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[N]_SLOT_INTERVAL register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC
    get_MTL_TXQ3_ETS_CONTROL_SLC() volatile
    {
        return ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC((MTL_TXQ3_ETS_CONTROL >> 4u) &
                                                 0b111u);
    }

    /**
     * Set MTL_TXQ3_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[N]_SLOT_INTERVAL register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline void set_MTL_TXQ3_ETS_CONTROL_SLC(
        ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC value) volatile
    {
        uint32_t curr = MTL_TXQ3_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ3_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ3_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline bool get_MTL_TXQ3_ETS_CONTROL_CC() volatile
    {
        return MTL_TXQ3_ETS_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_TXQ3_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void set_MTL_TXQ3_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ3_ETS_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_TXQ3_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void clear_MTL_TXQ3_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ3_ETS_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_TXQ3_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void toggle_MTL_TXQ3_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ3_ETS_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_TXQ3_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline bool get_MTL_TXQ3_ETS_CONTROL_AVALG() volatile
    {
        return MTL_TXQ3_ETS_CONTROL & (1u << 2u);
    }

    /**
     * Set MTL_TXQ3_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void set_MTL_TXQ3_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ3_ETS_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MTL_TXQ3_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void clear_MTL_TXQ3_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ3_ETS_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_TXQ3_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void toggle_MTL_TXQ3_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ3_ETS_CONTROL ^= 1u << 2u;
    }

    /**
     * Get all of MTL_TXQ3_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 3 ETS Control
     */
    inline void get_MTL_TXQ3_ETS_CONTROL(
        ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC &SLC, bool &CC, bool &AVALG) volatile
    {
        uint32_t curr = MTL_TXQ3_ETS_CONTROL;

        SLC = ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC((curr >> 4u) & 0b111u);
        CC = curr & (1u << 3u);
        AVALG = curr & (1u << 2u);
    }

    /**
     * Set all of MTL_TXQ3_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 3 ETS Control
     */
    inline void set_MTL_TXQ3_ETS_CONTROL(ENET_QOS_MTL_TXQ3_ETS_CONTROL_SLC SLC,
                                         bool CC, bool AVALG) volatile
    {
        uint32_t curr = MTL_TXQ3_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(SLC) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CC & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AVALG & 0b1u) << 2u;

        MTL_TXQ3_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ3_ETS_STATUS's ABS field.
     *
     * Average Bits per Slot This field contains the average transmitted bits
     * per slot.
     */
    inline uint32_t get_MTL_TXQ3_ETS_STATUS_ABS() volatile
    {
        return (MTL_TXQ3_ETS_STATUS >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get MTL_TXQ3_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline uint32_t get_MTL_TXQ3_QUANTUM_WEIGHT_ISCQW() volatile
    {
        return (MTL_TXQ3_QUANTUM_WEIGHT >> 0u) & 0b111111111111111111111u;
    }

    /**
     * Set MTL_TXQ3_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline void set_MTL_TXQ3_QUANTUM_WEIGHT_ISCQW(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ3_QUANTUM_WEIGHT;

        curr &= ~(0b111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111u) << 0u;

        MTL_TXQ3_QUANTUM_WEIGHT = curr;
    }

    /**
     * Get MTL_TXQ3_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline uint16_t get_MTL_TXQ3_SENDSLOPECREDIT_SSC() volatile
    {
        return (MTL_TXQ3_SENDSLOPECREDIT >> 0u) & 0b11111111111111u;
    }

    /**
     * Set MTL_TXQ3_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline void set_MTL_TXQ3_SENDSLOPECREDIT_SSC(uint16_t value) volatile
    {
        uint32_t curr = MTL_TXQ3_SENDSLOPECREDIT;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        MTL_TXQ3_SENDSLOPECREDIT = curr;
    }

    /**
     * Get MTL_TXQ3_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ3_HICREDIT_HC() volatile
    {
        return (MTL_TXQ3_HICREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ3_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ3_HICREDIT_HC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ3_HICREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ3_HICREDIT = curr;
    }

    /**
     * Get MTL_TXQ3_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ3_LOCREDIT_LC() volatile
    {
        return (MTL_TXQ3_LOCREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ3_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ3_LOCREDIT_LC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ3_LOCREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ3_LOCREDIT = curr;
    }

    /**
     * Get MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline bool get_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        return MTL_Q3_INTERRUPT_CONTROL_STATUS & (1u << 24u);
    }

    /**
     * Set MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS |= 1u << 24u;
    }

    /**
     * Clear MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void clear_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void toggle_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS ^= 1u << 24u;
    }

    /**
     * Get MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline bool get_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        return MTL_Q3_INTERRUPT_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void clear_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_Q3_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void toggle_MTL_Q3_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline bool get_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        return MTL_Q3_INTERRUPT_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Set MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS |= 1u << 9u;
    }

    /**
     * Clear MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void clear_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void toggle_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS ^= 1u << 9u;
    }

    /**
     * Get MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline bool get_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        return MTL_Q3_INTERRUPT_CONTROL_STATUS & (1u << 8u);
    }

    /**
     * Set MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS |= 1u << 8u;
    }

    /**
     * Clear MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void clear_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void toggle_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS ^= 1u << 8u;
    }

    /**
     * Get MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline bool get_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        return MTL_Q3_INTERRUPT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void clear_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_Q3_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void toggle_MTL_Q3_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline bool get_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        return MTL_Q3_INTERRUPT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void clear_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_Q3_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void toggle_MTL_Q3_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q3_INTERRUPT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_Q3_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 3 Interrupt Control Status
     */
    inline void get_MTL_Q3_INTERRUPT_CONTROL_STATUS(bool &RXOIE, bool &RXOVFIS,
                                                    bool &ABPSIE, bool &TXUIE,
                                                    bool &ABPSIS,
                                                    bool &TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q3_INTERRUPT_CONTROL_STATUS;

        RXOIE = curr & (1u << 24u);
        RXOVFIS = curr & (1u << 16u);
        ABPSIE = curr & (1u << 9u);
        TXUIE = curr & (1u << 8u);
        ABPSIS = curr & (1u << 1u);
        TXUNFIS = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_Q3_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 3 Interrupt Control Status
     */
    inline void set_MTL_Q3_INTERRUPT_CONTROL_STATUS(bool RXOIE, bool RXOVFIS,
                                                    bool ABPSIE, bool TXUIE,
                                                    bool ABPSIS,
                                                    bool TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q3_INTERRUPT_CONTROL_STATUS;

        curr &= ~(0b1u << 24u);
        curr |= (RXOIE & 0b1u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (RXOVFIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (ABPSIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TXUIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (ABPSIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXUNFIS & 0b1u) << 0u;

        MTL_Q3_INTERRUPT_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_RXQ3_OPERATION_MODE_RQS() volatile
    {
        return (MTL_RXQ3_OPERATION_MODE >> 20u) & 0b11111u;
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_RQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ3_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        MTL_RXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline uint8_t get_MTL_RXQ3_OPERATION_MODE_RFD() volatile
    {
        return (MTL_RXQ3_OPERATION_MODE >> 14u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_RFD(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ3_OPERATION_MODE;

        curr &= ~(0b1111u << 14u);
        curr |= (value & 0b1111u) << 14u;

        MTL_RXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline uint8_t get_MTL_RXQ3_OPERATION_MODE_RFA() volatile
    {
        return (MTL_RXQ3_OPERATION_MODE >> 8u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_RFA(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ3_OPERATION_MODE;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MTL_RXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline bool get_MTL_RXQ3_OPERATION_MODE_EHFC() volatile
    {
        return MTL_RXQ3_OPERATION_MODE & (1u << 7u);
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ3_OPERATION_MODE |= 1u << 7u;
    }

    /**
     * Clear MTL_RXQ3_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void clear_MTL_RXQ3_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ3_OPERATION_MODE &= ~(1u << 7u);
    }

    /**
     * Toggle MTL_RXQ3_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void toggle_MTL_RXQ3_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ3_OPERATION_MODE ^= 1u << 7u;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline bool get_MTL_RXQ3_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        return MTL_RXQ3_OPERATION_MODE & (1u << 6u);
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ3_OPERATION_MODE |= 1u << 6u;
    }

    /**
     * Clear MTL_RXQ3_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void clear_MTL_RXQ3_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ3_OPERATION_MODE &= ~(1u << 6u);
    }

    /**
     * Toggle MTL_RXQ3_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void toggle_MTL_RXQ3_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ3_OPERATION_MODE ^= 1u << 6u;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline bool get_MTL_RXQ3_OPERATION_MODE_RSF() volatile
    {
        return MTL_RXQ3_OPERATION_MODE & (1u << 5u);
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ3_OPERATION_MODE |= 1u << 5u;
    }

    /**
     * Clear MTL_RXQ3_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void clear_MTL_RXQ3_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ3_OPERATION_MODE &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_RXQ3_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void toggle_MTL_RXQ3_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ3_OPERATION_MODE ^= 1u << 5u;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline bool get_MTL_RXQ3_OPERATION_MODE_FEP() volatile
    {
        return MTL_RXQ3_OPERATION_MODE & (1u << 4u);
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ3_OPERATION_MODE |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ3_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void clear_MTL_RXQ3_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ3_OPERATION_MODE &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ3_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void toggle_MTL_RXQ3_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ3_OPERATION_MODE ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline bool get_MTL_RXQ3_OPERATION_MODE_FUP() volatile
    {
        return MTL_RXQ3_OPERATION_MODE & (1u << 3u);
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ3_OPERATION_MODE |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ3_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void clear_MTL_RXQ3_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ3_OPERATION_MODE &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ3_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void toggle_MTL_RXQ3_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ3_OPERATION_MODE ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ3_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC
    get_MTL_RXQ3_OPERATION_MODE_RTC() volatile
    {
        return ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC(
            (MTL_RXQ3_OPERATION_MODE >> 0u) & 0b11u);
    }

    /**
     * Set MTL_RXQ3_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline void set_MTL_RXQ3_OPERATION_MODE_RTC(
        ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC value) volatile
    {
        uint32_t curr = MTL_RXQ3_OPERATION_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        MTL_RXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get all of MTL_RXQ3_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 3 Receive Operation Mode
     */
    inline void get_MTL_RXQ3_OPERATION_MODE(
        uint8_t &RQS, uint8_t &RFD, uint8_t &RFA, bool &EHFC, bool &DIS_TCP_EF,
        bool &RSF, bool &FEP, bool &FUP,
        ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC &RTC) volatile
    {
        uint32_t curr = MTL_RXQ3_OPERATION_MODE;

        RQS = (curr >> 20u) & 0b11111u;
        RFD = (curr >> 14u) & 0b1111u;
        RFA = (curr >> 8u) & 0b1111u;
        EHFC = curr & (1u << 7u);
        DIS_TCP_EF = curr & (1u << 6u);
        RSF = curr & (1u << 5u);
        FEP = curr & (1u << 4u);
        FUP = curr & (1u << 3u);
        RTC = ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of MTL_RXQ3_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 3 Receive Operation Mode
     */
    inline void set_MTL_RXQ3_OPERATION_MODE(
        uint8_t RQS, uint8_t RFD, uint8_t RFA, bool EHFC, bool DIS_TCP_EF,
        bool RSF, bool FEP, bool FUP,
        ENET_QOS_MTL_RXQ3_OPERATION_MODE_RTC RTC) volatile
    {
        uint32_t curr = MTL_RXQ3_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (RQS & 0b11111u) << 20u;
        curr &= ~(0b1111u << 14u);
        curr |= (RFD & 0b1111u) << 14u;
        curr &= ~(0b1111u << 8u);
        curr |= (RFA & 0b1111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (EHFC & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DIS_TCP_EF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RSF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (FEP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FUP & 0b1u) << 3u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RTC) & 0b11u) << 0u;

        MTL_RXQ3_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT's MISCNTOVF bit.
     *
     * Missed Packet Counter Overflow Bit When set, this bit indicates that the
     * Rx Queue Missed Packet Counter crossed the maximum limit.
     */
    inline bool get_MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT_MISCNTOVF() volatile
    {
        return MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT & (1u << 27u);
    }

    /**
     * Get MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT's MISPKTCNT field.
     *
     * Missed Packet Counter This field indicates the number of packets missed
     * by the DWC_ether_qos because the application asserted ari_pkt_flush_i[]
     * for this queue.
     */
    inline uint16_t
    get_MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT_MISPKTCNT() volatile
    {
        return (MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT >> 16u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT's OVFCNTOVF bit.
     *
     * Overflow Counter Overflow Bit When set, this bit indicates that the Rx
     * Queue Overflow Packet Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT_OVFCNTOVF() volatile
    {
        return MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT & (1u << 11u);
    }

    /**
     * Get MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT's OVFPKTCNT field.
     *
     * Overflow Packet Counter This field indicates the number of packets
     * discarded by the DWC_ether_qos because of Receive queue overflow.
     */
    inline uint16_t
    get_MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT_OVFPKTCNT() volatile
    {
        return (MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT's bit fields.
     *
     * (read-write) Queue 3 Missed Packet and Overflow Counter
     */
    inline void get_MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT(
        bool &MISCNTOVF, uint16_t &MISPKTCNT, bool &OVFCNTOVF,
        uint16_t &OVFPKTCNT) volatile
    {
        uint32_t curr = MTL_RXQ3_MISSED_PACKET_OVERFLOW_CNT;

        MISCNTOVF = curr & (1u << 27u);
        MISPKTCNT = (curr >> 16u) & 0b11111111111u;
        OVFCNTOVF = curr & (1u << 11u);
        OVFPKTCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ3_DEBUG's PRXQ field.
     *
     * Number of Packets in Receive Queue This field indicates the current
     * number of packets in the Rx Queue.
     */
    inline uint16_t get_MTL_RXQ3_DEBUG_PRXQ() volatile
    {
        return (MTL_RXQ3_DEBUG >> 16u) & 0b11111111111111u;
    }

    /**
     * Get MTL_RXQ3_DEBUG's RXQSTS field.
     *
     * MTL Rx Queue Fill-Level Status This field gives the status of the
     * fill-level of the Rx Queue:
     */
    inline ENET_QOS_MTL_RXQ3_DEBUG_RXQSTS get_MTL_RXQ3_DEBUG_RXQSTS() volatile
    {
        return ENET_QOS_MTL_RXQ3_DEBUG_RXQSTS((MTL_RXQ3_DEBUG >> 4u) & 0b11u);
    }

    /**
     * Get MTL_RXQ3_DEBUG's RRCSTS field.
     *
     * MTL Rx Queue Read Controller State This field gives the state of the Rx
     * queue Read controller:
     */
    inline ENET_QOS_MTL_RXQ3_DEBUG_RRCSTS get_MTL_RXQ3_DEBUG_RRCSTS() volatile
    {
        return ENET_QOS_MTL_RXQ3_DEBUG_RRCSTS((MTL_RXQ3_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_RXQ3_DEBUG's RWCSTS bit.
     *
     * MTL Rx Queue Write Controller Active Status When high, this bit
     * indicates that the MTL Rx queue Write controller is active, and it is
     * transferring a received packet to the Rx Queue.
     */
    inline bool get_MTL_RXQ3_DEBUG_RWCSTS() volatile
    {
        return MTL_RXQ3_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_RXQ3_DEBUG's bit fields.
     *
     * (read-write) Queue 3 Receive Debug
     */
    inline void get_MTL_RXQ3_DEBUG(uint16_t &PRXQ,
                                   ENET_QOS_MTL_RXQ3_DEBUG_RXQSTS &RXQSTS,
                                   ENET_QOS_MTL_RXQ3_DEBUG_RRCSTS &RRCSTS,
                                   bool &RWCSTS) volatile
    {
        uint32_t curr = MTL_RXQ3_DEBUG;

        PRXQ = (curr >> 16u) & 0b11111111111111u;
        RXQSTS = ENET_QOS_MTL_RXQ3_DEBUG_RXQSTS((curr >> 4u) & 0b11u);
        RRCSTS = ENET_QOS_MTL_RXQ3_DEBUG_RRCSTS((curr >> 1u) & 0b11u);
        RWCSTS = curr & (1u << 0u);
    }

    /**
     * Get MTL_RXQ3_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline bool get_MTL_RXQ3_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        return MTL_RXQ3_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_RXQ3_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void set_MTL_RXQ3_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ3_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ3_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void clear_MTL_RXQ3_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ3_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ3_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void toggle_MTL_RXQ3_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ3_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ3_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline uint8_t get_MTL_RXQ3_CONTROL_RXQ_WEGT() volatile
    {
        return (MTL_RXQ3_CONTROL >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ3_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline void set_MTL_RXQ3_CONTROL_RXQ_WEGT(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ3_CONTROL;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ3_CONTROL = curr;
    }

    /**
     * Get all of MTL_RXQ3_CONTROL's bit fields.
     *
     * (read-write) Queue 3 Receive Control
     */
    inline void get_MTL_RXQ3_CONTROL(bool &RXQ_FRM_ARBIT,
                                     uint8_t &RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ3_CONTROL;

        RXQ_FRM_ARBIT = curr & (1u << 3u);
        RXQ_WEGT = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ3_CONTROL's bit fields.
     *
     * (read-write) Queue 3 Receive Control
     */
    inline void set_MTL_RXQ3_CONTROL(bool RXQ_FRM_ARBIT,
                                     uint8_t RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ3_CONTROL;

        curr &= ~(0b1u << 3u);
        curr |= (RXQ_FRM_ARBIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (RXQ_WEGT & 0b111u) << 0u;

        MTL_RXQ3_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ4_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_TXQ4_OPERATION_MODE_TQS() volatile
    {
        return (MTL_TXQ4_OPERATION_MODE >> 16u) & 0b11111u;
    }

    /**
     * Set MTL_TXQ4_OPERATION_MODE's TQS field.
     *
     * Transmit Queue Size This field indicates the size of the allocated
     * Transmit queues in blocks of 256 bytes.
     */
    inline void set_MTL_TXQ4_OPERATION_MODE_TQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_TXQ4_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        MTL_TXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ4_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC
    get_MTL_TXQ4_OPERATION_MODE_TTC() volatile
    {
        return ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC(
            (MTL_TXQ4_OPERATION_MODE >> 4u) & 0b111u);
    }

    /**
     * Set MTL_TXQ4_OPERATION_MODE's TTC field.
     *
     * Transmit Threshold Control These bits control the threshold level of the
     * MTL Tx Queue.
     */
    inline void set_MTL_TXQ4_OPERATION_MODE_TTC(
        ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC value) volatile
    {
        uint32_t curr = MTL_TXQ4_OPERATION_MODE;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ4_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN
    get_MTL_TXQ4_OPERATION_MODE_TXQEN() volatile
    {
        return ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN(
            (MTL_TXQ4_OPERATION_MODE >> 2u) & 0b11u);
    }

    /**
     * Set MTL_TXQ4_OPERATION_MODE's TXQEN field.
     *
     * Transmit Queue Enable This field is used to enable/disable the transmit
     * queue 0.
     */
    inline void set_MTL_TXQ4_OPERATION_MODE_TXQEN(
        ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN value) volatile
    {
        uint32_t curr = MTL_TXQ4_OPERATION_MODE;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        MTL_TXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ4_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline bool get_MTL_TXQ4_OPERATION_MODE_TSF() volatile
    {
        return MTL_TXQ4_OPERATION_MODE & (1u << 1u);
    }

    /**
     * Set MTL_TXQ4_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void set_MTL_TXQ4_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ4_OPERATION_MODE |= 1u << 1u;
    }

    /**
     * Clear MTL_TXQ4_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void clear_MTL_TXQ4_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ4_OPERATION_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_TXQ4_OPERATION_MODE's TSF bit.
     *
     * Transmit Store and Forward When this bit is set, the transmission starts
     * when a full packet resides in the MTL Tx queue.
     */
    inline void toggle_MTL_TXQ4_OPERATION_MODE_TSF() volatile
    {
        MTL_TXQ4_OPERATION_MODE ^= 1u << 1u;
    }

    /**
     * Get MTL_TXQ4_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline bool get_MTL_TXQ4_OPERATION_MODE_FTQ() volatile
    {
        return MTL_TXQ4_OPERATION_MODE & (1u << 0u);
    }

    /**
     * Set MTL_TXQ4_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void set_MTL_TXQ4_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ4_OPERATION_MODE |= 1u << 0u;
    }

    /**
     * Clear MTL_TXQ4_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void clear_MTL_TXQ4_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ4_OPERATION_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_TXQ4_OPERATION_MODE's FTQ bit.
     *
     * Flush Transmit Queue When this bit is set, the Tx queue controller logic
     * is reset to its default values.
     */
    inline void toggle_MTL_TXQ4_OPERATION_MODE_FTQ() volatile
    {
        MTL_TXQ4_OPERATION_MODE ^= 1u << 0u;
    }

    /**
     * Get all of MTL_TXQ4_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 4 Transmit Operation Mode
     */
    inline void get_MTL_TXQ4_OPERATION_MODE(
        uint8_t &TQS, ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC &TTC,
        ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN &TXQEN, bool &TSF,
        bool &FTQ) volatile
    {
        uint32_t curr = MTL_TXQ4_OPERATION_MODE;

        TQS = (curr >> 16u) & 0b11111u;
        TTC = ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC((curr >> 4u) & 0b111u);
        TXQEN = ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN((curr >> 2u) & 0b11u);
        TSF = curr & (1u << 1u);
        FTQ = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_TXQ4_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 4 Transmit Operation Mode
     */
    inline void set_MTL_TXQ4_OPERATION_MODE(
        uint8_t TQS, ENET_QOS_MTL_TXQ4_OPERATION_MODE_TTC TTC,
        ENET_QOS_MTL_TXQ4_OPERATION_MODE_TXQEN TXQEN, bool TSF,
        bool FTQ) volatile
    {
        uint32_t curr = MTL_TXQ4_OPERATION_MODE;

        curr &= ~(0b11111u << 16u);
        curr |= (TQS & 0b11111u) << 16u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(TTC) & 0b111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(TXQEN) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TSF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FTQ & 0b1u) << 0u;

        MTL_TXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_TXQ4_UNDERFLOW's UFCNTOVF bit.
     *
     * Overflow Bit for Underflow Packet Counter This bit is set every time the
     * Tx queue Underflow Packet Counter field overflows, that is, it has
     * crossed the maximum count.
     */
    inline bool get_MTL_TXQ4_UNDERFLOW_UFCNTOVF() volatile
    {
        return MTL_TXQ4_UNDERFLOW & (1u << 11u);
    }

    /**
     * Get MTL_TXQ4_UNDERFLOW's UFFRMCNT field.
     *
     * Underflow Packet Counter This field indicates the number of packets
     * aborted by the controller because of Tx Queue Underflow.
     */
    inline uint16_t get_MTL_TXQ4_UNDERFLOW_UFFRMCNT() volatile
    {
        return (MTL_TXQ4_UNDERFLOW >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_TXQ4_UNDERFLOW's bit fields.
     *
     * (read-write) Queue 4 Underflow Counter
     */
    inline void get_MTL_TXQ4_UNDERFLOW(bool &UFCNTOVF,
                                       uint16_t &UFFRMCNT) volatile
    {
        uint32_t curr = MTL_TXQ4_UNDERFLOW;

        UFCNTOVF = curr & (1u << 11u);
        UFFRMCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_TXQ4_DEBUG's STXSTSF field.
     *
     * Number of Status Words in Tx Status FIFO of Queue This field indicates
     * the current number of status in the Tx Status FIFO of this queue.
     */
    inline uint8_t get_MTL_TXQ4_DEBUG_STXSTSF() volatile
    {
        return (MTL_TXQ4_DEBUG >> 20u) & 0b111u;
    }

    /**
     * Get MTL_TXQ4_DEBUG's PTXQ field.
     *
     * Number of Packets in the Transmit Queue This field indicates the current
     * number of packets in the Tx Queue.
     */
    inline uint8_t get_MTL_TXQ4_DEBUG_PTXQ() volatile
    {
        return (MTL_TXQ4_DEBUG >> 16u) & 0b111u;
    }

    /**
     * Get MTL_TXQ4_DEBUG's TXSTSFSTS bit.
     *
     * MTL Tx Status FIFO Full Status When high, this bit indicates that the
     * MTL Tx Status FIFO is full.
     */
    inline bool get_MTL_TXQ4_DEBUG_TXSTSFSTS() volatile
    {
        return MTL_TXQ4_DEBUG & (1u << 5u);
    }

    /**
     * Get MTL_TXQ4_DEBUG's TXQSTS bit.
     *
     * MTL Tx Queue Not Empty Status When this bit is high, it indicates that
     * the MTL Tx Queue is not empty and some data is left for transmission.
     */
    inline bool get_MTL_TXQ4_DEBUG_TXQSTS() volatile
    {
        return MTL_TXQ4_DEBUG & (1u << 4u);
    }

    /**
     * Get MTL_TXQ4_DEBUG's TWCSTS bit.
     *
     * MTL Tx Queue Write Controller Status When high, this bit indicates that
     * the MTL Tx Queue Write Controller is active, and it is transferring the
     * data to the Tx Queue.
     */
    inline bool get_MTL_TXQ4_DEBUG_TWCSTS() volatile
    {
        return MTL_TXQ4_DEBUG & (1u << 3u);
    }

    /**
     * Get MTL_TXQ4_DEBUG's TRCSTS field.
     *
     * MTL Tx Queue Read Controller Status This field indicates the state of
     * the Tx Queue Read Controller:
     */
    inline ENET_QOS_MTL_TXQ4_DEBUG_TRCSTS get_MTL_TXQ4_DEBUG_TRCSTS() volatile
    {
        return ENET_QOS_MTL_TXQ4_DEBUG_TRCSTS((MTL_TXQ4_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_TXQ4_DEBUG's TXQPAUSED bit.
     *
     * Transmit Queue in Pause When this bit is high and the Rx flow control is
     * enabled, it indicates that the Tx Queue is in the Pause condition (in
     * the full-duplex only mode) because of the following: - Reception of the
     * PFC packet for the priorities assigned to the Tx Queue when PFC is
     * enabled - Reception of 802.
     */
    inline bool get_MTL_TXQ4_DEBUG_TXQPAUSED() volatile
    {
        return MTL_TXQ4_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_TXQ4_DEBUG's bit fields.
     *
     * (read-write) Queue 4 Transmit Debug
     */
    inline void get_MTL_TXQ4_DEBUG(uint8_t &STXSTSF, uint8_t &PTXQ,
                                   bool &TXSTSFSTS, bool &TXQSTS, bool &TWCSTS,
                                   ENET_QOS_MTL_TXQ4_DEBUG_TRCSTS &TRCSTS,
                                   bool &TXQPAUSED) volatile
    {
        uint32_t curr = MTL_TXQ4_DEBUG;

        STXSTSF = (curr >> 20u) & 0b111u;
        PTXQ = (curr >> 16u) & 0b111u;
        TXSTSFSTS = curr & (1u << 5u);
        TXQSTS = curr & (1u << 4u);
        TWCSTS = curr & (1u << 3u);
        TRCSTS = ENET_QOS_MTL_TXQ4_DEBUG_TRCSTS((curr >> 1u) & 0b11u);
        TXQPAUSED = curr & (1u << 0u);
    }

    /**
     * Get MTL_TXQ4_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[N]_SLOT_INTERVAL register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC
    get_MTL_TXQ4_ETS_CONTROL_SLC() volatile
    {
        return ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC((MTL_TXQ4_ETS_CONTROL >> 4u) &
                                                 0b111u);
    }

    /**
     * Set MTL_TXQ4_ETS_CONTROL's SLC field.
     *
     * Slot Count If the credit-based shaper algorithm is enabled, the software
     * can program the number of slots (of duration programmed in
     * DMA_CH[N]_SLOT_INTERVAL register) over which the average transmitted
     * bits per slot, provided in the MTL_TXQ[N]_ETS_STATUS register, need to
     * be computed for Queue.
     */
    inline void set_MTL_TXQ4_ETS_CONTROL_SLC(
        ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC value) volatile
    {
        uint32_t curr = MTL_TXQ4_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        MTL_TXQ4_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ4_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline bool get_MTL_TXQ4_ETS_CONTROL_CC() volatile
    {
        return MTL_TXQ4_ETS_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_TXQ4_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void set_MTL_TXQ4_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ4_ETS_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_TXQ4_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void clear_MTL_TXQ4_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ4_ETS_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_TXQ4_ETS_CONTROL's CC bit.
     *
     * Credit Control When this bit is set, the accumulated credit parameter in
     * the credit-based shaper algorithm logic is not reset to zero when there
     * is positive credit and no packet to transmit in Channel 1.
     */
    inline void toggle_MTL_TXQ4_ETS_CONTROL_CC() volatile
    {
        MTL_TXQ4_ETS_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_TXQ4_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline bool get_MTL_TXQ4_ETS_CONTROL_AVALG() volatile
    {
        return MTL_TXQ4_ETS_CONTROL & (1u << 2u);
    }

    /**
     * Set MTL_TXQ4_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void set_MTL_TXQ4_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ4_ETS_CONTROL |= 1u << 2u;
    }

    /**
     * Clear MTL_TXQ4_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void clear_MTL_TXQ4_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ4_ETS_CONTROL &= ~(1u << 2u);
    }

    /**
     * Toggle MTL_TXQ4_ETS_CONTROL's AVALG bit.
     *
     * AV Algorithm When Queue 1 is programmed for AV, this field configures
     * the scheduling algorithm for this queue: This bit when set, indicates
     * credit based shaper algorithm (CBS) is selected for Queue 1 traffic.
     */
    inline void toggle_MTL_TXQ4_ETS_CONTROL_AVALG() volatile
    {
        MTL_TXQ4_ETS_CONTROL ^= 1u << 2u;
    }

    /**
     * Get all of MTL_TXQ4_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 4 ETS Control
     */
    inline void get_MTL_TXQ4_ETS_CONTROL(
        ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC &SLC, bool &CC, bool &AVALG) volatile
    {
        uint32_t curr = MTL_TXQ4_ETS_CONTROL;

        SLC = ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC((curr >> 4u) & 0b111u);
        CC = curr & (1u << 3u);
        AVALG = curr & (1u << 2u);
    }

    /**
     * Set all of MTL_TXQ4_ETS_CONTROL's bit fields.
     *
     * (read-write) Queue 4 ETS Control
     */
    inline void set_MTL_TXQ4_ETS_CONTROL(ENET_QOS_MTL_TXQ4_ETS_CONTROL_SLC SLC,
                                         bool CC, bool AVALG) volatile
    {
        uint32_t curr = MTL_TXQ4_ETS_CONTROL;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(SLC) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CC & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AVALG & 0b1u) << 2u;

        MTL_TXQ4_ETS_CONTROL = curr;
    }

    /**
     * Get MTL_TXQ4_ETS_STATUS's ABS field.
     *
     * Average Bits per Slot This field contains the average transmitted bits
     * per slot.
     */
    inline uint32_t get_MTL_TXQ4_ETS_STATUS_ABS() volatile
    {
        return (MTL_TXQ4_ETS_STATUS >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get MTL_TXQ4_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline uint32_t get_MTL_TXQ4_QUANTUM_WEIGHT_ISCQW() volatile
    {
        return (MTL_TXQ4_QUANTUM_WEIGHT >> 0u) & 0b111111111111111111111u;
    }

    /**
     * Set MTL_TXQ4_QUANTUM_WEIGHT's ISCQW field.
     *
     * idleSlopeCredit, Quantum or Weights - idleSlopeCredit When AV feature is
     * enabled, this field contains the idleSlopeCredit value required for the
     * credit-based shaper algorithm for Queue 1.
     */
    inline void set_MTL_TXQ4_QUANTUM_WEIGHT_ISCQW(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ4_QUANTUM_WEIGHT;

        curr &= ~(0b111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111u) << 0u;

        MTL_TXQ4_QUANTUM_WEIGHT = curr;
    }

    /**
     * Get MTL_TXQ4_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline uint16_t get_MTL_TXQ4_SENDSLOPECREDIT_SSC() volatile
    {
        return (MTL_TXQ4_SENDSLOPECREDIT >> 0u) & 0b11111111111111u;
    }

    /**
     * Set MTL_TXQ4_SENDSLOPECREDIT's SSC field.
     *
     * sendSlopeCredit Value When AV operation is enabled, this field contains
     * the sendSlopeCredit value required for credit-based shaper algorithm for
     * Queue 1.
     */
    inline void set_MTL_TXQ4_SENDSLOPECREDIT_SSC(uint16_t value) volatile
    {
        uint32_t curr = MTL_TXQ4_SENDSLOPECREDIT;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        MTL_TXQ4_SENDSLOPECREDIT = curr;
    }

    /**
     * Get MTL_TXQ4_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ4_HICREDIT_HC() volatile
    {
        return (MTL_TXQ4_HICREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ4_HICREDIT's HC field.
     *
     * hiCredit Value When the AV feature is enabled, this field contains the
     * hiCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ4_HICREDIT_HC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ4_HICREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ4_HICREDIT = curr;
    }

    /**
     * Get MTL_TXQ4_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline uint32_t get_MTL_TXQ4_LOCREDIT_LC() volatile
    {
        return (MTL_TXQ4_LOCREDIT >> 0u) & 0b11111111111111111111111111111u;
    }

    /**
     * Set MTL_TXQ4_LOCREDIT's LC field.
     *
     * loCredit Value When AV operation is enabled, this field contains the
     * loCredit value required for the credit-based shaper algorithm.
     */
    inline void set_MTL_TXQ4_LOCREDIT_LC(uint32_t value) volatile
    {
        uint32_t curr = MTL_TXQ4_LOCREDIT;

        curr &= ~(0b11111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111u) << 0u;

        MTL_TXQ4_LOCREDIT = curr;
    }

    /**
     * Get MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline bool get_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        return MTL_Q4_INTERRUPT_CONTROL_STATUS & (1u << 24u);
    }

    /**
     * Set MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS |= 1u << 24u;
    }

    /**
     * Clear MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void clear_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOIE bit.
     *
     * Receive Queue Overflow Interrupt Enable When this bit is set, the
     * Receive Queue Overflow interrupt is enabled.
     */
    inline void toggle_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS ^= 1u << 24u;
    }

    /**
     * Get MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline bool get_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        return MTL_Q4_INTERRUPT_CONTROL_STATUS & (1u << 16u);
    }

    /**
     * Set MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS |= 1u << 16u;
    }

    /**
     * Clear MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void clear_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle MTL_Q4_INTERRUPT_CONTROL_STATUS's RXOVFIS bit.
     *
     * Receive Queue Overflow Interrupt Status This bit indicates that the
     * Receive Queue had an overflow while receiving the packet.
     */
    inline void toggle_MTL_Q4_INTERRUPT_CONTROL_STATUS_RXOVFIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS ^= 1u << 16u;
    }

    /**
     * Get MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline bool get_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        return MTL_Q4_INTERRUPT_CONTROL_STATUS & (1u << 9u);
    }

    /**
     * Set MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS |= 1u << 9u;
    }

    /**
     * Clear MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void clear_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIE bit.
     *
     * Average Bits Per Slot Interrupt Enable When this bit is set, the MAC
     * asserts the sbd_intr_o or mci_intr_o interrupt when the average bits per
     * slot status is updated.
     */
    inline void toggle_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS ^= 1u << 9u;
    }

    /**
     * Get MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline bool get_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        return MTL_Q4_INTERRUPT_CONTROL_STATUS & (1u << 8u);
    }

    /**
     * Set MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS |= 1u << 8u;
    }

    /**
     * Clear MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void clear_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUIE bit.
     *
     * Transmit Queue Underflow Interrupt Enable When this bit is set, the
     * Transmit Queue Underflow interrupt is enabled.
     */
    inline void toggle_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUIE() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS ^= 1u << 8u;
    }

    /**
     * Get MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline bool get_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        return MTL_Q4_INTERRUPT_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void clear_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle MTL_Q4_INTERRUPT_CONTROL_STATUS's ABPSIS bit.
     *
     * Average Bits Per Slot Interrupt Status When set, this bit indicates that
     * the MAC has updated the ABS value.
     */
    inline void toggle_MTL_Q4_INTERRUPT_CONTROL_STATUS_ABPSIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline bool get_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        return MTL_Q4_INTERRUPT_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void clear_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle MTL_Q4_INTERRUPT_CONTROL_STATUS's TXUNFIS bit.
     *
     * Transmit Queue Underflow Interrupt Status This bit indicates that the
     * Transmit Queue had an underflow while transmitting the packet.
     */
    inline void toggle_MTL_Q4_INTERRUPT_CONTROL_STATUS_TXUNFIS() volatile
    {
        MTL_Q4_INTERRUPT_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of MTL_Q4_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 4 Interrupt Control Status
     */
    inline void get_MTL_Q4_INTERRUPT_CONTROL_STATUS(bool &RXOIE, bool &RXOVFIS,
                                                    bool &ABPSIE, bool &TXUIE,
                                                    bool &ABPSIS,
                                                    bool &TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q4_INTERRUPT_CONTROL_STATUS;

        RXOIE = curr & (1u << 24u);
        RXOVFIS = curr & (1u << 16u);
        ABPSIE = curr & (1u << 9u);
        TXUIE = curr & (1u << 8u);
        ABPSIS = curr & (1u << 1u);
        TXUNFIS = curr & (1u << 0u);
    }

    /**
     * Set all of MTL_Q4_INTERRUPT_CONTROL_STATUS's bit fields.
     *
     * (read-write) Queue 4 Interrupt Control Status
     */
    inline void set_MTL_Q4_INTERRUPT_CONTROL_STATUS(bool RXOIE, bool RXOVFIS,
                                                    bool ABPSIE, bool TXUIE,
                                                    bool ABPSIS,
                                                    bool TXUNFIS) volatile
    {
        uint32_t curr = MTL_Q4_INTERRUPT_CONTROL_STATUS;

        curr &= ~(0b1u << 24u);
        curr |= (RXOIE & 0b1u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (RXOVFIS & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (ABPSIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (TXUIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (ABPSIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXUNFIS & 0b1u) << 0u;

        MTL_Q4_INTERRUPT_CONTROL_STATUS = curr;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline uint8_t get_MTL_RXQ4_OPERATION_MODE_RQS() volatile
    {
        return (MTL_RXQ4_OPERATION_MODE >> 20u) & 0b11111u;
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's RQS field.
     *
     * Receive Queue Size This field indicates the size of the allocated
     * Receive queues in blocks of 256 bytes.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_RQS(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ4_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        MTL_RXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline uint8_t get_MTL_RXQ4_OPERATION_MODE_RFD() volatile
    {
        return (MTL_RXQ4_OPERATION_MODE >> 14u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's RFD field.
     *
     * Threshold for Deactivating Flow Control (in half-duplex and full-duplex
     * modes) These bits control the threshold (fill-level of Rx queue) at
     * which the flow control is de-asserted after activation: - 0: Full minus
     * 1 KB, that is, FULL 1 KB - 1: Full minus 1.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_RFD(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ4_OPERATION_MODE;

        curr &= ~(0b1111u << 14u);
        curr |= (value & 0b1111u) << 14u;

        MTL_RXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline uint8_t get_MTL_RXQ4_OPERATION_MODE_RFA() volatile
    {
        return (MTL_RXQ4_OPERATION_MODE >> 8u) & 0b1111u;
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's RFA field.
     *
     * Threshold for Activating Flow Control (in half-duplex and full-duplex
     * These bits control the threshold (fill-level of Rx queue) at which the
     * flow control is activated: For more information on encoding for this
     * field, see RFD.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_RFA(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ4_OPERATION_MODE;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        MTL_RXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline bool get_MTL_RXQ4_OPERATION_MODE_EHFC() volatile
    {
        return MTL_RXQ4_OPERATION_MODE & (1u << 7u);
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ4_OPERATION_MODE |= 1u << 7u;
    }

    /**
     * Clear MTL_RXQ4_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void clear_MTL_RXQ4_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ4_OPERATION_MODE &= ~(1u << 7u);
    }

    /**
     * Toggle MTL_RXQ4_OPERATION_MODE's EHFC bit.
     *
     * Enable Hardware Flow Control When this bit is set, the flow control
     * signal operation, based on the fill-level of Rx queue, is enabled.
     */
    inline void toggle_MTL_RXQ4_OPERATION_MODE_EHFC() volatile
    {
        MTL_RXQ4_OPERATION_MODE ^= 1u << 7u;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline bool get_MTL_RXQ4_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        return MTL_RXQ4_OPERATION_MODE & (1u << 6u);
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ4_OPERATION_MODE |= 1u << 6u;
    }

    /**
     * Clear MTL_RXQ4_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void clear_MTL_RXQ4_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ4_OPERATION_MODE &= ~(1u << 6u);
    }

    /**
     * Toggle MTL_RXQ4_OPERATION_MODE's DIS_TCP_EF bit.
     *
     * Disable Dropping of TCP/IP Checksum Error Packets When this bit is set,
     * the MAC does not drop the packets which only have the errors detected by
     * the Receive Checksum Offload engine.
     */
    inline void toggle_MTL_RXQ4_OPERATION_MODE_DIS_TCP_EF() volatile
    {
        MTL_RXQ4_OPERATION_MODE ^= 1u << 6u;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline bool get_MTL_RXQ4_OPERATION_MODE_RSF() volatile
    {
        return MTL_RXQ4_OPERATION_MODE & (1u << 5u);
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ4_OPERATION_MODE |= 1u << 5u;
    }

    /**
     * Clear MTL_RXQ4_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void clear_MTL_RXQ4_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ4_OPERATION_MODE &= ~(1u << 5u);
    }

    /**
     * Toggle MTL_RXQ4_OPERATION_MODE's RSF bit.
     *
     * Receive Queue Store and Forward When this bit is set, the DWC_ether_qos
     * reads a packet from the Rx queue only after the complete packet has been
     * written to it, ignoring the RTC field of this register.
     */
    inline void toggle_MTL_RXQ4_OPERATION_MODE_RSF() volatile
    {
        MTL_RXQ4_OPERATION_MODE ^= 1u << 5u;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline bool get_MTL_RXQ4_OPERATION_MODE_FEP() volatile
    {
        return MTL_RXQ4_OPERATION_MODE & (1u << 4u);
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ4_OPERATION_MODE |= 1u << 4u;
    }

    /**
     * Clear MTL_RXQ4_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void clear_MTL_RXQ4_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ4_OPERATION_MODE &= ~(1u << 4u);
    }

    /**
     * Toggle MTL_RXQ4_OPERATION_MODE's FEP bit.
     *
     * Forward Error Packets When this bit is reset, the Rx queue drops packets
     * with error status (CRC error, GMII_ER, watchdog timeout, or overflow).
     */
    inline void toggle_MTL_RXQ4_OPERATION_MODE_FEP() volatile
    {
        MTL_RXQ4_OPERATION_MODE ^= 1u << 4u;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline bool get_MTL_RXQ4_OPERATION_MODE_FUP() volatile
    {
        return MTL_RXQ4_OPERATION_MODE & (1u << 3u);
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ4_OPERATION_MODE |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ4_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void clear_MTL_RXQ4_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ4_OPERATION_MODE &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ4_OPERATION_MODE's FUP bit.
     *
     * Forward Undersized Good Packets When this bit is set, the Rx queue
     * forwards the undersized good packets (packets with no error and length
     * less than 64 bytes), including pad-bytes and CRC.
     */
    inline void toggle_MTL_RXQ4_OPERATION_MODE_FUP() volatile
    {
        MTL_RXQ4_OPERATION_MODE ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ4_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC
    get_MTL_RXQ4_OPERATION_MODE_RTC() volatile
    {
        return ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC(
            (MTL_RXQ4_OPERATION_MODE >> 0u) & 0b11u);
    }

    /**
     * Set MTL_RXQ4_OPERATION_MODE's RTC field.
     *
     * Receive Queue Threshold Control These bits control the threshold level
     * of the MTL Rx queue (in bytes): The received packet is transferred to
     * the application or DMA when the packet size within the MTL Rx queue is
     * larger than the threshold.
     */
    inline void set_MTL_RXQ4_OPERATION_MODE_RTC(
        ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC value) volatile
    {
        uint32_t curr = MTL_RXQ4_OPERATION_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        MTL_RXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get all of MTL_RXQ4_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 4 Receive Operation Mode
     */
    inline void get_MTL_RXQ4_OPERATION_MODE(
        uint8_t &RQS, uint8_t &RFD, uint8_t &RFA, bool &EHFC, bool &DIS_TCP_EF,
        bool &RSF, bool &FEP, bool &FUP,
        ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC &RTC) volatile
    {
        uint32_t curr = MTL_RXQ4_OPERATION_MODE;

        RQS = (curr >> 20u) & 0b11111u;
        RFD = (curr >> 14u) & 0b1111u;
        RFA = (curr >> 8u) & 0b1111u;
        EHFC = curr & (1u << 7u);
        DIS_TCP_EF = curr & (1u << 6u);
        RSF = curr & (1u << 5u);
        FEP = curr & (1u << 4u);
        FUP = curr & (1u << 3u);
        RTC = ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of MTL_RXQ4_OPERATION_MODE's bit fields.
     *
     * (read-write) Queue 4 Receive Operation Mode
     */
    inline void set_MTL_RXQ4_OPERATION_MODE(
        uint8_t RQS, uint8_t RFD, uint8_t RFA, bool EHFC, bool DIS_TCP_EF,
        bool RSF, bool FEP, bool FUP,
        ENET_QOS_MTL_RXQ4_OPERATION_MODE_RTC RTC) volatile
    {
        uint32_t curr = MTL_RXQ4_OPERATION_MODE;

        curr &= ~(0b11111u << 20u);
        curr |= (RQS & 0b11111u) << 20u;
        curr &= ~(0b1111u << 14u);
        curr |= (RFD & 0b1111u) << 14u;
        curr &= ~(0b1111u << 8u);
        curr |= (RFA & 0b1111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (EHFC & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DIS_TCP_EF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RSF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (FEP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (FUP & 0b1u) << 3u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(RTC) & 0b11u) << 0u;

        MTL_RXQ4_OPERATION_MODE = curr;
    }

    /**
     * Get MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT's MISCNTOVF bit.
     *
     * Missed Packet Counter Overflow Bit When set, this bit indicates that the
     * Rx Queue Missed Packet Counter crossed the maximum limit.
     */
    inline bool get_MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT_MISCNTOVF() volatile
    {
        return MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT & (1u << 27u);
    }

    /**
     * Get MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT's MISPKTCNT field.
     *
     * Missed Packet Counter This field indicates the number of packets missed
     * by the DWC_ether_qos because the application asserted ari_pkt_flush_i[]
     * for this queue.
     */
    inline uint16_t
    get_MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT_MISPKTCNT() volatile
    {
        return (MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT >> 16u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT's OVFCNTOVF bit.
     *
     * Overflow Counter Overflow Bit When set, this bit indicates that the Rx
     * Queue Overflow Packet Counter field crossed the maximum limit.
     */
    inline bool get_MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT_OVFCNTOVF() volatile
    {
        return MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT & (1u << 11u);
    }

    /**
     * Get MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT's OVFPKTCNT field.
     *
     * Overflow Packet Counter This field indicates the number of packets
     * discarded by the DWC_ether_qos because of Receive queue overflow.
     */
    inline uint16_t
    get_MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT_OVFPKTCNT() volatile
    {
        return (MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT's bit fields.
     *
     * (read-write) Queue 4 Missed Packet and Overflow Counter
     */
    inline void get_MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT(
        bool &MISCNTOVF, uint16_t &MISPKTCNT, bool &OVFCNTOVF,
        uint16_t &OVFPKTCNT) volatile
    {
        uint32_t curr = MTL_RXQ4_MISSED_PACKET_OVERFLOW_CNT;

        MISCNTOVF = curr & (1u << 27u);
        MISPKTCNT = (curr >> 16u) & 0b11111111111u;
        OVFCNTOVF = curr & (1u << 11u);
        OVFPKTCNT = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get MTL_RXQ4_DEBUG's PRXQ field.
     *
     * Number of Packets in Receive Queue This field indicates the current
     * number of packets in the Rx Queue.
     */
    inline uint16_t get_MTL_RXQ4_DEBUG_PRXQ() volatile
    {
        return (MTL_RXQ4_DEBUG >> 16u) & 0b11111111111111u;
    }

    /**
     * Get MTL_RXQ4_DEBUG's RXQSTS field.
     *
     * MTL Rx Queue Fill-Level Status This field gives the status of the
     * fill-level of the Rx Queue:
     */
    inline ENET_QOS_MTL_RXQ4_DEBUG_RXQSTS get_MTL_RXQ4_DEBUG_RXQSTS() volatile
    {
        return ENET_QOS_MTL_RXQ4_DEBUG_RXQSTS((MTL_RXQ4_DEBUG >> 4u) & 0b11u);
    }

    /**
     * Get MTL_RXQ4_DEBUG's RRCSTS field.
     *
     * MTL Rx Queue Read Controller State This field gives the state of the Rx
     * queue Read controller:
     */
    inline ENET_QOS_MTL_RXQ4_DEBUG_RRCSTS get_MTL_RXQ4_DEBUG_RRCSTS() volatile
    {
        return ENET_QOS_MTL_RXQ4_DEBUG_RRCSTS((MTL_RXQ4_DEBUG >> 1u) & 0b11u);
    }

    /**
     * Get MTL_RXQ4_DEBUG's RWCSTS bit.
     *
     * MTL Rx Queue Write Controller Active Status When high, this bit
     * indicates that the MTL Rx queue Write controller is active, and it is
     * transferring a received packet to the Rx Queue.
     */
    inline bool get_MTL_RXQ4_DEBUG_RWCSTS() volatile
    {
        return MTL_RXQ4_DEBUG & (1u << 0u);
    }

    /**
     * Get all of MTL_RXQ4_DEBUG's bit fields.
     *
     * (read-write) Queue 4 Receive Debug
     */
    inline void get_MTL_RXQ4_DEBUG(uint16_t &PRXQ,
                                   ENET_QOS_MTL_RXQ4_DEBUG_RXQSTS &RXQSTS,
                                   ENET_QOS_MTL_RXQ4_DEBUG_RRCSTS &RRCSTS,
                                   bool &RWCSTS) volatile
    {
        uint32_t curr = MTL_RXQ4_DEBUG;

        PRXQ = (curr >> 16u) & 0b11111111111111u;
        RXQSTS = ENET_QOS_MTL_RXQ4_DEBUG_RXQSTS((curr >> 4u) & 0b11u);
        RRCSTS = ENET_QOS_MTL_RXQ4_DEBUG_RRCSTS((curr >> 1u) & 0b11u);
        RWCSTS = curr & (1u << 0u);
    }

    /**
     * Get MTL_RXQ4_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline bool get_MTL_RXQ4_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        return MTL_RXQ4_CONTROL & (1u << 3u);
    }

    /**
     * Set MTL_RXQ4_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void set_MTL_RXQ4_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ4_CONTROL |= 1u << 3u;
    }

    /**
     * Clear MTL_RXQ4_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void clear_MTL_RXQ4_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ4_CONTROL &= ~(1u << 3u);
    }

    /**
     * Toggle MTL_RXQ4_CONTROL's RXQ_FRM_ARBIT bit.
     *
     * Receive Queue Packet Arbitration When this bit is set, the DWC_ether_qos
     * drives the packet data to the ARI interface such that the entire packet
     * data of currently-selected queue is transmitted before switching to
     * other queue.
     */
    inline void toggle_MTL_RXQ4_CONTROL_RXQ_FRM_ARBIT() volatile
    {
        MTL_RXQ4_CONTROL ^= 1u << 3u;
    }

    /**
     * Get MTL_RXQ4_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline uint8_t get_MTL_RXQ4_CONTROL_RXQ_WEGT() volatile
    {
        return (MTL_RXQ4_CONTROL >> 0u) & 0b111u;
    }

    /**
     * Set MTL_RXQ4_CONTROL's RXQ_WEGT field.
     *
     * Receive Queue Weight This field indicates the weight assigned to the Rx
     * Queue 0.
     */
    inline void set_MTL_RXQ4_CONTROL_RXQ_WEGT(uint8_t value) volatile
    {
        uint32_t curr = MTL_RXQ4_CONTROL;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        MTL_RXQ4_CONTROL = curr;
    }

    /**
     * Get all of MTL_RXQ4_CONTROL's bit fields.
     *
     * (read-write) Queue 4 Receive Control
     */
    inline void get_MTL_RXQ4_CONTROL(bool &RXQ_FRM_ARBIT,
                                     uint8_t &RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ4_CONTROL;

        RXQ_FRM_ARBIT = curr & (1u << 3u);
        RXQ_WEGT = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of MTL_RXQ4_CONTROL's bit fields.
     *
     * (read-write) Queue 4 Receive Control
     */
    inline void set_MTL_RXQ4_CONTROL(bool RXQ_FRM_ARBIT,
                                     uint8_t RXQ_WEGT) volatile
    {
        uint32_t curr = MTL_RXQ4_CONTROL;

        curr &= ~(0b1u << 3u);
        curr |= (RXQ_FRM_ARBIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (RXQ_WEGT & 0b111u) << 0u;

        MTL_RXQ4_CONTROL = curr;
    }

    /**
     * Get DMA_MODE's INTM field.
     *
     * Interrupt Mode This field defines the interrupt mode of DWC_ether_qos.
     */
    inline ENET_QOS_DMA_MODE_INTM get_DMA_MODE_INTM() volatile
    {
        return ENET_QOS_DMA_MODE_INTM((DMA_MODE >> 16u) & 0b11u);
    }

    /**
     * Set DMA_MODE's INTM field.
     *
     * Interrupt Mode This field defines the interrupt mode of DWC_ether_qos.
     */
    inline void set_DMA_MODE_INTM(ENET_QOS_DMA_MODE_INTM value) volatile
    {
        uint32_t curr = DMA_MODE;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        DMA_MODE = curr;
    }

    /**
     * Get DMA_MODE's DSPW bit.
     *
     * Descriptor Posted Write When this bit is set to 0, the descriptor writes
     * are always non-posted.
     */
    inline bool get_DMA_MODE_DSPW() volatile
    {
        return DMA_MODE & (1u << 8u);
    }

    /**
     * Set DMA_MODE's DSPW bit.
     *
     * Descriptor Posted Write When this bit is set to 0, the descriptor writes
     * are always non-posted.
     */
    inline void set_DMA_MODE_DSPW() volatile
    {
        DMA_MODE |= 1u << 8u;
    }

    /**
     * Clear DMA_MODE's DSPW bit.
     *
     * Descriptor Posted Write When this bit is set to 0, the descriptor writes
     * are always non-posted.
     */
    inline void clear_DMA_MODE_DSPW() volatile
    {
        DMA_MODE &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_MODE's DSPW bit.
     *
     * Descriptor Posted Write When this bit is set to 0, the descriptor writes
     * are always non-posted.
     */
    inline void toggle_DMA_MODE_DSPW() volatile
    {
        DMA_MODE ^= 1u << 8u;
    }

    /**
     * Get DMA_MODE's SWR bit.
     *
     * Software Reset When this bit is set, the MAC and the DMA controller
     * reset the logic and all internal registers of the DMA, MTL, and MAC.
     */
    inline bool get_DMA_MODE_SWR() volatile
    {
        return DMA_MODE & (1u << 0u);
    }

    /**
     * Set DMA_MODE's SWR bit.
     *
     * Software Reset When this bit is set, the MAC and the DMA controller
     * reset the logic and all internal registers of the DMA, MTL, and MAC.
     */
    inline void set_DMA_MODE_SWR() volatile
    {
        DMA_MODE |= 1u << 0u;
    }

    /**
     * Clear DMA_MODE's SWR bit.
     *
     * Software Reset When this bit is set, the MAC and the DMA controller
     * reset the logic and all internal registers of the DMA, MTL, and MAC.
     */
    inline void clear_DMA_MODE_SWR() volatile
    {
        DMA_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_MODE's SWR bit.
     *
     * Software Reset When this bit is set, the MAC and the DMA controller
     * reset the logic and all internal registers of the DMA, MTL, and MAC.
     */
    inline void toggle_DMA_MODE_SWR() volatile
    {
        DMA_MODE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_MODE's bit fields.
     *
     * (read-write) DMA Bus Mode
     */
    inline void get_DMA_MODE(ENET_QOS_DMA_MODE_INTM &INTM, bool &DSPW,
                             bool &SWR) volatile
    {
        uint32_t curr = DMA_MODE;

        INTM = ENET_QOS_DMA_MODE_INTM((curr >> 16u) & 0b11u);
        DSPW = curr & (1u << 8u);
        SWR = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_MODE's bit fields.
     *
     * (read-write) DMA Bus Mode
     */
    inline void set_DMA_MODE(ENET_QOS_DMA_MODE_INTM INTM, bool DSPW,
                             bool SWR) volatile
    {
        uint32_t curr = DMA_MODE;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(INTM) & 0b11u) << 16u;
        curr &= ~(0b1u << 8u);
        curr |= (DSPW & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (SWR & 0b1u) << 0u;

        DMA_MODE = curr;
    }

    /**
     * Get DMA_SYSBUS_MODE's EN_LPI bit.
     *
     * Enable Low Power Interface (LPI) When set to 1, this bit enables the LPI
     * mode supported by the EQOS-AXI configuration and accepts the LPI request
     * from the AXI System Clock controller.
     */
    inline bool get_DMA_SYSBUS_MODE_EN_LPI() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 31u);
    }

    /**
     * Set DMA_SYSBUS_MODE's EN_LPI bit.
     *
     * Enable Low Power Interface (LPI) When set to 1, this bit enables the LPI
     * mode supported by the EQOS-AXI configuration and accepts the LPI request
     * from the AXI System Clock controller.
     */
    inline void set_DMA_SYSBUS_MODE_EN_LPI() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 31u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's EN_LPI bit.
     *
     * Enable Low Power Interface (LPI) When set to 1, this bit enables the LPI
     * mode supported by the EQOS-AXI configuration and accepts the LPI request
     * from the AXI System Clock controller.
     */
    inline void clear_DMA_SYSBUS_MODE_EN_LPI() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 31u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's EN_LPI bit.
     *
     * Enable Low Power Interface (LPI) When set to 1, this bit enables the LPI
     * mode supported by the EQOS-AXI configuration and accepts the LPI request
     * from the AXI System Clock controller.
     */
    inline void toggle_DMA_SYSBUS_MODE_EN_LPI() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 31u;
    }

    /**
     * Get DMA_SYSBUS_MODE's LPI_XIT_PKT bit.
     *
     * Unlock on Magic Packet or Remote Wake-Up Packet When set to 1, this bit
     * enables the AXI master to come out of the LPI mode only when the magic
     * packet or remote wake-up packet is received.
     */
    inline bool get_DMA_SYSBUS_MODE_LPI_XIT_PKT() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 30u);
    }

    /**
     * Set DMA_SYSBUS_MODE's LPI_XIT_PKT bit.
     *
     * Unlock on Magic Packet or Remote Wake-Up Packet When set to 1, this bit
     * enables the AXI master to come out of the LPI mode only when the magic
     * packet or remote wake-up packet is received.
     */
    inline void set_DMA_SYSBUS_MODE_LPI_XIT_PKT() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 30u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's LPI_XIT_PKT bit.
     *
     * Unlock on Magic Packet or Remote Wake-Up Packet When set to 1, this bit
     * enables the AXI master to come out of the LPI mode only when the magic
     * packet or remote wake-up packet is received.
     */
    inline void clear_DMA_SYSBUS_MODE_LPI_XIT_PKT() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 30u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's LPI_XIT_PKT bit.
     *
     * Unlock on Magic Packet or Remote Wake-Up Packet When set to 1, this bit
     * enables the AXI master to come out of the LPI mode only when the magic
     * packet or remote wake-up packet is received.
     */
    inline void toggle_DMA_SYSBUS_MODE_LPI_XIT_PKT() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 30u;
    }

    /**
     * Get DMA_SYSBUS_MODE's WR_OSR_LMT field.
     *
     * AXI Maximum Write Outstanding Request Limit This value limits the
     * maximum outstanding request on the AXI write interface.
     */
    inline uint8_t get_DMA_SYSBUS_MODE_WR_OSR_LMT() volatile
    {
        return (DMA_SYSBUS_MODE >> 24u) & 0b1111u;
    }

    /**
     * Set DMA_SYSBUS_MODE's WR_OSR_LMT field.
     *
     * AXI Maximum Write Outstanding Request Limit This value limits the
     * maximum outstanding request on the AXI write interface.
     */
    inline void set_DMA_SYSBUS_MODE_WR_OSR_LMT(uint8_t value) volatile
    {
        uint32_t curr = DMA_SYSBUS_MODE;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        DMA_SYSBUS_MODE = curr;
    }

    /**
     * Get DMA_SYSBUS_MODE's RD_OSR_LMT field.
     *
     * AXI Maximum Read Outstanding Request Limit This value limits the maximum
     * outstanding request on the AXI read interface.
     */
    inline uint8_t get_DMA_SYSBUS_MODE_RD_OSR_LMT() volatile
    {
        return (DMA_SYSBUS_MODE >> 16u) & 0b1111u;
    }

    /**
     * Set DMA_SYSBUS_MODE's RD_OSR_LMT field.
     *
     * AXI Maximum Read Outstanding Request Limit This value limits the maximum
     * outstanding request on the AXI read interface.
     */
    inline void set_DMA_SYSBUS_MODE_RD_OSR_LMT(uint8_t value) volatile
    {
        uint32_t curr = DMA_SYSBUS_MODE;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        DMA_SYSBUS_MODE = curr;
    }

    /**
     * Get DMA_SYSBUS_MODE's ONEKBBE bit.
     *
     * 1 KB Boundary Crossing Enable for the EQOS-AXI Master When set, the
     * burst transfers performed by the EQOS-AXI master do not cross 1 KB
     * boundary.
     */
    inline bool get_DMA_SYSBUS_MODE_ONEKBBE() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 13u);
    }

    /**
     * Set DMA_SYSBUS_MODE's ONEKBBE bit.
     *
     * 1 KB Boundary Crossing Enable for the EQOS-AXI Master When set, the
     * burst transfers performed by the EQOS-AXI master do not cross 1 KB
     * boundary.
     */
    inline void set_DMA_SYSBUS_MODE_ONEKBBE() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 13u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's ONEKBBE bit.
     *
     * 1 KB Boundary Crossing Enable for the EQOS-AXI Master When set, the
     * burst transfers performed by the EQOS-AXI master do not cross 1 KB
     * boundary.
     */
    inline void clear_DMA_SYSBUS_MODE_ONEKBBE() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's ONEKBBE bit.
     *
     * 1 KB Boundary Crossing Enable for the EQOS-AXI Master When set, the
     * burst transfers performed by the EQOS-AXI master do not cross 1 KB
     * boundary.
     */
    inline void toggle_DMA_SYSBUS_MODE_ONEKBBE() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 13u;
    }

    /**
     * Get DMA_SYSBUS_MODE's AAL bit.
     *
     * Address-Aligned Beats When this bit is set to 1, the EQOS-AXI or
     * EQOS-AHB master performs address-aligned burst transfers on Read and
     * Write channels.
     */
    inline bool get_DMA_SYSBUS_MODE_AAL() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 12u);
    }

    /**
     * Set DMA_SYSBUS_MODE's AAL bit.
     *
     * Address-Aligned Beats When this bit is set to 1, the EQOS-AXI or
     * EQOS-AHB master performs address-aligned burst transfers on Read and
     * Write channels.
     */
    inline void set_DMA_SYSBUS_MODE_AAL() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 12u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's AAL bit.
     *
     * Address-Aligned Beats When this bit is set to 1, the EQOS-AXI or
     * EQOS-AHB master performs address-aligned burst transfers on Read and
     * Write channels.
     */
    inline void clear_DMA_SYSBUS_MODE_AAL() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's AAL bit.
     *
     * Address-Aligned Beats When this bit is set to 1, the EQOS-AXI or
     * EQOS-AHB master performs address-aligned burst transfers on Read and
     * Write channels.
     */
    inline void toggle_DMA_SYSBUS_MODE_AAL() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 12u;
    }

    /**
     * Get DMA_SYSBUS_MODE's AALE bit.
     *
     * Automatic AXI LPI enable When set to 1, enables the AXI master to enter
     * into LPI state when there is no activity in the DWC_ether_qos for number
     * of system clock cycles programmed in the LPIEI field of
     * DMA_AXI_LPI_ENTRY_INTERVAL register.
     */
    inline bool get_DMA_SYSBUS_MODE_AALE() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 10u);
    }

    /**
     * Set DMA_SYSBUS_MODE's AALE bit.
     *
     * Automatic AXI LPI enable When set to 1, enables the AXI master to enter
     * into LPI state when there is no activity in the DWC_ether_qos for number
     * of system clock cycles programmed in the LPIEI field of
     * DMA_AXI_LPI_ENTRY_INTERVAL register.
     */
    inline void set_DMA_SYSBUS_MODE_AALE() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 10u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's AALE bit.
     *
     * Automatic AXI LPI enable When set to 1, enables the AXI master to enter
     * into LPI state when there is no activity in the DWC_ether_qos for number
     * of system clock cycles programmed in the LPIEI field of
     * DMA_AXI_LPI_ENTRY_INTERVAL register.
     */
    inline void clear_DMA_SYSBUS_MODE_AALE() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's AALE bit.
     *
     * Automatic AXI LPI enable When set to 1, enables the AXI master to enter
     * into LPI state when there is no activity in the DWC_ether_qos for number
     * of system clock cycles programmed in the LPIEI field of
     * DMA_AXI_LPI_ENTRY_INTERVAL register.
     */
    inline void toggle_DMA_SYSBUS_MODE_AALE() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 10u;
    }

    /**
     * Get DMA_SYSBUS_MODE's BLEN16 bit.
     *
     * AXI Burst Length 16 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 16 on the AXI
     * interface.
     */
    inline bool get_DMA_SYSBUS_MODE_BLEN16() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 3u);
    }

    /**
     * Set DMA_SYSBUS_MODE's BLEN16 bit.
     *
     * AXI Burst Length 16 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 16 on the AXI
     * interface.
     */
    inline void set_DMA_SYSBUS_MODE_BLEN16() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 3u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's BLEN16 bit.
     *
     * AXI Burst Length 16 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 16 on the AXI
     * interface.
     */
    inline void clear_DMA_SYSBUS_MODE_BLEN16() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 3u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's BLEN16 bit.
     *
     * AXI Burst Length 16 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 16 on the AXI
     * interface.
     */
    inline void toggle_DMA_SYSBUS_MODE_BLEN16() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 3u;
    }

    /**
     * Get DMA_SYSBUS_MODE's BLEN8 bit.
     *
     * AXI Burst Length 8 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 8 on the AXI interface.
     */
    inline bool get_DMA_SYSBUS_MODE_BLEN8() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 2u);
    }

    /**
     * Set DMA_SYSBUS_MODE's BLEN8 bit.
     *
     * AXI Burst Length 8 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 8 on the AXI interface.
     */
    inline void set_DMA_SYSBUS_MODE_BLEN8() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 2u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's BLEN8 bit.
     *
     * AXI Burst Length 8 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 8 on the AXI interface.
     */
    inline void clear_DMA_SYSBUS_MODE_BLEN8() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's BLEN8 bit.
     *
     * AXI Burst Length 8 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 8 on the AXI interface.
     */
    inline void toggle_DMA_SYSBUS_MODE_BLEN8() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 2u;
    }

    /**
     * Get DMA_SYSBUS_MODE's BLEN4 bit.
     *
     * AXI Burst Length 4 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 4 on the AXI interface.
     */
    inline bool get_DMA_SYSBUS_MODE_BLEN4() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 1u);
    }

    /**
     * Set DMA_SYSBUS_MODE's BLEN4 bit.
     *
     * AXI Burst Length 4 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 4 on the AXI interface.
     */
    inline void set_DMA_SYSBUS_MODE_BLEN4() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 1u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's BLEN4 bit.
     *
     * AXI Burst Length 4 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 4 on the AXI interface.
     */
    inline void clear_DMA_SYSBUS_MODE_BLEN4() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's BLEN4 bit.
     *
     * AXI Burst Length 4 When this bit is set to 1 or the FB bit is set to 0,
     * the EQOS-AXI master can select a burst length of 4 on the AXI interface.
     */
    inline void toggle_DMA_SYSBUS_MODE_BLEN4() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 1u;
    }

    /**
     * Get DMA_SYSBUS_MODE's FB bit.
     *
     * Fixed Burst Length When this bit is set to 1, the EQOS-AXI master
     * initiates burst transfers of specified lengths as given below.
     */
    inline bool get_DMA_SYSBUS_MODE_FB() volatile
    {
        return DMA_SYSBUS_MODE & (1u << 0u);
    }

    /**
     * Set DMA_SYSBUS_MODE's FB bit.
     *
     * Fixed Burst Length When this bit is set to 1, the EQOS-AXI master
     * initiates burst transfers of specified lengths as given below.
     */
    inline void set_DMA_SYSBUS_MODE_FB() volatile
    {
        DMA_SYSBUS_MODE |= 1u << 0u;
    }

    /**
     * Clear DMA_SYSBUS_MODE's FB bit.
     *
     * Fixed Burst Length When this bit is set to 1, the EQOS-AXI master
     * initiates burst transfers of specified lengths as given below.
     */
    inline void clear_DMA_SYSBUS_MODE_FB() volatile
    {
        DMA_SYSBUS_MODE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_SYSBUS_MODE's FB bit.
     *
     * Fixed Burst Length When this bit is set to 1, the EQOS-AXI master
     * initiates burst transfers of specified lengths as given below.
     */
    inline void toggle_DMA_SYSBUS_MODE_FB() volatile
    {
        DMA_SYSBUS_MODE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_SYSBUS_MODE's bit fields.
     *
     * (read-write) DMA System Bus Mode
     */
    inline void get_DMA_SYSBUS_MODE(bool &EN_LPI, bool &LPI_XIT_PKT,
                                    uint8_t &WR_OSR_LMT, uint8_t &RD_OSR_LMT,
                                    bool &ONEKBBE, bool &AAL, bool &AALE,
                                    bool &BLEN16, bool &BLEN8, bool &BLEN4,
                                    bool &FB) volatile
    {
        uint32_t curr = DMA_SYSBUS_MODE;

        EN_LPI = curr & (1u << 31u);
        LPI_XIT_PKT = curr & (1u << 30u);
        WR_OSR_LMT = (curr >> 24u) & 0b1111u;
        RD_OSR_LMT = (curr >> 16u) & 0b1111u;
        ONEKBBE = curr & (1u << 13u);
        AAL = curr & (1u << 12u);
        AALE = curr & (1u << 10u);
        BLEN16 = curr & (1u << 3u);
        BLEN8 = curr & (1u << 2u);
        BLEN4 = curr & (1u << 1u);
        FB = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_SYSBUS_MODE's bit fields.
     *
     * (read-write) DMA System Bus Mode
     */
    inline void set_DMA_SYSBUS_MODE(bool EN_LPI, bool LPI_XIT_PKT,
                                    uint8_t WR_OSR_LMT, uint8_t RD_OSR_LMT,
                                    bool ONEKBBE, bool AAL, bool AALE,
                                    bool BLEN16, bool BLEN8, bool BLEN4,
                                    bool FB) volatile
    {
        uint32_t curr = DMA_SYSBUS_MODE;

        curr &= ~(0b1u << 31u);
        curr |= (EN_LPI & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (LPI_XIT_PKT & 0b1u) << 30u;
        curr &= ~(0b1111u << 24u);
        curr |= (WR_OSR_LMT & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (RD_OSR_LMT & 0b1111u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (ONEKBBE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (AAL & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (AALE & 0b1u) << 10u;
        curr &= ~(0b1u << 3u);
        curr |= (BLEN16 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BLEN8 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (BLEN4 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FB & 0b1u) << 0u;

        DMA_SYSBUS_MODE = curr;
    }

    /**
     * Get DMA_INTERRUPT_STATUS's MACIS bit.
     *
     * MAC Interrupt Status This bit indicates an interrupt event in the MAC.
     */
    inline bool get_DMA_INTERRUPT_STATUS_MACIS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 17u);
    }

    /**
     * Get DMA_INTERRUPT_STATUS's MTLIS bit.
     *
     * MTL Interrupt Status This bit indicates an interrupt event in the MTL.
     */
    inline bool get_DMA_INTERRUPT_STATUS_MTLIS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 16u);
    }

    /**
     * Get DMA_INTERRUPT_STATUS's DC4IS bit.
     *
     * DMA Channel 4 Interrupt Status This bit indicates an interrupt event in
     * DMA Channel 4.
     */
    inline bool get_DMA_INTERRUPT_STATUS_DC4IS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 4u);
    }

    /**
     * Get DMA_INTERRUPT_STATUS's DC3IS bit.
     *
     * DMA Channel 3 Interrupt Status This bit indicates an interrupt event in
     * DMA Channel 3.
     */
    inline bool get_DMA_INTERRUPT_STATUS_DC3IS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 3u);
    }

    /**
     * Get DMA_INTERRUPT_STATUS's DC2IS bit.
     *
     * DMA Channel 2 Interrupt Status This bit indicates an interrupt event in
     * DMA Channel 2.
     */
    inline bool get_DMA_INTERRUPT_STATUS_DC2IS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 2u);
    }

    /**
     * Get DMA_INTERRUPT_STATUS's DC1IS bit.
     *
     * DMA Channel 1 Interrupt Status This bit indicates an interrupt event in
     * DMA Channel 1.
     */
    inline bool get_DMA_INTERRUPT_STATUS_DC1IS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 1u);
    }

    /**
     * Get DMA_INTERRUPT_STATUS's DC0IS bit.
     *
     * DMA Channel 0 Interrupt Status This bit indicates an interrupt event in
     * DMA Channel 0.
     */
    inline bool get_DMA_INTERRUPT_STATUS_DC0IS() volatile
    {
        return DMA_INTERRUPT_STATUS & (1u << 0u);
    }

    /**
     * Get all of DMA_INTERRUPT_STATUS's bit fields.
     *
     * (read-write) DMA Interrupt Status
     */
    inline void get_DMA_INTERRUPT_STATUS(bool &MACIS, bool &MTLIS, bool &DC4IS,
                                         bool &DC3IS, bool &DC2IS, bool &DC1IS,
                                         bool &DC0IS) volatile
    {
        uint32_t curr = DMA_INTERRUPT_STATUS;

        MACIS = curr & (1u << 17u);
        MTLIS = curr & (1u << 16u);
        DC4IS = curr & (1u << 4u);
        DC3IS = curr & (1u << 3u);
        DC2IS = curr & (1u << 2u);
        DC1IS = curr & (1u << 1u);
        DC0IS = curr & (1u << 0u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's TPS2 field.
     *
     * DMA Channel 2 Transmit Process State This field indicates the Tx DMA FSM
     * state for Channel 2.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS0_TPS2
    get_DMA_DEBUG_STATUS0_TPS2() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS0_TPS2((DMA_DEBUG_STATUS0 >> 28u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's RPS2 field.
     *
     * DMA Channel 2 Receive Process State This field indicates the Rx DMA FSM
     * state for Channel 2.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS0_RPS2
    get_DMA_DEBUG_STATUS0_RPS2() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS0_RPS2((DMA_DEBUG_STATUS0 >> 24u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's TPS1 field.
     *
     * DMA Channel 1 Transmit Process State This field indicates the Tx DMA FSM
     * state for Channel 1.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS0_TPS1
    get_DMA_DEBUG_STATUS0_TPS1() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS0_TPS1((DMA_DEBUG_STATUS0 >> 20u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's RPS1 field.
     *
     * DMA Channel 1 Receive Process State This field indicates the Rx DMA FSM
     * state for Channel 1.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS0_RPS1
    get_DMA_DEBUG_STATUS0_RPS1() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS0_RPS1((DMA_DEBUG_STATUS0 >> 16u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's TPS0 field.
     *
     * DMA Channel 0 Transmit Process State This field indicates the Tx DMA FSM
     * state for Channel 0.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS0_TPS0
    get_DMA_DEBUG_STATUS0_TPS0() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS0_TPS0((DMA_DEBUG_STATUS0 >> 12u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's RPS0 field.
     *
     * DMA Channel 0 Receive Process State This field indicates the Rx DMA FSM
     * state for Channel 0.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS0_RPS0
    get_DMA_DEBUG_STATUS0_RPS0() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS0_RPS0((DMA_DEBUG_STATUS0 >> 8u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's AXRHSTS bit.
     *
     * AXI Master Read Channel Status When high, this bit indicates that the
     * read channel of the AXI master is active, and it is transferring the
     * data.
     */
    inline bool get_DMA_DEBUG_STATUS0_AXRHSTS() volatile
    {
        return DMA_DEBUG_STATUS0 & (1u << 1u);
    }

    /**
     * Get DMA_DEBUG_STATUS0's AXWHSTS bit.
     *
     * AXI Master Write Channel When high, this bit indicates that the write
     * channel of the AXI master is active, and it is transferring data.
     */
    inline bool get_DMA_DEBUG_STATUS0_AXWHSTS() volatile
    {
        return DMA_DEBUG_STATUS0 & (1u << 0u);
    }

    /**
     * Get all of DMA_DEBUG_STATUS0's bit fields.
     *
     * (read-write) DMA Debug Status 0
     */
    inline void get_DMA_DEBUG_STATUS0(ENET_QOS_DMA_DEBUG_STATUS0_TPS2 &TPS2,
                                      ENET_QOS_DMA_DEBUG_STATUS0_RPS2 &RPS2,
                                      ENET_QOS_DMA_DEBUG_STATUS0_TPS1 &TPS1,
                                      ENET_QOS_DMA_DEBUG_STATUS0_RPS1 &RPS1,
                                      ENET_QOS_DMA_DEBUG_STATUS0_TPS0 &TPS0,
                                      ENET_QOS_DMA_DEBUG_STATUS0_RPS0 &RPS0,
                                      bool &AXRHSTS, bool &AXWHSTS) volatile
    {
        uint32_t curr = DMA_DEBUG_STATUS0;

        TPS2 = ENET_QOS_DMA_DEBUG_STATUS0_TPS2((curr >> 28u) & 0b1111u);
        RPS2 = ENET_QOS_DMA_DEBUG_STATUS0_RPS2((curr >> 24u) & 0b1111u);
        TPS1 = ENET_QOS_DMA_DEBUG_STATUS0_TPS1((curr >> 20u) & 0b1111u);
        RPS1 = ENET_QOS_DMA_DEBUG_STATUS0_RPS1((curr >> 16u) & 0b1111u);
        TPS0 = ENET_QOS_DMA_DEBUG_STATUS0_TPS0((curr >> 12u) & 0b1111u);
        RPS0 = ENET_QOS_DMA_DEBUG_STATUS0_RPS0((curr >> 8u) & 0b1111u);
        AXRHSTS = curr & (1u << 1u);
        AXWHSTS = curr & (1u << 0u);
    }

    /**
     * Get DMA_DEBUG_STATUS1's TPS4 field.
     *
     * DMA Channel 4 Transmit Process State This field indicates the Tx DMA FSM
     * state for Channel 4.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS1_TPS4
    get_DMA_DEBUG_STATUS1_TPS4() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS1_TPS4((DMA_DEBUG_STATUS1 >> 12u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS1's RPS4 field.
     *
     * DMA Channel 4 Receive Process State This field indicates the Rx DMA FSM
     * state for Channel 4.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS1_RPS4
    get_DMA_DEBUG_STATUS1_RPS4() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS1_RPS4((DMA_DEBUG_STATUS1 >> 8u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS1's TPS3 field.
     *
     * DMA Channel 3 Transmit Process State This field indicates the Tx DMA FSM
     * state for Channel 3.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS1_TPS3
    get_DMA_DEBUG_STATUS1_TPS3() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS1_TPS3((DMA_DEBUG_STATUS1 >> 4u) &
                                               0b1111u);
    }

    /**
     * Get DMA_DEBUG_STATUS1's RPS3 field.
     *
     * DMA Channel 3 Receive Process State This field indicates the Rx DMA FSM
     * state for Channel 3.
     */
    inline ENET_QOS_DMA_DEBUG_STATUS1_RPS3
    get_DMA_DEBUG_STATUS1_RPS3() volatile
    {
        return ENET_QOS_DMA_DEBUG_STATUS1_RPS3((DMA_DEBUG_STATUS1 >> 0u) &
                                               0b1111u);
    }

    /**
     * Get all of DMA_DEBUG_STATUS1's bit fields.
     *
     * (read-write) DMA Debug Status 1
     */
    inline void get_DMA_DEBUG_STATUS1(
        ENET_QOS_DMA_DEBUG_STATUS1_TPS4 &TPS4,
        ENET_QOS_DMA_DEBUG_STATUS1_RPS4 &RPS4,
        ENET_QOS_DMA_DEBUG_STATUS1_TPS3 &TPS3,
        ENET_QOS_DMA_DEBUG_STATUS1_RPS3 &RPS3) volatile
    {
        uint32_t curr = DMA_DEBUG_STATUS1;

        TPS4 = ENET_QOS_DMA_DEBUG_STATUS1_TPS4((curr >> 12u) & 0b1111u);
        RPS4 = ENET_QOS_DMA_DEBUG_STATUS1_RPS4((curr >> 8u) & 0b1111u);
        TPS3 = ENET_QOS_DMA_DEBUG_STATUS1_TPS3((curr >> 4u) & 0b1111u);
        RPS3 = ENET_QOS_DMA_DEBUG_STATUS1_RPS3((curr >> 0u) & 0b1111u);
    }

    /**
     * Get DMA_AXI_LPI_ENTRY_INTERVAL's LPIEI field.
     *
     * LPI Entry Interval Contains the number of system clock cycles,
     * multiplied by 64, to wait for an activity in the DWC_ether_qos to enter
     * into the AXI low power state 0 indicates 64 clock cycles
     */
    inline uint8_t get_DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI() volatile
    {
        return (DMA_AXI_LPI_ENTRY_INTERVAL >> 0u) & 0b1111u;
    }

    /**
     * Set DMA_AXI_LPI_ENTRY_INTERVAL's LPIEI field.
     *
     * LPI Entry Interval Contains the number of system clock cycles,
     * multiplied by 64, to wait for an activity in the DWC_ether_qos to enter
     * into the AXI low power state 0 indicates 64 clock cycles
     */
    inline void set_DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI(uint8_t value) volatile
    {
        uint32_t curr = DMA_AXI_LPI_ENTRY_INTERVAL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        DMA_AXI_LPI_ENTRY_INTERVAL = curr;
    }

    /**
     * Get DMA_TBS_CTRL's FTOS field.
     *
     * Fetch Time Offset The value in units of 256 nanoseconds, that has to be
     * deducted from the Launch time to compute the Fetch Time.
     */
    inline uint32_t get_DMA_TBS_CTRL_FTOS() volatile
    {
        return (DMA_TBS_CTRL >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set DMA_TBS_CTRL's FTOS field.
     *
     * Fetch Time Offset The value in units of 256 nanoseconds, that has to be
     * deducted from the Launch time to compute the Fetch Time.
     */
    inline void set_DMA_TBS_CTRL_FTOS(uint32_t value) volatile
    {
        uint32_t curr = DMA_TBS_CTRL;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        DMA_TBS_CTRL = curr;
    }

    /**
     * Get DMA_TBS_CTRL's FGOS field.
     *
     * Fetch GSN Offset The number GSN slots that must be deducted from the
     * Launch GSN to compute the Fetch GSN.
     */
    inline uint8_t get_DMA_TBS_CTRL_FGOS() volatile
    {
        return (DMA_TBS_CTRL >> 4u) & 0b111u;
    }

    /**
     * Set DMA_TBS_CTRL's FGOS field.
     *
     * Fetch GSN Offset The number GSN slots that must be deducted from the
     * Launch GSN to compute the Fetch GSN.
     */
    inline void set_DMA_TBS_CTRL_FGOS(uint8_t value) volatile
    {
        uint32_t curr = DMA_TBS_CTRL;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        DMA_TBS_CTRL = curr;
    }

    /**
     * Get DMA_TBS_CTRL's FTOV bit.
     *
     * Fetch Time Offset Valid When set indicates the FTOS field is valid.
     */
    inline bool get_DMA_TBS_CTRL_FTOV() volatile
    {
        return DMA_TBS_CTRL & (1u << 0u);
    }

    /**
     * Set DMA_TBS_CTRL's FTOV bit.
     *
     * Fetch Time Offset Valid When set indicates the FTOS field is valid.
     */
    inline void set_DMA_TBS_CTRL_FTOV() volatile
    {
        DMA_TBS_CTRL |= 1u << 0u;
    }

    /**
     * Clear DMA_TBS_CTRL's FTOV bit.
     *
     * Fetch Time Offset Valid When set indicates the FTOS field is valid.
     */
    inline void clear_DMA_TBS_CTRL_FTOV() volatile
    {
        DMA_TBS_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_TBS_CTRL's FTOV bit.
     *
     * Fetch Time Offset Valid When set indicates the FTOS field is valid.
     */
    inline void toggle_DMA_TBS_CTRL_FTOV() volatile
    {
        DMA_TBS_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_TBS_CTRL's bit fields.
     *
     * (read-write) TBS Control
     */
    inline void get_DMA_TBS_CTRL(uint32_t &FTOS, uint8_t &FGOS,
                                 bool &FTOV) volatile
    {
        uint32_t curr = DMA_TBS_CTRL;

        FTOS = (curr >> 8u) & 0b111111111111111111111111u;
        FGOS = (curr >> 4u) & 0b111u;
        FTOV = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_TBS_CTRL's bit fields.
     *
     * (read-write) TBS Control
     */
    inline void set_DMA_TBS_CTRL(uint32_t FTOS, uint8_t FGOS,
                                 bool FTOV) volatile
    {
        uint32_t curr = DMA_TBS_CTRL;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (FTOS & 0b111111111111111111111111u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (FGOS & 0b111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (FTOV & 0b1u) << 0u;

        DMA_TBS_CTRL = curr;
    }

    /**
     * Get DMA_CH0_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline uint8_t get_DMA_CH0_CONTROL_DSL() volatile
    {
        return (DMA_CH0_CONTROL >> 18u) & 0b111u;
    }

    /**
     * Set DMA_CH0_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline void set_DMA_CH0_CONTROL_DSL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH0_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DMA_CH0_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH0_TX_CONTROL and Bits[21:16] in DMA_CH0_RX_CONTROL is
     * multiplied by eight times.
     */
    inline bool get_DMA_CH0_CONTROL_PBLx8() volatile
    {
        return DMA_CH0_CONTROL & (1u << 16u);
    }

    /**
     * Set DMA_CH0_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH0_TX_CONTROL and Bits[21:16] in DMA_CH0_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void set_DMA_CH0_CONTROL_PBLx8() volatile
    {
        DMA_CH0_CONTROL |= 1u << 16u;
    }

    /**
     * Clear DMA_CH0_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH0_TX_CONTROL and Bits[21:16] in DMA_CH0_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void clear_DMA_CH0_CONTROL_PBLx8() volatile
    {
        DMA_CH0_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle DMA_CH0_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH0_TX_CONTROL and Bits[21:16] in DMA_CH0_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void toggle_DMA_CH0_CONTROL_PBLx8() volatile
    {
        DMA_CH0_CONTROL ^= 1u << 16u;
    }

    /**
     * Get all of DMA_CH0_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 0 Control
     */
    inline void get_DMA_CH0_CONTROL(uint8_t &DSL, bool &PBLx8) volatile
    {
        uint32_t curr = DMA_CH0_CONTROL;

        DSL = (curr >> 18u) & 0b111u;
        PBLx8 = curr & (1u << 16u);
    }

    /**
     * Set all of DMA_CH0_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 0 Control
     */
    inline void set_DMA_CH0_CONTROL(uint8_t DSL, bool PBLx8) volatile
    {
        uint32_t curr = DMA_CH0_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (DSL & 0b111u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (PBLx8 & 0b1u) << 16u;

        DMA_CH0_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline bool get_DMA_CH0_TX_CONTROL_EDSE() volatile
    {
        return DMA_CH0_TX_CONTROL & (1u << 28u);
    }

    /**
     * Set DMA_CH0_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void set_DMA_CH0_TX_CONTROL_EDSE() volatile
    {
        DMA_CH0_TX_CONTROL |= 1u << 28u;
    }

    /**
     * Clear DMA_CH0_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void clear_DMA_CH0_TX_CONTROL_EDSE() volatile
    {
        DMA_CH0_TX_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle DMA_CH0_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void toggle_DMA_CH0_TX_CONTROL_EDSE() volatile
    {
        DMA_CH0_TX_CONTROL ^= 1u << 28u;
    }

    /**
     * Get DMA_CH0_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH0_TX_CONTROL_TxPBL() volatile
    {
        return (DMA_CH0_TX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH0_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH0_TX_CONTROL_TxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH0_TX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH0_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline bool get_DMA_CH0_TX_CONTROL_IPBL() volatile
    {
        return DMA_CH0_TX_CONTROL & (1u << 15u);
    }

    /**
     * Set DMA_CH0_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void set_DMA_CH0_TX_CONTROL_IPBL() volatile
    {
        DMA_CH0_TX_CONTROL |= 1u << 15u;
    }

    /**
     * Clear DMA_CH0_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void clear_DMA_CH0_TX_CONTROL_IPBL() volatile
    {
        DMA_CH0_TX_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH0_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void toggle_DMA_CH0_TX_CONTROL_IPBL() volatile
    {
        DMA_CH0_TX_CONTROL ^= 1u << 15u;
    }

    /**
     * Get DMA_CH0_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline bool get_DMA_CH0_TX_CONTROL_OSF() volatile
    {
        return DMA_CH0_TX_CONTROL & (1u << 4u);
    }

    /**
     * Set DMA_CH0_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void set_DMA_CH0_TX_CONTROL_OSF() volatile
    {
        DMA_CH0_TX_CONTROL |= 1u << 4u;
    }

    /**
     * Clear DMA_CH0_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void clear_DMA_CH0_TX_CONTROL_OSF() volatile
    {
        DMA_CH0_TX_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle DMA_CH0_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void toggle_DMA_CH0_TX_CONTROL_OSF() volatile
    {
        DMA_CH0_TX_CONTROL ^= 1u << 4u;
    }

    /**
     * Get DMA_CH0_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline bool get_DMA_CH0_TX_CONTROL_ST() volatile
    {
        return DMA_CH0_TX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH0_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void set_DMA_CH0_TX_CONTROL_ST() volatile
    {
        DMA_CH0_TX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH0_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void clear_DMA_CH0_TX_CONTROL_ST() volatile
    {
        DMA_CH0_TX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH0_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void toggle_DMA_CH0_TX_CONTROL_ST() volatile
    {
        DMA_CH0_TX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH0_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 0 Transmit Control
     */
    inline void get_DMA_CH0_TX_CONTROL(bool &EDSE, uint8_t &TxPBL, bool &IPBL,
                                       bool &OSF, bool &ST) volatile
    {
        uint32_t curr = DMA_CH0_TX_CONTROL;

        EDSE = curr & (1u << 28u);
        TxPBL = (curr >> 16u) & 0b111111u;
        IPBL = curr & (1u << 15u);
        OSF = curr & (1u << 4u);
        ST = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH0_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 0 Transmit Control
     */
    inline void set_DMA_CH0_TX_CONTROL(bool EDSE, uint8_t TxPBL, bool IPBL,
                                       bool OSF, bool ST) volatile
    {
        uint32_t curr = DMA_CH0_TX_CONTROL;

        curr &= ~(0b1u << 28u);
        curr |= (EDSE & 0b1u) << 28u;
        curr &= ~(0b111111u << 16u);
        curr |= (TxPBL & 0b111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IPBL & 0b1u) << 15u;
        curr &= ~(0b1u << 4u);
        curr |= (OSF & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (ST & 0b1u) << 0u;

        DMA_CH0_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline bool get_DMA_CH0_RX_CONTROL_RPF() volatile
    {
        return DMA_CH0_RX_CONTROL & (1u << 31u);
    }

    /**
     * Set DMA_CH0_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void set_DMA_CH0_RX_CONTROL_RPF() volatile
    {
        DMA_CH0_RX_CONTROL |= 1u << 31u;
    }

    /**
     * Clear DMA_CH0_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void clear_DMA_CH0_RX_CONTROL_RPF() volatile
    {
        DMA_CH0_RX_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle DMA_CH0_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void toggle_DMA_CH0_RX_CONTROL_RPF() volatile
    {
        DMA_CH0_RX_CONTROL ^= 1u << 31u;
    }

    /**
     * Get DMA_CH0_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH0_RX_CONTROL_RxPBL() volatile
    {
        return (DMA_CH0_RX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH0_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH0_RX_CONTROL_RxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH0_RX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH0_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline uint16_t get_DMA_CH0_RX_CONTROL_RBSZ_13_y() volatile
    {
        return (DMA_CH0_RX_CONTROL >> 4u) & 0b11111111111u;
    }

    /**
     * Set DMA_CH0_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline void set_DMA_CH0_RX_CONTROL_RBSZ_13_y(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH0_RX_CONTROL;

        curr &= ~(0b11111111111u << 4u);
        curr |= (value & 0b11111111111u) << 4u;

        DMA_CH0_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_RX_CONTROL's RBSZ_x_0 field.
     *
     * Receive Buffer size Low RBSZ[13:0] is split into two fields RBSZ_13_y
     * and RBSZ_x_0.
     */
    inline uint8_t get_DMA_CH0_RX_CONTROL_RBSZ_x_0() volatile
    {
        return (DMA_CH0_RX_CONTROL >> 1u) & 0b111u;
    }

    /**
     * Get DMA_CH0_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline bool get_DMA_CH0_RX_CONTROL_SR() volatile
    {
        return DMA_CH0_RX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH0_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void set_DMA_CH0_RX_CONTROL_SR() volatile
    {
        DMA_CH0_RX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH0_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void clear_DMA_CH0_RX_CONTROL_SR() volatile
    {
        DMA_CH0_RX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH0_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void toggle_DMA_CH0_RX_CONTROL_SR() volatile
    {
        DMA_CH0_RX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH0_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 0 Receive Control
     */
    inline void get_DMA_CH0_RX_CONTROL(bool &RPF, uint8_t &RxPBL,
                                       uint16_t &RBSZ_13_y, uint8_t &RBSZ_x_0,
                                       bool &SR) volatile
    {
        uint32_t curr = DMA_CH0_RX_CONTROL;

        RPF = curr & (1u << 31u);
        RxPBL = (curr >> 16u) & 0b111111u;
        RBSZ_13_y = (curr >> 4u) & 0b11111111111u;
        RBSZ_x_0 = (curr >> 1u) & 0b111u;
        SR = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH0_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 0 Receive Control
     */
    inline void set_DMA_CH0_RX_CONTROL(bool RPF, uint8_t RxPBL,
                                       uint16_t RBSZ_13_y, bool SR) volatile
    {
        uint32_t curr = DMA_CH0_RX_CONTROL;

        curr &= ~(0b1u << 31u);
        curr |= (RPF & 0b1u) << 31u;
        curr &= ~(0b111111u << 16u);
        curr |= (RxPBL & 0b111111u) << 16u;
        curr &= ~(0b11111111111u << 4u);
        curr |= (RBSZ_13_y & 0b11111111111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (SR & 0b1u) << 0u;

        DMA_CH0_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH0_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline uint32_t get_DMA_CH0_TXDESC_LIST_ADDRESS_TDESLA() volatile
    {
        return (DMA_CH0_TXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH0_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline void set_DMA_CH0_TXDESC_LIST_ADDRESS_TDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH0_TXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH0_TXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH0_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline uint32_t get_DMA_CH0_RXDESC_LIST_ADDRESS_RDESLA() volatile
    {
        return (DMA_CH0_RXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH0_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline void set_DMA_CH0_RXDESC_LIST_ADDRESS_RDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH0_RXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH0_RXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH0_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline uint32_t get_DMA_CH0_TXDESC_TAIL_POINTER_TDTP() volatile
    {
        return (DMA_CH0_TXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH0_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline void set_DMA_CH0_TXDESC_TAIL_POINTER_TDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH0_TXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH0_TXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH0_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline uint32_t get_DMA_CH0_RXDESC_TAIL_POINTER_RDTP() volatile
    {
        return (DMA_CH0_RXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH0_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline void set_DMA_CH0_RXDESC_TAIL_POINTER_RDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH0_RXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH0_RXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH0_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH0_TXDESC_RING_LENGTH_TDRL() volatile
    {
        return (DMA_CH0_TXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH0_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH0_TXDESC_RING_LENGTH_TDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH0_TXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH0_TXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH0_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH0_RXDESC_RING_LENGTH_RDRL() volatile
    {
        return (DMA_CH0_RXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH0_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH0_RXDESC_RING_LENGTH_RDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH0_RXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH0_RXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_NIE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 15u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 15u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 15u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_AIE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 14u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 14u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 14u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_CDEE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 13u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 13u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 13u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_FBEE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 12u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 12u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 12u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_ERIE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 11u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 11u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 11u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_ETIE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 10u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 10u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 10u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_RWTE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 9u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 9u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 9u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_RSE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 8u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 8u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 8u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_RBUE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 7u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 7u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 7u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_RIE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 6u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 6u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 6u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_TBUE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 2u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 2u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 2u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_TXSE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 1u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 1u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 1u;
    }

    /**
     * Get DMA_CH0_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline bool get_DMA_CH0_INTERRUPT_ENABLE_TIE() volatile
    {
        return DMA_CH0_INTERRUPT_ENABLE & (1u << 0u);
    }

    /**
     * Set DMA_CH0_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE |= 1u << 0u;
    }

    /**
     * Clear DMA_CH0_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void clear_DMA_CH0_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH0_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void toggle_DMA_CH0_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH0_INTERRUPT_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH0_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 0 Interrupt Enable
     */
    inline void get_DMA_CH0_INTERRUPT_ENABLE(bool &NIE, bool &AIE, bool &CDEE,
                                             bool &FBEE, bool &ERIE,
                                             bool &ETIE, bool &RWTE, bool &RSE,
                                             bool &RBUE, bool &RIE, bool &TBUE,
                                             bool &TXSE, bool &TIE) volatile
    {
        uint32_t curr = DMA_CH0_INTERRUPT_ENABLE;

        NIE = curr & (1u << 15u);
        AIE = curr & (1u << 14u);
        CDEE = curr & (1u << 13u);
        FBEE = curr & (1u << 12u);
        ERIE = curr & (1u << 11u);
        ETIE = curr & (1u << 10u);
        RWTE = curr & (1u << 9u);
        RSE = curr & (1u << 8u);
        RBUE = curr & (1u << 7u);
        RIE = curr & (1u << 6u);
        TBUE = curr & (1u << 2u);
        TXSE = curr & (1u << 1u);
        TIE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH0_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 0 Interrupt Enable
     */
    inline void set_DMA_CH0_INTERRUPT_ENABLE(bool NIE, bool AIE, bool CDEE,
                                             bool FBEE, bool ERIE, bool ETIE,
                                             bool RWTE, bool RSE, bool RBUE,
                                             bool RIE, bool TBUE, bool TXSE,
                                             bool TIE) volatile
    {
        uint32_t curr = DMA_CH0_INTERRUPT_ENABLE;

        curr &= ~(0b1u << 15u);
        curr |= (NIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDEE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBEE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWTE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBUE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RIE & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TIE & 0b1u) << 0u;

        DMA_CH0_INTERRUPT_ENABLE = curr;
    }

    /**
     * Get DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline uint8_t get_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER_RWTU() volatile
    {
        return (DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER >> 16u) & 0b11u;
    }

    /**
     * Set DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline void set_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER_RWTU(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline uint8_t get_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER_RWT() volatile
    {
        return (DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER >> 0u) & 0b11111111u;
    }

    /**
     * Set DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline void set_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER_RWT(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get all of DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 0 Receive Interrupt Watchdog Timer
     */
    inline void get_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t &RWTU,
                                                        uint8_t &RWT) volatile
    {
        uint32_t curr = DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER;

        RWTU = (curr >> 16u) & 0b11u;
        RWT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 0 Receive Interrupt Watchdog Timer
     */
    inline void set_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t RWTU,
                                                        uint8_t RWT) volatile
    {
        uint32_t curr = DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (RWTU & 0b11u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RWT & 0b11111111u) << 0u;

        DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's RSN field.
     *
     * Reference Slot Number This field gives the current value of the
     * reference slot number in the DMA.
     */
    inline uint8_t get_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_RSN() volatile
    {
        return (DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline uint16_t get_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_SIV() volatile
    {
        return (DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS >> 4u) & 0b111111111111u;
    }

    /**
     * Set DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline void set_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_SIV(
        uint16_t value) volatile
    {
        uint32_t curr = DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (value & 0b111111111111u) << 4u;

        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline bool get_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        return DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void set_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void clear_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void toggle_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline bool get_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        return DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void set_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void clear_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void toggle_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 0 Slot Function Control and Status
     */
    inline void get_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS(uint8_t &RSN,
                                                         uint16_t &SIV,
                                                         bool &ASC,
                                                         bool &ESC) volatile
    {
        uint32_t curr = DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS;

        RSN = (curr >> 16u) & 0b1111u;
        SIV = (curr >> 4u) & 0b111111111111u;
        ASC = curr & (1u << 1u);
        ESC = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 0 Slot Function Control and Status
     */
    inline void set_DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS(uint16_t SIV,
                                                         bool ASC,
                                                         bool ESC) volatile
    {
        uint32_t curr = DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (SIV & 0b111111111111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (ASC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ESC & 0b1u) << 0u;

        DMA_CH0_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH0_CURRENT_APP_TXDESC's CURTDESAPTR field.
     *
     * Application Transmit Descriptor Address Pointer The DMA updates this
     * pointer during Tx operation.
     */
    inline uint32_t get_DMA_CH0_CURRENT_APP_TXDESC_CURTDESAPTR() volatile
    {
        return (DMA_CH0_CURRENT_APP_TXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH0_CURRENT_APP_RXDESC's CURRDESAPTR field.
     *
     * Application Receive Descriptor Address Pointer The DMA updates this
     * pointer during Rx operation.
     */
    inline uint32_t get_DMA_CH0_CURRENT_APP_RXDESC_CURRDESAPTR() volatile
    {
        return (DMA_CH0_CURRENT_APP_RXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH0_CURRENT_APP_TXBUFFER's CURTBUFAPTR field.
     *
     * Application Transmit Buffer Address Pointer The DMA updates this pointer
     * during Tx operation.
     */
    inline uint32_t get_DMA_CH0_CURRENT_APP_TXBUFFER_CURTBUFAPTR() volatile
    {
        return (DMA_CH0_CURRENT_APP_TXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH0_CURRENT_APP_RXBUFFER's CURRBUFAPTR field.
     *
     * Application Receive Buffer Address Pointer The DMA updates this pointer
     * during Rx operation.
     */
    inline uint32_t get_DMA_CH0_CURRENT_APP_RXBUFFER_CURRBUFAPTR() volatile
    {
        return (DMA_CH0_CURRENT_APP_RXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH0_STATUS's REB field.
     *
     * Rx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH0_STATUS_REB() volatile
    {
        return (DMA_CH0_STATUS >> 19u) & 0b111u;
    }

    /**
     * Get DMA_CH0_STATUS's TEB field.
     *
     * Tx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH0_STATUS_TEB() volatile
    {
        return (DMA_CH0_STATUS >> 16u) & 0b111u;
    }

    /**
     * Get DMA_CH0_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH0_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline bool get_DMA_CH0_STATUS_NIS() volatile
    {
        return DMA_CH0_STATUS & (1u << 15u);
    }

    /**
     * Set DMA_CH0_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH0_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void set_DMA_CH0_STATUS_NIS() volatile
    {
        DMA_CH0_STATUS |= 1u << 15u;
    }

    /**
     * Clear DMA_CH0_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH0_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void clear_DMA_CH0_STATUS_NIS() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH0_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH0_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void toggle_DMA_CH0_STATUS_NIS() volatile
    {
        DMA_CH0_STATUS ^= 1u << 15u;
    }

    /**
     * Get DMA_CH0_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline bool get_DMA_CH0_STATUS_AIS() volatile
    {
        return DMA_CH0_STATUS & (1u << 14u);
    }

    /**
     * Set DMA_CH0_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void set_DMA_CH0_STATUS_AIS() volatile
    {
        DMA_CH0_STATUS |= 1u << 14u;
    }

    /**
     * Clear DMA_CH0_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void clear_DMA_CH0_STATUS_AIS() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH0_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void toggle_DMA_CH0_STATUS_AIS() volatile
    {
        DMA_CH0_STATUS ^= 1u << 14u;
    }

    /**
     * Get DMA_CH0_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow (intermediate descriptor) or all ones descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline bool get_DMA_CH0_STATUS_CDE() volatile
    {
        return DMA_CH0_STATUS & (1u << 13u);
    }

    /**
     * Set DMA_CH0_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow (intermediate descriptor) or all ones descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void set_DMA_CH0_STATUS_CDE() volatile
    {
        DMA_CH0_STATUS |= 1u << 13u;
    }

    /**
     * Clear DMA_CH0_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow (intermediate descriptor) or all ones descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void clear_DMA_CH0_STATUS_CDE() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH0_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow (intermediate descriptor) or all ones descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void toggle_DMA_CH0_STATUS_CDE() volatile
    {
        DMA_CH0_STATUS ^= 1u << 13u;
    }

    /**
     * Get DMA_CH0_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline bool get_DMA_CH0_STATUS_FBE() volatile
    {
        return DMA_CH0_STATUS & (1u << 12u);
    }

    /**
     * Set DMA_CH0_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void set_DMA_CH0_STATUS_FBE() volatile
    {
        DMA_CH0_STATUS |= 1u << 12u;
    }

    /**
     * Clear DMA_CH0_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void clear_DMA_CH0_STATUS_FBE() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH0_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void toggle_DMA_CH0_STATUS_FBE() volatile
    {
        DMA_CH0_STATUS ^= 1u << 12u;
    }

    /**
     * Get DMA_CH0_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline bool get_DMA_CH0_STATUS_ERI() volatile
    {
        return DMA_CH0_STATUS & (1u << 11u);
    }

    /**
     * Set DMA_CH0_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void set_DMA_CH0_STATUS_ERI() volatile
    {
        DMA_CH0_STATUS |= 1u << 11u;
    }

    /**
     * Clear DMA_CH0_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void clear_DMA_CH0_STATUS_ERI() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH0_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void toggle_DMA_CH0_STATUS_ERI() volatile
    {
        DMA_CH0_STATUS ^= 1u << 11u;
    }

    /**
     * Get DMA_CH0_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline bool get_DMA_CH0_STATUS_ETI() volatile
    {
        return DMA_CH0_STATUS & (1u << 10u);
    }

    /**
     * Set DMA_CH0_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void set_DMA_CH0_STATUS_ETI() volatile
    {
        DMA_CH0_STATUS |= 1u << 10u;
    }

    /**
     * Clear DMA_CH0_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void clear_DMA_CH0_STATUS_ETI() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH0_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void toggle_DMA_CH0_STATUS_ETI() volatile
    {
        DMA_CH0_STATUS ^= 1u << 10u;
    }

    /**
     * Get DMA_CH0_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline bool get_DMA_CH0_STATUS_RWT() volatile
    {
        return DMA_CH0_STATUS & (1u << 9u);
    }

    /**
     * Set DMA_CH0_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void set_DMA_CH0_STATUS_RWT() volatile
    {
        DMA_CH0_STATUS |= 1u << 9u;
    }

    /**
     * Clear DMA_CH0_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void clear_DMA_CH0_STATUS_RWT() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH0_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void toggle_DMA_CH0_STATUS_RWT() volatile
    {
        DMA_CH0_STATUS ^= 1u << 9u;
    }

    /**
     * Get DMA_CH0_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline bool get_DMA_CH0_STATUS_RPS() volatile
    {
        return DMA_CH0_STATUS & (1u << 8u);
    }

    /**
     * Set DMA_CH0_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void set_DMA_CH0_STATUS_RPS() volatile
    {
        DMA_CH0_STATUS |= 1u << 8u;
    }

    /**
     * Clear DMA_CH0_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void clear_DMA_CH0_STATUS_RPS() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH0_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void toggle_DMA_CH0_STATUS_RPS() volatile
    {
        DMA_CH0_STATUS ^= 1u << 8u;
    }

    /**
     * Get DMA_CH0_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH0_STATUS_RBU() volatile
    {
        return DMA_CH0_STATUS & (1u << 7u);
    }

    /**
     * Set DMA_CH0_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH0_STATUS_RBU() volatile
    {
        DMA_CH0_STATUS |= 1u << 7u;
    }

    /**
     * Clear DMA_CH0_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH0_STATUS_RBU() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH0_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH0_STATUS_RBU() volatile
    {
        DMA_CH0_STATUS ^= 1u << 7u;
    }

    /**
     * Get DMA_CH0_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline bool get_DMA_CH0_STATUS_RI() volatile
    {
        return DMA_CH0_STATUS & (1u << 6u);
    }

    /**
     * Set DMA_CH0_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void set_DMA_CH0_STATUS_RI() volatile
    {
        DMA_CH0_STATUS |= 1u << 6u;
    }

    /**
     * Clear DMA_CH0_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void clear_DMA_CH0_STATUS_RI() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH0_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void toggle_DMA_CH0_STATUS_RI() volatile
    {
        DMA_CH0_STATUS ^= 1u << 6u;
    }

    /**
     * Get DMA_CH0_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH0_STATUS_TBU() volatile
    {
        return DMA_CH0_STATUS & (1u << 2u);
    }

    /**
     * Set DMA_CH0_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH0_STATUS_TBU() volatile
    {
        DMA_CH0_STATUS |= 1u << 2u;
    }

    /**
     * Clear DMA_CH0_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH0_STATUS_TBU() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH0_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH0_STATUS_TBU() volatile
    {
        DMA_CH0_STATUS ^= 1u << 2u;
    }

    /**
     * Get DMA_CH0_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline bool get_DMA_CH0_STATUS_TPS() volatile
    {
        return DMA_CH0_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH0_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void set_DMA_CH0_STATUS_TPS() volatile
    {
        DMA_CH0_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH0_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void clear_DMA_CH0_STATUS_TPS() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH0_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void toggle_DMA_CH0_STATUS_TPS() volatile
    {
        DMA_CH0_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH0_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline bool get_DMA_CH0_STATUS_TI() volatile
    {
        return DMA_CH0_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH0_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void set_DMA_CH0_STATUS_TI() volatile
    {
        DMA_CH0_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH0_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void clear_DMA_CH0_STATUS_TI() volatile
    {
        DMA_CH0_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH0_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void toggle_DMA_CH0_STATUS_TI() volatile
    {
        DMA_CH0_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH0_STATUS's bit fields.
     *
     * (read-write) DMA Channel 0 Status
     */
    inline void get_DMA_CH0_STATUS(uint8_t &REB, uint8_t &TEB, bool &NIS,
                                   bool &AIS, bool &CDE, bool &FBE, bool &ERI,
                                   bool &ETI, bool &RWT, bool &RPS, bool &RBU,
                                   bool &RI, bool &TBU, bool &TPS,
                                   bool &TI) volatile
    {
        uint32_t curr = DMA_CH0_STATUS;

        REB = (curr >> 19u) & 0b111u;
        TEB = (curr >> 16u) & 0b111u;
        NIS = curr & (1u << 15u);
        AIS = curr & (1u << 14u);
        CDE = curr & (1u << 13u);
        FBE = curr & (1u << 12u);
        ERI = curr & (1u << 11u);
        ETI = curr & (1u << 10u);
        RWT = curr & (1u << 9u);
        RPS = curr & (1u << 8u);
        RBU = curr & (1u << 7u);
        RI = curr & (1u << 6u);
        TBU = curr & (1u << 2u);
        TPS = curr & (1u << 1u);
        TI = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH0_STATUS's bit fields.
     *
     * (read-write) DMA Channel 0 Status
     */
    inline void set_DMA_CH0_STATUS(bool NIS, bool AIS, bool CDE, bool FBE,
                                   bool ERI, bool ETI, bool RWT, bool RPS,
                                   bool RBU, bool RI, bool TBU, bool TPS,
                                   bool TI) volatile
    {
        uint32_t curr = DMA_CH0_STATUS;

        curr &= ~(0b1u << 15u);
        curr |= (NIS & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERI & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETI & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RPS & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBU & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RI & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TI & 0b1u) << 0u;

        DMA_CH0_STATUS = curr;
    }

    /**
     * Get DMA_CH0_MISS_FRAME_CNT's MFCO bit.
     *
     * Overflow status of the MFC Counter When this bit is set then the MFC
     * counter does not get incremented further.
     */
    inline bool get_DMA_CH0_MISS_FRAME_CNT_MFCO() volatile
    {
        return DMA_CH0_MISS_FRAME_CNT & (1u << 15u);
    }

    /**
     * Get DMA_CH0_MISS_FRAME_CNT's MFC field.
     *
     * Dropped Packet Counters This counter indicates the number of packet
     * counters that are dropped by the DMA either because of bus error or
     * because of programming RPF field in DMA_CH0_RX_CONTROL register.
     */
    inline uint16_t get_DMA_CH0_MISS_FRAME_CNT_MFC() volatile
    {
        return (DMA_CH0_MISS_FRAME_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of DMA_CH0_MISS_FRAME_CNT's bit fields.
     *
     * (read-write) Channel 0 Missed Frame Counter
     */
    inline void get_DMA_CH0_MISS_FRAME_CNT(bool &MFCO, uint16_t &MFC) volatile
    {
        uint32_t curr = DMA_CH0_MISS_FRAME_CNT;

        MFCO = curr & (1u << 15u);
        MFC = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get DMA_CH0_RXP_ACCEPT_CNT's RXPACOF bit.
     *
     * Rx Parser Accept Counter Overflow Bit When set, this bit indicates that
     * the RXPAC Counter field crossed the maximum limit.
     */
    inline bool get_DMA_CH0_RXP_ACCEPT_CNT_RXPACOF() volatile
    {
        return DMA_CH0_RXP_ACCEPT_CNT & (1u << 31u);
    }

    /**
     * Get DMA_CH0_RXP_ACCEPT_CNT's RXPAC field.
     *
     * Rx Parser Accept Counter This 31-bit counter is implemented whenever a
     * Rx Parser Accept a packet due to AF =1.
     */
    inline uint32_t get_DMA_CH0_RXP_ACCEPT_CNT_RXPAC() volatile
    {
        return (DMA_CH0_RXP_ACCEPT_CNT >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get all of DMA_CH0_RXP_ACCEPT_CNT's bit fields.
     *
     * (read-write) Channel 0 RXP Frames Accepted Counter
     */
    inline void get_DMA_CH0_RXP_ACCEPT_CNT(bool &RXPACOF,
                                           uint32_t &RXPAC) volatile
    {
        uint32_t curr = DMA_CH0_RXP_ACCEPT_CNT;

        RXPACOF = curr & (1u << 31u);
        RXPAC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH0_RX_ERI_CNT's ECNT field.
     *
     * ERI Counter When ERIC bit of RX_CONTROL register is set, this counter
     * increments for burst transfer completed by the Rx DMA from the start of
     * packet transfer.
     */
    inline uint16_t get_DMA_CH0_RX_ERI_CNT_ECNT() volatile
    {
        return (DMA_CH0_RX_ERI_CNT >> 0u) & 0b111111111111u;
    }

    /**
     * Get DMA_CH1_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline uint8_t get_DMA_CH1_CONTROL_DSL() volatile
    {
        return (DMA_CH1_CONTROL >> 18u) & 0b111u;
    }

    /**
     * Set DMA_CH1_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline void set_DMA_CH1_CONTROL_DSL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH1_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DMA_CH1_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in TX_CONTROL and Bits[21:16] in DMA_CH1_RX_CONTROL is multiplied by
     * eight times.
     */
    inline bool get_DMA_CH1_CONTROL_PBLx8() volatile
    {
        return DMA_CH1_CONTROL & (1u << 16u);
    }

    /**
     * Set DMA_CH1_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in TX_CONTROL and Bits[21:16] in DMA_CH1_RX_CONTROL is multiplied by
     * eight times.
     */
    inline void set_DMA_CH1_CONTROL_PBLx8() volatile
    {
        DMA_CH1_CONTROL |= 1u << 16u;
    }

    /**
     * Clear DMA_CH1_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in TX_CONTROL and Bits[21:16] in DMA_CH1_RX_CONTROL is multiplied by
     * eight times.
     */
    inline void clear_DMA_CH1_CONTROL_PBLx8() volatile
    {
        DMA_CH1_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle DMA_CH1_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in TX_CONTROL and Bits[21:16] in DMA_CH1_RX_CONTROL is multiplied by
     * eight times.
     */
    inline void toggle_DMA_CH1_CONTROL_PBLx8() volatile
    {
        DMA_CH1_CONTROL ^= 1u << 16u;
    }

    /**
     * Get all of DMA_CH1_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 1 Control
     */
    inline void get_DMA_CH1_CONTROL(uint8_t &DSL, bool &PBLx8) volatile
    {
        uint32_t curr = DMA_CH1_CONTROL;

        DSL = (curr >> 18u) & 0b111u;
        PBLx8 = curr & (1u << 16u);
    }

    /**
     * Set all of DMA_CH1_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 1 Control
     */
    inline void set_DMA_CH1_CONTROL(uint8_t DSL, bool PBLx8) volatile
    {
        uint32_t curr = DMA_CH1_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (DSL & 0b111u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (PBLx8 & 0b1u) << 16u;

        DMA_CH1_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline bool get_DMA_CH1_TX_CONTROL_EDSE() volatile
    {
        return DMA_CH1_TX_CONTROL & (1u << 28u);
    }

    /**
     * Set DMA_CH1_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void set_DMA_CH1_TX_CONTROL_EDSE() volatile
    {
        DMA_CH1_TX_CONTROL |= 1u << 28u;
    }

    /**
     * Clear DMA_CH1_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void clear_DMA_CH1_TX_CONTROL_EDSE() volatile
    {
        DMA_CH1_TX_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle DMA_CH1_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void toggle_DMA_CH1_TX_CONTROL_EDSE() volatile
    {
        DMA_CH1_TX_CONTROL ^= 1u << 28u;
    }

    /**
     * Get DMA_CH1_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH1_TX_CONTROL_TxPBL() volatile
    {
        return (DMA_CH1_TX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH1_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH1_TX_CONTROL_TxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH1_TX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH1_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline bool get_DMA_CH1_TX_CONTROL_IPBL() volatile
    {
        return DMA_CH1_TX_CONTROL & (1u << 15u);
    }

    /**
     * Set DMA_CH1_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void set_DMA_CH1_TX_CONTROL_IPBL() volatile
    {
        DMA_CH1_TX_CONTROL |= 1u << 15u;
    }

    /**
     * Clear DMA_CH1_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void clear_DMA_CH1_TX_CONTROL_IPBL() volatile
    {
        DMA_CH1_TX_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH1_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void toggle_DMA_CH1_TX_CONTROL_IPBL() volatile
    {
        DMA_CH1_TX_CONTROL ^= 1u << 15u;
    }

    /**
     * Get DMA_CH1_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline bool get_DMA_CH1_TX_CONTROL_OSF() volatile
    {
        return DMA_CH1_TX_CONTROL & (1u << 4u);
    }

    /**
     * Set DMA_CH1_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void set_DMA_CH1_TX_CONTROL_OSF() volatile
    {
        DMA_CH1_TX_CONTROL |= 1u << 4u;
    }

    /**
     * Clear DMA_CH1_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void clear_DMA_CH1_TX_CONTROL_OSF() volatile
    {
        DMA_CH1_TX_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle DMA_CH1_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void toggle_DMA_CH1_TX_CONTROL_OSF() volatile
    {
        DMA_CH1_TX_CONTROL ^= 1u << 4u;
    }

    /**
     * Get DMA_CH1_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline bool get_DMA_CH1_TX_CONTROL_ST() volatile
    {
        return DMA_CH1_TX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH1_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void set_DMA_CH1_TX_CONTROL_ST() volatile
    {
        DMA_CH1_TX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH1_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void clear_DMA_CH1_TX_CONTROL_ST() volatile
    {
        DMA_CH1_TX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH1_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void toggle_DMA_CH1_TX_CONTROL_ST() volatile
    {
        DMA_CH1_TX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH1_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 1 Transmit Control
     */
    inline void get_DMA_CH1_TX_CONTROL(bool &EDSE, uint8_t &TxPBL, bool &IPBL,
                                       bool &OSF, bool &ST) volatile
    {
        uint32_t curr = DMA_CH1_TX_CONTROL;

        EDSE = curr & (1u << 28u);
        TxPBL = (curr >> 16u) & 0b111111u;
        IPBL = curr & (1u << 15u);
        OSF = curr & (1u << 4u);
        ST = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH1_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 1 Transmit Control
     */
    inline void set_DMA_CH1_TX_CONTROL(bool EDSE, uint8_t TxPBL, bool IPBL,
                                       bool OSF, bool ST) volatile
    {
        uint32_t curr = DMA_CH1_TX_CONTROL;

        curr &= ~(0b1u << 28u);
        curr |= (EDSE & 0b1u) << 28u;
        curr &= ~(0b111111u << 16u);
        curr |= (TxPBL & 0b111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IPBL & 0b1u) << 15u;
        curr &= ~(0b1u << 4u);
        curr |= (OSF & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (ST & 0b1u) << 0u;

        DMA_CH1_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline bool get_DMA_CH1_RX_CONTROL_RPF() volatile
    {
        return DMA_CH1_RX_CONTROL & (1u << 31u);
    }

    /**
     * Set DMA_CH1_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void set_DMA_CH1_RX_CONTROL_RPF() volatile
    {
        DMA_CH1_RX_CONTROL |= 1u << 31u;
    }

    /**
     * Clear DMA_CH1_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void clear_DMA_CH1_RX_CONTROL_RPF() volatile
    {
        DMA_CH1_RX_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle DMA_CH1_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void toggle_DMA_CH1_RX_CONTROL_RPF() volatile
    {
        DMA_CH1_RX_CONTROL ^= 1u << 31u;
    }

    /**
     * Get DMA_CH1_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH1_RX_CONTROL_RxPBL() volatile
    {
        return (DMA_CH1_RX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH1_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH1_RX_CONTROL_RxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH1_RX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH1_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline uint16_t get_DMA_CH1_RX_CONTROL_RBSZ_13_y() volatile
    {
        return (DMA_CH1_RX_CONTROL >> 4u) & 0b11111111111u;
    }

    /**
     * Set DMA_CH1_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline void set_DMA_CH1_RX_CONTROL_RBSZ_13_y(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH1_RX_CONTROL;

        curr &= ~(0b11111111111u << 4u);
        curr |= (value & 0b11111111111u) << 4u;

        DMA_CH1_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_RX_CONTROL's RBSZ_x_0 field.
     *
     * Receive Buffer size Low RBSZ[13:0] is split into two fields RBSZ_13_y
     * and RBSZ_x_0.
     */
    inline uint8_t get_DMA_CH1_RX_CONTROL_RBSZ_x_0() volatile
    {
        return (DMA_CH1_RX_CONTROL >> 1u) & 0b111u;
    }

    /**
     * Get DMA_CH1_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline bool get_DMA_CH1_RX_CONTROL_SR() volatile
    {
        return DMA_CH1_RX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH1_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void set_DMA_CH1_RX_CONTROL_SR() volatile
    {
        DMA_CH1_RX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH1_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void clear_DMA_CH1_RX_CONTROL_SR() volatile
    {
        DMA_CH1_RX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH1_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void toggle_DMA_CH1_RX_CONTROL_SR() volatile
    {
        DMA_CH1_RX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH1_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 1 Receive Control
     */
    inline void get_DMA_CH1_RX_CONTROL(bool &RPF, uint8_t &RxPBL,
                                       uint16_t &RBSZ_13_y, uint8_t &RBSZ_x_0,
                                       bool &SR) volatile
    {
        uint32_t curr = DMA_CH1_RX_CONTROL;

        RPF = curr & (1u << 31u);
        RxPBL = (curr >> 16u) & 0b111111u;
        RBSZ_13_y = (curr >> 4u) & 0b11111111111u;
        RBSZ_x_0 = (curr >> 1u) & 0b111u;
        SR = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH1_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 1 Receive Control
     */
    inline void set_DMA_CH1_RX_CONTROL(bool RPF, uint8_t RxPBL,
                                       uint16_t RBSZ_13_y, bool SR) volatile
    {
        uint32_t curr = DMA_CH1_RX_CONTROL;

        curr &= ~(0b1u << 31u);
        curr |= (RPF & 0b1u) << 31u;
        curr &= ~(0b111111u << 16u);
        curr |= (RxPBL & 0b111111u) << 16u;
        curr &= ~(0b11111111111u << 4u);
        curr |= (RBSZ_13_y & 0b11111111111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (SR & 0b1u) << 0u;

        DMA_CH1_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH1_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline uint32_t get_DMA_CH1_TXDESC_LIST_ADDRESS_TDESLA() volatile
    {
        return (DMA_CH1_TXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH1_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline void set_DMA_CH1_TXDESC_LIST_ADDRESS_TDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH1_TXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH1_TXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH1_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline uint32_t get_DMA_CH1_RXDESC_LIST_ADDRESS_RDESLA() volatile
    {
        return (DMA_CH1_RXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH1_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline void set_DMA_CH1_RXDESC_LIST_ADDRESS_RDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH1_RXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH1_RXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH1_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline uint32_t get_DMA_CH1_TXDESC_TAIL_POINTER_TDTP() volatile
    {
        return (DMA_CH1_TXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH1_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline void set_DMA_CH1_TXDESC_TAIL_POINTER_TDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH1_TXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH1_TXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH1_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline uint32_t get_DMA_CH1_RXDESC_TAIL_POINTER_RDTP() volatile
    {
        return (DMA_CH1_RXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH1_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline void set_DMA_CH1_RXDESC_TAIL_POINTER_RDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH1_RXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH1_RXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH1_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH1_TXDESC_RING_LENGTH_TDRL() volatile
    {
        return (DMA_CH1_TXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH1_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH1_TXDESC_RING_LENGTH_TDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH1_TXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH1_TXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH1_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH1_RXDESC_RING_LENGTH_RDRL() volatile
    {
        return (DMA_CH1_RXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH1_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH1_RXDESC_RING_LENGTH_RDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH1_RXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH1_RXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_NIE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 15u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 15u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 15u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_AIE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 14u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 14u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 14u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_CDEE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 13u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 13u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 13u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_FBEE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 12u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 12u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 12u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_ERIE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 11u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 11u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 11u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_ETIE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 10u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 10u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 10u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_RWTE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 9u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 9u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 9u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_RSE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 8u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 8u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 8u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_RBUE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 7u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 7u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 7u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_RIE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 6u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 6u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 6u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_TBUE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 2u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 2u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 2u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_TXSE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 1u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 1u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 1u;
    }

    /**
     * Get DMA_CH1_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline bool get_DMA_CH1_INTERRUPT_ENABLE_TIE() volatile
    {
        return DMA_CH1_INTERRUPT_ENABLE & (1u << 0u);
    }

    /**
     * Set DMA_CH1_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE |= 1u << 0u;
    }

    /**
     * Clear DMA_CH1_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void clear_DMA_CH1_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH1_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void toggle_DMA_CH1_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH1_INTERRUPT_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH1_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 1 Interrupt Enable
     */
    inline void get_DMA_CH1_INTERRUPT_ENABLE(bool &NIE, bool &AIE, bool &CDEE,
                                             bool &FBEE, bool &ERIE,
                                             bool &ETIE, bool &RWTE, bool &RSE,
                                             bool &RBUE, bool &RIE, bool &TBUE,
                                             bool &TXSE, bool &TIE) volatile
    {
        uint32_t curr = DMA_CH1_INTERRUPT_ENABLE;

        NIE = curr & (1u << 15u);
        AIE = curr & (1u << 14u);
        CDEE = curr & (1u << 13u);
        FBEE = curr & (1u << 12u);
        ERIE = curr & (1u << 11u);
        ETIE = curr & (1u << 10u);
        RWTE = curr & (1u << 9u);
        RSE = curr & (1u << 8u);
        RBUE = curr & (1u << 7u);
        RIE = curr & (1u << 6u);
        TBUE = curr & (1u << 2u);
        TXSE = curr & (1u << 1u);
        TIE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH1_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 1 Interrupt Enable
     */
    inline void set_DMA_CH1_INTERRUPT_ENABLE(bool NIE, bool AIE, bool CDEE,
                                             bool FBEE, bool ERIE, bool ETIE,
                                             bool RWTE, bool RSE, bool RBUE,
                                             bool RIE, bool TBUE, bool TXSE,
                                             bool TIE) volatile
    {
        uint32_t curr = DMA_CH1_INTERRUPT_ENABLE;

        curr &= ~(0b1u << 15u);
        curr |= (NIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDEE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBEE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWTE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBUE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RIE & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TIE & 0b1u) << 0u;

        DMA_CH1_INTERRUPT_ENABLE = curr;
    }

    /**
     * Get DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline uint8_t get_DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER_RWTU() volatile
    {
        return (DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER >> 16u) & 0b11u;
    }

    /**
     * Set DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline void set_DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER_RWTU(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline uint8_t get_DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER_RWT() volatile
    {
        return (DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER >> 0u) & 0b11111111u;
    }

    /**
     * Set DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline void set_DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER_RWT(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get all of DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 1 Receive Interrupt Watchdog Timer
     */
    inline void get_DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t &RWTU,
                                                        uint8_t &RWT) volatile
    {
        uint32_t curr = DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER;

        RWTU = (curr >> 16u) & 0b11u;
        RWT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 1 Receive Interrupt Watchdog Timer
     */
    inline void set_DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t RWTU,
                                                        uint8_t RWT) volatile
    {
        uint32_t curr = DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (RWTU & 0b11u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RWT & 0b11111111u) << 0u;

        DMA_CH1_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's RSN field.
     *
     * Reference Slot Number This field gives the current value of the
     * reference slot number in the DMA.
     */
    inline uint8_t get_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_RSN() volatile
    {
        return (DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline uint16_t get_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_SIV() volatile
    {
        return (DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS >> 4u) & 0b111111111111u;
    }

    /**
     * Set DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline void set_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_SIV(
        uint16_t value) volatile
    {
        uint32_t curr = DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (value & 0b111111111111u) << 4u;

        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline bool get_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        return DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void set_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void clear_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void toggle_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline bool get_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        return DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void set_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void clear_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void toggle_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 1 Slot Function Control and Status
     */
    inline void get_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS(uint8_t &RSN,
                                                         uint16_t &SIV,
                                                         bool &ASC,
                                                         bool &ESC) volatile
    {
        uint32_t curr = DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS;

        RSN = (curr >> 16u) & 0b1111u;
        SIV = (curr >> 4u) & 0b111111111111u;
        ASC = curr & (1u << 1u);
        ESC = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 1 Slot Function Control and Status
     */
    inline void set_DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS(uint16_t SIV,
                                                         bool ASC,
                                                         bool ESC) volatile
    {
        uint32_t curr = DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (SIV & 0b111111111111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (ASC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ESC & 0b1u) << 0u;

        DMA_CH1_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH1_CURRENT_APP_TXDESC's CURTDESAPTR field.
     *
     * Application Transmit Descriptor Address Pointer The DMA updates this
     * pointer during Tx operation.
     */
    inline uint32_t get_DMA_CH1_CURRENT_APP_TXDESC_CURTDESAPTR() volatile
    {
        return (DMA_CH1_CURRENT_APP_TXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH1_CURRENT_APP_RXDESC's CURRDESAPTR field.
     *
     * Application Receive Descriptor Address Pointer The DMA updates this
     * pointer during Rx operation.
     */
    inline uint32_t get_DMA_CH1_CURRENT_APP_RXDESC_CURRDESAPTR() volatile
    {
        return (DMA_CH1_CURRENT_APP_RXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH1_CURRENT_APP_TXBUFFER's CURTBUFAPTR field.
     *
     * Application Transmit Buffer Address Pointer The DMA updates this pointer
     * during Tx operation.
     */
    inline uint32_t get_DMA_CH1_CURRENT_APP_TXBUFFER_CURTBUFAPTR() volatile
    {
        return (DMA_CH1_CURRENT_APP_TXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH1_CURRENT_APP_RXBUFFER's CURRBUFAPTR field.
     *
     * Application Receive Buffer Address Pointer The DMA updates this pointer
     * during Rx operation.
     */
    inline uint32_t get_DMA_CH1_CURRENT_APP_RXBUFFER_CURRBUFAPTR() volatile
    {
        return (DMA_CH1_CURRENT_APP_RXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH1_STATUS's REB field.
     *
     * Rx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH1_STATUS_REB() volatile
    {
        return (DMA_CH1_STATUS >> 19u) & 0b111u;
    }

    /**
     * Get DMA_CH1_STATUS's TEB field.
     *
     * Tx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH1_STATUS_TEB() volatile
    {
        return (DMA_CH1_STATUS >> 16u) & 0b111u;
    }

    /**
     * Get DMA_CH1_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline bool get_DMA_CH1_STATUS_NIS() volatile
    {
        return DMA_CH1_STATUS & (1u << 15u);
    }

    /**
     * Set DMA_CH1_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void set_DMA_CH1_STATUS_NIS() volatile
    {
        DMA_CH1_STATUS |= 1u << 15u;
    }

    /**
     * Clear DMA_CH1_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void clear_DMA_CH1_STATUS_NIS() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH1_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void toggle_DMA_CH1_STATUS_NIS() volatile
    {
        DMA_CH1_STATUS ^= 1u << 15u;
    }

    /**
     * Get DMA_CH1_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline bool get_DMA_CH1_STATUS_AIS() volatile
    {
        return DMA_CH1_STATUS & (1u << 14u);
    }

    /**
     * Set DMA_CH1_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void set_DMA_CH1_STATUS_AIS() volatile
    {
        DMA_CH1_STATUS |= 1u << 14u;
    }

    /**
     * Clear DMA_CH1_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void clear_DMA_CH1_STATUS_AIS() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH1_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void toggle_DMA_CH1_STATUS_AIS() volatile
    {
        DMA_CH1_STATUS ^= 1u << 14u;
    }

    /**
     * Get DMA_CH1_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline bool get_DMA_CH1_STATUS_CDE() volatile
    {
        return DMA_CH1_STATUS & (1u << 13u);
    }

    /**
     * Set DMA_CH1_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void set_DMA_CH1_STATUS_CDE() volatile
    {
        DMA_CH1_STATUS |= 1u << 13u;
    }

    /**
     * Clear DMA_CH1_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void clear_DMA_CH1_STATUS_CDE() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH1_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void toggle_DMA_CH1_STATUS_CDE() volatile
    {
        DMA_CH1_STATUS ^= 1u << 13u;
    }

    /**
     * Get DMA_CH1_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline bool get_DMA_CH1_STATUS_FBE() volatile
    {
        return DMA_CH1_STATUS & (1u << 12u);
    }

    /**
     * Set DMA_CH1_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void set_DMA_CH1_STATUS_FBE() volatile
    {
        DMA_CH1_STATUS |= 1u << 12u;
    }

    /**
     * Clear DMA_CH1_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void clear_DMA_CH1_STATUS_FBE() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH1_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void toggle_DMA_CH1_STATUS_FBE() volatile
    {
        DMA_CH1_STATUS ^= 1u << 12u;
    }

    /**
     * Get DMA_CH1_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline bool get_DMA_CH1_STATUS_ERI() volatile
    {
        return DMA_CH1_STATUS & (1u << 11u);
    }

    /**
     * Set DMA_CH1_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void set_DMA_CH1_STATUS_ERI() volatile
    {
        DMA_CH1_STATUS |= 1u << 11u;
    }

    /**
     * Clear DMA_CH1_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void clear_DMA_CH1_STATUS_ERI() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH1_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void toggle_DMA_CH1_STATUS_ERI() volatile
    {
        DMA_CH1_STATUS ^= 1u << 11u;
    }

    /**
     * Get DMA_CH1_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline bool get_DMA_CH1_STATUS_ETI() volatile
    {
        return DMA_CH1_STATUS & (1u << 10u);
    }

    /**
     * Set DMA_CH1_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void set_DMA_CH1_STATUS_ETI() volatile
    {
        DMA_CH1_STATUS |= 1u << 10u;
    }

    /**
     * Clear DMA_CH1_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void clear_DMA_CH1_STATUS_ETI() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH1_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void toggle_DMA_CH1_STATUS_ETI() volatile
    {
        DMA_CH1_STATUS ^= 1u << 10u;
    }

    /**
     * Get DMA_CH1_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline bool get_DMA_CH1_STATUS_RWT() volatile
    {
        return DMA_CH1_STATUS & (1u << 9u);
    }

    /**
     * Set DMA_CH1_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void set_DMA_CH1_STATUS_RWT() volatile
    {
        DMA_CH1_STATUS |= 1u << 9u;
    }

    /**
     * Clear DMA_CH1_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void clear_DMA_CH1_STATUS_RWT() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH1_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void toggle_DMA_CH1_STATUS_RWT() volatile
    {
        DMA_CH1_STATUS ^= 1u << 9u;
    }

    /**
     * Get DMA_CH1_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline bool get_DMA_CH1_STATUS_RPS() volatile
    {
        return DMA_CH1_STATUS & (1u << 8u);
    }

    /**
     * Set DMA_CH1_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void set_DMA_CH1_STATUS_RPS() volatile
    {
        DMA_CH1_STATUS |= 1u << 8u;
    }

    /**
     * Clear DMA_CH1_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void clear_DMA_CH1_STATUS_RPS() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH1_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void toggle_DMA_CH1_STATUS_RPS() volatile
    {
        DMA_CH1_STATUS ^= 1u << 8u;
    }

    /**
     * Get DMA_CH1_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH1_STATUS_RBU() volatile
    {
        return DMA_CH1_STATUS & (1u << 7u);
    }

    /**
     * Set DMA_CH1_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH1_STATUS_RBU() volatile
    {
        DMA_CH1_STATUS |= 1u << 7u;
    }

    /**
     * Clear DMA_CH1_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH1_STATUS_RBU() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH1_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH1_STATUS_RBU() volatile
    {
        DMA_CH1_STATUS ^= 1u << 7u;
    }

    /**
     * Get DMA_CH1_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline bool get_DMA_CH1_STATUS_RI() volatile
    {
        return DMA_CH1_STATUS & (1u << 6u);
    }

    /**
     * Set DMA_CH1_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void set_DMA_CH1_STATUS_RI() volatile
    {
        DMA_CH1_STATUS |= 1u << 6u;
    }

    /**
     * Clear DMA_CH1_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void clear_DMA_CH1_STATUS_RI() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH1_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void toggle_DMA_CH1_STATUS_RI() volatile
    {
        DMA_CH1_STATUS ^= 1u << 6u;
    }

    /**
     * Get DMA_CH1_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH1_STATUS_TBU() volatile
    {
        return DMA_CH1_STATUS & (1u << 2u);
    }

    /**
     * Set DMA_CH1_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH1_STATUS_TBU() volatile
    {
        DMA_CH1_STATUS |= 1u << 2u;
    }

    /**
     * Clear DMA_CH1_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH1_STATUS_TBU() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH1_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH1_STATUS_TBU() volatile
    {
        DMA_CH1_STATUS ^= 1u << 2u;
    }

    /**
     * Get DMA_CH1_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline bool get_DMA_CH1_STATUS_TPS() volatile
    {
        return DMA_CH1_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH1_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void set_DMA_CH1_STATUS_TPS() volatile
    {
        DMA_CH1_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH1_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void clear_DMA_CH1_STATUS_TPS() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH1_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void toggle_DMA_CH1_STATUS_TPS() volatile
    {
        DMA_CH1_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH1_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline bool get_DMA_CH1_STATUS_TI() volatile
    {
        return DMA_CH1_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH1_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void set_DMA_CH1_STATUS_TI() volatile
    {
        DMA_CH1_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH1_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void clear_DMA_CH1_STATUS_TI() volatile
    {
        DMA_CH1_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH1_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void toggle_DMA_CH1_STATUS_TI() volatile
    {
        DMA_CH1_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH1_STATUS's bit fields.
     *
     * (read-write) DMA Channel 1 Status
     */
    inline void get_DMA_CH1_STATUS(uint8_t &REB, uint8_t &TEB, bool &NIS,
                                   bool &AIS, bool &CDE, bool &FBE, bool &ERI,
                                   bool &ETI, bool &RWT, bool &RPS, bool &RBU,
                                   bool &RI, bool &TBU, bool &TPS,
                                   bool &TI) volatile
    {
        uint32_t curr = DMA_CH1_STATUS;

        REB = (curr >> 19u) & 0b111u;
        TEB = (curr >> 16u) & 0b111u;
        NIS = curr & (1u << 15u);
        AIS = curr & (1u << 14u);
        CDE = curr & (1u << 13u);
        FBE = curr & (1u << 12u);
        ERI = curr & (1u << 11u);
        ETI = curr & (1u << 10u);
        RWT = curr & (1u << 9u);
        RPS = curr & (1u << 8u);
        RBU = curr & (1u << 7u);
        RI = curr & (1u << 6u);
        TBU = curr & (1u << 2u);
        TPS = curr & (1u << 1u);
        TI = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH1_STATUS's bit fields.
     *
     * (read-write) DMA Channel 1 Status
     */
    inline void set_DMA_CH1_STATUS(bool NIS, bool AIS, bool CDE, bool FBE,
                                   bool ERI, bool ETI, bool RWT, bool RPS,
                                   bool RBU, bool RI, bool TBU, bool TPS,
                                   bool TI) volatile
    {
        uint32_t curr = DMA_CH1_STATUS;

        curr &= ~(0b1u << 15u);
        curr |= (NIS & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERI & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETI & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RPS & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBU & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RI & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TI & 0b1u) << 0u;

        DMA_CH1_STATUS = curr;
    }

    /**
     * Get DMA_CH1_MISS_FRAME_CNT's MFCO bit.
     *
     * Overflow status of the MFC Counter When this bit is set then the MFC
     * counter does not get incremented further.
     */
    inline bool get_DMA_CH1_MISS_FRAME_CNT_MFCO() volatile
    {
        return DMA_CH1_MISS_FRAME_CNT & (1u << 15u);
    }

    /**
     * Get DMA_CH1_MISS_FRAME_CNT's MFC field.
     *
     * Dropped Packet Counters This counter indicates the number of packet
     * counters that are dropped by the DMA either because of bus error or
     * because of programming RPF field in RX_CONTROL register.
     */
    inline uint16_t get_DMA_CH1_MISS_FRAME_CNT_MFC() volatile
    {
        return (DMA_CH1_MISS_FRAME_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of DMA_CH1_MISS_FRAME_CNT's bit fields.
     *
     * (read-write) Channel 1 Missed Frame Counter
     */
    inline void get_DMA_CH1_MISS_FRAME_CNT(bool &MFCO, uint16_t &MFC) volatile
    {
        uint32_t curr = DMA_CH1_MISS_FRAME_CNT;

        MFCO = curr & (1u << 15u);
        MFC = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get DMA_CH1_RXP_ACCEPT_CNT's RXPACOF bit.
     *
     * Rx Parser Accept Counter Overflow Bit When set, this bit indicates that
     * the RXPAC Counter field crossed the maximum limit.
     */
    inline bool get_DMA_CH1_RXP_ACCEPT_CNT_RXPACOF() volatile
    {
        return DMA_CH1_RXP_ACCEPT_CNT & (1u << 31u);
    }

    /**
     * Get DMA_CH1_RXP_ACCEPT_CNT's RXPAC field.
     *
     * Rx Parser Accept Counter This 31-bit counter is implemented whenever a
     * Rx Parser Accept a packet due to AF =1.
     */
    inline uint32_t get_DMA_CH1_RXP_ACCEPT_CNT_RXPAC() volatile
    {
        return (DMA_CH1_RXP_ACCEPT_CNT >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get all of DMA_CH1_RXP_ACCEPT_CNT's bit fields.
     *
     * (read-write) Channel 1 RXP Frames Accepted Counter
     */
    inline void get_DMA_CH1_RXP_ACCEPT_CNT(bool &RXPACOF,
                                           uint32_t &RXPAC) volatile
    {
        uint32_t curr = DMA_CH1_RXP_ACCEPT_CNT;

        RXPACOF = curr & (1u << 31u);
        RXPAC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH1_RX_ERI_CNT's ECNT field.
     *
     * ERI Counter When ERIC bit of RX_CONTROL register is set, this counter
     * increments for burst transfer completed by the Rx DMA from the start of
     * packet transfer.
     */
    inline uint16_t get_DMA_CH1_RX_ERI_CNT_ECNT() volatile
    {
        return (DMA_CH1_RX_ERI_CNT >> 0u) & 0b111111111111u;
    }

    /**
     * Get DMA_CH2_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline uint8_t get_DMA_CH2_CONTROL_DSL() volatile
    {
        return (DMA_CH2_CONTROL >> 18u) & 0b111u;
    }

    /**
     * Set DMA_CH2_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline void set_DMA_CH2_CONTROL_DSL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH2_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DMA_CH2_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH2_TX_CONTROL and Bits[21:16] in DMA_CH2_RX_CONTROL is
     * multiplied by eight times.
     */
    inline bool get_DMA_CH2_CONTROL_PBLx8() volatile
    {
        return DMA_CH2_CONTROL & (1u << 16u);
    }

    /**
     * Set DMA_CH2_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH2_TX_CONTROL and Bits[21:16] in DMA_CH2_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void set_DMA_CH2_CONTROL_PBLx8() volatile
    {
        DMA_CH2_CONTROL |= 1u << 16u;
    }

    /**
     * Clear DMA_CH2_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH2_TX_CONTROL and Bits[21:16] in DMA_CH2_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void clear_DMA_CH2_CONTROL_PBLx8() volatile
    {
        DMA_CH2_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle DMA_CH2_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH2_TX_CONTROL and Bits[21:16] in DMA_CH2_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void toggle_DMA_CH2_CONTROL_PBLx8() volatile
    {
        DMA_CH2_CONTROL ^= 1u << 16u;
    }

    /**
     * Get all of DMA_CH2_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 2 Control
     */
    inline void get_DMA_CH2_CONTROL(uint8_t &DSL, bool &PBLx8) volatile
    {
        uint32_t curr = DMA_CH2_CONTROL;

        DSL = (curr >> 18u) & 0b111u;
        PBLx8 = curr & (1u << 16u);
    }

    /**
     * Set all of DMA_CH2_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 2 Control
     */
    inline void set_DMA_CH2_CONTROL(uint8_t DSL, bool PBLx8) volatile
    {
        uint32_t curr = DMA_CH2_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (DSL & 0b111u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (PBLx8 & 0b1u) << 16u;

        DMA_CH2_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline bool get_DMA_CH2_TX_CONTROL_EDSE() volatile
    {
        return DMA_CH2_TX_CONTROL & (1u << 28u);
    }

    /**
     * Set DMA_CH2_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void set_DMA_CH2_TX_CONTROL_EDSE() volatile
    {
        DMA_CH2_TX_CONTROL |= 1u << 28u;
    }

    /**
     * Clear DMA_CH2_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void clear_DMA_CH2_TX_CONTROL_EDSE() volatile
    {
        DMA_CH2_TX_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle DMA_CH2_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void toggle_DMA_CH2_TX_CONTROL_EDSE() volatile
    {
        DMA_CH2_TX_CONTROL ^= 1u << 28u;
    }

    /**
     * Get DMA_CH2_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH2_TX_CONTROL_TxPBL() volatile
    {
        return (DMA_CH2_TX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH2_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH2_TX_CONTROL_TxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH2_TX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH2_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline bool get_DMA_CH2_TX_CONTROL_IPBL() volatile
    {
        return DMA_CH2_TX_CONTROL & (1u << 15u);
    }

    /**
     * Set DMA_CH2_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void set_DMA_CH2_TX_CONTROL_IPBL() volatile
    {
        DMA_CH2_TX_CONTROL |= 1u << 15u;
    }

    /**
     * Clear DMA_CH2_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void clear_DMA_CH2_TX_CONTROL_IPBL() volatile
    {
        DMA_CH2_TX_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH2_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void toggle_DMA_CH2_TX_CONTROL_IPBL() volatile
    {
        DMA_CH2_TX_CONTROL ^= 1u << 15u;
    }

    /**
     * Get DMA_CH2_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline bool get_DMA_CH2_TX_CONTROL_OSF() volatile
    {
        return DMA_CH2_TX_CONTROL & (1u << 4u);
    }

    /**
     * Set DMA_CH2_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void set_DMA_CH2_TX_CONTROL_OSF() volatile
    {
        DMA_CH2_TX_CONTROL |= 1u << 4u;
    }

    /**
     * Clear DMA_CH2_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void clear_DMA_CH2_TX_CONTROL_OSF() volatile
    {
        DMA_CH2_TX_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle DMA_CH2_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void toggle_DMA_CH2_TX_CONTROL_OSF() volatile
    {
        DMA_CH2_TX_CONTROL ^= 1u << 4u;
    }

    /**
     * Get DMA_CH2_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline bool get_DMA_CH2_TX_CONTROL_ST() volatile
    {
        return DMA_CH2_TX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH2_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void set_DMA_CH2_TX_CONTROL_ST() volatile
    {
        DMA_CH2_TX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH2_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void clear_DMA_CH2_TX_CONTROL_ST() volatile
    {
        DMA_CH2_TX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH2_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void toggle_DMA_CH2_TX_CONTROL_ST() volatile
    {
        DMA_CH2_TX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH2_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 2 Transmit Control
     */
    inline void get_DMA_CH2_TX_CONTROL(bool &EDSE, uint8_t &TxPBL, bool &IPBL,
                                       bool &OSF, bool &ST) volatile
    {
        uint32_t curr = DMA_CH2_TX_CONTROL;

        EDSE = curr & (1u << 28u);
        TxPBL = (curr >> 16u) & 0b111111u;
        IPBL = curr & (1u << 15u);
        OSF = curr & (1u << 4u);
        ST = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH2_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 2 Transmit Control
     */
    inline void set_DMA_CH2_TX_CONTROL(bool EDSE, uint8_t TxPBL, bool IPBL,
                                       bool OSF, bool ST) volatile
    {
        uint32_t curr = DMA_CH2_TX_CONTROL;

        curr &= ~(0b1u << 28u);
        curr |= (EDSE & 0b1u) << 28u;
        curr &= ~(0b111111u << 16u);
        curr |= (TxPBL & 0b111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IPBL & 0b1u) << 15u;
        curr &= ~(0b1u << 4u);
        curr |= (OSF & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (ST & 0b1u) << 0u;

        DMA_CH2_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline bool get_DMA_CH2_RX_CONTROL_RPF() volatile
    {
        return DMA_CH2_RX_CONTROL & (1u << 31u);
    }

    /**
     * Set DMA_CH2_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void set_DMA_CH2_RX_CONTROL_RPF() volatile
    {
        DMA_CH2_RX_CONTROL |= 1u << 31u;
    }

    /**
     * Clear DMA_CH2_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void clear_DMA_CH2_RX_CONTROL_RPF() volatile
    {
        DMA_CH2_RX_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle DMA_CH2_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void toggle_DMA_CH2_RX_CONTROL_RPF() volatile
    {
        DMA_CH2_RX_CONTROL ^= 1u << 31u;
    }

    /**
     * Get DMA_CH2_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH2_RX_CONTROL_RxPBL() volatile
    {
        return (DMA_CH2_RX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH2_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH2_RX_CONTROL_RxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH2_RX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH2_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline uint16_t get_DMA_CH2_RX_CONTROL_RBSZ_13_y() volatile
    {
        return (DMA_CH2_RX_CONTROL >> 4u) & 0b11111111111u;
    }

    /**
     * Set DMA_CH2_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline void set_DMA_CH2_RX_CONTROL_RBSZ_13_y(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH2_RX_CONTROL;

        curr &= ~(0b11111111111u << 4u);
        curr |= (value & 0b11111111111u) << 4u;

        DMA_CH2_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_RX_CONTROL's RBSZ_x_0 field.
     *
     * Receive Buffer size Low RBSZ[13:0] is split into two fields RBSZ_13_y
     * and RBSZ_x_0.
     */
    inline uint8_t get_DMA_CH2_RX_CONTROL_RBSZ_x_0() volatile
    {
        return (DMA_CH2_RX_CONTROL >> 1u) & 0b111u;
    }

    /**
     * Get DMA_CH2_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline bool get_DMA_CH2_RX_CONTROL_SR() volatile
    {
        return DMA_CH2_RX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH2_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void set_DMA_CH2_RX_CONTROL_SR() volatile
    {
        DMA_CH2_RX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH2_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void clear_DMA_CH2_RX_CONTROL_SR() volatile
    {
        DMA_CH2_RX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH2_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void toggle_DMA_CH2_RX_CONTROL_SR() volatile
    {
        DMA_CH2_RX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH2_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 2 Receive Control
     */
    inline void get_DMA_CH2_RX_CONTROL(bool &RPF, uint8_t &RxPBL,
                                       uint16_t &RBSZ_13_y, uint8_t &RBSZ_x_0,
                                       bool &SR) volatile
    {
        uint32_t curr = DMA_CH2_RX_CONTROL;

        RPF = curr & (1u << 31u);
        RxPBL = (curr >> 16u) & 0b111111u;
        RBSZ_13_y = (curr >> 4u) & 0b11111111111u;
        RBSZ_x_0 = (curr >> 1u) & 0b111u;
        SR = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH2_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 2 Receive Control
     */
    inline void set_DMA_CH2_RX_CONTROL(bool RPF, uint8_t RxPBL,
                                       uint16_t RBSZ_13_y, bool SR) volatile
    {
        uint32_t curr = DMA_CH2_RX_CONTROL;

        curr &= ~(0b1u << 31u);
        curr |= (RPF & 0b1u) << 31u;
        curr &= ~(0b111111u << 16u);
        curr |= (RxPBL & 0b111111u) << 16u;
        curr &= ~(0b11111111111u << 4u);
        curr |= (RBSZ_13_y & 0b11111111111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (SR & 0b1u) << 0u;

        DMA_CH2_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH2_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline uint32_t get_DMA_CH2_TXDESC_LIST_ADDRESS_TDESLA() volatile
    {
        return (DMA_CH2_TXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH2_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline void set_DMA_CH2_TXDESC_LIST_ADDRESS_TDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH2_TXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH2_TXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH2_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline uint32_t get_DMA_CH2_RXDESC_LIST_ADDRESS_RDESLA() volatile
    {
        return (DMA_CH2_RXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH2_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline void set_DMA_CH2_RXDESC_LIST_ADDRESS_RDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH2_RXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH2_RXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH2_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline uint32_t get_DMA_CH2_TXDESC_TAIL_POINTER_TDTP() volatile
    {
        return (DMA_CH2_TXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH2_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline void set_DMA_CH2_TXDESC_TAIL_POINTER_TDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH2_TXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH2_TXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH2_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline uint32_t get_DMA_CH2_RXDESC_TAIL_POINTER_RDTP() volatile
    {
        return (DMA_CH2_RXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH2_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline void set_DMA_CH2_RXDESC_TAIL_POINTER_RDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH2_RXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH2_RXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH2_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH2_TXDESC_RING_LENGTH_TDRL() volatile
    {
        return (DMA_CH2_TXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH2_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH2_TXDESC_RING_LENGTH_TDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH2_TXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH2_TXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH2_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH2_RXDESC_RING_LENGTH_RDRL() volatile
    {
        return (DMA_CH2_RXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH2_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH2_RXDESC_RING_LENGTH_RDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH2_RXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH2_RXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_NIE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 15u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 15u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 15u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_AIE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 14u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 14u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 14u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_CDEE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 13u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 13u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 13u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_FBEE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 12u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 12u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 12u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_ERIE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 11u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 11u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 11u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_ETIE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 10u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 10u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 10u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_RWTE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 9u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 9u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 9u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_RSE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 8u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 8u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 8u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_RBUE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 7u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 7u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 7u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_RIE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 6u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 6u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 6u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_TBUE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 2u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 2u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 2u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_TXSE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 1u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 1u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 1u;
    }

    /**
     * Get DMA_CH2_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline bool get_DMA_CH2_INTERRUPT_ENABLE_TIE() volatile
    {
        return DMA_CH2_INTERRUPT_ENABLE & (1u << 0u);
    }

    /**
     * Set DMA_CH2_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE |= 1u << 0u;
    }

    /**
     * Clear DMA_CH2_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void clear_DMA_CH2_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH2_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void toggle_DMA_CH2_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH2_INTERRUPT_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH2_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 2 Interrupt Enable
     */
    inline void get_DMA_CH2_INTERRUPT_ENABLE(bool &NIE, bool &AIE, bool &CDEE,
                                             bool &FBEE, bool &ERIE,
                                             bool &ETIE, bool &RWTE, bool &RSE,
                                             bool &RBUE, bool &RIE, bool &TBUE,
                                             bool &TXSE, bool &TIE) volatile
    {
        uint32_t curr = DMA_CH2_INTERRUPT_ENABLE;

        NIE = curr & (1u << 15u);
        AIE = curr & (1u << 14u);
        CDEE = curr & (1u << 13u);
        FBEE = curr & (1u << 12u);
        ERIE = curr & (1u << 11u);
        ETIE = curr & (1u << 10u);
        RWTE = curr & (1u << 9u);
        RSE = curr & (1u << 8u);
        RBUE = curr & (1u << 7u);
        RIE = curr & (1u << 6u);
        TBUE = curr & (1u << 2u);
        TXSE = curr & (1u << 1u);
        TIE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH2_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 2 Interrupt Enable
     */
    inline void set_DMA_CH2_INTERRUPT_ENABLE(bool NIE, bool AIE, bool CDEE,
                                             bool FBEE, bool ERIE, bool ETIE,
                                             bool RWTE, bool RSE, bool RBUE,
                                             bool RIE, bool TBUE, bool TXSE,
                                             bool TIE) volatile
    {
        uint32_t curr = DMA_CH2_INTERRUPT_ENABLE;

        curr &= ~(0b1u << 15u);
        curr |= (NIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDEE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBEE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWTE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBUE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RIE & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TIE & 0b1u) << 0u;

        DMA_CH2_INTERRUPT_ENABLE = curr;
    }

    /**
     * Get DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline uint8_t get_DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER_RWTU() volatile
    {
        return (DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER >> 16u) & 0b11u;
    }

    /**
     * Set DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline void set_DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER_RWTU(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline uint8_t get_DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER_RWT() volatile
    {
        return (DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER >> 0u) & 0b11111111u;
    }

    /**
     * Set DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline void set_DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER_RWT(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get all of DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 2 Receive Interrupt Watchdog Timer
     */
    inline void get_DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t &RWTU,
                                                        uint8_t &RWT) volatile
    {
        uint32_t curr = DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER;

        RWTU = (curr >> 16u) & 0b11u;
        RWT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 2 Receive Interrupt Watchdog Timer
     */
    inline void set_DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t RWTU,
                                                        uint8_t RWT) volatile
    {
        uint32_t curr = DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (RWTU & 0b11u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RWT & 0b11111111u) << 0u;

        DMA_CH2_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's RSN field.
     *
     * Reference Slot Number This field gives the current value of the
     * reference slot number in the DMA.
     */
    inline uint8_t get_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_RSN() volatile
    {
        return (DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline uint16_t get_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_SIV() volatile
    {
        return (DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS >> 4u) & 0b111111111111u;
    }

    /**
     * Set DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline void set_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_SIV(
        uint16_t value) volatile
    {
        uint32_t curr = DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (value & 0b111111111111u) << 4u;

        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline bool get_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        return DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void set_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void clear_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void toggle_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline bool get_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        return DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void set_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void clear_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void toggle_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 2 Slot Function Control and Status
     */
    inline void get_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS(uint8_t &RSN,
                                                         uint16_t &SIV,
                                                         bool &ASC,
                                                         bool &ESC) volatile
    {
        uint32_t curr = DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS;

        RSN = (curr >> 16u) & 0b1111u;
        SIV = (curr >> 4u) & 0b111111111111u;
        ASC = curr & (1u << 1u);
        ESC = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 2 Slot Function Control and Status
     */
    inline void set_DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS(uint16_t SIV,
                                                         bool ASC,
                                                         bool ESC) volatile
    {
        uint32_t curr = DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (SIV & 0b111111111111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (ASC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ESC & 0b1u) << 0u;

        DMA_CH2_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH2_CURRENT_APP_TXDESC's CURTDESAPTR field.
     *
     * Application Transmit Descriptor Address Pointer The DMA updates this
     * pointer during Tx operation.
     */
    inline uint32_t get_DMA_CH2_CURRENT_APP_TXDESC_CURTDESAPTR() volatile
    {
        return (DMA_CH2_CURRENT_APP_TXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH2_CURRENT_APP_RXDESC's CURRDESAPTR field.
     *
     * Application Receive Descriptor Address Pointer The DMA updates this
     * pointer during Rx operation.
     */
    inline uint32_t get_DMA_CH2_CURRENT_APP_RXDESC_CURRDESAPTR() volatile
    {
        return (DMA_CH2_CURRENT_APP_RXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH2_CURRENT_APP_TXBUFFER's CURTBUFAPTR field.
     *
     * Application Transmit Buffer Address Pointer The DMA updates this pointer
     * during Tx operation.
     */
    inline uint32_t get_DMA_CH2_CURRENT_APP_TXBUFFER_CURTBUFAPTR() volatile
    {
        return (DMA_CH2_CURRENT_APP_TXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH2_CURRENT_APP_RXBUFFER's CURRBUFAPTR field.
     *
     * Application Receive Buffer Address Pointer The DMA updates this pointer
     * during Rx operation.
     */
    inline uint32_t get_DMA_CH2_CURRENT_APP_RXBUFFER_CURRBUFAPTR() volatile
    {
        return (DMA_CH2_CURRENT_APP_RXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH2_STATUS's REB field.
     *
     * Rx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH2_STATUS_REB() volatile
    {
        return (DMA_CH2_STATUS >> 19u) & 0b111u;
    }

    /**
     * Get DMA_CH2_STATUS's TEB field.
     *
     * Tx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH2_STATUS_TEB() volatile
    {
        return (DMA_CH2_STATUS >> 16u) & 0b111u;
    }

    /**
     * Get DMA_CH2_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH2_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline bool get_DMA_CH2_STATUS_NIS() volatile
    {
        return DMA_CH2_STATUS & (1u << 15u);
    }

    /**
     * Set DMA_CH2_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH2_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline void set_DMA_CH2_STATUS_NIS() volatile
    {
        DMA_CH2_STATUS |= 1u << 15u;
    }

    /**
     * Clear DMA_CH2_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH2_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline void clear_DMA_CH2_STATUS_NIS() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH2_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH2_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline void toggle_DMA_CH2_STATUS_NIS() volatile
    {
        DMA_CH2_STATUS ^= 1u << 15u;
    }

    /**
     * Get DMA_CH2_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH2_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline bool get_DMA_CH2_STATUS_AIS() volatile
    {
        return DMA_CH2_STATUS & (1u << 14u);
    }

    /**
     * Set DMA_CH2_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH2_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline void set_DMA_CH2_STATUS_AIS() volatile
    {
        DMA_CH2_STATUS |= 1u << 14u;
    }

    /**
     * Clear DMA_CH2_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH2_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline void clear_DMA_CH2_STATUS_AIS() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH2_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH2_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline void toggle_DMA_CH2_STATUS_AIS() volatile
    {
        DMA_CH2_STATUS ^= 1u << 14u;
    }

    /**
     * Get DMA_CH2_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline bool get_DMA_CH2_STATUS_CDE() volatile
    {
        return DMA_CH2_STATUS & (1u << 13u);
    }

    /**
     * Set DMA_CH2_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void set_DMA_CH2_STATUS_CDE() volatile
    {
        DMA_CH2_STATUS |= 1u << 13u;
    }

    /**
     * Clear DMA_CH2_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void clear_DMA_CH2_STATUS_CDE() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH2_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void toggle_DMA_CH2_STATUS_CDE() volatile
    {
        DMA_CH2_STATUS ^= 1u << 13u;
    }

    /**
     * Get DMA_CH2_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline bool get_DMA_CH2_STATUS_FBE() volatile
    {
        return DMA_CH2_STATUS & (1u << 12u);
    }

    /**
     * Set DMA_CH2_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void set_DMA_CH2_STATUS_FBE() volatile
    {
        DMA_CH2_STATUS |= 1u << 12u;
    }

    /**
     * Clear DMA_CH2_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void clear_DMA_CH2_STATUS_FBE() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH2_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void toggle_DMA_CH2_STATUS_FBE() volatile
    {
        DMA_CH2_STATUS ^= 1u << 12u;
    }

    /**
     * Get DMA_CH2_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline bool get_DMA_CH2_STATUS_ERI() volatile
    {
        return DMA_CH2_STATUS & (1u << 11u);
    }

    /**
     * Set DMA_CH2_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void set_DMA_CH2_STATUS_ERI() volatile
    {
        DMA_CH2_STATUS |= 1u << 11u;
    }

    /**
     * Clear DMA_CH2_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void clear_DMA_CH2_STATUS_ERI() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH2_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void toggle_DMA_CH2_STATUS_ERI() volatile
    {
        DMA_CH2_STATUS ^= 1u << 11u;
    }

    /**
     * Get DMA_CH2_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline bool get_DMA_CH2_STATUS_ETI() volatile
    {
        return DMA_CH2_STATUS & (1u << 10u);
    }

    /**
     * Set DMA_CH2_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void set_DMA_CH2_STATUS_ETI() volatile
    {
        DMA_CH2_STATUS |= 1u << 10u;
    }

    /**
     * Clear DMA_CH2_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void clear_DMA_CH2_STATUS_ETI() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH2_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void toggle_DMA_CH2_STATUS_ETI() volatile
    {
        DMA_CH2_STATUS ^= 1u << 10u;
    }

    /**
     * Get DMA_CH2_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline bool get_DMA_CH2_STATUS_RWT() volatile
    {
        return DMA_CH2_STATUS & (1u << 9u);
    }

    /**
     * Set DMA_CH2_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void set_DMA_CH2_STATUS_RWT() volatile
    {
        DMA_CH2_STATUS |= 1u << 9u;
    }

    /**
     * Clear DMA_CH2_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void clear_DMA_CH2_STATUS_RWT() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH2_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void toggle_DMA_CH2_STATUS_RWT() volatile
    {
        DMA_CH2_STATUS ^= 1u << 9u;
    }

    /**
     * Get DMA_CH2_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline bool get_DMA_CH2_STATUS_RPS() volatile
    {
        return DMA_CH2_STATUS & (1u << 8u);
    }

    /**
     * Set DMA_CH2_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void set_DMA_CH2_STATUS_RPS() volatile
    {
        DMA_CH2_STATUS |= 1u << 8u;
    }

    /**
     * Clear DMA_CH2_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void clear_DMA_CH2_STATUS_RPS() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH2_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void toggle_DMA_CH2_STATUS_RPS() volatile
    {
        DMA_CH2_STATUS ^= 1u << 8u;
    }

    /**
     * Get DMA_CH2_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH2_STATUS_RBU() volatile
    {
        return DMA_CH2_STATUS & (1u << 7u);
    }

    /**
     * Set DMA_CH2_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH2_STATUS_RBU() volatile
    {
        DMA_CH2_STATUS |= 1u << 7u;
    }

    /**
     * Clear DMA_CH2_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH2_STATUS_RBU() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH2_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH2_STATUS_RBU() volatile
    {
        DMA_CH2_STATUS ^= 1u << 7u;
    }

    /**
     * Get DMA_CH2_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline bool get_DMA_CH2_STATUS_RI() volatile
    {
        return DMA_CH2_STATUS & (1u << 6u);
    }

    /**
     * Set DMA_CH2_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void set_DMA_CH2_STATUS_RI() volatile
    {
        DMA_CH2_STATUS |= 1u << 6u;
    }

    /**
     * Clear DMA_CH2_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void clear_DMA_CH2_STATUS_RI() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH2_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void toggle_DMA_CH2_STATUS_RI() volatile
    {
        DMA_CH2_STATUS ^= 1u << 6u;
    }

    /**
     * Get DMA_CH2_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH2_STATUS_TBU() volatile
    {
        return DMA_CH2_STATUS & (1u << 2u);
    }

    /**
     * Set DMA_CH2_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH2_STATUS_TBU() volatile
    {
        DMA_CH2_STATUS |= 1u << 2u;
    }

    /**
     * Clear DMA_CH2_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH2_STATUS_TBU() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH2_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH2_STATUS_TBU() volatile
    {
        DMA_CH2_STATUS ^= 1u << 2u;
    }

    /**
     * Get DMA_CH2_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline bool get_DMA_CH2_STATUS_TPS() volatile
    {
        return DMA_CH2_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH2_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void set_DMA_CH2_STATUS_TPS() volatile
    {
        DMA_CH2_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH2_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void clear_DMA_CH2_STATUS_TPS() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH2_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void toggle_DMA_CH2_STATUS_TPS() volatile
    {
        DMA_CH2_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH2_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline bool get_DMA_CH2_STATUS_TI() volatile
    {
        return DMA_CH2_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH2_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void set_DMA_CH2_STATUS_TI() volatile
    {
        DMA_CH2_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH2_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void clear_DMA_CH2_STATUS_TI() volatile
    {
        DMA_CH2_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH2_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void toggle_DMA_CH2_STATUS_TI() volatile
    {
        DMA_CH2_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH2_STATUS's bit fields.
     *
     * (read-write) DMA Channel 2 Status
     */
    inline void get_DMA_CH2_STATUS(uint8_t &REB, uint8_t &TEB, bool &NIS,
                                   bool &AIS, bool &CDE, bool &FBE, bool &ERI,
                                   bool &ETI, bool &RWT, bool &RPS, bool &RBU,
                                   bool &RI, bool &TBU, bool &TPS,
                                   bool &TI) volatile
    {
        uint32_t curr = DMA_CH2_STATUS;

        REB = (curr >> 19u) & 0b111u;
        TEB = (curr >> 16u) & 0b111u;
        NIS = curr & (1u << 15u);
        AIS = curr & (1u << 14u);
        CDE = curr & (1u << 13u);
        FBE = curr & (1u << 12u);
        ERI = curr & (1u << 11u);
        ETI = curr & (1u << 10u);
        RWT = curr & (1u << 9u);
        RPS = curr & (1u << 8u);
        RBU = curr & (1u << 7u);
        RI = curr & (1u << 6u);
        TBU = curr & (1u << 2u);
        TPS = curr & (1u << 1u);
        TI = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH2_STATUS's bit fields.
     *
     * (read-write) DMA Channel 2 Status
     */
    inline void set_DMA_CH2_STATUS(bool NIS, bool AIS, bool CDE, bool FBE,
                                   bool ERI, bool ETI, bool RWT, bool RPS,
                                   bool RBU, bool RI, bool TBU, bool TPS,
                                   bool TI) volatile
    {
        uint32_t curr = DMA_CH2_STATUS;

        curr &= ~(0b1u << 15u);
        curr |= (NIS & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERI & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETI & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RPS & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBU & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RI & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TI & 0b1u) << 0u;

        DMA_CH2_STATUS = curr;
    }

    /**
     * Get DMA_CH2_MISS_FRAME_CNT's MFCO bit.
     *
     * Overflow status of the MFC Counter When this bit is set then the MFC
     * counter does not get incremented further.
     */
    inline bool get_DMA_CH2_MISS_FRAME_CNT_MFCO() volatile
    {
        return DMA_CH2_MISS_FRAME_CNT & (1u << 15u);
    }

    /**
     * Get DMA_CH2_MISS_FRAME_CNT's MFC field.
     *
     * Dropped Packet Counters This counter indicates the number of packet
     * counters that are dropped by the DMA either because of bus error or
     * because of programming RPF field in DMA_CH2_RX_CONTROL register.
     */
    inline uint16_t get_DMA_CH2_MISS_FRAME_CNT_MFC() volatile
    {
        return (DMA_CH2_MISS_FRAME_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of DMA_CH2_MISS_FRAME_CNT's bit fields.
     *
     * (read-write) Channel 2 Missed Frame Counter
     */
    inline void get_DMA_CH2_MISS_FRAME_CNT(bool &MFCO, uint16_t &MFC) volatile
    {
        uint32_t curr = DMA_CH2_MISS_FRAME_CNT;

        MFCO = curr & (1u << 15u);
        MFC = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get DMA_CH2_RXP_ACCEPT_CNT's RXPACOF bit.
     *
     * Rx Parser Accept Counter Overflow Bit When set, this bit indicates that
     * the RXPAC Counter field crossed the maximum limit.
     */
    inline bool get_DMA_CH2_RXP_ACCEPT_CNT_RXPACOF() volatile
    {
        return DMA_CH2_RXP_ACCEPT_CNT & (1u << 31u);
    }

    /**
     * Get DMA_CH2_RXP_ACCEPT_CNT's RXPAC field.
     *
     * Rx Parser Accept Counter This 31-bit counter is implemented whenever a
     * Rx Parser Accept a packet due to AF =1.
     */
    inline uint32_t get_DMA_CH2_RXP_ACCEPT_CNT_RXPAC() volatile
    {
        return (DMA_CH2_RXP_ACCEPT_CNT >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get all of DMA_CH2_RXP_ACCEPT_CNT's bit fields.
     *
     * (read-write) Channel 2 RXP Frames Accepted Counter
     */
    inline void get_DMA_CH2_RXP_ACCEPT_CNT(bool &RXPACOF,
                                           uint32_t &RXPAC) volatile
    {
        uint32_t curr = DMA_CH2_RXP_ACCEPT_CNT;

        RXPACOF = curr & (1u << 31u);
        RXPAC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH2_RX_ERI_CNT's ECNT field.
     *
     * ERI Counter When ERIC bit of DMA_CH2_RX_CONTROL register is set, this
     * counter increments for burst transfer completed by the Rx DMA from the
     * start of packet transfer.
     */
    inline uint16_t get_DMA_CH2_RX_ERI_CNT_ECNT() volatile
    {
        return (DMA_CH2_RX_ERI_CNT >> 0u) & 0b111111111111u;
    }

    /**
     * Get DMA_CH3_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline uint8_t get_DMA_CH3_CONTROL_DSL() volatile
    {
        return (DMA_CH3_CONTROL >> 18u) & 0b111u;
    }

    /**
     * Set DMA_CH3_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline void set_DMA_CH3_CONTROL_DSL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH3_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DMA_CH3_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH3_TX_CONTROL and Bits[21:16] in DMA_CH3_RX_CONTROL is
     * multiplied by eight times.
     */
    inline bool get_DMA_CH3_CONTROL_PBLx8() volatile
    {
        return DMA_CH3_CONTROL & (1u << 16u);
    }

    /**
     * Set DMA_CH3_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH3_TX_CONTROL and Bits[21:16] in DMA_CH3_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void set_DMA_CH3_CONTROL_PBLx8() volatile
    {
        DMA_CH3_CONTROL |= 1u << 16u;
    }

    /**
     * Clear DMA_CH3_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH3_TX_CONTROL and Bits[21:16] in DMA_CH3_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void clear_DMA_CH3_CONTROL_PBLx8() volatile
    {
        DMA_CH3_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle DMA_CH3_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH3_TX_CONTROL and Bits[21:16] in DMA_CH3_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void toggle_DMA_CH3_CONTROL_PBLx8() volatile
    {
        DMA_CH3_CONTROL ^= 1u << 16u;
    }

    /**
     * Get all of DMA_CH3_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 3 Control
     */
    inline void get_DMA_CH3_CONTROL(uint8_t &DSL, bool &PBLx8) volatile
    {
        uint32_t curr = DMA_CH3_CONTROL;

        DSL = (curr >> 18u) & 0b111u;
        PBLx8 = curr & (1u << 16u);
    }

    /**
     * Set all of DMA_CH3_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 3 Control
     */
    inline void set_DMA_CH3_CONTROL(uint8_t DSL, bool PBLx8) volatile
    {
        uint32_t curr = DMA_CH3_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (DSL & 0b111u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (PBLx8 & 0b1u) << 16u;

        DMA_CH3_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline bool get_DMA_CH3_TX_CONTROL_EDSE() volatile
    {
        return DMA_CH3_TX_CONTROL & (1u << 28u);
    }

    /**
     * Set DMA_CH3_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void set_DMA_CH3_TX_CONTROL_EDSE() volatile
    {
        DMA_CH3_TX_CONTROL |= 1u << 28u;
    }

    /**
     * Clear DMA_CH3_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void clear_DMA_CH3_TX_CONTROL_EDSE() volatile
    {
        DMA_CH3_TX_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle DMA_CH3_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void toggle_DMA_CH3_TX_CONTROL_EDSE() volatile
    {
        DMA_CH3_TX_CONTROL ^= 1u << 28u;
    }

    /**
     * Get DMA_CH3_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH3_TX_CONTROL_TxPBL() volatile
    {
        return (DMA_CH3_TX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH3_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH3_TX_CONTROL_TxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH3_TX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH3_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline bool get_DMA_CH3_TX_CONTROL_IPBL() volatile
    {
        return DMA_CH3_TX_CONTROL & (1u << 15u);
    }

    /**
     * Set DMA_CH3_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void set_DMA_CH3_TX_CONTROL_IPBL() volatile
    {
        DMA_CH3_TX_CONTROL |= 1u << 15u;
    }

    /**
     * Clear DMA_CH3_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void clear_DMA_CH3_TX_CONTROL_IPBL() volatile
    {
        DMA_CH3_TX_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH3_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void toggle_DMA_CH3_TX_CONTROL_IPBL() volatile
    {
        DMA_CH3_TX_CONTROL ^= 1u << 15u;
    }

    /**
     * Get DMA_CH3_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline bool get_DMA_CH3_TX_CONTROL_OSF() volatile
    {
        return DMA_CH3_TX_CONTROL & (1u << 4u);
    }

    /**
     * Set DMA_CH3_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void set_DMA_CH3_TX_CONTROL_OSF() volatile
    {
        DMA_CH3_TX_CONTROL |= 1u << 4u;
    }

    /**
     * Clear DMA_CH3_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void clear_DMA_CH3_TX_CONTROL_OSF() volatile
    {
        DMA_CH3_TX_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle DMA_CH3_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void toggle_DMA_CH3_TX_CONTROL_OSF() volatile
    {
        DMA_CH3_TX_CONTROL ^= 1u << 4u;
    }

    /**
     * Get DMA_CH3_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline bool get_DMA_CH3_TX_CONTROL_ST() volatile
    {
        return DMA_CH3_TX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH3_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void set_DMA_CH3_TX_CONTROL_ST() volatile
    {
        DMA_CH3_TX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH3_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void clear_DMA_CH3_TX_CONTROL_ST() volatile
    {
        DMA_CH3_TX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH3_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void toggle_DMA_CH3_TX_CONTROL_ST() volatile
    {
        DMA_CH3_TX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH3_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 3 Transmit Control
     */
    inline void get_DMA_CH3_TX_CONTROL(bool &EDSE, uint8_t &TxPBL, bool &IPBL,
                                       bool &OSF, bool &ST) volatile
    {
        uint32_t curr = DMA_CH3_TX_CONTROL;

        EDSE = curr & (1u << 28u);
        TxPBL = (curr >> 16u) & 0b111111u;
        IPBL = curr & (1u << 15u);
        OSF = curr & (1u << 4u);
        ST = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH3_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 3 Transmit Control
     */
    inline void set_DMA_CH3_TX_CONTROL(bool EDSE, uint8_t TxPBL, bool IPBL,
                                       bool OSF, bool ST) volatile
    {
        uint32_t curr = DMA_CH3_TX_CONTROL;

        curr &= ~(0b1u << 28u);
        curr |= (EDSE & 0b1u) << 28u;
        curr &= ~(0b111111u << 16u);
        curr |= (TxPBL & 0b111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IPBL & 0b1u) << 15u;
        curr &= ~(0b1u << 4u);
        curr |= (OSF & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (ST & 0b1u) << 0u;

        DMA_CH3_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline bool get_DMA_CH3_RX_CONTROL_RPF() volatile
    {
        return DMA_CH3_RX_CONTROL & (1u << 31u);
    }

    /**
     * Set DMA_CH3_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void set_DMA_CH3_RX_CONTROL_RPF() volatile
    {
        DMA_CH3_RX_CONTROL |= 1u << 31u;
    }

    /**
     * Clear DMA_CH3_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void clear_DMA_CH3_RX_CONTROL_RPF() volatile
    {
        DMA_CH3_RX_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle DMA_CH3_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void toggle_DMA_CH3_RX_CONTROL_RPF() volatile
    {
        DMA_CH3_RX_CONTROL ^= 1u << 31u;
    }

    /**
     * Get DMA_CH3_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH3_RX_CONTROL_RxPBL() volatile
    {
        return (DMA_CH3_RX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH3_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH3_RX_CONTROL_RxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH3_RX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH3_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline uint16_t get_DMA_CH3_RX_CONTROL_RBSZ_13_y() volatile
    {
        return (DMA_CH3_RX_CONTROL >> 4u) & 0b11111111111u;
    }

    /**
     * Set DMA_CH3_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline void set_DMA_CH3_RX_CONTROL_RBSZ_13_y(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH3_RX_CONTROL;

        curr &= ~(0b11111111111u << 4u);
        curr |= (value & 0b11111111111u) << 4u;

        DMA_CH3_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_RX_CONTROL's RBSZ_x_0 field.
     *
     * Receive Buffer size Low RBSZ[13:0] is split into two fields RBSZ_13_y
     * and RBSZ_x_0.
     */
    inline uint8_t get_DMA_CH3_RX_CONTROL_RBSZ_x_0() volatile
    {
        return (DMA_CH3_RX_CONTROL >> 1u) & 0b111u;
    }

    /**
     * Get DMA_CH3_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline bool get_DMA_CH3_RX_CONTROL_SR() volatile
    {
        return DMA_CH3_RX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH3_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void set_DMA_CH3_RX_CONTROL_SR() volatile
    {
        DMA_CH3_RX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH3_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void clear_DMA_CH3_RX_CONTROL_SR() volatile
    {
        DMA_CH3_RX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH3_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void toggle_DMA_CH3_RX_CONTROL_SR() volatile
    {
        DMA_CH3_RX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH3_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 3 Receive Control
     */
    inline void get_DMA_CH3_RX_CONTROL(bool &RPF, uint8_t &RxPBL,
                                       uint16_t &RBSZ_13_y, uint8_t &RBSZ_x_0,
                                       bool &SR) volatile
    {
        uint32_t curr = DMA_CH3_RX_CONTROL;

        RPF = curr & (1u << 31u);
        RxPBL = (curr >> 16u) & 0b111111u;
        RBSZ_13_y = (curr >> 4u) & 0b11111111111u;
        RBSZ_x_0 = (curr >> 1u) & 0b111u;
        SR = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH3_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 3 Receive Control
     */
    inline void set_DMA_CH3_RX_CONTROL(bool RPF, uint8_t RxPBL,
                                       uint16_t RBSZ_13_y, bool SR) volatile
    {
        uint32_t curr = DMA_CH3_RX_CONTROL;

        curr &= ~(0b1u << 31u);
        curr |= (RPF & 0b1u) << 31u;
        curr &= ~(0b111111u << 16u);
        curr |= (RxPBL & 0b111111u) << 16u;
        curr &= ~(0b11111111111u << 4u);
        curr |= (RBSZ_13_y & 0b11111111111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (SR & 0b1u) << 0u;

        DMA_CH3_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH3_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline uint32_t get_DMA_CH3_TXDESC_LIST_ADDRESS_TDESLA() volatile
    {
        return (DMA_CH3_TXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH3_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline void set_DMA_CH3_TXDESC_LIST_ADDRESS_TDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH3_TXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH3_TXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH3_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline uint32_t get_DMA_CH3_RXDESC_LIST_ADDRESS_RDESLA() volatile
    {
        return (DMA_CH3_RXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH3_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline void set_DMA_CH3_RXDESC_LIST_ADDRESS_RDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH3_RXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH3_RXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH3_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline uint32_t get_DMA_CH3_TXDESC_TAIL_POINTER_TDTP() volatile
    {
        return (DMA_CH3_TXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH3_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline void set_DMA_CH3_TXDESC_TAIL_POINTER_TDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH3_TXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH3_TXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH3_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline uint32_t get_DMA_CH3_RXDESC_TAIL_POINTER_RDTP() volatile
    {
        return (DMA_CH3_RXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH3_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline void set_DMA_CH3_RXDESC_TAIL_POINTER_RDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH3_RXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH3_RXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH3_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH3_TXDESC_RING_LENGTH_TDRL() volatile
    {
        return (DMA_CH3_TXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH3_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH3_TXDESC_RING_LENGTH_TDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH3_TXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH3_TXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH3_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH3_RXDESC_RING_LENGTH_RDRL() volatile
    {
        return (DMA_CH3_RXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH3_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH3_RXDESC_RING_LENGTH_RDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH3_RXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH3_RXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_NIE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 15u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 15u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 15u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_AIE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 14u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 14u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 14u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_CDEE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 13u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 13u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 13u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_FBEE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 12u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 12u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 12u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_ERIE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 11u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 11u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 11u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_ETIE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 10u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 10u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 10u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_RWTE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 9u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 9u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 9u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_RSE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 8u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 8u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 8u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_RBUE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 7u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 7u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 7u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_RIE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 6u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 6u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 6u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_TBUE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 2u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 2u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 2u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_TXSE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 1u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 1u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 1u;
    }

    /**
     * Get DMA_CH3_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline bool get_DMA_CH3_INTERRUPT_ENABLE_TIE() volatile
    {
        return DMA_CH3_INTERRUPT_ENABLE & (1u << 0u);
    }

    /**
     * Set DMA_CH3_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE |= 1u << 0u;
    }

    /**
     * Clear DMA_CH3_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void clear_DMA_CH3_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH3_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void toggle_DMA_CH3_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH3_INTERRUPT_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH3_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 3 Interrupt Enable
     */
    inline void get_DMA_CH3_INTERRUPT_ENABLE(bool &NIE, bool &AIE, bool &CDEE,
                                             bool &FBEE, bool &ERIE,
                                             bool &ETIE, bool &RWTE, bool &RSE,
                                             bool &RBUE, bool &RIE, bool &TBUE,
                                             bool &TXSE, bool &TIE) volatile
    {
        uint32_t curr = DMA_CH3_INTERRUPT_ENABLE;

        NIE = curr & (1u << 15u);
        AIE = curr & (1u << 14u);
        CDEE = curr & (1u << 13u);
        FBEE = curr & (1u << 12u);
        ERIE = curr & (1u << 11u);
        ETIE = curr & (1u << 10u);
        RWTE = curr & (1u << 9u);
        RSE = curr & (1u << 8u);
        RBUE = curr & (1u << 7u);
        RIE = curr & (1u << 6u);
        TBUE = curr & (1u << 2u);
        TXSE = curr & (1u << 1u);
        TIE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH3_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 3 Interrupt Enable
     */
    inline void set_DMA_CH3_INTERRUPT_ENABLE(bool NIE, bool AIE, bool CDEE,
                                             bool FBEE, bool ERIE, bool ETIE,
                                             bool RWTE, bool RSE, bool RBUE,
                                             bool RIE, bool TBUE, bool TXSE,
                                             bool TIE) volatile
    {
        uint32_t curr = DMA_CH3_INTERRUPT_ENABLE;

        curr &= ~(0b1u << 15u);
        curr |= (NIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDEE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBEE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWTE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBUE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RIE & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TIE & 0b1u) << 0u;

        DMA_CH3_INTERRUPT_ENABLE = curr;
    }

    /**
     * Get DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline uint8_t get_DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER_RWTU() volatile
    {
        return (DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER >> 16u) & 0b11u;
    }

    /**
     * Set DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline void set_DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER_RWTU(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline uint8_t get_DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER_RWT() volatile
    {
        return (DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER >> 0u) & 0b11111111u;
    }

    /**
     * Set DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline void set_DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER_RWT(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get all of DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 3 Receive Interrupt Watchdog Time
     */
    inline void get_DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t &RWTU,
                                                        uint8_t &RWT) volatile
    {
        uint32_t curr = DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER;

        RWTU = (curr >> 16u) & 0b11u;
        RWT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 3 Receive Interrupt Watchdog Time
     */
    inline void set_DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t RWTU,
                                                        uint8_t RWT) volatile
    {
        uint32_t curr = DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (RWTU & 0b11u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RWT & 0b11111111u) << 0u;

        DMA_CH3_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's RSN field.
     *
     * Reference Slot Number This field gives the current value of the
     * reference slot number in the DMA.
     */
    inline uint8_t get_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_RSN() volatile
    {
        return (DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline uint16_t get_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_SIV() volatile
    {
        return (DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS >> 4u) & 0b111111111111u;
    }

    /**
     * Set DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline void set_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_SIV(
        uint16_t value) volatile
    {
        uint32_t curr = DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (value & 0b111111111111u) << 4u;

        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline bool get_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        return DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void set_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void clear_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void toggle_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline bool get_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        return DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void set_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void clear_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void toggle_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 3 Slot Function Control and Status
     */
    inline void get_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS(uint8_t &RSN,
                                                         uint16_t &SIV,
                                                         bool &ASC,
                                                         bool &ESC) volatile
    {
        uint32_t curr = DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS;

        RSN = (curr >> 16u) & 0b1111u;
        SIV = (curr >> 4u) & 0b111111111111u;
        ASC = curr & (1u << 1u);
        ESC = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 3 Slot Function Control and Status
     */
    inline void set_DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS(uint16_t SIV,
                                                         bool ASC,
                                                         bool ESC) volatile
    {
        uint32_t curr = DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (SIV & 0b111111111111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (ASC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ESC & 0b1u) << 0u;

        DMA_CH3_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH3_CURRENT_APP_TXDESC's CURTDESAPTR field.
     *
     * Application Transmit Descriptor Address Pointer The DMA updates this
     * pointer during Tx operation.
     */
    inline uint32_t get_DMA_CH3_CURRENT_APP_TXDESC_CURTDESAPTR() volatile
    {
        return (DMA_CH3_CURRENT_APP_TXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH3_CURRENT_APP_RXDESC's CURRDESAPTR field.
     *
     * Application Receive Descriptor Address Pointer The DMA updates this
     * pointer during Rx operation.
     */
    inline uint32_t get_DMA_CH3_CURRENT_APP_RXDESC_CURRDESAPTR() volatile
    {
        return (DMA_CH3_CURRENT_APP_RXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH3_CURRENT_APP_TXBUFFER's CURTBUFAPTR field.
     *
     * Application Transmit Buffer Address Pointer The DMA updates this pointer
     * during Tx operation.
     */
    inline uint32_t get_DMA_CH3_CURRENT_APP_TXBUFFER_CURTBUFAPTR() volatile
    {
        return (DMA_CH3_CURRENT_APP_TXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH3_CURRENT_APP_RXBUFFER's CURRBUFAPTR field.
     *
     * Application Receive Buffer Address Pointer The DMA updates this pointer
     * during Rx operation.
     */
    inline uint32_t get_DMA_CH3_CURRENT_APP_RXBUFFER_CURRBUFAPTR() volatile
    {
        return (DMA_CH3_CURRENT_APP_RXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH3_STATUS's REB field.
     *
     * Rx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH3_STATUS_REB() volatile
    {
        return (DMA_CH3_STATUS >> 19u) & 0b111u;
    }

    /**
     * Get DMA_CH3_STATUS's TEB field.
     *
     * Tx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH3_STATUS_TEB() volatile
    {
        return (DMA_CH3_STATUS >> 16u) & 0b111u;
    }

    /**
     * Get DMA_CH3_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH3_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline bool get_DMA_CH3_STATUS_NIS() volatile
    {
        return DMA_CH3_STATUS & (1u << 15u);
    }

    /**
     * Set DMA_CH3_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH3_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline void set_DMA_CH3_STATUS_NIS() volatile
    {
        DMA_CH3_STATUS |= 1u << 15u;
    }

    /**
     * Clear DMA_CH3_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH3_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline void clear_DMA_CH3_STATUS_NIS() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH3_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in
     * DMA_CH3_INTERRUPT_ENABLE register) affect the Normal Interrupt Summary
     * bit.
     */
    inline void toggle_DMA_CH3_STATUS_NIS() volatile
    {
        DMA_CH3_STATUS ^= 1u << 15u;
    }

    /**
     * Get DMA_CH3_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline bool get_DMA_CH3_STATUS_AIS() volatile
    {
        return DMA_CH3_STATUS & (1u << 14u);
    }

    /**
     * Set DMA_CH3_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline void set_DMA_CH3_STATUS_AIS() volatile
    {
        DMA_CH3_STATUS |= 1u << 14u;
    }

    /**
     * Clear DMA_CH3_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline void clear_DMA_CH3_STATUS_AIS() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH3_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the DMA_CH3_INTERRUPT_ENABLE register: - Bit 1: Transmit
     * Process Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive
     * Process Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus
     * Error - Bit 13: Context Descriptor Error Only unmasked bits affect the
     * Abnormal Interrupt Summary bit.
     */
    inline void toggle_DMA_CH3_STATUS_AIS() volatile
    {
        DMA_CH3_STATUS ^= 1u << 14u;
    }

    /**
     * Get DMA_CH3_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline bool get_DMA_CH3_STATUS_CDE() volatile
    {
        return DMA_CH3_STATUS & (1u << 13u);
    }

    /**
     * Set DMA_CH3_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void set_DMA_CH3_STATUS_CDE() volatile
    {
        DMA_CH3_STATUS |= 1u << 13u;
    }

    /**
     * Clear DMA_CH3_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void clear_DMA_CH3_STATUS_CDE() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH3_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void toggle_DMA_CH3_STATUS_CDE() volatile
    {
        DMA_CH3_STATUS ^= 1u << 13u;
    }

    /**
     * Get DMA_CH3_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline bool get_DMA_CH3_STATUS_FBE() volatile
    {
        return DMA_CH3_STATUS & (1u << 12u);
    }

    /**
     * Set DMA_CH3_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void set_DMA_CH3_STATUS_FBE() volatile
    {
        DMA_CH3_STATUS |= 1u << 12u;
    }

    /**
     * Clear DMA_CH3_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void clear_DMA_CH3_STATUS_FBE() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH3_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void toggle_DMA_CH3_STATUS_FBE() volatile
    {
        DMA_CH3_STATUS ^= 1u << 12u;
    }

    /**
     * Get DMA_CH3_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline bool get_DMA_CH3_STATUS_ERI() volatile
    {
        return DMA_CH3_STATUS & (1u << 11u);
    }

    /**
     * Set DMA_CH3_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void set_DMA_CH3_STATUS_ERI() volatile
    {
        DMA_CH3_STATUS |= 1u << 11u;
    }

    /**
     * Clear DMA_CH3_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void clear_DMA_CH3_STATUS_ERI() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH3_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void toggle_DMA_CH3_STATUS_ERI() volatile
    {
        DMA_CH3_STATUS ^= 1u << 11u;
    }

    /**
     * Get DMA_CH3_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline bool get_DMA_CH3_STATUS_ETI() volatile
    {
        return DMA_CH3_STATUS & (1u << 10u);
    }

    /**
     * Set DMA_CH3_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void set_DMA_CH3_STATUS_ETI() volatile
    {
        DMA_CH3_STATUS |= 1u << 10u;
    }

    /**
     * Clear DMA_CH3_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void clear_DMA_CH3_STATUS_ETI() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH3_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void toggle_DMA_CH3_STATUS_ETI() volatile
    {
        DMA_CH3_STATUS ^= 1u << 10u;
    }

    /**
     * Get DMA_CH3_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline bool get_DMA_CH3_STATUS_RWT() volatile
    {
        return DMA_CH3_STATUS & (1u << 9u);
    }

    /**
     * Set DMA_CH3_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void set_DMA_CH3_STATUS_RWT() volatile
    {
        DMA_CH3_STATUS |= 1u << 9u;
    }

    /**
     * Clear DMA_CH3_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void clear_DMA_CH3_STATUS_RWT() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH3_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void toggle_DMA_CH3_STATUS_RWT() volatile
    {
        DMA_CH3_STATUS ^= 1u << 9u;
    }

    /**
     * Get DMA_CH3_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline bool get_DMA_CH3_STATUS_RPS() volatile
    {
        return DMA_CH3_STATUS & (1u << 8u);
    }

    /**
     * Set DMA_CH3_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void set_DMA_CH3_STATUS_RPS() volatile
    {
        DMA_CH3_STATUS |= 1u << 8u;
    }

    /**
     * Clear DMA_CH3_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void clear_DMA_CH3_STATUS_RPS() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH3_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void toggle_DMA_CH3_STATUS_RPS() volatile
    {
        DMA_CH3_STATUS ^= 1u << 8u;
    }

    /**
     * Get DMA_CH3_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH3_STATUS_RBU() volatile
    {
        return DMA_CH3_STATUS & (1u << 7u);
    }

    /**
     * Set DMA_CH3_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH3_STATUS_RBU() volatile
    {
        DMA_CH3_STATUS |= 1u << 7u;
    }

    /**
     * Clear DMA_CH3_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH3_STATUS_RBU() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH3_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH3_STATUS_RBU() volatile
    {
        DMA_CH3_STATUS ^= 1u << 7u;
    }

    /**
     * Get DMA_CH3_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline bool get_DMA_CH3_STATUS_RI() volatile
    {
        return DMA_CH3_STATUS & (1u << 6u);
    }

    /**
     * Set DMA_CH3_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void set_DMA_CH3_STATUS_RI() volatile
    {
        DMA_CH3_STATUS |= 1u << 6u;
    }

    /**
     * Clear DMA_CH3_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void clear_DMA_CH3_STATUS_RI() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH3_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void toggle_DMA_CH3_STATUS_RI() volatile
    {
        DMA_CH3_STATUS ^= 1u << 6u;
    }

    /**
     * Get DMA_CH3_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH3_STATUS_TBU() volatile
    {
        return DMA_CH3_STATUS & (1u << 2u);
    }

    /**
     * Set DMA_CH3_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH3_STATUS_TBU() volatile
    {
        DMA_CH3_STATUS |= 1u << 2u;
    }

    /**
     * Clear DMA_CH3_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH3_STATUS_TBU() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH3_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH3_STATUS_TBU() volatile
    {
        DMA_CH3_STATUS ^= 1u << 2u;
    }

    /**
     * Get DMA_CH3_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline bool get_DMA_CH3_STATUS_TPS() volatile
    {
        return DMA_CH3_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH3_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void set_DMA_CH3_STATUS_TPS() volatile
    {
        DMA_CH3_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH3_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void clear_DMA_CH3_STATUS_TPS() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH3_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void toggle_DMA_CH3_STATUS_TPS() volatile
    {
        DMA_CH3_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH3_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline bool get_DMA_CH3_STATUS_TI() volatile
    {
        return DMA_CH3_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH3_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void set_DMA_CH3_STATUS_TI() volatile
    {
        DMA_CH3_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH3_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void clear_DMA_CH3_STATUS_TI() volatile
    {
        DMA_CH3_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH3_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void toggle_DMA_CH3_STATUS_TI() volatile
    {
        DMA_CH3_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH3_STATUS's bit fields.
     *
     * (read-write) DMA Channel 3 Status
     */
    inline void get_DMA_CH3_STATUS(uint8_t &REB, uint8_t &TEB, bool &NIS,
                                   bool &AIS, bool &CDE, bool &FBE, bool &ERI,
                                   bool &ETI, bool &RWT, bool &RPS, bool &RBU,
                                   bool &RI, bool &TBU, bool &TPS,
                                   bool &TI) volatile
    {
        uint32_t curr = DMA_CH3_STATUS;

        REB = (curr >> 19u) & 0b111u;
        TEB = (curr >> 16u) & 0b111u;
        NIS = curr & (1u << 15u);
        AIS = curr & (1u << 14u);
        CDE = curr & (1u << 13u);
        FBE = curr & (1u << 12u);
        ERI = curr & (1u << 11u);
        ETI = curr & (1u << 10u);
        RWT = curr & (1u << 9u);
        RPS = curr & (1u << 8u);
        RBU = curr & (1u << 7u);
        RI = curr & (1u << 6u);
        TBU = curr & (1u << 2u);
        TPS = curr & (1u << 1u);
        TI = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH3_STATUS's bit fields.
     *
     * (read-write) DMA Channel 3 Status
     */
    inline void set_DMA_CH3_STATUS(bool NIS, bool AIS, bool CDE, bool FBE,
                                   bool ERI, bool ETI, bool RWT, bool RPS,
                                   bool RBU, bool RI, bool TBU, bool TPS,
                                   bool TI) volatile
    {
        uint32_t curr = DMA_CH3_STATUS;

        curr &= ~(0b1u << 15u);
        curr |= (NIS & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERI & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETI & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RPS & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBU & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RI & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TI & 0b1u) << 0u;

        DMA_CH3_STATUS = curr;
    }

    /**
     * Get DMA_CH3_MISS_FRAME_CNT's MFCO bit.
     *
     * Overflow status of the MFC Counter When this bit is set then the MFC
     * counter does not get incremented further.
     */
    inline bool get_DMA_CH3_MISS_FRAME_CNT_MFCO() volatile
    {
        return DMA_CH3_MISS_FRAME_CNT & (1u << 15u);
    }

    /**
     * Get DMA_CH3_MISS_FRAME_CNT's MFC field.
     *
     * Dropped Packet Counters This counter indicates the number of packet
     * counters that are dropped by the DMA either because of bus error or
     * because of programming RPF field in RX_CONTROL register.
     */
    inline uint16_t get_DMA_CH3_MISS_FRAME_CNT_MFC() volatile
    {
        return (DMA_CH3_MISS_FRAME_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of DMA_CH3_MISS_FRAME_CNT's bit fields.
     *
     * (read-write) Channel 3 Missed Frame Counter
     */
    inline void get_DMA_CH3_MISS_FRAME_CNT(bool &MFCO, uint16_t &MFC) volatile
    {
        uint32_t curr = DMA_CH3_MISS_FRAME_CNT;

        MFCO = curr & (1u << 15u);
        MFC = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get DMA_CH3_RXP_ACCEPT_CNT's RXPACOF bit.
     *
     * Rx Parser Accept Counter Overflow Bit When set, this bit indicates that
     * the RXPAC Counter field crossed the maximum limit.
     */
    inline bool get_DMA_CH3_RXP_ACCEPT_CNT_RXPACOF() volatile
    {
        return DMA_CH3_RXP_ACCEPT_CNT & (1u << 31u);
    }

    /**
     * Get DMA_CH3_RXP_ACCEPT_CNT's RXPAC field.
     *
     * Rx Parser Accept Counter This 31-bit counter is implemented whenever a
     * Rx Parser Accept a packet due to AF =1.
     */
    inline uint32_t get_DMA_CH3_RXP_ACCEPT_CNT_RXPAC() volatile
    {
        return (DMA_CH3_RXP_ACCEPT_CNT >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get all of DMA_CH3_RXP_ACCEPT_CNT's bit fields.
     *
     * (read-write) Channel 3 RXP Frames Accepted Counter
     */
    inline void get_DMA_CH3_RXP_ACCEPT_CNT(bool &RXPACOF,
                                           uint32_t &RXPAC) volatile
    {
        uint32_t curr = DMA_CH3_RXP_ACCEPT_CNT;

        RXPACOF = curr & (1u << 31u);
        RXPAC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH3_RX_ERI_CNT's ECNT field.
     *
     * ERI Counter When ERIC bit of DMA_CH3_RX_CONTROL register is set, this
     * counter increments for burst transfer completed by the Rx DMA from the
     * start of packet transfer.
     */
    inline uint16_t get_DMA_CH3_RX_ERI_CNT_ECNT() volatile
    {
        return (DMA_CH3_RX_ERI_CNT >> 0u) & 0b111111111111u;
    }

    /**
     * Get DMA_CH4_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline uint8_t get_DMA_CH4_CONTROL_DSL() volatile
    {
        return (DMA_CH4_CONTROL >> 18u) & 0b111u;
    }

    /**
     * Set DMA_CH4_CONTROL's DSL field.
     *
     * Descriptor Skip Length This bit specifies the Word, Dword, or Lword
     * number (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between
     * two unchained descriptors.
     */
    inline void set_DMA_CH4_CONTROL_DSL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH4_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DMA_CH4_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH4_TX_CONTROL and Bits[21:16] in DMA_CH4_RX_CONTROL is
     * multiplied by eight times.
     */
    inline bool get_DMA_CH4_CONTROL_PBLx8() volatile
    {
        return DMA_CH4_CONTROL & (1u << 16u);
    }

    /**
     * Set DMA_CH4_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH4_TX_CONTROL and Bits[21:16] in DMA_CH4_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void set_DMA_CH4_CONTROL_PBLx8() volatile
    {
        DMA_CH4_CONTROL |= 1u << 16u;
    }

    /**
     * Clear DMA_CH4_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH4_TX_CONTROL and Bits[21:16] in DMA_CH4_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void clear_DMA_CH4_CONTROL_PBLx8() volatile
    {
        DMA_CH4_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle DMA_CH4_CONTROL's PBLx8 bit.
     *
     * 8xPBL mode When this bit is set, the PBL value programmed in Bits[21:16]
     * in DMA_CH4_TX_CONTROL and Bits[21:16] in DMA_CH4_RX_CONTROL is
     * multiplied by eight times.
     */
    inline void toggle_DMA_CH4_CONTROL_PBLx8() volatile
    {
        DMA_CH4_CONTROL ^= 1u << 16u;
    }

    /**
     * Get all of DMA_CH4_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 4 Control
     */
    inline void get_DMA_CH4_CONTROL(uint8_t &DSL, bool &PBLx8) volatile
    {
        uint32_t curr = DMA_CH4_CONTROL;

        DSL = (curr >> 18u) & 0b111u;
        PBLx8 = curr & (1u << 16u);
    }

    /**
     * Set all of DMA_CH4_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 4 Control
     */
    inline void set_DMA_CH4_CONTROL(uint8_t DSL, bool PBLx8) volatile
    {
        uint32_t curr = DMA_CH4_CONTROL;

        curr &= ~(0b111u << 18u);
        curr |= (DSL & 0b111u) << 18u;
        curr &= ~(0b1u << 16u);
        curr |= (PBLx8 & 0b1u) << 16u;

        DMA_CH4_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline bool get_DMA_CH4_TX_CONTROL_EDSE() volatile
    {
        return DMA_CH4_TX_CONTROL & (1u << 28u);
    }

    /**
     * Set DMA_CH4_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void set_DMA_CH4_TX_CONTROL_EDSE() volatile
    {
        DMA_CH4_TX_CONTROL |= 1u << 28u;
    }

    /**
     * Clear DMA_CH4_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void clear_DMA_CH4_TX_CONTROL_EDSE() volatile
    {
        DMA_CH4_TX_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle DMA_CH4_TX_CONTROL's EDSE bit.
     *
     * Enhanced Descriptor Enable When this bit is set, the corresponding
     * channel uses Enhanced Descriptors that are 32 Bytes for both Normal and
     * Context Descriptors.
     */
    inline void toggle_DMA_CH4_TX_CONTROL_EDSE() volatile
    {
        DMA_CH4_TX_CONTROL ^= 1u << 28u;
    }

    /**
     * Get DMA_CH4_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH4_TX_CONTROL_TxPBL() volatile
    {
        return (DMA_CH4_TX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH4_TX_CONTROL's TxPBL field.
     *
     * Transmit Programmable Burst Length These bits indicate the maximum
     * number of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH4_TX_CONTROL_TxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH4_TX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH4_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline bool get_DMA_CH4_TX_CONTROL_IPBL() volatile
    {
        return DMA_CH4_TX_CONTROL & (1u << 15u);
    }

    /**
     * Set DMA_CH4_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void set_DMA_CH4_TX_CONTROL_IPBL() volatile
    {
        DMA_CH4_TX_CONTROL |= 1u << 15u;
    }

    /**
     * Clear DMA_CH4_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void clear_DMA_CH4_TX_CONTROL_IPBL() volatile
    {
        DMA_CH4_TX_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH4_TX_CONTROL's IPBL bit.
     *
     * Ignore PBL Requirement When this bit is set, the DMA does not check for
     * PBL number of locations in the MTL before initiating a transfer.
     */
    inline void toggle_DMA_CH4_TX_CONTROL_IPBL() volatile
    {
        DMA_CH4_TX_CONTROL ^= 1u << 15u;
    }

    /**
     * Get DMA_CH4_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline bool get_DMA_CH4_TX_CONTROL_OSF() volatile
    {
        return DMA_CH4_TX_CONTROL & (1u << 4u);
    }

    /**
     * Set DMA_CH4_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void set_DMA_CH4_TX_CONTROL_OSF() volatile
    {
        DMA_CH4_TX_CONTROL |= 1u << 4u;
    }

    /**
     * Clear DMA_CH4_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void clear_DMA_CH4_TX_CONTROL_OSF() volatile
    {
        DMA_CH4_TX_CONTROL &= ~(1u << 4u);
    }

    /**
     * Toggle DMA_CH4_TX_CONTROL's OSF bit.
     *
     * Operate on Second Packet When this bit is set, it instructs the DMA to
     * process the second packet of the Transmit data even before the status
     * for the first packet is obtained.
     */
    inline void toggle_DMA_CH4_TX_CONTROL_OSF() volatile
    {
        DMA_CH4_TX_CONTROL ^= 1u << 4u;
    }

    /**
     * Get DMA_CH4_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline bool get_DMA_CH4_TX_CONTROL_ST() volatile
    {
        return DMA_CH4_TX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH4_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void set_DMA_CH4_TX_CONTROL_ST() volatile
    {
        DMA_CH4_TX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH4_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void clear_DMA_CH4_TX_CONTROL_ST() volatile
    {
        DMA_CH4_TX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH4_TX_CONTROL's ST bit.
     *
     * Start or Stop Transmission Command When this bit is set, transmission is
     * placed in the Running state.
     */
    inline void toggle_DMA_CH4_TX_CONTROL_ST() volatile
    {
        DMA_CH4_TX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH4_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 4 Transmit Control
     */
    inline void get_DMA_CH4_TX_CONTROL(bool &EDSE, uint8_t &TxPBL, bool &IPBL,
                                       bool &OSF, bool &ST) volatile
    {
        uint32_t curr = DMA_CH4_TX_CONTROL;

        EDSE = curr & (1u << 28u);
        TxPBL = (curr >> 16u) & 0b111111u;
        IPBL = curr & (1u << 15u);
        OSF = curr & (1u << 4u);
        ST = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH4_TX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 4 Transmit Control
     */
    inline void set_DMA_CH4_TX_CONTROL(bool EDSE, uint8_t TxPBL, bool IPBL,
                                       bool OSF, bool ST) volatile
    {
        uint32_t curr = DMA_CH4_TX_CONTROL;

        curr &= ~(0b1u << 28u);
        curr |= (EDSE & 0b1u) << 28u;
        curr &= ~(0b111111u << 16u);
        curr |= (TxPBL & 0b111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IPBL & 0b1u) << 15u;
        curr &= ~(0b1u << 4u);
        curr |= (OSF & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (ST & 0b1u) << 0u;

        DMA_CH4_TX_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline bool get_DMA_CH4_RX_CONTROL_RPF() volatile
    {
        return DMA_CH4_RX_CONTROL & (1u << 31u);
    }

    /**
     * Set DMA_CH4_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void set_DMA_CH4_RX_CONTROL_RPF() volatile
    {
        DMA_CH4_RX_CONTROL |= 1u << 31u;
    }

    /**
     * Clear DMA_CH4_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void clear_DMA_CH4_RX_CONTROL_RPF() volatile
    {
        DMA_CH4_RX_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle DMA_CH4_RX_CONTROL's RPF bit.
     *
     * Rx Packet Flush.
     */
    inline void toggle_DMA_CH4_RX_CONTROL_RPF() volatile
    {
        DMA_CH4_RX_CONTROL ^= 1u << 31u;
    }

    /**
     * Get DMA_CH4_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline uint8_t get_DMA_CH4_RX_CONTROL_RxPBL() volatile
    {
        return (DMA_CH4_RX_CONTROL >> 16u) & 0b111111u;
    }

    /**
     * Set DMA_CH4_RX_CONTROL's RxPBL field.
     *
     * Receive Programmable Burst Length These bits indicate the maximum number
     * of beats to be transferred in one DMA block data transfer.
     */
    inline void set_DMA_CH4_RX_CONTROL_RxPBL(uint8_t value) volatile
    {
        uint32_t curr = DMA_CH4_RX_CONTROL;

        curr &= ~(0b111111u << 16u);
        curr |= (value & 0b111111u) << 16u;

        DMA_CH4_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline uint16_t get_DMA_CH4_RX_CONTROL_RBSZ_13_y() volatile
    {
        return (DMA_CH4_RX_CONTROL >> 4u) & 0b11111111111u;
    }

    /**
     * Set DMA_CH4_RX_CONTROL's RBSZ_13_y field.
     *
     * Receive Buffer size High RBSZ[13:0] is split into two fields higher
     * RBSZ_13_y and lower RBSZ_x_0.
     */
    inline void set_DMA_CH4_RX_CONTROL_RBSZ_13_y(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH4_RX_CONTROL;

        curr &= ~(0b11111111111u << 4u);
        curr |= (value & 0b11111111111u) << 4u;

        DMA_CH4_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_RX_CONTROL's RBSZ_x_0 field.
     *
     * Receive Buffer size Low RBSZ[13:0] is split into two fields RBSZ_13_y
     * and RBSZ_x_0.
     */
    inline uint8_t get_DMA_CH4_RX_CONTROL_RBSZ_x_0() volatile
    {
        return (DMA_CH4_RX_CONTROL >> 1u) & 0b111u;
    }

    /**
     * Get DMA_CH4_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline bool get_DMA_CH4_RX_CONTROL_SR() volatile
    {
        return DMA_CH4_RX_CONTROL & (1u << 0u);
    }

    /**
     * Set DMA_CH4_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void set_DMA_CH4_RX_CONTROL_SR() volatile
    {
        DMA_CH4_RX_CONTROL |= 1u << 0u;
    }

    /**
     * Clear DMA_CH4_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void clear_DMA_CH4_RX_CONTROL_SR() volatile
    {
        DMA_CH4_RX_CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH4_RX_CONTROL's SR bit.
     *
     * Start or Stop Receive When this bit is set, the DMA tries to acquire the
     * descriptor from the Receive list and processes the incoming packets.
     */
    inline void toggle_DMA_CH4_RX_CONTROL_SR() volatile
    {
        DMA_CH4_RX_CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH4_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 4 Receive Control
     */
    inline void get_DMA_CH4_RX_CONTROL(bool &RPF, uint8_t &RxPBL,
                                       uint16_t &RBSZ_13_y, uint8_t &RBSZ_x_0,
                                       bool &SR) volatile
    {
        uint32_t curr = DMA_CH4_RX_CONTROL;

        RPF = curr & (1u << 31u);
        RxPBL = (curr >> 16u) & 0b111111u;
        RBSZ_13_y = (curr >> 4u) & 0b11111111111u;
        RBSZ_x_0 = (curr >> 1u) & 0b111u;
        SR = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH4_RX_CONTROL's bit fields.
     *
     * (read-write) DMA Channel 4 Receive Control
     */
    inline void set_DMA_CH4_RX_CONTROL(bool RPF, uint8_t RxPBL,
                                       uint16_t RBSZ_13_y, bool SR) volatile
    {
        uint32_t curr = DMA_CH4_RX_CONTROL;

        curr &= ~(0b1u << 31u);
        curr |= (RPF & 0b1u) << 31u;
        curr &= ~(0b111111u << 16u);
        curr |= (RxPBL & 0b111111u) << 16u;
        curr &= ~(0b11111111111u << 4u);
        curr |= (RBSZ_13_y & 0b11111111111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (SR & 0b1u) << 0u;

        DMA_CH4_RX_CONTROL = curr;
    }

    /**
     * Get DMA_CH4_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline uint32_t get_DMA_CH4_TXDESC_LIST_ADDRESS_TDESLA() volatile
    {
        return (DMA_CH4_TXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH4_TXDESC_LIST_ADDRESS's TDESLA field.
     *
     * Start of Transmit List This field contains the base address of the first
     * descriptor in the Transmit descriptor list.
     */
    inline void set_DMA_CH4_TXDESC_LIST_ADDRESS_TDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH4_TXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH4_TXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH4_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline uint32_t get_DMA_CH4_RXDESC_LIST_ADDRESS_RDESLA() volatile
    {
        return (DMA_CH4_RXDESC_LIST_ADDRESS >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH4_RXDESC_LIST_ADDRESS's RDESLA field.
     *
     * Start of Receive List This field contains the base address of the first
     * descriptor in the Rx Descriptor list.
     */
    inline void set_DMA_CH4_RXDESC_LIST_ADDRESS_RDESLA(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH4_RXDESC_LIST_ADDRESS;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH4_RXDESC_LIST_ADDRESS = curr;
    }

    /**
     * Get DMA_CH4_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline uint32_t get_DMA_CH4_TXDESC_TAIL_POINTER_TDTP() volatile
    {
        return (DMA_CH4_TXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH4_TXDESC_TAIL_POINTER's TDTP field.
     *
     * Transmit Descriptor Tail Pointer This field contains the tail pointer
     * for the Tx descriptor ring.
     */
    inline void set_DMA_CH4_TXDESC_TAIL_POINTER_TDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH4_TXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH4_TXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH4_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline uint32_t get_DMA_CH4_RXDESC_TAIL_POINTER_RDTP() volatile
    {
        return (DMA_CH4_RXDESC_TAIL_POINTER >> 3u) &
               0b11111111111111111111111111111u;
    }

    /**
     * Set DMA_CH4_RXDESC_TAIL_POINTER's RDTP field.
     *
     * Receive Descriptor Tail Pointer This field contains the tail pointer for
     * the Rx descriptor ring.
     */
    inline void set_DMA_CH4_RXDESC_TAIL_POINTER_RDTP(uint32_t value) volatile
    {
        uint32_t curr = DMA_CH4_RXDESC_TAIL_POINTER;

        curr &= ~(0b11111111111111111111111111111u << 3u);
        curr |= (value & 0b11111111111111111111111111111u) << 3u;

        DMA_CH4_RXDESC_TAIL_POINTER = curr;
    }

    /**
     * Get DMA_CH4_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH4_TXDESC_RING_LENGTH_TDRL() volatile
    {
        return (DMA_CH4_TXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH4_TXDESC_RING_LENGTH's TDRL field.
     *
     * Transmit Descriptor Ring Length This field sets the maximum number of Tx
     * descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH4_TXDESC_RING_LENGTH_TDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH4_TXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH4_TXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH4_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline uint16_t get_DMA_CH4_RXDESC_RING_LENGTH_RDRL() volatile
    {
        return (DMA_CH4_RXDESC_RING_LENGTH >> 0u) & 0b1111111111u;
    }

    /**
     * Set DMA_CH4_RXDESC_RING_LENGTH's RDRL field.
     *
     * Receive Descriptor Ring Length This register sets the maximum number of
     * Rx descriptors in the circular descriptor ring.
     */
    inline void set_DMA_CH4_RXDESC_RING_LENGTH_RDRL(uint16_t value) volatile
    {
        uint32_t curr = DMA_CH4_RXDESC_RING_LENGTH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        DMA_CH4_RXDESC_RING_LENGTH = curr;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_NIE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 15u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 15u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's NIE bit.
     *
     * Normal Interrupt Summary Enable When this bit is set, the normal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_NIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 15u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_AIE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 14u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 14u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's AIE bit.
     *
     * Abnormal Interrupt Summary Enable When this bit is set, the abnormal
     * interrupt summary is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_AIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 14u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_CDEE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 13u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 13u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's CDEE bit.
     *
     * Context Descriptor Error Enable When this bit is set along with the AIE
     * bit, the Descriptor error interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_CDEE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 13u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_FBEE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 12u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 12u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's FBEE bit.
     *
     * Fatal Bus Error Enable When this bit is set along with the AIE bit, the
     * Fatal Bus error interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_FBEE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 12u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_ERIE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 11u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 11u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's ERIE bit.
     *
     * Early Receive Interrupt Enable When this bit is set along with the NIE
     * bit, the Early Receive interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_ERIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 11u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_ETIE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 10u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 10u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's ETIE bit.
     *
     * Early Transmit Interrupt Enable When this bit is set along with the AIE
     * bit, the Early Transmit interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_ETIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 10u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_RWTE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 9u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 9u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's RWTE bit.
     *
     * Receive Watchdog Timeout Enable When this bit is set along with the AIE
     * bit, the Receive Watchdog Timeout interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_RWTE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 9u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_RSE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 8u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 8u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's RSE bit.
     *
     * Receive Stopped Enable When this bit is set along with the AIE bit, the
     * Receive Stopped Interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_RSE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 8u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_RBUE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 7u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 7u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's RBUE bit.
     *
     * Receive Buffer Unavailable Enable When this bit is set along with the
     * AIE bit, the Receive Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_RBUE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 7u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_RIE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 6u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 6u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's RIE bit.
     *
     * Receive Interrupt Enable When this bit is set along with the NIE bit,
     * the Receive Interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_RIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 6u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_TBUE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 2u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 2u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's TBUE bit.
     *
     * Transmit Buffer Unavailable Enable When this bit is set along with the
     * NIE bit, the Transmit Buffer Unavailable interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_TBUE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 2u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_TXSE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 1u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 1u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's TXSE bit.
     *
     * Transmit Stopped Enable When this bit is set along with the AIE bit, the
     * Transmission Stopped interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_TXSE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 1u;
    }

    /**
     * Get DMA_CH4_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline bool get_DMA_CH4_INTERRUPT_ENABLE_TIE() volatile
    {
        return DMA_CH4_INTERRUPT_ENABLE & (1u << 0u);
    }

    /**
     * Set DMA_CH4_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE |= 1u << 0u;
    }

    /**
     * Clear DMA_CH4_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void clear_DMA_CH4_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH4_INTERRUPT_ENABLE's TIE bit.
     *
     * Transmit Interrupt Enable When this bit is set along with the NIE bit,
     * the Transmit Interrupt is enabled.
     */
    inline void toggle_DMA_CH4_INTERRUPT_ENABLE_TIE() volatile
    {
        DMA_CH4_INTERRUPT_ENABLE ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH4_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 4 Interrupt Enable
     */
    inline void get_DMA_CH4_INTERRUPT_ENABLE(bool &NIE, bool &AIE, bool &CDEE,
                                             bool &FBEE, bool &ERIE,
                                             bool &ETIE, bool &RWTE, bool &RSE,
                                             bool &RBUE, bool &RIE, bool &TBUE,
                                             bool &TXSE, bool &TIE) volatile
    {
        uint32_t curr = DMA_CH4_INTERRUPT_ENABLE;

        NIE = curr & (1u << 15u);
        AIE = curr & (1u << 14u);
        CDEE = curr & (1u << 13u);
        FBEE = curr & (1u << 12u);
        ERIE = curr & (1u << 11u);
        ETIE = curr & (1u << 10u);
        RWTE = curr & (1u << 9u);
        RSE = curr & (1u << 8u);
        RBUE = curr & (1u << 7u);
        RIE = curr & (1u << 6u);
        TBUE = curr & (1u << 2u);
        TXSE = curr & (1u << 1u);
        TIE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH4_INTERRUPT_ENABLE's bit fields.
     *
     * (read-write) Channel 4 Interrupt Enable
     */
    inline void set_DMA_CH4_INTERRUPT_ENABLE(bool NIE, bool AIE, bool CDEE,
                                             bool FBEE, bool ERIE, bool ETIE,
                                             bool RWTE, bool RSE, bool RBUE,
                                             bool RIE, bool TBUE, bool TXSE,
                                             bool TIE) volatile
    {
        uint32_t curr = DMA_CH4_INTERRUPT_ENABLE;

        curr &= ~(0b1u << 15u);
        curr |= (NIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDEE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBEE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWTE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RSE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBUE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RIE & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TIE & 0b1u) << 0u;

        DMA_CH4_INTERRUPT_ENABLE = curr;
    }

    /**
     * Get DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline uint8_t get_DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER_RWTU() volatile
    {
        return (DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER >> 16u) & 0b11u;
    }

    /**
     * Set DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER's RWTU field.
     *
     * Receive Interrupt Watchdog Timer Count Units This fields indicates the
     * number of system clock cycles corresponding to one unit in RWT field.
     */
    inline void set_DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER_RWTU(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline uint8_t get_DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER_RWT() volatile
    {
        return (DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER >> 0u) & 0b11111111u;
    }

    /**
     * Set DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER's RWT field.
     *
     * Receive Interrupt Watchdog Timer Count This field indicates the number
     * of system clock cycles, multiplied by factor indicated in RWTU field,
     * for which the watchdog timer is set.
     */
    inline void set_DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER_RWT(
        uint8_t value) volatile
    {
        uint32_t curr = DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get all of DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 4 Receive Interrupt Watchdog Timer
     */
    inline void get_DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t &RWTU,
                                                        uint8_t &RWT) volatile
    {
        uint32_t curr = DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER;

        RWTU = (curr >> 16u) & 0b11u;
        RWT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER's bit fields.
     *
     * (read-write) Channel 4 Receive Interrupt Watchdog Timer
     */
    inline void set_DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER(uint8_t RWTU,
                                                        uint8_t RWT) volatile
    {
        uint32_t curr = DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER;

        curr &= ~(0b11u << 16u);
        curr |= (RWTU & 0b11u) << 16u;
        curr &= ~(0b11111111u << 0u);
        curr |= (RWT & 0b11111111u) << 0u;

        DMA_CH4_RX_INTERRUPT_WATCHDOG_TIMER = curr;
    }

    /**
     * Get DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's RSN field.
     *
     * Reference Slot Number This field gives the current value of the
     * reference slot number in the DMA.
     */
    inline uint8_t get_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_RSN() volatile
    {
        return (DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline uint16_t get_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_SIV() volatile
    {
        return (DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS >> 4u) & 0b111111111111u;
    }

    /**
     * Set DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's SIV field.
     *
     * Slot Interval Value This field controls the period of the slot interval
     * in which the TxDMA fetches the scheduled packets.
     */
    inline void set_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_SIV(
        uint16_t value) volatile
    {
        uint32_t curr = DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (value & 0b111111111111u) << 4u;

        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline bool get_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        return DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void set_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void clear_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ASC bit.
     *
     * Advance Slot Check When set, this bit enables the DMA to fetch the data
     * from the buffer when the slot number (SLOTNUM) programmed in the Tx
     * descriptor is - equal to the reference slot number given in the RSN
     * field or - ahead of the reference slot number by up to two slots This
     * bit is applicable only when the ESC bit is set.
     */
    inline void toggle_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ASC() volatile
    {
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline bool get_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        return DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void set_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void clear_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's ESC bit.
     *
     * Enable Slot Comparison When set, this bit enables the checking of the
     * slot numbers programmed in the Tx descriptor with the current reference
     * given in the RSN field.
     */
    inline void toggle_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS_ESC() volatile
    {
        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 4 Slot Function Control and Status
     */
    inline void get_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS(uint8_t &RSN,
                                                         uint16_t &SIV,
                                                         bool &ASC,
                                                         bool &ESC) volatile
    {
        uint32_t curr = DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS;

        RSN = (curr >> 16u) & 0b1111u;
        SIV = (curr >> 4u) & 0b111111111111u;
        ASC = curr & (1u << 1u);
        ESC = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS's bit fields.
     *
     * (read-write) Channel 4 Slot Function Control and Status
     */
    inline void set_DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS(uint16_t SIV,
                                                         bool ASC,
                                                         bool ESC) volatile
    {
        uint32_t curr = DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS;

        curr &= ~(0b111111111111u << 4u);
        curr |= (SIV & 0b111111111111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (ASC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ESC & 0b1u) << 0u;

        DMA_CH4_SLOT_FUNCTION_CONTROL_STATUS = curr;
    }

    /**
     * Get DMA_CH4_CURRENT_APP_TXDESC's CURTDESAPTR field.
     *
     * Application Transmit Descriptor Address Pointer The DMA updates this
     * pointer during Tx operation.
     */
    inline uint32_t get_DMA_CH4_CURRENT_APP_TXDESC_CURTDESAPTR() volatile
    {
        return (DMA_CH4_CURRENT_APP_TXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH4_CURRENT_APP_RXDESC's CURRDESAPTR field.
     *
     * Application Receive Descriptor Address Pointer The DMA updates this
     * pointer during Rx operation.
     */
    inline uint32_t get_DMA_CH4_CURRENT_APP_RXDESC_CURRDESAPTR() volatile
    {
        return (DMA_CH4_CURRENT_APP_RXDESC >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH4_CURRENT_APP_TXBUFFER's CURTBUFAPTR field.
     *
     * Application Transmit Buffer Address Pointer The DMA updates this pointer
     * during Tx operation.
     */
    inline uint32_t get_DMA_CH4_CURRENT_APP_TXBUFFER_CURTBUFAPTR() volatile
    {
        return (DMA_CH4_CURRENT_APP_TXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH4_CURRENT_APP_RXBUFFER's CURRBUFAPTR field.
     *
     * Application Receive Buffer Address Pointer The DMA updates this pointer
     * during Rx operation.
     */
    inline uint32_t get_DMA_CH4_CURRENT_APP_RXBUFFER_CURRBUFAPTR() volatile
    {
        return (DMA_CH4_CURRENT_APP_RXBUFFER >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH4_STATUS's REB field.
     *
     * Rx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH4_STATUS_REB() volatile
    {
        return (DMA_CH4_STATUS >> 19u) & 0b111u;
    }

    /**
     * Get DMA_CH4_STATUS's TEB field.
     *
     * Tx DMA Error Bits This field indicates the type of error that caused a
     * Bus Error.
     */
    inline uint8_t get_DMA_CH4_STATUS_TEB() volatile
    {
        return (DMA_CH4_STATUS >> 16u) & 0b111u;
    }

    /**
     * Get DMA_CH4_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline bool get_DMA_CH4_STATUS_NIS() volatile
    {
        return DMA_CH4_STATUS & (1u << 15u);
    }

    /**
     * Set DMA_CH4_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void set_DMA_CH4_STATUS_NIS() volatile
    {
        DMA_CH4_STATUS |= 1u << 15u;
    }

    /**
     * Clear DMA_CH4_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void clear_DMA_CH4_STATUS_NIS() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 15u);
    }

    /**
     * Toggle DMA_CH4_STATUS's NIS bit.
     *
     * Normal Interrupt Summary Normal Interrupt Summary bit value is the
     * logical OR of the following bits when the corresponding interrupt bits
     * are enabled in the INTERRUPT_ENABLE register: - Bit 0: Transmit
     * Interrupt - Bit 2: Transmit Buffer Unavailable - Bit 6: Receive
     * Interrupt - Bit 11: Early Receive Interrupt Only unmasked bits
     * (interrupts for which interrupt enable is set in INTERRUPT_ENABLE
     * register) affect the Normal Interrupt Summary bit.
     */
    inline void toggle_DMA_CH4_STATUS_NIS() volatile
    {
        DMA_CH4_STATUS ^= 1u << 15u;
    }

    /**
     * Get DMA_CH4_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline bool get_DMA_CH4_STATUS_AIS() volatile
    {
        return DMA_CH4_STATUS & (1u << 14u);
    }

    /**
     * Set DMA_CH4_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void set_DMA_CH4_STATUS_AIS() volatile
    {
        DMA_CH4_STATUS |= 1u << 14u;
    }

    /**
     * Clear DMA_CH4_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void clear_DMA_CH4_STATUS_AIS() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle DMA_CH4_STATUS's AIS bit.
     *
     * Abnormal Interrupt Summary Abnormal Interrupt Summary bit value is the
     * logical OR of the following when the corresponding interrupt bits are
     * enabled in the INTERRUPT_ENABLE register: - Bit 1: Transmit Process
     * Stopped - Bit 7: Receive Buffer Unavailable - Bit 8: Receive Process
     * Stopped - Bit 10: Early Transmit Interrupt - Bit 12: Fatal Bus Error -
     * Bit 13: Context Descriptor Error Only unmasked bits affect the Abnormal
     * Interrupt Summary bit.
     */
    inline void toggle_DMA_CH4_STATUS_AIS() volatile
    {
        DMA_CH4_STATUS ^= 1u << 14u;
    }

    /**
     * Get DMA_CH4_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline bool get_DMA_CH4_STATUS_CDE() volatile
    {
        return DMA_CH4_STATUS & (1u << 13u);
    }

    /**
     * Set DMA_CH4_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void set_DMA_CH4_STATUS_CDE() volatile
    {
        DMA_CH4_STATUS |= 1u << 13u;
    }

    /**
     * Clear DMA_CH4_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void clear_DMA_CH4_STATUS_CDE() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle DMA_CH4_STATUS's CDE bit.
     *
     * Context Descriptor Error This bit indicates that the DMA Tx/Rx engine
     * received a descriptor error, which indicates invalid context in the
     * middle of packet flow ( intermediate descriptor) or all one's descriptor
     * in Tx case and on Rx side it indicates DMA has read a descriptor with
     * either of the buffer address as ones which is considered to be invalid.
     */
    inline void toggle_DMA_CH4_STATUS_CDE() volatile
    {
        DMA_CH4_STATUS ^= 1u << 13u;
    }

    /**
     * Get DMA_CH4_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline bool get_DMA_CH4_STATUS_FBE() volatile
    {
        return DMA_CH4_STATUS & (1u << 12u);
    }

    /**
     * Set DMA_CH4_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void set_DMA_CH4_STATUS_FBE() volatile
    {
        DMA_CH4_STATUS |= 1u << 12u;
    }

    /**
     * Clear DMA_CH4_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void clear_DMA_CH4_STATUS_FBE() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle DMA_CH4_STATUS's FBE bit.
     *
     * Fatal Bus Error This bit indicates that a bus error occurred (as
     * described in the EB field).
     */
    inline void toggle_DMA_CH4_STATUS_FBE() volatile
    {
        DMA_CH4_STATUS ^= 1u << 12u;
    }

    /**
     * Get DMA_CH4_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline bool get_DMA_CH4_STATUS_ERI() volatile
    {
        return DMA_CH4_STATUS & (1u << 11u);
    }

    /**
     * Set DMA_CH4_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void set_DMA_CH4_STATUS_ERI() volatile
    {
        DMA_CH4_STATUS |= 1u << 11u;
    }

    /**
     * Clear DMA_CH4_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void clear_DMA_CH4_STATUS_ERI() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle DMA_CH4_STATUS's ERI bit.
     *
     * Early Receive Interrupt This bit when set indicates that the RxDMA has
     * completed the transfer of packet data to the memory.
     */
    inline void toggle_DMA_CH4_STATUS_ERI() volatile
    {
        DMA_CH4_STATUS ^= 1u << 11u;
    }

    /**
     * Get DMA_CH4_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline bool get_DMA_CH4_STATUS_ETI() volatile
    {
        return DMA_CH4_STATUS & (1u << 10u);
    }

    /**
     * Set DMA_CH4_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void set_DMA_CH4_STATUS_ETI() volatile
    {
        DMA_CH4_STATUS |= 1u << 10u;
    }

    /**
     * Clear DMA_CH4_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void clear_DMA_CH4_STATUS_ETI() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle DMA_CH4_STATUS's ETI bit.
     *
     * Early Transmit Interrupt This bit when set indicates that the TxDMA has
     * completed the transfer of packet data to the MTL TXFIFO memory.
     */
    inline void toggle_DMA_CH4_STATUS_ETI() volatile
    {
        DMA_CH4_STATUS ^= 1u << 10u;
    }

    /**
     * Get DMA_CH4_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline bool get_DMA_CH4_STATUS_RWT() volatile
    {
        return DMA_CH4_STATUS & (1u << 9u);
    }

    /**
     * Set DMA_CH4_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void set_DMA_CH4_STATUS_RWT() volatile
    {
        DMA_CH4_STATUS |= 1u << 9u;
    }

    /**
     * Clear DMA_CH4_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void clear_DMA_CH4_STATUS_RWT() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle DMA_CH4_STATUS's RWT bit.
     *
     * Receive Watchdog Timeout This bit is asserted when a packet with length
     * greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is
     * enabled) is received.
     */
    inline void toggle_DMA_CH4_STATUS_RWT() volatile
    {
        DMA_CH4_STATUS ^= 1u << 9u;
    }

    /**
     * Get DMA_CH4_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline bool get_DMA_CH4_STATUS_RPS() volatile
    {
        return DMA_CH4_STATUS & (1u << 8u);
    }

    /**
     * Set DMA_CH4_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void set_DMA_CH4_STATUS_RPS() volatile
    {
        DMA_CH4_STATUS |= 1u << 8u;
    }

    /**
     * Clear DMA_CH4_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void clear_DMA_CH4_STATUS_RPS() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle DMA_CH4_STATUS's RPS bit.
     *
     * Receive Process Stopped This bit is asserted when the Rx process enters
     * the Stopped state.
     */
    inline void toggle_DMA_CH4_STATUS_RPS() volatile
    {
        DMA_CH4_STATUS ^= 1u << 8u;
    }

    /**
     * Get DMA_CH4_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH4_STATUS_RBU() volatile
    {
        return DMA_CH4_STATUS & (1u << 7u);
    }

    /**
     * Set DMA_CH4_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH4_STATUS_RBU() volatile
    {
        DMA_CH4_STATUS |= 1u << 7u;
    }

    /**
     * Clear DMA_CH4_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH4_STATUS_RBU() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle DMA_CH4_STATUS's RBU bit.
     *
     * Receive Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Receive list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH4_STATUS_RBU() volatile
    {
        DMA_CH4_STATUS ^= 1u << 7u;
    }

    /**
     * Get DMA_CH4_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline bool get_DMA_CH4_STATUS_RI() volatile
    {
        return DMA_CH4_STATUS & (1u << 6u);
    }

    /**
     * Set DMA_CH4_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void set_DMA_CH4_STATUS_RI() volatile
    {
        DMA_CH4_STATUS |= 1u << 6u;
    }

    /**
     * Clear DMA_CH4_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void clear_DMA_CH4_STATUS_RI() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle DMA_CH4_STATUS's RI bit.
     *
     * Receive Interrupt This bit indicates that the packet reception is
     * complete.
     */
    inline void toggle_DMA_CH4_STATUS_RI() volatile
    {
        DMA_CH4_STATUS ^= 1u << 6u;
    }

    /**
     * Get DMA_CH4_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline bool get_DMA_CH4_STATUS_TBU() volatile
    {
        return DMA_CH4_STATUS & (1u << 2u);
    }

    /**
     * Set DMA_CH4_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void set_DMA_CH4_STATUS_TBU() volatile
    {
        DMA_CH4_STATUS |= 1u << 2u;
    }

    /**
     * Clear DMA_CH4_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void clear_DMA_CH4_STATUS_TBU() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle DMA_CH4_STATUS's TBU bit.
     *
     * Transmit Buffer Unavailable This bit indicates that the application owns
     * the next descriptor in the Transmit list, and the DMA cannot acquire it.
     */
    inline void toggle_DMA_CH4_STATUS_TBU() volatile
    {
        DMA_CH4_STATUS ^= 1u << 2u;
    }

    /**
     * Get DMA_CH4_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline bool get_DMA_CH4_STATUS_TPS() volatile
    {
        return DMA_CH4_STATUS & (1u << 1u);
    }

    /**
     * Set DMA_CH4_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void set_DMA_CH4_STATUS_TPS() volatile
    {
        DMA_CH4_STATUS |= 1u << 1u;
    }

    /**
     * Clear DMA_CH4_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void clear_DMA_CH4_STATUS_TPS() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle DMA_CH4_STATUS's TPS bit.
     *
     * Transmit Process Stopped This bit is set when the transmission is
     * stopped.
     */
    inline void toggle_DMA_CH4_STATUS_TPS() volatile
    {
        DMA_CH4_STATUS ^= 1u << 1u;
    }

    /**
     * Get DMA_CH4_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline bool get_DMA_CH4_STATUS_TI() volatile
    {
        return DMA_CH4_STATUS & (1u << 0u);
    }

    /**
     * Set DMA_CH4_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void set_DMA_CH4_STATUS_TI() volatile
    {
        DMA_CH4_STATUS |= 1u << 0u;
    }

    /**
     * Clear DMA_CH4_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void clear_DMA_CH4_STATUS_TI() volatile
    {
        DMA_CH4_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle DMA_CH4_STATUS's TI bit.
     *
     * Transmit Interrupt This bit indicates that the packet transmission is
     * complete.
     */
    inline void toggle_DMA_CH4_STATUS_TI() volatile
    {
        DMA_CH4_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of DMA_CH4_STATUS's bit fields.
     *
     * (read-write) DMA Channel 4 Status
     */
    inline void get_DMA_CH4_STATUS(uint8_t &REB, uint8_t &TEB, bool &NIS,
                                   bool &AIS, bool &CDE, bool &FBE, bool &ERI,
                                   bool &ETI, bool &RWT, bool &RPS, bool &RBU,
                                   bool &RI, bool &TBU, bool &TPS,
                                   bool &TI) volatile
    {
        uint32_t curr = DMA_CH4_STATUS;

        REB = (curr >> 19u) & 0b111u;
        TEB = (curr >> 16u) & 0b111u;
        NIS = curr & (1u << 15u);
        AIS = curr & (1u << 14u);
        CDE = curr & (1u << 13u);
        FBE = curr & (1u << 12u);
        ERI = curr & (1u << 11u);
        ETI = curr & (1u << 10u);
        RWT = curr & (1u << 9u);
        RPS = curr & (1u << 8u);
        RBU = curr & (1u << 7u);
        RI = curr & (1u << 6u);
        TBU = curr & (1u << 2u);
        TPS = curr & (1u << 1u);
        TI = curr & (1u << 0u);
    }

    /**
     * Set all of DMA_CH4_STATUS's bit fields.
     *
     * (read-write) DMA Channel 4 Status
     */
    inline void set_DMA_CH4_STATUS(bool NIS, bool AIS, bool CDE, bool FBE,
                                   bool ERI, bool ETI, bool RWT, bool RPS,
                                   bool RBU, bool RI, bool TBU, bool TPS,
                                   bool TI) volatile
    {
        uint32_t curr = DMA_CH4_STATUS;

        curr &= ~(0b1u << 15u);
        curr |= (NIS & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (AIS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CDE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (FBE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ERI & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ETI & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RWT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RPS & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (RBU & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RI & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (TBU & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TI & 0b1u) << 0u;

        DMA_CH4_STATUS = curr;
    }

    /**
     * Get DMA_CH4_MISS_FRAME_CNT's MFCO bit.
     *
     * Overflow status of the MFC Counter When this bit is set then the MFC
     * counter does not get incremented further.
     */
    inline bool get_DMA_CH4_MISS_FRAME_CNT_MFCO() volatile
    {
        return DMA_CH4_MISS_FRAME_CNT & (1u << 15u);
    }

    /**
     * Get DMA_CH4_MISS_FRAME_CNT's MFC field.
     *
     * Dropped Packet Counters This counter indicates the number of packet
     * counters that are dropped by the DMA either because of bus error or
     * because of programming RPF field in RX_CONTROL register.
     */
    inline uint16_t get_DMA_CH4_MISS_FRAME_CNT_MFC() volatile
    {
        return (DMA_CH4_MISS_FRAME_CNT >> 0u) & 0b11111111111u;
    }

    /**
     * Get all of DMA_CH4_MISS_FRAME_CNT's bit fields.
     *
     * (read-write) Channel 4 Missed Frame Counter
     */
    inline void get_DMA_CH4_MISS_FRAME_CNT(bool &MFCO, uint16_t &MFC) volatile
    {
        uint32_t curr = DMA_CH4_MISS_FRAME_CNT;

        MFCO = curr & (1u << 15u);
        MFC = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Get DMA_CH4_RXP_ACCEPT_CNT's RXPACOF bit.
     *
     * Rx Parser Accept Counter Overflow Bit When set, this bit indicates that
     * the RXPAC Counter field crossed the maximum limit.
     */
    inline bool get_DMA_CH4_RXP_ACCEPT_CNT_RXPACOF() volatile
    {
        return DMA_CH4_RXP_ACCEPT_CNT & (1u << 31u);
    }

    /**
     * Get DMA_CH4_RXP_ACCEPT_CNT's RXPAC field.
     *
     * Rx Parser Accept Counter This 31-bit counter is implemented whenever a
     * Rx Parser Accept a packet due to AF =1.
     */
    inline uint32_t get_DMA_CH4_RXP_ACCEPT_CNT_RXPAC() volatile
    {
        return (DMA_CH4_RXP_ACCEPT_CNT >> 0u) &
               0b1111111111111111111111111111111u;
    }

    /**
     * Get all of DMA_CH4_RXP_ACCEPT_CNT's bit fields.
     *
     * (read-write) Channel 4 RXP Frames Accepted Counter
     */
    inline void get_DMA_CH4_RXP_ACCEPT_CNT(bool &RXPACOF,
                                           uint32_t &RXPAC) volatile
    {
        uint32_t curr = DMA_CH4_RXP_ACCEPT_CNT;

        RXPACOF = curr & (1u << 31u);
        RXPAC = (curr >> 0u) & 0b1111111111111111111111111111111u;
    }

    /**
     * Get DMA_CH4_RX_ERI_CNT's ECNT field.
     *
     * ERI Counter When ERIC bit of DMA_CH4_RX_CONTROL register is set, this
     * counter increments for burst transfer completed by the Rx DMA from the
     * start of packet transfer.
     */
    inline uint16_t get_DMA_CH4_RX_ERI_CNT_ECNT() volatile
    {
        return (DMA_CH4_RX_ERI_CNT >> 0u) & 0b111111111111u;
    }
};

static_assert(sizeof(enet_qos) == enet_qos::size);

static volatile enet_qos *const ENET_QOS =
    reinterpret_cast<enet_qos *>(0x4043C000);

}; // namespace MIMXRT1176::CM7
