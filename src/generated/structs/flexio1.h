/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/FLEXIO1_SHIFTCFG_SSTART.h"
#include "../enums/FLEXIO1_SHIFTCFG_SSTOP.h"
#include "../enums/FLEXIO1_SHIFTCTL_PINCFG.h"
#include "../enums/FLEXIO1_SHIFTCTL_SMOD.h"
#include "../enums/FLEXIO1_TIMCFG_TIMDEC.h"
#include "../enums/FLEXIO1_TIMCFG_TIMDIS.h"
#include "../enums/FLEXIO1_TIMCFG_TIMENA.h"
#include "../enums/FLEXIO1_TIMCFG_TIMOUT.h"
#include "../enums/FLEXIO1_TIMCFG_TIMRST.h"
#include "../enums/FLEXIO1_TIMCFG_TSTOP.h"
#include "../enums/FLEXIO1_TIMCTL_PINCFG.h"
#include "../enums/FLEXIO1_TIMCTL_TIMOD.h"
#include "../enums/FLEXIO1_VERID_FEATURE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * FLEXIO
 */
struct [[gnu::packed]] flexio1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 2208; /*!< flexio1's size in bytes. */

    /* Fields. */
    uint32_t VERID;     /*!< (read-write) Version ID Register */
    uint32_t PARAM;     /*!< (read-write) Parameter Register */
    uint32_t CTRL;      /*!< (read-write) FlexIO Control Register */
    uint32_t PIN;       /*!< (read-write) Pin State Register */
    uint32_t SHIFTSTAT; /*!< (read-write) Shifter Status Register */
    uint32_t SHIFTERR;  /*!< (read-write) Shifter Error Register */
    uint32_t TIMSTAT;   /*!< (read-write) Timer Status Register */
    const uint32_t reserved_padding0 = {};
    uint32_t SHIFTSIEN; /*!< (read-write) Shifter Status Interrupt Enable */
    uint32_t SHIFTEIEN; /*!< (read-write) Shifter Error Interrupt Enable */
    uint32_t TIMIEN;    /*!< (read-write) Timer Interrupt Enable Register */
    const uint32_t reserved_padding1 = {};
    uint32_t SHIFTSDEN; /*!< (read-write) Shifter Status DMA Enable */
    const uint32_t reserved_padding2 = {};
    uint32_t TIMERSDEN; /*!< (read-write) Timer Status DMA Enable */
    const uint32_t reserved_padding3 = {};
    uint32_t SHIFTSTATE; /*!< (read-write) Shifter State Register */
    static constexpr std::size_t reserved_padding4_length = 15;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    static constexpr std::size_t SHIFTCTL_length = 8;
    uint32_t SHIFTCTL[SHIFTCTL_length]; /*!< (read-write) Shifter Control N
                                           Register */
    static constexpr std::size_t reserved_padding5_length = 24;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    static constexpr std::size_t SHIFTCFG_length = 8;
    uint32_t SHIFTCFG[SHIFTCFG_length]; /*!< (read-write) Shifter Configuration
                                           N Register */
    static constexpr std::size_t reserved_padding6_length = 56;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    static constexpr std::size_t SHIFTBUF_length = 8;
    uint32_t SHIFTBUF[SHIFTBUF_length]; /*!< (read-write) Shifter Buffer N
                                           Register */
    static constexpr std::size_t reserved_padding7_length = 24;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    static constexpr std::size_t SHIFTBUFBIS_length = 8;
    uint32_t SHIFTBUFBIS[SHIFTBUFBIS_length]; /*!< (read-write) Shifter Buffer
                                                 N Bit Swapped Register */
    static constexpr std::size_t reserved_padding8_length = 24;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    static constexpr std::size_t SHIFTBUFBYS_length = 8;
    uint32_t SHIFTBUFBYS[SHIFTBUFBYS_length]; /*!< (read-write) Shifter Buffer
                                                 N Byte Swapped Register */
    static constexpr std::size_t reserved_padding9_length = 24;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    static constexpr std::size_t SHIFTBUFBBS_length = 8;
    uint32_t SHIFTBUFBBS[SHIFTBUFBBS_length]; /*!< (read-write) Shifter Buffer
                                                 N Bit Byte Swapped Register */
    static constexpr std::size_t reserved_padding10_length = 24;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    static constexpr std::size_t TIMCTL_length = 8;
    uint32_t
        TIMCTL[TIMCTL_length]; /*!< (read-write) Timer Control N Register */
    static constexpr std::size_t reserved_padding11_length = 24;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    static constexpr std::size_t TIMCFG_length = 8;
    uint32_t TIMCFG[TIMCFG_length]; /*!< (read-write) Timer Configuration N
                                       Register */
    static constexpr std::size_t reserved_padding12_length = 24;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    static constexpr std::size_t TIMCMP_length = 8;
    uint32_t
        TIMCMP[TIMCMP_length]; /*!< (read-write) Timer Compare N Register */
    static constexpr std::size_t reserved_padding13_length = 88;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    static constexpr std::size_t SHIFTBUFNBS_length = 8;
    uint32_t
        SHIFTBUFNBS[SHIFTBUFNBS_length]; /*!< (read-write) Shifter Buffer N
                                            Nibble Byte Swapped Register */
    static constexpr std::size_t reserved_padding14_length = 24;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    static constexpr std::size_t SHIFTBUFHWS_length = 8;
    uint32_t
        SHIFTBUFHWS[SHIFTBUFHWS_length]; /*!< (read-write) Shifter Buffer N
                                            Half Word Swapped Register */
    static constexpr std::size_t reserved_padding15_length = 24;
    const uint32_t reserved_padding15[reserved_padding15_length] = {};
    static constexpr std::size_t SHIFTBUFNIS_length = 8;
    uint32_t SHIFTBUFNIS[SHIFTBUFNIS_length]; /*!< (read-write) Shifter Buffer
                                                 N Nibble Swapped Register */
    static constexpr std::size_t reserved_padding16_length = 24;
    const uint32_t reserved_padding16[reserved_padding16_length] = {};
    static constexpr std::size_t SHIFTBUFOES_length = 8;
    uint32_t SHIFTBUFOES[SHIFTBUFOES_length]; /*!< (read-write) Shifter Buffer
                                                 N Odd Even Swapped Register */
    static constexpr std::size_t reserved_padding17_length = 24;
    const uint32_t reserved_padding17[reserved_padding17_length] = {};
    static constexpr std::size_t SHIFTBUFEOS_length = 8;
    uint32_t SHIFTBUFEOS[SHIFTBUFEOS_length]; /*!< (read-write) Shifter Buffer
                                                 N Even Odd Swapped Register */

    /* Methods. */

    /**
     * Get VERID's MAJOR field.
     *
     * Major Version Number
     */
    inline uint8_t get_VERID_MAJOR() volatile
    {
        return (VERID >> 24u) & 0b11111111u;
    }

    /**
     * Get VERID's MINOR field.
     *
     * Minor Version Number
     */
    inline uint8_t get_VERID_MINOR() volatile
    {
        return (VERID >> 16u) & 0b11111111u;
    }

    /**
     * Get VERID's FEATURE field.
     *
     * Feature Specification Number
     */
    inline FLEXIO1_VERID_FEATURE get_VERID_FEATURE() volatile
    {
        return FLEXIO1_VERID_FEATURE((VERID >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get all of VERID's bit fields.
     *
     * (read-write) Version ID Register
     */
    inline void get_VERID(uint8_t &MAJOR, uint8_t &MINOR,
                          FLEXIO1_VERID_FEATURE &FEATURE) volatile
    {
        uint32_t curr = VERID;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        FEATURE = FLEXIO1_VERID_FEATURE((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get PARAM's TRIGGER field.
     *
     * Trigger Number
     */
    inline uint8_t get_PARAM_TRIGGER() volatile
    {
        return (PARAM >> 24u) & 0b11111111u;
    }

    /**
     * Get PARAM's PIN field.
     *
     * Pin Number
     */
    inline uint8_t get_PARAM_PIN() volatile
    {
        return (PARAM >> 16u) & 0b11111111u;
    }

    /**
     * Get PARAM's TIMER field.
     *
     * Timer Number
     */
    inline uint8_t get_PARAM_TIMER() volatile
    {
        return (PARAM >> 8u) & 0b11111111u;
    }

    /**
     * Get PARAM's SHIFTER field.
     *
     * Shifter Number
     */
    inline uint8_t get_PARAM_SHIFTER() volatile
    {
        return (PARAM >> 0u) & 0b11111111u;
    }

    /**
     * Get all of PARAM's bit fields.
     *
     * (read-write) Parameter Register
     */
    inline void get_PARAM(uint8_t &TRIGGER, uint8_t &PIN, uint8_t &TIMER,
                          uint8_t &SHIFTER) volatile
    {
        uint32_t curr = PARAM;

        TRIGGER = (curr >> 24u) & 0b11111111u;
        PIN = (curr >> 16u) & 0b11111111u;
        TIMER = (curr >> 8u) & 0b11111111u;
        SHIFTER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline bool get_CTRL_DOZEN() volatile
    {
        return CTRL & (1u << 31u);
    }

    /**
     * Set CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline void set_CTRL_DOZEN() volatile
    {
        CTRL |= 1u << 31u;
    }

    /**
     * Clear CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline void clear_CTRL_DOZEN() volatile
    {
        CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline void toggle_CTRL_DOZEN() volatile
    {
        CTRL ^= 1u << 31u;
    }

    /**
     * Get CTRL's DBGE bit.
     *
     * Debug Enable
     */
    inline bool get_CTRL_DBGE() volatile
    {
        return CTRL & (1u << 30u);
    }

    /**
     * Set CTRL's DBGE bit.
     *
     * Debug Enable
     */
    inline void set_CTRL_DBGE() volatile
    {
        CTRL |= 1u << 30u;
    }

    /**
     * Clear CTRL's DBGE bit.
     *
     * Debug Enable
     */
    inline void clear_CTRL_DBGE() volatile
    {
        CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL's DBGE bit.
     *
     * Debug Enable
     */
    inline void toggle_CTRL_DBGE() volatile
    {
        CTRL ^= 1u << 30u;
    }

    /**
     * Get CTRL's FASTACC bit.
     *
     * Fast Access
     */
    inline bool get_CTRL_FASTACC() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's FASTACC bit.
     *
     * Fast Access
     */
    inline void set_CTRL_FASTACC() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's FASTACC bit.
     *
     * Fast Access
     */
    inline void clear_CTRL_FASTACC() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's FASTACC bit.
     *
     * Fast Access
     */
    inline void toggle_CTRL_FASTACC() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's SWRST bit.
     *
     * Software Reset
     */
    inline bool get_CTRL_SWRST() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's SWRST bit.
     *
     * Software Reset
     */
    inline void set_CTRL_SWRST() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's SWRST bit.
     *
     * Software Reset
     */
    inline void clear_CTRL_SWRST() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's SWRST bit.
     *
     * Software Reset
     */
    inline void toggle_CTRL_SWRST() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's FLEXEN bit.
     *
     * FlexIO Enable
     */
    inline bool get_CTRL_FLEXEN() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's FLEXEN bit.
     *
     * FlexIO Enable
     */
    inline void set_CTRL_FLEXEN() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's FLEXEN bit.
     *
     * FlexIO Enable
     */
    inline void clear_CTRL_FLEXEN() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's FLEXEN bit.
     *
     * FlexIO Enable
     */
    inline void toggle_CTRL_FLEXEN() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) FlexIO Control Register
     */
    inline void get_CTRL(bool &DOZEN, bool &DBGE, bool &FASTACC, bool &SWRST,
                         bool &FLEXEN) volatile
    {
        uint32_t curr = CTRL;

        DOZEN = curr & (1u << 31u);
        DBGE = curr & (1u << 30u);
        FASTACC = curr & (1u << 2u);
        SWRST = curr & (1u << 1u);
        FLEXEN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) FlexIO Control Register
     */
    inline void set_CTRL(bool DOZEN, bool DBGE, bool FASTACC, bool SWRST,
                         bool FLEXEN) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DOZEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (DBGE & 0b1u) << 30u;
        curr &= ~(0b1u << 2u);
        curr |= (FASTACC & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SWRST & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FLEXEN & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get PIN's PDI field.
     *
     * Pin Data Input
     */
    inline uint32_t get_PIN_PDI() volatile
    {
        return (PIN >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get SHIFTSTAT's SSF field.
     *
     * Shifter Status Flag
     */
    inline uint8_t get_SHIFTSTAT_SSF() volatile
    {
        return (SHIFTSTAT >> 0u) & 0b11111111u;
    }

    /**
     * Set SHIFTSTAT's SSF field.
     *
     * Shifter Status Flag
     */
    inline void set_SHIFTSTAT_SSF(uint8_t value) volatile
    {
        uint32_t curr = SHIFTSTAT;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHIFTSTAT = curr;
    }

    /**
     * Get SHIFTERR's SEF field.
     *
     * Shifter Error Flags
     */
    inline uint8_t get_SHIFTERR_SEF() volatile
    {
        return (SHIFTERR >> 0u) & 0b11111111u;
    }

    /**
     * Set SHIFTERR's SEF field.
     *
     * Shifter Error Flags
     */
    inline void set_SHIFTERR_SEF(uint8_t value) volatile
    {
        uint32_t curr = SHIFTERR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHIFTERR = curr;
    }

    /**
     * Get TIMSTAT's TSF field.
     *
     * Timer Status Flags
     */
    inline uint8_t get_TIMSTAT_TSF() volatile
    {
        return (TIMSTAT >> 0u) & 0b11111111u;
    }

    /**
     * Set TIMSTAT's TSF field.
     *
     * Timer Status Flags
     */
    inline void set_TIMSTAT_TSF(uint8_t value) volatile
    {
        uint32_t curr = TIMSTAT;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TIMSTAT = curr;
    }

    /**
     * Get SHIFTSIEN's SSIE field.
     *
     * Shifter Status Interrupt Enable
     */
    inline uint8_t get_SHIFTSIEN_SSIE() volatile
    {
        return (SHIFTSIEN >> 0u) & 0b11111111u;
    }

    /**
     * Set SHIFTSIEN's SSIE field.
     *
     * Shifter Status Interrupt Enable
     */
    inline void set_SHIFTSIEN_SSIE(uint8_t value) volatile
    {
        uint32_t curr = SHIFTSIEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHIFTSIEN = curr;
    }

    /**
     * Get SHIFTEIEN's SEIE field.
     *
     * Shifter Error Interrupt Enable
     */
    inline uint8_t get_SHIFTEIEN_SEIE() volatile
    {
        return (SHIFTEIEN >> 0u) & 0b11111111u;
    }

    /**
     * Set SHIFTEIEN's SEIE field.
     *
     * Shifter Error Interrupt Enable
     */
    inline void set_SHIFTEIEN_SEIE(uint8_t value) volatile
    {
        uint32_t curr = SHIFTEIEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHIFTEIEN = curr;
    }

    /**
     * Get TIMIEN's TEIE field.
     *
     * Timer Status Interrupt Enable
     */
    inline uint8_t get_TIMIEN_TEIE() volatile
    {
        return (TIMIEN >> 0u) & 0b11111111u;
    }

    /**
     * Set TIMIEN's TEIE field.
     *
     * Timer Status Interrupt Enable
     */
    inline void set_TIMIEN_TEIE(uint8_t value) volatile
    {
        uint32_t curr = TIMIEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TIMIEN = curr;
    }

    /**
     * Get SHIFTSDEN's SSDE field.
     *
     * Shifter Status DMA Enable
     */
    inline uint8_t get_SHIFTSDEN_SSDE() volatile
    {
        return (SHIFTSDEN >> 0u) & 0b11111111u;
    }

    /**
     * Set SHIFTSDEN's SSDE field.
     *
     * Shifter Status DMA Enable
     */
    inline void set_SHIFTSDEN_SSDE(uint8_t value) volatile
    {
        uint32_t curr = SHIFTSDEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHIFTSDEN = curr;
    }

    /**
     * Get TIMERSDEN's TSDE field.
     *
     * Timer Status DMA Enable
     */
    inline uint8_t get_TIMERSDEN_TSDE() volatile
    {
        return (TIMERSDEN >> 0u) & 0b11111111u;
    }

    /**
     * Set TIMERSDEN's TSDE field.
     *
     * Timer Status DMA Enable
     */
    inline void set_TIMERSDEN_TSDE(uint8_t value) volatile
    {
        uint32_t curr = TIMERSDEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TIMERSDEN = curr;
    }

    /**
     * Get SHIFTSTATE's STATE field.
     *
     * Current State Pointer
     */
    inline uint8_t get_SHIFTSTATE_STATE() volatile
    {
        return (SHIFTSTATE >> 0u) & 0b111u;
    }

    /**
     * Set SHIFTSTATE's STATE field.
     *
     * Current State Pointer
     */
    inline void set_SHIFTSTATE_STATE(uint8_t value) volatile
    {
        uint32_t curr = SHIFTSTATE;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        SHIFTSTATE = curr;
    }

    /**
     * Get SHIFTCTL's TIMSEL field.
     *
     * Timer Select
     */
    inline uint8_t get_SHIFTCTL_TIMSEL(std::size_t index) volatile
    {
        return (SHIFTCTL[index] >> 24u) & 0b111u;
    }

    /**
     * Set SHIFTCTL's TIMSEL field.
     *
     * Timer Select
     */
    inline void set_SHIFTCTL_TIMSEL(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = SHIFTCTL[index];

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        SHIFTCTL[index] = curr;
    }

    /**
     * Get SHIFTCTL's TIMPOL bit.
     *
     * Timer Polarity
     */
    inline bool get_SHIFTCTL_TIMPOL(std::size_t index) volatile
    {
        return SHIFTCTL[index] & (1u << 23u);
    }

    /**
     * Set SHIFTCTL's TIMPOL bit.
     *
     * Timer Polarity
     */
    inline void set_SHIFTCTL_TIMPOL() volatile
    {
        SHIFTCTL |= 1u << 23u;
    }

    /**
     * Clear SHIFTCTL's TIMPOL bit.
     *
     * Timer Polarity
     */
    inline void clear_SHIFTCTL_TIMPOL() volatile
    {
        SHIFTCTL &= ~(1u << 23u);
    }

    /**
     * Toggle SHIFTCTL's TIMPOL bit.
     *
     * Timer Polarity
     */
    inline void toggle_SHIFTCTL_TIMPOL() volatile
    {
        SHIFTCTL ^= 1u << 23u;
    }

    /**
     * Get SHIFTCTL's PINCFG field.
     *
     * Shifter Pin Configuration
     */
    inline FLEXIO1_SHIFTCTL_PINCFG get_SHIFTCTL_PINCFG(
        std::size_t index) volatile
    {
        return FLEXIO1_SHIFTCTL_PINCFG((SHIFTCTL[index] >> 16u) & 0b11u);
    }

    /**
     * Set SHIFTCTL's PINCFG field.
     *
     * Shifter Pin Configuration
     */
    inline void set_SHIFTCTL_PINCFG(std::size_t index,
                                    FLEXIO1_SHIFTCTL_PINCFG value) volatile
    {
        uint32_t curr = SHIFTCTL[index];

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        SHIFTCTL[index] = curr;
    }

    /**
     * Get SHIFTCTL's PINSEL field.
     *
     * Shifter Pin Select
     */
    inline uint8_t get_SHIFTCTL_PINSEL(std::size_t index) volatile
    {
        return (SHIFTCTL[index] >> 8u) & 0b11111u;
    }

    /**
     * Set SHIFTCTL's PINSEL field.
     *
     * Shifter Pin Select
     */
    inline void set_SHIFTCTL_PINSEL(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = SHIFTCTL[index];

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        SHIFTCTL[index] = curr;
    }

    /**
     * Get SHIFTCTL's PINPOL bit.
     *
     * Shifter Pin Polarity
     */
    inline bool get_SHIFTCTL_PINPOL(std::size_t index) volatile
    {
        return SHIFTCTL[index] & (1u << 7u);
    }

    /**
     * Set SHIFTCTL's PINPOL bit.
     *
     * Shifter Pin Polarity
     */
    inline void set_SHIFTCTL_PINPOL() volatile
    {
        SHIFTCTL |= 1u << 7u;
    }

    /**
     * Clear SHIFTCTL's PINPOL bit.
     *
     * Shifter Pin Polarity
     */
    inline void clear_SHIFTCTL_PINPOL() volatile
    {
        SHIFTCTL &= ~(1u << 7u);
    }

    /**
     * Toggle SHIFTCTL's PINPOL bit.
     *
     * Shifter Pin Polarity
     */
    inline void toggle_SHIFTCTL_PINPOL() volatile
    {
        SHIFTCTL ^= 1u << 7u;
    }

    /**
     * Get SHIFTCTL's SMOD field.
     *
     * Shifter Mode
     */
    inline FLEXIO1_SHIFTCTL_SMOD get_SHIFTCTL_SMOD(std::size_t index) volatile
    {
        return FLEXIO1_SHIFTCTL_SMOD((SHIFTCTL[index] >> 0u) & 0b111u);
    }

    /**
     * Set SHIFTCTL's SMOD field.
     *
     * Shifter Mode
     */
    inline void set_SHIFTCTL_SMOD(std::size_t index,
                                  FLEXIO1_SHIFTCTL_SMOD value) volatile
    {
        uint32_t curr = SHIFTCTL[index];

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        SHIFTCTL[index] = curr;
    }

    /**
     * Get all of SHIFTCTL's bit fields.
     *
     * (read-write) Shifter Control N Register
     */
    inline void get_SHIFTCTL(std::size_t index, uint8_t &TIMSEL, bool &TIMPOL,
                             FLEXIO1_SHIFTCTL_PINCFG &PINCFG, uint8_t &PINSEL,
                             bool &PINPOL,
                             FLEXIO1_SHIFTCTL_SMOD &SMOD) volatile
    {
        uint32_t curr = SHIFTCTL[index];

        TIMSEL = (curr >> 24u) & 0b111u;
        TIMPOL = curr & (1u << 23u);
        PINCFG = FLEXIO1_SHIFTCTL_PINCFG((curr >> 16u) & 0b11u);
        PINSEL = (curr >> 8u) & 0b11111u;
        PINPOL = curr & (1u << 7u);
        SMOD = FLEXIO1_SHIFTCTL_SMOD((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of SHIFTCTL's bit fields.
     *
     * (read-write) Shifter Control N Register
     */
    inline void set_SHIFTCTL(std::size_t index, uint8_t TIMSEL, bool TIMPOL,
                             FLEXIO1_SHIFTCTL_PINCFG PINCFG, uint8_t PINSEL,
                             bool PINPOL, FLEXIO1_SHIFTCTL_SMOD SMOD) volatile
    {
        uint32_t curr = SHIFTCTL[index];

        curr &= ~(0b111u << 24u);
        curr |= (TIMSEL & 0b111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (TIMPOL & 0b1u) << 23u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(PINCFG) & 0b11u) << 16u;
        curr &= ~(0b11111u << 8u);
        curr |= (PINSEL & 0b11111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (PINPOL & 0b1u) << 7u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(SMOD) & 0b111u) << 0u;

        SHIFTCTL[index] = curr;
    }

    /**
     * Get SHIFTCFG's PWIDTH field.
     *
     * Parallel Width
     */
    inline uint8_t get_SHIFTCFG_PWIDTH(std::size_t index) volatile
    {
        return (SHIFTCFG[index] >> 16u) & 0b11111u;
    }

    /**
     * Set SHIFTCFG's PWIDTH field.
     *
     * Parallel Width
     */
    inline void set_SHIFTCFG_PWIDTH(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = SHIFTCFG[index];

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        SHIFTCFG[index] = curr;
    }

    /**
     * Get SHIFTCFG's LATST bit.
     *
     * Late Store
     */
    inline bool get_SHIFTCFG_LATST(std::size_t index) volatile
    {
        return SHIFTCFG[index] & (1u << 9u);
    }

    /**
     * Set SHIFTCFG's LATST bit.
     *
     * Late Store
     */
    inline void set_SHIFTCFG_LATST() volatile
    {
        SHIFTCFG |= 1u << 9u;
    }

    /**
     * Clear SHIFTCFG's LATST bit.
     *
     * Late Store
     */
    inline void clear_SHIFTCFG_LATST() volatile
    {
        SHIFTCFG &= ~(1u << 9u);
    }

    /**
     * Toggle SHIFTCFG's LATST bit.
     *
     * Late Store
     */
    inline void toggle_SHIFTCFG_LATST() volatile
    {
        SHIFTCFG ^= 1u << 9u;
    }

    /**
     * Get SHIFTCFG's INSRC bit.
     *
     * Input Source
     */
    inline bool get_SHIFTCFG_INSRC(std::size_t index) volatile
    {
        return SHIFTCFG[index] & (1u << 8u);
    }

    /**
     * Set SHIFTCFG's INSRC bit.
     *
     * Input Source
     */
    inline void set_SHIFTCFG_INSRC() volatile
    {
        SHIFTCFG |= 1u << 8u;
    }

    /**
     * Clear SHIFTCFG's INSRC bit.
     *
     * Input Source
     */
    inline void clear_SHIFTCFG_INSRC() volatile
    {
        SHIFTCFG &= ~(1u << 8u);
    }

    /**
     * Toggle SHIFTCFG's INSRC bit.
     *
     * Input Source
     */
    inline void toggle_SHIFTCFG_INSRC() volatile
    {
        SHIFTCFG ^= 1u << 8u;
    }

    /**
     * Get SHIFTCFG's SSTOP field.
     *
     * Shifter Stop bit
     */
    inline FLEXIO1_SHIFTCFG_SSTOP get_SHIFTCFG_SSTOP(
        std::size_t index) volatile
    {
        return FLEXIO1_SHIFTCFG_SSTOP((SHIFTCFG[index] >> 4u) & 0b11u);
    }

    /**
     * Set SHIFTCFG's SSTOP field.
     *
     * Shifter Stop bit
     */
    inline void set_SHIFTCFG_SSTOP(std::size_t index,
                                   FLEXIO1_SHIFTCFG_SSTOP value) volatile
    {
        uint32_t curr = SHIFTCFG[index];

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        SHIFTCFG[index] = curr;
    }

    /**
     * Get SHIFTCFG's SSTART field.
     *
     * Shifter Start bit
     */
    inline FLEXIO1_SHIFTCFG_SSTART get_SHIFTCFG_SSTART(
        std::size_t index) volatile
    {
        return FLEXIO1_SHIFTCFG_SSTART((SHIFTCFG[index] >> 0u) & 0b11u);
    }

    /**
     * Set SHIFTCFG's SSTART field.
     *
     * Shifter Start bit
     */
    inline void set_SHIFTCFG_SSTART(std::size_t index,
                                    FLEXIO1_SHIFTCFG_SSTART value) volatile
    {
        uint32_t curr = SHIFTCFG[index];

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SHIFTCFG[index] = curr;
    }

    /**
     * Get all of SHIFTCFG's bit fields.
     *
     * (read-write) Shifter Configuration N Register
     */
    inline void get_SHIFTCFG(std::size_t index, uint8_t &PWIDTH, bool &LATST,
                             bool &INSRC, FLEXIO1_SHIFTCFG_SSTOP &SSTOP,
                             FLEXIO1_SHIFTCFG_SSTART &SSTART) volatile
    {
        uint32_t curr = SHIFTCFG[index];

        PWIDTH = (curr >> 16u) & 0b11111u;
        LATST = curr & (1u << 9u);
        INSRC = curr & (1u << 8u);
        SSTOP = FLEXIO1_SHIFTCFG_SSTOP((curr >> 4u) & 0b11u);
        SSTART = FLEXIO1_SHIFTCFG_SSTART((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of SHIFTCFG's bit fields.
     *
     * (read-write) Shifter Configuration N Register
     */
    inline void set_SHIFTCFG(std::size_t index, uint8_t PWIDTH, bool LATST,
                             bool INSRC, FLEXIO1_SHIFTCFG_SSTOP SSTOP,
                             FLEXIO1_SHIFTCFG_SSTART SSTART) volatile
    {
        uint32_t curr = SHIFTCFG[index];

        curr &= ~(0b11111u << 16u);
        curr |= (PWIDTH & 0b11111u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (LATST & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (INSRC & 0b1u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(SSTOP) & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(SSTART) & 0b11u) << 0u;

        SHIFTCFG[index] = curr;
    }

    /**
     * Get SHIFTBUF's SHIFTBUF field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUF_SHIFTBUF(std::size_t index) volatile
    {
        return (SHIFTBUF[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUF's SHIFTBUF field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUF_SHIFTBUF(std::size_t index,
                                      uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUF[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUF[index] = curr;
    }

    /**
     * Get SHIFTBUFBIS's SHIFTBUFBIS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFBIS_SHIFTBUFBIS(std::size_t index) volatile
    {
        return (SHIFTBUFBIS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFBIS's SHIFTBUFBIS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFBIS_SHIFTBUFBIS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFBIS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFBIS[index] = curr;
    }

    /**
     * Get SHIFTBUFBYS's SHIFTBUFBYS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFBYS_SHIFTBUFBYS(std::size_t index) volatile
    {
        return (SHIFTBUFBYS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFBYS's SHIFTBUFBYS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFBYS_SHIFTBUFBYS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFBYS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFBYS[index] = curr;
    }

    /**
     * Get SHIFTBUFBBS's SHIFTBUFBBS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFBBS_SHIFTBUFBBS(std::size_t index) volatile
    {
        return (SHIFTBUFBBS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFBBS's SHIFTBUFBBS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFBBS_SHIFTBUFBBS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFBBS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFBBS[index] = curr;
    }

    /**
     * Get TIMCTL's TRGSEL field.
     *
     * Trigger Select
     */
    inline uint8_t get_TIMCTL_TRGSEL(std::size_t index) volatile
    {
        return (TIMCTL[index] >> 24u) & 0b111111u;
    }

    /**
     * Set TIMCTL's TRGSEL field.
     *
     * Trigger Select
     */
    inline void set_TIMCTL_TRGSEL(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = TIMCTL[index];

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        TIMCTL[index] = curr;
    }

    /**
     * Get TIMCTL's TRGPOL bit.
     *
     * Trigger Polarity
     */
    inline bool get_TIMCTL_TRGPOL(std::size_t index) volatile
    {
        return TIMCTL[index] & (1u << 23u);
    }

    /**
     * Set TIMCTL's TRGPOL bit.
     *
     * Trigger Polarity
     */
    inline void set_TIMCTL_TRGPOL() volatile
    {
        TIMCTL |= 1u << 23u;
    }

    /**
     * Clear TIMCTL's TRGPOL bit.
     *
     * Trigger Polarity
     */
    inline void clear_TIMCTL_TRGPOL() volatile
    {
        TIMCTL &= ~(1u << 23u);
    }

    /**
     * Toggle TIMCTL's TRGPOL bit.
     *
     * Trigger Polarity
     */
    inline void toggle_TIMCTL_TRGPOL() volatile
    {
        TIMCTL ^= 1u << 23u;
    }

    /**
     * Get TIMCTL's TRGSRC bit.
     *
     * Trigger Source
     */
    inline bool get_TIMCTL_TRGSRC(std::size_t index) volatile
    {
        return TIMCTL[index] & (1u << 22u);
    }

    /**
     * Set TIMCTL's TRGSRC bit.
     *
     * Trigger Source
     */
    inline void set_TIMCTL_TRGSRC() volatile
    {
        TIMCTL |= 1u << 22u;
    }

    /**
     * Clear TIMCTL's TRGSRC bit.
     *
     * Trigger Source
     */
    inline void clear_TIMCTL_TRGSRC() volatile
    {
        TIMCTL &= ~(1u << 22u);
    }

    /**
     * Toggle TIMCTL's TRGSRC bit.
     *
     * Trigger Source
     */
    inline void toggle_TIMCTL_TRGSRC() volatile
    {
        TIMCTL ^= 1u << 22u;
    }

    /**
     * Get TIMCTL's PINCFG field.
     *
     * Timer Pin Configuration
     */
    inline FLEXIO1_TIMCTL_PINCFG get_TIMCTL_PINCFG(std::size_t index) volatile
    {
        return FLEXIO1_TIMCTL_PINCFG((TIMCTL[index] >> 16u) & 0b11u);
    }

    /**
     * Set TIMCTL's PINCFG field.
     *
     * Timer Pin Configuration
     */
    inline void set_TIMCTL_PINCFG(std::size_t index,
                                  FLEXIO1_TIMCTL_PINCFG value) volatile
    {
        uint32_t curr = TIMCTL[index];

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        TIMCTL[index] = curr;
    }

    /**
     * Get TIMCTL's PINSEL field.
     *
     * Timer Pin Select
     */
    inline uint8_t get_TIMCTL_PINSEL(std::size_t index) volatile
    {
        return (TIMCTL[index] >> 8u) & 0b11111u;
    }

    /**
     * Set TIMCTL's PINSEL field.
     *
     * Timer Pin Select
     */
    inline void set_TIMCTL_PINSEL(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = TIMCTL[index];

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        TIMCTL[index] = curr;
    }

    /**
     * Get TIMCTL's PINPOL bit.
     *
     * Timer Pin Polarity
     */
    inline bool get_TIMCTL_PINPOL(std::size_t index) volatile
    {
        return TIMCTL[index] & (1u << 7u);
    }

    /**
     * Set TIMCTL's PINPOL bit.
     *
     * Timer Pin Polarity
     */
    inline void set_TIMCTL_PINPOL() volatile
    {
        TIMCTL |= 1u << 7u;
    }

    /**
     * Clear TIMCTL's PINPOL bit.
     *
     * Timer Pin Polarity
     */
    inline void clear_TIMCTL_PINPOL() volatile
    {
        TIMCTL &= ~(1u << 7u);
    }

    /**
     * Toggle TIMCTL's PINPOL bit.
     *
     * Timer Pin Polarity
     */
    inline void toggle_TIMCTL_PINPOL() volatile
    {
        TIMCTL ^= 1u << 7u;
    }

    /**
     * Get TIMCTL's PININS bit.
     *
     * Timer Pin Input Select
     */
    inline bool get_TIMCTL_PININS(std::size_t index) volatile
    {
        return TIMCTL[index] & (1u << 6u);
    }

    /**
     * Set TIMCTL's PININS bit.
     *
     * Timer Pin Input Select
     */
    inline void set_TIMCTL_PININS() volatile
    {
        TIMCTL |= 1u << 6u;
    }

    /**
     * Clear TIMCTL's PININS bit.
     *
     * Timer Pin Input Select
     */
    inline void clear_TIMCTL_PININS() volatile
    {
        TIMCTL &= ~(1u << 6u);
    }

    /**
     * Toggle TIMCTL's PININS bit.
     *
     * Timer Pin Input Select
     */
    inline void toggle_TIMCTL_PININS() volatile
    {
        TIMCTL ^= 1u << 6u;
    }

    /**
     * Get TIMCTL's ONETIM bit.
     *
     * Timer One Time Operation
     */
    inline bool get_TIMCTL_ONETIM(std::size_t index) volatile
    {
        return TIMCTL[index] & (1u << 5u);
    }

    /**
     * Set TIMCTL's ONETIM bit.
     *
     * Timer One Time Operation
     */
    inline void set_TIMCTL_ONETIM() volatile
    {
        TIMCTL |= 1u << 5u;
    }

    /**
     * Clear TIMCTL's ONETIM bit.
     *
     * Timer One Time Operation
     */
    inline void clear_TIMCTL_ONETIM() volatile
    {
        TIMCTL &= ~(1u << 5u);
    }

    /**
     * Toggle TIMCTL's ONETIM bit.
     *
     * Timer One Time Operation
     */
    inline void toggle_TIMCTL_ONETIM() volatile
    {
        TIMCTL ^= 1u << 5u;
    }

    /**
     * Get TIMCTL's TIMOD field.
     *
     * Timer Mode
     */
    inline FLEXIO1_TIMCTL_TIMOD get_TIMCTL_TIMOD(std::size_t index) volatile
    {
        return FLEXIO1_TIMCTL_TIMOD((TIMCTL[index] >> 0u) & 0b111u);
    }

    /**
     * Set TIMCTL's TIMOD field.
     *
     * Timer Mode
     */
    inline void set_TIMCTL_TIMOD(std::size_t index,
                                 FLEXIO1_TIMCTL_TIMOD value) volatile
    {
        uint32_t curr = TIMCTL[index];

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        TIMCTL[index] = curr;
    }

    /**
     * Get all of TIMCTL's bit fields.
     *
     * (read-write) Timer Control N Register
     */
    inline void get_TIMCTL(std::size_t index, uint8_t &TRGSEL, bool &TRGPOL,
                           bool &TRGSRC, FLEXIO1_TIMCTL_PINCFG &PINCFG,
                           uint8_t &PINSEL, bool &PINPOL, bool &PININS,
                           bool &ONETIM, FLEXIO1_TIMCTL_TIMOD &TIMOD) volatile
    {
        uint32_t curr = TIMCTL[index];

        TRGSEL = (curr >> 24u) & 0b111111u;
        TRGPOL = curr & (1u << 23u);
        TRGSRC = curr & (1u << 22u);
        PINCFG = FLEXIO1_TIMCTL_PINCFG((curr >> 16u) & 0b11u);
        PINSEL = (curr >> 8u) & 0b11111u;
        PINPOL = curr & (1u << 7u);
        PININS = curr & (1u << 6u);
        ONETIM = curr & (1u << 5u);
        TIMOD = FLEXIO1_TIMCTL_TIMOD((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of TIMCTL's bit fields.
     *
     * (read-write) Timer Control N Register
     */
    inline void set_TIMCTL(std::size_t index, uint8_t TRGSEL, bool TRGPOL,
                           bool TRGSRC, FLEXIO1_TIMCTL_PINCFG PINCFG,
                           uint8_t PINSEL, bool PINPOL, bool PININS,
                           bool ONETIM, FLEXIO1_TIMCTL_TIMOD TIMOD) volatile
    {
        uint32_t curr = TIMCTL[index];

        curr &= ~(0b111111u << 24u);
        curr |= (TRGSEL & 0b111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (TRGPOL & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (TRGSRC & 0b1u) << 22u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(PINCFG) & 0b11u) << 16u;
        curr &= ~(0b11111u << 8u);
        curr |= (PINSEL & 0b11111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (PINPOL & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (PININS & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ONETIM & 0b1u) << 5u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(TIMOD) & 0b111u) << 0u;

        TIMCTL[index] = curr;
    }

    /**
     * Get TIMCFG's TIMOUT field.
     *
     * Timer Output
     */
    inline FLEXIO1_TIMCFG_TIMOUT get_TIMCFG_TIMOUT(std::size_t index) volatile
    {
        return FLEXIO1_TIMCFG_TIMOUT((TIMCFG[index] >> 24u) & 0b11u);
    }

    /**
     * Set TIMCFG's TIMOUT field.
     *
     * Timer Output
     */
    inline void set_TIMCFG_TIMOUT(std::size_t index,
                                  FLEXIO1_TIMCFG_TIMOUT value) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(value) & 0b11u) << 24u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCFG's TIMDEC field.
     *
     * Timer Decrement
     */
    inline FLEXIO1_TIMCFG_TIMDEC get_TIMCFG_TIMDEC(std::size_t index) volatile
    {
        return FLEXIO1_TIMCFG_TIMDEC((TIMCFG[index] >> 20u) & 0b111u);
    }

    /**
     * Set TIMCFG's TIMDEC field.
     *
     * Timer Decrement
     */
    inline void set_TIMCFG_TIMDEC(std::size_t index,
                                  FLEXIO1_TIMCFG_TIMDEC value) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(value) & 0b111u) << 20u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCFG's TIMRST field.
     *
     * Timer Reset
     */
    inline FLEXIO1_TIMCFG_TIMRST get_TIMCFG_TIMRST(std::size_t index) volatile
    {
        return FLEXIO1_TIMCFG_TIMRST((TIMCFG[index] >> 16u) & 0b111u);
    }

    /**
     * Set TIMCFG's TIMRST field.
     *
     * Timer Reset
     */
    inline void set_TIMCFG_TIMRST(std::size_t index,
                                  FLEXIO1_TIMCFG_TIMRST value) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCFG's TIMDIS field.
     *
     * Timer Disable
     */
    inline FLEXIO1_TIMCFG_TIMDIS get_TIMCFG_TIMDIS(std::size_t index) volatile
    {
        return FLEXIO1_TIMCFG_TIMDIS((TIMCFG[index] >> 12u) & 0b111u);
    }

    /**
     * Set TIMCFG's TIMDIS field.
     *
     * Timer Disable
     */
    inline void set_TIMCFG_TIMDIS(std::size_t index,
                                  FLEXIO1_TIMCFG_TIMDIS value) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCFG's TIMENA field.
     *
     * Timer Enable
     */
    inline FLEXIO1_TIMCFG_TIMENA get_TIMCFG_TIMENA(std::size_t index) volatile
    {
        return FLEXIO1_TIMCFG_TIMENA((TIMCFG[index] >> 8u) & 0b111u);
    }

    /**
     * Set TIMCFG's TIMENA field.
     *
     * Timer Enable
     */
    inline void set_TIMCFG_TIMENA(std::size_t index,
                                  FLEXIO1_TIMCFG_TIMENA value) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCFG's TSTOP field.
     *
     * Timer Stop Bit
     */
    inline FLEXIO1_TIMCFG_TSTOP get_TIMCFG_TSTOP(std::size_t index) volatile
    {
        return FLEXIO1_TIMCFG_TSTOP((TIMCFG[index] >> 4u) & 0b11u);
    }

    /**
     * Set TIMCFG's TSTOP field.
     *
     * Timer Stop Bit
     */
    inline void set_TIMCFG_TSTOP(std::size_t index,
                                 FLEXIO1_TIMCFG_TSTOP value) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCFG's TSTART bit.
     *
     * Timer Start Bit
     */
    inline bool get_TIMCFG_TSTART(std::size_t index) volatile
    {
        return TIMCFG[index] & (1u << 1u);
    }

    /**
     * Set TIMCFG's TSTART bit.
     *
     * Timer Start Bit
     */
    inline void set_TIMCFG_TSTART() volatile
    {
        TIMCFG |= 1u << 1u;
    }

    /**
     * Clear TIMCFG's TSTART bit.
     *
     * Timer Start Bit
     */
    inline void clear_TIMCFG_TSTART() volatile
    {
        TIMCFG &= ~(1u << 1u);
    }

    /**
     * Toggle TIMCFG's TSTART bit.
     *
     * Timer Start Bit
     */
    inline void toggle_TIMCFG_TSTART() volatile
    {
        TIMCFG ^= 1u << 1u;
    }

    /**
     * Get all of TIMCFG's bit fields.
     *
     * (read-write) Timer Configuration N Register
     */
    inline void get_TIMCFG(std::size_t index, FLEXIO1_TIMCFG_TIMOUT &TIMOUT,
                           FLEXIO1_TIMCFG_TIMDEC &TIMDEC,
                           FLEXIO1_TIMCFG_TIMRST &TIMRST,
                           FLEXIO1_TIMCFG_TIMDIS &TIMDIS,
                           FLEXIO1_TIMCFG_TIMENA &TIMENA,
                           FLEXIO1_TIMCFG_TSTOP &TSTOP, bool &TSTART) volatile
    {
        uint32_t curr = TIMCFG[index];

        TIMOUT = FLEXIO1_TIMCFG_TIMOUT((curr >> 24u) & 0b11u);
        TIMDEC = FLEXIO1_TIMCFG_TIMDEC((curr >> 20u) & 0b111u);
        TIMRST = FLEXIO1_TIMCFG_TIMRST((curr >> 16u) & 0b111u);
        TIMDIS = FLEXIO1_TIMCFG_TIMDIS((curr >> 12u) & 0b111u);
        TIMENA = FLEXIO1_TIMCFG_TIMENA((curr >> 8u) & 0b111u);
        TSTOP = FLEXIO1_TIMCFG_TSTOP((curr >> 4u) & 0b11u);
        TSTART = curr & (1u << 1u);
    }

    /**
     * Set all of TIMCFG's bit fields.
     *
     * (read-write) Timer Configuration N Register
     */
    inline void set_TIMCFG(std::size_t index, FLEXIO1_TIMCFG_TIMOUT TIMOUT,
                           FLEXIO1_TIMCFG_TIMDEC TIMDEC,
                           FLEXIO1_TIMCFG_TIMRST TIMRST,
                           FLEXIO1_TIMCFG_TIMDIS TIMDIS,
                           FLEXIO1_TIMCFG_TIMENA TIMENA,
                           FLEXIO1_TIMCFG_TSTOP TSTOP, bool TSTART) volatile
    {
        uint32_t curr = TIMCFG[index];

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(TIMOUT) & 0b11u) << 24u;
        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(TIMDEC) & 0b111u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(TIMRST) & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(TIMDIS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(TIMENA) & 0b111u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(TSTOP) & 0b11u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TSTART & 0b1u) << 1u;

        TIMCFG[index] = curr;
    }

    /**
     * Get TIMCMP's CMP field.
     *
     * Timer Compare Value
     */
    inline uint16_t get_TIMCMP_CMP(std::size_t index) volatile
    {
        return (TIMCMP[index] >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMCMP's CMP field.
     *
     * Timer Compare Value
     */
    inline void set_TIMCMP_CMP(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = TIMCMP[index];

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMCMP[index] = curr;
    }

    /**
     * Get SHIFTBUFNBS's SHIFTBUFNBS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFNBS_SHIFTBUFNBS(std::size_t index) volatile
    {
        return (SHIFTBUFNBS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFNBS's SHIFTBUFNBS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFNBS_SHIFTBUFNBS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFNBS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFNBS[index] = curr;
    }

    /**
     * Get SHIFTBUFHWS's SHIFTBUFHWS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFHWS_SHIFTBUFHWS(std::size_t index) volatile
    {
        return (SHIFTBUFHWS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFHWS's SHIFTBUFHWS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFHWS_SHIFTBUFHWS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFHWS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFHWS[index] = curr;
    }

    /**
     * Get SHIFTBUFNIS's SHIFTBUFNIS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFNIS_SHIFTBUFNIS(std::size_t index) volatile
    {
        return (SHIFTBUFNIS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFNIS's SHIFTBUFNIS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFNIS_SHIFTBUFNIS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFNIS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFNIS[index] = curr;
    }

    /**
     * Get SHIFTBUFOES's SHIFTBUFOES field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFOES_SHIFTBUFOES(std::size_t index) volatile
    {
        return (SHIFTBUFOES[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFOES's SHIFTBUFOES field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFOES_SHIFTBUFOES(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFOES[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFOES[index] = curr;
    }

    /**
     * Get SHIFTBUFEOS's SHIFTBUFEOS field.
     *
     * Shift Buffer
     */
    inline uint32_t get_SHIFTBUFEOS_SHIFTBUFEOS(std::size_t index) volatile
    {
        return (SHIFTBUFEOS[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set SHIFTBUFEOS's SHIFTBUFEOS field.
     *
     * Shift Buffer
     */
    inline void set_SHIFTBUFEOS_SHIFTBUFEOS(std::size_t index,
                                            uint32_t value) volatile
    {
        uint32_t curr = SHIFTBUFEOS[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        SHIFTBUFEOS[index] = curr;
    }
};

static_assert(sizeof(flexio1) == flexio1::size);

static volatile flexio1 *const FLEXIO1 =
    reinterpret_cast<flexio1 *>(0x400AC000);

static volatile flexio1 *const FLEXIO2 =
    reinterpret_cast<flexio1 *>(0x400B0000);

}; // namespace MIMXRT1176::CM7
