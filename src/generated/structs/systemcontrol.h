/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/SystemControl_ACTLR_DISDI.h"
#include "../enums/SystemControl_ACTLR_DISISSCH1.h"
#include "../enums/SystemControl_CCSIDR_LINESIZE.h"
#include "../enums/SystemControl_CLIDR_CL1.h"
#include "../enums/SystemControl_CLIDR_CL2.h"
#include "../enums/SystemControl_CLIDR_CL3.h"
#include "../enums/SystemControl_CLIDR_CL4.h"
#include "../enums/SystemControl_CLIDR_CL5.h"
#include "../enums/SystemControl_CLIDR_CL6.h"
#include "../enums/SystemControl_CLIDR_CL7.h"
#include "../enums/SystemControl_CLIDR_LOC.h"
#include "../enums/SystemControl_CLIDR_LOU.h"
#include "../enums/SystemControl_CLIDR_LOUIS.h"
#include "../enums/SystemControl_CM7_ABFSR_AXIMTYPE.h"
#include "../enums/SystemControl_CM7_AHBPCR_SZ.h"
#include "../enums/SystemControl_CM7_AHBSCR_CTL.h"
#include "../enums/SystemControl_CM7_DTCMCR_SZ.h"
#include "../enums/SystemControl_CM7_ITCMCR_SZ.h"
#include "../enums/SystemControl_CPACR_CP0.h"
#include "../enums/SystemControl_CPACR_CP1.h"
#include "../enums/SystemControl_CPACR_CP10.h"
#include "../enums/SystemControl_CPACR_CP11.h"
#include "../enums/SystemControl_CPACR_CP2.h"
#include "../enums/SystemControl_CPACR_CP3.h"
#include "../enums/SystemControl_CPACR_CP4.h"
#include "../enums/SystemControl_CPACR_CP5.h"
#include "../enums/SystemControl_CPACR_CP6.h"
#include "../enums/SystemControl_CPACR_CP7.h"
#include "../enums/SystemControl_CSSELR_LEVEL.h"
#include "../enums/SystemControl_CTR_FORMAT.h"
#include "../enums/SystemControl_ID_DFR0_DEBUGMODEL.h"
#include "../enums/SystemControl_ID_ISAR0_BITCOUNT_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR0_BITFIELD_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR0_CMPBRANCH_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR0_COPROC_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR0_DEBUG_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR0_DIVIDE_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR1_EXTEND_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR1_IFTHEN_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR1_IMMEDIATE_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR1_INTERWORK_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_LOADSTORE_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_MEMHINT_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_MULTIACCESSINT_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_MULTS_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_MULTU_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_MULT_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR2_REVERSAL_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR3_SATURATE_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR3_SIMD_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR3_SVC_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR3_TABBRANCH_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR3_THUMBCOPY_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR3_TRUENOP_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR4_BARRIER_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR4_PSR_M_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR4_UNPRIV_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR4_WITHSHIFTS_INSTRS.h"
#include "../enums/SystemControl_ID_ISAR4_WRITEBACK_INSTRS.h"
#include "../enums/SystemControl_ID_MMFR0_AUXILIARY_REGISTERS.h"
#include "../enums/SystemControl_ID_MMFR0_OUTERMOST_SHAREABILITY.h"
#include "../enums/SystemControl_ID_MMFR0_PMSASUPPORT.h"
#include "../enums/SystemControl_ID_MMFR0_SHAREABILITY_LEVELS.h"
#include "../enums/SystemControl_ID_MMFR0_TCM_SUPPORT.h"
#include "../enums/SystemControl_ID_MMFR2_WFI_STALL.h"
#include "../enums/SystemControl_ID_PFR0_STATE0.h"
#include "../enums/SystemControl_ID_PFR0_STATE1.h"
#include "../enums/SystemControl_ID_PFR1_PROGMODEL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * System Control Block
 */
struct [[gnu::packed]] systemcontrol
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        4012; /*!< systemcontrol's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t ACTLR; /*!< (read-write) Auxiliary Control Register, */
    static constexpr std::size_t reserved_padding1_length = 829;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CPUID; /*!< (read-write) CPUID Base Register */
    uint32_t ICSR;  /*!< (read-write) Interrupt Control and State Register */
    uint32_t VTOR;  /*!< (read-write) Vector Table Offset Register */
    uint32_t AIRCR; /*!< (read-write) Application Interrupt and Reset Control
                       Register */
    uint32_t SCR;   /*!< (read-write) System Control Register */
    uint32_t CCR;   /*!< (read-write) Configuration and Control Register */
    uint32_t SHPR1; /*!< (read-write) System Handler Priority Register 1 */
    uint32_t SHPR2; /*!< (read-write) System Handler Priority Register 2 */
    uint32_t SHPR3; /*!< (read-write) System Handler Priority Register 3 */
    uint32_t
        SHCSR; /*!< (read-write) System Handler Control and State Register */
    uint32_t CFSR;  /*!< (read-write) Configurable Fault Status Register */
    uint32_t HFSR;  /*!< (read-write) HardFault Status register */
    uint32_t DFSR;  /*!< (read-write) Debug Fault Status Register */
    uint32_t MMFAR; /*!< (read-write) MemManage Fault Address Register */
    uint32_t BFAR;  /*!< (read-write) BusFault Address Register */
    const uint32_t reserved_padding2 = {};
    uint32_t ID_PFR0;  /*!< (read-write) Processor Feature Register 0 */
    uint32_t ID_PFR1;  /*!< (read-write) Processor Feature Register 1 */
    uint32_t ID_DFR0;  /*!< (read-write) Debug Feature Register */
    uint32_t ID_AFR0;  /*!< (read-write) Auxiliary Feature Register */
    uint32_t ID_MMFR0; /*!< (read-write) Memory Model Feature Register 0 */
    uint32_t ID_MMFR1; /*!< (read-write) Memory Model Feature Register 1 */
    uint32_t ID_MMFR2; /*!< (read-write) Memory Model Feature Register 2 */
    uint32_t ID_MMFR3; /*!< (read-write) Memory Model Feature Register 3 */
    uint32_t
        ID_ISAR0; /*!< (read-write) Instruction Set Attributes Register 0 */
    uint32_t
        ID_ISAR1; /*!< (read-write) Instruction Set Attributes Register 1 */
    uint32_t
        ID_ISAR2; /*!< (read-write) Instruction Set Attributes Register 2 */
    uint32_t
        ID_ISAR3; /*!< (read-write) Instruction Set Attributes Register 3 */
    uint32_t
        ID_ISAR4; /*!< (read-write) Instruction Set Attributes Register 4 */
    const uint32_t reserved_padding3 = {};
    uint32_t CLIDR;  /*!< (read-write) Cache Level ID register */
    uint32_t CTR;    /*!< (read-write) Cache Type register */
    uint32_t CCSIDR; /*!< (read-write) Cache Size ID Register */
    uint32_t CSSELR; /*!< (read-write) Cache Size Selection Register */
    uint32_t CPACR;  /*!< (read-write) Coprocessor Access Control Register */
    static constexpr std::size_t reserved_padding4_length = 93;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t STIR; /*!< (read-write) Instruction cache invalidate all to Point
                      of Unification (PoU) */
    static constexpr std::size_t reserved_padding5_length = 19;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t ICIALLU; /*!< (read-write) Instruction cache invalidate all to
                         Point of Unification (PoU) */
    const uint32_t reserved_padding6 = {};
    uint32_t ICIMVAU; /*!< (read-write) Instruction cache invalidate by address
                         to PoU */
    uint32_t DCIMVAC; /*!< (read-write) Data cache invalidate by address to
                         Point of Coherency (PoC) */
    uint32_t DCISW;   /*!< (read-write) Data cache invalidate by set/way */
    uint32_t DCCMVAU; /*!< (read-write) Data cache by address to PoU */
    uint32_t DCCMVAC; /*!< (read-write) Data cache clean by address to PoC */
    uint32_t DCCSW;   /*!< (read-write) Data cache clean by set/way */
    uint32_t DCCIMVAC; /*!< (read-write) Data cache clean and invalidate by
                          address to PoC */
    uint32_t
        DCCISW; /*!< (read-write) Data cache clean and invalidate by set/way */
    static constexpr std::size_t reserved_padding7_length = 6;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t CM7_ITCMCR; /*!< (read-write) Instruction Tightly-Coupled Memory
                            Control Register */
    uint32_t CM7_DTCMCR; /*!< (read-write) Data Tightly-Coupled Memory Control
                            Register */
    uint32_t CM7_AHBPCR; /*!< (read-write) AHBP Control Register */
    uint32_t CM7_CACR;   /*!< (read-write) L1 Cache Control Register */
    uint32_t CM7_AHBSCR; /*!< (read-write) AHB Slave Control Register */
    const uint32_t reserved_padding8 = {};
    uint32_t
        CM7_ABFSR; /*!< (read-write) Auxiliary Bus Fault Status Register */

    /* Methods. */

    /**
     * Get ACTLR's DISFPUISSOPT bit.
     *
     * Disables critical AXI read-under-write
     */
    inline bool get_ACTLR_DISFPUISSOPT() volatile
    {
        return ACTLR & (1u << 28u);
    }

    /**
     * Set ACTLR's DISFPUISSOPT bit.
     *
     * Disables critical AXI read-under-write
     */
    inline void set_ACTLR_DISFPUISSOPT() volatile
    {
        ACTLR |= 1u << 28u;
    }

    /**
     * Clear ACTLR's DISFPUISSOPT bit.
     *
     * Disables critical AXI read-under-write
     */
    inline void clear_ACTLR_DISFPUISSOPT() volatile
    {
        ACTLR &= ~(1u << 28u);
    }

    /**
     * Toggle ACTLR's DISFPUISSOPT bit.
     *
     * Disables critical AXI read-under-write
     */
    inline void toggle_ACTLR_DISFPUISSOPT() volatile
    {
        ACTLR ^= 1u << 28u;
    }

    /**
     * Get ACTLR's DISCRITAXIRUW bit.
     *
     * Disables critical AXI read-under-write
     */
    inline bool get_ACTLR_DISCRITAXIRUW() volatile
    {
        return ACTLR & (1u << 27u);
    }

    /**
     * Set ACTLR's DISCRITAXIRUW bit.
     *
     * Disables critical AXI read-under-write
     */
    inline void set_ACTLR_DISCRITAXIRUW() volatile
    {
        ACTLR |= 1u << 27u;
    }

    /**
     * Clear ACTLR's DISCRITAXIRUW bit.
     *
     * Disables critical AXI read-under-write
     */
    inline void clear_ACTLR_DISCRITAXIRUW() volatile
    {
        ACTLR &= ~(1u << 27u);
    }

    /**
     * Toggle ACTLR's DISCRITAXIRUW bit.
     *
     * Disables critical AXI read-under-write
     */
    inline void toggle_ACTLR_DISCRITAXIRUW() volatile
    {
        ACTLR ^= 1u << 27u;
    }

    /**
     * Get ACTLR's DISDYNADD bit.
     *
     * Disables dynamic allocation of ADD and SUB instructions
     */
    inline bool get_ACTLR_DISDYNADD() volatile
    {
        return ACTLR & (1u << 26u);
    }

    /**
     * Set ACTLR's DISDYNADD bit.
     *
     * Disables dynamic allocation of ADD and SUB instructions
     */
    inline void set_ACTLR_DISDYNADD() volatile
    {
        ACTLR |= 1u << 26u;
    }

    /**
     * Clear ACTLR's DISDYNADD bit.
     *
     * Disables dynamic allocation of ADD and SUB instructions
     */
    inline void clear_ACTLR_DISDYNADD() volatile
    {
        ACTLR &= ~(1u << 26u);
    }

    /**
     * Toggle ACTLR's DISDYNADD bit.
     *
     * Disables dynamic allocation of ADD and SUB instructions
     */
    inline void toggle_ACTLR_DISDYNADD() volatile
    {
        ACTLR ^= 1u << 26u;
    }

    /**
     * Get ACTLR's DISISSCH1 field.
     *
     * Disables dual-issued.
     */
    inline SystemControl_ACTLR_DISISSCH1 get_ACTLR_DISISSCH1() volatile
    {
        return SystemControl_ACTLR_DISISSCH1((ACTLR >> 21u) & 0b11111u);
    }

    /**
     * Set ACTLR's DISISSCH1 field.
     *
     * Disables dual-issued.
     */
    inline void set_ACTLR_DISISSCH1(
        SystemControl_ACTLR_DISISSCH1 value) volatile
    {
        uint32_t curr = ACTLR;

        curr &= ~(0b11111u << 21u);
        curr |= (std::to_underlying(value) & 0b11111u) << 21u;

        ACTLR = curr;
    }

    /**
     * Get ACTLR's DISDI field.
     *
     * Disables dual-issued.
     */
    inline SystemControl_ACTLR_DISDI get_ACTLR_DISDI() volatile
    {
        return SystemControl_ACTLR_DISDI((ACTLR >> 16u) & 0b11111u);
    }

    /**
     * Set ACTLR's DISDI field.
     *
     * Disables dual-issued.
     */
    inline void set_ACTLR_DISDI(SystemControl_ACTLR_DISDI value) volatile
    {
        uint32_t curr = ACTLR;

        curr &= ~(0b11111u << 16u);
        curr |= (std::to_underlying(value) & 0b11111u) << 16u;

        ACTLR = curr;
    }

    /**
     * Get ACTLR's DISCRITAXIRUR bit.
     *
     * Disables critical AXI Read-Under-Read.
     */
    inline bool get_ACTLR_DISCRITAXIRUR() volatile
    {
        return ACTLR & (1u << 15u);
    }

    /**
     * Set ACTLR's DISCRITAXIRUR bit.
     *
     * Disables critical AXI Read-Under-Read.
     */
    inline void set_ACTLR_DISCRITAXIRUR() volatile
    {
        ACTLR |= 1u << 15u;
    }

    /**
     * Clear ACTLR's DISCRITAXIRUR bit.
     *
     * Disables critical AXI Read-Under-Read.
     */
    inline void clear_ACTLR_DISCRITAXIRUR() volatile
    {
        ACTLR &= ~(1u << 15u);
    }

    /**
     * Toggle ACTLR's DISCRITAXIRUR bit.
     *
     * Disables critical AXI Read-Under-Read.
     */
    inline void toggle_ACTLR_DISCRITAXIRUR() volatile
    {
        ACTLR ^= 1u << 15u;
    }

    /**
     * Get ACTLR's DISBTACALLOC bit.
     *
     * Disables BTAC allocate.
     */
    inline bool get_ACTLR_DISBTACALLOC() volatile
    {
        return ACTLR & (1u << 14u);
    }

    /**
     * Set ACTLR's DISBTACALLOC bit.
     *
     * Disables BTAC allocate.
     */
    inline void set_ACTLR_DISBTACALLOC() volatile
    {
        ACTLR |= 1u << 14u;
    }

    /**
     * Clear ACTLR's DISBTACALLOC bit.
     *
     * Disables BTAC allocate.
     */
    inline void clear_ACTLR_DISBTACALLOC() volatile
    {
        ACTLR &= ~(1u << 14u);
    }

    /**
     * Toggle ACTLR's DISBTACALLOC bit.
     *
     * Disables BTAC allocate.
     */
    inline void toggle_ACTLR_DISBTACALLOC() volatile
    {
        ACTLR ^= 1u << 14u;
    }

    /**
     * Get ACTLR's DISBTACREAD bit.
     *
     * Disables BTAC read.
     */
    inline bool get_ACTLR_DISBTACREAD() volatile
    {
        return ACTLR & (1u << 13u);
    }

    /**
     * Set ACTLR's DISBTACREAD bit.
     *
     * Disables BTAC read.
     */
    inline void set_ACTLR_DISBTACREAD() volatile
    {
        ACTLR |= 1u << 13u;
    }

    /**
     * Clear ACTLR's DISBTACREAD bit.
     *
     * Disables BTAC read.
     */
    inline void clear_ACTLR_DISBTACREAD() volatile
    {
        ACTLR &= ~(1u << 13u);
    }

    /**
     * Toggle ACTLR's DISBTACREAD bit.
     *
     * Disables BTAC read.
     */
    inline void toggle_ACTLR_DISBTACREAD() volatile
    {
        ACTLR ^= 1u << 13u;
    }

    /**
     * Get ACTLR's DISITMATBFLUSH bit.
     *
     * Disables ITM and DWT ATB flush.
     */
    inline bool get_ACTLR_DISITMATBFLUSH() volatile
    {
        return ACTLR & (1u << 12u);
    }

    /**
     * Set ACTLR's DISITMATBFLUSH bit.
     *
     * Disables ITM and DWT ATB flush.
     */
    inline void set_ACTLR_DISITMATBFLUSH() volatile
    {
        ACTLR |= 1u << 12u;
    }

    /**
     * Clear ACTLR's DISITMATBFLUSH bit.
     *
     * Disables ITM and DWT ATB flush.
     */
    inline void clear_ACTLR_DISITMATBFLUSH() volatile
    {
        ACTLR &= ~(1u << 12u);
    }

    /**
     * Toggle ACTLR's DISITMATBFLUSH bit.
     *
     * Disables ITM and DWT ATB flush.
     */
    inline void toggle_ACTLR_DISITMATBFLUSH() volatile
    {
        ACTLR ^= 1u << 12u;
    }

    /**
     * Get ACTLR's DISRAMODE bit.
     *
     * Disables dynamic read allocate mode for Write-Back Write-Allocate memory
     * regions.
     */
    inline bool get_ACTLR_DISRAMODE() volatile
    {
        return ACTLR & (1u << 11u);
    }

    /**
     * Set ACTLR's DISRAMODE bit.
     *
     * Disables dynamic read allocate mode for Write-Back Write-Allocate memory
     * regions.
     */
    inline void set_ACTLR_DISRAMODE() volatile
    {
        ACTLR |= 1u << 11u;
    }

    /**
     * Clear ACTLR's DISRAMODE bit.
     *
     * Disables dynamic read allocate mode for Write-Back Write-Allocate memory
     * regions.
     */
    inline void clear_ACTLR_DISRAMODE() volatile
    {
        ACTLR &= ~(1u << 11u);
    }

    /**
     * Toggle ACTLR's DISRAMODE bit.
     *
     * Disables dynamic read allocate mode for Write-Back Write-Allocate memory
     * regions.
     */
    inline void toggle_ACTLR_DISRAMODE() volatile
    {
        ACTLR ^= 1u << 11u;
    }

    /**
     * Get ACTLR's FPEXCODIS bit.
     *
     * Disables FPU exception outputs.
     */
    inline bool get_ACTLR_FPEXCODIS() volatile
    {
        return ACTLR & (1u << 10u);
    }

    /**
     * Set ACTLR's FPEXCODIS bit.
     *
     * Disables FPU exception outputs.
     */
    inline void set_ACTLR_FPEXCODIS() volatile
    {
        ACTLR |= 1u << 10u;
    }

    /**
     * Clear ACTLR's FPEXCODIS bit.
     *
     * Disables FPU exception outputs.
     */
    inline void clear_ACTLR_FPEXCODIS() volatile
    {
        ACTLR &= ~(1u << 10u);
    }

    /**
     * Toggle ACTLR's FPEXCODIS bit.
     *
     * Disables FPU exception outputs.
     */
    inline void toggle_ACTLR_FPEXCODIS() volatile
    {
        ACTLR ^= 1u << 10u;
    }

    /**
     * Get ACTLR's DISFOLD bit.
     *
     * Disables folding of IT instructions.
     */
    inline bool get_ACTLR_DISFOLD() volatile
    {
        return ACTLR & (1u << 2u);
    }

    /**
     * Set ACTLR's DISFOLD bit.
     *
     * Disables folding of IT instructions.
     */
    inline void set_ACTLR_DISFOLD() volatile
    {
        ACTLR |= 1u << 2u;
    }

    /**
     * Clear ACTLR's DISFOLD bit.
     *
     * Disables folding of IT instructions.
     */
    inline void clear_ACTLR_DISFOLD() volatile
    {
        ACTLR &= ~(1u << 2u);
    }

    /**
     * Toggle ACTLR's DISFOLD bit.
     *
     * Disables folding of IT instructions.
     */
    inline void toggle_ACTLR_DISFOLD() volatile
    {
        ACTLR ^= 1u << 2u;
    }

    /**
     * Get all of ACTLR's bit fields.
     *
     * (read-write) Auxiliary Control Register,
     */
    inline void get_ACTLR(bool &DISFPUISSOPT, bool &DISCRITAXIRUW,
                          bool &DISDYNADD,
                          SystemControl_ACTLR_DISISSCH1 &DISISSCH1,
                          SystemControl_ACTLR_DISDI &DISDI,
                          bool &DISCRITAXIRUR, bool &DISBTACALLOC,
                          bool &DISBTACREAD, bool &DISITMATBFLUSH,
                          bool &DISRAMODE, bool &FPEXCODIS,
                          bool &DISFOLD) volatile
    {
        uint32_t curr = ACTLR;

        DISFPUISSOPT = curr & (1u << 28u);
        DISCRITAXIRUW = curr & (1u << 27u);
        DISDYNADD = curr & (1u << 26u);
        DISISSCH1 = SystemControl_ACTLR_DISISSCH1((curr >> 21u) & 0b11111u);
        DISDI = SystemControl_ACTLR_DISDI((curr >> 16u) & 0b11111u);
        DISCRITAXIRUR = curr & (1u << 15u);
        DISBTACALLOC = curr & (1u << 14u);
        DISBTACREAD = curr & (1u << 13u);
        DISITMATBFLUSH = curr & (1u << 12u);
        DISRAMODE = curr & (1u << 11u);
        FPEXCODIS = curr & (1u << 10u);
        DISFOLD = curr & (1u << 2u);
    }

    /**
     * Set all of ACTLR's bit fields.
     *
     * (read-write) Auxiliary Control Register,
     */
    inline void set_ACTLR(bool DISFPUISSOPT, bool DISCRITAXIRUW,
                          bool DISDYNADD,
                          SystemControl_ACTLR_DISISSCH1 DISISSCH1,
                          SystemControl_ACTLR_DISDI DISDI, bool DISCRITAXIRUR,
                          bool DISBTACALLOC, bool DISBTACREAD,
                          bool DISITMATBFLUSH, bool DISRAMODE, bool FPEXCODIS,
                          bool DISFOLD) volatile
    {
        uint32_t curr = ACTLR;

        curr &= ~(0b1u << 28u);
        curr |= (DISFPUISSOPT & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (DISCRITAXIRUW & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (DISDYNADD & 0b1u) << 26u;
        curr &= ~(0b11111u << 21u);
        curr |= (std::to_underlying(DISISSCH1) & 0b11111u) << 21u;
        curr &= ~(0b11111u << 16u);
        curr |= (std::to_underlying(DISDI) & 0b11111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (DISCRITAXIRUR & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (DISBTACALLOC & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (DISBTACREAD & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (DISITMATBFLUSH & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (DISRAMODE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (FPEXCODIS & 0b1u) << 10u;
        curr &= ~(0b1u << 2u);
        curr |= (DISFOLD & 0b1u) << 2u;

        ACTLR = curr;
    }

    /**
     * Get CPUID's IMPLEMENTER field.
     *
     * Implementer code
     */
    inline uint8_t get_CPUID_IMPLEMENTER() volatile
    {
        return (CPUID >> 24u) & 0b11111111u;
    }

    /**
     * Get CPUID's VARIANT field.
     *
     * Indicates processor revision: 0x2 = Revision 2
     */
    inline uint8_t get_CPUID_VARIANT() volatile
    {
        return (CPUID >> 20u) & 0b1111u;
    }

    /**
     * Get CPUID's ARCHITECTURE field.
     *
     * ARCHITECTURE
     */
    inline uint8_t get_CPUID_ARCHITECTURE() volatile
    {
        return (CPUID >> 16u) & 0b1111u;
    }

    /**
     * Get CPUID's PARTNO field.
     *
     * Indicates part number
     */
    inline uint16_t get_CPUID_PARTNO() volatile
    {
        return (CPUID >> 4u) & 0b111111111111u;
    }

    /**
     * Get CPUID's REVISION field.
     *
     * Indicates patch release: 0x0 = Patch 0
     */
    inline uint8_t get_CPUID_REVISION() volatile
    {
        return (CPUID >> 0u) & 0b1111u;
    }

    /**
     * Get all of CPUID's bit fields.
     *
     * (read-write) CPUID Base Register
     */
    inline void get_CPUID(uint8_t &IMPLEMENTER, uint8_t &VARIANT,
                          uint8_t &ARCHITECTURE, uint16_t &PARTNO,
                          uint8_t &REVISION) volatile
    {
        uint32_t curr = CPUID;

        IMPLEMENTER = (curr >> 24u) & 0b11111111u;
        VARIANT = (curr >> 20u) & 0b1111u;
        ARCHITECTURE = (curr >> 16u) & 0b1111u;
        PARTNO = (curr >> 4u) & 0b111111111111u;
        REVISION = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit
     */
    inline bool get_ICSR_NMIPENDSET() volatile
    {
        return ICSR & (1u << 31u);
    }

    /**
     * Set ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit
     */
    inline void set_ICSR_NMIPENDSET() volatile
    {
        ICSR |= 1u << 31u;
    }

    /**
     * Clear ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit
     */
    inline void clear_ICSR_NMIPENDSET() volatile
    {
        ICSR &= ~(1u << 31u);
    }

    /**
     * Toggle ICSR's NMIPENDSET bit.
     *
     * NMI set-pending bit
     */
    inline void toggle_ICSR_NMIPENDSET() volatile
    {
        ICSR ^= 1u << 31u;
    }

    /**
     * Get ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit
     */
    inline bool get_ICSR_PENDSVSET() volatile
    {
        return ICSR & (1u << 28u);
    }

    /**
     * Set ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit
     */
    inline void set_ICSR_PENDSVSET() volatile
    {
        ICSR |= 1u << 28u;
    }

    /**
     * Clear ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit
     */
    inline void clear_ICSR_PENDSVSET() volatile
    {
        ICSR &= ~(1u << 28u);
    }

    /**
     * Toggle ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit
     */
    inline void toggle_ICSR_PENDSVSET() volatile
    {
        ICSR ^= 1u << 28u;
    }

    /**
     * Set ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit
     */
    inline void set_ICSR_PENDSVCLR() volatile
    {
        ICSR |= 1u << 27u;
    }

    /**
     * Clear ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit
     */
    inline void clear_ICSR_PENDSVCLR() volatile
    {
        ICSR &= ~(1u << 27u);
    }

    /**
     * Toggle ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit
     */
    inline void toggle_ICSR_PENDSVCLR() volatile
    {
        ICSR ^= 1u << 27u;
    }

    /**
     * Get ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline bool get_ICSR_PENDSTSET() volatile
    {
        return ICSR & (1u << 26u);
    }

    /**
     * Set ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline void set_ICSR_PENDSTSET() volatile
    {
        ICSR |= 1u << 26u;
    }

    /**
     * Clear ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline void clear_ICSR_PENDSTSET() volatile
    {
        ICSR &= ~(1u << 26u);
    }

    /**
     * Toggle ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit
     */
    inline void toggle_ICSR_PENDSTSET() volatile
    {
        ICSR ^= 1u << 26u;
    }

    /**
     * Set ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit
     */
    inline void set_ICSR_PENDSTCLR() volatile
    {
        ICSR |= 1u << 25u;
    }

    /**
     * Clear ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit
     */
    inline void clear_ICSR_PENDSTCLR() volatile
    {
        ICSR &= ~(1u << 25u);
    }

    /**
     * Toggle ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit
     */
    inline void toggle_ICSR_PENDSTCLR() volatile
    {
        ICSR ^= 1u << 25u;
    }

    /**
     * Get ICSR's ISRPENDING bit.
     *
     * Interrupt pending flag, excluding NMI and Faults
     */
    inline bool get_ICSR_ISRPENDING() volatile
    {
        return ICSR & (1u << 22u);
    }

    /**
     * Get ICSR's VECTPENDING field.
     *
     * Exception number of the highest priority pending enabled exception
     */
    inline uint16_t get_ICSR_VECTPENDING() volatile
    {
        return (ICSR >> 12u) & 0b111111111u;
    }

    /**
     * Get ICSR's RETTOBASE bit.
     *
     * Indicates whether there are preempted active exceptions
     */
    inline bool get_ICSR_RETTOBASE() volatile
    {
        return ICSR & (1u << 11u);
    }

    /**
     * Get ICSR's VECTACTIVE field.
     *
     * Active exception number
     */
    inline uint16_t get_ICSR_VECTACTIVE() volatile
    {
        return (ICSR >> 0u) & 0b111111111u;
    }

    /**
     * Get all of ICSR's bit fields.
     *
     * (read-write) Interrupt Control and State Register
     */
    inline void get_ICSR(bool &NMIPENDSET, bool &PENDSVSET, bool &PENDSTSET,
                         bool &ISRPENDING, uint16_t &VECTPENDING,
                         bool &RETTOBASE, uint16_t &VECTACTIVE) volatile
    {
        uint32_t curr = ICSR;

        NMIPENDSET = curr & (1u << 31u);
        PENDSVSET = curr & (1u << 28u);
        PENDSTSET = curr & (1u << 26u);
        ISRPENDING = curr & (1u << 22u);
        VECTPENDING = (curr >> 12u) & 0b111111111u;
        RETTOBASE = curr & (1u << 11u);
        VECTACTIVE = (curr >> 0u) & 0b111111111u;
    }

    /**
     * Set all of ICSR's bit fields.
     *
     * (read-write) Interrupt Control and State Register
     */
    inline void set_ICSR(bool NMIPENDSET, bool PENDSVSET, bool PENDSVCLR,
                         bool PENDSTSET, bool PENDSTCLR) volatile
    {
        uint32_t curr = ICSR;

        curr &= ~(0b1u << 31u);
        curr |= (NMIPENDSET & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (PENDSVSET & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (PENDSVCLR & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (PENDSTSET & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (PENDSTCLR & 0b1u) << 25u;

        ICSR = curr;
    }

    /**
     * Get VTOR's TBLOFF field.
     *
     * Vector table base offset
     */
    inline uint32_t get_VTOR_TBLOFF() volatile
    {
        return (VTOR >> 7u) & 0b1111111111111111111111111u;
    }

    /**
     * Set VTOR's TBLOFF field.
     *
     * Vector table base offset
     */
    inline void set_VTOR_TBLOFF(uint32_t value) volatile
    {
        uint32_t curr = VTOR;

        curr &= ~(0b1111111111111111111111111u << 7u);
        curr |= (value & 0b1111111111111111111111111u) << 7u;

        VTOR = curr;
    }

    /**
     * Get AIRCR's VECTKEY field.
     *
     * Register key
     */
    inline uint16_t get_AIRCR_VECTKEY() volatile
    {
        return (AIRCR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set AIRCR's VECTKEY field.
     *
     * Register key
     */
    inline void set_AIRCR_VECTKEY(uint16_t value) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get AIRCR's ENDIANNESS bit.
     *
     * Data endianness
     */
    inline bool get_AIRCR_ENDIANNESS() volatile
    {
        return AIRCR & (1u << 15u);
    }

    /**
     * Get AIRCR's PRIGROUP field.
     *
     * Interrupt priority grouping field. This field determines the split of
     * group priority from subpriority.
     */
    inline uint8_t get_AIRCR_PRIGROUP() volatile
    {
        return (AIRCR >> 8u) & 0b111u;
    }

    /**
     * Set AIRCR's PRIGROUP field.
     *
     * Interrupt priority grouping field. This field determines the split of
     * group priority from subpriority.
     */
    inline void set_AIRCR_PRIGROUP(uint8_t value) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        AIRCR = curr;
    }

    /**
     * Set AIRCR's SYSRESETREQ bit.
     *
     * System reset request
     */
    inline void set_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR |= 1u << 2u;
    }

    /**
     * Clear AIRCR's SYSRESETREQ bit.
     *
     * System reset request
     */
    inline void clear_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR &= ~(1u << 2u);
    }

    /**
     * Toggle AIRCR's SYSRESETREQ bit.
     *
     * System reset request
     */
    inline void toggle_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR ^= 1u << 2u;
    }

    /**
     * Set AIRCR's VECTCLRACTIVE bit.
     *
     * Writing 1 to this bit clears all active state information for fixed and
     * configurable exceptions.
     */
    inline void set_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR |= 1u << 1u;
    }

    /**
     * Clear AIRCR's VECTCLRACTIVE bit.
     *
     * Writing 1 to this bit clears all active state information for fixed and
     * configurable exceptions.
     */
    inline void clear_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR &= ~(1u << 1u);
    }

    /**
     * Toggle AIRCR's VECTCLRACTIVE bit.
     *
     * Writing 1 to this bit clears all active state information for fixed and
     * configurable exceptions.
     */
    inline void toggle_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR ^= 1u << 1u;
    }

    /**
     * Set AIRCR's VECTRESET bit.
     *
     * Writing 1 to this bit causes a local system reset
     */
    inline void set_AIRCR_VECTRESET() volatile
    {
        AIRCR |= 1u << 0u;
    }

    /**
     * Clear AIRCR's VECTRESET bit.
     *
     * Writing 1 to this bit causes a local system reset
     */
    inline void clear_AIRCR_VECTRESET() volatile
    {
        AIRCR &= ~(1u << 0u);
    }

    /**
     * Toggle AIRCR's VECTRESET bit.
     *
     * Writing 1 to this bit causes a local system reset
     */
    inline void toggle_AIRCR_VECTRESET() volatile
    {
        AIRCR ^= 1u << 0u;
    }

    /**
     * Get all of AIRCR's bit fields.
     *
     * (read-write) Application Interrupt and Reset Control Register
     */
    inline void get_AIRCR(uint16_t &VECTKEY, bool &ENDIANNESS,
                          uint8_t &PRIGROUP) volatile
    {
        uint32_t curr = AIRCR;

        VECTKEY = (curr >> 16u) & 0b1111111111111111u;
        ENDIANNESS = curr & (1u << 15u);
        PRIGROUP = (curr >> 8u) & 0b111u;
    }

    /**
     * Set all of AIRCR's bit fields.
     *
     * (read-write) Application Interrupt and Reset Control Register
     */
    inline void set_AIRCR(uint16_t VECTKEY, uint8_t PRIGROUP, bool SYSRESETREQ,
                          bool VECTCLRACTIVE, bool VECTRESET) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (VECTKEY & 0b1111111111111111u) << 16u;
        curr &= ~(0b111u << 8u);
        curr |= (PRIGROUP & 0b111u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (SYSRESETREQ & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (VECTCLRACTIVE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VECTRESET & 0b1u) << 0u;

        AIRCR = curr;
    }

    /**
     * Get SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit
     */
    inline bool get_SCR_SEVONPEND() volatile
    {
        return SCR & (1u << 4u);
    }

    /**
     * Set SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit
     */
    inline void set_SCR_SEVONPEND() volatile
    {
        SCR |= 1u << 4u;
    }

    /**
     * Clear SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit
     */
    inline void clear_SCR_SEVONPEND() volatile
    {
        SCR &= ~(1u << 4u);
    }

    /**
     * Toggle SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit
     */
    inline void toggle_SCR_SEVONPEND() volatile
    {
        SCR ^= 1u << 4u;
    }

    /**
     * Get SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode
     */
    inline bool get_SCR_SLEEPDEEP() volatile
    {
        return SCR & (1u << 2u);
    }

    /**
     * Set SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode
     */
    inline void set_SCR_SLEEPDEEP() volatile
    {
        SCR |= 1u << 2u;
    }

    /**
     * Clear SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode
     */
    inline void clear_SCR_SLEEPDEEP() volatile
    {
        SCR &= ~(1u << 2u);
    }

    /**
     * Toggle SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode
     */
    inline void toggle_SCR_SLEEPDEEP() volatile
    {
        SCR ^= 1u << 2u;
    }

    /**
     * Get SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread mode
     */
    inline bool get_SCR_SLEEPONEXIT() volatile
    {
        return SCR & (1u << 1u);
    }

    /**
     * Set SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread mode
     */
    inline void set_SCR_SLEEPONEXIT() volatile
    {
        SCR |= 1u << 1u;
    }

    /**
     * Clear SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread mode
     */
    inline void clear_SCR_SLEEPONEXIT() volatile
    {
        SCR &= ~(1u << 1u);
    }

    /**
     * Toggle SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread mode
     */
    inline void toggle_SCR_SLEEPONEXIT() volatile
    {
        SCR ^= 1u << 1u;
    }

    /**
     * Get all of SCR's bit fields.
     *
     * (read-write) System Control Register
     */
    inline void get_SCR(bool &SEVONPEND, bool &SLEEPDEEP,
                        bool &SLEEPONEXIT) volatile
    {
        uint32_t curr = SCR;

        SEVONPEND = curr & (1u << 4u);
        SLEEPDEEP = curr & (1u << 2u);
        SLEEPONEXIT = curr & (1u << 1u);
    }

    /**
     * Set all of SCR's bit fields.
     *
     * (read-write) System Control Register
     */
    inline void set_SCR(bool SEVONPEND, bool SLEEPDEEP,
                        bool SLEEPONEXIT) volatile
    {
        uint32_t curr = SCR;

        curr &= ~(0b1u << 4u);
        curr |= (SEVONPEND & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (SLEEPDEEP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SLEEPONEXIT & 0b1u) << 1u;

        SCR = curr;
    }

    /**
     * Get CCR's BP bit.
     *
     * Always reads-as-one. It indicates branch prediction is enabled.
     */
    inline bool get_CCR_BP() volatile
    {
        return CCR & (1u << 18u);
    }

    /**
     * Get CCR's IC bit.
     *
     * Enables L1 instruction cache.
     */
    inline bool get_CCR_IC() volatile
    {
        return CCR & (1u << 17u);
    }

    /**
     * Set CCR's IC bit.
     *
     * Enables L1 instruction cache.
     */
    inline void set_CCR_IC() volatile
    {
        CCR |= 1u << 17u;
    }

    /**
     * Clear CCR's IC bit.
     *
     * Enables L1 instruction cache.
     */
    inline void clear_CCR_IC() volatile
    {
        CCR &= ~(1u << 17u);
    }

    /**
     * Toggle CCR's IC bit.
     *
     * Enables L1 instruction cache.
     */
    inline void toggle_CCR_IC() volatile
    {
        CCR ^= 1u << 17u;
    }

    /**
     * Get CCR's DC bit.
     *
     * Enables L1 data cache.
     */
    inline bool get_CCR_DC() volatile
    {
        return CCR & (1u << 16u);
    }

    /**
     * Set CCR's DC bit.
     *
     * Enables L1 data cache.
     */
    inline void set_CCR_DC() volatile
    {
        CCR |= 1u << 16u;
    }

    /**
     * Clear CCR's DC bit.
     *
     * Enables L1 data cache.
     */
    inline void clear_CCR_DC() volatile
    {
        CCR &= ~(1u << 16u);
    }

    /**
     * Toggle CCR's DC bit.
     *
     * Enables L1 data cache.
     */
    inline void toggle_CCR_DC() volatile
    {
        CCR ^= 1u << 16u;
    }

    /**
     * Get CCR's STKALIGN bit.
     *
     * Indicates stack alignment on exception entry
     */
    inline bool get_CCR_STKALIGN() volatile
    {
        return CCR & (1u << 9u);
    }

    /**
     * Set CCR's STKALIGN bit.
     *
     * Indicates stack alignment on exception entry
     */
    inline void set_CCR_STKALIGN() volatile
    {
        CCR |= 1u << 9u;
    }

    /**
     * Clear CCR's STKALIGN bit.
     *
     * Indicates stack alignment on exception entry
     */
    inline void clear_CCR_STKALIGN() volatile
    {
        CCR &= ~(1u << 9u);
    }

    /**
     * Toggle CCR's STKALIGN bit.
     *
     * Indicates stack alignment on exception entry
     */
    inline void toggle_CCR_STKALIGN() volatile
    {
        CCR ^= 1u << 9u;
    }

    /**
     * Get CCR's BFHFNMIGN bit.
     *
     * Enables handlers with priority -1 or -2 to ignore data BusFaults caused
     * by load and store instructions.
     */
    inline bool get_CCR_BFHFNMIGN() volatile
    {
        return CCR & (1u << 8u);
    }

    /**
     * Set CCR's BFHFNMIGN bit.
     *
     * Enables handlers with priority -1 or -2 to ignore data BusFaults caused
     * by load and store instructions.
     */
    inline void set_CCR_BFHFNMIGN() volatile
    {
        CCR |= 1u << 8u;
    }

    /**
     * Clear CCR's BFHFNMIGN bit.
     *
     * Enables handlers with priority -1 or -2 to ignore data BusFaults caused
     * by load and store instructions.
     */
    inline void clear_CCR_BFHFNMIGN() volatile
    {
        CCR &= ~(1u << 8u);
    }

    /**
     * Toggle CCR's BFHFNMIGN bit.
     *
     * Enables handlers with priority -1 or -2 to ignore data BusFaults caused
     * by load and store instructions.
     */
    inline void toggle_CCR_BFHFNMIGN() volatile
    {
        CCR ^= 1u << 8u;
    }

    /**
     * Get CCR's DIV_0_TRP bit.
     *
     * Enables faulting or halting when the processor executes an SDIV or UDIV
     * instruction with a divisor of 0
     */
    inline bool get_CCR_DIV_0_TRP() volatile
    {
        return CCR & (1u << 4u);
    }

    /**
     * Set CCR's DIV_0_TRP bit.
     *
     * Enables faulting or halting when the processor executes an SDIV or UDIV
     * instruction with a divisor of 0
     */
    inline void set_CCR_DIV_0_TRP() volatile
    {
        CCR |= 1u << 4u;
    }

    /**
     * Clear CCR's DIV_0_TRP bit.
     *
     * Enables faulting or halting when the processor executes an SDIV or UDIV
     * instruction with a divisor of 0
     */
    inline void clear_CCR_DIV_0_TRP() volatile
    {
        CCR &= ~(1u << 4u);
    }

    /**
     * Toggle CCR's DIV_0_TRP bit.
     *
     * Enables faulting or halting when the processor executes an SDIV or UDIV
     * instruction with a divisor of 0
     */
    inline void toggle_CCR_DIV_0_TRP() volatile
    {
        CCR ^= 1u << 4u;
    }

    /**
     * Get CCR's UNALIGN_TRP bit.
     *
     * Enables unaligned access traps
     */
    inline bool get_CCR_UNALIGN_TRP() volatile
    {
        return CCR & (1u << 3u);
    }

    /**
     * Set CCR's UNALIGN_TRP bit.
     *
     * Enables unaligned access traps
     */
    inline void set_CCR_UNALIGN_TRP() volatile
    {
        CCR |= 1u << 3u;
    }

    /**
     * Clear CCR's UNALIGN_TRP bit.
     *
     * Enables unaligned access traps
     */
    inline void clear_CCR_UNALIGN_TRP() volatile
    {
        CCR &= ~(1u << 3u);
    }

    /**
     * Toggle CCR's UNALIGN_TRP bit.
     *
     * Enables unaligned access traps
     */
    inline void toggle_CCR_UNALIGN_TRP() volatile
    {
        CCR ^= 1u << 3u;
    }

    /**
     * Get CCR's USERSETMPEND bit.
     *
     * Enables unprivileged software access to the STIR
     */
    inline bool get_CCR_USERSETMPEND() volatile
    {
        return CCR & (1u << 1u);
    }

    /**
     * Set CCR's USERSETMPEND bit.
     *
     * Enables unprivileged software access to the STIR
     */
    inline void set_CCR_USERSETMPEND() volatile
    {
        CCR |= 1u << 1u;
    }

    /**
     * Clear CCR's USERSETMPEND bit.
     *
     * Enables unprivileged software access to the STIR
     */
    inline void clear_CCR_USERSETMPEND() volatile
    {
        CCR &= ~(1u << 1u);
    }

    /**
     * Toggle CCR's USERSETMPEND bit.
     *
     * Enables unprivileged software access to the STIR
     */
    inline void toggle_CCR_USERSETMPEND() volatile
    {
        CCR ^= 1u << 1u;
    }

    /**
     * Get CCR's NONBASETHRDENA bit.
     *
     * Indicates how the processor enters Thread mode
     */
    inline bool get_CCR_NONBASETHRDENA() volatile
    {
        return CCR & (1u << 0u);
    }

    /**
     * Set CCR's NONBASETHRDENA bit.
     *
     * Indicates how the processor enters Thread mode
     */
    inline void set_CCR_NONBASETHRDENA() volatile
    {
        CCR |= 1u << 0u;
    }

    /**
     * Clear CCR's NONBASETHRDENA bit.
     *
     * Indicates how the processor enters Thread mode
     */
    inline void clear_CCR_NONBASETHRDENA() volatile
    {
        CCR &= ~(1u << 0u);
    }

    /**
     * Toggle CCR's NONBASETHRDENA bit.
     *
     * Indicates how the processor enters Thread mode
     */
    inline void toggle_CCR_NONBASETHRDENA() volatile
    {
        CCR ^= 1u << 0u;
    }

    /**
     * Get all of CCR's bit fields.
     *
     * (read-write) Configuration and Control Register
     */
    inline void get_CCR(bool &BP, bool &IC, bool &DC, bool &STKALIGN,
                        bool &BFHFNMIGN, bool &DIV_0_TRP, bool &UNALIGN_TRP,
                        bool &USERSETMPEND, bool &NONBASETHRDENA) volatile
    {
        uint32_t curr = CCR;

        BP = curr & (1u << 18u);
        IC = curr & (1u << 17u);
        DC = curr & (1u << 16u);
        STKALIGN = curr & (1u << 9u);
        BFHFNMIGN = curr & (1u << 8u);
        DIV_0_TRP = curr & (1u << 4u);
        UNALIGN_TRP = curr & (1u << 3u);
        USERSETMPEND = curr & (1u << 1u);
        NONBASETHRDENA = curr & (1u << 0u);
    }

    /**
     * Set all of CCR's bit fields.
     *
     * (read-write) Configuration and Control Register
     */
    inline void set_CCR(bool IC, bool DC, bool STKALIGN, bool BFHFNMIGN,
                        bool DIV_0_TRP, bool UNALIGN_TRP, bool USERSETMPEND,
                        bool NONBASETHRDENA) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b1u << 17u);
        curr |= (IC & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DC & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (STKALIGN & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (BFHFNMIGN & 0b1u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (DIV_0_TRP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (UNALIGN_TRP & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (USERSETMPEND & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (NONBASETHRDENA & 0b1u) << 0u;

        CCR = curr;
    }

    /**
     * Get SHPR1's PRI_6 field.
     *
     * Priority of system handler 6, UsageFault
     */
    inline uint8_t get_SHPR1_PRI_6() volatile
    {
        return (SHPR1 >> 16u) & 0b11111111u;
    }

    /**
     * Set SHPR1's PRI_6 field.
     *
     * Priority of system handler 6, UsageFault
     */
    inline void set_SHPR1_PRI_6(uint8_t value) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        SHPR1 = curr;
    }

    /**
     * Get SHPR1's PRI_5 field.
     *
     * Priority of system handler 5, BusFault
     */
    inline uint8_t get_SHPR1_PRI_5() volatile
    {
        return (SHPR1 >> 8u) & 0b11111111u;
    }

    /**
     * Set SHPR1's PRI_5 field.
     *
     * Priority of system handler 5, BusFault
     */
    inline void set_SHPR1_PRI_5(uint8_t value) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SHPR1 = curr;
    }

    /**
     * Get SHPR1's PRI_4 field.
     *
     * Priority of system handler 4, MemManage
     */
    inline uint8_t get_SHPR1_PRI_4() volatile
    {
        return (SHPR1 >> 0u) & 0b11111111u;
    }

    /**
     * Set SHPR1's PRI_4 field.
     *
     * Priority of system handler 4, MemManage
     */
    inline void set_SHPR1_PRI_4(uint8_t value) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SHPR1 = curr;
    }

    /**
     * Get all of SHPR1's bit fields.
     *
     * (read-write) System Handler Priority Register 1
     */
    inline void get_SHPR1(uint8_t &PRI_6, uint8_t &PRI_5,
                          uint8_t &PRI_4) volatile
    {
        uint32_t curr = SHPR1;

        PRI_6 = (curr >> 16u) & 0b11111111u;
        PRI_5 = (curr >> 8u) & 0b11111111u;
        PRI_4 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of SHPR1's bit fields.
     *
     * (read-write) System Handler Priority Register 1
     */
    inline void set_SHPR1(uint8_t PRI_6, uint8_t PRI_5, uint8_t PRI_4) volatile
    {
        uint32_t curr = SHPR1;

        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_6 & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (PRI_5 & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (PRI_4 & 0b11111111u) << 0u;

        SHPR1 = curr;
    }

    /**
     * Get SHPR2's PRI_11 field.
     *
     * Priority of system handler 11, SVCall
     */
    inline uint8_t get_SHPR2_PRI_11() volatile
    {
        return (SHPR2 >> 24u) & 0b11111111u;
    }

    /**
     * Set SHPR2's PRI_11 field.
     *
     * Priority of system handler 11, SVCall
     */
    inline void set_SHPR2_PRI_11(uint8_t value) volatile
    {
        uint32_t curr = SHPR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        SHPR2 = curr;
    }

    /**
     * Get SHPR3's PRI_15 field.
     *
     * Priority of system handler 15, SysTick exception
     */
    inline uint8_t get_SHPR3_PRI_15() volatile
    {
        return (SHPR3 >> 24u) & 0b11111111u;
    }

    /**
     * Set SHPR3's PRI_15 field.
     *
     * Priority of system handler 15, SysTick exception
     */
    inline void set_SHPR3_PRI_15(uint8_t value) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        SHPR3 = curr;
    }

    /**
     * Get SHPR3's PRI_14 field.
     *
     * Priority of system handler 14, PendSV
     */
    inline uint8_t get_SHPR3_PRI_14() volatile
    {
        return (SHPR3 >> 16u) & 0b11111111u;
    }

    /**
     * Set SHPR3's PRI_14 field.
     *
     * Priority of system handler 14, PendSV
     */
    inline void set_SHPR3_PRI_14(uint8_t value) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        SHPR3 = curr;
    }

    /**
     * Get all of SHPR3's bit fields.
     *
     * (read-write) System Handler Priority Register 3
     */
    inline void get_SHPR3(uint8_t &PRI_15, uint8_t &PRI_14) volatile
    {
        uint32_t curr = SHPR3;

        PRI_15 = (curr >> 24u) & 0b11111111u;
        PRI_14 = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Set all of SHPR3's bit fields.
     *
     * (read-write) System Handler Priority Register 3
     */
    inline void set_SHPR3(uint8_t PRI_15, uint8_t PRI_14) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (PRI_15 & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PRI_14 & 0b11111111u) << 16u;

        SHPR3 = curr;
    }

    /**
     * Get SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline bool get_SHCSR_USGFAULTENA() volatile
    {
        return SHCSR & (1u << 18u);
    }

    /**
     * Set SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline void set_SHCSR_USGFAULTENA() volatile
    {
        SHCSR |= 1u << 18u;
    }

    /**
     * Clear SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline void clear_SHCSR_USGFAULTENA() volatile
    {
        SHCSR &= ~(1u << 18u);
    }

    /**
     * Toggle SHCSR's USGFAULTENA bit.
     *
     * UsageFault enable bit
     */
    inline void toggle_SHCSR_USGFAULTENA() volatile
    {
        SHCSR ^= 1u << 18u;
    }

    /**
     * Get SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline bool get_SHCSR_BUSFAULTENA() volatile
    {
        return SHCSR & (1u << 17u);
    }

    /**
     * Set SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline void set_SHCSR_BUSFAULTENA() volatile
    {
        SHCSR |= 1u << 17u;
    }

    /**
     * Clear SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline void clear_SHCSR_BUSFAULTENA() volatile
    {
        SHCSR &= ~(1u << 17u);
    }

    /**
     * Toggle SHCSR's BUSFAULTENA bit.
     *
     * BusFault enable bit
     */
    inline void toggle_SHCSR_BUSFAULTENA() volatile
    {
        SHCSR ^= 1u << 17u;
    }

    /**
     * Get SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline bool get_SHCSR_MEMFAULTENA() volatile
    {
        return SHCSR & (1u << 16u);
    }

    /**
     * Set SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline void set_SHCSR_MEMFAULTENA() volatile
    {
        SHCSR |= 1u << 16u;
    }

    /**
     * Clear SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline void clear_SHCSR_MEMFAULTENA() volatile
    {
        SHCSR &= ~(1u << 16u);
    }

    /**
     * Toggle SHCSR's MEMFAULTENA bit.
     *
     * MemManage enable bit
     */
    inline void toggle_SHCSR_MEMFAULTENA() volatile
    {
        SHCSR ^= 1u << 16u;
    }

    /**
     * Get SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline bool get_SHCSR_SVCALLPENDED() volatile
    {
        return SHCSR & (1u << 15u);
    }

    /**
     * Set SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline void set_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR |= 1u << 15u;
    }

    /**
     * Clear SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline void clear_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR &= ~(1u << 15u);
    }

    /**
     * Toggle SHCSR's SVCALLPENDED bit.
     *
     * SVCall pending bit
     */
    inline void toggle_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR ^= 1u << 15u;
    }

    /**
     * Get SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline bool get_SHCSR_BUSFAULTPENDED() volatile
    {
        return SHCSR & (1u << 14u);
    }

    /**
     * Set SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline void set_SHCSR_BUSFAULTPENDED() volatile
    {
        SHCSR |= 1u << 14u;
    }

    /**
     * Clear SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline void clear_SHCSR_BUSFAULTPENDED() volatile
    {
        SHCSR &= ~(1u << 14u);
    }

    /**
     * Toggle SHCSR's BUSFAULTPENDED bit.
     *
     * BusFault exception pending bit
     */
    inline void toggle_SHCSR_BUSFAULTPENDED() volatile
    {
        SHCSR ^= 1u << 14u;
    }

    /**
     * Get SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline bool get_SHCSR_MEMFAULTPENDED() volatile
    {
        return SHCSR & (1u << 13u);
    }

    /**
     * Set SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline void set_SHCSR_MEMFAULTPENDED() volatile
    {
        SHCSR |= 1u << 13u;
    }

    /**
     * Clear SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline void clear_SHCSR_MEMFAULTPENDED() volatile
    {
        SHCSR &= ~(1u << 13u);
    }

    /**
     * Toggle SHCSR's MEMFAULTPENDED bit.
     *
     * MemManage exception pending bit
     */
    inline void toggle_SHCSR_MEMFAULTPENDED() volatile
    {
        SHCSR ^= 1u << 13u;
    }

    /**
     * Get SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline bool get_SHCSR_USGFAULTPENDED() volatile
    {
        return SHCSR & (1u << 12u);
    }

    /**
     * Set SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline void set_SHCSR_USGFAULTPENDED() volatile
    {
        SHCSR |= 1u << 12u;
    }

    /**
     * Clear SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline void clear_SHCSR_USGFAULTPENDED() volatile
    {
        SHCSR &= ~(1u << 12u);
    }

    /**
     * Toggle SHCSR's USGFAULTPENDED bit.
     *
     * UsageFault exception pending bit
     */
    inline void toggle_SHCSR_USGFAULTPENDED() volatile
    {
        SHCSR ^= 1u << 12u;
    }

    /**
     * Get SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline bool get_SHCSR_SYSTICKACT() volatile
    {
        return SHCSR & (1u << 11u);
    }

    /**
     * Set SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline void set_SHCSR_SYSTICKACT() volatile
    {
        SHCSR |= 1u << 11u;
    }

    /**
     * Clear SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline void clear_SHCSR_SYSTICKACT() volatile
    {
        SHCSR &= ~(1u << 11u);
    }

    /**
     * Toggle SHCSR's SYSTICKACT bit.
     *
     * SysTick exception active bit
     */
    inline void toggle_SHCSR_SYSTICKACT() volatile
    {
        SHCSR ^= 1u << 11u;
    }

    /**
     * Get SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline bool get_SHCSR_PENDSVACT() volatile
    {
        return SHCSR & (1u << 10u);
    }

    /**
     * Set SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline void set_SHCSR_PENDSVACT() volatile
    {
        SHCSR |= 1u << 10u;
    }

    /**
     * Clear SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline void clear_SHCSR_PENDSVACT() volatile
    {
        SHCSR &= ~(1u << 10u);
    }

    /**
     * Toggle SHCSR's PENDSVACT bit.
     *
     * PendSV exception active bit
     */
    inline void toggle_SHCSR_PENDSVACT() volatile
    {
        SHCSR ^= 1u << 10u;
    }

    /**
     * Get SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline bool get_SHCSR_MONITORACT() volatile
    {
        return SHCSR & (1u << 8u);
    }

    /**
     * Set SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline void set_SHCSR_MONITORACT() volatile
    {
        SHCSR |= 1u << 8u;
    }

    /**
     * Clear SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline void clear_SHCSR_MONITORACT() volatile
    {
        SHCSR &= ~(1u << 8u);
    }

    /**
     * Toggle SHCSR's MONITORACT bit.
     *
     * Debug monitor active bit
     */
    inline void toggle_SHCSR_MONITORACT() volatile
    {
        SHCSR ^= 1u << 8u;
    }

    /**
     * Get SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline bool get_SHCSR_SVCALLACT() volatile
    {
        return SHCSR & (1u << 7u);
    }

    /**
     * Set SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline void set_SHCSR_SVCALLACT() volatile
    {
        SHCSR |= 1u << 7u;
    }

    /**
     * Clear SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline void clear_SHCSR_SVCALLACT() volatile
    {
        SHCSR &= ~(1u << 7u);
    }

    /**
     * Toggle SHCSR's SVCALLACT bit.
     *
     * SVCall active bit
     */
    inline void toggle_SHCSR_SVCALLACT() volatile
    {
        SHCSR ^= 1u << 7u;
    }

    /**
     * Get SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline bool get_SHCSR_USGFAULTACT() volatile
    {
        return SHCSR & (1u << 3u);
    }

    /**
     * Set SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline void set_SHCSR_USGFAULTACT() volatile
    {
        SHCSR |= 1u << 3u;
    }

    /**
     * Clear SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline void clear_SHCSR_USGFAULTACT() volatile
    {
        SHCSR &= ~(1u << 3u);
    }

    /**
     * Toggle SHCSR's USGFAULTACT bit.
     *
     * UsageFault exception active bit
     */
    inline void toggle_SHCSR_USGFAULTACT() volatile
    {
        SHCSR ^= 1u << 3u;
    }

    /**
     * Get SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline bool get_SHCSR_BUSFAULTACT() volatile
    {
        return SHCSR & (1u << 1u);
    }

    /**
     * Set SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline void set_SHCSR_BUSFAULTACT() volatile
    {
        SHCSR |= 1u << 1u;
    }

    /**
     * Clear SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline void clear_SHCSR_BUSFAULTACT() volatile
    {
        SHCSR &= ~(1u << 1u);
    }

    /**
     * Toggle SHCSR's BUSFAULTACT bit.
     *
     * BusFault exception active bit
     */
    inline void toggle_SHCSR_BUSFAULTACT() volatile
    {
        SHCSR ^= 1u << 1u;
    }

    /**
     * Get SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline bool get_SHCSR_MEMFAULTACT() volatile
    {
        return SHCSR & (1u << 0u);
    }

    /**
     * Set SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline void set_SHCSR_MEMFAULTACT() volatile
    {
        SHCSR |= 1u << 0u;
    }

    /**
     * Clear SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline void clear_SHCSR_MEMFAULTACT() volatile
    {
        SHCSR &= ~(1u << 0u);
    }

    /**
     * Toggle SHCSR's MEMFAULTACT bit.
     *
     * MemManage exception active bit
     */
    inline void toggle_SHCSR_MEMFAULTACT() volatile
    {
        SHCSR ^= 1u << 0u;
    }

    /**
     * Get all of SHCSR's bit fields.
     *
     * (read-write) System Handler Control and State Register
     */
    inline void get_SHCSR(bool &USGFAULTENA, bool &BUSFAULTENA,
                          bool &MEMFAULTENA, bool &SVCALLPENDED,
                          bool &BUSFAULTPENDED, bool &MEMFAULTPENDED,
                          bool &USGFAULTPENDED, bool &SYSTICKACT,
                          bool &PENDSVACT, bool &MONITORACT, bool &SVCALLACT,
                          bool &USGFAULTACT, bool &BUSFAULTACT,
                          bool &MEMFAULTACT) volatile
    {
        uint32_t curr = SHCSR;

        USGFAULTENA = curr & (1u << 18u);
        BUSFAULTENA = curr & (1u << 17u);
        MEMFAULTENA = curr & (1u << 16u);
        SVCALLPENDED = curr & (1u << 15u);
        BUSFAULTPENDED = curr & (1u << 14u);
        MEMFAULTPENDED = curr & (1u << 13u);
        USGFAULTPENDED = curr & (1u << 12u);
        SYSTICKACT = curr & (1u << 11u);
        PENDSVACT = curr & (1u << 10u);
        MONITORACT = curr & (1u << 8u);
        SVCALLACT = curr & (1u << 7u);
        USGFAULTACT = curr & (1u << 3u);
        BUSFAULTACT = curr & (1u << 1u);
        MEMFAULTACT = curr & (1u << 0u);
    }

    /**
     * Set all of SHCSR's bit fields.
     *
     * (read-write) System Handler Control and State Register
     */
    inline void set_SHCSR(bool USGFAULTENA, bool BUSFAULTENA, bool MEMFAULTENA,
                          bool SVCALLPENDED, bool BUSFAULTPENDED,
                          bool MEMFAULTPENDED, bool USGFAULTPENDED,
                          bool SYSTICKACT, bool PENDSVACT, bool MONITORACT,
                          bool SVCALLACT, bool USGFAULTACT, bool BUSFAULTACT,
                          bool MEMFAULTACT) volatile
    {
        uint32_t curr = SHCSR;

        curr &= ~(0b1u << 18u);
        curr |= (USGFAULTENA & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (BUSFAULTENA & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (MEMFAULTENA & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (SVCALLPENDED & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (BUSFAULTPENDED & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (MEMFAULTPENDED & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (USGFAULTPENDED & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SYSTICKACT & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (PENDSVACT & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (MONITORACT & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (SVCALLACT & 0b1u) << 7u;
        curr &= ~(0b1u << 3u);
        curr |= (USGFAULTACT & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (BUSFAULTACT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MEMFAULTACT & 0b1u) << 0u;

        SHCSR = curr;
    }

    /**
     * Get CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline bool get_CFSR_DIVBYZERO() volatile
    {
        return CFSR & (1u << 25u);
    }

    /**
     * Set CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline void set_CFSR_DIVBYZERO() volatile
    {
        CFSR |= 1u << 25u;
    }

    /**
     * Clear CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline void clear_CFSR_DIVBYZERO() volatile
    {
        CFSR &= ~(1u << 25u);
    }

    /**
     * Toggle CFSR's DIVBYZERO bit.
     *
     * Divide by zero UsageFault
     */
    inline void toggle_CFSR_DIVBYZERO() volatile
    {
        CFSR ^= 1u << 25u;
    }

    /**
     * Get CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline bool get_CFSR_UNALIGNED() volatile
    {
        return CFSR & (1u << 24u);
    }

    /**
     * Set CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline void set_CFSR_UNALIGNED() volatile
    {
        CFSR |= 1u << 24u;
    }

    /**
     * Clear CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline void clear_CFSR_UNALIGNED() volatile
    {
        CFSR &= ~(1u << 24u);
    }

    /**
     * Toggle CFSR's UNALIGNED bit.
     *
     * Unaligned access UsageFault
     */
    inline void toggle_CFSR_UNALIGNED() volatile
    {
        CFSR ^= 1u << 24u;
    }

    /**
     * Get CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline bool get_CFSR_NOCP() volatile
    {
        return CFSR & (1u << 19u);
    }

    /**
     * Set CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline void set_CFSR_NOCP() volatile
    {
        CFSR |= 1u << 19u;
    }

    /**
     * Clear CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline void clear_CFSR_NOCP() volatile
    {
        CFSR &= ~(1u << 19u);
    }

    /**
     * Toggle CFSR's NOCP bit.
     *
     * No coprocessor UsageFault
     */
    inline void toggle_CFSR_NOCP() volatile
    {
        CFSR ^= 1u << 19u;
    }

    /**
     * Get CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
     */
    inline bool get_CFSR_INVPC() volatile
    {
        return CFSR & (1u << 18u);
    }

    /**
     * Set CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
     */
    inline void set_CFSR_INVPC() volatile
    {
        CFSR |= 1u << 18u;
    }

    /**
     * Clear CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
     */
    inline void clear_CFSR_INVPC() volatile
    {
        CFSR &= ~(1u << 18u);
    }

    /**
     * Toggle CFSR's INVPC bit.
     *
     * Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
     */
    inline void toggle_CFSR_INVPC() volatile
    {
        CFSR ^= 1u << 18u;
    }

    /**
     * Get CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline bool get_CFSR_INVSTATE() volatile
    {
        return CFSR & (1u << 17u);
    }

    /**
     * Set CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline void set_CFSR_INVSTATE() volatile
    {
        CFSR |= 1u << 17u;
    }

    /**
     * Clear CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline void clear_CFSR_INVSTATE() volatile
    {
        CFSR &= ~(1u << 17u);
    }

    /**
     * Toggle CFSR's INVSTATE bit.
     *
     * Invalid state UsageFault
     */
    inline void toggle_CFSR_INVSTATE() volatile
    {
        CFSR ^= 1u << 17u;
    }

    /**
     * Get CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline bool get_CFSR_UNDEFINSTR() volatile
    {
        return CFSR & (1u << 16u);
    }

    /**
     * Set CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline void set_CFSR_UNDEFINSTR() volatile
    {
        CFSR |= 1u << 16u;
    }

    /**
     * Clear CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline void clear_CFSR_UNDEFINSTR() volatile
    {
        CFSR &= ~(1u << 16u);
    }

    /**
     * Toggle CFSR's UNDEFINSTR bit.
     *
     * Undefined instruction UsageFault
     */
    inline void toggle_CFSR_UNDEFINSTR() volatile
    {
        CFSR ^= 1u << 16u;
    }

    /**
     * Get CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline bool get_CFSR_BFARVALID() volatile
    {
        return CFSR & (1u << 15u);
    }

    /**
     * Set CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline void set_CFSR_BFARVALID() volatile
    {
        CFSR |= 1u << 15u;
    }

    /**
     * Clear CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline void clear_CFSR_BFARVALID() volatile
    {
        CFSR &= ~(1u << 15u);
    }

    /**
     * Toggle CFSR's BFARVALID bit.
     *
     * BusFault Address Register (BFAR) valid flag
     */
    inline void toggle_CFSR_BFARVALID() volatile
    {
        CFSR ^= 1u << 15u;
    }

    /**
     * Get CFSR's LSPERR bit.
     *
     * Bus fault occurred during floating-point lazy state preservation
     */
    inline bool get_CFSR_LSPERR() volatile
    {
        return CFSR & (1u << 13u);
    }

    /**
     * Set CFSR's LSPERR bit.
     *
     * Bus fault occurred during floating-point lazy state preservation
     */
    inline void set_CFSR_LSPERR() volatile
    {
        CFSR |= 1u << 13u;
    }

    /**
     * Clear CFSR's LSPERR bit.
     *
     * Bus fault occurred during floating-point lazy state preservation
     */
    inline void clear_CFSR_LSPERR() volatile
    {
        CFSR &= ~(1u << 13u);
    }

    /**
     * Toggle CFSR's LSPERR bit.
     *
     * Bus fault occurred during floating-point lazy state preservation
     */
    inline void toggle_CFSR_LSPERR() volatile
    {
        CFSR ^= 1u << 13u;
    }

    /**
     * Get CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline bool get_CFSR_STKERR() volatile
    {
        return CFSR & (1u << 12u);
    }

    /**
     * Set CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline void set_CFSR_STKERR() volatile
    {
        CFSR |= 1u << 12u;
    }

    /**
     * Clear CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline void clear_CFSR_STKERR() volatile
    {
        CFSR &= ~(1u << 12u);
    }

    /**
     * Toggle CFSR's STKERR bit.
     *
     * BusFault on stacking for exception entry
     */
    inline void toggle_CFSR_STKERR() volatile
    {
        CFSR ^= 1u << 12u;
    }

    /**
     * Get CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline bool get_CFSR_UNSTKERR() volatile
    {
        return CFSR & (1u << 11u);
    }

    /**
     * Set CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline void set_CFSR_UNSTKERR() volatile
    {
        CFSR |= 1u << 11u;
    }

    /**
     * Clear CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline void clear_CFSR_UNSTKERR() volatile
    {
        CFSR &= ~(1u << 11u);
    }

    /**
     * Toggle CFSR's UNSTKERR bit.
     *
     * BusFault on unstacking for a return from exception
     */
    inline void toggle_CFSR_UNSTKERR() volatile
    {
        CFSR ^= 1u << 11u;
    }

    /**
     * Get CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline bool get_CFSR_IMPRECISERR() volatile
    {
        return CFSR & (1u << 10u);
    }

    /**
     * Set CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline void set_CFSR_IMPRECISERR() volatile
    {
        CFSR |= 1u << 10u;
    }

    /**
     * Clear CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline void clear_CFSR_IMPRECISERR() volatile
    {
        CFSR &= ~(1u << 10u);
    }

    /**
     * Toggle CFSR's IMPRECISERR bit.
     *
     * Imprecise data bus error
     */
    inline void toggle_CFSR_IMPRECISERR() volatile
    {
        CFSR ^= 1u << 10u;
    }

    /**
     * Get CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline bool get_CFSR_PRECISERR() volatile
    {
        return CFSR & (1u << 9u);
    }

    /**
     * Set CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline void set_CFSR_PRECISERR() volatile
    {
        CFSR |= 1u << 9u;
    }

    /**
     * Clear CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline void clear_CFSR_PRECISERR() volatile
    {
        CFSR &= ~(1u << 9u);
    }

    /**
     * Toggle CFSR's PRECISERR bit.
     *
     * Precise data bus error
     */
    inline void toggle_CFSR_PRECISERR() volatile
    {
        CFSR ^= 1u << 9u;
    }

    /**
     * Get CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline bool get_CFSR_IBUSERR() volatile
    {
        return CFSR & (1u << 8u);
    }

    /**
     * Set CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline void set_CFSR_IBUSERR() volatile
    {
        CFSR |= 1u << 8u;
    }

    /**
     * Clear CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline void clear_CFSR_IBUSERR() volatile
    {
        CFSR &= ~(1u << 8u);
    }

    /**
     * Toggle CFSR's IBUSERR bit.
     *
     * Instruction bus error
     */
    inline void toggle_CFSR_IBUSERR() volatile
    {
        CFSR ^= 1u << 8u;
    }

    /**
     * Get CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline bool get_CFSR_MMARVALID() volatile
    {
        return CFSR & (1u << 7u);
    }

    /**
     * Set CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline void set_CFSR_MMARVALID() volatile
    {
        CFSR |= 1u << 7u;
    }

    /**
     * Clear CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline void clear_CFSR_MMARVALID() volatile
    {
        CFSR &= ~(1u << 7u);
    }

    /**
     * Toggle CFSR's MMARVALID bit.
     *
     * MemManage Fault Address Register (MMFAR) valid flag
     */
    inline void toggle_CFSR_MMARVALID() volatile
    {
        CFSR ^= 1u << 7u;
    }

    /**
     * Get CFSR's MLSPERR bit.
     *
     * MemManage fault occurred during floating-point lazy state preservation
     */
    inline bool get_CFSR_MLSPERR() volatile
    {
        return CFSR & (1u << 5u);
    }

    /**
     * Set CFSR's MLSPERR bit.
     *
     * MemManage fault occurred during floating-point lazy state preservation
     */
    inline void set_CFSR_MLSPERR() volatile
    {
        CFSR |= 1u << 5u;
    }

    /**
     * Clear CFSR's MLSPERR bit.
     *
     * MemManage fault occurred during floating-point lazy state preservation
     */
    inline void clear_CFSR_MLSPERR() volatile
    {
        CFSR &= ~(1u << 5u);
    }

    /**
     * Toggle CFSR's MLSPERR bit.
     *
     * MemManage fault occurred during floating-point lazy state preservation
     */
    inline void toggle_CFSR_MLSPERR() volatile
    {
        CFSR ^= 1u << 5u;
    }

    /**
     * Get CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline bool get_CFSR_MSTKERR() volatile
    {
        return CFSR & (1u << 4u);
    }

    /**
     * Set CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline void set_CFSR_MSTKERR() volatile
    {
        CFSR |= 1u << 4u;
    }

    /**
     * Clear CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline void clear_CFSR_MSTKERR() volatile
    {
        CFSR &= ~(1u << 4u);
    }

    /**
     * Toggle CFSR's MSTKERR bit.
     *
     * MemManage fault on stacking for exception entry
     */
    inline void toggle_CFSR_MSTKERR() volatile
    {
        CFSR ^= 1u << 4u;
    }

    /**
     * Get CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline bool get_CFSR_MUNSTKERR() volatile
    {
        return CFSR & (1u << 3u);
    }

    /**
     * Set CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline void set_CFSR_MUNSTKERR() volatile
    {
        CFSR |= 1u << 3u;
    }

    /**
     * Clear CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline void clear_CFSR_MUNSTKERR() volatile
    {
        CFSR &= ~(1u << 3u);
    }

    /**
     * Toggle CFSR's MUNSTKERR bit.
     *
     * MemManage fault on unstacking for a return from exception
     */
    inline void toggle_CFSR_MUNSTKERR() volatile
    {
        CFSR ^= 1u << 3u;
    }

    /**
     * Get CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline bool get_CFSR_DACCVIOL() volatile
    {
        return CFSR & (1u << 1u);
    }

    /**
     * Set CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline void set_CFSR_DACCVIOL() volatile
    {
        CFSR |= 1u << 1u;
    }

    /**
     * Clear CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline void clear_CFSR_DACCVIOL() volatile
    {
        CFSR &= ~(1u << 1u);
    }

    /**
     * Toggle CFSR's DACCVIOL bit.
     *
     * Data access violation flag
     */
    inline void toggle_CFSR_DACCVIOL() volatile
    {
        CFSR ^= 1u << 1u;
    }

    /**
     * Get CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline bool get_CFSR_IACCVIOL() volatile
    {
        return CFSR & (1u << 0u);
    }

    /**
     * Set CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline void set_CFSR_IACCVIOL() volatile
    {
        CFSR |= 1u << 0u;
    }

    /**
     * Clear CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline void clear_CFSR_IACCVIOL() volatile
    {
        CFSR &= ~(1u << 0u);
    }

    /**
     * Toggle CFSR's IACCVIOL bit.
     *
     * Instruction access violation flag
     */
    inline void toggle_CFSR_IACCVIOL() volatile
    {
        CFSR ^= 1u << 0u;
    }

    /**
     * Get all of CFSR's bit fields.
     *
     * (read-write) Configurable Fault Status Register
     */
    inline void get_CFSR(bool &DIVBYZERO, bool &UNALIGNED, bool &NOCP,
                         bool &INVPC, bool &INVSTATE, bool &UNDEFINSTR,
                         bool &BFARVALID, bool &LSPERR, bool &STKERR,
                         bool &UNSTKERR, bool &IMPRECISERR, bool &PRECISERR,
                         bool &IBUSERR, bool &MMARVALID, bool &MLSPERR,
                         bool &MSTKERR, bool &MUNSTKERR, bool &DACCVIOL,
                         bool &IACCVIOL) volatile
    {
        uint32_t curr = CFSR;

        DIVBYZERO = curr & (1u << 25u);
        UNALIGNED = curr & (1u << 24u);
        NOCP = curr & (1u << 19u);
        INVPC = curr & (1u << 18u);
        INVSTATE = curr & (1u << 17u);
        UNDEFINSTR = curr & (1u << 16u);
        BFARVALID = curr & (1u << 15u);
        LSPERR = curr & (1u << 13u);
        STKERR = curr & (1u << 12u);
        UNSTKERR = curr & (1u << 11u);
        IMPRECISERR = curr & (1u << 10u);
        PRECISERR = curr & (1u << 9u);
        IBUSERR = curr & (1u << 8u);
        MMARVALID = curr & (1u << 7u);
        MLSPERR = curr & (1u << 5u);
        MSTKERR = curr & (1u << 4u);
        MUNSTKERR = curr & (1u << 3u);
        DACCVIOL = curr & (1u << 1u);
        IACCVIOL = curr & (1u << 0u);
    }

    /**
     * Set all of CFSR's bit fields.
     *
     * (read-write) Configurable Fault Status Register
     */
    inline void set_CFSR(bool DIVBYZERO, bool UNALIGNED, bool NOCP, bool INVPC,
                         bool INVSTATE, bool UNDEFINSTR, bool BFARVALID,
                         bool LSPERR, bool STKERR, bool UNSTKERR,
                         bool IMPRECISERR, bool PRECISERR, bool IBUSERR,
                         bool MMARVALID, bool MLSPERR, bool MSTKERR,
                         bool MUNSTKERR, bool DACCVIOL, bool IACCVIOL) volatile
    {
        uint32_t curr = CFSR;

        curr &= ~(0b1u << 25u);
        curr |= (DIVBYZERO & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (UNALIGNED & 0b1u) << 24u;
        curr &= ~(0b1u << 19u);
        curr |= (NOCP & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (INVPC & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (INVSTATE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (UNDEFINSTR & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (BFARVALID & 0b1u) << 15u;
        curr &= ~(0b1u << 13u);
        curr |= (LSPERR & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (STKERR & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (UNSTKERR & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IMPRECISERR & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (PRECISERR & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (IBUSERR & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (MMARVALID & 0b1u) << 7u;
        curr &= ~(0b1u << 5u);
        curr |= (MLSPERR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MSTKERR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (MUNSTKERR & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (DACCVIOL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IACCVIOL & 0b1u) << 0u;

        CFSR = curr;
    }

    /**
     * Get HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use. When writing to the register you must write 0 to
     * this bit, otherwise behavior is Unpredictable.
     */
    inline bool get_HFSR_DEBUGEVT() volatile
    {
        return HFSR & (1u << 31u);
    }

    /**
     * Set HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use. When writing to the register you must write 0 to
     * this bit, otherwise behavior is Unpredictable.
     */
    inline void set_HFSR_DEBUGEVT() volatile
    {
        HFSR |= 1u << 31u;
    }

    /**
     * Clear HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use. When writing to the register you must write 0 to
     * this bit, otherwise behavior is Unpredictable.
     */
    inline void clear_HFSR_DEBUGEVT() volatile
    {
        HFSR &= ~(1u << 31u);
    }

    /**
     * Toggle HFSR's DEBUGEVT bit.
     *
     * Reserved for Debug use. When writing to the register you must write 0 to
     * this bit, otherwise behavior is Unpredictable.
     */
    inline void toggle_HFSR_DEBUGEVT() volatile
    {
        HFSR ^= 1u << 31u;
    }

    /**
     * Get HFSR's FORCED bit.
     *
     * Indicates a forced hard fault, generated by escalation of a fault with
     * configurable priority that cannot be handles, either because of priority
     * or because it is disabled.
     */
    inline bool get_HFSR_FORCED() volatile
    {
        return HFSR & (1u << 30u);
    }

    /**
     * Set HFSR's FORCED bit.
     *
     * Indicates a forced hard fault, generated by escalation of a fault with
     * configurable priority that cannot be handles, either because of priority
     * or because it is disabled.
     */
    inline void set_HFSR_FORCED() volatile
    {
        HFSR |= 1u << 30u;
    }

    /**
     * Clear HFSR's FORCED bit.
     *
     * Indicates a forced hard fault, generated by escalation of a fault with
     * configurable priority that cannot be handles, either because of priority
     * or because it is disabled.
     */
    inline void clear_HFSR_FORCED() volatile
    {
        HFSR &= ~(1u << 30u);
    }

    /**
     * Toggle HFSR's FORCED bit.
     *
     * Indicates a forced hard fault, generated by escalation of a fault with
     * configurable priority that cannot be handles, either because of priority
     * or because it is disabled.
     */
    inline void toggle_HFSR_FORCED() volatile
    {
        HFSR ^= 1u << 30u;
    }

    /**
     * Get HFSR's VECTTBL bit.
     *
     * Indicates a BusFault on a vector table read during exception processing.
     */
    inline bool get_HFSR_VECTTBL() volatile
    {
        return HFSR & (1u << 1u);
    }

    /**
     * Set HFSR's VECTTBL bit.
     *
     * Indicates a BusFault on a vector table read during exception processing.
     */
    inline void set_HFSR_VECTTBL() volatile
    {
        HFSR |= 1u << 1u;
    }

    /**
     * Clear HFSR's VECTTBL bit.
     *
     * Indicates a BusFault on a vector table read during exception processing.
     */
    inline void clear_HFSR_VECTTBL() volatile
    {
        HFSR &= ~(1u << 1u);
    }

    /**
     * Toggle HFSR's VECTTBL bit.
     *
     * Indicates a BusFault on a vector table read during exception processing.
     */
    inline void toggle_HFSR_VECTTBL() volatile
    {
        HFSR ^= 1u << 1u;
    }

    /**
     * Get all of HFSR's bit fields.
     *
     * (read-write) HardFault Status register
     */
    inline void get_HFSR(bool &DEBUGEVT, bool &FORCED, bool &VECTTBL) volatile
    {
        uint32_t curr = HFSR;

        DEBUGEVT = curr & (1u << 31u);
        FORCED = curr & (1u << 30u);
        VECTTBL = curr & (1u << 1u);
    }

    /**
     * Set all of HFSR's bit fields.
     *
     * (read-write) HardFault Status register
     */
    inline void set_HFSR(bool DEBUGEVT, bool FORCED, bool VECTTBL) volatile
    {
        uint32_t curr = HFSR;

        curr &= ~(0b1u << 31u);
        curr |= (DEBUGEVT & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (FORCED & 0b1u) << 30u;
        curr &= ~(0b1u << 1u);
        curr |= (VECTTBL & 0b1u) << 1u;

        HFSR = curr;
    }

    /**
     * Get DFSR's EXTERNAL bit.
     *
     * Debug event generated because of the assertion of an external debug
     * request
     */
    inline bool get_DFSR_EXTERNAL() volatile
    {
        return DFSR & (1u << 4u);
    }

    /**
     * Set DFSR's EXTERNAL bit.
     *
     * Debug event generated because of the assertion of an external debug
     * request
     */
    inline void set_DFSR_EXTERNAL() volatile
    {
        DFSR |= 1u << 4u;
    }

    /**
     * Clear DFSR's EXTERNAL bit.
     *
     * Debug event generated because of the assertion of an external debug
     * request
     */
    inline void clear_DFSR_EXTERNAL() volatile
    {
        DFSR &= ~(1u << 4u);
    }

    /**
     * Toggle DFSR's EXTERNAL bit.
     *
     * Debug event generated because of the assertion of an external debug
     * request
     */
    inline void toggle_DFSR_EXTERNAL() volatile
    {
        DFSR ^= 1u << 4u;
    }

    /**
     * Get DFSR's VCATCH bit.
     *
     * Indicates triggering of a Vector catch
     */
    inline bool get_DFSR_VCATCH() volatile
    {
        return DFSR & (1u << 3u);
    }

    /**
     * Set DFSR's VCATCH bit.
     *
     * Indicates triggering of a Vector catch
     */
    inline void set_DFSR_VCATCH() volatile
    {
        DFSR |= 1u << 3u;
    }

    /**
     * Clear DFSR's VCATCH bit.
     *
     * Indicates triggering of a Vector catch
     */
    inline void clear_DFSR_VCATCH() volatile
    {
        DFSR &= ~(1u << 3u);
    }

    /**
     * Toggle DFSR's VCATCH bit.
     *
     * Indicates triggering of a Vector catch
     */
    inline void toggle_DFSR_VCATCH() volatile
    {
        DFSR ^= 1u << 3u;
    }

    /**
     * Get DFSR's DWTTRAP bit.
     *
     * Debug event generated by the DWT
     */
    inline bool get_DFSR_DWTTRAP() volatile
    {
        return DFSR & (1u << 2u);
    }

    /**
     * Set DFSR's DWTTRAP bit.
     *
     * Debug event generated by the DWT
     */
    inline void set_DFSR_DWTTRAP() volatile
    {
        DFSR |= 1u << 2u;
    }

    /**
     * Clear DFSR's DWTTRAP bit.
     *
     * Debug event generated by the DWT
     */
    inline void clear_DFSR_DWTTRAP() volatile
    {
        DFSR &= ~(1u << 2u);
    }

    /**
     * Toggle DFSR's DWTTRAP bit.
     *
     * Debug event generated by the DWT
     */
    inline void toggle_DFSR_DWTTRAP() volatile
    {
        DFSR ^= 1u << 2u;
    }

    /**
     * Get DFSR's BKPT bit.
     *
     * Debug event generated by BKPT instruction execution or a breakpoint
     * match in FPB
     */
    inline bool get_DFSR_BKPT() volatile
    {
        return DFSR & (1u << 1u);
    }

    /**
     * Set DFSR's BKPT bit.
     *
     * Debug event generated by BKPT instruction execution or a breakpoint
     * match in FPB
     */
    inline void set_DFSR_BKPT() volatile
    {
        DFSR |= 1u << 1u;
    }

    /**
     * Clear DFSR's BKPT bit.
     *
     * Debug event generated by BKPT instruction execution or a breakpoint
     * match in FPB
     */
    inline void clear_DFSR_BKPT() volatile
    {
        DFSR &= ~(1u << 1u);
    }

    /**
     * Toggle DFSR's BKPT bit.
     *
     * Debug event generated by BKPT instruction execution or a breakpoint
     * match in FPB
     */
    inline void toggle_DFSR_BKPT() volatile
    {
        DFSR ^= 1u << 1u;
    }

    /**
     * Get DFSR's HALTED bit.
     *
     * Indicates a debug event generated by either a C_HALT or C_STEP request,
     * triggered by a write to the DHCSR or a step request triggered by setting
     * DEMCR.MON_STEP to 1.
     */
    inline bool get_DFSR_HALTED() volatile
    {
        return DFSR & (1u << 0u);
    }

    /**
     * Set DFSR's HALTED bit.
     *
     * Indicates a debug event generated by either a C_HALT or C_STEP request,
     * triggered by a write to the DHCSR or a step request triggered by setting
     * DEMCR.MON_STEP to 1.
     */
    inline void set_DFSR_HALTED() volatile
    {
        DFSR |= 1u << 0u;
    }

    /**
     * Clear DFSR's HALTED bit.
     *
     * Indicates a debug event generated by either a C_HALT or C_STEP request,
     * triggered by a write to the DHCSR or a step request triggered by setting
     * DEMCR.MON_STEP to 1.
     */
    inline void clear_DFSR_HALTED() volatile
    {
        DFSR &= ~(1u << 0u);
    }

    /**
     * Toggle DFSR's HALTED bit.
     *
     * Indicates a debug event generated by either a C_HALT or C_STEP request,
     * triggered by a write to the DHCSR or a step request triggered by setting
     * DEMCR.MON_STEP to 1.
     */
    inline void toggle_DFSR_HALTED() volatile
    {
        DFSR ^= 1u << 0u;
    }

    /**
     * Get all of DFSR's bit fields.
     *
     * (read-write) Debug Fault Status Register
     */
    inline void get_DFSR(bool &EXTERNAL, bool &VCATCH, bool &DWTTRAP,
                         bool &BKPT, bool &HALTED) volatile
    {
        uint32_t curr = DFSR;

        EXTERNAL = curr & (1u << 4u);
        VCATCH = curr & (1u << 3u);
        DWTTRAP = curr & (1u << 2u);
        BKPT = curr & (1u << 1u);
        HALTED = curr & (1u << 0u);
    }

    /**
     * Set all of DFSR's bit fields.
     *
     * (read-write) Debug Fault Status Register
     */
    inline void set_DFSR(bool EXTERNAL, bool VCATCH, bool DWTTRAP, bool BKPT,
                         bool HALTED) volatile
    {
        uint32_t curr = DFSR;

        curr &= ~(0b1u << 4u);
        curr |= (EXTERNAL & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VCATCH & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DWTTRAP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (BKPT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (HALTED & 0b1u) << 0u;

        DFSR = curr;
    }

    /**
     * Get MMFAR's ADDRESS field.
     *
     * Address of MemManage fault location
     */
    inline uint32_t get_MMFAR_ADDRESS() volatile
    {
        return (MMFAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set MMFAR's ADDRESS field.
     *
     * Address of MemManage fault location
     */
    inline void set_MMFAR_ADDRESS(uint32_t value) volatile
    {
        uint32_t curr = MMFAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        MMFAR = curr;
    }

    /**
     * Get BFAR's ADDRESS field.
     *
     * Address of the BusFault location
     */
    inline uint32_t get_BFAR_ADDRESS() volatile
    {
        return (BFAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set BFAR's ADDRESS field.
     *
     * Address of the BusFault location
     */
    inline void set_BFAR_ADDRESS(uint32_t value) volatile
    {
        uint32_t curr = BFAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        BFAR = curr;
    }

    /**
     * Get ID_PFR0's STATE3 field.
     *
     * ARMv7-M unused
     */
    inline uint8_t get_ID_PFR0_STATE3() volatile
    {
        return (ID_PFR0 >> 12u) & 0b1111u;
    }

    /**
     * Get ID_PFR0's STATE2 field.
     *
     * ARMv7-M unused
     */
    inline uint8_t get_ID_PFR0_STATE2() volatile
    {
        return (ID_PFR0 >> 8u) & 0b1111u;
    }

    /**
     * Get ID_PFR0's STATE1 field.
     *
     * Thumb instruction set support
     */
    inline SystemControl_ID_PFR0_STATE1 get_ID_PFR0_STATE1() volatile
    {
        return SystemControl_ID_PFR0_STATE1((ID_PFR0 >> 4u) & 0b1111u);
    }

    /**
     * Get ID_PFR0's STATE0 field.
     *
     * ARM instruction set support
     */
    inline SystemControl_ID_PFR0_STATE0 get_ID_PFR0_STATE0() volatile
    {
        return SystemControl_ID_PFR0_STATE0((ID_PFR0 >> 0u) & 0b1111u);
    }

    /**
     * Get all of ID_PFR0's bit fields.
     *
     * (read-write) Processor Feature Register 0
     */
    inline void get_ID_PFR0(uint8_t &STATE3, uint8_t &STATE2,
                            SystemControl_ID_PFR0_STATE1 &STATE1,
                            SystemControl_ID_PFR0_STATE0 &STATE0) volatile
    {
        uint32_t curr = ID_PFR0;

        STATE3 = (curr >> 12u) & 0b1111u;
        STATE2 = (curr >> 8u) & 0b1111u;
        STATE1 = SystemControl_ID_PFR0_STATE1((curr >> 4u) & 0b1111u);
        STATE0 = SystemControl_ID_PFR0_STATE0((curr >> 0u) & 0b1111u);
    }

    /**
     * Get ID_PFR1's PROGMODEL field.
     *
     * M profile programmers' model
     */
    inline SystemControl_ID_PFR1_PROGMODEL get_ID_PFR1_PROGMODEL() volatile
    {
        return SystemControl_ID_PFR1_PROGMODEL((ID_PFR1 >> 8u) & 0b1111u);
    }

    /**
     * Get ID_DFR0's DEBUGMODEL field.
     *
     * Support for memory-mapped debug model for M profile processors
     */
    inline SystemControl_ID_DFR0_DEBUGMODEL get_ID_DFR0_DEBUGMODEL() volatile
    {
        return SystemControl_ID_DFR0_DEBUGMODEL((ID_DFR0 >> 20u) & 0b1111u);
    }

    /**
     * Get ID_AFR0's IMPLEMENTATION_DEFINED3 field.
     *
     * Gives information about the IMPLEMENTATION DEFINED features of a
     * processor implementation.
     */
    inline uint8_t get_ID_AFR0_IMPLEMENTATION_DEFINED3() volatile
    {
        return (ID_AFR0 >> 12u) & 0b1111u;
    }

    /**
     * Get ID_AFR0's IMPLEMENTATION_DEFINED2 field.
     *
     * Gives information about the IMPLEMENTATION DEFINED features of a
     * processor implementation.
     */
    inline uint8_t get_ID_AFR0_IMPLEMENTATION_DEFINED2() volatile
    {
        return (ID_AFR0 >> 8u) & 0b1111u;
    }

    /**
     * Get ID_AFR0's IMPLEMENTATION_DEFINED1 field.
     *
     * Gives information about the IMPLEMENTATION DEFINED features of a
     * processor implementation.
     */
    inline uint8_t get_ID_AFR0_IMPLEMENTATION_DEFINED1() volatile
    {
        return (ID_AFR0 >> 4u) & 0b1111u;
    }

    /**
     * Get ID_AFR0's IMPLEMENTATION_DEFINED0 field.
     *
     * Gives information about the IMPLEMENTATION DEFINED features of a
     * processor implementation.
     */
    inline uint8_t get_ID_AFR0_IMPLEMENTATION_DEFINED0() volatile
    {
        return (ID_AFR0 >> 0u) & 0b1111u;
    }

    /**
     * Get all of ID_AFR0's bit fields.
     *
     * (read-write) Auxiliary Feature Register
     */
    inline void get_ID_AFR0(uint8_t &IMPLEMENTATION_DEFINED3,
                            uint8_t &IMPLEMENTATION_DEFINED2,
                            uint8_t &IMPLEMENTATION_DEFINED1,
                            uint8_t &IMPLEMENTATION_DEFINED0) volatile
    {
        uint32_t curr = ID_AFR0;

        IMPLEMENTATION_DEFINED3 = (curr >> 12u) & 0b1111u;
        IMPLEMENTATION_DEFINED2 = (curr >> 8u) & 0b1111u;
        IMPLEMENTATION_DEFINED1 = (curr >> 4u) & 0b1111u;
        IMPLEMENTATION_DEFINED0 = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get ID_MMFR0's AUXILIARY_REGISTERS field.
     *
     * Indicates the support for Auxiliary registers
     */
    inline SystemControl_ID_MMFR0_AUXILIARY_REGISTERS
    get_ID_MMFR0_AUXILIARY_REGISTERS() volatile
    {
        return SystemControl_ID_MMFR0_AUXILIARY_REGISTERS((ID_MMFR0 >> 20u) &
                                                          0b1111u);
    }

    /**
     * Get ID_MMFR0's TCM_SUPPORT field.
     *
     * Indicates the support for Tightly Coupled Memory
     */
    inline SystemControl_ID_MMFR0_TCM_SUPPORT
    get_ID_MMFR0_TCM_SUPPORT() volatile
    {
        return SystemControl_ID_MMFR0_TCM_SUPPORT((ID_MMFR0 >> 16u) & 0b1111u);
    }

    /**
     * Get ID_MMFR0's SHAREABILITY_LEVELS field.
     *
     * Indicates the number of shareability levels implemented
     */
    inline SystemControl_ID_MMFR0_SHAREABILITY_LEVELS
    get_ID_MMFR0_SHAREABILITY_LEVELS() volatile
    {
        return SystemControl_ID_MMFR0_SHAREABILITY_LEVELS((ID_MMFR0 >> 12u) &
                                                          0b1111u);
    }

    /**
     * Get ID_MMFR0's OUTERMOST_SHAREABILITY field.
     *
     * Indicates the outermost shareability domain implemented
     */
    inline SystemControl_ID_MMFR0_OUTERMOST_SHAREABILITY
    get_ID_MMFR0_OUTERMOST_SHAREABILITY() volatile
    {
        return SystemControl_ID_MMFR0_OUTERMOST_SHAREABILITY((ID_MMFR0 >> 8u) &
                                                             0b1111u);
    }

    /**
     * Get ID_MMFR0's PMSASUPPORT field.
     *
     * Indicates support for a PMSA
     */
    inline SystemControl_ID_MMFR0_PMSASUPPORT
    get_ID_MMFR0_PMSASUPPORT() volatile
    {
        return SystemControl_ID_MMFR0_PMSASUPPORT((ID_MMFR0 >> 4u) & 0b1111u);
    }

    /**
     * Get all of ID_MMFR0's bit fields.
     *
     * (read-write) Memory Model Feature Register 0
     */
    inline void get_ID_MMFR0(
        SystemControl_ID_MMFR0_AUXILIARY_REGISTERS &AUXILIARY_REGISTERS,
        SystemControl_ID_MMFR0_TCM_SUPPORT &TCM_SUPPORT,
        SystemControl_ID_MMFR0_SHAREABILITY_LEVELS &SHAREABILITY_LEVELS,
        SystemControl_ID_MMFR0_OUTERMOST_SHAREABILITY &OUTERMOST_SHAREABILITY,
        SystemControl_ID_MMFR0_PMSASUPPORT &PMSASUPPORT) volatile
    {
        uint32_t curr = ID_MMFR0;

        AUXILIARY_REGISTERS = SystemControl_ID_MMFR0_AUXILIARY_REGISTERS(
            (curr >> 20u) & 0b1111u);
        TCM_SUPPORT =
            SystemControl_ID_MMFR0_TCM_SUPPORT((curr >> 16u) & 0b1111u);
        SHAREABILITY_LEVELS = SystemControl_ID_MMFR0_SHAREABILITY_LEVELS(
            (curr >> 12u) & 0b1111u);
        OUTERMOST_SHAREABILITY = SystemControl_ID_MMFR0_OUTERMOST_SHAREABILITY(
            (curr >> 8u) & 0b1111u);
        PMSASUPPORT =
            SystemControl_ID_MMFR0_PMSASUPPORT((curr >> 4u) & 0b1111u);
    }

    /**
     * Get ID_MMFR1's ID_MMFR1 field.
     *
     * Gives information about the implemented memory model and memory
     * management support.
     */
    inline uint32_t get_ID_MMFR1_ID_MMFR1() volatile
    {
        return (ID_MMFR1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get ID_MMFR2's WFI_STALL field.
     *
     * Indicates the support for Wait For Interrupt (WFI) stalling
     */
    inline SystemControl_ID_MMFR2_WFI_STALL get_ID_MMFR2_WFI_STALL() volatile
    {
        return SystemControl_ID_MMFR2_WFI_STALL((ID_MMFR2 >> 24u) & 0b1111u);
    }

    /**
     * Get ID_MMFR3's ID_MMFR3 field.
     *
     * Gives information about the implemented memory model and memory
     * management support.
     */
    inline uint32_t get_ID_MMFR3_ID_MMFR3() volatile
    {
        return (ID_MMFR3 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get ID_ISAR0's DIVIDE_INSTRS field.
     *
     * Indicates the supported Divide instructions
     */
    inline SystemControl_ID_ISAR0_DIVIDE_INSTRS
    get_ID_ISAR0_DIVIDE_INSTRS() volatile
    {
        return SystemControl_ID_ISAR0_DIVIDE_INSTRS((ID_ISAR0 >> 24u) &
                                                    0b1111u);
    }

    /**
     * Get ID_ISAR0's DEBUG_INSTRS field.
     *
     * Indicates the supported Debug instructions
     */
    inline SystemControl_ID_ISAR0_DEBUG_INSTRS
    get_ID_ISAR0_DEBUG_INSTRS() volatile
    {
        return SystemControl_ID_ISAR0_DEBUG_INSTRS((ID_ISAR0 >> 20u) &
                                                   0b1111u);
    }

    /**
     * Get ID_ISAR0's COPROC_INSTRS field.
     *
     * Indicates the supported Coprocessor instructions
     */
    inline SystemControl_ID_ISAR0_COPROC_INSTRS
    get_ID_ISAR0_COPROC_INSTRS() volatile
    {
        return SystemControl_ID_ISAR0_COPROC_INSTRS((ID_ISAR0 >> 16u) &
                                                    0b1111u);
    }

    /**
     * Get ID_ISAR0's CMPBRANCH_INSTRS field.
     *
     * Indicates the supported combined Compare and Branch instructions
     */
    inline SystemControl_ID_ISAR0_CMPBRANCH_INSTRS
    get_ID_ISAR0_CMPBRANCH_INSTRS() volatile
    {
        return SystemControl_ID_ISAR0_CMPBRANCH_INSTRS((ID_ISAR0 >> 12u) &
                                                       0b1111u);
    }

    /**
     * Get ID_ISAR0's BITFIELD_INSTRS field.
     *
     * Indicates the supported BitField instructions
     */
    inline SystemControl_ID_ISAR0_BITFIELD_INSTRS
    get_ID_ISAR0_BITFIELD_INSTRS() volatile
    {
        return SystemControl_ID_ISAR0_BITFIELD_INSTRS((ID_ISAR0 >> 8u) &
                                                      0b1111u);
    }

    /**
     * Get ID_ISAR0's BITCOUNT_INSTRS field.
     *
     * Indicates the supported Bit Counting instructions
     */
    inline SystemControl_ID_ISAR0_BITCOUNT_INSTRS
    get_ID_ISAR0_BITCOUNT_INSTRS() volatile
    {
        return SystemControl_ID_ISAR0_BITCOUNT_INSTRS((ID_ISAR0 >> 4u) &
                                                      0b1111u);
    }

    /**
     * Get all of ID_ISAR0's bit fields.
     *
     * (read-write) Instruction Set Attributes Register 0
     */
    inline void get_ID_ISAR0(
        SystemControl_ID_ISAR0_DIVIDE_INSTRS &DIVIDE_INSTRS,
        SystemControl_ID_ISAR0_DEBUG_INSTRS &DEBUG_INSTRS,
        SystemControl_ID_ISAR0_COPROC_INSTRS &COPROC_INSTRS,
        SystemControl_ID_ISAR0_CMPBRANCH_INSTRS &CMPBRANCH_INSTRS,
        SystemControl_ID_ISAR0_BITFIELD_INSTRS &BITFIELD_INSTRS,
        SystemControl_ID_ISAR0_BITCOUNT_INSTRS &BITCOUNT_INSTRS) volatile
    {
        uint32_t curr = ID_ISAR0;

        DIVIDE_INSTRS =
            SystemControl_ID_ISAR0_DIVIDE_INSTRS((curr >> 24u) & 0b1111u);
        DEBUG_INSTRS =
            SystemControl_ID_ISAR0_DEBUG_INSTRS((curr >> 20u) & 0b1111u);
        COPROC_INSTRS =
            SystemControl_ID_ISAR0_COPROC_INSTRS((curr >> 16u) & 0b1111u);
        CMPBRANCH_INSTRS =
            SystemControl_ID_ISAR0_CMPBRANCH_INSTRS((curr >> 12u) & 0b1111u);
        BITFIELD_INSTRS =
            SystemControl_ID_ISAR0_BITFIELD_INSTRS((curr >> 8u) & 0b1111u);
        BITCOUNT_INSTRS =
            SystemControl_ID_ISAR0_BITCOUNT_INSTRS((curr >> 4u) & 0b1111u);
    }

    /**
     * Get ID_ISAR1's INTERWORK_INSTRS field.
     *
     * Indicates the supported Interworking instructions
     */
    inline SystemControl_ID_ISAR1_INTERWORK_INSTRS
    get_ID_ISAR1_INTERWORK_INSTRS() volatile
    {
        return SystemControl_ID_ISAR1_INTERWORK_INSTRS((ID_ISAR1 >> 24u) &
                                                       0b1111u);
    }

    /**
     * Get ID_ISAR1's IMMEDIATE_INSTRS field.
     *
     * Indicates the support for data-processing instructions with long
     * immediate
     */
    inline SystemControl_ID_ISAR1_IMMEDIATE_INSTRS
    get_ID_ISAR1_IMMEDIATE_INSTRS() volatile
    {
        return SystemControl_ID_ISAR1_IMMEDIATE_INSTRS((ID_ISAR1 >> 20u) &
                                                       0b1111u);
    }

    /**
     * Get ID_ISAR1's IFTHEN_INSTRS field.
     *
     * Indicates the supported IfThen instructions
     */
    inline SystemControl_ID_ISAR1_IFTHEN_INSTRS
    get_ID_ISAR1_IFTHEN_INSTRS() volatile
    {
        return SystemControl_ID_ISAR1_IFTHEN_INSTRS((ID_ISAR1 >> 16u) &
                                                    0b1111u);
    }

    /**
     * Get ID_ISAR1's EXTEND_INSTRS field.
     *
     * Indicates the supported Extend instructions
     */
    inline SystemControl_ID_ISAR1_EXTEND_INSTRS
    get_ID_ISAR1_EXTEND_INSTRS() volatile
    {
        return SystemControl_ID_ISAR1_EXTEND_INSTRS((ID_ISAR1 >> 12u) &
                                                    0b1111u);
    }

    /**
     * Get all of ID_ISAR1's bit fields.
     *
     * (read-write) Instruction Set Attributes Register 1
     */
    inline void get_ID_ISAR1(
        SystemControl_ID_ISAR1_INTERWORK_INSTRS &INTERWORK_INSTRS,
        SystemControl_ID_ISAR1_IMMEDIATE_INSTRS &IMMEDIATE_INSTRS,
        SystemControl_ID_ISAR1_IFTHEN_INSTRS &IFTHEN_INSTRS,
        SystemControl_ID_ISAR1_EXTEND_INSTRS &EXTEND_INSTRS) volatile
    {
        uint32_t curr = ID_ISAR1;

        INTERWORK_INSTRS =
            SystemControl_ID_ISAR1_INTERWORK_INSTRS((curr >> 24u) & 0b1111u);
        IMMEDIATE_INSTRS =
            SystemControl_ID_ISAR1_IMMEDIATE_INSTRS((curr >> 20u) & 0b1111u);
        IFTHEN_INSTRS =
            SystemControl_ID_ISAR1_IFTHEN_INSTRS((curr >> 16u) & 0b1111u);
        EXTEND_INSTRS =
            SystemControl_ID_ISAR1_EXTEND_INSTRS((curr >> 12u) & 0b1111u);
    }

    /**
     * Get ID_ISAR2's REVERSAL_INSTRS field.
     *
     * Indicates the supported Reversal instructions
     */
    inline SystemControl_ID_ISAR2_REVERSAL_INSTRS
    get_ID_ISAR2_REVERSAL_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_REVERSAL_INSTRS((ID_ISAR2 >> 28u) &
                                                      0b1111u);
    }

    /**
     * Get ID_ISAR2's MULTU_INSTRS field.
     *
     * Indicates the supported advanced unsigned Multiply instructions
     */
    inline SystemControl_ID_ISAR2_MULTU_INSTRS
    get_ID_ISAR2_MULTU_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_MULTU_INSTRS((ID_ISAR2 >> 20u) &
                                                   0b1111u);
    }

    /**
     * Get ID_ISAR2's MULTS_INSTRS field.
     *
     * Indicates the supported advanced signed Multiply instructions
     */
    inline SystemControl_ID_ISAR2_MULTS_INSTRS
    get_ID_ISAR2_MULTS_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_MULTS_INSTRS((ID_ISAR2 >> 16u) &
                                                   0b1111u);
    }

    /**
     * Get ID_ISAR2's MULT_INSTRS field.
     *
     * Indicates the supported additional Multiply instructions
     */
    inline SystemControl_ID_ISAR2_MULT_INSTRS
    get_ID_ISAR2_MULT_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_MULT_INSTRS((ID_ISAR2 >> 12u) & 0b1111u);
    }

    /**
     * Get ID_ISAR2's MULTIACCESSINT_INSTRS field.
     *
     * Indicates the support for multi-access interruptible instructions
     */
    inline SystemControl_ID_ISAR2_MULTIACCESSINT_INSTRS
    get_ID_ISAR2_MULTIACCESSINT_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_MULTIACCESSINT_INSTRS((ID_ISAR2 >> 8u) &
                                                            0b1111u);
    }

    /**
     * Get ID_ISAR2's MEMHINT_INSTRS field.
     *
     * Indicates the supported Memory Hint instructions
     */
    inline SystemControl_ID_ISAR2_MEMHINT_INSTRS
    get_ID_ISAR2_MEMHINT_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_MEMHINT_INSTRS((ID_ISAR2 >> 4u) &
                                                     0b1111u);
    }

    /**
     * Get ID_ISAR2's LOADSTORE_INSTRS field.
     *
     * Indicates the supported additional load and store instructions
     */
    inline SystemControl_ID_ISAR2_LOADSTORE_INSTRS
    get_ID_ISAR2_LOADSTORE_INSTRS() volatile
    {
        return SystemControl_ID_ISAR2_LOADSTORE_INSTRS((ID_ISAR2 >> 0u) &
                                                       0b1111u);
    }

    /**
     * Get all of ID_ISAR2's bit fields.
     *
     * (read-write) Instruction Set Attributes Register 2
     */
    inline void get_ID_ISAR2(
        SystemControl_ID_ISAR2_REVERSAL_INSTRS &REVERSAL_INSTRS,
        SystemControl_ID_ISAR2_MULTU_INSTRS &MULTU_INSTRS,
        SystemControl_ID_ISAR2_MULTS_INSTRS &MULTS_INSTRS,
        SystemControl_ID_ISAR2_MULT_INSTRS &MULT_INSTRS,
        SystemControl_ID_ISAR2_MULTIACCESSINT_INSTRS &MULTIACCESSINT_INSTRS,
        SystemControl_ID_ISAR2_MEMHINT_INSTRS &MEMHINT_INSTRS,
        SystemControl_ID_ISAR2_LOADSTORE_INSTRS &LOADSTORE_INSTRS) volatile
    {
        uint32_t curr = ID_ISAR2;

        REVERSAL_INSTRS =
            SystemControl_ID_ISAR2_REVERSAL_INSTRS((curr >> 28u) & 0b1111u);
        MULTU_INSTRS =
            SystemControl_ID_ISAR2_MULTU_INSTRS((curr >> 20u) & 0b1111u);
        MULTS_INSTRS =
            SystemControl_ID_ISAR2_MULTS_INSTRS((curr >> 16u) & 0b1111u);
        MULT_INSTRS =
            SystemControl_ID_ISAR2_MULT_INSTRS((curr >> 12u) & 0b1111u);
        MULTIACCESSINT_INSTRS = SystemControl_ID_ISAR2_MULTIACCESSINT_INSTRS(
            (curr >> 8u) & 0b1111u);
        MEMHINT_INSTRS =
            SystemControl_ID_ISAR2_MEMHINT_INSTRS((curr >> 4u) & 0b1111u);
        LOADSTORE_INSTRS =
            SystemControl_ID_ISAR2_LOADSTORE_INSTRS((curr >> 0u) & 0b1111u);
    }

    /**
     * Get ID_ISAR3's TRUENOP_INSTRS field.
     *
     * Indicates the supported non flag-setting MOV instructions
     */
    inline SystemControl_ID_ISAR3_TRUENOP_INSTRS
    get_ID_ISAR3_TRUENOP_INSTRS() volatile
    {
        return SystemControl_ID_ISAR3_TRUENOP_INSTRS((ID_ISAR3 >> 24u) &
                                                     0b1111u);
    }

    /**
     * Get ID_ISAR3's THUMBCOPY_INSTRS field.
     *
     * Indicates the supported non flag-setting MOV instructions
     */
    inline SystemControl_ID_ISAR3_THUMBCOPY_INSTRS
    get_ID_ISAR3_THUMBCOPY_INSTRS() volatile
    {
        return SystemControl_ID_ISAR3_THUMBCOPY_INSTRS((ID_ISAR3 >> 20u) &
                                                       0b1111u);
    }

    /**
     * Get ID_ISAR3's TABBRANCH_INSTRS field.
     *
     * Indicates the supported Table Branch instructions
     */
    inline SystemControl_ID_ISAR3_TABBRANCH_INSTRS
    get_ID_ISAR3_TABBRANCH_INSTRS() volatile
    {
        return SystemControl_ID_ISAR3_TABBRANCH_INSTRS((ID_ISAR3 >> 16u) &
                                                       0b1111u);
    }

    /**
     * Get ID_ISAR3's SYNCHPRIM_INSTRS field.
     *
     * Together with the ID_ISAR4[SYNCHPRIM_INSTRS_FRAC] indicates the
     * supported Synchronization Primitives
     */
    inline uint8_t get_ID_ISAR3_SYNCHPRIM_INSTRS() volatile
    {
        return (ID_ISAR3 >> 12u) & 0b1111u;
    }

    /**
     * Get ID_ISAR3's SVC_INSTRS field.
     *
     * Indicates the supported SVC instructions
     */
    inline SystemControl_ID_ISAR3_SVC_INSTRS get_ID_ISAR3_SVC_INSTRS() volatile
    {
        return SystemControl_ID_ISAR3_SVC_INSTRS((ID_ISAR3 >> 8u) & 0b1111u);
    }

    /**
     * Get ID_ISAR3's SIMD_INSTRS field.
     *
     * Indicates the supported SIMD instructions
     */
    inline SystemControl_ID_ISAR3_SIMD_INSTRS
    get_ID_ISAR3_SIMD_INSTRS() volatile
    {
        return SystemControl_ID_ISAR3_SIMD_INSTRS((ID_ISAR3 >> 4u) & 0b1111u);
    }

    /**
     * Get ID_ISAR3's SATURATE_INSTRS field.
     *
     * Indicates the supported Saturate instructions
     */
    inline SystemControl_ID_ISAR3_SATURATE_INSTRS
    get_ID_ISAR3_SATURATE_INSTRS() volatile
    {
        return SystemControl_ID_ISAR3_SATURATE_INSTRS((ID_ISAR3 >> 0u) &
                                                      0b1111u);
    }

    /**
     * Get all of ID_ISAR3's bit fields.
     *
     * (read-write) Instruction Set Attributes Register 3
     */
    inline void get_ID_ISAR3(
        SystemControl_ID_ISAR3_TRUENOP_INSTRS &TRUENOP_INSTRS,
        SystemControl_ID_ISAR3_THUMBCOPY_INSTRS &THUMBCOPY_INSTRS,
        SystemControl_ID_ISAR3_TABBRANCH_INSTRS &TABBRANCH_INSTRS,
        uint8_t &SYNCHPRIM_INSTRS,
        SystemControl_ID_ISAR3_SVC_INSTRS &SVC_INSTRS,
        SystemControl_ID_ISAR3_SIMD_INSTRS &SIMD_INSTRS,
        SystemControl_ID_ISAR3_SATURATE_INSTRS &SATURATE_INSTRS) volatile
    {
        uint32_t curr = ID_ISAR3;

        TRUENOP_INSTRS =
            SystemControl_ID_ISAR3_TRUENOP_INSTRS((curr >> 24u) & 0b1111u);
        THUMBCOPY_INSTRS =
            SystemControl_ID_ISAR3_THUMBCOPY_INSTRS((curr >> 20u) & 0b1111u);
        TABBRANCH_INSTRS =
            SystemControl_ID_ISAR3_TABBRANCH_INSTRS((curr >> 16u) & 0b1111u);
        SYNCHPRIM_INSTRS = (curr >> 12u) & 0b1111u;
        SVC_INSTRS = SystemControl_ID_ISAR3_SVC_INSTRS((curr >> 8u) & 0b1111u);
        SIMD_INSTRS =
            SystemControl_ID_ISAR3_SIMD_INSTRS((curr >> 4u) & 0b1111u);
        SATURATE_INSTRS =
            SystemControl_ID_ISAR3_SATURATE_INSTRS((curr >> 0u) & 0b1111u);
    }

    /**
     * Get ID_ISAR4's PSR_M_INSTRS field.
     *
     * Indicates the supported M profile instructions to modify the PSRs
     */
    inline SystemControl_ID_ISAR4_PSR_M_INSTRS
    get_ID_ISAR4_PSR_M_INSTRS() volatile
    {
        return SystemControl_ID_ISAR4_PSR_M_INSTRS((ID_ISAR4 >> 24u) &
                                                   0b1111u);
    }

    /**
     * Get ID_ISAR4's SYNCHPRIM_INSTRS_FRAC field.
     *
     * Together with the ID_ISAR3[SYNCHPRIM_INSTRS] indicates the supported
     * Synchronization Primitives
     */
    inline uint8_t get_ID_ISAR4_SYNCHPRIM_INSTRS_FRAC() volatile
    {
        return (ID_ISAR4 >> 20u) & 0b1111u;
    }

    /**
     * Get ID_ISAR4's BARRIER_INSTRS field.
     *
     * Indicates the supported Barrier instructions
     */
    inline SystemControl_ID_ISAR4_BARRIER_INSTRS
    get_ID_ISAR4_BARRIER_INSTRS() volatile
    {
        return SystemControl_ID_ISAR4_BARRIER_INSTRS((ID_ISAR4 >> 16u) &
                                                     0b1111u);
    }

    /**
     * Get ID_ISAR4's WRITEBACK_INSTRS field.
     *
     * Indicates the support for Writeback addressing modes
     */
    inline SystemControl_ID_ISAR4_WRITEBACK_INSTRS
    get_ID_ISAR4_WRITEBACK_INSTRS() volatile
    {
        return SystemControl_ID_ISAR4_WRITEBACK_INSTRS((ID_ISAR4 >> 8u) &
                                                       0b1111u);
    }

    /**
     * Get ID_ISAR4's WITHSHIFTS_INSTRS field.
     *
     * Indicates the support for instructions with shifts
     */
    inline SystemControl_ID_ISAR4_WITHSHIFTS_INSTRS
    get_ID_ISAR4_WITHSHIFTS_INSTRS() volatile
    {
        return SystemControl_ID_ISAR4_WITHSHIFTS_INSTRS((ID_ISAR4 >> 4u) &
                                                        0b1111u);
    }

    /**
     * Get ID_ISAR4's UNPRIV_INSTRS field.
     *
     * Indicates the supported unprivileged instructions. These are the
     * instruction variants indicated by a T suffix.
     */
    inline SystemControl_ID_ISAR4_UNPRIV_INSTRS
    get_ID_ISAR4_UNPRIV_INSTRS() volatile
    {
        return SystemControl_ID_ISAR4_UNPRIV_INSTRS((ID_ISAR4 >> 0u) &
                                                    0b1111u);
    }

    /**
     * Get all of ID_ISAR4's bit fields.
     *
     * (read-write) Instruction Set Attributes Register 4
     */
    inline void get_ID_ISAR4(
        SystemControl_ID_ISAR4_PSR_M_INSTRS &PSR_M_INSTRS,
        uint8_t &SYNCHPRIM_INSTRS_FRAC,
        SystemControl_ID_ISAR4_BARRIER_INSTRS &BARRIER_INSTRS,
        SystemControl_ID_ISAR4_WRITEBACK_INSTRS &WRITEBACK_INSTRS,
        SystemControl_ID_ISAR4_WITHSHIFTS_INSTRS &WITHSHIFTS_INSTRS,
        SystemControl_ID_ISAR4_UNPRIV_INSTRS &UNPRIV_INSTRS) volatile
    {
        uint32_t curr = ID_ISAR4;

        PSR_M_INSTRS =
            SystemControl_ID_ISAR4_PSR_M_INSTRS((curr >> 24u) & 0b1111u);
        SYNCHPRIM_INSTRS_FRAC = (curr >> 20u) & 0b1111u;
        BARRIER_INSTRS =
            SystemControl_ID_ISAR4_BARRIER_INSTRS((curr >> 16u) & 0b1111u);
        WRITEBACK_INSTRS =
            SystemControl_ID_ISAR4_WRITEBACK_INSTRS((curr >> 8u) & 0b1111u);
        WITHSHIFTS_INSTRS =
            SystemControl_ID_ISAR4_WITHSHIFTS_INSTRS((curr >> 4u) & 0b1111u);
        UNPRIV_INSTRS =
            SystemControl_ID_ISAR4_UNPRIV_INSTRS((curr >> 0u) & 0b1111u);
    }

    /**
     * Get CLIDR's LOU field.
     *
     * Level of Unification for the cache hierarchy
     */
    inline SystemControl_CLIDR_LOU get_CLIDR_LOU() volatile
    {
        return SystemControl_CLIDR_LOU((CLIDR >> 27u) & 0b111u);
    }

    /**
     * Get CLIDR's LOC field.
     *
     * Level of Coherency for the cache hierarchy
     */
    inline SystemControl_CLIDR_LOC get_CLIDR_LOC() volatile
    {
        return SystemControl_CLIDR_LOC((CLIDR >> 24u) & 0b111u);
    }

    /**
     * Get CLIDR's LOUIS field.
     *
     * Level of Unification Inner Shareable for the cache hierarchy. This field
     * is RAZ.
     */
    inline SystemControl_CLIDR_LOUIS get_CLIDR_LOUIS() volatile
    {
        return SystemControl_CLIDR_LOUIS((CLIDR >> 21u) & 0b111u);
    }

    /**
     * Get CLIDR's CL7 field.
     *
     * Indicate the type of cache implemented at level 7.
     */
    inline SystemControl_CLIDR_CL7 get_CLIDR_CL7() volatile
    {
        return SystemControl_CLIDR_CL7((CLIDR >> 18u) & 0b111u);
    }

    /**
     * Get CLIDR's CL6 field.
     *
     * Indicate the type of cache implemented at level 6.
     */
    inline SystemControl_CLIDR_CL6 get_CLIDR_CL6() volatile
    {
        return SystemControl_CLIDR_CL6((CLIDR >> 15u) & 0b111u);
    }

    /**
     * Get CLIDR's CL5 field.
     *
     * Indicate the type of cache implemented at level 5.
     */
    inline SystemControl_CLIDR_CL5 get_CLIDR_CL5() volatile
    {
        return SystemControl_CLIDR_CL5((CLIDR >> 12u) & 0b111u);
    }

    /**
     * Get CLIDR's CL4 field.
     *
     * Indicate the type of cache implemented at level 4.
     */
    inline SystemControl_CLIDR_CL4 get_CLIDR_CL4() volatile
    {
        return SystemControl_CLIDR_CL4((CLIDR >> 9u) & 0b111u);
    }

    /**
     * Get CLIDR's CL3 field.
     *
     * Indicate the type of cache implemented at level 3.
     */
    inline SystemControl_CLIDR_CL3 get_CLIDR_CL3() volatile
    {
        return SystemControl_CLIDR_CL3((CLIDR >> 6u) & 0b111u);
    }

    /**
     * Get CLIDR's CL2 field.
     *
     * Indicate the type of cache implemented at level 2.
     */
    inline SystemControl_CLIDR_CL2 get_CLIDR_CL2() volatile
    {
        return SystemControl_CLIDR_CL2((CLIDR >> 3u) & 0b111u);
    }

    /**
     * Get CLIDR's CL1 field.
     *
     * Indicate the type of cache implemented at level 1.
     */
    inline SystemControl_CLIDR_CL1 get_CLIDR_CL1() volatile
    {
        return SystemControl_CLIDR_CL1((CLIDR >> 0u) & 0b111u);
    }

    /**
     * Get all of CLIDR's bit fields.
     *
     * (read-write) Cache Level ID register
     */
    inline void get_CLIDR(
        SystemControl_CLIDR_LOU &LOU, SystemControl_CLIDR_LOC &LOC,
        SystemControl_CLIDR_LOUIS &LOUIS, SystemControl_CLIDR_CL7 &CL7,
        SystemControl_CLIDR_CL6 &CL6, SystemControl_CLIDR_CL5 &CL5,
        SystemControl_CLIDR_CL4 &CL4, SystemControl_CLIDR_CL3 &CL3,
        SystemControl_CLIDR_CL2 &CL2, SystemControl_CLIDR_CL1 &CL1) volatile
    {
        uint32_t curr = CLIDR;

        LOU = SystemControl_CLIDR_LOU((curr >> 27u) & 0b111u);
        LOC = SystemControl_CLIDR_LOC((curr >> 24u) & 0b111u);
        LOUIS = SystemControl_CLIDR_LOUIS((curr >> 21u) & 0b111u);
        CL7 = SystemControl_CLIDR_CL7((curr >> 18u) & 0b111u);
        CL6 = SystemControl_CLIDR_CL6((curr >> 15u) & 0b111u);
        CL5 = SystemControl_CLIDR_CL5((curr >> 12u) & 0b111u);
        CL4 = SystemControl_CLIDR_CL4((curr >> 9u) & 0b111u);
        CL3 = SystemControl_CLIDR_CL3((curr >> 6u) & 0b111u);
        CL2 = SystemControl_CLIDR_CL2((curr >> 3u) & 0b111u);
        CL1 = SystemControl_CLIDR_CL1((curr >> 0u) & 0b111u);
    }

    /**
     * Get CTR's FORMAT field.
     *
     * Indicates the implemented CTR format.
     */
    inline SystemControl_CTR_FORMAT get_CTR_FORMAT() volatile
    {
        return SystemControl_CTR_FORMAT((CTR >> 29u) & 0b111u);
    }

    /**
     * Get CTR's CWG field.
     *
     * Cache Write-back Granule. The maximum size of memory that can be
     * overwritten as a result of the eviction of a cache entry that has had a
     * memory location in it modified, encoded as Log2 of the number of words.
     */
    inline uint8_t get_CTR_CWG() volatile
    {
        return (CTR >> 24u) & 0b1111u;
    }

    /**
     * Get CTR's ERG field.
     *
     * Exclusives Reservation Granule. The maximum size of the reservation
     * granule that has been implemented for the Load-Exclusive and
     * Store-Exclusive instructions, encoded as Log2 of the number of words.
     */
    inline uint8_t get_CTR_ERG() volatile
    {
        return (CTR >> 20u) & 0b1111u;
    }

    /**
     * Get CTR's DMINLINE field.
     *
     * Log2 of the number of words in the smallest cache line of all the data
     * caches and unified caches that are controlled by the processor.
     */
    inline uint8_t get_CTR_DMINLINE() volatile
    {
        return (CTR >> 16u) & 0b1111u;
    }

    /**
     * Get CTR's IMINLINE field.
     *
     * Log2 of the number of words in the smallest cache line of all the
     * instruction caches that are controlled by the processor.
     */
    inline uint8_t get_CTR_IMINLINE() volatile
    {
        return (CTR >> 0u) & 0b1111u;
    }

    /**
     * Get all of CTR's bit fields.
     *
     * (read-write) Cache Type register
     */
    inline void get_CTR(SystemControl_CTR_FORMAT &FORMAT, uint8_t &CWG,
                        uint8_t &ERG, uint8_t &DMINLINE,
                        uint8_t &IMINLINE) volatile
    {
        uint32_t curr = CTR;

        FORMAT = SystemControl_CTR_FORMAT((curr >> 29u) & 0b111u);
        CWG = (curr >> 24u) & 0b1111u;
        ERG = (curr >> 20u) & 0b1111u;
        DMINLINE = (curr >> 16u) & 0b1111u;
        IMINLINE = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get CCSIDR's WT bit.
     *
     * Indicates whether the cache level supports write-through
     */
    inline bool get_CCSIDR_WT() volatile
    {
        return CCSIDR & (1u << 31u);
    }

    /**
     * Get CCSIDR's WB bit.
     *
     * Indicates whether the cache level supports write-back
     */
    inline bool get_CCSIDR_WB() volatile
    {
        return CCSIDR & (1u << 30u);
    }

    /**
     * Get CCSIDR's RA bit.
     *
     * Indicates whether the cache level supports read-allocation
     */
    inline bool get_CCSIDR_RA() volatile
    {
        return CCSIDR & (1u << 29u);
    }

    /**
     * Get CCSIDR's WA bit.
     *
     * Indicates whether the cache level supports write-allocation
     */
    inline bool get_CCSIDR_WA() volatile
    {
        return CCSIDR & (1u << 28u);
    }

    /**
     * Get CCSIDR's NUMSETS field.
     *
     * (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in
     * the cache. The number of sets does not have to be a power of 2.
     */
    inline uint16_t get_CCSIDR_NUMSETS() volatile
    {
        return (CCSIDR >> 13u) & 0b111111111111111u;
    }

    /**
     * Get CCSIDR's ASSOCIATIVITY field.
     *
     * (Associativity of cache) - 1, therefore a value of 0 indicates an
     * associativity of 1. The associativity does not have to be a power of 2.
     */
    inline uint16_t get_CCSIDR_ASSOCIATIVITY() volatile
    {
        return (CCSIDR >> 3u) & 0b1111111111u;
    }

    /**
     * Get CCSIDR's LINESIZE field.
     *
     * (Log2(Number of words in cache line)) - 2.
     */
    inline SystemControl_CCSIDR_LINESIZE get_CCSIDR_LINESIZE() volatile
    {
        return SystemControl_CCSIDR_LINESIZE((CCSIDR >> 0u) & 0b111u);
    }

    /**
     * Get all of CCSIDR's bit fields.
     *
     * (read-write) Cache Size ID Register
     */
    inline void get_CCSIDR(bool &WT, bool &WB, bool &RA, bool &WA,
                           uint16_t &NUMSETS, uint16_t &ASSOCIATIVITY,
                           SystemControl_CCSIDR_LINESIZE &LINESIZE) volatile
    {
        uint32_t curr = CCSIDR;

        WT = curr & (1u << 31u);
        WB = curr & (1u << 30u);
        RA = curr & (1u << 29u);
        WA = curr & (1u << 28u);
        NUMSETS = (curr >> 13u) & 0b111111111111111u;
        ASSOCIATIVITY = (curr >> 3u) & 0b1111111111u;
        LINESIZE = SystemControl_CCSIDR_LINESIZE((curr >> 0u) & 0b111u);
    }

    /**
     * Get CSSELR's LEVEL field.
     *
     * Cache level of required cache
     */
    inline SystemControl_CSSELR_LEVEL get_CSSELR_LEVEL() volatile
    {
        return SystemControl_CSSELR_LEVEL((CSSELR >> 1u) & 0b111u);
    }

    /**
     * Set CSSELR's LEVEL field.
     *
     * Cache level of required cache
     */
    inline void set_CSSELR_LEVEL(SystemControl_CSSELR_LEVEL value) volatile
    {
        uint32_t curr = CSSELR;

        curr &= ~(0b111u << 1u);
        curr |= (std::to_underlying(value) & 0b111u) << 1u;

        CSSELR = curr;
    }

    /**
     * Get CSSELR's IND bit.
     *
     * Instruction not data bit
     */
    inline bool get_CSSELR_IND() volatile
    {
        return CSSELR & (1u << 0u);
    }

    /**
     * Set CSSELR's IND bit.
     *
     * Instruction not data bit
     */
    inline void set_CSSELR_IND() volatile
    {
        CSSELR |= 1u << 0u;
    }

    /**
     * Clear CSSELR's IND bit.
     *
     * Instruction not data bit
     */
    inline void clear_CSSELR_IND() volatile
    {
        CSSELR &= ~(1u << 0u);
    }

    /**
     * Toggle CSSELR's IND bit.
     *
     * Instruction not data bit
     */
    inline void toggle_CSSELR_IND() volatile
    {
        CSSELR ^= 1u << 0u;
    }

    /**
     * Get all of CSSELR's bit fields.
     *
     * (read-write) Cache Size Selection Register
     */
    inline void get_CSSELR(SystemControl_CSSELR_LEVEL &LEVEL,
                           bool &IND) volatile
    {
        uint32_t curr = CSSELR;

        LEVEL = SystemControl_CSSELR_LEVEL((curr >> 1u) & 0b111u);
        IND = curr & (1u << 0u);
    }

    /**
     * Set all of CSSELR's bit fields.
     *
     * (read-write) Cache Size Selection Register
     */
    inline void set_CSSELR(SystemControl_CSSELR_LEVEL LEVEL, bool IND) volatile
    {
        uint32_t curr = CSSELR;

        curr &= ~(0b111u << 1u);
        curr |= (std::to_underlying(LEVEL) & 0b111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IND & 0b1u) << 0u;

        CSSELR = curr;
    }

    /**
     * Get CPACR's CP11 field.
     *
     * Access privileges for coprocessor 11.
     */
    inline SystemControl_CPACR_CP11 get_CPACR_CP11() volatile
    {
        return SystemControl_CPACR_CP11((CPACR >> 22u) & 0b11u);
    }

    /**
     * Set CPACR's CP11 field.
     *
     * Access privileges for coprocessor 11.
     */
    inline void set_CPACR_CP11(SystemControl_CPACR_CP11 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 22u);
        curr |= (std::to_underlying(value) & 0b11u) << 22u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP10 field.
     *
     * Access privileges for coprocessor 10.
     */
    inline SystemControl_CPACR_CP10 get_CPACR_CP10() volatile
    {
        return SystemControl_CPACR_CP10((CPACR >> 20u) & 0b11u);
    }

    /**
     * Set CPACR's CP10 field.
     *
     * Access privileges for coprocessor 10.
     */
    inline void set_CPACR_CP10(SystemControl_CPACR_CP10 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP7 field.
     *
     * Access privileges for coprocessor 7.
     */
    inline SystemControl_CPACR_CP7 get_CPACR_CP7() volatile
    {
        return SystemControl_CPACR_CP7((CPACR >> 14u) & 0b11u);
    }

    /**
     * Set CPACR's CP7 field.
     *
     * Access privileges for coprocessor 7.
     */
    inline void set_CPACR_CP7(SystemControl_CPACR_CP7 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP6 field.
     *
     * Access privileges for coprocessor 6.
     */
    inline SystemControl_CPACR_CP6 get_CPACR_CP6() volatile
    {
        return SystemControl_CPACR_CP6((CPACR >> 12u) & 0b11u);
    }

    /**
     * Set CPACR's CP6 field.
     *
     * Access privileges for coprocessor 6.
     */
    inline void set_CPACR_CP6(SystemControl_CPACR_CP6 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP5 field.
     *
     * Access privileges for coprocessor 5.
     */
    inline SystemControl_CPACR_CP5 get_CPACR_CP5() volatile
    {
        return SystemControl_CPACR_CP5((CPACR >> 10u) & 0b11u);
    }

    /**
     * Set CPACR's CP5 field.
     *
     * Access privileges for coprocessor 5.
     */
    inline void set_CPACR_CP5(SystemControl_CPACR_CP5 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP4 field.
     *
     * Access privileges for coprocessor 4.
     */
    inline SystemControl_CPACR_CP4 get_CPACR_CP4() volatile
    {
        return SystemControl_CPACR_CP4((CPACR >> 8u) & 0b11u);
    }

    /**
     * Set CPACR's CP4 field.
     *
     * Access privileges for coprocessor 4.
     */
    inline void set_CPACR_CP4(SystemControl_CPACR_CP4 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP3 field.
     *
     * Access privileges for coprocessor 3.
     */
    inline SystemControl_CPACR_CP3 get_CPACR_CP3() volatile
    {
        return SystemControl_CPACR_CP3((CPACR >> 6u) & 0b11u);
    }

    /**
     * Set CPACR's CP3 field.
     *
     * Access privileges for coprocessor 3.
     */
    inline void set_CPACR_CP3(SystemControl_CPACR_CP3 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP2 field.
     *
     * Access privileges for coprocessor 2.
     */
    inline SystemControl_CPACR_CP2 get_CPACR_CP2() volatile
    {
        return SystemControl_CPACR_CP2((CPACR >> 4u) & 0b11u);
    }

    /**
     * Set CPACR's CP2 field.
     *
     * Access privileges for coprocessor 2.
     */
    inline void set_CPACR_CP2(SystemControl_CPACR_CP2 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP1 field.
     *
     * Access privileges for coprocessor 1.
     */
    inline SystemControl_CPACR_CP1 get_CPACR_CP1() volatile
    {
        return SystemControl_CPACR_CP1((CPACR >> 2u) & 0b11u);
    }

    /**
     * Set CPACR's CP1 field.
     *
     * Access privileges for coprocessor 1.
     */
    inline void set_CPACR_CP1(SystemControl_CPACR_CP1 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CPACR = curr;
    }

    /**
     * Get CPACR's CP0 field.
     *
     * Access privileges for coprocessor 0.
     */
    inline SystemControl_CPACR_CP0 get_CPACR_CP0() volatile
    {
        return SystemControl_CPACR_CP0((CPACR >> 0u) & 0b11u);
    }

    /**
     * Set CPACR's CP0 field.
     *
     * Access privileges for coprocessor 0.
     */
    inline void set_CPACR_CP0(SystemControl_CPACR_CP0 value) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CPACR = curr;
    }

    /**
     * Get all of CPACR's bit fields.
     *
     * (read-write) Coprocessor Access Control Register
     */
    inline void get_CPACR(
        SystemControl_CPACR_CP11 &CP11, SystemControl_CPACR_CP10 &CP10,
        SystemControl_CPACR_CP7 &CP7, SystemControl_CPACR_CP6 &CP6,
        SystemControl_CPACR_CP5 &CP5, SystemControl_CPACR_CP4 &CP4,
        SystemControl_CPACR_CP3 &CP3, SystemControl_CPACR_CP2 &CP2,
        SystemControl_CPACR_CP1 &CP1, SystemControl_CPACR_CP0 &CP0) volatile
    {
        uint32_t curr = CPACR;

        CP11 = SystemControl_CPACR_CP11((curr >> 22u) & 0b11u);
        CP10 = SystemControl_CPACR_CP10((curr >> 20u) & 0b11u);
        CP7 = SystemControl_CPACR_CP7((curr >> 14u) & 0b11u);
        CP6 = SystemControl_CPACR_CP6((curr >> 12u) & 0b11u);
        CP5 = SystemControl_CPACR_CP5((curr >> 10u) & 0b11u);
        CP4 = SystemControl_CPACR_CP4((curr >> 8u) & 0b11u);
        CP3 = SystemControl_CPACR_CP3((curr >> 6u) & 0b11u);
        CP2 = SystemControl_CPACR_CP2((curr >> 4u) & 0b11u);
        CP1 = SystemControl_CPACR_CP1((curr >> 2u) & 0b11u);
        CP0 = SystemControl_CPACR_CP0((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CPACR's bit fields.
     *
     * (read-write) Coprocessor Access Control Register
     */
    inline void set_CPACR(
        SystemControl_CPACR_CP11 CP11, SystemControl_CPACR_CP10 CP10,
        SystemControl_CPACR_CP7 CP7, SystemControl_CPACR_CP6 CP6,
        SystemControl_CPACR_CP5 CP5, SystemControl_CPACR_CP4 CP4,
        SystemControl_CPACR_CP3 CP3, SystemControl_CPACR_CP2 CP2,
        SystemControl_CPACR_CP1 CP1, SystemControl_CPACR_CP0 CP0) volatile
    {
        uint32_t curr = CPACR;

        curr &= ~(0b11u << 22u);
        curr |= (std::to_underlying(CP11) & 0b11u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(CP10) & 0b11u) << 20u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(CP7) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(CP6) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(CP5) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(CP4) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CP3) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(CP2) & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CP1) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CP0) & 0b11u) << 0u;

        CPACR = curr;
    }

    /**
     * Set STIR's INTID field.
     *
     * Indicates the interrupt to be triggered
     */
    inline void set_STIR_INTID(uint16_t value) volatile
    {
        uint32_t curr = STIR;

        curr &= ~(0b111111111u << 0u);
        curr |= (value & 0b111111111u) << 0u;

        STIR = curr;
    }

    /**
     * Set ICIALLU's ICIALLU field.
     *
     * I-cache invalidate all to PoU
     */
    inline void set_ICIALLU_ICIALLU(uint32_t value) volatile
    {
        uint32_t curr = ICIALLU;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ICIALLU = curr;
    }

    /**
     * Set ICIMVAU's ICIMVAU field.
     *
     * I-cache invalidate by MVA to PoU
     */
    inline void set_ICIMVAU_ICIMVAU(uint32_t value) volatile
    {
        uint32_t curr = ICIMVAU;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        ICIMVAU = curr;
    }

    /**
     * Set DCIMVAC's DCIMVAC field.
     *
     * D-cache invalidate by MVA to PoC
     */
    inline void set_DCIMVAC_DCIMVAC(uint32_t value) volatile
    {
        uint32_t curr = DCIMVAC;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCIMVAC = curr;
    }

    /**
     * Set DCISW's DCISW field.
     *
     * D-cache invalidate by set-way
     */
    inline void set_DCISW_DCISW(uint32_t value) volatile
    {
        uint32_t curr = DCISW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCISW = curr;
    }

    /**
     * Set DCCMVAU's DCCMVAU field.
     *
     * D-cache clean by MVA to PoU
     */
    inline void set_DCCMVAU_DCCMVAU(uint32_t value) volatile
    {
        uint32_t curr = DCCMVAU;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCCMVAU = curr;
    }

    /**
     * Set DCCMVAC's DCCMVAC field.
     *
     * D-cache clean by MVA to PoC
     */
    inline void set_DCCMVAC_DCCMVAC(uint32_t value) volatile
    {
        uint32_t curr = DCCMVAC;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCCMVAC = curr;
    }

    /**
     * Set DCCSW's DCCSW field.
     *
     * D-cache clean by set-way
     */
    inline void set_DCCSW_DCCSW(uint32_t value) volatile
    {
        uint32_t curr = DCCSW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCCSW = curr;
    }

    /**
     * Set DCCIMVAC's DCCIMVAC field.
     *
     * D-cache clean and invalidate by MVA to PoC
     */
    inline void set_DCCIMVAC_DCCIMVAC(uint32_t value) volatile
    {
        uint32_t curr = DCCIMVAC;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCCIMVAC = curr;
    }

    /**
     * Set DCCISW's DCCISW field.
     *
     * D-cache clean and invalidate by set-way
     */
    inline void set_DCCISW_DCCISW(uint32_t value) volatile
    {
        uint32_t curr = DCCISW;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DCCISW = curr;
    }

    /**
     * Get CM7_ITCMCR's SZ field.
     *
     * TCM size. Indicates the size of the relevant TCM.
     */
    inline SystemControl_CM7_ITCMCR_SZ get_CM7_ITCMCR_SZ() volatile
    {
        return SystemControl_CM7_ITCMCR_SZ((CM7_ITCMCR >> 3u) & 0b1111u);
    }

    /**
     * Get CM7_ITCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline bool get_CM7_ITCMCR_RETEN() volatile
    {
        return CM7_ITCMCR & (1u << 2u);
    }

    /**
     * Set CM7_ITCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline void set_CM7_ITCMCR_RETEN() volatile
    {
        CM7_ITCMCR |= 1u << 2u;
    }

    /**
     * Clear CM7_ITCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline void clear_CM7_ITCMCR_RETEN() volatile
    {
        CM7_ITCMCR &= ~(1u << 2u);
    }

    /**
     * Toggle CM7_ITCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline void toggle_CM7_ITCMCR_RETEN() volatile
    {
        CM7_ITCMCR ^= 1u << 2u;
    }

    /**
     * Get CM7_ITCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline bool get_CM7_ITCMCR_RMW() volatile
    {
        return CM7_ITCMCR & (1u << 1u);
    }

    /**
     * Set CM7_ITCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline void set_CM7_ITCMCR_RMW() volatile
    {
        CM7_ITCMCR |= 1u << 1u;
    }

    /**
     * Clear CM7_ITCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline void clear_CM7_ITCMCR_RMW() volatile
    {
        CM7_ITCMCR &= ~(1u << 1u);
    }

    /**
     * Toggle CM7_ITCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline void toggle_CM7_ITCMCR_RMW() volatile
    {
        CM7_ITCMCR ^= 1u << 1u;
    }

    /**
     * Get CM7_ITCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline bool get_CM7_ITCMCR_EN() volatile
    {
        return CM7_ITCMCR & (1u << 0u);
    }

    /**
     * Set CM7_ITCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline void set_CM7_ITCMCR_EN() volatile
    {
        CM7_ITCMCR |= 1u << 0u;
    }

    /**
     * Clear CM7_ITCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline void clear_CM7_ITCMCR_EN() volatile
    {
        CM7_ITCMCR &= ~(1u << 0u);
    }

    /**
     * Toggle CM7_ITCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline void toggle_CM7_ITCMCR_EN() volatile
    {
        CM7_ITCMCR ^= 1u << 0u;
    }

    /**
     * Get all of CM7_ITCMCR's bit fields.
     *
     * (read-write) Instruction Tightly-Coupled Memory Control Register
     */
    inline void get_CM7_ITCMCR(SystemControl_CM7_ITCMCR_SZ &SZ, bool &RETEN,
                               bool &RMW, bool &EN) volatile
    {
        uint32_t curr = CM7_ITCMCR;

        SZ = SystemControl_CM7_ITCMCR_SZ((curr >> 3u) & 0b1111u);
        RETEN = curr & (1u << 2u);
        RMW = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of CM7_ITCMCR's bit fields.
     *
     * (read-write) Instruction Tightly-Coupled Memory Control Register
     */
    inline void set_CM7_ITCMCR(bool RETEN, bool RMW, bool EN) volatile
    {
        uint32_t curr = CM7_ITCMCR;

        curr &= ~(0b1u << 2u);
        curr |= (RETEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RMW & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        CM7_ITCMCR = curr;
    }

    /**
     * Get CM7_DTCMCR's SZ field.
     *
     * TCM size. Indicates the size of the relevant TCM.
     */
    inline SystemControl_CM7_DTCMCR_SZ get_CM7_DTCMCR_SZ() volatile
    {
        return SystemControl_CM7_DTCMCR_SZ((CM7_DTCMCR >> 3u) & 0b1111u);
    }

    /**
     * Get CM7_DTCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline bool get_CM7_DTCMCR_RETEN() volatile
    {
        return CM7_DTCMCR & (1u << 2u);
    }

    /**
     * Set CM7_DTCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline void set_CM7_DTCMCR_RETEN() volatile
    {
        CM7_DTCMCR |= 1u << 2u;
    }

    /**
     * Clear CM7_DTCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline void clear_CM7_DTCMCR_RETEN() volatile
    {
        CM7_DTCMCR &= ~(1u << 2u);
    }

    /**
     * Toggle CM7_DTCMCR's RETEN bit.
     *
     * Retry phase enable. When enabled the processor guarantees to honor the
     * retry output on the corresponding TCM interface, re-executing the
     * instruction which carried out the TCM access.
     */
    inline void toggle_CM7_DTCMCR_RETEN() volatile
    {
        CM7_DTCMCR ^= 1u << 2u;
    }

    /**
     * Get CM7_DTCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline bool get_CM7_DTCMCR_RMW() volatile
    {
        return CM7_DTCMCR & (1u << 1u);
    }

    /**
     * Set CM7_DTCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline void set_CM7_DTCMCR_RMW() volatile
    {
        CM7_DTCMCR |= 1u << 1u;
    }

    /**
     * Clear CM7_DTCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline void clear_CM7_DTCMCR_RMW() volatile
    {
        CM7_DTCMCR &= ~(1u << 1u);
    }

    /**
     * Toggle CM7_DTCMCR's RMW bit.
     *
     * Read-Modify-Write (RMW) enable. Indicates that all writes to TCM, that
     * are not the full width of the TCM RAM, use a RMW sequence.
     */
    inline void toggle_CM7_DTCMCR_RMW() volatile
    {
        CM7_DTCMCR ^= 1u << 1u;
    }

    /**
     * Get CM7_DTCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline bool get_CM7_DTCMCR_EN() volatile
    {
        return CM7_DTCMCR & (1u << 0u);
    }

    /**
     * Set CM7_DTCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline void set_CM7_DTCMCR_EN() volatile
    {
        CM7_DTCMCR |= 1u << 0u;
    }

    /**
     * Clear CM7_DTCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline void clear_CM7_DTCMCR_EN() volatile
    {
        CM7_DTCMCR &= ~(1u << 0u);
    }

    /**
     * Toggle CM7_DTCMCR's EN bit.
     *
     * TCM enable. When a TCM is disabled all accesses are made to the AXIM
     * interface.
     */
    inline void toggle_CM7_DTCMCR_EN() volatile
    {
        CM7_DTCMCR ^= 1u << 0u;
    }

    /**
     * Get all of CM7_DTCMCR's bit fields.
     *
     * (read-write) Data Tightly-Coupled Memory Control Register
     */
    inline void get_CM7_DTCMCR(SystemControl_CM7_DTCMCR_SZ &SZ, bool &RETEN,
                               bool &RMW, bool &EN) volatile
    {
        uint32_t curr = CM7_DTCMCR;

        SZ = SystemControl_CM7_DTCMCR_SZ((curr >> 3u) & 0b1111u);
        RETEN = curr & (1u << 2u);
        RMW = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of CM7_DTCMCR's bit fields.
     *
     * (read-write) Data Tightly-Coupled Memory Control Register
     */
    inline void set_CM7_DTCMCR(bool RETEN, bool RMW, bool EN) volatile
    {
        uint32_t curr = CM7_DTCMCR;

        curr &= ~(0b1u << 2u);
        curr |= (RETEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RMW & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        CM7_DTCMCR = curr;
    }

    /**
     * Get CM7_AHBPCR's SZ field.
     *
     * AHBP size.
     */
    inline SystemControl_CM7_AHBPCR_SZ get_CM7_AHBPCR_SZ() volatile
    {
        return SystemControl_CM7_AHBPCR_SZ((CM7_AHBPCR >> 1u) & 0b111u);
    }

    /**
     * Get CM7_AHBPCR's EN bit.
     *
     * AHBP enable.
     */
    inline bool get_CM7_AHBPCR_EN() volatile
    {
        return CM7_AHBPCR & (1u << 0u);
    }

    /**
     * Set CM7_AHBPCR's EN bit.
     *
     * AHBP enable.
     */
    inline void set_CM7_AHBPCR_EN() volatile
    {
        CM7_AHBPCR |= 1u << 0u;
    }

    /**
     * Clear CM7_AHBPCR's EN bit.
     *
     * AHBP enable.
     */
    inline void clear_CM7_AHBPCR_EN() volatile
    {
        CM7_AHBPCR &= ~(1u << 0u);
    }

    /**
     * Toggle CM7_AHBPCR's EN bit.
     *
     * AHBP enable.
     */
    inline void toggle_CM7_AHBPCR_EN() volatile
    {
        CM7_AHBPCR ^= 1u << 0u;
    }

    /**
     * Get all of CM7_AHBPCR's bit fields.
     *
     * (read-write) AHBP Control Register
     */
    inline void get_CM7_AHBPCR(SystemControl_CM7_AHBPCR_SZ &SZ,
                               bool &EN) volatile
    {
        uint32_t curr = CM7_AHBPCR;

        SZ = SystemControl_CM7_AHBPCR_SZ((curr >> 1u) & 0b111u);
        EN = curr & (1u << 0u);
    }

    /**
     * Get CM7_CACR's FORCEWT bit.
     *
     * Enables Force Write-Through in the data cache.
     */
    inline bool get_CM7_CACR_FORCEWT() volatile
    {
        return CM7_CACR & (1u << 2u);
    }

    /**
     * Set CM7_CACR's FORCEWT bit.
     *
     * Enables Force Write-Through in the data cache.
     */
    inline void set_CM7_CACR_FORCEWT() volatile
    {
        CM7_CACR |= 1u << 2u;
    }

    /**
     * Clear CM7_CACR's FORCEWT bit.
     *
     * Enables Force Write-Through in the data cache.
     */
    inline void clear_CM7_CACR_FORCEWT() volatile
    {
        CM7_CACR &= ~(1u << 2u);
    }

    /**
     * Toggle CM7_CACR's FORCEWT bit.
     *
     * Enables Force Write-Through in the data cache.
     */
    inline void toggle_CM7_CACR_FORCEWT() volatile
    {
        CM7_CACR ^= 1u << 2u;
    }

    /**
     * Get CM7_CACR's ECCDIS bit.
     *
     * Enables ECC in the instruction and data cache.
     */
    inline bool get_CM7_CACR_ECCDIS() volatile
    {
        return CM7_CACR & (1u << 1u);
    }

    /**
     * Set CM7_CACR's ECCDIS bit.
     *
     * Enables ECC in the instruction and data cache.
     */
    inline void set_CM7_CACR_ECCDIS() volatile
    {
        CM7_CACR |= 1u << 1u;
    }

    /**
     * Clear CM7_CACR's ECCDIS bit.
     *
     * Enables ECC in the instruction and data cache.
     */
    inline void clear_CM7_CACR_ECCDIS() volatile
    {
        CM7_CACR &= ~(1u << 1u);
    }

    /**
     * Toggle CM7_CACR's ECCDIS bit.
     *
     * Enables ECC in the instruction and data cache.
     */
    inline void toggle_CM7_CACR_ECCDIS() volatile
    {
        CM7_CACR ^= 1u << 1u;
    }

    /**
     * Get CM7_CACR's SIWT bit.
     *
     * Shared cacheable-is-WT for data cache. Enables limited cache coherency
     * usage.
     */
    inline bool get_CM7_CACR_SIWT() volatile
    {
        return CM7_CACR & (1u << 0u);
    }

    /**
     * Set CM7_CACR's SIWT bit.
     *
     * Shared cacheable-is-WT for data cache. Enables limited cache coherency
     * usage.
     */
    inline void set_CM7_CACR_SIWT() volatile
    {
        CM7_CACR |= 1u << 0u;
    }

    /**
     * Clear CM7_CACR's SIWT bit.
     *
     * Shared cacheable-is-WT for data cache. Enables limited cache coherency
     * usage.
     */
    inline void clear_CM7_CACR_SIWT() volatile
    {
        CM7_CACR &= ~(1u << 0u);
    }

    /**
     * Toggle CM7_CACR's SIWT bit.
     *
     * Shared cacheable-is-WT for data cache. Enables limited cache coherency
     * usage.
     */
    inline void toggle_CM7_CACR_SIWT() volatile
    {
        CM7_CACR ^= 1u << 0u;
    }

    /**
     * Get all of CM7_CACR's bit fields.
     *
     * (read-write) L1 Cache Control Register
     */
    inline void get_CM7_CACR(bool &FORCEWT, bool &ECCDIS, bool &SIWT) volatile
    {
        uint32_t curr = CM7_CACR;

        FORCEWT = curr & (1u << 2u);
        ECCDIS = curr & (1u << 1u);
        SIWT = curr & (1u << 0u);
    }

    /**
     * Set all of CM7_CACR's bit fields.
     *
     * (read-write) L1 Cache Control Register
     */
    inline void set_CM7_CACR(bool FORCEWT, bool ECCDIS, bool SIWT) volatile
    {
        uint32_t curr = CM7_CACR;

        curr &= ~(0b1u << 2u);
        curr |= (FORCEWT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ECCDIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SIWT & 0b1u) << 0u;

        CM7_CACR = curr;
    }

    /**
     * Get CM7_AHBSCR's INITCOUNT field.
     *
     * Fairness counter initialization value.
     */
    inline uint8_t get_CM7_AHBSCR_INITCOUNT() volatile
    {
        return (CM7_AHBSCR >> 11u) & 0b11111u;
    }

    /**
     * Set CM7_AHBSCR's INITCOUNT field.
     *
     * Fairness counter initialization value.
     */
    inline void set_CM7_AHBSCR_INITCOUNT(uint8_t value) volatile
    {
        uint32_t curr = CM7_AHBSCR;

        curr &= ~(0b11111u << 11u);
        curr |= (value & 0b11111u) << 11u;

        CM7_AHBSCR = curr;
    }

    /**
     * Get CM7_AHBSCR's TPRI field.
     *
     * Threshold execution priority for AHBS traffic demotion.
     */
    inline uint16_t get_CM7_AHBSCR_TPRI() volatile
    {
        return (CM7_AHBSCR >> 2u) & 0b111111111u;
    }

    /**
     * Set CM7_AHBSCR's TPRI field.
     *
     * Threshold execution priority for AHBS traffic demotion.
     */
    inline void set_CM7_AHBSCR_TPRI(uint16_t value) volatile
    {
        uint32_t curr = CM7_AHBSCR;

        curr &= ~(0b111111111u << 2u);
        curr |= (value & 0b111111111u) << 2u;

        CM7_AHBSCR = curr;
    }

    /**
     * Get CM7_AHBSCR's CTL field.
     *
     * AHBS prioritization control.
     */
    inline SystemControl_CM7_AHBSCR_CTL get_CM7_AHBSCR_CTL() volatile
    {
        return SystemControl_CM7_AHBSCR_CTL((CM7_AHBSCR >> 0u) & 0b11u);
    }

    /**
     * Set CM7_AHBSCR's CTL field.
     *
     * AHBS prioritization control.
     */
    inline void set_CM7_AHBSCR_CTL(SystemControl_CM7_AHBSCR_CTL value) volatile
    {
        uint32_t curr = CM7_AHBSCR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CM7_AHBSCR = curr;
    }

    /**
     * Get all of CM7_AHBSCR's bit fields.
     *
     * (read-write) AHB Slave Control Register
     */
    inline void get_CM7_AHBSCR(uint8_t &INITCOUNT, uint16_t &TPRI,
                               SystemControl_CM7_AHBSCR_CTL &CTL) volatile
    {
        uint32_t curr = CM7_AHBSCR;

        INITCOUNT = (curr >> 11u) & 0b11111u;
        TPRI = (curr >> 2u) & 0b111111111u;
        CTL = SystemControl_CM7_AHBSCR_CTL((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CM7_AHBSCR's bit fields.
     *
     * (read-write) AHB Slave Control Register
     */
    inline void set_CM7_AHBSCR(uint8_t INITCOUNT, uint16_t TPRI,
                               SystemControl_CM7_AHBSCR_CTL CTL) volatile
    {
        uint32_t curr = CM7_AHBSCR;

        curr &= ~(0b11111u << 11u);
        curr |= (INITCOUNT & 0b11111u) << 11u;
        curr &= ~(0b111111111u << 2u);
        curr |= (TPRI & 0b111111111u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CTL) & 0b11u) << 0u;

        CM7_AHBSCR = curr;
    }

    /**
     * Get CM7_ABFSR's AXIMTYPE field.
     *
     * Indicates the type of fault on the AXIM interface. Only valid when AXIM
     * is 1.
     */
    inline SystemControl_CM7_ABFSR_AXIMTYPE get_CM7_ABFSR_AXIMTYPE() volatile
    {
        return SystemControl_CM7_ABFSR_AXIMTYPE((CM7_ABFSR >> 8u) & 0b11u);
    }

    /**
     * Set CM7_ABFSR's AXIMTYPE field.
     *
     * Indicates the type of fault on the AXIM interface. Only valid when AXIM
     * is 1.
     */
    inline void set_CM7_ABFSR_AXIMTYPE(
        SystemControl_CM7_ABFSR_AXIMTYPE value) volatile
    {
        uint32_t curr = CM7_ABFSR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CM7_ABFSR = curr;
    }

    /**
     * Get CM7_ABFSR's EPPB bit.
     *
     * Asynchronous fault on EPPB interface.
     */
    inline bool get_CM7_ABFSR_EPPB() volatile
    {
        return CM7_ABFSR & (1u << 4u);
    }

    /**
     * Set CM7_ABFSR's EPPB bit.
     *
     * Asynchronous fault on EPPB interface.
     */
    inline void set_CM7_ABFSR_EPPB() volatile
    {
        CM7_ABFSR |= 1u << 4u;
    }

    /**
     * Clear CM7_ABFSR's EPPB bit.
     *
     * Asynchronous fault on EPPB interface.
     */
    inline void clear_CM7_ABFSR_EPPB() volatile
    {
        CM7_ABFSR &= ~(1u << 4u);
    }

    /**
     * Toggle CM7_ABFSR's EPPB bit.
     *
     * Asynchronous fault on EPPB interface.
     */
    inline void toggle_CM7_ABFSR_EPPB() volatile
    {
        CM7_ABFSR ^= 1u << 4u;
    }

    /**
     * Get CM7_ABFSR's AXIM bit.
     *
     * Asynchronous fault on AXIM interface.
     */
    inline bool get_CM7_ABFSR_AXIM() volatile
    {
        return CM7_ABFSR & (1u << 3u);
    }

    /**
     * Set CM7_ABFSR's AXIM bit.
     *
     * Asynchronous fault on AXIM interface.
     */
    inline void set_CM7_ABFSR_AXIM() volatile
    {
        CM7_ABFSR |= 1u << 3u;
    }

    /**
     * Clear CM7_ABFSR's AXIM bit.
     *
     * Asynchronous fault on AXIM interface.
     */
    inline void clear_CM7_ABFSR_AXIM() volatile
    {
        CM7_ABFSR &= ~(1u << 3u);
    }

    /**
     * Toggle CM7_ABFSR's AXIM bit.
     *
     * Asynchronous fault on AXIM interface.
     */
    inline void toggle_CM7_ABFSR_AXIM() volatile
    {
        CM7_ABFSR ^= 1u << 3u;
    }

    /**
     * Get CM7_ABFSR's AHBP bit.
     *
     * Asynchronous fault on AHBP interface.
     */
    inline bool get_CM7_ABFSR_AHBP() volatile
    {
        return CM7_ABFSR & (1u << 2u);
    }

    /**
     * Set CM7_ABFSR's AHBP bit.
     *
     * Asynchronous fault on AHBP interface.
     */
    inline void set_CM7_ABFSR_AHBP() volatile
    {
        CM7_ABFSR |= 1u << 2u;
    }

    /**
     * Clear CM7_ABFSR's AHBP bit.
     *
     * Asynchronous fault on AHBP interface.
     */
    inline void clear_CM7_ABFSR_AHBP() volatile
    {
        CM7_ABFSR &= ~(1u << 2u);
    }

    /**
     * Toggle CM7_ABFSR's AHBP bit.
     *
     * Asynchronous fault on AHBP interface.
     */
    inline void toggle_CM7_ABFSR_AHBP() volatile
    {
        CM7_ABFSR ^= 1u << 2u;
    }

    /**
     * Get CM7_ABFSR's DTCM bit.
     *
     * Asynchronous fault on DTCM interface.
     */
    inline bool get_CM7_ABFSR_DTCM() volatile
    {
        return CM7_ABFSR & (1u << 1u);
    }

    /**
     * Set CM7_ABFSR's DTCM bit.
     *
     * Asynchronous fault on DTCM interface.
     */
    inline void set_CM7_ABFSR_DTCM() volatile
    {
        CM7_ABFSR |= 1u << 1u;
    }

    /**
     * Clear CM7_ABFSR's DTCM bit.
     *
     * Asynchronous fault on DTCM interface.
     */
    inline void clear_CM7_ABFSR_DTCM() volatile
    {
        CM7_ABFSR &= ~(1u << 1u);
    }

    /**
     * Toggle CM7_ABFSR's DTCM bit.
     *
     * Asynchronous fault on DTCM interface.
     */
    inline void toggle_CM7_ABFSR_DTCM() volatile
    {
        CM7_ABFSR ^= 1u << 1u;
    }

    /**
     * Get CM7_ABFSR's ITCM bit.
     *
     * Asynchronous fault on ITCM interface.
     */
    inline bool get_CM7_ABFSR_ITCM() volatile
    {
        return CM7_ABFSR & (1u << 0u);
    }

    /**
     * Set CM7_ABFSR's ITCM bit.
     *
     * Asynchronous fault on ITCM interface.
     */
    inline void set_CM7_ABFSR_ITCM() volatile
    {
        CM7_ABFSR |= 1u << 0u;
    }

    /**
     * Clear CM7_ABFSR's ITCM bit.
     *
     * Asynchronous fault on ITCM interface.
     */
    inline void clear_CM7_ABFSR_ITCM() volatile
    {
        CM7_ABFSR &= ~(1u << 0u);
    }

    /**
     * Toggle CM7_ABFSR's ITCM bit.
     *
     * Asynchronous fault on ITCM interface.
     */
    inline void toggle_CM7_ABFSR_ITCM() volatile
    {
        CM7_ABFSR ^= 1u << 0u;
    }

    /**
     * Get all of CM7_ABFSR's bit fields.
     *
     * (read-write) Auxiliary Bus Fault Status Register
     */
    inline void get_CM7_ABFSR(SystemControl_CM7_ABFSR_AXIMTYPE &AXIMTYPE,
                              bool &EPPB, bool &AXIM, bool &AHBP, bool &DTCM,
                              bool &ITCM) volatile
    {
        uint32_t curr = CM7_ABFSR;

        AXIMTYPE = SystemControl_CM7_ABFSR_AXIMTYPE((curr >> 8u) & 0b11u);
        EPPB = curr & (1u << 4u);
        AXIM = curr & (1u << 3u);
        AHBP = curr & (1u << 2u);
        DTCM = curr & (1u << 1u);
        ITCM = curr & (1u << 0u);
    }

    /**
     * Set all of CM7_ABFSR's bit fields.
     *
     * (read-write) Auxiliary Bus Fault Status Register
     */
    inline void set_CM7_ABFSR(SystemControl_CM7_ABFSR_AXIMTYPE AXIMTYPE,
                              bool EPPB, bool AXIM, bool AHBP, bool DTCM,
                              bool ITCM) volatile
    {
        uint32_t curr = CM7_ABFSR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(AXIMTYPE) & 0b11u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (EPPB & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (AXIM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AHBP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DTCM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ITCM & 0b1u) << 0u;

        CM7_ABFSR = curr;
    }
};

static_assert(sizeof(systemcontrol) == systemcontrol::size);

static volatile systemcontrol *const SystemControl =
    reinterpret_cast<systemcontrol *>(0xE000E000);

}; // namespace MIMXRT1176::CM7
