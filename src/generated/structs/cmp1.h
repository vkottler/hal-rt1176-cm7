/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/CMP1_C0_FILTER_CNT.h"
#include "../enums/CMP1_C0_HYSTCTR.h"
#include "../enums/CMP1_C1_MSEL.h"
#include "../enums/CMP1_C1_PSEL.h"
#include "../enums/CMP1_C2_FXMXCH.h"
#include "../enums/CMP1_C2_NSAM.h"
#include "../enums/CMP1_C3_ACPH1TC.h"
#include "../enums/CMP1_C3_ACPH2TC.h"
#include "../enums/CMP1_C3_ACSAT.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * CMP
 */
struct [[gnu::packed]] cmp1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 24; /*!< cmp1's size in bytes. */

    /* Fields. */
    uint32_t VERID; /*!< (read-write) Version ID Register */
    uint32_t PARAM; /*!< (read-write) Parameter Register */
    uint32_t C0;    /*!< (read-write) CMP Control Register 0 */
    uint32_t C1;    /*!< (read-write) CMP Control Register 1 */
    uint32_t C2;    /*!< (read-write) CMP Control Register 2 */
    uint32_t C3;    /*!< (read-write) CMP Control Register 3 */

    /* Methods. */

    /**
     * Get VERID's MAJOR field.
     *
     * Major Version Number. This read only field returns the major version
     * number for the module specification.
     */
    inline uint8_t get_VERID_MAJOR() volatile
    {
        return (VERID >> 24u) & 0b11111111u;
    }

    /**
     * Get VERID's MINOR field.
     *
     * Minor Version Number. This read only field returns the minor version
     * number for the module specification.
     */
    inline uint8_t get_VERID_MINOR() volatile
    {
        return (VERID >> 16u) & 0b11111111u;
    }

    /**
     * Get VERID's FEATURE field.
     *
     * Feature Specification Number. This read only filed returns the feature
     * set number.
     */
    inline uint16_t get_VERID_FEATURE() volatile
    {
        return (VERID >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of VERID's bit fields.
     *
     * (read-write) Version ID Register
     */
    inline void get_VERID(uint8_t &MAJOR, uint8_t &MINOR,
                          uint16_t &FEATURE) volatile
    {
        uint32_t curr = VERID;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        FEATURE = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get PARAM's PARAM field.
     *
     * Parameter Registers. This read only filed returns the feature parameters
     * implemented along with the Version ID register.
     */
    inline uint32_t get_PARAM_PARAM() volatile
    {
        return (PARAM >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get C0's LINKEN bit.
     *
     * CMP to DAC link enable.
     */
    inline bool get_C0_LINKEN() volatile
    {
        return C0 & (1u << 31u);
    }

    /**
     * Set C0's LINKEN bit.
     *
     * CMP to DAC link enable.
     */
    inline void set_C0_LINKEN() volatile
    {
        C0 |= 1u << 31u;
    }

    /**
     * Clear C0's LINKEN bit.
     *
     * CMP to DAC link enable.
     */
    inline void clear_C0_LINKEN() volatile
    {
        C0 &= ~(1u << 31u);
    }

    /**
     * Toggle C0's LINKEN bit.
     *
     * CMP to DAC link enable.
     */
    inline void toggle_C0_LINKEN() volatile
    {
        C0 ^= 1u << 31u;
    }

    /**
     * Get C0's DMAEN bit.
     *
     * DMA Enable
     */
    inline bool get_C0_DMAEN() volatile
    {
        return C0 & (1u << 30u);
    }

    /**
     * Set C0's DMAEN bit.
     *
     * DMA Enable
     */
    inline void set_C0_DMAEN() volatile
    {
        C0 |= 1u << 30u;
    }

    /**
     * Clear C0's DMAEN bit.
     *
     * DMA Enable
     */
    inline void clear_C0_DMAEN() volatile
    {
        C0 &= ~(1u << 30u);
    }

    /**
     * Toggle C0's DMAEN bit.
     *
     * DMA Enable
     */
    inline void toggle_C0_DMAEN() volatile
    {
        C0 ^= 1u << 30u;
    }

    /**
     * Get C0's IER bit.
     *
     * Comparator Interrupt Enable Rising
     */
    inline bool get_C0_IER() volatile
    {
        return C0 & (1u << 28u);
    }

    /**
     * Set C0's IER bit.
     *
     * Comparator Interrupt Enable Rising
     */
    inline void set_C0_IER() volatile
    {
        C0 |= 1u << 28u;
    }

    /**
     * Clear C0's IER bit.
     *
     * Comparator Interrupt Enable Rising
     */
    inline void clear_C0_IER() volatile
    {
        C0 &= ~(1u << 28u);
    }

    /**
     * Toggle C0's IER bit.
     *
     * Comparator Interrupt Enable Rising
     */
    inline void toggle_C0_IER() volatile
    {
        C0 ^= 1u << 28u;
    }

    /**
     * Get C0's IEF bit.
     *
     * Comparator Interrupt Enable Falling
     */
    inline bool get_C0_IEF() volatile
    {
        return C0 & (1u << 27u);
    }

    /**
     * Set C0's IEF bit.
     *
     * Comparator Interrupt Enable Falling
     */
    inline void set_C0_IEF() volatile
    {
        C0 |= 1u << 27u;
    }

    /**
     * Clear C0's IEF bit.
     *
     * Comparator Interrupt Enable Falling
     */
    inline void clear_C0_IEF() volatile
    {
        C0 &= ~(1u << 27u);
    }

    /**
     * Toggle C0's IEF bit.
     *
     * Comparator Interrupt Enable Falling
     */
    inline void toggle_C0_IEF() volatile
    {
        C0 ^= 1u << 27u;
    }

    /**
     * Get C0's CFR bit.
     *
     * Analog Comparator Flag Rising
     */
    inline bool get_C0_CFR() volatile
    {
        return C0 & (1u << 26u);
    }

    /**
     * Set C0's CFR bit.
     *
     * Analog Comparator Flag Rising
     */
    inline void set_C0_CFR() volatile
    {
        C0 |= 1u << 26u;
    }

    /**
     * Clear C0's CFR bit.
     *
     * Analog Comparator Flag Rising
     */
    inline void clear_C0_CFR() volatile
    {
        C0 &= ~(1u << 26u);
    }

    /**
     * Toggle C0's CFR bit.
     *
     * Analog Comparator Flag Rising
     */
    inline void toggle_C0_CFR() volatile
    {
        C0 ^= 1u << 26u;
    }

    /**
     * Get C0's CFF bit.
     *
     * Analog Comparator Flag Falling
     */
    inline bool get_C0_CFF() volatile
    {
        return C0 & (1u << 25u);
    }

    /**
     * Set C0's CFF bit.
     *
     * Analog Comparator Flag Falling
     */
    inline void set_C0_CFF() volatile
    {
        C0 |= 1u << 25u;
    }

    /**
     * Clear C0's CFF bit.
     *
     * Analog Comparator Flag Falling
     */
    inline void clear_C0_CFF() volatile
    {
        C0 &= ~(1u << 25u);
    }

    /**
     * Toggle C0's CFF bit.
     *
     * Analog Comparator Flag Falling
     */
    inline void toggle_C0_CFF() volatile
    {
        C0 ^= 1u << 25u;
    }

    /**
     * Get C0's COUT bit.
     *
     * Analog Comparator Output
     */
    inline bool get_C0_COUT() volatile
    {
        return C0 & (1u << 24u);
    }

    /**
     * Get C0's FPR field.
     *
     * Filter Sample Period
     */
    inline uint8_t get_C0_FPR() volatile
    {
        return (C0 >> 16u) & 0b11111111u;
    }

    /**
     * Set C0's FPR field.
     *
     * Filter Sample Period
     */
    inline void set_C0_FPR(uint8_t value) volatile
    {
        uint32_t curr = C0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        C0 = curr;
    }

    /**
     * Get C0's SE bit.
     *
     * Sample Enable
     */
    inline bool get_C0_SE() volatile
    {
        return C0 & (1u << 15u);
    }

    /**
     * Set C0's SE bit.
     *
     * Sample Enable
     */
    inline void set_C0_SE() volatile
    {
        C0 |= 1u << 15u;
    }

    /**
     * Clear C0's SE bit.
     *
     * Sample Enable
     */
    inline void clear_C0_SE() volatile
    {
        C0 &= ~(1u << 15u);
    }

    /**
     * Toggle C0's SE bit.
     *
     * Sample Enable
     */
    inline void toggle_C0_SE() volatile
    {
        C0 ^= 1u << 15u;
    }

    /**
     * Get C0's WE bit.
     *
     * Windowing Enable
     */
    inline bool get_C0_WE() volatile
    {
        return C0 & (1u << 14u);
    }

    /**
     * Set C0's WE bit.
     *
     * Windowing Enable
     */
    inline void set_C0_WE() volatile
    {
        C0 |= 1u << 14u;
    }

    /**
     * Clear C0's WE bit.
     *
     * Windowing Enable
     */
    inline void clear_C0_WE() volatile
    {
        C0 &= ~(1u << 14u);
    }

    /**
     * Toggle C0's WE bit.
     *
     * Windowing Enable
     */
    inline void toggle_C0_WE() volatile
    {
        C0 ^= 1u << 14u;
    }

    /**
     * Get C0's PMODE bit.
     *
     * Power Mode Select
     */
    inline bool get_C0_PMODE() volatile
    {
        return C0 & (1u << 12u);
    }

    /**
     * Set C0's PMODE bit.
     *
     * Power Mode Select
     */
    inline void set_C0_PMODE() volatile
    {
        C0 |= 1u << 12u;
    }

    /**
     * Clear C0's PMODE bit.
     *
     * Power Mode Select
     */
    inline void clear_C0_PMODE() volatile
    {
        C0 &= ~(1u << 12u);
    }

    /**
     * Toggle C0's PMODE bit.
     *
     * Power Mode Select
     */
    inline void toggle_C0_PMODE() volatile
    {
        C0 ^= 1u << 12u;
    }

    /**
     * Get C0's INVT bit.
     *
     * Comparator invert
     */
    inline bool get_C0_INVT() volatile
    {
        return C0 & (1u << 11u);
    }

    /**
     * Set C0's INVT bit.
     *
     * Comparator invert
     */
    inline void set_C0_INVT() volatile
    {
        C0 |= 1u << 11u;
    }

    /**
     * Clear C0's INVT bit.
     *
     * Comparator invert
     */
    inline void clear_C0_INVT() volatile
    {
        C0 &= ~(1u << 11u);
    }

    /**
     * Toggle C0's INVT bit.
     *
     * Comparator invert
     */
    inline void toggle_C0_INVT() volatile
    {
        C0 ^= 1u << 11u;
    }

    /**
     * Get C0's COS bit.
     *
     * Comparator Output Select
     */
    inline bool get_C0_COS() volatile
    {
        return C0 & (1u << 10u);
    }

    /**
     * Set C0's COS bit.
     *
     * Comparator Output Select
     */
    inline void set_C0_COS() volatile
    {
        C0 |= 1u << 10u;
    }

    /**
     * Clear C0's COS bit.
     *
     * Comparator Output Select
     */
    inline void clear_C0_COS() volatile
    {
        C0 &= ~(1u << 10u);
    }

    /**
     * Toggle C0's COS bit.
     *
     * Comparator Output Select
     */
    inline void toggle_C0_COS() volatile
    {
        C0 ^= 1u << 10u;
    }

    /**
     * Get C0's OPE bit.
     *
     * Comparator Output Pin Enable
     */
    inline bool get_C0_OPE() volatile
    {
        return C0 & (1u << 9u);
    }

    /**
     * Set C0's OPE bit.
     *
     * Comparator Output Pin Enable
     */
    inline void set_C0_OPE() volatile
    {
        C0 |= 1u << 9u;
    }

    /**
     * Clear C0's OPE bit.
     *
     * Comparator Output Pin Enable
     */
    inline void clear_C0_OPE() volatile
    {
        C0 &= ~(1u << 9u);
    }

    /**
     * Toggle C0's OPE bit.
     *
     * Comparator Output Pin Enable
     */
    inline void toggle_C0_OPE() volatile
    {
        C0 ^= 1u << 9u;
    }

    /**
     * Get C0's EN bit.
     *
     * Comparator Module Enable
     */
    inline bool get_C0_EN() volatile
    {
        return C0 & (1u << 8u);
    }

    /**
     * Set C0's EN bit.
     *
     * Comparator Module Enable
     */
    inline void set_C0_EN() volatile
    {
        C0 |= 1u << 8u;
    }

    /**
     * Clear C0's EN bit.
     *
     * Comparator Module Enable
     */
    inline void clear_C0_EN() volatile
    {
        C0 &= ~(1u << 8u);
    }

    /**
     * Toggle C0's EN bit.
     *
     * Comparator Module Enable
     */
    inline void toggle_C0_EN() volatile
    {
        C0 ^= 1u << 8u;
    }

    /**
     * Get C0's FILTER_CNT field.
     *
     * Filter Sample Count
     */
    inline CMP1_C0_FILTER_CNT get_C0_FILTER_CNT() volatile
    {
        return CMP1_C0_FILTER_CNT((C0 >> 4u) & 0b111u);
    }

    /**
     * Set C0's FILTER_CNT field.
     *
     * Filter Sample Count
     */
    inline void set_C0_FILTER_CNT(CMP1_C0_FILTER_CNT value) volatile
    {
        uint32_t curr = C0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        C0 = curr;
    }

    /**
     * Get C0's HYSTCTR field.
     *
     * Comparator hard block hysteresis control. See chip data sheet to get the
     * actual hystersis value with each level
     */
    inline CMP1_C0_HYSTCTR get_C0_HYSTCTR() volatile
    {
        return CMP1_C0_HYSTCTR((C0 >> 0u) & 0b11u);
    }

    /**
     * Set C0's HYSTCTR field.
     *
     * Comparator hard block hysteresis control. See chip data sheet to get the
     * actual hystersis value with each level
     */
    inline void set_C0_HYSTCTR(CMP1_C0_HYSTCTR value) volatile
    {
        uint32_t curr = C0;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        C0 = curr;
    }

    /**
     * Get all of C0's bit fields.
     *
     * (read-write) CMP Control Register 0
     */
    inline void get_C0(bool &LINKEN, bool &DMAEN, bool &IER, bool &IEF,
                       bool &CFR, bool &CFF, bool &COUT, uint8_t &FPR,
                       bool &SE, bool &WE, bool &PMODE, bool &INVT, bool &COS,
                       bool &OPE, bool &EN, CMP1_C0_FILTER_CNT &FILTER_CNT,
                       CMP1_C0_HYSTCTR &HYSTCTR) volatile
    {
        uint32_t curr = C0;

        LINKEN = curr & (1u << 31u);
        DMAEN = curr & (1u << 30u);
        IER = curr & (1u << 28u);
        IEF = curr & (1u << 27u);
        CFR = curr & (1u << 26u);
        CFF = curr & (1u << 25u);
        COUT = curr & (1u << 24u);
        FPR = (curr >> 16u) & 0b11111111u;
        SE = curr & (1u << 15u);
        WE = curr & (1u << 14u);
        PMODE = curr & (1u << 12u);
        INVT = curr & (1u << 11u);
        COS = curr & (1u << 10u);
        OPE = curr & (1u << 9u);
        EN = curr & (1u << 8u);
        FILTER_CNT = CMP1_C0_FILTER_CNT((curr >> 4u) & 0b111u);
        HYSTCTR = CMP1_C0_HYSTCTR((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of C0's bit fields.
     *
     * (read-write) CMP Control Register 0
     */
    inline void set_C0(bool LINKEN, bool DMAEN, bool IER, bool IEF, bool CFR,
                       bool CFF, uint8_t FPR, bool SE, bool WE, bool PMODE,
                       bool INVT, bool COS, bool OPE, bool EN,
                       CMP1_C0_FILTER_CNT FILTER_CNT,
                       CMP1_C0_HYSTCTR HYSTCTR) volatile
    {
        uint32_t curr = C0;

        curr &= ~(0b1u << 31u);
        curr |= (LINKEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (DMAEN & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (IER & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (IEF & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (CFR & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (CFF & 0b1u) << 25u;
        curr &= ~(0b11111111u << 16u);
        curr |= (FPR & 0b11111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (SE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (WE & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (PMODE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (INVT & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (COS & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (OPE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (EN & 0b1u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(FILTER_CNT) & 0b111u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(HYSTCTR) & 0b11u) << 0u;

        C0 = curr;
    }

    /**
     * Get C1's PSEL field.
     *
     * Plus Input MUX Control
     */
    inline CMP1_C1_PSEL get_C1_PSEL() volatile
    {
        return CMP1_C1_PSEL((C1 >> 28u) & 0b111u);
    }

    /**
     * Set C1's PSEL field.
     *
     * Plus Input MUX Control
     */
    inline void set_C1_PSEL(CMP1_C1_PSEL value) volatile
    {
        uint32_t curr = C1;

        curr &= ~(0b111u << 28u);
        curr |= (std::to_underlying(value) & 0b111u) << 28u;

        C1 = curr;
    }

    /**
     * Get C1's MSEL field.
     *
     * Minus Input MUX Control
     */
    inline CMP1_C1_MSEL get_C1_MSEL() volatile
    {
        return CMP1_C1_MSEL((C1 >> 24u) & 0b111u);
    }

    /**
     * Set C1's MSEL field.
     *
     * Minus Input MUX Control
     */
    inline void set_C1_MSEL(CMP1_C1_MSEL value) volatile
    {
        uint32_t curr = C1;

        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(value) & 0b111u) << 24u;

        C1 = curr;
    }

    /**
     * Get C1's CHN5 bit.
     *
     * Channel 5 input enable
     */
    inline bool get_C1_CHN5() volatile
    {
        return C1 & (1u << 21u);
    }

    /**
     * Set C1's CHN5 bit.
     *
     * Channel 5 input enable
     */
    inline void set_C1_CHN5() volatile
    {
        C1 |= 1u << 21u;
    }

    /**
     * Clear C1's CHN5 bit.
     *
     * Channel 5 input enable
     */
    inline void clear_C1_CHN5() volatile
    {
        C1 &= ~(1u << 21u);
    }

    /**
     * Toggle C1's CHN5 bit.
     *
     * Channel 5 input enable
     */
    inline void toggle_C1_CHN5() volatile
    {
        C1 ^= 1u << 21u;
    }

    /**
     * Get C1's CHN4 bit.
     *
     * Channel 4 input enable
     */
    inline bool get_C1_CHN4() volatile
    {
        return C1 & (1u << 20u);
    }

    /**
     * Set C1's CHN4 bit.
     *
     * Channel 4 input enable
     */
    inline void set_C1_CHN4() volatile
    {
        C1 |= 1u << 20u;
    }

    /**
     * Clear C1's CHN4 bit.
     *
     * Channel 4 input enable
     */
    inline void clear_C1_CHN4() volatile
    {
        C1 &= ~(1u << 20u);
    }

    /**
     * Toggle C1's CHN4 bit.
     *
     * Channel 4 input enable
     */
    inline void toggle_C1_CHN4() volatile
    {
        C1 ^= 1u << 20u;
    }

    /**
     * Get C1's CHN3 bit.
     *
     * Channel 3 input enable
     */
    inline bool get_C1_CHN3() volatile
    {
        return C1 & (1u << 19u);
    }

    /**
     * Set C1's CHN3 bit.
     *
     * Channel 3 input enable
     */
    inline void set_C1_CHN3() volatile
    {
        C1 |= 1u << 19u;
    }

    /**
     * Clear C1's CHN3 bit.
     *
     * Channel 3 input enable
     */
    inline void clear_C1_CHN3() volatile
    {
        C1 &= ~(1u << 19u);
    }

    /**
     * Toggle C1's CHN3 bit.
     *
     * Channel 3 input enable
     */
    inline void toggle_C1_CHN3() volatile
    {
        C1 ^= 1u << 19u;
    }

    /**
     * Get C1's CHN2 bit.
     *
     * Channel 2 input enable
     */
    inline bool get_C1_CHN2() volatile
    {
        return C1 & (1u << 18u);
    }

    /**
     * Set C1's CHN2 bit.
     *
     * Channel 2 input enable
     */
    inline void set_C1_CHN2() volatile
    {
        C1 |= 1u << 18u;
    }

    /**
     * Clear C1's CHN2 bit.
     *
     * Channel 2 input enable
     */
    inline void clear_C1_CHN2() volatile
    {
        C1 &= ~(1u << 18u);
    }

    /**
     * Toggle C1's CHN2 bit.
     *
     * Channel 2 input enable
     */
    inline void toggle_C1_CHN2() volatile
    {
        C1 ^= 1u << 18u;
    }

    /**
     * Get C1's CHN1 bit.
     *
     * Channel 1 input enable
     */
    inline bool get_C1_CHN1() volatile
    {
        return C1 & (1u << 17u);
    }

    /**
     * Set C1's CHN1 bit.
     *
     * Channel 1 input enable
     */
    inline void set_C1_CHN1() volatile
    {
        C1 |= 1u << 17u;
    }

    /**
     * Clear C1's CHN1 bit.
     *
     * Channel 1 input enable
     */
    inline void clear_C1_CHN1() volatile
    {
        C1 &= ~(1u << 17u);
    }

    /**
     * Toggle C1's CHN1 bit.
     *
     * Channel 1 input enable
     */
    inline void toggle_C1_CHN1() volatile
    {
        C1 ^= 1u << 17u;
    }

    /**
     * Get C1's CHN0 bit.
     *
     * Channel 0 input enable
     */
    inline bool get_C1_CHN0() volatile
    {
        return C1 & (1u << 16u);
    }

    /**
     * Set C1's CHN0 bit.
     *
     * Channel 0 input enable
     */
    inline void set_C1_CHN0() volatile
    {
        C1 |= 1u << 16u;
    }

    /**
     * Clear C1's CHN0 bit.
     *
     * Channel 0 input enable
     */
    inline void clear_C1_CHN0() volatile
    {
        C1 &= ~(1u << 16u);
    }

    /**
     * Toggle C1's CHN0 bit.
     *
     * Channel 0 input enable
     */
    inline void toggle_C1_CHN0() volatile
    {
        C1 ^= 1u << 16u;
    }

    /**
     * Get C1's DACEN bit.
     *
     * DAC Enable
     */
    inline bool get_C1_DACEN() volatile
    {
        return C1 & (1u << 10u);
    }

    /**
     * Set C1's DACEN bit.
     *
     * DAC Enable
     */
    inline void set_C1_DACEN() volatile
    {
        C1 |= 1u << 10u;
    }

    /**
     * Clear C1's DACEN bit.
     *
     * DAC Enable
     */
    inline void clear_C1_DACEN() volatile
    {
        C1 &= ~(1u << 10u);
    }

    /**
     * Toggle C1's DACEN bit.
     *
     * DAC Enable
     */
    inline void toggle_C1_DACEN() volatile
    {
        C1 ^= 1u << 10u;
    }

    /**
     * Get C1's VRSEL bit.
     *
     * Supply Voltage Reference Source Select
     */
    inline bool get_C1_VRSEL() volatile
    {
        return C1 & (1u << 9u);
    }

    /**
     * Set C1's VRSEL bit.
     *
     * Supply Voltage Reference Source Select
     */
    inline void set_C1_VRSEL() volatile
    {
        C1 |= 1u << 9u;
    }

    /**
     * Clear C1's VRSEL bit.
     *
     * Supply Voltage Reference Source Select
     */
    inline void clear_C1_VRSEL() volatile
    {
        C1 &= ~(1u << 9u);
    }

    /**
     * Toggle C1's VRSEL bit.
     *
     * Supply Voltage Reference Source Select
     */
    inline void toggle_C1_VRSEL() volatile
    {
        C1 ^= 1u << 9u;
    }

    /**
     * Get C1's DMODE bit.
     *
     * DAC Mode Selection
     */
    inline bool get_C1_DMODE() volatile
    {
        return C1 & (1u << 8u);
    }

    /**
     * Set C1's DMODE bit.
     *
     * DAC Mode Selection
     */
    inline void set_C1_DMODE() volatile
    {
        C1 |= 1u << 8u;
    }

    /**
     * Clear C1's DMODE bit.
     *
     * DAC Mode Selection
     */
    inline void clear_C1_DMODE() volatile
    {
        C1 &= ~(1u << 8u);
    }

    /**
     * Toggle C1's DMODE bit.
     *
     * DAC Mode Selection
     */
    inline void toggle_C1_DMODE() volatile
    {
        C1 ^= 1u << 8u;
    }

    /**
     * Get C1's VOSEL field.
     *
     * DAC Output Voltage Select
     */
    inline uint8_t get_C1_VOSEL() volatile
    {
        return (C1 >> 0u) & 0b11111111u;
    }

    /**
     * Set C1's VOSEL field.
     *
     * DAC Output Voltage Select
     */
    inline void set_C1_VOSEL(uint8_t value) volatile
    {
        uint32_t curr = C1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        C1 = curr;
    }

    /**
     * Get all of C1's bit fields.
     *
     * (read-write) CMP Control Register 1
     */
    inline void get_C1(CMP1_C1_PSEL &PSEL, CMP1_C1_MSEL &MSEL, bool &CHN5,
                       bool &CHN4, bool &CHN3, bool &CHN2, bool &CHN1,
                       bool &CHN0, bool &DACEN, bool &VRSEL, bool &DMODE,
                       uint8_t &VOSEL) volatile
    {
        uint32_t curr = C1;

        PSEL = CMP1_C1_PSEL((curr >> 28u) & 0b111u);
        MSEL = CMP1_C1_MSEL((curr >> 24u) & 0b111u);
        CHN5 = curr & (1u << 21u);
        CHN4 = curr & (1u << 20u);
        CHN3 = curr & (1u << 19u);
        CHN2 = curr & (1u << 18u);
        CHN1 = curr & (1u << 17u);
        CHN0 = curr & (1u << 16u);
        DACEN = curr & (1u << 10u);
        VRSEL = curr & (1u << 9u);
        DMODE = curr & (1u << 8u);
        VOSEL = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of C1's bit fields.
     *
     * (read-write) CMP Control Register 1
     */
    inline void set_C1(CMP1_C1_PSEL PSEL, CMP1_C1_MSEL MSEL, bool CHN5,
                       bool CHN4, bool CHN3, bool CHN2, bool CHN1, bool CHN0,
                       bool DACEN, bool VRSEL, bool DMODE,
                       uint8_t VOSEL) volatile
    {
        uint32_t curr = C1;

        curr &= ~(0b111u << 28u);
        curr |= (std::to_underlying(PSEL) & 0b111u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (std::to_underlying(MSEL) & 0b111u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (CHN5 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (CHN4 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CHN3 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (CHN2 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (CHN1 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (CHN0 & 0b1u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (DACEN & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (VRSEL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (DMODE & 0b1u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (VOSEL & 0b11111111u) << 0u;

        C1 = curr;
    }

    /**
     * Get C2's RRIE bit.
     *
     * Round-Robin interrupt enable
     */
    inline bool get_C2_RRIE() volatile
    {
        return C2 & (1u << 30u);
    }

    /**
     * Set C2's RRIE bit.
     *
     * Round-Robin interrupt enable
     */
    inline void set_C2_RRIE() volatile
    {
        C2 |= 1u << 30u;
    }

    /**
     * Clear C2's RRIE bit.
     *
     * Round-Robin interrupt enable
     */
    inline void clear_C2_RRIE() volatile
    {
        C2 &= ~(1u << 30u);
    }

    /**
     * Toggle C2's RRIE bit.
     *
     * Round-Robin interrupt enable
     */
    inline void toggle_C2_RRIE() volatile
    {
        C2 ^= 1u << 30u;
    }

    /**
     * Get C2's FXMP bit.
     *
     * Fixed MUX Port
     */
    inline bool get_C2_FXMP() volatile
    {
        return C2 & (1u << 29u);
    }

    /**
     * Set C2's FXMP bit.
     *
     * Fixed MUX Port
     */
    inline void set_C2_FXMP() volatile
    {
        C2 |= 1u << 29u;
    }

    /**
     * Clear C2's FXMP bit.
     *
     * Fixed MUX Port
     */
    inline void clear_C2_FXMP() volatile
    {
        C2 &= ~(1u << 29u);
    }

    /**
     * Toggle C2's FXMP bit.
     *
     * Fixed MUX Port
     */
    inline void toggle_C2_FXMP() volatile
    {
        C2 ^= 1u << 29u;
    }

    /**
     * Get C2's FXMXCH field.
     *
     * Fixed channel selection
     */
    inline CMP1_C2_FXMXCH get_C2_FXMXCH() volatile
    {
        return CMP1_C2_FXMXCH((C2 >> 25u) & 0b111u);
    }

    /**
     * Set C2's FXMXCH field.
     *
     * Fixed channel selection
     */
    inline void set_C2_FXMXCH(CMP1_C2_FXMXCH value) volatile
    {
        uint32_t curr = C2;

        curr &= ~(0b111u << 25u);
        curr |= (std::to_underlying(value) & 0b111u) << 25u;

        C2 = curr;
    }

    /**
     * Get C2's CH5F bit.
     *
     * CH5F
     */
    inline bool get_C2_CH5F() volatile
    {
        return C2 & (1u << 21u);
    }

    /**
     * Set C2's CH5F bit.
     *
     * CH5F
     */
    inline void set_C2_CH5F() volatile
    {
        C2 |= 1u << 21u;
    }

    /**
     * Clear C2's CH5F bit.
     *
     * CH5F
     */
    inline void clear_C2_CH5F() volatile
    {
        C2 &= ~(1u << 21u);
    }

    /**
     * Toggle C2's CH5F bit.
     *
     * CH5F
     */
    inline void toggle_C2_CH5F() volatile
    {
        C2 ^= 1u << 21u;
    }

    /**
     * Get C2's CH4F bit.
     *
     * CH4F
     */
    inline bool get_C2_CH4F() volatile
    {
        return C2 & (1u << 20u);
    }

    /**
     * Set C2's CH4F bit.
     *
     * CH4F
     */
    inline void set_C2_CH4F() volatile
    {
        C2 |= 1u << 20u;
    }

    /**
     * Clear C2's CH4F bit.
     *
     * CH4F
     */
    inline void clear_C2_CH4F() volatile
    {
        C2 &= ~(1u << 20u);
    }

    /**
     * Toggle C2's CH4F bit.
     *
     * CH4F
     */
    inline void toggle_C2_CH4F() volatile
    {
        C2 ^= 1u << 20u;
    }

    /**
     * Get C2's CH3F bit.
     *
     * CH3F
     */
    inline bool get_C2_CH3F() volatile
    {
        return C2 & (1u << 19u);
    }

    /**
     * Set C2's CH3F bit.
     *
     * CH3F
     */
    inline void set_C2_CH3F() volatile
    {
        C2 |= 1u << 19u;
    }

    /**
     * Clear C2's CH3F bit.
     *
     * CH3F
     */
    inline void clear_C2_CH3F() volatile
    {
        C2 &= ~(1u << 19u);
    }

    /**
     * Toggle C2's CH3F bit.
     *
     * CH3F
     */
    inline void toggle_C2_CH3F() volatile
    {
        C2 ^= 1u << 19u;
    }

    /**
     * Get C2's CH2F bit.
     *
     * CH2F
     */
    inline bool get_C2_CH2F() volatile
    {
        return C2 & (1u << 18u);
    }

    /**
     * Set C2's CH2F bit.
     *
     * CH2F
     */
    inline void set_C2_CH2F() volatile
    {
        C2 |= 1u << 18u;
    }

    /**
     * Clear C2's CH2F bit.
     *
     * CH2F
     */
    inline void clear_C2_CH2F() volatile
    {
        C2 &= ~(1u << 18u);
    }

    /**
     * Toggle C2's CH2F bit.
     *
     * CH2F
     */
    inline void toggle_C2_CH2F() volatile
    {
        C2 ^= 1u << 18u;
    }

    /**
     * Get C2's CH1F bit.
     *
     * CH1F
     */
    inline bool get_C2_CH1F() volatile
    {
        return C2 & (1u << 17u);
    }

    /**
     * Set C2's CH1F bit.
     *
     * CH1F
     */
    inline void set_C2_CH1F() volatile
    {
        C2 |= 1u << 17u;
    }

    /**
     * Clear C2's CH1F bit.
     *
     * CH1F
     */
    inline void clear_C2_CH1F() volatile
    {
        C2 &= ~(1u << 17u);
    }

    /**
     * Toggle C2's CH1F bit.
     *
     * CH1F
     */
    inline void toggle_C2_CH1F() volatile
    {
        C2 ^= 1u << 17u;
    }

    /**
     * Get C2's CH0F bit.
     *
     * CH0F
     */
    inline bool get_C2_CH0F() volatile
    {
        return C2 & (1u << 16u);
    }

    /**
     * Set C2's CH0F bit.
     *
     * CH0F
     */
    inline void set_C2_CH0F() volatile
    {
        C2 |= 1u << 16u;
    }

    /**
     * Clear C2's CH0F bit.
     *
     * CH0F
     */
    inline void clear_C2_CH0F() volatile
    {
        C2 &= ~(1u << 16u);
    }

    /**
     * Toggle C2's CH0F bit.
     *
     * CH0F
     */
    inline void toggle_C2_CH0F() volatile
    {
        C2 ^= 1u << 16u;
    }

    /**
     * Get C2's NSAM field.
     *
     * Number of sample clocks
     */
    inline CMP1_C2_NSAM get_C2_NSAM() volatile
    {
        return CMP1_C2_NSAM((C2 >> 14u) & 0b11u);
    }

    /**
     * Set C2's NSAM field.
     *
     * Number of sample clocks
     */
    inline void set_C2_NSAM(CMP1_C2_NSAM value) volatile
    {
        uint32_t curr = C2;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        C2 = curr;
    }

    /**
     * Get C2's INITMOD field.
     *
     * Comparator and DAC initialization delay modulus.
     */
    inline uint8_t get_C2_INITMOD() volatile
    {
        return (C2 >> 8u) & 0b111111u;
    }

    /**
     * Set C2's INITMOD field.
     *
     * Comparator and DAC initialization delay modulus.
     */
    inline void set_C2_INITMOD(uint8_t value) volatile
    {
        uint32_t curr = C2;

        curr &= ~(0b111111u << 8u);
        curr |= (value & 0b111111u) << 8u;

        C2 = curr;
    }

    /**
     * Get C2's ACOn field.
     *
     * ACOn
     */
    inline uint8_t get_C2_ACOn() volatile
    {
        return (C2 >> 0u) & 0b111111u;
    }

    /**
     * Set C2's ACOn field.
     *
     * ACOn
     */
    inline void set_C2_ACOn(uint8_t value) volatile
    {
        uint32_t curr = C2;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        C2 = curr;
    }

    /**
     * Get all of C2's bit fields.
     *
     * (read-write) CMP Control Register 2
     */
    inline void get_C2(bool &RRIE, bool &FXMP, CMP1_C2_FXMXCH &FXMXCH,
                       bool &CH5F, bool &CH4F, bool &CH3F, bool &CH2F,
                       bool &CH1F, bool &CH0F, CMP1_C2_NSAM &NSAM,
                       uint8_t &INITMOD, uint8_t &ACOn) volatile
    {
        uint32_t curr = C2;

        RRIE = curr & (1u << 30u);
        FXMP = curr & (1u << 29u);
        FXMXCH = CMP1_C2_FXMXCH((curr >> 25u) & 0b111u);
        CH5F = curr & (1u << 21u);
        CH4F = curr & (1u << 20u);
        CH3F = curr & (1u << 19u);
        CH2F = curr & (1u << 18u);
        CH1F = curr & (1u << 17u);
        CH0F = curr & (1u << 16u);
        NSAM = CMP1_C2_NSAM((curr >> 14u) & 0b11u);
        INITMOD = (curr >> 8u) & 0b111111u;
        ACOn = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of C2's bit fields.
     *
     * (read-write) CMP Control Register 2
     */
    inline void set_C2(bool RRIE, bool FXMP, CMP1_C2_FXMXCH FXMXCH, bool CH5F,
                       bool CH4F, bool CH3F, bool CH2F, bool CH1F, bool CH0F,
                       CMP1_C2_NSAM NSAM, uint8_t INITMOD,
                       uint8_t ACOn) volatile
    {
        uint32_t curr = C2;

        curr &= ~(0b1u << 30u);
        curr |= (RRIE & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (FXMP & 0b1u) << 29u;
        curr &= ~(0b111u << 25u);
        curr |= (std::to_underlying(FXMXCH) & 0b111u) << 25u;
        curr &= ~(0b1u << 21u);
        curr |= (CH5F & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (CH4F & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (CH3F & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (CH2F & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (CH1F & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (CH0F & 0b1u) << 16u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(NSAM) & 0b11u) << 14u;
        curr &= ~(0b111111u << 8u);
        curr |= (INITMOD & 0b111111u) << 8u;
        curr &= ~(0b111111u << 0u);
        curr |= (ACOn & 0b111111u) << 0u;

        C2 = curr;
    }

    /**
     * Get C3's PCHCTEN bit.
     *
     * Positive Channel Continuous Mode Enable.
     */
    inline bool get_C3_PCHCTEN() volatile
    {
        return C3 & (1u << 28u);
    }

    /**
     * Set C3's PCHCTEN bit.
     *
     * Positive Channel Continuous Mode Enable.
     */
    inline void set_C3_PCHCTEN() volatile
    {
        C3 |= 1u << 28u;
    }

    /**
     * Clear C3's PCHCTEN bit.
     *
     * Positive Channel Continuous Mode Enable.
     */
    inline void clear_C3_PCHCTEN() volatile
    {
        C3 &= ~(1u << 28u);
    }

    /**
     * Toggle C3's PCHCTEN bit.
     *
     * Positive Channel Continuous Mode Enable.
     */
    inline void toggle_C3_PCHCTEN() volatile
    {
        C3 ^= 1u << 28u;
    }

    /**
     * Get C3's NCHCTEN bit.
     *
     * Negative Channel Continuous Mode Enable.
     */
    inline bool get_C3_NCHCTEN() volatile
    {
        return C3 & (1u << 24u);
    }

    /**
     * Set C3's NCHCTEN bit.
     *
     * Negative Channel Continuous Mode Enable.
     */
    inline void set_C3_NCHCTEN() volatile
    {
        C3 |= 1u << 24u;
    }

    /**
     * Clear C3's NCHCTEN bit.
     *
     * Negative Channel Continuous Mode Enable.
     */
    inline void clear_C3_NCHCTEN() volatile
    {
        C3 &= ~(1u << 24u);
    }

    /**
     * Toggle C3's NCHCTEN bit.
     *
     * Negative Channel Continuous Mode Enable.
     */
    inline void toggle_C3_NCHCTEN() volatile
    {
        C3 ^= 1u << 24u;
    }

    /**
     * Get C3's RDIVE bit.
     *
     * Resistor Divider Enable
     */
    inline bool get_C3_RDIVE() volatile
    {
        return C3 & (1u << 20u);
    }

    /**
     * Set C3's RDIVE bit.
     *
     * Resistor Divider Enable
     */
    inline void set_C3_RDIVE() volatile
    {
        C3 |= 1u << 20u;
    }

    /**
     * Clear C3's RDIVE bit.
     *
     * Resistor Divider Enable
     */
    inline void clear_C3_RDIVE() volatile
    {
        C3 &= ~(1u << 20u);
    }

    /**
     * Toggle C3's RDIVE bit.
     *
     * Resistor Divider Enable
     */
    inline void toggle_C3_RDIVE() volatile
    {
        C3 ^= 1u << 20u;
    }

    /**
     * Get C3's DMCS bit.
     *
     * Discrete Mode Clock Selection
     */
    inline bool get_C3_DMCS() volatile
    {
        return C3 & (1u << 16u);
    }

    /**
     * Set C3's DMCS bit.
     *
     * Discrete Mode Clock Selection
     */
    inline void set_C3_DMCS() volatile
    {
        C3 |= 1u << 16u;
    }

    /**
     * Clear C3's DMCS bit.
     *
     * Discrete Mode Clock Selection
     */
    inline void clear_C3_DMCS() volatile
    {
        C3 &= ~(1u << 16u);
    }

    /**
     * Toggle C3's DMCS bit.
     *
     * Discrete Mode Clock Selection
     */
    inline void toggle_C3_DMCS() volatile
    {
        C3 ^= 1u << 16u;
    }

    /**
     * Get C3's ACSAT field.
     *
     * Analog Comparator Sampling Time control.
     */
    inline CMP1_C3_ACSAT get_C3_ACSAT() volatile
    {
        return CMP1_C3_ACSAT((C3 >> 12u) & 0b111u);
    }

    /**
     * Set C3's ACSAT field.
     *
     * Analog Comparator Sampling Time control.
     */
    inline void set_C3_ACSAT(CMP1_C3_ACSAT value) volatile
    {
        uint32_t curr = C3;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        C3 = curr;
    }

    /**
     * Get C3's ACPH1TC field.
     *
     * Analog Comparator Phase1 Timing Control.
     */
    inline CMP1_C3_ACPH1TC get_C3_ACPH1TC() volatile
    {
        return CMP1_C3_ACPH1TC((C3 >> 8u) & 0b111u);
    }

    /**
     * Set C3's ACPH1TC field.
     *
     * Analog Comparator Phase1 Timing Control.
     */
    inline void set_C3_ACPH1TC(CMP1_C3_ACPH1TC value) volatile
    {
        uint32_t curr = C3;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        C3 = curr;
    }

    /**
     * Get C3's ACPH2TC field.
     *
     * Analog Comparator Phase2 Timing Control.
     */
    inline CMP1_C3_ACPH2TC get_C3_ACPH2TC() volatile
    {
        return CMP1_C3_ACPH2TC((C3 >> 4u) & 0b111u);
    }

    /**
     * Set C3's ACPH2TC field.
     *
     * Analog Comparator Phase2 Timing Control.
     */
    inline void set_C3_ACPH2TC(CMP1_C3_ACPH2TC value) volatile
    {
        uint32_t curr = C3;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        C3 = curr;
    }

    /**
     * Get all of C3's bit fields.
     *
     * (read-write) CMP Control Register 3
     */
    inline void get_C3(bool &PCHCTEN, bool &NCHCTEN, bool &RDIVE, bool &DMCS,
                       CMP1_C3_ACSAT &ACSAT, CMP1_C3_ACPH1TC &ACPH1TC,
                       CMP1_C3_ACPH2TC &ACPH2TC) volatile
    {
        uint32_t curr = C3;

        PCHCTEN = curr & (1u << 28u);
        NCHCTEN = curr & (1u << 24u);
        RDIVE = curr & (1u << 20u);
        DMCS = curr & (1u << 16u);
        ACSAT = CMP1_C3_ACSAT((curr >> 12u) & 0b111u);
        ACPH1TC = CMP1_C3_ACPH1TC((curr >> 8u) & 0b111u);
        ACPH2TC = CMP1_C3_ACPH2TC((curr >> 4u) & 0b111u);
    }

    /**
     * Set all of C3's bit fields.
     *
     * (read-write) CMP Control Register 3
     */
    inline void set_C3(bool PCHCTEN, bool NCHCTEN, bool RDIVE, bool DMCS,
                       CMP1_C3_ACSAT ACSAT, CMP1_C3_ACPH1TC ACPH1TC,
                       CMP1_C3_ACPH2TC ACPH2TC) volatile
    {
        uint32_t curr = C3;

        curr &= ~(0b1u << 28u);
        curr |= (PCHCTEN & 0b1u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (NCHCTEN & 0b1u) << 24u;
        curr &= ~(0b1u << 20u);
        curr |= (RDIVE & 0b1u) << 20u;
        curr &= ~(0b1u << 16u);
        curr |= (DMCS & 0b1u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(ACSAT) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(ACPH1TC) & 0b111u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(ACPH2TC) & 0b111u) << 4u;

        C3 = curr;
    }
};

static_assert(sizeof(cmp1) == cmp1::size);

static volatile cmp1 *const CMP1 = reinterpret_cast<cmp1 *>(0x401A4000);

static volatile cmp1 *const CMP2 = reinterpret_cast<cmp1 *>(0x401A8000);

static volatile cmp1 *const CMP3 = reinterpret_cast<cmp1 *>(0x401AC000);

static volatile cmp1 *const CMP4 = reinterpret_cast<cmp1 *>(0x401B0000);

}; // namespace MIMXRT1176::CM7
