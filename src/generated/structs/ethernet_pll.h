/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/ETHERNET_PLL_CTRL0_POST_DIV_SEL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * Fractional PLL
 */
struct [[gnu::packed]] ethernet_pll
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        64; /*!< ethernet_pll's size in bytes. */

    /* Fields. */
    uint32_t CTRL0;     /*!< (read-write) Fractional PLL Control Register */
    uint32_t CTRL0_SET; /*!< (read-write) Fractional PLL Control Register */
    uint32_t CTRL0_CLR; /*!< (read-write) Fractional PLL Control Register */
    uint32_t CTRL0_TOG; /*!< (read-write) Fractional PLL Control Register */
    uint32_t SPREAD_SPECTRUM; /*!< (read-write) Fractional PLL Spread Spectrum
                                 Control Register */
    uint32_t SPREAD_SPECTRUM_SET; /*!< (read-write) Fractional PLL Spread
                                     Spectrum Control Register */
    uint32_t SPREAD_SPECTRUM_CLR; /*!< (read-write) Fractional PLL Spread
                                     Spectrum Control Register */
    uint32_t SPREAD_SPECTRUM_TOG; /*!< (read-write) Fractional PLL Spread
                                     Spectrum Control Register */
    uint32_t NUMERATOR;     /*!< (read-write) Fractional PLL Numerator Control
                               Register */
    uint32_t NUMERATOR_SET; /*!< (read-write) Fractional PLL Numerator Control
                               Register */
    uint32_t NUMERATOR_CLR; /*!< (read-write) Fractional PLL Numerator Control
                               Register */
    uint32_t NUMERATOR_TOG; /*!< (read-write) Fractional PLL Numerator Control
                               Register */
    uint32_t DENOMINATOR; /*!< (read-write) Fractional PLL Denominator Control
                             Register */
    uint32_t DENOMINATOR_SET; /*!< (read-write) Fractional PLL Denominator
                                 Control Register */
    uint32_t DENOMINATOR_CLR; /*!< (read-write) Fractional PLL Denominator
                                 Control Register */
    uint32_t DENOMINATOR_TOG; /*!< (read-write) Fractional PLL Denominator
                                 Control Register */

    /* Methods. */

    /**
     * Get CTRL0's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline bool get_CTRL0_BIAS_SELECT() volatile
    {
        return CTRL0 & (1u << 29u);
    }

    /**
     * Set CTRL0's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void set_CTRL0_BIAS_SELECT() volatile
    {
        CTRL0 |= 1u << 29u;
    }

    /**
     * Clear CTRL0's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void clear_CTRL0_BIAS_SELECT() volatile
    {
        CTRL0 &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL0's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void toggle_CTRL0_BIAS_SELECT() volatile
    {
        CTRL0 ^= 1u << 29u;
    }

    /**
     * Get CTRL0's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline ETHERNET_PLL_CTRL0_POST_DIV_SEL get_CTRL0_POST_DIV_SEL() volatile
    {
        return ETHERNET_PLL_CTRL0_POST_DIV_SEL((CTRL0 >> 25u) & 0b111u);
    }

    /**
     * Set CTRL0's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline void set_CTRL0_POST_DIV_SEL(
        ETHERNET_PLL_CTRL0_POST_DIV_SEL value) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b111u << 25u);
        curr |= (std::to_underlying(value) & 0b111u) << 25u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline bool get_CTRL0_PLL_REG_EN() volatile
    {
        return CTRL0 & (1u << 22u);
    }

    /**
     * Set CTRL0's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void set_CTRL0_PLL_REG_EN() volatile
    {
        CTRL0 |= 1u << 22u;
    }

    /**
     * Clear CTRL0's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void clear_CTRL0_PLL_REG_EN() volatile
    {
        CTRL0 &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL0's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void toggle_CTRL0_PLL_REG_EN() volatile
    {
        CTRL0 ^= 1u << 22u;
    }

    /**
     * Get CTRL0's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline uint8_t get_CTRL0_BIAS_TRIM() volatile
    {
        return (CTRL0 >> 19u) & 0b111u;
    }

    /**
     * Set CTRL0's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline void set_CTRL0_BIAS_TRIM(uint8_t value) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline bool get_CTRL0_DITHER_EN() volatile
    {
        return CTRL0 & (1u << 17u);
    }

    /**
     * Set CTRL0's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void set_CTRL0_DITHER_EN() volatile
    {
        CTRL0 |= 1u << 17u;
    }

    /**
     * Clear CTRL0's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void clear_CTRL0_DITHER_EN() volatile
    {
        CTRL0 &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL0's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void toggle_CTRL0_DITHER_EN() volatile
    {
        CTRL0 ^= 1u << 17u;
    }

    /**
     * Get CTRL0's BYPASS bit.
     *
     * BYPASS
     */
    inline bool get_CTRL0_BYPASS() volatile
    {
        return CTRL0 & (1u << 16u);
    }

    /**
     * Set CTRL0's BYPASS bit.
     *
     * BYPASS
     */
    inline void set_CTRL0_BYPASS() volatile
    {
        CTRL0 |= 1u << 16u;
    }

    /**
     * Clear CTRL0's BYPASS bit.
     *
     * BYPASS
     */
    inline void clear_CTRL0_BYPASS() volatile
    {
        CTRL0 &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL0's BYPASS bit.
     *
     * BYPASS
     */
    inline void toggle_CTRL0_BYPASS() volatile
    {
        CTRL0 ^= 1u << 16u;
    }

    /**
     * Get CTRL0's ENABLE bit.
     *
     * ENABLE
     */
    inline bool get_CTRL0_ENABLE() volatile
    {
        return CTRL0 & (1u << 15u);
    }

    /**
     * Set CTRL0's ENABLE bit.
     *
     * ENABLE
     */
    inline void set_CTRL0_ENABLE() volatile
    {
        CTRL0 |= 1u << 15u;
    }

    /**
     * Clear CTRL0's ENABLE bit.
     *
     * ENABLE
     */
    inline void clear_CTRL0_ENABLE() volatile
    {
        CTRL0 &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL0's ENABLE bit.
     *
     * ENABLE
     */
    inline void toggle_CTRL0_ENABLE() volatile
    {
        CTRL0 ^= 1u << 15u;
    }

    /**
     * Get CTRL0's POWERUP bit.
     *
     * POWERUP
     */
    inline bool get_CTRL0_POWERUP() volatile
    {
        return CTRL0 & (1u << 14u);
    }

    /**
     * Set CTRL0's POWERUP bit.
     *
     * POWERUP
     */
    inline void set_CTRL0_POWERUP() volatile
    {
        CTRL0 |= 1u << 14u;
    }

    /**
     * Clear CTRL0's POWERUP bit.
     *
     * POWERUP
     */
    inline void clear_CTRL0_POWERUP() volatile
    {
        CTRL0 &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL0's POWERUP bit.
     *
     * POWERUP
     */
    inline void toggle_CTRL0_POWERUP() volatile
    {
        CTRL0 ^= 1u << 14u;
    }

    /**
     * Get CTRL0's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline bool get_CTRL0_HOLD_RING_OFF() volatile
    {
        return CTRL0 & (1u << 13u);
    }

    /**
     * Set CTRL0's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void set_CTRL0_HOLD_RING_OFF() volatile
    {
        CTRL0 |= 1u << 13u;
    }

    /**
     * Clear CTRL0's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void clear_CTRL0_HOLD_RING_OFF() volatile
    {
        CTRL0 &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL0's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void toggle_CTRL0_HOLD_RING_OFF() volatile
    {
        CTRL0 ^= 1u << 13u;
    }

    /**
     * Get CTRL0's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline bool get_CTRL0_ENABLE_ALT() volatile
    {
        return CTRL0 & (1u << 8u);
    }

    /**
     * Set CTRL0's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void set_CTRL0_ENABLE_ALT() volatile
    {
        CTRL0 |= 1u << 8u;
    }

    /**
     * Clear CTRL0's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void clear_CTRL0_ENABLE_ALT() volatile
    {
        CTRL0 &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL0's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void toggle_CTRL0_ENABLE_ALT() volatile
    {
        CTRL0 ^= 1u << 8u;
    }

    /**
     * Get CTRL0's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline uint8_t get_CTRL0_DIV_SELECT() volatile
    {
        return (CTRL0 >> 0u) & 0b1111111u;
    }

    /**
     * Set CTRL0's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline void set_CTRL0_DIV_SELECT(uint8_t value) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        CTRL0 = curr;
    }

    /**
     * Get all of CTRL0's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void get_CTRL0(bool &BIAS_SELECT,
                          ETHERNET_PLL_CTRL0_POST_DIV_SEL &POST_DIV_SEL,
                          bool &PLL_REG_EN, uint8_t &BIAS_TRIM,
                          bool &DITHER_EN, bool &BYPASS, bool &ENABLE,
                          bool &POWERUP, bool &HOLD_RING_OFF, bool &ENABLE_ALT,
                          uint8_t &DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0;

        BIAS_SELECT = curr & (1u << 29u);
        POST_DIV_SEL = ETHERNET_PLL_CTRL0_POST_DIV_SEL((curr >> 25u) & 0b111u);
        PLL_REG_EN = curr & (1u << 22u);
        BIAS_TRIM = (curr >> 19u) & 0b111u;
        DITHER_EN = curr & (1u << 17u);
        BYPASS = curr & (1u << 16u);
        ENABLE = curr & (1u << 15u);
        POWERUP = curr & (1u << 14u);
        HOLD_RING_OFF = curr & (1u << 13u);
        ENABLE_ALT = curr & (1u << 8u);
        DIV_SELECT = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of CTRL0's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void set_CTRL0(bool BIAS_SELECT,
                          ETHERNET_PLL_CTRL0_POST_DIV_SEL POST_DIV_SEL,
                          bool PLL_REG_EN, uint8_t BIAS_TRIM, bool DITHER_EN,
                          bool BYPASS, bool ENABLE, bool POWERUP,
                          bool HOLD_RING_OFF, bool ENABLE_ALT,
                          uint8_t DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b1u << 29u);
        curr |= (BIAS_SELECT & 0b1u) << 29u;
        curr &= ~(0b111u << 25u);
        curr |= (std::to_underlying(POST_DIV_SEL) & 0b111u) << 25u;
        curr &= ~(0b1u << 22u);
        curr |= (PLL_REG_EN & 0b1u) << 22u;
        curr &= ~(0b111u << 19u);
        curr |= (BIAS_TRIM & 0b111u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DITHER_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (POWERUP & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (HOLD_RING_OFF & 0b1u) << 13u;
        curr &= ~(0b1u << 8u);
        curr |= (ENABLE_ALT & 0b1u) << 8u;
        curr &= ~(0b1111111u << 0u);
        curr |= (DIV_SELECT & 0b1111111u) << 0u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0_SET's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline bool get_CTRL0_SET_BIAS_SELECT() volatile
    {
        return CTRL0_SET & (1u << 29u);
    }

    /**
     * Set CTRL0_SET's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void set_CTRL0_SET_BIAS_SELECT() volatile
    {
        CTRL0_SET |= 1u << 29u;
    }

    /**
     * Clear CTRL0_SET's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void clear_CTRL0_SET_BIAS_SELECT() volatile
    {
        CTRL0_SET &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL0_SET's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void toggle_CTRL0_SET_BIAS_SELECT() volatile
    {
        CTRL0_SET ^= 1u << 29u;
    }

    /**
     * Get CTRL0_SET's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline uint8_t get_CTRL0_SET_POST_DIV_SEL() volatile
    {
        return (CTRL0_SET >> 25u) & 0b111u;
    }

    /**
     * Set CTRL0_SET's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline void set_CTRL0_SET_POST_DIV_SEL(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_SET;

        curr &= ~(0b111u << 25u);
        curr |= (value & 0b111u) << 25u;

        CTRL0_SET = curr;
    }

    /**
     * Get CTRL0_SET's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline bool get_CTRL0_SET_PLL_REG_EN() volatile
    {
        return CTRL0_SET & (1u << 22u);
    }

    /**
     * Set CTRL0_SET's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void set_CTRL0_SET_PLL_REG_EN() volatile
    {
        CTRL0_SET |= 1u << 22u;
    }

    /**
     * Clear CTRL0_SET's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void clear_CTRL0_SET_PLL_REG_EN() volatile
    {
        CTRL0_SET &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL0_SET's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void toggle_CTRL0_SET_PLL_REG_EN() volatile
    {
        CTRL0_SET ^= 1u << 22u;
    }

    /**
     * Get CTRL0_SET's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline uint8_t get_CTRL0_SET_BIAS_TRIM() volatile
    {
        return (CTRL0_SET >> 19u) & 0b111u;
    }

    /**
     * Set CTRL0_SET's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline void set_CTRL0_SET_BIAS_TRIM(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_SET;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        CTRL0_SET = curr;
    }

    /**
     * Get CTRL0_SET's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline bool get_CTRL0_SET_DITHER_EN() volatile
    {
        return CTRL0_SET & (1u << 17u);
    }

    /**
     * Set CTRL0_SET's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void set_CTRL0_SET_DITHER_EN() volatile
    {
        CTRL0_SET |= 1u << 17u;
    }

    /**
     * Clear CTRL0_SET's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void clear_CTRL0_SET_DITHER_EN() volatile
    {
        CTRL0_SET &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL0_SET's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void toggle_CTRL0_SET_DITHER_EN() volatile
    {
        CTRL0_SET ^= 1u << 17u;
    }

    /**
     * Get CTRL0_SET's BYPASS bit.
     *
     * BYPASS
     */
    inline bool get_CTRL0_SET_BYPASS() volatile
    {
        return CTRL0_SET & (1u << 16u);
    }

    /**
     * Set CTRL0_SET's BYPASS bit.
     *
     * BYPASS
     */
    inline void set_CTRL0_SET_BYPASS() volatile
    {
        CTRL0_SET |= 1u << 16u;
    }

    /**
     * Clear CTRL0_SET's BYPASS bit.
     *
     * BYPASS
     */
    inline void clear_CTRL0_SET_BYPASS() volatile
    {
        CTRL0_SET &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL0_SET's BYPASS bit.
     *
     * BYPASS
     */
    inline void toggle_CTRL0_SET_BYPASS() volatile
    {
        CTRL0_SET ^= 1u << 16u;
    }

    /**
     * Get CTRL0_SET's ENABLE bit.
     *
     * ENABLE
     */
    inline bool get_CTRL0_SET_ENABLE() volatile
    {
        return CTRL0_SET & (1u << 15u);
    }

    /**
     * Set CTRL0_SET's ENABLE bit.
     *
     * ENABLE
     */
    inline void set_CTRL0_SET_ENABLE() volatile
    {
        CTRL0_SET |= 1u << 15u;
    }

    /**
     * Clear CTRL0_SET's ENABLE bit.
     *
     * ENABLE
     */
    inline void clear_CTRL0_SET_ENABLE() volatile
    {
        CTRL0_SET &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL0_SET's ENABLE bit.
     *
     * ENABLE
     */
    inline void toggle_CTRL0_SET_ENABLE() volatile
    {
        CTRL0_SET ^= 1u << 15u;
    }

    /**
     * Get CTRL0_SET's POWERUP bit.
     *
     * POWERUP
     */
    inline bool get_CTRL0_SET_POWERUP() volatile
    {
        return CTRL0_SET & (1u << 14u);
    }

    /**
     * Set CTRL0_SET's POWERUP bit.
     *
     * POWERUP
     */
    inline void set_CTRL0_SET_POWERUP() volatile
    {
        CTRL0_SET |= 1u << 14u;
    }

    /**
     * Clear CTRL0_SET's POWERUP bit.
     *
     * POWERUP
     */
    inline void clear_CTRL0_SET_POWERUP() volatile
    {
        CTRL0_SET &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL0_SET's POWERUP bit.
     *
     * POWERUP
     */
    inline void toggle_CTRL0_SET_POWERUP() volatile
    {
        CTRL0_SET ^= 1u << 14u;
    }

    /**
     * Get CTRL0_SET's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline bool get_CTRL0_SET_HOLD_RING_OFF() volatile
    {
        return CTRL0_SET & (1u << 13u);
    }

    /**
     * Set CTRL0_SET's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void set_CTRL0_SET_HOLD_RING_OFF() volatile
    {
        CTRL0_SET |= 1u << 13u;
    }

    /**
     * Clear CTRL0_SET's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void clear_CTRL0_SET_HOLD_RING_OFF() volatile
    {
        CTRL0_SET &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL0_SET's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void toggle_CTRL0_SET_HOLD_RING_OFF() volatile
    {
        CTRL0_SET ^= 1u << 13u;
    }

    /**
     * Get CTRL0_SET's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline bool get_CTRL0_SET_ENABLE_ALT() volatile
    {
        return CTRL0_SET & (1u << 8u);
    }

    /**
     * Set CTRL0_SET's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void set_CTRL0_SET_ENABLE_ALT() volatile
    {
        CTRL0_SET |= 1u << 8u;
    }

    /**
     * Clear CTRL0_SET's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void clear_CTRL0_SET_ENABLE_ALT() volatile
    {
        CTRL0_SET &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL0_SET's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void toggle_CTRL0_SET_ENABLE_ALT() volatile
    {
        CTRL0_SET ^= 1u << 8u;
    }

    /**
     * Get CTRL0_SET's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline uint8_t get_CTRL0_SET_DIV_SELECT() volatile
    {
        return (CTRL0_SET >> 0u) & 0b1111111u;
    }

    /**
     * Set CTRL0_SET's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline void set_CTRL0_SET_DIV_SELECT(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_SET;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        CTRL0_SET = curr;
    }

    /**
     * Get all of CTRL0_SET's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void get_CTRL0_SET(bool &BIAS_SELECT, uint8_t &POST_DIV_SEL,
                              bool &PLL_REG_EN, uint8_t &BIAS_TRIM,
                              bool &DITHER_EN, bool &BYPASS, bool &ENABLE,
                              bool &POWERUP, bool &HOLD_RING_OFF,
                              bool &ENABLE_ALT, uint8_t &DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0_SET;

        BIAS_SELECT = curr & (1u << 29u);
        POST_DIV_SEL = (curr >> 25u) & 0b111u;
        PLL_REG_EN = curr & (1u << 22u);
        BIAS_TRIM = (curr >> 19u) & 0b111u;
        DITHER_EN = curr & (1u << 17u);
        BYPASS = curr & (1u << 16u);
        ENABLE = curr & (1u << 15u);
        POWERUP = curr & (1u << 14u);
        HOLD_RING_OFF = curr & (1u << 13u);
        ENABLE_ALT = curr & (1u << 8u);
        DIV_SELECT = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of CTRL0_SET's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void set_CTRL0_SET(bool BIAS_SELECT, uint8_t POST_DIV_SEL,
                              bool PLL_REG_EN, uint8_t BIAS_TRIM,
                              bool DITHER_EN, bool BYPASS, bool ENABLE,
                              bool POWERUP, bool HOLD_RING_OFF,
                              bool ENABLE_ALT, uint8_t DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0_SET;

        curr &= ~(0b1u << 29u);
        curr |= (BIAS_SELECT & 0b1u) << 29u;
        curr &= ~(0b111u << 25u);
        curr |= (POST_DIV_SEL & 0b111u) << 25u;
        curr &= ~(0b1u << 22u);
        curr |= (PLL_REG_EN & 0b1u) << 22u;
        curr &= ~(0b111u << 19u);
        curr |= (BIAS_TRIM & 0b111u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DITHER_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (POWERUP & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (HOLD_RING_OFF & 0b1u) << 13u;
        curr &= ~(0b1u << 8u);
        curr |= (ENABLE_ALT & 0b1u) << 8u;
        curr &= ~(0b1111111u << 0u);
        curr |= (DIV_SELECT & 0b1111111u) << 0u;

        CTRL0_SET = curr;
    }

    /**
     * Get CTRL0_CLR's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline bool get_CTRL0_CLR_BIAS_SELECT() volatile
    {
        return CTRL0_CLR & (1u << 29u);
    }

    /**
     * Set CTRL0_CLR's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void set_CTRL0_CLR_BIAS_SELECT() volatile
    {
        CTRL0_CLR |= 1u << 29u;
    }

    /**
     * Clear CTRL0_CLR's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void clear_CTRL0_CLR_BIAS_SELECT() volatile
    {
        CTRL0_CLR &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL0_CLR's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void toggle_CTRL0_CLR_BIAS_SELECT() volatile
    {
        CTRL0_CLR ^= 1u << 29u;
    }

    /**
     * Get CTRL0_CLR's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline uint8_t get_CTRL0_CLR_POST_DIV_SEL() volatile
    {
        return (CTRL0_CLR >> 25u) & 0b111u;
    }

    /**
     * Set CTRL0_CLR's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline void set_CTRL0_CLR_POST_DIV_SEL(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_CLR;

        curr &= ~(0b111u << 25u);
        curr |= (value & 0b111u) << 25u;

        CTRL0_CLR = curr;
    }

    /**
     * Get CTRL0_CLR's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline bool get_CTRL0_CLR_PLL_REG_EN() volatile
    {
        return CTRL0_CLR & (1u << 22u);
    }

    /**
     * Set CTRL0_CLR's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void set_CTRL0_CLR_PLL_REG_EN() volatile
    {
        CTRL0_CLR |= 1u << 22u;
    }

    /**
     * Clear CTRL0_CLR's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void clear_CTRL0_CLR_PLL_REG_EN() volatile
    {
        CTRL0_CLR &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL0_CLR's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void toggle_CTRL0_CLR_PLL_REG_EN() volatile
    {
        CTRL0_CLR ^= 1u << 22u;
    }

    /**
     * Get CTRL0_CLR's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline uint8_t get_CTRL0_CLR_BIAS_TRIM() volatile
    {
        return (CTRL0_CLR >> 19u) & 0b111u;
    }

    /**
     * Set CTRL0_CLR's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline void set_CTRL0_CLR_BIAS_TRIM(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_CLR;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        CTRL0_CLR = curr;
    }

    /**
     * Get CTRL0_CLR's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline bool get_CTRL0_CLR_DITHER_EN() volatile
    {
        return CTRL0_CLR & (1u << 17u);
    }

    /**
     * Set CTRL0_CLR's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void set_CTRL0_CLR_DITHER_EN() volatile
    {
        CTRL0_CLR |= 1u << 17u;
    }

    /**
     * Clear CTRL0_CLR's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void clear_CTRL0_CLR_DITHER_EN() volatile
    {
        CTRL0_CLR &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL0_CLR's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void toggle_CTRL0_CLR_DITHER_EN() volatile
    {
        CTRL0_CLR ^= 1u << 17u;
    }

    /**
     * Get CTRL0_CLR's BYPASS bit.
     *
     * BYPASS
     */
    inline bool get_CTRL0_CLR_BYPASS() volatile
    {
        return CTRL0_CLR & (1u << 16u);
    }

    /**
     * Set CTRL0_CLR's BYPASS bit.
     *
     * BYPASS
     */
    inline void set_CTRL0_CLR_BYPASS() volatile
    {
        CTRL0_CLR |= 1u << 16u;
    }

    /**
     * Clear CTRL0_CLR's BYPASS bit.
     *
     * BYPASS
     */
    inline void clear_CTRL0_CLR_BYPASS() volatile
    {
        CTRL0_CLR &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL0_CLR's BYPASS bit.
     *
     * BYPASS
     */
    inline void toggle_CTRL0_CLR_BYPASS() volatile
    {
        CTRL0_CLR ^= 1u << 16u;
    }

    /**
     * Get CTRL0_CLR's ENABLE bit.
     *
     * ENABLE
     */
    inline bool get_CTRL0_CLR_ENABLE() volatile
    {
        return CTRL0_CLR & (1u << 15u);
    }

    /**
     * Set CTRL0_CLR's ENABLE bit.
     *
     * ENABLE
     */
    inline void set_CTRL0_CLR_ENABLE() volatile
    {
        CTRL0_CLR |= 1u << 15u;
    }

    /**
     * Clear CTRL0_CLR's ENABLE bit.
     *
     * ENABLE
     */
    inline void clear_CTRL0_CLR_ENABLE() volatile
    {
        CTRL0_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL0_CLR's ENABLE bit.
     *
     * ENABLE
     */
    inline void toggle_CTRL0_CLR_ENABLE() volatile
    {
        CTRL0_CLR ^= 1u << 15u;
    }

    /**
     * Get CTRL0_CLR's POWERUP bit.
     *
     * POWERUP
     */
    inline bool get_CTRL0_CLR_POWERUP() volatile
    {
        return CTRL0_CLR & (1u << 14u);
    }

    /**
     * Set CTRL0_CLR's POWERUP bit.
     *
     * POWERUP
     */
    inline void set_CTRL0_CLR_POWERUP() volatile
    {
        CTRL0_CLR |= 1u << 14u;
    }

    /**
     * Clear CTRL0_CLR's POWERUP bit.
     *
     * POWERUP
     */
    inline void clear_CTRL0_CLR_POWERUP() volatile
    {
        CTRL0_CLR &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL0_CLR's POWERUP bit.
     *
     * POWERUP
     */
    inline void toggle_CTRL0_CLR_POWERUP() volatile
    {
        CTRL0_CLR ^= 1u << 14u;
    }

    /**
     * Get CTRL0_CLR's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline bool get_CTRL0_CLR_HOLD_RING_OFF() volatile
    {
        return CTRL0_CLR & (1u << 13u);
    }

    /**
     * Set CTRL0_CLR's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void set_CTRL0_CLR_HOLD_RING_OFF() volatile
    {
        CTRL0_CLR |= 1u << 13u;
    }

    /**
     * Clear CTRL0_CLR's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void clear_CTRL0_CLR_HOLD_RING_OFF() volatile
    {
        CTRL0_CLR &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL0_CLR's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void toggle_CTRL0_CLR_HOLD_RING_OFF() volatile
    {
        CTRL0_CLR ^= 1u << 13u;
    }

    /**
     * Get CTRL0_CLR's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline bool get_CTRL0_CLR_ENABLE_ALT() volatile
    {
        return CTRL0_CLR & (1u << 8u);
    }

    /**
     * Set CTRL0_CLR's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void set_CTRL0_CLR_ENABLE_ALT() volatile
    {
        CTRL0_CLR |= 1u << 8u;
    }

    /**
     * Clear CTRL0_CLR's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void clear_CTRL0_CLR_ENABLE_ALT() volatile
    {
        CTRL0_CLR &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL0_CLR's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void toggle_CTRL0_CLR_ENABLE_ALT() volatile
    {
        CTRL0_CLR ^= 1u << 8u;
    }

    /**
     * Get CTRL0_CLR's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline uint8_t get_CTRL0_CLR_DIV_SELECT() volatile
    {
        return (CTRL0_CLR >> 0u) & 0b1111111u;
    }

    /**
     * Set CTRL0_CLR's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline void set_CTRL0_CLR_DIV_SELECT(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_CLR;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        CTRL0_CLR = curr;
    }

    /**
     * Get all of CTRL0_CLR's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void get_CTRL0_CLR(bool &BIAS_SELECT, uint8_t &POST_DIV_SEL,
                              bool &PLL_REG_EN, uint8_t &BIAS_TRIM,
                              bool &DITHER_EN, bool &BYPASS, bool &ENABLE,
                              bool &POWERUP, bool &HOLD_RING_OFF,
                              bool &ENABLE_ALT, uint8_t &DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0_CLR;

        BIAS_SELECT = curr & (1u << 29u);
        POST_DIV_SEL = (curr >> 25u) & 0b111u;
        PLL_REG_EN = curr & (1u << 22u);
        BIAS_TRIM = (curr >> 19u) & 0b111u;
        DITHER_EN = curr & (1u << 17u);
        BYPASS = curr & (1u << 16u);
        ENABLE = curr & (1u << 15u);
        POWERUP = curr & (1u << 14u);
        HOLD_RING_OFF = curr & (1u << 13u);
        ENABLE_ALT = curr & (1u << 8u);
        DIV_SELECT = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of CTRL0_CLR's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void set_CTRL0_CLR(bool BIAS_SELECT, uint8_t POST_DIV_SEL,
                              bool PLL_REG_EN, uint8_t BIAS_TRIM,
                              bool DITHER_EN, bool BYPASS, bool ENABLE,
                              bool POWERUP, bool HOLD_RING_OFF,
                              bool ENABLE_ALT, uint8_t DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0_CLR;

        curr &= ~(0b1u << 29u);
        curr |= (BIAS_SELECT & 0b1u) << 29u;
        curr &= ~(0b111u << 25u);
        curr |= (POST_DIV_SEL & 0b111u) << 25u;
        curr &= ~(0b1u << 22u);
        curr |= (PLL_REG_EN & 0b1u) << 22u;
        curr &= ~(0b111u << 19u);
        curr |= (BIAS_TRIM & 0b111u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DITHER_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (POWERUP & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (HOLD_RING_OFF & 0b1u) << 13u;
        curr &= ~(0b1u << 8u);
        curr |= (ENABLE_ALT & 0b1u) << 8u;
        curr &= ~(0b1111111u << 0u);
        curr |= (DIV_SELECT & 0b1111111u) << 0u;

        CTRL0_CLR = curr;
    }

    /**
     * Get CTRL0_TOG's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline bool get_CTRL0_TOG_BIAS_SELECT() volatile
    {
        return CTRL0_TOG & (1u << 29u);
    }

    /**
     * Set CTRL0_TOG's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void set_CTRL0_TOG_BIAS_SELECT() volatile
    {
        CTRL0_TOG |= 1u << 29u;
    }

    /**
     * Clear CTRL0_TOG's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void clear_CTRL0_TOG_BIAS_SELECT() volatile
    {
        CTRL0_TOG &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL0_TOG's BIAS_SELECT bit.
     *
     * BIAS_SELECT
     */
    inline void toggle_CTRL0_TOG_BIAS_SELECT() volatile
    {
        CTRL0_TOG ^= 1u << 29u;
    }

    /**
     * Get CTRL0_TOG's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline uint8_t get_CTRL0_TOG_POST_DIV_SEL() volatile
    {
        return (CTRL0_TOG >> 25u) & 0b111u;
    }

    /**
     * Set CTRL0_TOG's POST_DIV_SEL field.
     *
     * Post Divide Select
     */
    inline void set_CTRL0_TOG_POST_DIV_SEL(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_TOG;

        curr &= ~(0b111u << 25u);
        curr |= (value & 0b111u) << 25u;

        CTRL0_TOG = curr;
    }

    /**
     * Get CTRL0_TOG's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline bool get_CTRL0_TOG_PLL_REG_EN() volatile
    {
        return CTRL0_TOG & (1u << 22u);
    }

    /**
     * Set CTRL0_TOG's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void set_CTRL0_TOG_PLL_REG_EN() volatile
    {
        CTRL0_TOG |= 1u << 22u;
    }

    /**
     * Clear CTRL0_TOG's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void clear_CTRL0_TOG_PLL_REG_EN() volatile
    {
        CTRL0_TOG &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL0_TOG's PLL_REG_EN bit.
     *
     * PLL_REG_EN
     */
    inline void toggle_CTRL0_TOG_PLL_REG_EN() volatile
    {
        CTRL0_TOG ^= 1u << 22u;
    }

    /**
     * Get CTRL0_TOG's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline uint8_t get_CTRL0_TOG_BIAS_TRIM() volatile
    {
        return (CTRL0_TOG >> 19u) & 0b111u;
    }

    /**
     * Set CTRL0_TOG's BIAS_TRIM field.
     *
     * BIAS_TRIM
     */
    inline void set_CTRL0_TOG_BIAS_TRIM(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_TOG;

        curr &= ~(0b111u << 19u);
        curr |= (value & 0b111u) << 19u;

        CTRL0_TOG = curr;
    }

    /**
     * Get CTRL0_TOG's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline bool get_CTRL0_TOG_DITHER_EN() volatile
    {
        return CTRL0_TOG & (1u << 17u);
    }

    /**
     * Set CTRL0_TOG's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void set_CTRL0_TOG_DITHER_EN() volatile
    {
        CTRL0_TOG |= 1u << 17u;
    }

    /**
     * Clear CTRL0_TOG's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void clear_CTRL0_TOG_DITHER_EN() volatile
    {
        CTRL0_TOG &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL0_TOG's DITHER_EN bit.
     *
     * DITHER_EN
     */
    inline void toggle_CTRL0_TOG_DITHER_EN() volatile
    {
        CTRL0_TOG ^= 1u << 17u;
    }

    /**
     * Get CTRL0_TOG's BYPASS bit.
     *
     * BYPASS
     */
    inline bool get_CTRL0_TOG_BYPASS() volatile
    {
        return CTRL0_TOG & (1u << 16u);
    }

    /**
     * Set CTRL0_TOG's BYPASS bit.
     *
     * BYPASS
     */
    inline void set_CTRL0_TOG_BYPASS() volatile
    {
        CTRL0_TOG |= 1u << 16u;
    }

    /**
     * Clear CTRL0_TOG's BYPASS bit.
     *
     * BYPASS
     */
    inline void clear_CTRL0_TOG_BYPASS() volatile
    {
        CTRL0_TOG &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL0_TOG's BYPASS bit.
     *
     * BYPASS
     */
    inline void toggle_CTRL0_TOG_BYPASS() volatile
    {
        CTRL0_TOG ^= 1u << 16u;
    }

    /**
     * Get CTRL0_TOG's ENABLE bit.
     *
     * ENABLE
     */
    inline bool get_CTRL0_TOG_ENABLE() volatile
    {
        return CTRL0_TOG & (1u << 15u);
    }

    /**
     * Set CTRL0_TOG's ENABLE bit.
     *
     * ENABLE
     */
    inline void set_CTRL0_TOG_ENABLE() volatile
    {
        CTRL0_TOG |= 1u << 15u;
    }

    /**
     * Clear CTRL0_TOG's ENABLE bit.
     *
     * ENABLE
     */
    inline void clear_CTRL0_TOG_ENABLE() volatile
    {
        CTRL0_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL0_TOG's ENABLE bit.
     *
     * ENABLE
     */
    inline void toggle_CTRL0_TOG_ENABLE() volatile
    {
        CTRL0_TOG ^= 1u << 15u;
    }

    /**
     * Get CTRL0_TOG's POWERUP bit.
     *
     * POWERUP
     */
    inline bool get_CTRL0_TOG_POWERUP() volatile
    {
        return CTRL0_TOG & (1u << 14u);
    }

    /**
     * Set CTRL0_TOG's POWERUP bit.
     *
     * POWERUP
     */
    inline void set_CTRL0_TOG_POWERUP() volatile
    {
        CTRL0_TOG |= 1u << 14u;
    }

    /**
     * Clear CTRL0_TOG's POWERUP bit.
     *
     * POWERUP
     */
    inline void clear_CTRL0_TOG_POWERUP() volatile
    {
        CTRL0_TOG &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL0_TOG's POWERUP bit.
     *
     * POWERUP
     */
    inline void toggle_CTRL0_TOG_POWERUP() volatile
    {
        CTRL0_TOG ^= 1u << 14u;
    }

    /**
     * Get CTRL0_TOG's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline bool get_CTRL0_TOG_HOLD_RING_OFF() volatile
    {
        return CTRL0_TOG & (1u << 13u);
    }

    /**
     * Set CTRL0_TOG's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void set_CTRL0_TOG_HOLD_RING_OFF() volatile
    {
        CTRL0_TOG |= 1u << 13u;
    }

    /**
     * Clear CTRL0_TOG's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void clear_CTRL0_TOG_HOLD_RING_OFF() volatile
    {
        CTRL0_TOG &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL0_TOG's HOLD_RING_OFF bit.
     *
     * PLL Start up initialization
     */
    inline void toggle_CTRL0_TOG_HOLD_RING_OFF() volatile
    {
        CTRL0_TOG ^= 1u << 13u;
    }

    /**
     * Get CTRL0_TOG's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline bool get_CTRL0_TOG_ENABLE_ALT() volatile
    {
        return CTRL0_TOG & (1u << 8u);
    }

    /**
     * Set CTRL0_TOG's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void set_CTRL0_TOG_ENABLE_ALT() volatile
    {
        CTRL0_TOG |= 1u << 8u;
    }

    /**
     * Clear CTRL0_TOG's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void clear_CTRL0_TOG_ENABLE_ALT() volatile
    {
        CTRL0_TOG &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL0_TOG's ENABLE_ALT bit.
     *
     * ENABLE_ALT
     */
    inline void toggle_CTRL0_TOG_ENABLE_ALT() volatile
    {
        CTRL0_TOG ^= 1u << 8u;
    }

    /**
     * Get CTRL0_TOG's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline uint8_t get_CTRL0_TOG_DIV_SELECT() volatile
    {
        return (CTRL0_TOG >> 0u) & 0b1111111u;
    }

    /**
     * Set CTRL0_TOG's DIV_SELECT field.
     *
     * DIV_SELECT
     */
    inline void set_CTRL0_TOG_DIV_SELECT(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_TOG;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        CTRL0_TOG = curr;
    }

    /**
     * Get all of CTRL0_TOG's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void get_CTRL0_TOG(bool &BIAS_SELECT, uint8_t &POST_DIV_SEL,
                              bool &PLL_REG_EN, uint8_t &BIAS_TRIM,
                              bool &DITHER_EN, bool &BYPASS, bool &ENABLE,
                              bool &POWERUP, bool &HOLD_RING_OFF,
                              bool &ENABLE_ALT, uint8_t &DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0_TOG;

        BIAS_SELECT = curr & (1u << 29u);
        POST_DIV_SEL = (curr >> 25u) & 0b111u;
        PLL_REG_EN = curr & (1u << 22u);
        BIAS_TRIM = (curr >> 19u) & 0b111u;
        DITHER_EN = curr & (1u << 17u);
        BYPASS = curr & (1u << 16u);
        ENABLE = curr & (1u << 15u);
        POWERUP = curr & (1u << 14u);
        HOLD_RING_OFF = curr & (1u << 13u);
        ENABLE_ALT = curr & (1u << 8u);
        DIV_SELECT = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of CTRL0_TOG's bit fields.
     *
     * (read-write) Fractional PLL Control Register
     */
    inline void set_CTRL0_TOG(bool BIAS_SELECT, uint8_t POST_DIV_SEL,
                              bool PLL_REG_EN, uint8_t BIAS_TRIM,
                              bool DITHER_EN, bool BYPASS, bool ENABLE,
                              bool POWERUP, bool HOLD_RING_OFF,
                              bool ENABLE_ALT, uint8_t DIV_SELECT) volatile
    {
        uint32_t curr = CTRL0_TOG;

        curr &= ~(0b1u << 29u);
        curr |= (BIAS_SELECT & 0b1u) << 29u;
        curr &= ~(0b111u << 25u);
        curr |= (POST_DIV_SEL & 0b111u) << 25u;
        curr &= ~(0b1u << 22u);
        curr |= (PLL_REG_EN & 0b1u) << 22u;
        curr &= ~(0b111u << 19u);
        curr |= (BIAS_TRIM & 0b111u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DITHER_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (POWERUP & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (HOLD_RING_OFF & 0b1u) << 13u;
        curr &= ~(0b1u << 8u);
        curr |= (ENABLE_ALT & 0b1u) << 8u;
        curr &= ~(0b1111111u << 0u);
        curr |= (DIV_SELECT & 0b1111111u) << 0u;

        CTRL0_TOG = curr;
    }

    /**
     * Get SPREAD_SPECTRUM's STOP field.
     *
     * Stop
     */
    inline uint16_t get_SPREAD_SPECTRUM_STOP() volatile
    {
        return (SPREAD_SPECTRUM >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM's STOP field.
     *
     * Stop
     */
    inline void set_SPREAD_SPECTRUM_STOP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SPREAD_SPECTRUM = curr;
    }

    /**
     * Get SPREAD_SPECTRUM's ENABLE bit.
     *
     * Enable
     */
    inline bool get_SPREAD_SPECTRUM_ENABLE() volatile
    {
        return SPREAD_SPECTRUM & (1u << 15u);
    }

    /**
     * Set SPREAD_SPECTRUM's ENABLE bit.
     *
     * Enable
     */
    inline void set_SPREAD_SPECTRUM_ENABLE() volatile
    {
        SPREAD_SPECTRUM |= 1u << 15u;
    }

    /**
     * Clear SPREAD_SPECTRUM's ENABLE bit.
     *
     * Enable
     */
    inline void clear_SPREAD_SPECTRUM_ENABLE() volatile
    {
        SPREAD_SPECTRUM &= ~(1u << 15u);
    }

    /**
     * Toggle SPREAD_SPECTRUM's ENABLE bit.
     *
     * Enable
     */
    inline void toggle_SPREAD_SPECTRUM_ENABLE() volatile
    {
        SPREAD_SPECTRUM ^= 1u << 15u;
    }

    /**
     * Get SPREAD_SPECTRUM's STEP field.
     *
     * Step
     */
    inline uint16_t get_SPREAD_SPECTRUM_STEP() volatile
    {
        return (SPREAD_SPECTRUM >> 0u) & 0b111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM's STEP field.
     *
     * Step
     */
    inline void set_SPREAD_SPECTRUM_STEP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM = curr;
    }

    /**
     * Get all of SPREAD_SPECTRUM's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void get_SPREAD_SPECTRUM(uint16_t &STOP, bool &ENABLE,
                                    uint16_t &STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM;

        STOP = (curr >> 16u) & 0b1111111111111111u;
        ENABLE = curr & (1u << 15u);
        STEP = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Set all of SPREAD_SPECTRUM's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void set_SPREAD_SPECTRUM(uint16_t STOP, bool ENABLE,
                                    uint16_t STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (STOP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b111111111111111u << 0u);
        curr |= (STEP & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM = curr;
    }

    /**
     * Get SPREAD_SPECTRUM_SET's STOP field.
     *
     * Stop
     */
    inline uint16_t get_SPREAD_SPECTRUM_SET_STOP() volatile
    {
        return (SPREAD_SPECTRUM_SET >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM_SET's STOP field.
     *
     * Stop
     */
    inline void set_SPREAD_SPECTRUM_SET_STOP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SPREAD_SPECTRUM_SET = curr;
    }

    /**
     * Get SPREAD_SPECTRUM_SET's ENABLE bit.
     *
     * Enable
     */
    inline bool get_SPREAD_SPECTRUM_SET_ENABLE() volatile
    {
        return SPREAD_SPECTRUM_SET & (1u << 15u);
    }

    /**
     * Set SPREAD_SPECTRUM_SET's ENABLE bit.
     *
     * Enable
     */
    inline void set_SPREAD_SPECTRUM_SET_ENABLE() volatile
    {
        SPREAD_SPECTRUM_SET |= 1u << 15u;
    }

    /**
     * Clear SPREAD_SPECTRUM_SET's ENABLE bit.
     *
     * Enable
     */
    inline void clear_SPREAD_SPECTRUM_SET_ENABLE() volatile
    {
        SPREAD_SPECTRUM_SET &= ~(1u << 15u);
    }

    /**
     * Toggle SPREAD_SPECTRUM_SET's ENABLE bit.
     *
     * Enable
     */
    inline void toggle_SPREAD_SPECTRUM_SET_ENABLE() volatile
    {
        SPREAD_SPECTRUM_SET ^= 1u << 15u;
    }

    /**
     * Get SPREAD_SPECTRUM_SET's STEP field.
     *
     * Step
     */
    inline uint16_t get_SPREAD_SPECTRUM_SET_STEP() volatile
    {
        return (SPREAD_SPECTRUM_SET >> 0u) & 0b111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM_SET's STEP field.
     *
     * Step
     */
    inline void set_SPREAD_SPECTRUM_SET_STEP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_SET;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM_SET = curr;
    }

    /**
     * Get all of SPREAD_SPECTRUM_SET's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void get_SPREAD_SPECTRUM_SET(uint16_t &STOP, bool &ENABLE,
                                        uint16_t &STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_SET;

        STOP = (curr >> 16u) & 0b1111111111111111u;
        ENABLE = curr & (1u << 15u);
        STEP = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Set all of SPREAD_SPECTRUM_SET's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void set_SPREAD_SPECTRUM_SET(uint16_t STOP, bool ENABLE,
                                        uint16_t STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (STOP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b111111111111111u << 0u);
        curr |= (STEP & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM_SET = curr;
    }

    /**
     * Get SPREAD_SPECTRUM_CLR's STOP field.
     *
     * Stop
     */
    inline uint16_t get_SPREAD_SPECTRUM_CLR_STOP() volatile
    {
        return (SPREAD_SPECTRUM_CLR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM_CLR's STOP field.
     *
     * Stop
     */
    inline void set_SPREAD_SPECTRUM_CLR_STOP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SPREAD_SPECTRUM_CLR = curr;
    }

    /**
     * Get SPREAD_SPECTRUM_CLR's ENABLE bit.
     *
     * Enable
     */
    inline bool get_SPREAD_SPECTRUM_CLR_ENABLE() volatile
    {
        return SPREAD_SPECTRUM_CLR & (1u << 15u);
    }

    /**
     * Set SPREAD_SPECTRUM_CLR's ENABLE bit.
     *
     * Enable
     */
    inline void set_SPREAD_SPECTRUM_CLR_ENABLE() volatile
    {
        SPREAD_SPECTRUM_CLR |= 1u << 15u;
    }

    /**
     * Clear SPREAD_SPECTRUM_CLR's ENABLE bit.
     *
     * Enable
     */
    inline void clear_SPREAD_SPECTRUM_CLR_ENABLE() volatile
    {
        SPREAD_SPECTRUM_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle SPREAD_SPECTRUM_CLR's ENABLE bit.
     *
     * Enable
     */
    inline void toggle_SPREAD_SPECTRUM_CLR_ENABLE() volatile
    {
        SPREAD_SPECTRUM_CLR ^= 1u << 15u;
    }

    /**
     * Get SPREAD_SPECTRUM_CLR's STEP field.
     *
     * Step
     */
    inline uint16_t get_SPREAD_SPECTRUM_CLR_STEP() volatile
    {
        return (SPREAD_SPECTRUM_CLR >> 0u) & 0b111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM_CLR's STEP field.
     *
     * Step
     */
    inline void set_SPREAD_SPECTRUM_CLR_STEP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_CLR;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM_CLR = curr;
    }

    /**
     * Get all of SPREAD_SPECTRUM_CLR's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void get_SPREAD_SPECTRUM_CLR(uint16_t &STOP, bool &ENABLE,
                                        uint16_t &STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_CLR;

        STOP = (curr >> 16u) & 0b1111111111111111u;
        ENABLE = curr & (1u << 15u);
        STEP = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Set all of SPREAD_SPECTRUM_CLR's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void set_SPREAD_SPECTRUM_CLR(uint16_t STOP, bool ENABLE,
                                        uint16_t STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (STOP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b111111111111111u << 0u);
        curr |= (STEP & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM_CLR = curr;
    }

    /**
     * Get SPREAD_SPECTRUM_TOG's STOP field.
     *
     * Stop
     */
    inline uint16_t get_SPREAD_SPECTRUM_TOG_STOP() volatile
    {
        return (SPREAD_SPECTRUM_TOG >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM_TOG's STOP field.
     *
     * Stop
     */
    inline void set_SPREAD_SPECTRUM_TOG_STOP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SPREAD_SPECTRUM_TOG = curr;
    }

    /**
     * Get SPREAD_SPECTRUM_TOG's ENABLE bit.
     *
     * Enable
     */
    inline bool get_SPREAD_SPECTRUM_TOG_ENABLE() volatile
    {
        return SPREAD_SPECTRUM_TOG & (1u << 15u);
    }

    /**
     * Set SPREAD_SPECTRUM_TOG's ENABLE bit.
     *
     * Enable
     */
    inline void set_SPREAD_SPECTRUM_TOG_ENABLE() volatile
    {
        SPREAD_SPECTRUM_TOG |= 1u << 15u;
    }

    /**
     * Clear SPREAD_SPECTRUM_TOG's ENABLE bit.
     *
     * Enable
     */
    inline void clear_SPREAD_SPECTRUM_TOG_ENABLE() volatile
    {
        SPREAD_SPECTRUM_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle SPREAD_SPECTRUM_TOG's ENABLE bit.
     *
     * Enable
     */
    inline void toggle_SPREAD_SPECTRUM_TOG_ENABLE() volatile
    {
        SPREAD_SPECTRUM_TOG ^= 1u << 15u;
    }

    /**
     * Get SPREAD_SPECTRUM_TOG's STEP field.
     *
     * Step
     */
    inline uint16_t get_SPREAD_SPECTRUM_TOG_STEP() volatile
    {
        return (SPREAD_SPECTRUM_TOG >> 0u) & 0b111111111111111u;
    }

    /**
     * Set SPREAD_SPECTRUM_TOG's STEP field.
     *
     * Step
     */
    inline void set_SPREAD_SPECTRUM_TOG_STEP(uint16_t value) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_TOG;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM_TOG = curr;
    }

    /**
     * Get all of SPREAD_SPECTRUM_TOG's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void get_SPREAD_SPECTRUM_TOG(uint16_t &STOP, bool &ENABLE,
                                        uint16_t &STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_TOG;

        STOP = (curr >> 16u) & 0b1111111111111111u;
        ENABLE = curr & (1u << 15u);
        STEP = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Set all of SPREAD_SPECTRUM_TOG's bit fields.
     *
     * (read-write) Fractional PLL Spread Spectrum Control Register
     */
    inline void set_SPREAD_SPECTRUM_TOG(uint16_t STOP, bool ENABLE,
                                        uint16_t STEP) volatile
    {
        uint32_t curr = SPREAD_SPECTRUM_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (STOP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENABLE & 0b1u) << 15u;
        curr &= ~(0b111111111111111u << 0u);
        curr |= (STEP & 0b111111111111111u) << 0u;

        SPREAD_SPECTRUM_TOG = curr;
    }

    /**
     * Get NUMERATOR's NUM field.
     *
     * Numerator
     */
    inline uint32_t get_NUMERATOR_NUM() volatile
    {
        return (NUMERATOR >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set NUMERATOR's NUM field.
     *
     * Numerator
     */
    inline void set_NUMERATOR_NUM(uint32_t value) volatile
    {
        uint32_t curr = NUMERATOR;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        NUMERATOR = curr;
    }

    /**
     * Get NUMERATOR_SET's NUM field.
     *
     * Numerator
     */
    inline uint32_t get_NUMERATOR_SET_NUM() volatile
    {
        return (NUMERATOR_SET >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set NUMERATOR_SET's NUM field.
     *
     * Numerator
     */
    inline void set_NUMERATOR_SET_NUM(uint32_t value) volatile
    {
        uint32_t curr = NUMERATOR_SET;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        NUMERATOR_SET = curr;
    }

    /**
     * Get NUMERATOR_CLR's NUM field.
     *
     * Numerator
     */
    inline uint32_t get_NUMERATOR_CLR_NUM() volatile
    {
        return (NUMERATOR_CLR >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set NUMERATOR_CLR's NUM field.
     *
     * Numerator
     */
    inline void set_NUMERATOR_CLR_NUM(uint32_t value) volatile
    {
        uint32_t curr = NUMERATOR_CLR;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        NUMERATOR_CLR = curr;
    }

    /**
     * Get NUMERATOR_TOG's NUM field.
     *
     * Numerator
     */
    inline uint32_t get_NUMERATOR_TOG_NUM() volatile
    {
        return (NUMERATOR_TOG >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set NUMERATOR_TOG's NUM field.
     *
     * Numerator
     */
    inline void set_NUMERATOR_TOG_NUM(uint32_t value) volatile
    {
        uint32_t curr = NUMERATOR_TOG;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        NUMERATOR_TOG = curr;
    }

    /**
     * Get DENOMINATOR's DENOM field.
     *
     * Denominator
     */
    inline uint32_t get_DENOMINATOR_DENOM() volatile
    {
        return (DENOMINATOR >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DENOMINATOR's DENOM field.
     *
     * Denominator
     */
    inline void set_DENOMINATOR_DENOM(uint32_t value) volatile
    {
        uint32_t curr = DENOMINATOR;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        DENOMINATOR = curr;
    }

    /**
     * Get DENOMINATOR_SET's DENOM field.
     *
     * Denominator
     */
    inline uint32_t get_DENOMINATOR_SET_DENOM() volatile
    {
        return (DENOMINATOR_SET >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DENOMINATOR_SET's DENOM field.
     *
     * Denominator
     */
    inline void set_DENOMINATOR_SET_DENOM(uint32_t value) volatile
    {
        uint32_t curr = DENOMINATOR_SET;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        DENOMINATOR_SET = curr;
    }

    /**
     * Get DENOMINATOR_CLR's DENOM field.
     *
     * Denominator
     */
    inline uint32_t get_DENOMINATOR_CLR_DENOM() volatile
    {
        return (DENOMINATOR_CLR >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DENOMINATOR_CLR's DENOM field.
     *
     * Denominator
     */
    inline void set_DENOMINATOR_CLR_DENOM(uint32_t value) volatile
    {
        uint32_t curr = DENOMINATOR_CLR;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        DENOMINATOR_CLR = curr;
    }

    /**
     * Get DENOMINATOR_TOG's DENOM field.
     *
     * Denominator
     */
    inline uint32_t get_DENOMINATOR_TOG_DENOM() volatile
    {
        return (DENOMINATOR_TOG >> 0u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DENOMINATOR_TOG's DENOM field.
     *
     * Denominator
     */
    inline void set_DENOMINATOR_TOG_DENOM(uint32_t value) volatile
    {
        uint32_t curr = DENOMINATOR_TOG;

        curr &= ~(0b111111111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111111111u) << 0u;

        DENOMINATOR_TOG = curr;
    }
};

static_assert(sizeof(ethernet_pll) == ethernet_pll::size);

static volatile ethernet_pll *const ETHERNET_PLL =
    reinterpret_cast<ethernet_pll *>(0);

}; // namespace MIMXRT1176::CM7
