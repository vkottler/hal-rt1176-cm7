/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/LPADC1_CFG_PWRSEL.h"
#include "../enums/LPADC1_CFG_REFSEL.h"
#include "../enums/LPADC1_CMDH10_AVGS.h"
#include "../enums/LPADC1_CMDH10_LOOP.h"
#include "../enums/LPADC1_CMDH10_NEXT.h"
#include "../enums/LPADC1_CMDH10_STS.h"
#include "../enums/LPADC1_CMDH11_AVGS.h"
#include "../enums/LPADC1_CMDH11_LOOP.h"
#include "../enums/LPADC1_CMDH11_NEXT.h"
#include "../enums/LPADC1_CMDH11_STS.h"
#include "../enums/LPADC1_CMDH12_AVGS.h"
#include "../enums/LPADC1_CMDH12_LOOP.h"
#include "../enums/LPADC1_CMDH12_NEXT.h"
#include "../enums/LPADC1_CMDH12_STS.h"
#include "../enums/LPADC1_CMDH13_AVGS.h"
#include "../enums/LPADC1_CMDH13_LOOP.h"
#include "../enums/LPADC1_CMDH13_NEXT.h"
#include "../enums/LPADC1_CMDH13_STS.h"
#include "../enums/LPADC1_CMDH14_AVGS.h"
#include "../enums/LPADC1_CMDH14_LOOP.h"
#include "../enums/LPADC1_CMDH14_NEXT.h"
#include "../enums/LPADC1_CMDH14_STS.h"
#include "../enums/LPADC1_CMDH15_AVGS.h"
#include "../enums/LPADC1_CMDH15_LOOP.h"
#include "../enums/LPADC1_CMDH15_NEXT.h"
#include "../enums/LPADC1_CMDH15_STS.h"
#include "../enums/LPADC1_CMDH1_AVGS.h"
#include "../enums/LPADC1_CMDH1_CMPEN.h"
#include "../enums/LPADC1_CMDH1_LOOP.h"
#include "../enums/LPADC1_CMDH1_NEXT.h"
#include "../enums/LPADC1_CMDH1_STS.h"
#include "../enums/LPADC1_CMDH2_AVGS.h"
#include "../enums/LPADC1_CMDH2_CMPEN.h"
#include "../enums/LPADC1_CMDH2_LOOP.h"
#include "../enums/LPADC1_CMDH2_NEXT.h"
#include "../enums/LPADC1_CMDH2_STS.h"
#include "../enums/LPADC1_CMDH3_AVGS.h"
#include "../enums/LPADC1_CMDH3_CMPEN.h"
#include "../enums/LPADC1_CMDH3_LOOP.h"
#include "../enums/LPADC1_CMDH3_NEXT.h"
#include "../enums/LPADC1_CMDH3_STS.h"
#include "../enums/LPADC1_CMDH4_AVGS.h"
#include "../enums/LPADC1_CMDH4_CMPEN.h"
#include "../enums/LPADC1_CMDH4_LOOP.h"
#include "../enums/LPADC1_CMDH4_NEXT.h"
#include "../enums/LPADC1_CMDH4_STS.h"
#include "../enums/LPADC1_CMDH5_AVGS.h"
#include "../enums/LPADC1_CMDH5_LOOP.h"
#include "../enums/LPADC1_CMDH5_NEXT.h"
#include "../enums/LPADC1_CMDH5_STS.h"
#include "../enums/LPADC1_CMDH6_AVGS.h"
#include "../enums/LPADC1_CMDH6_LOOP.h"
#include "../enums/LPADC1_CMDH6_NEXT.h"
#include "../enums/LPADC1_CMDH6_STS.h"
#include "../enums/LPADC1_CMDH7_AVGS.h"
#include "../enums/LPADC1_CMDH7_LOOP.h"
#include "../enums/LPADC1_CMDH7_NEXT.h"
#include "../enums/LPADC1_CMDH7_STS.h"
#include "../enums/LPADC1_CMDH8_AVGS.h"
#include "../enums/LPADC1_CMDH8_LOOP.h"
#include "../enums/LPADC1_CMDH8_NEXT.h"
#include "../enums/LPADC1_CMDH8_STS.h"
#include "../enums/LPADC1_CMDH9_AVGS.h"
#include "../enums/LPADC1_CMDH9_LOOP.h"
#include "../enums/LPADC1_CMDH9_NEXT.h"
#include "../enums/LPADC1_CMDH9_STS.h"
#include "../enums/LPADC1_CMDL10_ADCH.h"
#include "../enums/LPADC1_CMDL11_ADCH.h"
#include "../enums/LPADC1_CMDL12_ADCH.h"
#include "../enums/LPADC1_CMDL13_ADCH.h"
#include "../enums/LPADC1_CMDL14_ADCH.h"
#include "../enums/LPADC1_CMDL15_ADCH.h"
#include "../enums/LPADC1_CMDL1_ADCH.h"
#include "../enums/LPADC1_CMDL2_ADCH.h"
#include "../enums/LPADC1_CMDL3_ADCH.h"
#include "../enums/LPADC1_CMDL4_ADCH.h"
#include "../enums/LPADC1_CMDL5_ADCH.h"
#include "../enums/LPADC1_CMDL6_ADCH.h"
#include "../enums/LPADC1_CMDL7_ADCH.h"
#include "../enums/LPADC1_CMDL8_ADCH.h"
#include "../enums/LPADC1_CMDL9_ADCH.h"
#include "../enums/LPADC1_CTRL_TRIG_SRC.h"
#include "../enums/LPADC1_FCTRL_FCOUNT.h"
#include "../enums/LPADC1_FCTRL_FWMARK.h"
#include "../enums/LPADC1_PARAM_CMD_NUM.h"
#include "../enums/LPADC1_PARAM_CV_NUM.h"
#include "../enums/LPADC1_PARAM_FIFOSIZE.h"
#include "../enums/LPADC1_PARAM_TRIG_NUM.h"
#include "../enums/LPADC1_RESFIFO_CMDSRC.h"
#include "../enums/LPADC1_RESFIFO_LOOPCNT.h"
#include "../enums/LPADC1_RESFIFO_TSRC.h"
#include "../enums/LPADC1_STAT_CMDACT.h"
#include "../enums/LPADC1_STAT_TRGACT.h"
#include "../enums/LPADC1_TCTRL_TCMD.h"
#include "../enums/LPADC1_TCTRL_TPRI.h"
#include "../enums/LPADC1_VERID_CSW.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * LPADC
 */
struct [[gnu::packed]] lpadc1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 772; /*!< lpadc1's size in bytes. */

    /* Fields. */
    uint32_t VERID; /*!< (read-write) Version ID Register */
    uint32_t PARAM; /*!< (read-write) Parameter Register */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t CTRL;  /*!< (read-write) LPADC Control Register */
    uint32_t STAT;  /*!< (read-write) LPADC Status Register */
    uint32_t IE;    /*!< (read-write) Interrupt Enable Register */
    uint32_t DE;    /*!< (read-write) DMA Enable Register */
    uint32_t CFG;   /*!< (read-write) LPADC Configuration Register */
    uint32_t PAUSE; /*!< (read-write) LPADC Pause Register */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t FCTRL;  /*!< (read-write) LPADC FIFO Control Register */
    uint32_t SWTRIG; /*!< (read-write) Software Trigger Register */
    static constexpr std::size_t reserved_padding2_length = 34;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    static constexpr std::size_t TCTRL_length = 8;
    uint32_t TCTRL[TCTRL_length]; /*!< (read-write) Trigger Control Register */
    static constexpr std::size_t reserved_padding3_length = 8;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t CMDL1;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH1;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL2;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH2;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL3;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH3;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL4;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH4;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL5;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH5;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL6;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH6;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL7;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH7;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL8;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH8;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL9;  /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH9;  /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL10; /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH10; /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL11; /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH11; /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL12; /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH12; /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL13; /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH13; /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL14; /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH14; /*!< (read-write) LPADC Command High Buffer Register */
    uint32_t CMDL15; /*!< (read-write) LPADC Command Low Buffer Register */
    uint32_t CMDH15; /*!< (read-write) LPADC Command High Buffer Register */
    static constexpr std::size_t reserved_padding4_length = 34;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    static constexpr std::size_t CV_length = 4;
    uint32_t CV[CV_length]; /*!< (read-write) Compare Value Register */
    static constexpr std::size_t reserved_padding5_length = 60;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t RESFIFO; /*!< (read-write) LPADC Data Result FIFO Register */

    /* Methods. */

    /**
     * Get VERID's MAJOR field.
     *
     * Major Version Number
     */
    inline uint8_t get_VERID_MAJOR() volatile
    {
        return (VERID >> 24u) & 0b11111111u;
    }

    /**
     * Get VERID's MINOR field.
     *
     * Minor Version Number
     */
    inline uint8_t get_VERID_MINOR() volatile
    {
        return (VERID >> 16u) & 0b11111111u;
    }

    /**
     * Get VERID's CALOFSI bit.
     *
     * Calibration Offset Function Implemented
     */
    inline bool get_VERID_CALOFSI() volatile
    {
        return VERID & (1u << 10u);
    }

    /**
     * Get VERID's IADCKI bit.
     *
     * Internal LPADC Clock implemented
     */
    inline bool get_VERID_IADCKI() volatile
    {
        return VERID & (1u << 9u);
    }

    /**
     * Get VERID's VR1RNGI bit.
     *
     * Voltage Reference 1 Range Control Bit Implemented
     */
    inline bool get_VERID_VR1RNGI() volatile
    {
        return VERID & (1u << 8u);
    }

    /**
     * Get VERID's CSW field.
     *
     * Channel Scale Width
     */
    inline LPADC1_VERID_CSW get_VERID_CSW() volatile
    {
        return LPADC1_VERID_CSW((VERID >> 4u) & 0b111u);
    }

    /**
     * Get VERID's MVI bit.
     *
     * Multi Vref Implemented
     */
    inline bool get_VERID_MVI() volatile
    {
        return VERID & (1u << 3u);
    }

    /**
     * Get VERID's DIFFEN bit.
     *
     * Differential Supported
     */
    inline bool get_VERID_DIFFEN() volatile
    {
        return VERID & (1u << 1u);
    }

    /**
     * Get VERID's RES bit.
     *
     * Resolution
     */
    inline bool get_VERID_RES() volatile
    {
        return VERID & (1u << 0u);
    }

    /**
     * Get all of VERID's bit fields.
     *
     * (read-write) Version ID Register
     */
    inline void get_VERID(uint8_t &MAJOR, uint8_t &MINOR, bool &CALOFSI,
                          bool &IADCKI, bool &VR1RNGI, LPADC1_VERID_CSW &CSW,
                          bool &MVI, bool &DIFFEN, bool &RES) volatile
    {
        uint32_t curr = VERID;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        CALOFSI = curr & (1u << 10u);
        IADCKI = curr & (1u << 9u);
        VR1RNGI = curr & (1u << 8u);
        CSW = LPADC1_VERID_CSW((curr >> 4u) & 0b111u);
        MVI = curr & (1u << 3u);
        DIFFEN = curr & (1u << 1u);
        RES = curr & (1u << 0u);
    }

    /**
     * Get PARAM's CMD_NUM field.
     *
     * Command Buffer Number
     */
    inline LPADC1_PARAM_CMD_NUM get_PARAM_CMD_NUM() volatile
    {
        return LPADC1_PARAM_CMD_NUM((PARAM >> 24u) & 0b11111111u);
    }

    /**
     * Get PARAM's CV_NUM field.
     *
     * Compare Value Number
     */
    inline LPADC1_PARAM_CV_NUM get_PARAM_CV_NUM() volatile
    {
        return LPADC1_PARAM_CV_NUM((PARAM >> 16u) & 0b11111111u);
    }

    /**
     * Get PARAM's FIFOSIZE field.
     *
     * Result FIFO Depth
     */
    inline LPADC1_PARAM_FIFOSIZE get_PARAM_FIFOSIZE() volatile
    {
        return LPADC1_PARAM_FIFOSIZE((PARAM >> 8u) & 0b11111111u);
    }

    /**
     * Get PARAM's TRIG_NUM field.
     *
     * Trigger Number
     */
    inline LPADC1_PARAM_TRIG_NUM get_PARAM_TRIG_NUM() volatile
    {
        return LPADC1_PARAM_TRIG_NUM((PARAM >> 0u) & 0b11111111u);
    }

    /**
     * Get all of PARAM's bit fields.
     *
     * (read-write) Parameter Register
     */
    inline void get_PARAM(LPADC1_PARAM_CMD_NUM &CMD_NUM,
                          LPADC1_PARAM_CV_NUM &CV_NUM,
                          LPADC1_PARAM_FIFOSIZE &FIFOSIZE,
                          LPADC1_PARAM_TRIG_NUM &TRIG_NUM) volatile
    {
        uint32_t curr = PARAM;

        CMD_NUM = LPADC1_PARAM_CMD_NUM((curr >> 24u) & 0b11111111u);
        CV_NUM = LPADC1_PARAM_CV_NUM((curr >> 16u) & 0b11111111u);
        FIFOSIZE = LPADC1_PARAM_FIFOSIZE((curr >> 8u) & 0b11111111u);
        TRIG_NUM = LPADC1_PARAM_TRIG_NUM((curr >> 0u) & 0b11111111u);
    }

    /**
     * Get CTRL's RSTFIFO bit.
     *
     * Reset FIFO
     */
    inline bool get_CTRL_RSTFIFO() volatile
    {
        return CTRL & (1u << 8u);
    }

    /**
     * Set CTRL's RSTFIFO bit.
     *
     * Reset FIFO
     */
    inline void set_CTRL_RSTFIFO() volatile
    {
        CTRL |= 1u << 8u;
    }

    /**
     * Clear CTRL's RSTFIFO bit.
     *
     * Reset FIFO
     */
    inline void clear_CTRL_RSTFIFO() volatile
    {
        CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL's RSTFIFO bit.
     *
     * Reset FIFO
     */
    inline void toggle_CTRL_RSTFIFO() volatile
    {
        CTRL ^= 1u << 8u;
    }

    /**
     * Get CTRL's TRIG_SRC field.
     *
     * Hardware trigger source selection
     */
    inline LPADC1_CTRL_TRIG_SRC get_CTRL_TRIG_SRC() volatile
    {
        return LPADC1_CTRL_TRIG_SRC((CTRL >> 3u) & 0b11u);
    }

    /**
     * Set CTRL's TRIG_SRC field.
     *
     * Hardware trigger source selection
     */
    inline void set_CTRL_TRIG_SRC(LPADC1_CTRL_TRIG_SRC value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11u << 3u);
        curr |= (std::to_underlying(value) & 0b11u) << 3u;

        CTRL = curr;
    }

    /**
     * Get CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline bool get_CTRL_DOZEN() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline void set_CTRL_DOZEN() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline void clear_CTRL_DOZEN() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's DOZEN bit.
     *
     * Doze Enable
     */
    inline void toggle_CTRL_DOZEN() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's RST bit.
     *
     * Software Reset
     */
    inline bool get_CTRL_RST() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's RST bit.
     *
     * Software Reset
     */
    inline void set_CTRL_RST() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's RST bit.
     *
     * Software Reset
     */
    inline void clear_CTRL_RST() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's RST bit.
     *
     * Software Reset
     */
    inline void toggle_CTRL_RST() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's ADCEN bit.
     *
     * LPADC Enable
     */
    inline bool get_CTRL_ADCEN() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's ADCEN bit.
     *
     * LPADC Enable
     */
    inline void set_CTRL_ADCEN() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's ADCEN bit.
     *
     * LPADC Enable
     */
    inline void clear_CTRL_ADCEN() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's ADCEN bit.
     *
     * LPADC Enable
     */
    inline void toggle_CTRL_ADCEN() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) LPADC Control Register
     */
    inline void get_CTRL(bool &RSTFIFO, LPADC1_CTRL_TRIG_SRC &TRIG_SRC,
                         bool &DOZEN, bool &RST, bool &ADCEN) volatile
    {
        uint32_t curr = CTRL;

        RSTFIFO = curr & (1u << 8u);
        TRIG_SRC = LPADC1_CTRL_TRIG_SRC((curr >> 3u) & 0b11u);
        DOZEN = curr & (1u << 2u);
        RST = curr & (1u << 1u);
        ADCEN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) LPADC Control Register
     */
    inline void set_CTRL(bool RSTFIFO, LPADC1_CTRL_TRIG_SRC TRIG_SRC,
                         bool DOZEN, bool RST, bool ADCEN) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 8u);
        curr |= (RSTFIFO & 0b1u) << 8u;
        curr &= ~(0b11u << 3u);
        curr |= (std::to_underlying(TRIG_SRC) & 0b11u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DOZEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RST & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ADCEN & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get STAT's CMDACT field.
     *
     * Command Active
     */
    inline LPADC1_STAT_CMDACT get_STAT_CMDACT() volatile
    {
        return LPADC1_STAT_CMDACT((STAT >> 24u) & 0b1111u);
    }

    /**
     * Get STAT's TRGACT field.
     *
     * Trigger Active
     */
    inline LPADC1_STAT_TRGACT get_STAT_TRGACT() volatile
    {
        return LPADC1_STAT_TRGACT((STAT >> 16u) & 0b111u);
    }

    /**
     * Get STAT's ADC_ACTIVE bit.
     *
     * ADC Active
     */
    inline bool get_STAT_ADC_ACTIVE() volatile
    {
        return STAT & (1u << 8u);
    }

    /**
     * Get STAT's FOF bit.
     *
     * Result FIFO Overflow Flag
     */
    inline bool get_STAT_FOF() volatile
    {
        return STAT & (1u << 1u);
    }

    /**
     * Set STAT's FOF bit.
     *
     * Result FIFO Overflow Flag
     */
    inline void set_STAT_FOF() volatile
    {
        STAT |= 1u << 1u;
    }

    /**
     * Clear STAT's FOF bit.
     *
     * Result FIFO Overflow Flag
     */
    inline void clear_STAT_FOF() volatile
    {
        STAT &= ~(1u << 1u);
    }

    /**
     * Toggle STAT's FOF bit.
     *
     * Result FIFO Overflow Flag
     */
    inline void toggle_STAT_FOF() volatile
    {
        STAT ^= 1u << 1u;
    }

    /**
     * Get STAT's RDY bit.
     *
     * Result FIFO Ready Flag
     */
    inline bool get_STAT_RDY() volatile
    {
        return STAT & (1u << 0u);
    }

    /**
     * Get all of STAT's bit fields.
     *
     * (read-write) LPADC Status Register
     */
    inline void get_STAT(LPADC1_STAT_CMDACT &CMDACT,
                         LPADC1_STAT_TRGACT &TRGACT, bool &ADC_ACTIVE,
                         bool &FOF, bool &RDY) volatile
    {
        uint32_t curr = STAT;

        CMDACT = LPADC1_STAT_CMDACT((curr >> 24u) & 0b1111u);
        TRGACT = LPADC1_STAT_TRGACT((curr >> 16u) & 0b111u);
        ADC_ACTIVE = curr & (1u << 8u);
        FOF = curr & (1u << 1u);
        RDY = curr & (1u << 0u);
    }

    /**
     * Get IE's FOFIE bit.
     *
     * Result FIFO Overflow Interrupt Enable
     */
    inline bool get_IE_FOFIE() volatile
    {
        return IE & (1u << 1u);
    }

    /**
     * Set IE's FOFIE bit.
     *
     * Result FIFO Overflow Interrupt Enable
     */
    inline void set_IE_FOFIE() volatile
    {
        IE |= 1u << 1u;
    }

    /**
     * Clear IE's FOFIE bit.
     *
     * Result FIFO Overflow Interrupt Enable
     */
    inline void clear_IE_FOFIE() volatile
    {
        IE &= ~(1u << 1u);
    }

    /**
     * Toggle IE's FOFIE bit.
     *
     * Result FIFO Overflow Interrupt Enable
     */
    inline void toggle_IE_FOFIE() volatile
    {
        IE ^= 1u << 1u;
    }

    /**
     * Get IE's FWMIE bit.
     *
     * FIFO Watermark Interrupt Enable
     */
    inline bool get_IE_FWMIE() volatile
    {
        return IE & (1u << 0u);
    }

    /**
     * Set IE's FWMIE bit.
     *
     * FIFO Watermark Interrupt Enable
     */
    inline void set_IE_FWMIE() volatile
    {
        IE |= 1u << 0u;
    }

    /**
     * Clear IE's FWMIE bit.
     *
     * FIFO Watermark Interrupt Enable
     */
    inline void clear_IE_FWMIE() volatile
    {
        IE &= ~(1u << 0u);
    }

    /**
     * Toggle IE's FWMIE bit.
     *
     * FIFO Watermark Interrupt Enable
     */
    inline void toggle_IE_FWMIE() volatile
    {
        IE ^= 1u << 0u;
    }

    /**
     * Get all of IE's bit fields.
     *
     * (read-write) Interrupt Enable Register
     */
    inline void get_IE(bool &FOFIE, bool &FWMIE) volatile
    {
        uint32_t curr = IE;

        FOFIE = curr & (1u << 1u);
        FWMIE = curr & (1u << 0u);
    }

    /**
     * Set all of IE's bit fields.
     *
     * (read-write) Interrupt Enable Register
     */
    inline void set_IE(bool FOFIE, bool FWMIE) volatile
    {
        uint32_t curr = IE;

        curr &= ~(0b1u << 1u);
        curr |= (FOFIE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (FWMIE & 0b1u) << 0u;

        IE = curr;
    }

    /**
     * Get DE's FWMDE bit.
     *
     * FIFO Watermark DMA Enable
     */
    inline bool get_DE_FWMDE() volatile
    {
        return DE & (1u << 0u);
    }

    /**
     * Set DE's FWMDE bit.
     *
     * FIFO Watermark DMA Enable
     */
    inline void set_DE_FWMDE() volatile
    {
        DE |= 1u << 0u;
    }

    /**
     * Clear DE's FWMDE bit.
     *
     * FIFO Watermark DMA Enable
     */
    inline void clear_DE_FWMDE() volatile
    {
        DE &= ~(1u << 0u);
    }

    /**
     * Toggle DE's FWMDE bit.
     *
     * FIFO Watermark DMA Enable
     */
    inline void toggle_DE_FWMDE() volatile
    {
        DE ^= 1u << 0u;
    }

    /**
     * Get CFG's PWREN bit.
     *
     * LPADC Analog Pre-Enable
     */
    inline bool get_CFG_PWREN() volatile
    {
        return CFG & (1u << 28u);
    }

    /**
     * Set CFG's PWREN bit.
     *
     * LPADC Analog Pre-Enable
     */
    inline void set_CFG_PWREN() volatile
    {
        CFG |= 1u << 28u;
    }

    /**
     * Clear CFG's PWREN bit.
     *
     * LPADC Analog Pre-Enable
     */
    inline void clear_CFG_PWREN() volatile
    {
        CFG &= ~(1u << 28u);
    }

    /**
     * Toggle CFG's PWREN bit.
     *
     * LPADC Analog Pre-Enable
     */
    inline void toggle_CFG_PWREN() volatile
    {
        CFG ^= 1u << 28u;
    }

    /**
     * Get CFG's PUDLY field.
     *
     * Power Up Delay
     */
    inline uint8_t get_CFG_PUDLY() volatile
    {
        return (CFG >> 16u) & 0b11111111u;
    }

    /**
     * Set CFG's PUDLY field.
     *
     * Power Up Delay
     */
    inline void set_CFG_PUDLY(uint8_t value) volatile
    {
        uint32_t curr = CFG;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        CFG = curr;
    }

    /**
     * Get CFG's REFSEL field.
     *
     * Voltage Reference Selection
     */
    inline LPADC1_CFG_REFSEL get_CFG_REFSEL() volatile
    {
        return LPADC1_CFG_REFSEL((CFG >> 6u) & 0b11u);
    }

    /**
     * Set CFG's REFSEL field.
     *
     * Voltage Reference Selection
     */
    inline void set_CFG_REFSEL(LPADC1_CFG_REFSEL value) volatile
    {
        uint32_t curr = CFG;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        CFG = curr;
    }

    /**
     * Get CFG's PWRSEL field.
     *
     * Power Configuration Select
     */
    inline LPADC1_CFG_PWRSEL get_CFG_PWRSEL() volatile
    {
        return LPADC1_CFG_PWRSEL((CFG >> 4u) & 0b11u);
    }

    /**
     * Set CFG's PWRSEL field.
     *
     * Power Configuration Select
     */
    inline void set_CFG_PWRSEL(LPADC1_CFG_PWRSEL value) volatile
    {
        uint32_t curr = CFG;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CFG = curr;
    }

    /**
     * Get CFG's TPRICTRL bit.
     *
     * LPADC trigger priority control
     */
    inline bool get_CFG_TPRICTRL() volatile
    {
        return CFG & (1u << 0u);
    }

    /**
     * Set CFG's TPRICTRL bit.
     *
     * LPADC trigger priority control
     */
    inline void set_CFG_TPRICTRL() volatile
    {
        CFG |= 1u << 0u;
    }

    /**
     * Clear CFG's TPRICTRL bit.
     *
     * LPADC trigger priority control
     */
    inline void clear_CFG_TPRICTRL() volatile
    {
        CFG &= ~(1u << 0u);
    }

    /**
     * Toggle CFG's TPRICTRL bit.
     *
     * LPADC trigger priority control
     */
    inline void toggle_CFG_TPRICTRL() volatile
    {
        CFG ^= 1u << 0u;
    }

    /**
     * Get all of CFG's bit fields.
     *
     * (read-write) LPADC Configuration Register
     */
    inline void get_CFG(bool &PWREN, uint8_t &PUDLY, LPADC1_CFG_REFSEL &REFSEL,
                        LPADC1_CFG_PWRSEL &PWRSEL, bool &TPRICTRL) volatile
    {
        uint32_t curr = CFG;

        PWREN = curr & (1u << 28u);
        PUDLY = (curr >> 16u) & 0b11111111u;
        REFSEL = LPADC1_CFG_REFSEL((curr >> 6u) & 0b11u);
        PWRSEL = LPADC1_CFG_PWRSEL((curr >> 4u) & 0b11u);
        TPRICTRL = curr & (1u << 0u);
    }

    /**
     * Set all of CFG's bit fields.
     *
     * (read-write) LPADC Configuration Register
     */
    inline void set_CFG(bool PWREN, uint8_t PUDLY, LPADC1_CFG_REFSEL REFSEL,
                        LPADC1_CFG_PWRSEL PWRSEL, bool TPRICTRL) volatile
    {
        uint32_t curr = CFG;

        curr &= ~(0b1u << 28u);
        curr |= (PWREN & 0b1u) << 28u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PUDLY & 0b11111111u) << 16u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(REFSEL) & 0b11u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(PWRSEL) & 0b11u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (TPRICTRL & 0b1u) << 0u;

        CFG = curr;
    }

    /**
     * Get PAUSE's PAUSEEN bit.
     *
     * PAUSE Option Enable
     */
    inline bool get_PAUSE_PAUSEEN() volatile
    {
        return PAUSE & (1u << 31u);
    }

    /**
     * Set PAUSE's PAUSEEN bit.
     *
     * PAUSE Option Enable
     */
    inline void set_PAUSE_PAUSEEN() volatile
    {
        PAUSE |= 1u << 31u;
    }

    /**
     * Clear PAUSE's PAUSEEN bit.
     *
     * PAUSE Option Enable
     */
    inline void clear_PAUSE_PAUSEEN() volatile
    {
        PAUSE &= ~(1u << 31u);
    }

    /**
     * Toggle PAUSE's PAUSEEN bit.
     *
     * PAUSE Option Enable
     */
    inline void toggle_PAUSE_PAUSEEN() volatile
    {
        PAUSE ^= 1u << 31u;
    }

    /**
     * Get PAUSE's PAUSEDLY field.
     *
     * Pause Delay
     */
    inline uint16_t get_PAUSE_PAUSEDLY() volatile
    {
        return (PAUSE >> 0u) & 0b111111111u;
    }

    /**
     * Set PAUSE's PAUSEDLY field.
     *
     * Pause Delay
     */
    inline void set_PAUSE_PAUSEDLY(uint16_t value) volatile
    {
        uint32_t curr = PAUSE;

        curr &= ~(0b111111111u << 0u);
        curr |= (value & 0b111111111u) << 0u;

        PAUSE = curr;
    }

    /**
     * Get all of PAUSE's bit fields.
     *
     * (read-write) LPADC Pause Register
     */
    inline void get_PAUSE(bool &PAUSEEN, uint16_t &PAUSEDLY) volatile
    {
        uint32_t curr = PAUSE;

        PAUSEEN = curr & (1u << 31u);
        PAUSEDLY = (curr >> 0u) & 0b111111111u;
    }

    /**
     * Set all of PAUSE's bit fields.
     *
     * (read-write) LPADC Pause Register
     */
    inline void set_PAUSE(bool PAUSEEN, uint16_t PAUSEDLY) volatile
    {
        uint32_t curr = PAUSE;

        curr &= ~(0b1u << 31u);
        curr |= (PAUSEEN & 0b1u) << 31u;
        curr &= ~(0b111111111u << 0u);
        curr |= (PAUSEDLY & 0b111111111u) << 0u;

        PAUSE = curr;
    }

    /**
     * Get FCTRL's FWMARK field.
     *
     * Watermark level selection
     */
    inline LPADC1_FCTRL_FWMARK get_FCTRL_FWMARK() volatile
    {
        return LPADC1_FCTRL_FWMARK((FCTRL >> 16u) & 0b1111u);
    }

    /**
     * Set FCTRL's FWMARK field.
     *
     * Watermark level selection
     */
    inline void set_FCTRL_FWMARK(LPADC1_FCTRL_FWMARK value) volatile
    {
        uint32_t curr = FCTRL;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        FCTRL = curr;
    }

    /**
     * Get FCTRL's FCOUNT field.
     *
     * Result FIFO counter
     */
    inline LPADC1_FCTRL_FCOUNT get_FCTRL_FCOUNT() volatile
    {
        return LPADC1_FCTRL_FCOUNT((FCTRL >> 0u) & 0b11111u);
    }

    /**
     * Get all of FCTRL's bit fields.
     *
     * (read-write) LPADC FIFO Control Register
     */
    inline void get_FCTRL(LPADC1_FCTRL_FWMARK &FWMARK,
                          LPADC1_FCTRL_FCOUNT &FCOUNT) volatile
    {
        uint32_t curr = FCTRL;

        FWMARK = LPADC1_FCTRL_FWMARK((curr >> 16u) & 0b1111u);
        FCOUNT = LPADC1_FCTRL_FCOUNT((curr >> 0u) & 0b11111u);
    }

    /**
     * Get SWTRIG's SWT7 bit.
     *
     * Software trigger 7 event
     */
    inline bool get_SWTRIG_SWT7() volatile
    {
        return SWTRIG & (1u << 7u);
    }

    /**
     * Set SWTRIG's SWT7 bit.
     *
     * Software trigger 7 event
     */
    inline void set_SWTRIG_SWT7() volatile
    {
        SWTRIG |= 1u << 7u;
    }

    /**
     * Clear SWTRIG's SWT7 bit.
     *
     * Software trigger 7 event
     */
    inline void clear_SWTRIG_SWT7() volatile
    {
        SWTRIG &= ~(1u << 7u);
    }

    /**
     * Toggle SWTRIG's SWT7 bit.
     *
     * Software trigger 7 event
     */
    inline void toggle_SWTRIG_SWT7() volatile
    {
        SWTRIG ^= 1u << 7u;
    }

    /**
     * Get SWTRIG's SWT6 bit.
     *
     * Software trigger 6 event
     */
    inline bool get_SWTRIG_SWT6() volatile
    {
        return SWTRIG & (1u << 6u);
    }

    /**
     * Set SWTRIG's SWT6 bit.
     *
     * Software trigger 6 event
     */
    inline void set_SWTRIG_SWT6() volatile
    {
        SWTRIG |= 1u << 6u;
    }

    /**
     * Clear SWTRIG's SWT6 bit.
     *
     * Software trigger 6 event
     */
    inline void clear_SWTRIG_SWT6() volatile
    {
        SWTRIG &= ~(1u << 6u);
    }

    /**
     * Toggle SWTRIG's SWT6 bit.
     *
     * Software trigger 6 event
     */
    inline void toggle_SWTRIG_SWT6() volatile
    {
        SWTRIG ^= 1u << 6u;
    }

    /**
     * Get SWTRIG's SWT5 bit.
     *
     * Software trigger 5 event
     */
    inline bool get_SWTRIG_SWT5() volatile
    {
        return SWTRIG & (1u << 5u);
    }

    /**
     * Set SWTRIG's SWT5 bit.
     *
     * Software trigger 5 event
     */
    inline void set_SWTRIG_SWT5() volatile
    {
        SWTRIG |= 1u << 5u;
    }

    /**
     * Clear SWTRIG's SWT5 bit.
     *
     * Software trigger 5 event
     */
    inline void clear_SWTRIG_SWT5() volatile
    {
        SWTRIG &= ~(1u << 5u);
    }

    /**
     * Toggle SWTRIG's SWT5 bit.
     *
     * Software trigger 5 event
     */
    inline void toggle_SWTRIG_SWT5() volatile
    {
        SWTRIG ^= 1u << 5u;
    }

    /**
     * Get SWTRIG's SWT4 bit.
     *
     * Software trigger 4 event
     */
    inline bool get_SWTRIG_SWT4() volatile
    {
        return SWTRIG & (1u << 4u);
    }

    /**
     * Set SWTRIG's SWT4 bit.
     *
     * Software trigger 4 event
     */
    inline void set_SWTRIG_SWT4() volatile
    {
        SWTRIG |= 1u << 4u;
    }

    /**
     * Clear SWTRIG's SWT4 bit.
     *
     * Software trigger 4 event
     */
    inline void clear_SWTRIG_SWT4() volatile
    {
        SWTRIG &= ~(1u << 4u);
    }

    /**
     * Toggle SWTRIG's SWT4 bit.
     *
     * Software trigger 4 event
     */
    inline void toggle_SWTRIG_SWT4() volatile
    {
        SWTRIG ^= 1u << 4u;
    }

    /**
     * Get SWTRIG's SWT3 bit.
     *
     * Software trigger 3 event
     */
    inline bool get_SWTRIG_SWT3() volatile
    {
        return SWTRIG & (1u << 3u);
    }

    /**
     * Set SWTRIG's SWT3 bit.
     *
     * Software trigger 3 event
     */
    inline void set_SWTRIG_SWT3() volatile
    {
        SWTRIG |= 1u << 3u;
    }

    /**
     * Clear SWTRIG's SWT3 bit.
     *
     * Software trigger 3 event
     */
    inline void clear_SWTRIG_SWT3() volatile
    {
        SWTRIG &= ~(1u << 3u);
    }

    /**
     * Toggle SWTRIG's SWT3 bit.
     *
     * Software trigger 3 event
     */
    inline void toggle_SWTRIG_SWT3() volatile
    {
        SWTRIG ^= 1u << 3u;
    }

    /**
     * Get SWTRIG's SWT2 bit.
     *
     * Software trigger 2 event
     */
    inline bool get_SWTRIG_SWT2() volatile
    {
        return SWTRIG & (1u << 2u);
    }

    /**
     * Set SWTRIG's SWT2 bit.
     *
     * Software trigger 2 event
     */
    inline void set_SWTRIG_SWT2() volatile
    {
        SWTRIG |= 1u << 2u;
    }

    /**
     * Clear SWTRIG's SWT2 bit.
     *
     * Software trigger 2 event
     */
    inline void clear_SWTRIG_SWT2() volatile
    {
        SWTRIG &= ~(1u << 2u);
    }

    /**
     * Toggle SWTRIG's SWT2 bit.
     *
     * Software trigger 2 event
     */
    inline void toggle_SWTRIG_SWT2() volatile
    {
        SWTRIG ^= 1u << 2u;
    }

    /**
     * Get SWTRIG's SWT1 bit.
     *
     * Software trigger 1 event
     */
    inline bool get_SWTRIG_SWT1() volatile
    {
        return SWTRIG & (1u << 1u);
    }

    /**
     * Set SWTRIG's SWT1 bit.
     *
     * Software trigger 1 event
     */
    inline void set_SWTRIG_SWT1() volatile
    {
        SWTRIG |= 1u << 1u;
    }

    /**
     * Clear SWTRIG's SWT1 bit.
     *
     * Software trigger 1 event
     */
    inline void clear_SWTRIG_SWT1() volatile
    {
        SWTRIG &= ~(1u << 1u);
    }

    /**
     * Toggle SWTRIG's SWT1 bit.
     *
     * Software trigger 1 event
     */
    inline void toggle_SWTRIG_SWT1() volatile
    {
        SWTRIG ^= 1u << 1u;
    }

    /**
     * Get SWTRIG's SWT0 bit.
     *
     * Software trigger 0 event
     */
    inline bool get_SWTRIG_SWT0() volatile
    {
        return SWTRIG & (1u << 0u);
    }

    /**
     * Set SWTRIG's SWT0 bit.
     *
     * Software trigger 0 event
     */
    inline void set_SWTRIG_SWT0() volatile
    {
        SWTRIG |= 1u << 0u;
    }

    /**
     * Clear SWTRIG's SWT0 bit.
     *
     * Software trigger 0 event
     */
    inline void clear_SWTRIG_SWT0() volatile
    {
        SWTRIG &= ~(1u << 0u);
    }

    /**
     * Toggle SWTRIG's SWT0 bit.
     *
     * Software trigger 0 event
     */
    inline void toggle_SWTRIG_SWT0() volatile
    {
        SWTRIG ^= 1u << 0u;
    }

    /**
     * Get all of SWTRIG's bit fields.
     *
     * (read-write) Software Trigger Register
     */
    inline void get_SWTRIG(bool &SWT7, bool &SWT6, bool &SWT5, bool &SWT4,
                           bool &SWT3, bool &SWT2, bool &SWT1,
                           bool &SWT0) volatile
    {
        uint32_t curr = SWTRIG;

        SWT7 = curr & (1u << 7u);
        SWT6 = curr & (1u << 6u);
        SWT5 = curr & (1u << 5u);
        SWT4 = curr & (1u << 4u);
        SWT3 = curr & (1u << 3u);
        SWT2 = curr & (1u << 2u);
        SWT1 = curr & (1u << 1u);
        SWT0 = curr & (1u << 0u);
    }

    /**
     * Set all of SWTRIG's bit fields.
     *
     * (read-write) Software Trigger Register
     */
    inline void set_SWTRIG(bool SWT7, bool SWT6, bool SWT5, bool SWT4,
                           bool SWT3, bool SWT2, bool SWT1, bool SWT0) volatile
    {
        uint32_t curr = SWTRIG;

        curr &= ~(0b1u << 7u);
        curr |= (SWT7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (SWT6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (SWT5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SWT4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SWT3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SWT2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SWT1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SWT0 & 0b1u) << 0u;

        SWTRIG = curr;
    }

    /**
     * Get TCTRL's TCMD field.
     *
     * Trigger command select
     */
    inline LPADC1_TCTRL_TCMD get_TCTRL_TCMD(std::size_t index) volatile
    {
        return LPADC1_TCTRL_TCMD((TCTRL[index] >> 24u) & 0b1111u);
    }

    /**
     * Set TCTRL's TCMD field.
     *
     * Trigger command select
     */
    inline void set_TCTRL_TCMD(std::size_t index,
                               LPADC1_TCTRL_TCMD value) volatile
    {
        uint32_t curr = TCTRL[index];

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        TCTRL[index] = curr;
    }

    /**
     * Get TCTRL's TDLY field.
     *
     * Trigger delay select
     */
    inline uint8_t get_TCTRL_TDLY(std::size_t index) volatile
    {
        return (TCTRL[index] >> 16u) & 0b1111u;
    }

    /**
     * Set TCTRL's TDLY field.
     *
     * Trigger delay select
     */
    inline void set_TCTRL_TDLY(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = TCTRL[index];

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        TCTRL[index] = curr;
    }

    /**
     * Get TCTRL's TPRI field.
     *
     * Trigger priority setting
     */
    inline LPADC1_TCTRL_TPRI get_TCTRL_TPRI(std::size_t index) volatile
    {
        return LPADC1_TCTRL_TPRI((TCTRL[index] >> 8u) & 0b111u);
    }

    /**
     * Set TCTRL's TPRI field.
     *
     * Trigger priority setting
     */
    inline void set_TCTRL_TPRI(std::size_t index,
                               LPADC1_TCTRL_TPRI value) volatile
    {
        uint32_t curr = TCTRL[index];

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        TCTRL[index] = curr;
    }

    /**
     * Get TCTRL's CMD_SEL bit.
     *
     * The command number is selected by software TCMD or hardware tcmd signal
     */
    inline bool get_TCTRL_CMD_SEL(std::size_t index) volatile
    {
        return TCTRL[index] & (1u << 1u);
    }

    /**
     * Set TCTRL's CMD_SEL bit.
     *
     * The command number is selected by software TCMD or hardware tcmd signal
     */
    inline void set_TCTRL_CMD_SEL() volatile
    {
        TCTRL |= 1u << 1u;
    }

    /**
     * Clear TCTRL's CMD_SEL bit.
     *
     * The command number is selected by software TCMD or hardware tcmd signal
     */
    inline void clear_TCTRL_CMD_SEL() volatile
    {
        TCTRL &= ~(1u << 1u);
    }

    /**
     * Toggle TCTRL's CMD_SEL bit.
     *
     * The command number is selected by software TCMD or hardware tcmd signal
     */
    inline void toggle_TCTRL_CMD_SEL() volatile
    {
        TCTRL ^= 1u << 1u;
    }

    /**
     * Get TCTRL's HTEN bit.
     *
     * Trigger enable
     */
    inline bool get_TCTRL_HTEN(std::size_t index) volatile
    {
        return TCTRL[index] & (1u << 0u);
    }

    /**
     * Set TCTRL's HTEN bit.
     *
     * Trigger enable
     */
    inline void set_TCTRL_HTEN() volatile
    {
        TCTRL |= 1u << 0u;
    }

    /**
     * Clear TCTRL's HTEN bit.
     *
     * Trigger enable
     */
    inline void clear_TCTRL_HTEN() volatile
    {
        TCTRL &= ~(1u << 0u);
    }

    /**
     * Toggle TCTRL's HTEN bit.
     *
     * Trigger enable
     */
    inline void toggle_TCTRL_HTEN() volatile
    {
        TCTRL ^= 1u << 0u;
    }

    /**
     * Get all of TCTRL's bit fields.
     *
     * (read-write) Trigger Control Register
     */
    inline void get_TCTRL(std::size_t index, LPADC1_TCTRL_TCMD &TCMD,
                          uint8_t &TDLY, LPADC1_TCTRL_TPRI &TPRI,
                          bool &CMD_SEL, bool &HTEN) volatile
    {
        uint32_t curr = TCTRL[index];

        TCMD = LPADC1_TCTRL_TCMD((curr >> 24u) & 0b1111u);
        TDLY = (curr >> 16u) & 0b1111u;
        TPRI = LPADC1_TCTRL_TPRI((curr >> 8u) & 0b111u);
        CMD_SEL = curr & (1u << 1u);
        HTEN = curr & (1u << 0u);
    }

    /**
     * Set all of TCTRL's bit fields.
     *
     * (read-write) Trigger Control Register
     */
    inline void set_TCTRL(std::size_t index, LPADC1_TCTRL_TCMD TCMD,
                          uint8_t TDLY, LPADC1_TCTRL_TPRI TPRI, bool CMD_SEL,
                          bool HTEN) volatile
    {
        uint32_t curr = TCTRL[index];

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(TCMD) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (TDLY & 0b1111u) << 16u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(TPRI) & 0b111u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (CMD_SEL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (HTEN & 0b1u) << 0u;

        TCTRL[index] = curr;
    }

    /**
     * Get CMDL1's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL1_CSCALE() volatile
    {
        return CMDL1 & (1u << 13u);
    }

    /**
     * Set CMDL1's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL1_CSCALE() volatile
    {
        CMDL1 |= 1u << 13u;
    }

    /**
     * Clear CMDL1's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL1_CSCALE() volatile
    {
        CMDL1 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL1's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL1_CSCALE() volatile
    {
        CMDL1 ^= 1u << 13u;
    }

    /**
     * Get CMDL1's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL1_DIFF() volatile
    {
        return CMDL1 & (1u << 6u);
    }

    /**
     * Set CMDL1's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL1_DIFF() volatile
    {
        CMDL1 |= 1u << 6u;
    }

    /**
     * Clear CMDL1's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL1_DIFF() volatile
    {
        CMDL1 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL1's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL1_DIFF() volatile
    {
        CMDL1 ^= 1u << 6u;
    }

    /**
     * Get CMDL1's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL1_ABSEL() volatile
    {
        return CMDL1 & (1u << 5u);
    }

    /**
     * Set CMDL1's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL1_ABSEL() volatile
    {
        CMDL1 |= 1u << 5u;
    }

    /**
     * Clear CMDL1's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL1_ABSEL() volatile
    {
        CMDL1 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL1's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL1_ABSEL() volatile
    {
        CMDL1 ^= 1u << 5u;
    }

    /**
     * Get CMDL1's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL1_ADCH get_CMDL1_ADCH() volatile
    {
        return LPADC1_CMDL1_ADCH((CMDL1 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL1's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL1_ADCH(LPADC1_CMDL1_ADCH value) volatile
    {
        uint32_t curr = CMDL1;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL1 = curr;
    }

    /**
     * Get all of CMDL1's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL1(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL1_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL1;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL1_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL1's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL1(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL1_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL1;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL1 = curr;
    }

    /**
     * Get CMDH1's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH1_NEXT get_CMDH1_NEXT() volatile
    {
        return LPADC1_CMDH1_NEXT((CMDH1 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH1's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH1_NEXT(LPADC1_CMDH1_NEXT value) volatile
    {
        uint32_t curr = CMDH1;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH1 = curr;
    }

    /**
     * Get CMDH1's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH1_LOOP get_CMDH1_LOOP() volatile
    {
        return LPADC1_CMDH1_LOOP((CMDH1 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH1's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH1_LOOP(LPADC1_CMDH1_LOOP value) volatile
    {
        uint32_t curr = CMDH1;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH1 = curr;
    }

    /**
     * Get CMDH1's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH1_AVGS get_CMDH1_AVGS() volatile
    {
        return LPADC1_CMDH1_AVGS((CMDH1 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH1's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH1_AVGS(LPADC1_CMDH1_AVGS value) volatile
    {
        uint32_t curr = CMDH1;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH1 = curr;
    }

    /**
     * Get CMDH1's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH1_STS get_CMDH1_STS() volatile
    {
        return LPADC1_CMDH1_STS((CMDH1 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH1's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH1_STS(LPADC1_CMDH1_STS value) volatile
    {
        uint32_t curr = CMDH1;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH1 = curr;
    }

    /**
     * Get CMDH1's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH1_LWI() volatile
    {
        return CMDH1 & (1u << 7u);
    }

    /**
     * Set CMDH1's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH1_LWI() volatile
    {
        CMDH1 |= 1u << 7u;
    }

    /**
     * Clear CMDH1's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH1_LWI() volatile
    {
        CMDH1 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH1's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH1_LWI() volatile
    {
        CMDH1 ^= 1u << 7u;
    }

    /**
     * Get CMDH1's CMPEN field.
     *
     * Compare Function Enable
     */
    inline LPADC1_CMDH1_CMPEN get_CMDH1_CMPEN() volatile
    {
        return LPADC1_CMDH1_CMPEN((CMDH1 >> 0u) & 0b11u);
    }

    /**
     * Set CMDH1's CMPEN field.
     *
     * Compare Function Enable
     */
    inline void set_CMDH1_CMPEN(LPADC1_CMDH1_CMPEN value) volatile
    {
        uint32_t curr = CMDH1;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CMDH1 = curr;
    }

    /**
     * Get all of CMDH1's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH1(LPADC1_CMDH1_NEXT &NEXT, LPADC1_CMDH1_LOOP &LOOP,
                          LPADC1_CMDH1_AVGS &AVGS, LPADC1_CMDH1_STS &STS,
                          bool &LWI, LPADC1_CMDH1_CMPEN &CMPEN) volatile
    {
        uint32_t curr = CMDH1;

        NEXT = LPADC1_CMDH1_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH1_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH1_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH1_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
        CMPEN = LPADC1_CMDH1_CMPEN((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CMDH1's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH1(LPADC1_CMDH1_NEXT NEXT, LPADC1_CMDH1_LOOP LOOP,
                          LPADC1_CMDH1_AVGS AVGS, LPADC1_CMDH1_STS STS,
                          bool LWI, LPADC1_CMDH1_CMPEN CMPEN) volatile
    {
        uint32_t curr = CMDH1;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CMPEN) & 0b11u) << 0u;

        CMDH1 = curr;
    }

    /**
     * Get CMDL2's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL2_CSCALE() volatile
    {
        return CMDL2 & (1u << 13u);
    }

    /**
     * Set CMDL2's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL2_CSCALE() volatile
    {
        CMDL2 |= 1u << 13u;
    }

    /**
     * Clear CMDL2's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL2_CSCALE() volatile
    {
        CMDL2 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL2's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL2_CSCALE() volatile
    {
        CMDL2 ^= 1u << 13u;
    }

    /**
     * Get CMDL2's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL2_DIFF() volatile
    {
        return CMDL2 & (1u << 6u);
    }

    /**
     * Set CMDL2's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL2_DIFF() volatile
    {
        CMDL2 |= 1u << 6u;
    }

    /**
     * Clear CMDL2's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL2_DIFF() volatile
    {
        CMDL2 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL2's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL2_DIFF() volatile
    {
        CMDL2 ^= 1u << 6u;
    }

    /**
     * Get CMDL2's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL2_ABSEL() volatile
    {
        return CMDL2 & (1u << 5u);
    }

    /**
     * Set CMDL2's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL2_ABSEL() volatile
    {
        CMDL2 |= 1u << 5u;
    }

    /**
     * Clear CMDL2's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL2_ABSEL() volatile
    {
        CMDL2 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL2's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL2_ABSEL() volatile
    {
        CMDL2 ^= 1u << 5u;
    }

    /**
     * Get CMDL2's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL2_ADCH get_CMDL2_ADCH() volatile
    {
        return LPADC1_CMDL2_ADCH((CMDL2 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL2's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL2_ADCH(LPADC1_CMDL2_ADCH value) volatile
    {
        uint32_t curr = CMDL2;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL2 = curr;
    }

    /**
     * Get all of CMDL2's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL2(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL2_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL2;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL2_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL2's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL2(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL2_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL2;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL2 = curr;
    }

    /**
     * Get CMDH2's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH2_NEXT get_CMDH2_NEXT() volatile
    {
        return LPADC1_CMDH2_NEXT((CMDH2 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH2's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH2_NEXT(LPADC1_CMDH2_NEXT value) volatile
    {
        uint32_t curr = CMDH2;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH2 = curr;
    }

    /**
     * Get CMDH2's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH2_LOOP get_CMDH2_LOOP() volatile
    {
        return LPADC1_CMDH2_LOOP((CMDH2 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH2's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH2_LOOP(LPADC1_CMDH2_LOOP value) volatile
    {
        uint32_t curr = CMDH2;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH2 = curr;
    }

    /**
     * Get CMDH2's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH2_AVGS get_CMDH2_AVGS() volatile
    {
        return LPADC1_CMDH2_AVGS((CMDH2 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH2's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH2_AVGS(LPADC1_CMDH2_AVGS value) volatile
    {
        uint32_t curr = CMDH2;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH2 = curr;
    }

    /**
     * Get CMDH2's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH2_STS get_CMDH2_STS() volatile
    {
        return LPADC1_CMDH2_STS((CMDH2 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH2's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH2_STS(LPADC1_CMDH2_STS value) volatile
    {
        uint32_t curr = CMDH2;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH2 = curr;
    }

    /**
     * Get CMDH2's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH2_LWI() volatile
    {
        return CMDH2 & (1u << 7u);
    }

    /**
     * Set CMDH2's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH2_LWI() volatile
    {
        CMDH2 |= 1u << 7u;
    }

    /**
     * Clear CMDH2's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH2_LWI() volatile
    {
        CMDH2 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH2's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH2_LWI() volatile
    {
        CMDH2 ^= 1u << 7u;
    }

    /**
     * Get CMDH2's CMPEN field.
     *
     * Compare Function Enable
     */
    inline LPADC1_CMDH2_CMPEN get_CMDH2_CMPEN() volatile
    {
        return LPADC1_CMDH2_CMPEN((CMDH2 >> 0u) & 0b11u);
    }

    /**
     * Set CMDH2's CMPEN field.
     *
     * Compare Function Enable
     */
    inline void set_CMDH2_CMPEN(LPADC1_CMDH2_CMPEN value) volatile
    {
        uint32_t curr = CMDH2;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CMDH2 = curr;
    }

    /**
     * Get all of CMDH2's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH2(LPADC1_CMDH2_NEXT &NEXT, LPADC1_CMDH2_LOOP &LOOP,
                          LPADC1_CMDH2_AVGS &AVGS, LPADC1_CMDH2_STS &STS,
                          bool &LWI, LPADC1_CMDH2_CMPEN &CMPEN) volatile
    {
        uint32_t curr = CMDH2;

        NEXT = LPADC1_CMDH2_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH2_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH2_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH2_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
        CMPEN = LPADC1_CMDH2_CMPEN((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CMDH2's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH2(LPADC1_CMDH2_NEXT NEXT, LPADC1_CMDH2_LOOP LOOP,
                          LPADC1_CMDH2_AVGS AVGS, LPADC1_CMDH2_STS STS,
                          bool LWI, LPADC1_CMDH2_CMPEN CMPEN) volatile
    {
        uint32_t curr = CMDH2;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CMPEN) & 0b11u) << 0u;

        CMDH2 = curr;
    }

    /**
     * Get CMDL3's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL3_CSCALE() volatile
    {
        return CMDL3 & (1u << 13u);
    }

    /**
     * Set CMDL3's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL3_CSCALE() volatile
    {
        CMDL3 |= 1u << 13u;
    }

    /**
     * Clear CMDL3's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL3_CSCALE() volatile
    {
        CMDL3 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL3's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL3_CSCALE() volatile
    {
        CMDL3 ^= 1u << 13u;
    }

    /**
     * Get CMDL3's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL3_DIFF() volatile
    {
        return CMDL3 & (1u << 6u);
    }

    /**
     * Set CMDL3's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL3_DIFF() volatile
    {
        CMDL3 |= 1u << 6u;
    }

    /**
     * Clear CMDL3's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL3_DIFF() volatile
    {
        CMDL3 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL3's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL3_DIFF() volatile
    {
        CMDL3 ^= 1u << 6u;
    }

    /**
     * Get CMDL3's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL3_ABSEL() volatile
    {
        return CMDL3 & (1u << 5u);
    }

    /**
     * Set CMDL3's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL3_ABSEL() volatile
    {
        CMDL3 |= 1u << 5u;
    }

    /**
     * Clear CMDL3's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL3_ABSEL() volatile
    {
        CMDL3 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL3's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL3_ABSEL() volatile
    {
        CMDL3 ^= 1u << 5u;
    }

    /**
     * Get CMDL3's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL3_ADCH get_CMDL3_ADCH() volatile
    {
        return LPADC1_CMDL3_ADCH((CMDL3 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL3's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL3_ADCH(LPADC1_CMDL3_ADCH value) volatile
    {
        uint32_t curr = CMDL3;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL3 = curr;
    }

    /**
     * Get all of CMDL3's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL3(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL3_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL3;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL3_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL3's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL3(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL3_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL3;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL3 = curr;
    }

    /**
     * Get CMDH3's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH3_NEXT get_CMDH3_NEXT() volatile
    {
        return LPADC1_CMDH3_NEXT((CMDH3 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH3's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH3_NEXT(LPADC1_CMDH3_NEXT value) volatile
    {
        uint32_t curr = CMDH3;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH3 = curr;
    }

    /**
     * Get CMDH3's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH3_LOOP get_CMDH3_LOOP() volatile
    {
        return LPADC1_CMDH3_LOOP((CMDH3 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH3's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH3_LOOP(LPADC1_CMDH3_LOOP value) volatile
    {
        uint32_t curr = CMDH3;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH3 = curr;
    }

    /**
     * Get CMDH3's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH3_AVGS get_CMDH3_AVGS() volatile
    {
        return LPADC1_CMDH3_AVGS((CMDH3 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH3's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH3_AVGS(LPADC1_CMDH3_AVGS value) volatile
    {
        uint32_t curr = CMDH3;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH3 = curr;
    }

    /**
     * Get CMDH3's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH3_STS get_CMDH3_STS() volatile
    {
        return LPADC1_CMDH3_STS((CMDH3 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH3's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH3_STS(LPADC1_CMDH3_STS value) volatile
    {
        uint32_t curr = CMDH3;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH3 = curr;
    }

    /**
     * Get CMDH3's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH3_LWI() volatile
    {
        return CMDH3 & (1u << 7u);
    }

    /**
     * Set CMDH3's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH3_LWI() volatile
    {
        CMDH3 |= 1u << 7u;
    }

    /**
     * Clear CMDH3's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH3_LWI() volatile
    {
        CMDH3 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH3's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH3_LWI() volatile
    {
        CMDH3 ^= 1u << 7u;
    }

    /**
     * Get CMDH3's CMPEN field.
     *
     * Compare Function Enable
     */
    inline LPADC1_CMDH3_CMPEN get_CMDH3_CMPEN() volatile
    {
        return LPADC1_CMDH3_CMPEN((CMDH3 >> 0u) & 0b11u);
    }

    /**
     * Set CMDH3's CMPEN field.
     *
     * Compare Function Enable
     */
    inline void set_CMDH3_CMPEN(LPADC1_CMDH3_CMPEN value) volatile
    {
        uint32_t curr = CMDH3;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CMDH3 = curr;
    }

    /**
     * Get all of CMDH3's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH3(LPADC1_CMDH3_NEXT &NEXT, LPADC1_CMDH3_LOOP &LOOP,
                          LPADC1_CMDH3_AVGS &AVGS, LPADC1_CMDH3_STS &STS,
                          bool &LWI, LPADC1_CMDH3_CMPEN &CMPEN) volatile
    {
        uint32_t curr = CMDH3;

        NEXT = LPADC1_CMDH3_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH3_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH3_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH3_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
        CMPEN = LPADC1_CMDH3_CMPEN((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CMDH3's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH3(LPADC1_CMDH3_NEXT NEXT, LPADC1_CMDH3_LOOP LOOP,
                          LPADC1_CMDH3_AVGS AVGS, LPADC1_CMDH3_STS STS,
                          bool LWI, LPADC1_CMDH3_CMPEN CMPEN) volatile
    {
        uint32_t curr = CMDH3;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CMPEN) & 0b11u) << 0u;

        CMDH3 = curr;
    }

    /**
     * Get CMDL4's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL4_CSCALE() volatile
    {
        return CMDL4 & (1u << 13u);
    }

    /**
     * Set CMDL4's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL4_CSCALE() volatile
    {
        CMDL4 |= 1u << 13u;
    }

    /**
     * Clear CMDL4's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL4_CSCALE() volatile
    {
        CMDL4 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL4's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL4_CSCALE() volatile
    {
        CMDL4 ^= 1u << 13u;
    }

    /**
     * Get CMDL4's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL4_DIFF() volatile
    {
        return CMDL4 & (1u << 6u);
    }

    /**
     * Set CMDL4's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL4_DIFF() volatile
    {
        CMDL4 |= 1u << 6u;
    }

    /**
     * Clear CMDL4's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL4_DIFF() volatile
    {
        CMDL4 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL4's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL4_DIFF() volatile
    {
        CMDL4 ^= 1u << 6u;
    }

    /**
     * Get CMDL4's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL4_ABSEL() volatile
    {
        return CMDL4 & (1u << 5u);
    }

    /**
     * Set CMDL4's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL4_ABSEL() volatile
    {
        CMDL4 |= 1u << 5u;
    }

    /**
     * Clear CMDL4's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL4_ABSEL() volatile
    {
        CMDL4 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL4's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL4_ABSEL() volatile
    {
        CMDL4 ^= 1u << 5u;
    }

    /**
     * Get CMDL4's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL4_ADCH get_CMDL4_ADCH() volatile
    {
        return LPADC1_CMDL4_ADCH((CMDL4 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL4's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL4_ADCH(LPADC1_CMDL4_ADCH value) volatile
    {
        uint32_t curr = CMDL4;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL4 = curr;
    }

    /**
     * Get all of CMDL4's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL4(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL4_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL4;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL4_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL4's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL4(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL4_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL4;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL4 = curr;
    }

    /**
     * Get CMDH4's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH4_NEXT get_CMDH4_NEXT() volatile
    {
        return LPADC1_CMDH4_NEXT((CMDH4 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH4's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH4_NEXT(LPADC1_CMDH4_NEXT value) volatile
    {
        uint32_t curr = CMDH4;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH4 = curr;
    }

    /**
     * Get CMDH4's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH4_LOOP get_CMDH4_LOOP() volatile
    {
        return LPADC1_CMDH4_LOOP((CMDH4 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH4's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH4_LOOP(LPADC1_CMDH4_LOOP value) volatile
    {
        uint32_t curr = CMDH4;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH4 = curr;
    }

    /**
     * Get CMDH4's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH4_AVGS get_CMDH4_AVGS() volatile
    {
        return LPADC1_CMDH4_AVGS((CMDH4 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH4's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH4_AVGS(LPADC1_CMDH4_AVGS value) volatile
    {
        uint32_t curr = CMDH4;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH4 = curr;
    }

    /**
     * Get CMDH4's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH4_STS get_CMDH4_STS() volatile
    {
        return LPADC1_CMDH4_STS((CMDH4 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH4's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH4_STS(LPADC1_CMDH4_STS value) volatile
    {
        uint32_t curr = CMDH4;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH4 = curr;
    }

    /**
     * Get CMDH4's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH4_LWI() volatile
    {
        return CMDH4 & (1u << 7u);
    }

    /**
     * Set CMDH4's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH4_LWI() volatile
    {
        CMDH4 |= 1u << 7u;
    }

    /**
     * Clear CMDH4's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH4_LWI() volatile
    {
        CMDH4 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH4's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH4_LWI() volatile
    {
        CMDH4 ^= 1u << 7u;
    }

    /**
     * Get CMDH4's CMPEN field.
     *
     * Compare Function Enable
     */
    inline LPADC1_CMDH4_CMPEN get_CMDH4_CMPEN() volatile
    {
        return LPADC1_CMDH4_CMPEN((CMDH4 >> 0u) & 0b11u);
    }

    /**
     * Set CMDH4's CMPEN field.
     *
     * Compare Function Enable
     */
    inline void set_CMDH4_CMPEN(LPADC1_CMDH4_CMPEN value) volatile
    {
        uint32_t curr = CMDH4;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CMDH4 = curr;
    }

    /**
     * Get all of CMDH4's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH4(LPADC1_CMDH4_NEXT &NEXT, LPADC1_CMDH4_LOOP &LOOP,
                          LPADC1_CMDH4_AVGS &AVGS, LPADC1_CMDH4_STS &STS,
                          bool &LWI, LPADC1_CMDH4_CMPEN &CMPEN) volatile
    {
        uint32_t curr = CMDH4;

        NEXT = LPADC1_CMDH4_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH4_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH4_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH4_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
        CMPEN = LPADC1_CMDH4_CMPEN((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CMDH4's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH4(LPADC1_CMDH4_NEXT NEXT, LPADC1_CMDH4_LOOP LOOP,
                          LPADC1_CMDH4_AVGS AVGS, LPADC1_CMDH4_STS STS,
                          bool LWI, LPADC1_CMDH4_CMPEN CMPEN) volatile
    {
        uint32_t curr = CMDH4;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CMPEN) & 0b11u) << 0u;

        CMDH4 = curr;
    }

    /**
     * Get CMDL5's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL5_CSCALE() volatile
    {
        return CMDL5 & (1u << 13u);
    }

    /**
     * Set CMDL5's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL5_CSCALE() volatile
    {
        CMDL5 |= 1u << 13u;
    }

    /**
     * Clear CMDL5's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL5_CSCALE() volatile
    {
        CMDL5 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL5's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL5_CSCALE() volatile
    {
        CMDL5 ^= 1u << 13u;
    }

    /**
     * Get CMDL5's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL5_DIFF() volatile
    {
        return CMDL5 & (1u << 6u);
    }

    /**
     * Set CMDL5's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL5_DIFF() volatile
    {
        CMDL5 |= 1u << 6u;
    }

    /**
     * Clear CMDL5's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL5_DIFF() volatile
    {
        CMDL5 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL5's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL5_DIFF() volatile
    {
        CMDL5 ^= 1u << 6u;
    }

    /**
     * Get CMDL5's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL5_ABSEL() volatile
    {
        return CMDL5 & (1u << 5u);
    }

    /**
     * Set CMDL5's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL5_ABSEL() volatile
    {
        CMDL5 |= 1u << 5u;
    }

    /**
     * Clear CMDL5's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL5_ABSEL() volatile
    {
        CMDL5 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL5's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL5_ABSEL() volatile
    {
        CMDL5 ^= 1u << 5u;
    }

    /**
     * Get CMDL5's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL5_ADCH get_CMDL5_ADCH() volatile
    {
        return LPADC1_CMDL5_ADCH((CMDL5 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL5's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL5_ADCH(LPADC1_CMDL5_ADCH value) volatile
    {
        uint32_t curr = CMDL5;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL5 = curr;
    }

    /**
     * Get all of CMDL5's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL5(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL5_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL5;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL5_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL5's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL5(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL5_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL5;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL5 = curr;
    }

    /**
     * Get CMDH5's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH5_NEXT get_CMDH5_NEXT() volatile
    {
        return LPADC1_CMDH5_NEXT((CMDH5 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH5's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH5_NEXT(LPADC1_CMDH5_NEXT value) volatile
    {
        uint32_t curr = CMDH5;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH5 = curr;
    }

    /**
     * Get CMDH5's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH5_LOOP get_CMDH5_LOOP() volatile
    {
        return LPADC1_CMDH5_LOOP((CMDH5 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH5's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH5_LOOP(LPADC1_CMDH5_LOOP value) volatile
    {
        uint32_t curr = CMDH5;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH5 = curr;
    }

    /**
     * Get CMDH5's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH5_AVGS get_CMDH5_AVGS() volatile
    {
        return LPADC1_CMDH5_AVGS((CMDH5 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH5's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH5_AVGS(LPADC1_CMDH5_AVGS value) volatile
    {
        uint32_t curr = CMDH5;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH5 = curr;
    }

    /**
     * Get CMDH5's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH5_STS get_CMDH5_STS() volatile
    {
        return LPADC1_CMDH5_STS((CMDH5 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH5's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH5_STS(LPADC1_CMDH5_STS value) volatile
    {
        uint32_t curr = CMDH5;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH5 = curr;
    }

    /**
     * Get CMDH5's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH5_LWI() volatile
    {
        return CMDH5 & (1u << 7u);
    }

    /**
     * Set CMDH5's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH5_LWI() volatile
    {
        CMDH5 |= 1u << 7u;
    }

    /**
     * Clear CMDH5's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH5_LWI() volatile
    {
        CMDH5 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH5's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH5_LWI() volatile
    {
        CMDH5 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH5's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH5(LPADC1_CMDH5_NEXT &NEXT, LPADC1_CMDH5_LOOP &LOOP,
                          LPADC1_CMDH5_AVGS &AVGS, LPADC1_CMDH5_STS &STS,
                          bool &LWI) volatile
    {
        uint32_t curr = CMDH5;

        NEXT = LPADC1_CMDH5_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH5_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH5_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH5_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH5's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH5(LPADC1_CMDH5_NEXT NEXT, LPADC1_CMDH5_LOOP LOOP,
                          LPADC1_CMDH5_AVGS AVGS, LPADC1_CMDH5_STS STS,
                          bool LWI) volatile
    {
        uint32_t curr = CMDH5;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH5 = curr;
    }

    /**
     * Get CMDL6's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL6_CSCALE() volatile
    {
        return CMDL6 & (1u << 13u);
    }

    /**
     * Set CMDL6's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL6_CSCALE() volatile
    {
        CMDL6 |= 1u << 13u;
    }

    /**
     * Clear CMDL6's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL6_CSCALE() volatile
    {
        CMDL6 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL6's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL6_CSCALE() volatile
    {
        CMDL6 ^= 1u << 13u;
    }

    /**
     * Get CMDL6's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL6_DIFF() volatile
    {
        return CMDL6 & (1u << 6u);
    }

    /**
     * Set CMDL6's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL6_DIFF() volatile
    {
        CMDL6 |= 1u << 6u;
    }

    /**
     * Clear CMDL6's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL6_DIFF() volatile
    {
        CMDL6 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL6's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL6_DIFF() volatile
    {
        CMDL6 ^= 1u << 6u;
    }

    /**
     * Get CMDL6's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL6_ABSEL() volatile
    {
        return CMDL6 & (1u << 5u);
    }

    /**
     * Set CMDL6's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL6_ABSEL() volatile
    {
        CMDL6 |= 1u << 5u;
    }

    /**
     * Clear CMDL6's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL6_ABSEL() volatile
    {
        CMDL6 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL6's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL6_ABSEL() volatile
    {
        CMDL6 ^= 1u << 5u;
    }

    /**
     * Get CMDL6's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL6_ADCH get_CMDL6_ADCH() volatile
    {
        return LPADC1_CMDL6_ADCH((CMDL6 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL6's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL6_ADCH(LPADC1_CMDL6_ADCH value) volatile
    {
        uint32_t curr = CMDL6;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL6 = curr;
    }

    /**
     * Get all of CMDL6's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL6(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL6_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL6;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL6_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL6's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL6(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL6_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL6;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL6 = curr;
    }

    /**
     * Get CMDH6's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH6_NEXT get_CMDH6_NEXT() volatile
    {
        return LPADC1_CMDH6_NEXT((CMDH6 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH6's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH6_NEXT(LPADC1_CMDH6_NEXT value) volatile
    {
        uint32_t curr = CMDH6;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH6 = curr;
    }

    /**
     * Get CMDH6's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH6_LOOP get_CMDH6_LOOP() volatile
    {
        return LPADC1_CMDH6_LOOP((CMDH6 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH6's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH6_LOOP(LPADC1_CMDH6_LOOP value) volatile
    {
        uint32_t curr = CMDH6;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH6 = curr;
    }

    /**
     * Get CMDH6's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH6_AVGS get_CMDH6_AVGS() volatile
    {
        return LPADC1_CMDH6_AVGS((CMDH6 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH6's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH6_AVGS(LPADC1_CMDH6_AVGS value) volatile
    {
        uint32_t curr = CMDH6;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH6 = curr;
    }

    /**
     * Get CMDH6's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH6_STS get_CMDH6_STS() volatile
    {
        return LPADC1_CMDH6_STS((CMDH6 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH6's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH6_STS(LPADC1_CMDH6_STS value) volatile
    {
        uint32_t curr = CMDH6;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH6 = curr;
    }

    /**
     * Get CMDH6's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH6_LWI() volatile
    {
        return CMDH6 & (1u << 7u);
    }

    /**
     * Set CMDH6's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH6_LWI() volatile
    {
        CMDH6 |= 1u << 7u;
    }

    /**
     * Clear CMDH6's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH6_LWI() volatile
    {
        CMDH6 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH6's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH6_LWI() volatile
    {
        CMDH6 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH6's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH6(LPADC1_CMDH6_NEXT &NEXT, LPADC1_CMDH6_LOOP &LOOP,
                          LPADC1_CMDH6_AVGS &AVGS, LPADC1_CMDH6_STS &STS,
                          bool &LWI) volatile
    {
        uint32_t curr = CMDH6;

        NEXT = LPADC1_CMDH6_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH6_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH6_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH6_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH6's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH6(LPADC1_CMDH6_NEXT NEXT, LPADC1_CMDH6_LOOP LOOP,
                          LPADC1_CMDH6_AVGS AVGS, LPADC1_CMDH6_STS STS,
                          bool LWI) volatile
    {
        uint32_t curr = CMDH6;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH6 = curr;
    }

    /**
     * Get CMDL7's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL7_CSCALE() volatile
    {
        return CMDL7 & (1u << 13u);
    }

    /**
     * Set CMDL7's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL7_CSCALE() volatile
    {
        CMDL7 |= 1u << 13u;
    }

    /**
     * Clear CMDL7's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL7_CSCALE() volatile
    {
        CMDL7 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL7's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL7_CSCALE() volatile
    {
        CMDL7 ^= 1u << 13u;
    }

    /**
     * Get CMDL7's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL7_DIFF() volatile
    {
        return CMDL7 & (1u << 6u);
    }

    /**
     * Set CMDL7's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL7_DIFF() volatile
    {
        CMDL7 |= 1u << 6u;
    }

    /**
     * Clear CMDL7's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL7_DIFF() volatile
    {
        CMDL7 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL7's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL7_DIFF() volatile
    {
        CMDL7 ^= 1u << 6u;
    }

    /**
     * Get CMDL7's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL7_ABSEL() volatile
    {
        return CMDL7 & (1u << 5u);
    }

    /**
     * Set CMDL7's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL7_ABSEL() volatile
    {
        CMDL7 |= 1u << 5u;
    }

    /**
     * Clear CMDL7's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL7_ABSEL() volatile
    {
        CMDL7 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL7's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL7_ABSEL() volatile
    {
        CMDL7 ^= 1u << 5u;
    }

    /**
     * Get CMDL7's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL7_ADCH get_CMDL7_ADCH() volatile
    {
        return LPADC1_CMDL7_ADCH((CMDL7 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL7's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL7_ADCH(LPADC1_CMDL7_ADCH value) volatile
    {
        uint32_t curr = CMDL7;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL7 = curr;
    }

    /**
     * Get all of CMDL7's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL7(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL7_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL7;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL7_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL7's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL7(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL7_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL7;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL7 = curr;
    }

    /**
     * Get CMDH7's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH7_NEXT get_CMDH7_NEXT() volatile
    {
        return LPADC1_CMDH7_NEXT((CMDH7 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH7's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH7_NEXT(LPADC1_CMDH7_NEXT value) volatile
    {
        uint32_t curr = CMDH7;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH7 = curr;
    }

    /**
     * Get CMDH7's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH7_LOOP get_CMDH7_LOOP() volatile
    {
        return LPADC1_CMDH7_LOOP((CMDH7 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH7's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH7_LOOP(LPADC1_CMDH7_LOOP value) volatile
    {
        uint32_t curr = CMDH7;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH7 = curr;
    }

    /**
     * Get CMDH7's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH7_AVGS get_CMDH7_AVGS() volatile
    {
        return LPADC1_CMDH7_AVGS((CMDH7 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH7's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH7_AVGS(LPADC1_CMDH7_AVGS value) volatile
    {
        uint32_t curr = CMDH7;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH7 = curr;
    }

    /**
     * Get CMDH7's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH7_STS get_CMDH7_STS() volatile
    {
        return LPADC1_CMDH7_STS((CMDH7 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH7's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH7_STS(LPADC1_CMDH7_STS value) volatile
    {
        uint32_t curr = CMDH7;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH7 = curr;
    }

    /**
     * Get CMDH7's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH7_LWI() volatile
    {
        return CMDH7 & (1u << 7u);
    }

    /**
     * Set CMDH7's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH7_LWI() volatile
    {
        CMDH7 |= 1u << 7u;
    }

    /**
     * Clear CMDH7's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH7_LWI() volatile
    {
        CMDH7 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH7's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH7_LWI() volatile
    {
        CMDH7 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH7's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH7(LPADC1_CMDH7_NEXT &NEXT, LPADC1_CMDH7_LOOP &LOOP,
                          LPADC1_CMDH7_AVGS &AVGS, LPADC1_CMDH7_STS &STS,
                          bool &LWI) volatile
    {
        uint32_t curr = CMDH7;

        NEXT = LPADC1_CMDH7_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH7_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH7_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH7_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH7's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH7(LPADC1_CMDH7_NEXT NEXT, LPADC1_CMDH7_LOOP LOOP,
                          LPADC1_CMDH7_AVGS AVGS, LPADC1_CMDH7_STS STS,
                          bool LWI) volatile
    {
        uint32_t curr = CMDH7;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH7 = curr;
    }

    /**
     * Get CMDL8's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL8_CSCALE() volatile
    {
        return CMDL8 & (1u << 13u);
    }

    /**
     * Set CMDL8's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL8_CSCALE() volatile
    {
        CMDL8 |= 1u << 13u;
    }

    /**
     * Clear CMDL8's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL8_CSCALE() volatile
    {
        CMDL8 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL8's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL8_CSCALE() volatile
    {
        CMDL8 ^= 1u << 13u;
    }

    /**
     * Get CMDL8's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL8_DIFF() volatile
    {
        return CMDL8 & (1u << 6u);
    }

    /**
     * Set CMDL8's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL8_DIFF() volatile
    {
        CMDL8 |= 1u << 6u;
    }

    /**
     * Clear CMDL8's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL8_DIFF() volatile
    {
        CMDL8 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL8's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL8_DIFF() volatile
    {
        CMDL8 ^= 1u << 6u;
    }

    /**
     * Get CMDL8's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL8_ABSEL() volatile
    {
        return CMDL8 & (1u << 5u);
    }

    /**
     * Set CMDL8's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL8_ABSEL() volatile
    {
        CMDL8 |= 1u << 5u;
    }

    /**
     * Clear CMDL8's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL8_ABSEL() volatile
    {
        CMDL8 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL8's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL8_ABSEL() volatile
    {
        CMDL8 ^= 1u << 5u;
    }

    /**
     * Get CMDL8's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL8_ADCH get_CMDL8_ADCH() volatile
    {
        return LPADC1_CMDL8_ADCH((CMDL8 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL8's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL8_ADCH(LPADC1_CMDL8_ADCH value) volatile
    {
        uint32_t curr = CMDL8;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL8 = curr;
    }

    /**
     * Get all of CMDL8's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL8(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL8_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL8;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL8_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL8's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL8(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL8_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL8;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL8 = curr;
    }

    /**
     * Get CMDH8's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH8_NEXT get_CMDH8_NEXT() volatile
    {
        return LPADC1_CMDH8_NEXT((CMDH8 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH8's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH8_NEXT(LPADC1_CMDH8_NEXT value) volatile
    {
        uint32_t curr = CMDH8;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH8 = curr;
    }

    /**
     * Get CMDH8's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH8_LOOP get_CMDH8_LOOP() volatile
    {
        return LPADC1_CMDH8_LOOP((CMDH8 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH8's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH8_LOOP(LPADC1_CMDH8_LOOP value) volatile
    {
        uint32_t curr = CMDH8;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH8 = curr;
    }

    /**
     * Get CMDH8's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH8_AVGS get_CMDH8_AVGS() volatile
    {
        return LPADC1_CMDH8_AVGS((CMDH8 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH8's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH8_AVGS(LPADC1_CMDH8_AVGS value) volatile
    {
        uint32_t curr = CMDH8;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH8 = curr;
    }

    /**
     * Get CMDH8's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH8_STS get_CMDH8_STS() volatile
    {
        return LPADC1_CMDH8_STS((CMDH8 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH8's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH8_STS(LPADC1_CMDH8_STS value) volatile
    {
        uint32_t curr = CMDH8;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH8 = curr;
    }

    /**
     * Get CMDH8's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH8_LWI() volatile
    {
        return CMDH8 & (1u << 7u);
    }

    /**
     * Set CMDH8's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH8_LWI() volatile
    {
        CMDH8 |= 1u << 7u;
    }

    /**
     * Clear CMDH8's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH8_LWI() volatile
    {
        CMDH8 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH8's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH8_LWI() volatile
    {
        CMDH8 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH8's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH8(LPADC1_CMDH8_NEXT &NEXT, LPADC1_CMDH8_LOOP &LOOP,
                          LPADC1_CMDH8_AVGS &AVGS, LPADC1_CMDH8_STS &STS,
                          bool &LWI) volatile
    {
        uint32_t curr = CMDH8;

        NEXT = LPADC1_CMDH8_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH8_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH8_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH8_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH8's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH8(LPADC1_CMDH8_NEXT NEXT, LPADC1_CMDH8_LOOP LOOP,
                          LPADC1_CMDH8_AVGS AVGS, LPADC1_CMDH8_STS STS,
                          bool LWI) volatile
    {
        uint32_t curr = CMDH8;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH8 = curr;
    }

    /**
     * Get CMDL9's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL9_CSCALE() volatile
    {
        return CMDL9 & (1u << 13u);
    }

    /**
     * Set CMDL9's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL9_CSCALE() volatile
    {
        CMDL9 |= 1u << 13u;
    }

    /**
     * Clear CMDL9's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL9_CSCALE() volatile
    {
        CMDL9 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL9's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL9_CSCALE() volatile
    {
        CMDL9 ^= 1u << 13u;
    }

    /**
     * Get CMDL9's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL9_DIFF() volatile
    {
        return CMDL9 & (1u << 6u);
    }

    /**
     * Set CMDL9's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL9_DIFF() volatile
    {
        CMDL9 |= 1u << 6u;
    }

    /**
     * Clear CMDL9's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL9_DIFF() volatile
    {
        CMDL9 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL9's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL9_DIFF() volatile
    {
        CMDL9 ^= 1u << 6u;
    }

    /**
     * Get CMDL9's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL9_ABSEL() volatile
    {
        return CMDL9 & (1u << 5u);
    }

    /**
     * Set CMDL9's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL9_ABSEL() volatile
    {
        CMDL9 |= 1u << 5u;
    }

    /**
     * Clear CMDL9's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL9_ABSEL() volatile
    {
        CMDL9 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL9's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL9_ABSEL() volatile
    {
        CMDL9 ^= 1u << 5u;
    }

    /**
     * Get CMDL9's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL9_ADCH get_CMDL9_ADCH() volatile
    {
        return LPADC1_CMDL9_ADCH((CMDL9 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL9's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL9_ADCH(LPADC1_CMDL9_ADCH value) volatile
    {
        uint32_t curr = CMDL9;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL9 = curr;
    }

    /**
     * Get all of CMDL9's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL9(bool &CSCALE, bool &DIFF, bool &ABSEL,
                          LPADC1_CMDL9_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL9;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL9_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL9's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL9(bool CSCALE, bool DIFF, bool ABSEL,
                          LPADC1_CMDL9_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL9;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL9 = curr;
    }

    /**
     * Get CMDH9's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH9_NEXT get_CMDH9_NEXT() volatile
    {
        return LPADC1_CMDH9_NEXT((CMDH9 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH9's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH9_NEXT(LPADC1_CMDH9_NEXT value) volatile
    {
        uint32_t curr = CMDH9;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH9 = curr;
    }

    /**
     * Get CMDH9's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH9_LOOP get_CMDH9_LOOP() volatile
    {
        return LPADC1_CMDH9_LOOP((CMDH9 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH9's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH9_LOOP(LPADC1_CMDH9_LOOP value) volatile
    {
        uint32_t curr = CMDH9;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH9 = curr;
    }

    /**
     * Get CMDH9's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH9_AVGS get_CMDH9_AVGS() volatile
    {
        return LPADC1_CMDH9_AVGS((CMDH9 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH9's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH9_AVGS(LPADC1_CMDH9_AVGS value) volatile
    {
        uint32_t curr = CMDH9;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH9 = curr;
    }

    /**
     * Get CMDH9's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH9_STS get_CMDH9_STS() volatile
    {
        return LPADC1_CMDH9_STS((CMDH9 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH9's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH9_STS(LPADC1_CMDH9_STS value) volatile
    {
        uint32_t curr = CMDH9;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH9 = curr;
    }

    /**
     * Get CMDH9's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH9_LWI() volatile
    {
        return CMDH9 & (1u << 7u);
    }

    /**
     * Set CMDH9's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH9_LWI() volatile
    {
        CMDH9 |= 1u << 7u;
    }

    /**
     * Clear CMDH9's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH9_LWI() volatile
    {
        CMDH9 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH9's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH9_LWI() volatile
    {
        CMDH9 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH9's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH9(LPADC1_CMDH9_NEXT &NEXT, LPADC1_CMDH9_LOOP &LOOP,
                          LPADC1_CMDH9_AVGS &AVGS, LPADC1_CMDH9_STS &STS,
                          bool &LWI) volatile
    {
        uint32_t curr = CMDH9;

        NEXT = LPADC1_CMDH9_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH9_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH9_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH9_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH9's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH9(LPADC1_CMDH9_NEXT NEXT, LPADC1_CMDH9_LOOP LOOP,
                          LPADC1_CMDH9_AVGS AVGS, LPADC1_CMDH9_STS STS,
                          bool LWI) volatile
    {
        uint32_t curr = CMDH9;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH9 = curr;
    }

    /**
     * Get CMDL10's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL10_CSCALE() volatile
    {
        return CMDL10 & (1u << 13u);
    }

    /**
     * Set CMDL10's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL10_CSCALE() volatile
    {
        CMDL10 |= 1u << 13u;
    }

    /**
     * Clear CMDL10's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL10_CSCALE() volatile
    {
        CMDL10 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL10's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL10_CSCALE() volatile
    {
        CMDL10 ^= 1u << 13u;
    }

    /**
     * Get CMDL10's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL10_DIFF() volatile
    {
        return CMDL10 & (1u << 6u);
    }

    /**
     * Set CMDL10's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL10_DIFF() volatile
    {
        CMDL10 |= 1u << 6u;
    }

    /**
     * Clear CMDL10's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL10_DIFF() volatile
    {
        CMDL10 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL10's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL10_DIFF() volatile
    {
        CMDL10 ^= 1u << 6u;
    }

    /**
     * Get CMDL10's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL10_ABSEL() volatile
    {
        return CMDL10 & (1u << 5u);
    }

    /**
     * Set CMDL10's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL10_ABSEL() volatile
    {
        CMDL10 |= 1u << 5u;
    }

    /**
     * Clear CMDL10's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL10_ABSEL() volatile
    {
        CMDL10 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL10's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL10_ABSEL() volatile
    {
        CMDL10 ^= 1u << 5u;
    }

    /**
     * Get CMDL10's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL10_ADCH get_CMDL10_ADCH() volatile
    {
        return LPADC1_CMDL10_ADCH((CMDL10 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL10's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL10_ADCH(LPADC1_CMDL10_ADCH value) volatile
    {
        uint32_t curr = CMDL10;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL10 = curr;
    }

    /**
     * Get all of CMDL10's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL10(bool &CSCALE, bool &DIFF, bool &ABSEL,
                           LPADC1_CMDL10_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL10;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL10_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL10's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL10(bool CSCALE, bool DIFF, bool ABSEL,
                           LPADC1_CMDL10_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL10;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL10 = curr;
    }

    /**
     * Get CMDH10's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH10_NEXT get_CMDH10_NEXT() volatile
    {
        return LPADC1_CMDH10_NEXT((CMDH10 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH10's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH10_NEXT(LPADC1_CMDH10_NEXT value) volatile
    {
        uint32_t curr = CMDH10;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH10 = curr;
    }

    /**
     * Get CMDH10's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH10_LOOP get_CMDH10_LOOP() volatile
    {
        return LPADC1_CMDH10_LOOP((CMDH10 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH10's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH10_LOOP(LPADC1_CMDH10_LOOP value) volatile
    {
        uint32_t curr = CMDH10;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH10 = curr;
    }

    /**
     * Get CMDH10's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH10_AVGS get_CMDH10_AVGS() volatile
    {
        return LPADC1_CMDH10_AVGS((CMDH10 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH10's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH10_AVGS(LPADC1_CMDH10_AVGS value) volatile
    {
        uint32_t curr = CMDH10;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH10 = curr;
    }

    /**
     * Get CMDH10's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH10_STS get_CMDH10_STS() volatile
    {
        return LPADC1_CMDH10_STS((CMDH10 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH10's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH10_STS(LPADC1_CMDH10_STS value) volatile
    {
        uint32_t curr = CMDH10;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH10 = curr;
    }

    /**
     * Get CMDH10's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH10_LWI() volatile
    {
        return CMDH10 & (1u << 7u);
    }

    /**
     * Set CMDH10's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH10_LWI() volatile
    {
        CMDH10 |= 1u << 7u;
    }

    /**
     * Clear CMDH10's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH10_LWI() volatile
    {
        CMDH10 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH10's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH10_LWI() volatile
    {
        CMDH10 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH10's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH10(LPADC1_CMDH10_NEXT &NEXT, LPADC1_CMDH10_LOOP &LOOP,
                           LPADC1_CMDH10_AVGS &AVGS, LPADC1_CMDH10_STS &STS,
                           bool &LWI) volatile
    {
        uint32_t curr = CMDH10;

        NEXT = LPADC1_CMDH10_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH10_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH10_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH10_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH10's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH10(LPADC1_CMDH10_NEXT NEXT, LPADC1_CMDH10_LOOP LOOP,
                           LPADC1_CMDH10_AVGS AVGS, LPADC1_CMDH10_STS STS,
                           bool LWI) volatile
    {
        uint32_t curr = CMDH10;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH10 = curr;
    }

    /**
     * Get CMDL11's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL11_CSCALE() volatile
    {
        return CMDL11 & (1u << 13u);
    }

    /**
     * Set CMDL11's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL11_CSCALE() volatile
    {
        CMDL11 |= 1u << 13u;
    }

    /**
     * Clear CMDL11's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL11_CSCALE() volatile
    {
        CMDL11 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL11's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL11_CSCALE() volatile
    {
        CMDL11 ^= 1u << 13u;
    }

    /**
     * Get CMDL11's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL11_DIFF() volatile
    {
        return CMDL11 & (1u << 6u);
    }

    /**
     * Set CMDL11's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL11_DIFF() volatile
    {
        CMDL11 |= 1u << 6u;
    }

    /**
     * Clear CMDL11's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL11_DIFF() volatile
    {
        CMDL11 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL11's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL11_DIFF() volatile
    {
        CMDL11 ^= 1u << 6u;
    }

    /**
     * Get CMDL11's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL11_ABSEL() volatile
    {
        return CMDL11 & (1u << 5u);
    }

    /**
     * Set CMDL11's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL11_ABSEL() volatile
    {
        CMDL11 |= 1u << 5u;
    }

    /**
     * Clear CMDL11's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL11_ABSEL() volatile
    {
        CMDL11 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL11's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL11_ABSEL() volatile
    {
        CMDL11 ^= 1u << 5u;
    }

    /**
     * Get CMDL11's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL11_ADCH get_CMDL11_ADCH() volatile
    {
        return LPADC1_CMDL11_ADCH((CMDL11 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL11's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL11_ADCH(LPADC1_CMDL11_ADCH value) volatile
    {
        uint32_t curr = CMDL11;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL11 = curr;
    }

    /**
     * Get all of CMDL11's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL11(bool &CSCALE, bool &DIFF, bool &ABSEL,
                           LPADC1_CMDL11_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL11;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL11_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL11's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL11(bool CSCALE, bool DIFF, bool ABSEL,
                           LPADC1_CMDL11_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL11;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL11 = curr;
    }

    /**
     * Get CMDH11's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH11_NEXT get_CMDH11_NEXT() volatile
    {
        return LPADC1_CMDH11_NEXT((CMDH11 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH11's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH11_NEXT(LPADC1_CMDH11_NEXT value) volatile
    {
        uint32_t curr = CMDH11;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH11 = curr;
    }

    /**
     * Get CMDH11's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH11_LOOP get_CMDH11_LOOP() volatile
    {
        return LPADC1_CMDH11_LOOP((CMDH11 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH11's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH11_LOOP(LPADC1_CMDH11_LOOP value) volatile
    {
        uint32_t curr = CMDH11;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH11 = curr;
    }

    /**
     * Get CMDH11's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH11_AVGS get_CMDH11_AVGS() volatile
    {
        return LPADC1_CMDH11_AVGS((CMDH11 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH11's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH11_AVGS(LPADC1_CMDH11_AVGS value) volatile
    {
        uint32_t curr = CMDH11;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH11 = curr;
    }

    /**
     * Get CMDH11's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH11_STS get_CMDH11_STS() volatile
    {
        return LPADC1_CMDH11_STS((CMDH11 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH11's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH11_STS(LPADC1_CMDH11_STS value) volatile
    {
        uint32_t curr = CMDH11;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH11 = curr;
    }

    /**
     * Get CMDH11's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH11_LWI() volatile
    {
        return CMDH11 & (1u << 7u);
    }

    /**
     * Set CMDH11's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH11_LWI() volatile
    {
        CMDH11 |= 1u << 7u;
    }

    /**
     * Clear CMDH11's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH11_LWI() volatile
    {
        CMDH11 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH11's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH11_LWI() volatile
    {
        CMDH11 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH11's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH11(LPADC1_CMDH11_NEXT &NEXT, LPADC1_CMDH11_LOOP &LOOP,
                           LPADC1_CMDH11_AVGS &AVGS, LPADC1_CMDH11_STS &STS,
                           bool &LWI) volatile
    {
        uint32_t curr = CMDH11;

        NEXT = LPADC1_CMDH11_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH11_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH11_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH11_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH11's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH11(LPADC1_CMDH11_NEXT NEXT, LPADC1_CMDH11_LOOP LOOP,
                           LPADC1_CMDH11_AVGS AVGS, LPADC1_CMDH11_STS STS,
                           bool LWI) volatile
    {
        uint32_t curr = CMDH11;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH11 = curr;
    }

    /**
     * Get CMDL12's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL12_CSCALE() volatile
    {
        return CMDL12 & (1u << 13u);
    }

    /**
     * Set CMDL12's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL12_CSCALE() volatile
    {
        CMDL12 |= 1u << 13u;
    }

    /**
     * Clear CMDL12's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL12_CSCALE() volatile
    {
        CMDL12 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL12's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL12_CSCALE() volatile
    {
        CMDL12 ^= 1u << 13u;
    }

    /**
     * Get CMDL12's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL12_DIFF() volatile
    {
        return CMDL12 & (1u << 6u);
    }

    /**
     * Set CMDL12's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL12_DIFF() volatile
    {
        CMDL12 |= 1u << 6u;
    }

    /**
     * Clear CMDL12's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL12_DIFF() volatile
    {
        CMDL12 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL12's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL12_DIFF() volatile
    {
        CMDL12 ^= 1u << 6u;
    }

    /**
     * Get CMDL12's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL12_ABSEL() volatile
    {
        return CMDL12 & (1u << 5u);
    }

    /**
     * Set CMDL12's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL12_ABSEL() volatile
    {
        CMDL12 |= 1u << 5u;
    }

    /**
     * Clear CMDL12's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL12_ABSEL() volatile
    {
        CMDL12 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL12's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL12_ABSEL() volatile
    {
        CMDL12 ^= 1u << 5u;
    }

    /**
     * Get CMDL12's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL12_ADCH get_CMDL12_ADCH() volatile
    {
        return LPADC1_CMDL12_ADCH((CMDL12 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL12's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL12_ADCH(LPADC1_CMDL12_ADCH value) volatile
    {
        uint32_t curr = CMDL12;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL12 = curr;
    }

    /**
     * Get all of CMDL12's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL12(bool &CSCALE, bool &DIFF, bool &ABSEL,
                           LPADC1_CMDL12_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL12;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL12_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL12's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL12(bool CSCALE, bool DIFF, bool ABSEL,
                           LPADC1_CMDL12_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL12;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL12 = curr;
    }

    /**
     * Get CMDH12's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH12_NEXT get_CMDH12_NEXT() volatile
    {
        return LPADC1_CMDH12_NEXT((CMDH12 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH12's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH12_NEXT(LPADC1_CMDH12_NEXT value) volatile
    {
        uint32_t curr = CMDH12;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH12 = curr;
    }

    /**
     * Get CMDH12's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH12_LOOP get_CMDH12_LOOP() volatile
    {
        return LPADC1_CMDH12_LOOP((CMDH12 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH12's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH12_LOOP(LPADC1_CMDH12_LOOP value) volatile
    {
        uint32_t curr = CMDH12;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH12 = curr;
    }

    /**
     * Get CMDH12's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH12_AVGS get_CMDH12_AVGS() volatile
    {
        return LPADC1_CMDH12_AVGS((CMDH12 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH12's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH12_AVGS(LPADC1_CMDH12_AVGS value) volatile
    {
        uint32_t curr = CMDH12;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH12 = curr;
    }

    /**
     * Get CMDH12's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH12_STS get_CMDH12_STS() volatile
    {
        return LPADC1_CMDH12_STS((CMDH12 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH12's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH12_STS(LPADC1_CMDH12_STS value) volatile
    {
        uint32_t curr = CMDH12;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH12 = curr;
    }

    /**
     * Get CMDH12's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH12_LWI() volatile
    {
        return CMDH12 & (1u << 7u);
    }

    /**
     * Set CMDH12's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH12_LWI() volatile
    {
        CMDH12 |= 1u << 7u;
    }

    /**
     * Clear CMDH12's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH12_LWI() volatile
    {
        CMDH12 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH12's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH12_LWI() volatile
    {
        CMDH12 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH12's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH12(LPADC1_CMDH12_NEXT &NEXT, LPADC1_CMDH12_LOOP &LOOP,
                           LPADC1_CMDH12_AVGS &AVGS, LPADC1_CMDH12_STS &STS,
                           bool &LWI) volatile
    {
        uint32_t curr = CMDH12;

        NEXT = LPADC1_CMDH12_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH12_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH12_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH12_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH12's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH12(LPADC1_CMDH12_NEXT NEXT, LPADC1_CMDH12_LOOP LOOP,
                           LPADC1_CMDH12_AVGS AVGS, LPADC1_CMDH12_STS STS,
                           bool LWI) volatile
    {
        uint32_t curr = CMDH12;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH12 = curr;
    }

    /**
     * Get CMDL13's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL13_CSCALE() volatile
    {
        return CMDL13 & (1u << 13u);
    }

    /**
     * Set CMDL13's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL13_CSCALE() volatile
    {
        CMDL13 |= 1u << 13u;
    }

    /**
     * Clear CMDL13's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL13_CSCALE() volatile
    {
        CMDL13 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL13's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL13_CSCALE() volatile
    {
        CMDL13 ^= 1u << 13u;
    }

    /**
     * Get CMDL13's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL13_DIFF() volatile
    {
        return CMDL13 & (1u << 6u);
    }

    /**
     * Set CMDL13's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL13_DIFF() volatile
    {
        CMDL13 |= 1u << 6u;
    }

    /**
     * Clear CMDL13's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL13_DIFF() volatile
    {
        CMDL13 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL13's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL13_DIFF() volatile
    {
        CMDL13 ^= 1u << 6u;
    }

    /**
     * Get CMDL13's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL13_ABSEL() volatile
    {
        return CMDL13 & (1u << 5u);
    }

    /**
     * Set CMDL13's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL13_ABSEL() volatile
    {
        CMDL13 |= 1u << 5u;
    }

    /**
     * Clear CMDL13's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL13_ABSEL() volatile
    {
        CMDL13 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL13's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL13_ABSEL() volatile
    {
        CMDL13 ^= 1u << 5u;
    }

    /**
     * Get CMDL13's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL13_ADCH get_CMDL13_ADCH() volatile
    {
        return LPADC1_CMDL13_ADCH((CMDL13 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL13's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL13_ADCH(LPADC1_CMDL13_ADCH value) volatile
    {
        uint32_t curr = CMDL13;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL13 = curr;
    }

    /**
     * Get all of CMDL13's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL13(bool &CSCALE, bool &DIFF, bool &ABSEL,
                           LPADC1_CMDL13_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL13;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL13_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL13's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL13(bool CSCALE, bool DIFF, bool ABSEL,
                           LPADC1_CMDL13_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL13;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL13 = curr;
    }

    /**
     * Get CMDH13's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH13_NEXT get_CMDH13_NEXT() volatile
    {
        return LPADC1_CMDH13_NEXT((CMDH13 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH13's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH13_NEXT(LPADC1_CMDH13_NEXT value) volatile
    {
        uint32_t curr = CMDH13;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH13 = curr;
    }

    /**
     * Get CMDH13's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH13_LOOP get_CMDH13_LOOP() volatile
    {
        return LPADC1_CMDH13_LOOP((CMDH13 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH13's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH13_LOOP(LPADC1_CMDH13_LOOP value) volatile
    {
        uint32_t curr = CMDH13;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH13 = curr;
    }

    /**
     * Get CMDH13's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH13_AVGS get_CMDH13_AVGS() volatile
    {
        return LPADC1_CMDH13_AVGS((CMDH13 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH13's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH13_AVGS(LPADC1_CMDH13_AVGS value) volatile
    {
        uint32_t curr = CMDH13;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH13 = curr;
    }

    /**
     * Get CMDH13's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH13_STS get_CMDH13_STS() volatile
    {
        return LPADC1_CMDH13_STS((CMDH13 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH13's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH13_STS(LPADC1_CMDH13_STS value) volatile
    {
        uint32_t curr = CMDH13;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH13 = curr;
    }

    /**
     * Get CMDH13's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH13_LWI() volatile
    {
        return CMDH13 & (1u << 7u);
    }

    /**
     * Set CMDH13's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH13_LWI() volatile
    {
        CMDH13 |= 1u << 7u;
    }

    /**
     * Clear CMDH13's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH13_LWI() volatile
    {
        CMDH13 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH13's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH13_LWI() volatile
    {
        CMDH13 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH13's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH13(LPADC1_CMDH13_NEXT &NEXT, LPADC1_CMDH13_LOOP &LOOP,
                           LPADC1_CMDH13_AVGS &AVGS, LPADC1_CMDH13_STS &STS,
                           bool &LWI) volatile
    {
        uint32_t curr = CMDH13;

        NEXT = LPADC1_CMDH13_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH13_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH13_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH13_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH13's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH13(LPADC1_CMDH13_NEXT NEXT, LPADC1_CMDH13_LOOP LOOP,
                           LPADC1_CMDH13_AVGS AVGS, LPADC1_CMDH13_STS STS,
                           bool LWI) volatile
    {
        uint32_t curr = CMDH13;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH13 = curr;
    }

    /**
     * Get CMDL14's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL14_CSCALE() volatile
    {
        return CMDL14 & (1u << 13u);
    }

    /**
     * Set CMDL14's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL14_CSCALE() volatile
    {
        CMDL14 |= 1u << 13u;
    }

    /**
     * Clear CMDL14's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL14_CSCALE() volatile
    {
        CMDL14 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL14's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL14_CSCALE() volatile
    {
        CMDL14 ^= 1u << 13u;
    }

    /**
     * Get CMDL14's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL14_DIFF() volatile
    {
        return CMDL14 & (1u << 6u);
    }

    /**
     * Set CMDL14's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL14_DIFF() volatile
    {
        CMDL14 |= 1u << 6u;
    }

    /**
     * Clear CMDL14's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL14_DIFF() volatile
    {
        CMDL14 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL14's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL14_DIFF() volatile
    {
        CMDL14 ^= 1u << 6u;
    }

    /**
     * Get CMDL14's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL14_ABSEL() volatile
    {
        return CMDL14 & (1u << 5u);
    }

    /**
     * Set CMDL14's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL14_ABSEL() volatile
    {
        CMDL14 |= 1u << 5u;
    }

    /**
     * Clear CMDL14's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL14_ABSEL() volatile
    {
        CMDL14 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL14's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL14_ABSEL() volatile
    {
        CMDL14 ^= 1u << 5u;
    }

    /**
     * Get CMDL14's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL14_ADCH get_CMDL14_ADCH() volatile
    {
        return LPADC1_CMDL14_ADCH((CMDL14 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL14's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL14_ADCH(LPADC1_CMDL14_ADCH value) volatile
    {
        uint32_t curr = CMDL14;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL14 = curr;
    }

    /**
     * Get all of CMDL14's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL14(bool &CSCALE, bool &DIFF, bool &ABSEL,
                           LPADC1_CMDL14_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL14;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL14_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL14's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL14(bool CSCALE, bool DIFF, bool ABSEL,
                           LPADC1_CMDL14_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL14;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL14 = curr;
    }

    /**
     * Get CMDH14's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH14_NEXT get_CMDH14_NEXT() volatile
    {
        return LPADC1_CMDH14_NEXT((CMDH14 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH14's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH14_NEXT(LPADC1_CMDH14_NEXT value) volatile
    {
        uint32_t curr = CMDH14;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH14 = curr;
    }

    /**
     * Get CMDH14's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH14_LOOP get_CMDH14_LOOP() volatile
    {
        return LPADC1_CMDH14_LOOP((CMDH14 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH14's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH14_LOOP(LPADC1_CMDH14_LOOP value) volatile
    {
        uint32_t curr = CMDH14;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH14 = curr;
    }

    /**
     * Get CMDH14's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH14_AVGS get_CMDH14_AVGS() volatile
    {
        return LPADC1_CMDH14_AVGS((CMDH14 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH14's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH14_AVGS(LPADC1_CMDH14_AVGS value) volatile
    {
        uint32_t curr = CMDH14;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH14 = curr;
    }

    /**
     * Get CMDH14's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH14_STS get_CMDH14_STS() volatile
    {
        return LPADC1_CMDH14_STS((CMDH14 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH14's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH14_STS(LPADC1_CMDH14_STS value) volatile
    {
        uint32_t curr = CMDH14;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH14 = curr;
    }

    /**
     * Get CMDH14's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH14_LWI() volatile
    {
        return CMDH14 & (1u << 7u);
    }

    /**
     * Set CMDH14's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH14_LWI() volatile
    {
        CMDH14 |= 1u << 7u;
    }

    /**
     * Clear CMDH14's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH14_LWI() volatile
    {
        CMDH14 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH14's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH14_LWI() volatile
    {
        CMDH14 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH14's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH14(LPADC1_CMDH14_NEXT &NEXT, LPADC1_CMDH14_LOOP &LOOP,
                           LPADC1_CMDH14_AVGS &AVGS, LPADC1_CMDH14_STS &STS,
                           bool &LWI) volatile
    {
        uint32_t curr = CMDH14;

        NEXT = LPADC1_CMDH14_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH14_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH14_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH14_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH14's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH14(LPADC1_CMDH14_NEXT NEXT, LPADC1_CMDH14_LOOP LOOP,
                           LPADC1_CMDH14_AVGS AVGS, LPADC1_CMDH14_STS STS,
                           bool LWI) volatile
    {
        uint32_t curr = CMDH14;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH14 = curr;
    }

    /**
     * Get CMDL15's CSCALE bit.
     *
     * Channel Scale
     */
    inline bool get_CMDL15_CSCALE() volatile
    {
        return CMDL15 & (1u << 13u);
    }

    /**
     * Set CMDL15's CSCALE bit.
     *
     * Channel Scale
     */
    inline void set_CMDL15_CSCALE() volatile
    {
        CMDL15 |= 1u << 13u;
    }

    /**
     * Clear CMDL15's CSCALE bit.
     *
     * Channel Scale
     */
    inline void clear_CMDL15_CSCALE() volatile
    {
        CMDL15 &= ~(1u << 13u);
    }

    /**
     * Toggle CMDL15's CSCALE bit.
     *
     * Channel Scale
     */
    inline void toggle_CMDL15_CSCALE() volatile
    {
        CMDL15 ^= 1u << 13u;
    }

    /**
     * Get CMDL15's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline bool get_CMDL15_DIFF() volatile
    {
        return CMDL15 & (1u << 6u);
    }

    /**
     * Set CMDL15's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void set_CMDL15_DIFF() volatile
    {
        CMDL15 |= 1u << 6u;
    }

    /**
     * Clear CMDL15's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void clear_CMDL15_DIFF() volatile
    {
        CMDL15 &= ~(1u << 6u);
    }

    /**
     * Toggle CMDL15's DIFF bit.
     *
     * Differential Mode Enable
     */
    inline void toggle_CMDL15_DIFF() volatile
    {
        CMDL15 ^= 1u << 6u;
    }

    /**
     * Get CMDL15's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline bool get_CMDL15_ABSEL() volatile
    {
        return CMDL15 & (1u << 5u);
    }

    /**
     * Set CMDL15's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void set_CMDL15_ABSEL() volatile
    {
        CMDL15 |= 1u << 5u;
    }

    /**
     * Clear CMDL15's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void clear_CMDL15_ABSEL() volatile
    {
        CMDL15 &= ~(1u << 5u);
    }

    /**
     * Toggle CMDL15's ABSEL bit.
     *
     * A-side vs. B-side Select
     */
    inline void toggle_CMDL15_ABSEL() volatile
    {
        CMDL15 ^= 1u << 5u;
    }

    /**
     * Get CMDL15's ADCH field.
     *
     * Input channel select
     */
    inline LPADC1_CMDL15_ADCH get_CMDL15_ADCH() volatile
    {
        return LPADC1_CMDL15_ADCH((CMDL15 >> 0u) & 0b11111u);
    }

    /**
     * Set CMDL15's ADCH field.
     *
     * Input channel select
     */
    inline void set_CMDL15_ADCH(LPADC1_CMDL15_ADCH value) volatile
    {
        uint32_t curr = CMDL15;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CMDL15 = curr;
    }

    /**
     * Get all of CMDL15's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void get_CMDL15(bool &CSCALE, bool &DIFF, bool &ABSEL,
                           LPADC1_CMDL15_ADCH &ADCH) volatile
    {
        uint32_t curr = CMDL15;

        CSCALE = curr & (1u << 13u);
        DIFF = curr & (1u << 6u);
        ABSEL = curr & (1u << 5u);
        ADCH = LPADC1_CMDL15_ADCH((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CMDL15's bit fields.
     *
     * (read-write) LPADC Command Low Buffer Register
     */
    inline void set_CMDL15(bool CSCALE, bool DIFF, bool ABSEL,
                           LPADC1_CMDL15_ADCH ADCH) volatile
    {
        uint32_t curr = CMDL15;

        curr &= ~(0b1u << 13u);
        curr |= (CSCALE & 0b1u) << 13u;
        curr &= ~(0b1u << 6u);
        curr |= (DIFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ABSEL & 0b1u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(ADCH) & 0b11111u) << 0u;

        CMDL15 = curr;
    }

    /**
     * Get CMDH15's NEXT field.
     *
     * Next Command Select
     */
    inline LPADC1_CMDH15_NEXT get_CMDH15_NEXT() volatile
    {
        return LPADC1_CMDH15_NEXT((CMDH15 >> 24u) & 0b1111u);
    }

    /**
     * Set CMDH15's NEXT field.
     *
     * Next Command Select
     */
    inline void set_CMDH15_NEXT(LPADC1_CMDH15_NEXT value) volatile
    {
        uint32_t curr = CMDH15;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(value) & 0b1111u) << 24u;

        CMDH15 = curr;
    }

    /**
     * Get CMDH15's LOOP field.
     *
     * Loop Count Select
     */
    inline LPADC1_CMDH15_LOOP get_CMDH15_LOOP() volatile
    {
        return LPADC1_CMDH15_LOOP((CMDH15 >> 16u) & 0b1111u);
    }

    /**
     * Set CMDH15's LOOP field.
     *
     * Loop Count Select
     */
    inline void set_CMDH15_LOOP(LPADC1_CMDH15_LOOP value) volatile
    {
        uint32_t curr = CMDH15;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        CMDH15 = curr;
    }

    /**
     * Get CMDH15's AVGS field.
     *
     * Hardware Average Select
     */
    inline LPADC1_CMDH15_AVGS get_CMDH15_AVGS() volatile
    {
        return LPADC1_CMDH15_AVGS((CMDH15 >> 12u) & 0b111u);
    }

    /**
     * Set CMDH15's AVGS field.
     *
     * Hardware Average Select
     */
    inline void set_CMDH15_AVGS(LPADC1_CMDH15_AVGS value) volatile
    {
        uint32_t curr = CMDH15;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CMDH15 = curr;
    }

    /**
     * Get CMDH15's STS field.
     *
     * Sample Time Select
     */
    inline LPADC1_CMDH15_STS get_CMDH15_STS() volatile
    {
        return LPADC1_CMDH15_STS((CMDH15 >> 8u) & 0b111u);
    }

    /**
     * Set CMDH15's STS field.
     *
     * Sample Time Select
     */
    inline void set_CMDH15_STS(LPADC1_CMDH15_STS value) volatile
    {
        uint32_t curr = CMDH15;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CMDH15 = curr;
    }

    /**
     * Get CMDH15's LWI bit.
     *
     * Loop with Increment
     */
    inline bool get_CMDH15_LWI() volatile
    {
        return CMDH15 & (1u << 7u);
    }

    /**
     * Set CMDH15's LWI bit.
     *
     * Loop with Increment
     */
    inline void set_CMDH15_LWI() volatile
    {
        CMDH15 |= 1u << 7u;
    }

    /**
     * Clear CMDH15's LWI bit.
     *
     * Loop with Increment
     */
    inline void clear_CMDH15_LWI() volatile
    {
        CMDH15 &= ~(1u << 7u);
    }

    /**
     * Toggle CMDH15's LWI bit.
     *
     * Loop with Increment
     */
    inline void toggle_CMDH15_LWI() volatile
    {
        CMDH15 ^= 1u << 7u;
    }

    /**
     * Get all of CMDH15's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void get_CMDH15(LPADC1_CMDH15_NEXT &NEXT, LPADC1_CMDH15_LOOP &LOOP,
                           LPADC1_CMDH15_AVGS &AVGS, LPADC1_CMDH15_STS &STS,
                           bool &LWI) volatile
    {
        uint32_t curr = CMDH15;

        NEXT = LPADC1_CMDH15_NEXT((curr >> 24u) & 0b1111u);
        LOOP = LPADC1_CMDH15_LOOP((curr >> 16u) & 0b1111u);
        AVGS = LPADC1_CMDH15_AVGS((curr >> 12u) & 0b111u);
        STS = LPADC1_CMDH15_STS((curr >> 8u) & 0b111u);
        LWI = curr & (1u << 7u);
    }

    /**
     * Set all of CMDH15's bit fields.
     *
     * (read-write) LPADC Command High Buffer Register
     */
    inline void set_CMDH15(LPADC1_CMDH15_NEXT NEXT, LPADC1_CMDH15_LOOP LOOP,
                           LPADC1_CMDH15_AVGS AVGS, LPADC1_CMDH15_STS STS,
                           bool LWI) volatile
    {
        uint32_t curr = CMDH15;

        curr &= ~(0b1111u << 24u);
        curr |= (std::to_underlying(NEXT) & 0b1111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(LOOP) & 0b1111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(AVGS) & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STS) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LWI & 0b1u) << 7u;

        CMDH15 = curr;
    }

    /**
     * Get CV's CVH field.
     *
     * Compare Value High.
     */
    inline uint16_t get_CV_CVH(std::size_t index) volatile
    {
        return (CV[index] >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CV's CVH field.
     *
     * Compare Value High.
     */
    inline void set_CV_CVH(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = CV[index];

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CV[index] = curr;
    }

    /**
     * Get CV's CVL field.
     *
     * Compare Value Low
     */
    inline uint16_t get_CV_CVL(std::size_t index) volatile
    {
        return (CV[index] >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CV's CVL field.
     *
     * Compare Value Low
     */
    inline void set_CV_CVL(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = CV[index];

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CV[index] = curr;
    }

    /**
     * Get all of CV's bit fields.
     *
     * (read-write) Compare Value Register
     */
    inline void get_CV(std::size_t index, uint16_t &CVH,
                       uint16_t &CVL) volatile
    {
        uint32_t curr = CV[index];

        CVH = (curr >> 16u) & 0b1111111111111111u;
        CVL = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CV's bit fields.
     *
     * (read-write) Compare Value Register
     */
    inline void set_CV(std::size_t index, uint16_t CVH, uint16_t CVL) volatile
    {
        uint32_t curr = CV[index];

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (CVH & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (CVL & 0b1111111111111111u) << 0u;

        CV[index] = curr;
    }

    /**
     * Get RESFIFO's VALID bit.
     *
     * FIFO entry is valid
     */
    inline bool get_RESFIFO_VALID() volatile
    {
        return RESFIFO & (1u << 31u);
    }

    /**
     * Get RESFIFO's CMDSRC field.
     *
     * Command Buffer Source
     */
    inline LPADC1_RESFIFO_CMDSRC get_RESFIFO_CMDSRC() volatile
    {
        return LPADC1_RESFIFO_CMDSRC((RESFIFO >> 24u) & 0b1111u);
    }

    /**
     * Get RESFIFO's LOOPCNT field.
     *
     * Loop count value
     */
    inline LPADC1_RESFIFO_LOOPCNT get_RESFIFO_LOOPCNT() volatile
    {
        return LPADC1_RESFIFO_LOOPCNT((RESFIFO >> 20u) & 0b1111u);
    }

    /**
     * Get RESFIFO's TSRC field.
     *
     * Trigger Source
     */
    inline LPADC1_RESFIFO_TSRC get_RESFIFO_TSRC() volatile
    {
        return LPADC1_RESFIFO_TSRC((RESFIFO >> 16u) & 0b111u);
    }

    /**
     * Get RESFIFO's D field.
     *
     * Data result
     */
    inline uint16_t get_RESFIFO_D() volatile
    {
        return (RESFIFO >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of RESFIFO's bit fields.
     *
     * (read-write) LPADC Data Result FIFO Register
     */
    inline void get_RESFIFO(bool &VALID, LPADC1_RESFIFO_CMDSRC &CMDSRC,
                            LPADC1_RESFIFO_LOOPCNT &LOOPCNT,
                            LPADC1_RESFIFO_TSRC &TSRC, uint16_t &D) volatile
    {
        uint32_t curr = RESFIFO;

        VALID = curr & (1u << 31u);
        CMDSRC = LPADC1_RESFIFO_CMDSRC((curr >> 24u) & 0b1111u);
        LOOPCNT = LPADC1_RESFIFO_LOOPCNT((curr >> 20u) & 0b1111u);
        TSRC = LPADC1_RESFIFO_TSRC((curr >> 16u) & 0b111u);
        D = (curr >> 0u) & 0b1111111111111111u;
    }
};

static_assert(sizeof(lpadc1) == lpadc1::size);

static volatile lpadc1 *const LPADC1 = reinterpret_cast<lpadc1 *>(0x40050000);

static volatile lpadc1 *const LPADC2 = reinterpret_cast<lpadc1 *>(0x40054000);

}; // namespace MIMXRT1176::CM7
