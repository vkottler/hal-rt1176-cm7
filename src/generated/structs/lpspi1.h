/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/LPSPI1_CFGR1_MATCFG.h"
#include "../enums/LPSPI1_CFGR1_PINCFG.h"
#include "../enums/LPSPI1_TCR_PCS.h"
#include "../enums/LPSPI1_TCR_PRESCALE.h"
#include "../enums/LPSPI1_TCR_WIDTH.h"
#include "../enums/LPSPI1_VERID_FEATURE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * LPSPI
 */
struct [[gnu::packed]] lpspi1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 120; /*!< lpspi1's size in bytes. */

    /* Fields. */
    uint32_t VERID; /*!< (read-write) Version ID */
    uint32_t PARAM; /*!< (read-write) Parameter */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t CR;    /*!< (read-write) Control */
    uint32_t SR;    /*!< (read-write) Status */
    uint32_t IER;   /*!< (read-write) Interrupt Enable */
    uint32_t DER;   /*!< (read-write) DMA Enable */
    uint32_t CFGR0; /*!< (read-write) Configuration 0 */
    uint32_t CFGR1; /*!< (read-write) Configuration 1 */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t DMR0; /*!< (read-write) Data Match 0 */
    uint32_t DMR1; /*!< (read-write) Data Match 1 */
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t CCR; /*!< (read-write) Clock Configuration */
    static constexpr std::size_t reserved_padding3_length = 5;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t FCR; /*!< (read-write) FIFO Control */
    uint32_t FSR; /*!< (read-write) FIFO Status */
    uint32_t TCR; /*!< (read-write) Transmit Command */
    uint32_t TDR; /*!< (read-write) Transmit Data */
    static constexpr std::size_t reserved_padding4_length = 2;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t RSR; /*!< (read-write) Receive Status */
    uint32_t RDR; /*!< (read-write) Receive Data */

    /* Methods. */

    /**
     * Get VERID's MAJOR field.
     *
     * Major Version Number
     */
    inline uint8_t get_VERID_MAJOR() volatile
    {
        return (VERID >> 24u) & 0b11111111u;
    }

    /**
     * Get VERID's MINOR field.
     *
     * Minor Version Number
     */
    inline uint8_t get_VERID_MINOR() volatile
    {
        return (VERID >> 16u) & 0b11111111u;
    }

    /**
     * Get VERID's FEATURE field.
     *
     * Module Identification Number
     */
    inline LPSPI1_VERID_FEATURE get_VERID_FEATURE() volatile
    {
        return LPSPI1_VERID_FEATURE((VERID >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get all of VERID's bit fields.
     *
     * (read-write) Version ID
     */
    inline void get_VERID(uint8_t &MAJOR, uint8_t &MINOR,
                          LPSPI1_VERID_FEATURE &FEATURE) volatile
    {
        uint32_t curr = VERID;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        FEATURE = LPSPI1_VERID_FEATURE((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get PARAM's PCSNUM field.
     *
     * PCS Number
     */
    inline uint8_t get_PARAM_PCSNUM() volatile
    {
        return (PARAM >> 16u) & 0b11111111u;
    }

    /**
     * Get PARAM's RXFIFO field.
     *
     * Receive FIFO Size
     */
    inline uint8_t get_PARAM_RXFIFO() volatile
    {
        return (PARAM >> 8u) & 0b11111111u;
    }

    /**
     * Get PARAM's TXFIFO field.
     *
     * Transmit FIFO Size
     */
    inline uint8_t get_PARAM_TXFIFO() volatile
    {
        return (PARAM >> 0u) & 0b11111111u;
    }

    /**
     * Get all of PARAM's bit fields.
     *
     * (read-write) Parameter
     */
    inline void get_PARAM(uint8_t &PCSNUM, uint8_t &RXFIFO,
                          uint8_t &TXFIFO) volatile
    {
        uint32_t curr = PARAM;

        PCSNUM = (curr >> 16u) & 0b11111111u;
        RXFIFO = (curr >> 8u) & 0b11111111u;
        TXFIFO = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set CR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void set_CR_RRF() volatile
    {
        CR |= 1u << 9u;
    }

    /**
     * Clear CR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void clear_CR_RRF() volatile
    {
        CR &= ~(1u << 9u);
    }

    /**
     * Toggle CR's RRF bit.
     *
     * Reset Receive FIFO
     */
    inline void toggle_CR_RRF() volatile
    {
        CR ^= 1u << 9u;
    }

    /**
     * Set CR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void set_CR_RTF() volatile
    {
        CR |= 1u << 8u;
    }

    /**
     * Clear CR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void clear_CR_RTF() volatile
    {
        CR &= ~(1u << 8u);
    }

    /**
     * Toggle CR's RTF bit.
     *
     * Reset Transmit FIFO
     */
    inline void toggle_CR_RTF() volatile
    {
        CR ^= 1u << 8u;
    }

    /**
     * Get CR's DBGEN bit.
     *
     * Debug Enable
     */
    inline bool get_CR_DBGEN() volatile
    {
        return CR & (1u << 3u);
    }

    /**
     * Set CR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void set_CR_DBGEN() volatile
    {
        CR |= 1u << 3u;
    }

    /**
     * Clear CR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void clear_CR_DBGEN() volatile
    {
        CR &= ~(1u << 3u);
    }

    /**
     * Toggle CR's DBGEN bit.
     *
     * Debug Enable
     */
    inline void toggle_CR_DBGEN() volatile
    {
        CR ^= 1u << 3u;
    }

    /**
     * Get CR's DOZEN bit.
     *
     * Doze Mode Enable
     */
    inline bool get_CR_DOZEN() volatile
    {
        return CR & (1u << 2u);
    }

    /**
     * Set CR's DOZEN bit.
     *
     * Doze Mode Enable
     */
    inline void set_CR_DOZEN() volatile
    {
        CR |= 1u << 2u;
    }

    /**
     * Clear CR's DOZEN bit.
     *
     * Doze Mode Enable
     */
    inline void clear_CR_DOZEN() volatile
    {
        CR &= ~(1u << 2u);
    }

    /**
     * Toggle CR's DOZEN bit.
     *
     * Doze Mode Enable
     */
    inline void toggle_CR_DOZEN() volatile
    {
        CR ^= 1u << 2u;
    }

    /**
     * Get CR's RST bit.
     *
     * Software Reset
     */
    inline bool get_CR_RST() volatile
    {
        return CR & (1u << 1u);
    }

    /**
     * Set CR's RST bit.
     *
     * Software Reset
     */
    inline void set_CR_RST() volatile
    {
        CR |= 1u << 1u;
    }

    /**
     * Clear CR's RST bit.
     *
     * Software Reset
     */
    inline void clear_CR_RST() volatile
    {
        CR &= ~(1u << 1u);
    }

    /**
     * Toggle CR's RST bit.
     *
     * Software Reset
     */
    inline void toggle_CR_RST() volatile
    {
        CR ^= 1u << 1u;
    }

    /**
     * Get CR's MEN bit.
     *
     * Module Enable
     */
    inline bool get_CR_MEN() volatile
    {
        return CR & (1u << 0u);
    }

    /**
     * Set CR's MEN bit.
     *
     * Module Enable
     */
    inline void set_CR_MEN() volatile
    {
        CR |= 1u << 0u;
    }

    /**
     * Clear CR's MEN bit.
     *
     * Module Enable
     */
    inline void clear_CR_MEN() volatile
    {
        CR &= ~(1u << 0u);
    }

    /**
     * Toggle CR's MEN bit.
     *
     * Module Enable
     */
    inline void toggle_CR_MEN() volatile
    {
        CR ^= 1u << 0u;
    }

    /**
     * Get all of CR's bit fields.
     *
     * (read-write) Control
     */
    inline void get_CR(bool &DBGEN, bool &DOZEN, bool &RST, bool &MEN) volatile
    {
        uint32_t curr = CR;

        DBGEN = curr & (1u << 3u);
        DOZEN = curr & (1u << 2u);
        RST = curr & (1u << 1u);
        MEN = curr & (1u << 0u);
    }

    /**
     * Set all of CR's bit fields.
     *
     * (read-write) Control
     */
    inline void set_CR(bool RRF, bool RTF, bool DBGEN, bool DOZEN, bool RST,
                       bool MEN) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b1u << 9u);
        curr |= (RRF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RTF & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (DBGEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DOZEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RST & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MEN & 0b1u) << 0u;

        CR = curr;
    }

    /**
     * Get SR's MBF bit.
     *
     * Module Busy Flag
     */
    inline bool get_SR_MBF() volatile
    {
        return SR & (1u << 24u);
    }

    /**
     * Get SR's DMF bit.
     *
     * Data Match Flag
     */
    inline bool get_SR_DMF() volatile
    {
        return SR & (1u << 13u);
    }

    /**
     * Set SR's DMF bit.
     *
     * Data Match Flag
     */
    inline void set_SR_DMF() volatile
    {
        SR |= 1u << 13u;
    }

    /**
     * Clear SR's DMF bit.
     *
     * Data Match Flag
     */
    inline void clear_SR_DMF() volatile
    {
        SR &= ~(1u << 13u);
    }

    /**
     * Toggle SR's DMF bit.
     *
     * Data Match Flag
     */
    inline void toggle_SR_DMF() volatile
    {
        SR ^= 1u << 13u;
    }

    /**
     * Get SR's REF bit.
     *
     * Receive Error Flag
     */
    inline bool get_SR_REF() volatile
    {
        return SR & (1u << 12u);
    }

    /**
     * Set SR's REF bit.
     *
     * Receive Error Flag
     */
    inline void set_SR_REF() volatile
    {
        SR |= 1u << 12u;
    }

    /**
     * Clear SR's REF bit.
     *
     * Receive Error Flag
     */
    inline void clear_SR_REF() volatile
    {
        SR &= ~(1u << 12u);
    }

    /**
     * Toggle SR's REF bit.
     *
     * Receive Error Flag
     */
    inline void toggle_SR_REF() volatile
    {
        SR ^= 1u << 12u;
    }

    /**
     * Get SR's TEF bit.
     *
     * Transmit Error Flag
     */
    inline bool get_SR_TEF() volatile
    {
        return SR & (1u << 11u);
    }

    /**
     * Set SR's TEF bit.
     *
     * Transmit Error Flag
     */
    inline void set_SR_TEF() volatile
    {
        SR |= 1u << 11u;
    }

    /**
     * Clear SR's TEF bit.
     *
     * Transmit Error Flag
     */
    inline void clear_SR_TEF() volatile
    {
        SR &= ~(1u << 11u);
    }

    /**
     * Toggle SR's TEF bit.
     *
     * Transmit Error Flag
     */
    inline void toggle_SR_TEF() volatile
    {
        SR ^= 1u << 11u;
    }

    /**
     * Get SR's TCF bit.
     *
     * Transfer Complete Flag
     */
    inline bool get_SR_TCF() volatile
    {
        return SR & (1u << 10u);
    }

    /**
     * Set SR's TCF bit.
     *
     * Transfer Complete Flag
     */
    inline void set_SR_TCF() volatile
    {
        SR |= 1u << 10u;
    }

    /**
     * Clear SR's TCF bit.
     *
     * Transfer Complete Flag
     */
    inline void clear_SR_TCF() volatile
    {
        SR &= ~(1u << 10u);
    }

    /**
     * Toggle SR's TCF bit.
     *
     * Transfer Complete Flag
     */
    inline void toggle_SR_TCF() volatile
    {
        SR ^= 1u << 10u;
    }

    /**
     * Get SR's FCF bit.
     *
     * Frame Complete Flag
     */
    inline bool get_SR_FCF() volatile
    {
        return SR & (1u << 9u);
    }

    /**
     * Set SR's FCF bit.
     *
     * Frame Complete Flag
     */
    inline void set_SR_FCF() volatile
    {
        SR |= 1u << 9u;
    }

    /**
     * Clear SR's FCF bit.
     *
     * Frame Complete Flag
     */
    inline void clear_SR_FCF() volatile
    {
        SR &= ~(1u << 9u);
    }

    /**
     * Toggle SR's FCF bit.
     *
     * Frame Complete Flag
     */
    inline void toggle_SR_FCF() volatile
    {
        SR ^= 1u << 9u;
    }

    /**
     * Get SR's WCF bit.
     *
     * Word Complete Flag
     */
    inline bool get_SR_WCF() volatile
    {
        return SR & (1u << 8u);
    }

    /**
     * Set SR's WCF bit.
     *
     * Word Complete Flag
     */
    inline void set_SR_WCF() volatile
    {
        SR |= 1u << 8u;
    }

    /**
     * Clear SR's WCF bit.
     *
     * Word Complete Flag
     */
    inline void clear_SR_WCF() volatile
    {
        SR &= ~(1u << 8u);
    }

    /**
     * Toggle SR's WCF bit.
     *
     * Word Complete Flag
     */
    inline void toggle_SR_WCF() volatile
    {
        SR ^= 1u << 8u;
    }

    /**
     * Get SR's RDF bit.
     *
     * Receive Data Flag
     */
    inline bool get_SR_RDF() volatile
    {
        return SR & (1u << 1u);
    }

    /**
     * Get SR's TDF bit.
     *
     * Transmit Data Flag
     */
    inline bool get_SR_TDF() volatile
    {
        return SR & (1u << 0u);
    }

    /**
     * Get all of SR's bit fields.
     *
     * (read-write) Status
     */
    inline void get_SR(bool &MBF, bool &DMF, bool &REF, bool &TEF, bool &TCF,
                       bool &FCF, bool &WCF, bool &RDF, bool &TDF) volatile
    {
        uint32_t curr = SR;

        MBF = curr & (1u << 24u);
        DMF = curr & (1u << 13u);
        REF = curr & (1u << 12u);
        TEF = curr & (1u << 11u);
        TCF = curr & (1u << 10u);
        FCF = curr & (1u << 9u);
        WCF = curr & (1u << 8u);
        RDF = curr & (1u << 1u);
        TDF = curr & (1u << 0u);
    }

    /**
     * Set all of SR's bit fields.
     *
     * (read-write) Status
     */
    inline void set_SR(bool DMF, bool REF, bool TEF, bool TCF, bool FCF,
                       bool WCF) volatile
    {
        uint32_t curr = SR;

        curr &= ~(0b1u << 13u);
        curr |= (DMF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (REF & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TEF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TCF & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (FCF & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (WCF & 0b1u) << 8u;

        SR = curr;
    }

    /**
     * Get IER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline bool get_IER_DMIE() volatile
    {
        return IER & (1u << 13u);
    }

    /**
     * Set IER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline void set_IER_DMIE() volatile
    {
        IER |= 1u << 13u;
    }

    /**
     * Clear IER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline void clear_IER_DMIE() volatile
    {
        IER &= ~(1u << 13u);
    }

    /**
     * Toggle IER's DMIE bit.
     *
     * Data Match Interrupt Enable
     */
    inline void toggle_IER_DMIE() volatile
    {
        IER ^= 1u << 13u;
    }

    /**
     * Get IER's REIE bit.
     *
     * Receive Error Interrupt Enable
     */
    inline bool get_IER_REIE() volatile
    {
        return IER & (1u << 12u);
    }

    /**
     * Set IER's REIE bit.
     *
     * Receive Error Interrupt Enable
     */
    inline void set_IER_REIE() volatile
    {
        IER |= 1u << 12u;
    }

    /**
     * Clear IER's REIE bit.
     *
     * Receive Error Interrupt Enable
     */
    inline void clear_IER_REIE() volatile
    {
        IER &= ~(1u << 12u);
    }

    /**
     * Toggle IER's REIE bit.
     *
     * Receive Error Interrupt Enable
     */
    inline void toggle_IER_REIE() volatile
    {
        IER ^= 1u << 12u;
    }

    /**
     * Get IER's TEIE bit.
     *
     * Transmit Error Interrupt Enable
     */
    inline bool get_IER_TEIE() volatile
    {
        return IER & (1u << 11u);
    }

    /**
     * Set IER's TEIE bit.
     *
     * Transmit Error Interrupt Enable
     */
    inline void set_IER_TEIE() volatile
    {
        IER |= 1u << 11u;
    }

    /**
     * Clear IER's TEIE bit.
     *
     * Transmit Error Interrupt Enable
     */
    inline void clear_IER_TEIE() volatile
    {
        IER &= ~(1u << 11u);
    }

    /**
     * Toggle IER's TEIE bit.
     *
     * Transmit Error Interrupt Enable
     */
    inline void toggle_IER_TEIE() volatile
    {
        IER ^= 1u << 11u;
    }

    /**
     * Get IER's TCIE bit.
     *
     * Transfer Complete Interrupt Enable
     */
    inline bool get_IER_TCIE() volatile
    {
        return IER & (1u << 10u);
    }

    /**
     * Set IER's TCIE bit.
     *
     * Transfer Complete Interrupt Enable
     */
    inline void set_IER_TCIE() volatile
    {
        IER |= 1u << 10u;
    }

    /**
     * Clear IER's TCIE bit.
     *
     * Transfer Complete Interrupt Enable
     */
    inline void clear_IER_TCIE() volatile
    {
        IER &= ~(1u << 10u);
    }

    /**
     * Toggle IER's TCIE bit.
     *
     * Transfer Complete Interrupt Enable
     */
    inline void toggle_IER_TCIE() volatile
    {
        IER ^= 1u << 10u;
    }

    /**
     * Get IER's FCIE bit.
     *
     * Frame Complete Interrupt Enable
     */
    inline bool get_IER_FCIE() volatile
    {
        return IER & (1u << 9u);
    }

    /**
     * Set IER's FCIE bit.
     *
     * Frame Complete Interrupt Enable
     */
    inline void set_IER_FCIE() volatile
    {
        IER |= 1u << 9u;
    }

    /**
     * Clear IER's FCIE bit.
     *
     * Frame Complete Interrupt Enable
     */
    inline void clear_IER_FCIE() volatile
    {
        IER &= ~(1u << 9u);
    }

    /**
     * Toggle IER's FCIE bit.
     *
     * Frame Complete Interrupt Enable
     */
    inline void toggle_IER_FCIE() volatile
    {
        IER ^= 1u << 9u;
    }

    /**
     * Get IER's WCIE bit.
     *
     * Word Complete Interrupt Enable
     */
    inline bool get_IER_WCIE() volatile
    {
        return IER & (1u << 8u);
    }

    /**
     * Set IER's WCIE bit.
     *
     * Word Complete Interrupt Enable
     */
    inline void set_IER_WCIE() volatile
    {
        IER |= 1u << 8u;
    }

    /**
     * Clear IER's WCIE bit.
     *
     * Word Complete Interrupt Enable
     */
    inline void clear_IER_WCIE() volatile
    {
        IER &= ~(1u << 8u);
    }

    /**
     * Toggle IER's WCIE bit.
     *
     * Word Complete Interrupt Enable
     */
    inline void toggle_IER_WCIE() volatile
    {
        IER ^= 1u << 8u;
    }

    /**
     * Get IER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline bool get_IER_RDIE() volatile
    {
        return IER & (1u << 1u);
    }

    /**
     * Set IER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void set_IER_RDIE() volatile
    {
        IER |= 1u << 1u;
    }

    /**
     * Clear IER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void clear_IER_RDIE() volatile
    {
        IER &= ~(1u << 1u);
    }

    /**
     * Toggle IER's RDIE bit.
     *
     * Receive Data Interrupt Enable
     */
    inline void toggle_IER_RDIE() volatile
    {
        IER ^= 1u << 1u;
    }

    /**
     * Get IER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline bool get_IER_TDIE() volatile
    {
        return IER & (1u << 0u);
    }

    /**
     * Set IER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void set_IER_TDIE() volatile
    {
        IER |= 1u << 0u;
    }

    /**
     * Clear IER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void clear_IER_TDIE() volatile
    {
        IER &= ~(1u << 0u);
    }

    /**
     * Toggle IER's TDIE bit.
     *
     * Transmit Data Interrupt Enable
     */
    inline void toggle_IER_TDIE() volatile
    {
        IER ^= 1u << 0u;
    }

    /**
     * Get all of IER's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void get_IER(bool &DMIE, bool &REIE, bool &TEIE, bool &TCIE,
                        bool &FCIE, bool &WCIE, bool &RDIE,
                        bool &TDIE) volatile
    {
        uint32_t curr = IER;

        DMIE = curr & (1u << 13u);
        REIE = curr & (1u << 12u);
        TEIE = curr & (1u << 11u);
        TCIE = curr & (1u << 10u);
        FCIE = curr & (1u << 9u);
        WCIE = curr & (1u << 8u);
        RDIE = curr & (1u << 1u);
        TDIE = curr & (1u << 0u);
    }

    /**
     * Set all of IER's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void set_IER(bool DMIE, bool REIE, bool TEIE, bool TCIE, bool FCIE,
                        bool WCIE, bool RDIE, bool TDIE) volatile
    {
        uint32_t curr = IER;

        curr &= ~(0b1u << 13u);
        curr |= (DMIE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (REIE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TEIE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TCIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (FCIE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (WCIE & 0b1u) << 8u;
        curr &= ~(0b1u << 1u);
        curr |= (RDIE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TDIE & 0b1u) << 0u;

        IER = curr;
    }

    /**
     * Get DER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline bool get_DER_RDDE() volatile
    {
        return DER & (1u << 1u);
    }

    /**
     * Set DER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void set_DER_RDDE() volatile
    {
        DER |= 1u << 1u;
    }

    /**
     * Clear DER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void clear_DER_RDDE() volatile
    {
        DER &= ~(1u << 1u);
    }

    /**
     * Toggle DER's RDDE bit.
     *
     * Receive Data DMA Enable
     */
    inline void toggle_DER_RDDE() volatile
    {
        DER ^= 1u << 1u;
    }

    /**
     * Get DER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline bool get_DER_TDDE() volatile
    {
        return DER & (1u << 0u);
    }

    /**
     * Set DER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void set_DER_TDDE() volatile
    {
        DER |= 1u << 0u;
    }

    /**
     * Clear DER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void clear_DER_TDDE() volatile
    {
        DER &= ~(1u << 0u);
    }

    /**
     * Toggle DER's TDDE bit.
     *
     * Transmit Data DMA Enable
     */
    inline void toggle_DER_TDDE() volatile
    {
        DER ^= 1u << 0u;
    }

    /**
     * Get all of DER's bit fields.
     *
     * (read-write) DMA Enable
     */
    inline void get_DER(bool &RDDE, bool &TDDE) volatile
    {
        uint32_t curr = DER;

        RDDE = curr & (1u << 1u);
        TDDE = curr & (1u << 0u);
    }

    /**
     * Set all of DER's bit fields.
     *
     * (read-write) DMA Enable
     */
    inline void set_DER(bool RDDE, bool TDDE) volatile
    {
        uint32_t curr = DER;

        curr &= ~(0b1u << 1u);
        curr |= (RDDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TDDE & 0b1u) << 0u;

        DER = curr;
    }

    /**
     * Get CFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline bool get_CFGR0_RDMO() volatile
    {
        return CFGR0 & (1u << 9u);
    }

    /**
     * Set CFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline void set_CFGR0_RDMO() volatile
    {
        CFGR0 |= 1u << 9u;
    }

    /**
     * Clear CFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline void clear_CFGR0_RDMO() volatile
    {
        CFGR0 &= ~(1u << 9u);
    }

    /**
     * Toggle CFGR0's RDMO bit.
     *
     * Receive Data Match Only
     */
    inline void toggle_CFGR0_RDMO() volatile
    {
        CFGR0 ^= 1u << 9u;
    }

    /**
     * Get CFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline bool get_CFGR0_CIRFIFO() volatile
    {
        return CFGR0 & (1u << 8u);
    }

    /**
     * Set CFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline void set_CFGR0_CIRFIFO() volatile
    {
        CFGR0 |= 1u << 8u;
    }

    /**
     * Clear CFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline void clear_CFGR0_CIRFIFO() volatile
    {
        CFGR0 &= ~(1u << 8u);
    }

    /**
     * Toggle CFGR0's CIRFIFO bit.
     *
     * Circular FIFO Enable
     */
    inline void toggle_CFGR0_CIRFIFO() volatile
    {
        CFGR0 ^= 1u << 8u;
    }

    /**
     * Get all of CFGR0's bit fields.
     *
     * (read-write) Configuration 0
     */
    inline void get_CFGR0(bool &RDMO, bool &CIRFIFO) volatile
    {
        uint32_t curr = CFGR0;

        RDMO = curr & (1u << 9u);
        CIRFIFO = curr & (1u << 8u);
    }

    /**
     * Set all of CFGR0's bit fields.
     *
     * (read-write) Configuration 0
     */
    inline void set_CFGR0(bool RDMO, bool CIRFIFO) volatile
    {
        uint32_t curr = CFGR0;

        curr &= ~(0b1u << 9u);
        curr |= (RDMO & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CIRFIFO & 0b1u) << 8u;

        CFGR0 = curr;
    }

    /**
     * Get CFGR1's PCSCFG bit.
     *
     * Peripheral Chip Select Configuration
     */
    inline bool get_CFGR1_PCSCFG() volatile
    {
        return CFGR1 & (1u << 27u);
    }

    /**
     * Set CFGR1's PCSCFG bit.
     *
     * Peripheral Chip Select Configuration
     */
    inline void set_CFGR1_PCSCFG() volatile
    {
        CFGR1 |= 1u << 27u;
    }

    /**
     * Clear CFGR1's PCSCFG bit.
     *
     * Peripheral Chip Select Configuration
     */
    inline void clear_CFGR1_PCSCFG() volatile
    {
        CFGR1 &= ~(1u << 27u);
    }

    /**
     * Toggle CFGR1's PCSCFG bit.
     *
     * Peripheral Chip Select Configuration
     */
    inline void toggle_CFGR1_PCSCFG() volatile
    {
        CFGR1 ^= 1u << 27u;
    }

    /**
     * Get CFGR1's OUTCFG bit.
     *
     * Output Configuration
     */
    inline bool get_CFGR1_OUTCFG() volatile
    {
        return CFGR1 & (1u << 26u);
    }

    /**
     * Set CFGR1's OUTCFG bit.
     *
     * Output Configuration
     */
    inline void set_CFGR1_OUTCFG() volatile
    {
        CFGR1 |= 1u << 26u;
    }

    /**
     * Clear CFGR1's OUTCFG bit.
     *
     * Output Configuration
     */
    inline void clear_CFGR1_OUTCFG() volatile
    {
        CFGR1 &= ~(1u << 26u);
    }

    /**
     * Toggle CFGR1's OUTCFG bit.
     *
     * Output Configuration
     */
    inline void toggle_CFGR1_OUTCFG() volatile
    {
        CFGR1 ^= 1u << 26u;
    }

    /**
     * Get CFGR1's PINCFG field.
     *
     * Pin Configuration
     */
    inline LPSPI1_CFGR1_PINCFG get_CFGR1_PINCFG() volatile
    {
        return LPSPI1_CFGR1_PINCFG((CFGR1 >> 24u) & 0b11u);
    }

    /**
     * Set CFGR1's PINCFG field.
     *
     * Pin Configuration
     */
    inline void set_CFGR1_PINCFG(LPSPI1_CFGR1_PINCFG value) volatile
    {
        uint32_t curr = CFGR1;

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(value) & 0b11u) << 24u;

        CFGR1 = curr;
    }

    /**
     * Get CFGR1's MATCFG field.
     *
     * Match Configuration
     */
    inline LPSPI1_CFGR1_MATCFG get_CFGR1_MATCFG() volatile
    {
        return LPSPI1_CFGR1_MATCFG((CFGR1 >> 16u) & 0b111u);
    }

    /**
     * Set CFGR1's MATCFG field.
     *
     * Match Configuration
     */
    inline void set_CFGR1_MATCFG(LPSPI1_CFGR1_MATCFG value) volatile
    {
        uint32_t curr = CFGR1;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        CFGR1 = curr;
    }

    /**
     * Get CFGR1's PCSPOL field.
     *
     * Peripheral Chip Select Polarity
     */
    inline uint8_t get_CFGR1_PCSPOL() volatile
    {
        return (CFGR1 >> 8u) & 0b1111u;
    }

    /**
     * Set CFGR1's PCSPOL field.
     *
     * Peripheral Chip Select Polarity
     */
    inline void set_CFGR1_PCSPOL(uint8_t value) volatile
    {
        uint32_t curr = CFGR1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CFGR1 = curr;
    }

    /**
     * Get CFGR1's NOSTALL bit.
     *
     * No Stall
     */
    inline bool get_CFGR1_NOSTALL() volatile
    {
        return CFGR1 & (1u << 3u);
    }

    /**
     * Set CFGR1's NOSTALL bit.
     *
     * No Stall
     */
    inline void set_CFGR1_NOSTALL() volatile
    {
        CFGR1 |= 1u << 3u;
    }

    /**
     * Clear CFGR1's NOSTALL bit.
     *
     * No Stall
     */
    inline void clear_CFGR1_NOSTALL() volatile
    {
        CFGR1 &= ~(1u << 3u);
    }

    /**
     * Toggle CFGR1's NOSTALL bit.
     *
     * No Stall
     */
    inline void toggle_CFGR1_NOSTALL() volatile
    {
        CFGR1 ^= 1u << 3u;
    }

    /**
     * Get CFGR1's AUTOPCS bit.
     *
     * Automatic PCS
     */
    inline bool get_CFGR1_AUTOPCS() volatile
    {
        return CFGR1 & (1u << 2u);
    }

    /**
     * Set CFGR1's AUTOPCS bit.
     *
     * Automatic PCS
     */
    inline void set_CFGR1_AUTOPCS() volatile
    {
        CFGR1 |= 1u << 2u;
    }

    /**
     * Clear CFGR1's AUTOPCS bit.
     *
     * Automatic PCS
     */
    inline void clear_CFGR1_AUTOPCS() volatile
    {
        CFGR1 &= ~(1u << 2u);
    }

    /**
     * Toggle CFGR1's AUTOPCS bit.
     *
     * Automatic PCS
     */
    inline void toggle_CFGR1_AUTOPCS() volatile
    {
        CFGR1 ^= 1u << 2u;
    }

    /**
     * Get CFGR1's SAMPLE bit.
     *
     * Sample Point
     */
    inline bool get_CFGR1_SAMPLE() volatile
    {
        return CFGR1 & (1u << 1u);
    }

    /**
     * Set CFGR1's SAMPLE bit.
     *
     * Sample Point
     */
    inline void set_CFGR1_SAMPLE() volatile
    {
        CFGR1 |= 1u << 1u;
    }

    /**
     * Clear CFGR1's SAMPLE bit.
     *
     * Sample Point
     */
    inline void clear_CFGR1_SAMPLE() volatile
    {
        CFGR1 &= ~(1u << 1u);
    }

    /**
     * Toggle CFGR1's SAMPLE bit.
     *
     * Sample Point
     */
    inline void toggle_CFGR1_SAMPLE() volatile
    {
        CFGR1 ^= 1u << 1u;
    }

    /**
     * Get CFGR1's MASTER bit.
     *
     * Master Mode
     */
    inline bool get_CFGR1_MASTER() volatile
    {
        return CFGR1 & (1u << 0u);
    }

    /**
     * Set CFGR1's MASTER bit.
     *
     * Master Mode
     */
    inline void set_CFGR1_MASTER() volatile
    {
        CFGR1 |= 1u << 0u;
    }

    /**
     * Clear CFGR1's MASTER bit.
     *
     * Master Mode
     */
    inline void clear_CFGR1_MASTER() volatile
    {
        CFGR1 &= ~(1u << 0u);
    }

    /**
     * Toggle CFGR1's MASTER bit.
     *
     * Master Mode
     */
    inline void toggle_CFGR1_MASTER() volatile
    {
        CFGR1 ^= 1u << 0u;
    }

    /**
     * Get all of CFGR1's bit fields.
     *
     * (read-write) Configuration 1
     */
    inline void get_CFGR1(bool &PCSCFG, bool &OUTCFG,
                          LPSPI1_CFGR1_PINCFG &PINCFG,
                          LPSPI1_CFGR1_MATCFG &MATCFG, uint8_t &PCSPOL,
                          bool &NOSTALL, bool &AUTOPCS, bool &SAMPLE,
                          bool &MASTER) volatile
    {
        uint32_t curr = CFGR1;

        PCSCFG = curr & (1u << 27u);
        OUTCFG = curr & (1u << 26u);
        PINCFG = LPSPI1_CFGR1_PINCFG((curr >> 24u) & 0b11u);
        MATCFG = LPSPI1_CFGR1_MATCFG((curr >> 16u) & 0b111u);
        PCSPOL = (curr >> 8u) & 0b1111u;
        NOSTALL = curr & (1u << 3u);
        AUTOPCS = curr & (1u << 2u);
        SAMPLE = curr & (1u << 1u);
        MASTER = curr & (1u << 0u);
    }

    /**
     * Set all of CFGR1's bit fields.
     *
     * (read-write) Configuration 1
     */
    inline void set_CFGR1(bool PCSCFG, bool OUTCFG, LPSPI1_CFGR1_PINCFG PINCFG,
                          LPSPI1_CFGR1_MATCFG MATCFG, uint8_t PCSPOL,
                          bool NOSTALL, bool AUTOPCS, bool SAMPLE,
                          bool MASTER) volatile
    {
        uint32_t curr = CFGR1;

        curr &= ~(0b1u << 27u);
        curr |= (PCSCFG & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (OUTCFG & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(PINCFG) & 0b11u) << 24u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(MATCFG) & 0b111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (PCSPOL & 0b1111u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (NOSTALL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AUTOPCS & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SAMPLE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MASTER & 0b1u) << 0u;

        CFGR1 = curr;
    }

    /**
     * Get DMR0's MATCH0 field.
     *
     * Match 0 Value
     */
    inline uint32_t get_DMR0_MATCH0() volatile
    {
        return (DMR0 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DMR0's MATCH0 field.
     *
     * Match 0 Value
     */
    inline void set_DMR0_MATCH0(uint32_t value) volatile
    {
        uint32_t curr = DMR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DMR0 = curr;
    }

    /**
     * Get DMR1's MATCH1 field.
     *
     * Match 1 Value
     */
    inline uint32_t get_DMR1_MATCH1() volatile
    {
        return (DMR1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DMR1's MATCH1 field.
     *
     * Match 1 Value
     */
    inline void set_DMR1_MATCH1(uint32_t value) volatile
    {
        uint32_t curr = DMR1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DMR1 = curr;
    }

    /**
     * Get CCR's SCKPCS field.
     *
     * SCK-to-PCS Delay
     */
    inline uint8_t get_CCR_SCKPCS() volatile
    {
        return (CCR >> 24u) & 0b11111111u;
    }

    /**
     * Set CCR's SCKPCS field.
     *
     * SCK-to-PCS Delay
     */
    inline void set_CCR_SCKPCS(uint8_t value) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        CCR = curr;
    }

    /**
     * Get CCR's PCSSCK field.
     *
     * PCS-to-SCK Delay
     */
    inline uint8_t get_CCR_PCSSCK() volatile
    {
        return (CCR >> 16u) & 0b11111111u;
    }

    /**
     * Set CCR's PCSSCK field.
     *
     * PCS-to-SCK Delay
     */
    inline void set_CCR_PCSSCK(uint8_t value) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        CCR = curr;
    }

    /**
     * Get CCR's DBT field.
     *
     * Delay Between Transfers
     */
    inline uint8_t get_CCR_DBT() volatile
    {
        return (CCR >> 8u) & 0b11111111u;
    }

    /**
     * Set CCR's DBT field.
     *
     * Delay Between Transfers
     */
    inline void set_CCR_DBT(uint8_t value) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        CCR = curr;
    }

    /**
     * Get CCR's SCKDIV field.
     *
     * SCK Divider
     */
    inline uint8_t get_CCR_SCKDIV() volatile
    {
        return (CCR >> 0u) & 0b11111111u;
    }

    /**
     * Set CCR's SCKDIV field.
     *
     * SCK Divider
     */
    inline void set_CCR_SCKDIV(uint8_t value) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CCR = curr;
    }

    /**
     * Get all of CCR's bit fields.
     *
     * (read-write) Clock Configuration
     */
    inline void get_CCR(uint8_t &SCKPCS, uint8_t &PCSSCK, uint8_t &DBT,
                        uint8_t &SCKDIV) volatile
    {
        uint32_t curr = CCR;

        SCKPCS = (curr >> 24u) & 0b11111111u;
        PCSSCK = (curr >> 16u) & 0b11111111u;
        DBT = (curr >> 8u) & 0b11111111u;
        SCKDIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CCR's bit fields.
     *
     * (read-write) Clock Configuration
     */
    inline void set_CCR(uint8_t SCKPCS, uint8_t PCSSCK, uint8_t DBT,
                        uint8_t SCKDIV) volatile
    {
        uint32_t curr = CCR;

        curr &= ~(0b11111111u << 24u);
        curr |= (SCKPCS & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (PCSSCK & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (DBT & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (SCKDIV & 0b11111111u) << 0u;

        CCR = curr;
    }

    /**
     * Get FCR's RXWATER field.
     *
     * Receive FIFO Watermark
     */
    inline uint8_t get_FCR_RXWATER() volatile
    {
        return (FCR >> 16u) & 0b1111u;
    }

    /**
     * Set FCR's RXWATER field.
     *
     * Receive FIFO Watermark
     */
    inline void set_FCR_RXWATER(uint8_t value) volatile
    {
        uint32_t curr = FCR;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        FCR = curr;
    }

    /**
     * Get FCR's TXWATER field.
     *
     * Transmit FIFO Watermark
     */
    inline uint8_t get_FCR_TXWATER() volatile
    {
        return (FCR >> 0u) & 0b1111u;
    }

    /**
     * Set FCR's TXWATER field.
     *
     * Transmit FIFO Watermark
     */
    inline void set_FCR_TXWATER(uint8_t value) volatile
    {
        uint32_t curr = FCR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FCR = curr;
    }

    /**
     * Get all of FCR's bit fields.
     *
     * (read-write) FIFO Control
     */
    inline void get_FCR(uint8_t &RXWATER, uint8_t &TXWATER) volatile
    {
        uint32_t curr = FCR;

        RXWATER = (curr >> 16u) & 0b1111u;
        TXWATER = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of FCR's bit fields.
     *
     * (read-write) FIFO Control
     */
    inline void set_FCR(uint8_t RXWATER, uint8_t TXWATER) volatile
    {
        uint32_t curr = FCR;

        curr &= ~(0b1111u << 16u);
        curr |= (RXWATER & 0b1111u) << 16u;
        curr &= ~(0b1111u << 0u);
        curr |= (TXWATER & 0b1111u) << 0u;

        FCR = curr;
    }

    /**
     * Get FSR's RXCOUNT field.
     *
     * Receive FIFO Count
     */
    inline uint8_t get_FSR_RXCOUNT() volatile
    {
        return (FSR >> 16u) & 0b11111u;
    }

    /**
     * Get FSR's TXCOUNT field.
     *
     * Transmit FIFO Count
     */
    inline uint8_t get_FSR_TXCOUNT() volatile
    {
        return (FSR >> 0u) & 0b11111u;
    }

    /**
     * Get all of FSR's bit fields.
     *
     * (read-write) FIFO Status
     */
    inline void get_FSR(uint8_t &RXCOUNT, uint8_t &TXCOUNT) volatile
    {
        uint32_t curr = FSR;

        RXCOUNT = (curr >> 16u) & 0b11111u;
        TXCOUNT = (curr >> 0u) & 0b11111u;
    }

    /**
     * Get TCR's CPOL bit.
     *
     * Clock Polarity
     */
    inline bool get_TCR_CPOL() volatile
    {
        return TCR & (1u << 31u);
    }

    /**
     * Set TCR's CPOL bit.
     *
     * Clock Polarity
     */
    inline void set_TCR_CPOL() volatile
    {
        TCR |= 1u << 31u;
    }

    /**
     * Clear TCR's CPOL bit.
     *
     * Clock Polarity
     */
    inline void clear_TCR_CPOL() volatile
    {
        TCR &= ~(1u << 31u);
    }

    /**
     * Toggle TCR's CPOL bit.
     *
     * Clock Polarity
     */
    inline void toggle_TCR_CPOL() volatile
    {
        TCR ^= 1u << 31u;
    }

    /**
     * Get TCR's CPHA bit.
     *
     * Clock Phase
     */
    inline bool get_TCR_CPHA() volatile
    {
        return TCR & (1u << 30u);
    }

    /**
     * Set TCR's CPHA bit.
     *
     * Clock Phase
     */
    inline void set_TCR_CPHA() volatile
    {
        TCR |= 1u << 30u;
    }

    /**
     * Clear TCR's CPHA bit.
     *
     * Clock Phase
     */
    inline void clear_TCR_CPHA() volatile
    {
        TCR &= ~(1u << 30u);
    }

    /**
     * Toggle TCR's CPHA bit.
     *
     * Clock Phase
     */
    inline void toggle_TCR_CPHA() volatile
    {
        TCR ^= 1u << 30u;
    }

    /**
     * Get TCR's PRESCALE field.
     *
     * Prescaler Value
     */
    inline LPSPI1_TCR_PRESCALE get_TCR_PRESCALE() volatile
    {
        return LPSPI1_TCR_PRESCALE((TCR >> 27u) & 0b111u);
    }

    /**
     * Set TCR's PRESCALE field.
     *
     * Prescaler Value
     */
    inline void set_TCR_PRESCALE(LPSPI1_TCR_PRESCALE value) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b111u << 27u);
        curr |= (std::to_underlying(value) & 0b111u) << 27u;

        TCR = curr;
    }

    /**
     * Get TCR's PCS field.
     *
     * Peripheral Chip Select
     */
    inline LPSPI1_TCR_PCS get_TCR_PCS() volatile
    {
        return LPSPI1_TCR_PCS((TCR >> 24u) & 0b11u);
    }

    /**
     * Set TCR's PCS field.
     *
     * Peripheral Chip Select
     */
    inline void set_TCR_PCS(LPSPI1_TCR_PCS value) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(value) & 0b11u) << 24u;

        TCR = curr;
    }

    /**
     * Get TCR's LSBF bit.
     *
     * LSB First
     */
    inline bool get_TCR_LSBF() volatile
    {
        return TCR & (1u << 23u);
    }

    /**
     * Set TCR's LSBF bit.
     *
     * LSB First
     */
    inline void set_TCR_LSBF() volatile
    {
        TCR |= 1u << 23u;
    }

    /**
     * Clear TCR's LSBF bit.
     *
     * LSB First
     */
    inline void clear_TCR_LSBF() volatile
    {
        TCR &= ~(1u << 23u);
    }

    /**
     * Toggle TCR's LSBF bit.
     *
     * LSB First
     */
    inline void toggle_TCR_LSBF() volatile
    {
        TCR ^= 1u << 23u;
    }

    /**
     * Get TCR's BYSW bit.
     *
     * Byte Swap
     */
    inline bool get_TCR_BYSW() volatile
    {
        return TCR & (1u << 22u);
    }

    /**
     * Set TCR's BYSW bit.
     *
     * Byte Swap
     */
    inline void set_TCR_BYSW() volatile
    {
        TCR |= 1u << 22u;
    }

    /**
     * Clear TCR's BYSW bit.
     *
     * Byte Swap
     */
    inline void clear_TCR_BYSW() volatile
    {
        TCR &= ~(1u << 22u);
    }

    /**
     * Toggle TCR's BYSW bit.
     *
     * Byte Swap
     */
    inline void toggle_TCR_BYSW() volatile
    {
        TCR ^= 1u << 22u;
    }

    /**
     * Get TCR's CONT bit.
     *
     * Continuous Transfer
     */
    inline bool get_TCR_CONT() volatile
    {
        return TCR & (1u << 21u);
    }

    /**
     * Set TCR's CONT bit.
     *
     * Continuous Transfer
     */
    inline void set_TCR_CONT() volatile
    {
        TCR |= 1u << 21u;
    }

    /**
     * Clear TCR's CONT bit.
     *
     * Continuous Transfer
     */
    inline void clear_TCR_CONT() volatile
    {
        TCR &= ~(1u << 21u);
    }

    /**
     * Toggle TCR's CONT bit.
     *
     * Continuous Transfer
     */
    inline void toggle_TCR_CONT() volatile
    {
        TCR ^= 1u << 21u;
    }

    /**
     * Get TCR's CONTC bit.
     *
     * Continuing Command
     */
    inline bool get_TCR_CONTC() volatile
    {
        return TCR & (1u << 20u);
    }

    /**
     * Set TCR's CONTC bit.
     *
     * Continuing Command
     */
    inline void set_TCR_CONTC() volatile
    {
        TCR |= 1u << 20u;
    }

    /**
     * Clear TCR's CONTC bit.
     *
     * Continuing Command
     */
    inline void clear_TCR_CONTC() volatile
    {
        TCR &= ~(1u << 20u);
    }

    /**
     * Toggle TCR's CONTC bit.
     *
     * Continuing Command
     */
    inline void toggle_TCR_CONTC() volatile
    {
        TCR ^= 1u << 20u;
    }

    /**
     * Get TCR's RXMSK bit.
     *
     * Receive Data Mask
     */
    inline bool get_TCR_RXMSK() volatile
    {
        return TCR & (1u << 19u);
    }

    /**
     * Set TCR's RXMSK bit.
     *
     * Receive Data Mask
     */
    inline void set_TCR_RXMSK() volatile
    {
        TCR |= 1u << 19u;
    }

    /**
     * Clear TCR's RXMSK bit.
     *
     * Receive Data Mask
     */
    inline void clear_TCR_RXMSK() volatile
    {
        TCR &= ~(1u << 19u);
    }

    /**
     * Toggle TCR's RXMSK bit.
     *
     * Receive Data Mask
     */
    inline void toggle_TCR_RXMSK() volatile
    {
        TCR ^= 1u << 19u;
    }

    /**
     * Get TCR's TXMSK bit.
     *
     * Transmit Data Mask
     */
    inline bool get_TCR_TXMSK() volatile
    {
        return TCR & (1u << 18u);
    }

    /**
     * Set TCR's TXMSK bit.
     *
     * Transmit Data Mask
     */
    inline void set_TCR_TXMSK() volatile
    {
        TCR |= 1u << 18u;
    }

    /**
     * Clear TCR's TXMSK bit.
     *
     * Transmit Data Mask
     */
    inline void clear_TCR_TXMSK() volatile
    {
        TCR &= ~(1u << 18u);
    }

    /**
     * Toggle TCR's TXMSK bit.
     *
     * Transmit Data Mask
     */
    inline void toggle_TCR_TXMSK() volatile
    {
        TCR ^= 1u << 18u;
    }

    /**
     * Get TCR's WIDTH field.
     *
     * Transfer Width
     */
    inline LPSPI1_TCR_WIDTH get_TCR_WIDTH() volatile
    {
        return LPSPI1_TCR_WIDTH((TCR >> 16u) & 0b11u);
    }

    /**
     * Set TCR's WIDTH field.
     *
     * Transfer Width
     */
    inline void set_TCR_WIDTH(LPSPI1_TCR_WIDTH value) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        TCR = curr;
    }

    /**
     * Get TCR's FRAMESZ field.
     *
     * Frame Size
     */
    inline uint16_t get_TCR_FRAMESZ() volatile
    {
        return (TCR >> 0u) & 0b111111111111u;
    }

    /**
     * Set TCR's FRAMESZ field.
     *
     * Frame Size
     */
    inline void set_TCR_FRAMESZ(uint16_t value) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        TCR = curr;
    }

    /**
     * Get all of TCR's bit fields.
     *
     * (read-write) Transmit Command
     */
    inline void get_TCR(bool &CPOL, bool &CPHA, LPSPI1_TCR_PRESCALE &PRESCALE,
                        LPSPI1_TCR_PCS &PCS, bool &LSBF, bool &BYSW,
                        bool &CONT, bool &CONTC, bool &RXMSK, bool &TXMSK,
                        LPSPI1_TCR_WIDTH &WIDTH, uint16_t &FRAMESZ) volatile
    {
        uint32_t curr = TCR;

        CPOL = curr & (1u << 31u);
        CPHA = curr & (1u << 30u);
        PRESCALE = LPSPI1_TCR_PRESCALE((curr >> 27u) & 0b111u);
        PCS = LPSPI1_TCR_PCS((curr >> 24u) & 0b11u);
        LSBF = curr & (1u << 23u);
        BYSW = curr & (1u << 22u);
        CONT = curr & (1u << 21u);
        CONTC = curr & (1u << 20u);
        RXMSK = curr & (1u << 19u);
        TXMSK = curr & (1u << 18u);
        WIDTH = LPSPI1_TCR_WIDTH((curr >> 16u) & 0b11u);
        FRAMESZ = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of TCR's bit fields.
     *
     * (read-write) Transmit Command
     */
    inline void set_TCR(bool CPOL, bool CPHA, LPSPI1_TCR_PRESCALE PRESCALE,
                        LPSPI1_TCR_PCS PCS, bool LSBF, bool BYSW, bool CONT,
                        bool CONTC, bool RXMSK, bool TXMSK,
                        LPSPI1_TCR_WIDTH WIDTH, uint16_t FRAMESZ) volatile
    {
        uint32_t curr = TCR;

        curr &= ~(0b1u << 31u);
        curr |= (CPOL & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CPHA & 0b1u) << 30u;
        curr &= ~(0b111u << 27u);
        curr |= (std::to_underlying(PRESCALE) & 0b111u) << 27u;
        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(PCS) & 0b11u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (LSBF & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (BYSW & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (CONT & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (CONTC & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXMSK & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (TXMSK & 0b1u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(WIDTH) & 0b11u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FRAMESZ & 0b111111111111u) << 0u;

        TCR = curr;
    }

    /**
     * Set TDR's DATA field.
     *
     * Transmit Data
     */
    inline void set_TDR_DATA(uint32_t value) volatile
    {
        uint32_t curr = TDR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        TDR = curr;
    }

    /**
     * Get RSR's RXEMPTY bit.
     *
     * RX FIFO Empty
     */
    inline bool get_RSR_RXEMPTY() volatile
    {
        return RSR & (1u << 1u);
    }

    /**
     * Get RSR's SOF bit.
     *
     * Start Of Frame
     */
    inline bool get_RSR_SOF() volatile
    {
        return RSR & (1u << 0u);
    }

    /**
     * Get all of RSR's bit fields.
     *
     * (read-write) Receive Status
     */
    inline void get_RSR(bool &RXEMPTY, bool &SOF) volatile
    {
        uint32_t curr = RSR;

        RXEMPTY = curr & (1u << 1u);
        SOF = curr & (1u << 0u);
    }

    /**
     * Get RDR's DATA field.
     *
     * Receive Data
     */
    inline uint32_t get_RDR_DATA() volatile
    {
        return (RDR >> 0u) & 0b11111111111111111111111111111111u;
    }
};

static_assert(sizeof(lpspi1) == lpspi1::size);

static volatile lpspi1 *const LPSPI1 = reinterpret_cast<lpspi1 *>(0x40114000);

static volatile lpspi1 *const LPSPI2 = reinterpret_cast<lpspi1 *>(0x40118000);

static volatile lpspi1 *const LPSPI3 = reinterpret_cast<lpspi1 *>(0x4011C000);

static volatile lpspi1 *const LPSPI4 = reinterpret_cast<lpspi1 *>(0x40120000);

static volatile lpspi1 *const LPSPI5 = reinterpret_cast<lpspi1 *>(0x40C2C000);

static volatile lpspi1 *const LPSPI6 = reinterpret_cast<lpspi1 *>(0x40C30000);

}; // namespace MIMXRT1176::CM7
