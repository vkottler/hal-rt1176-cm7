/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/EMVSIM1_CLKCFG_GPCNT0_CLK_SEL.h"
#include "../enums/EMVSIM1_CLKCFG_GPCNT1_CLK_SEL.h"
#include "../enums/EMVSIM1_DIVISOR_DIVISOR_VALUE.h"
#include "../enums/EMVSIM1_RX_STATUS_RX_CNT.h"
#include "../enums/EMVSIM1_TX_STATUS_TX_CNT.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * EMVSIM
 */
struct [[gnu::packed]] emvsim1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 76; /*!< emvsim1's size in bytes. */

    /* Fields. */
    uint32_t VER_ID;    /*!< (read-write) Version ID Register */
    uint32_t PARAM;     /*!< (read-write) Parameter Register */
    uint32_t CLKCFG;    /*!< (read-write) Clock Configuration Register */
    uint32_t DIVISOR;   /*!< (read-write) Baud Rate Divisor Register */
    uint32_t CTRL;      /*!< (read-write) Control Register */
    uint32_t INT_MASK;  /*!< (read-write) Interrupt Mask Register */
    uint32_t RX_THD;    /*!< (read-write) Receiver Threshold Register */
    uint32_t TX_THD;    /*!< (read-write) Transmitter Threshold Register */
    uint32_t RX_STATUS; /*!< (read-write) Receive Status Register */
    uint32_t TX_STATUS; /*!< (read-write) Transmitter Status Register */
    uint32_t PCSR;      /*!< (read-write) Port Control and Status Register */
    uint32_t RX_BUF;    /*!< (read-write) Receive Data Read Buffer */
    uint32_t TX_BUF;    /*!< (read-write) Transmit Data Buffer */
    uint32_t TX_GETU; /*!< (read-write) Transmitter Guard ETU Value Register */
    uint32_t CWT_VAL; /*!< (read-write) Character Wait Time Value Register */
    uint32_t BWT_VAL; /*!< (read-write) Block Wait Time Value Register */
    uint32_t BGT_VAL; /*!< (read-write) Block Guard Time Value Register */
    uint32_t GPCNT0_VAL; /*!< (read-write) General Purpose Counter 0 Timeout
                            Value Register */
    uint32_t GPCNT1_VAL; /*!< (read-write) General Purpose Counter 1 Timeout
                            Value */

    /* Methods. */

    /**
     * Get VER_ID's VER field.
     *
     * Version ID of the module
     */
    inline uint32_t get_VER_ID_VER() volatile
    {
        return (VER_ID >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get PARAM's TX_FIFO_DEPTH field.
     *
     * Transmit FIFO Depth
     */
    inline uint8_t get_PARAM_TX_FIFO_DEPTH() volatile
    {
        return (PARAM >> 8u) & 0b11111111u;
    }

    /**
     * Get PARAM's RX_FIFO_DEPTH field.
     *
     * Receive FIFO Depth
     */
    inline uint8_t get_PARAM_RX_FIFO_DEPTH() volatile
    {
        return (PARAM >> 0u) & 0b11111111u;
    }

    /**
     * Get all of PARAM's bit fields.
     *
     * (read-write) Parameter Register
     */
    inline void get_PARAM(uint8_t &TX_FIFO_DEPTH,
                          uint8_t &RX_FIFO_DEPTH) volatile
    {
        uint32_t curr = PARAM;

        TX_FIFO_DEPTH = (curr >> 8u) & 0b11111111u;
        RX_FIFO_DEPTH = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get CLKCFG's GPCNT0_CLK_SEL field.
     *
     * General Purpose Counter 0 Clock Select
     */
    inline EMVSIM1_CLKCFG_GPCNT0_CLK_SEL get_CLKCFG_GPCNT0_CLK_SEL() volatile
    {
        return EMVSIM1_CLKCFG_GPCNT0_CLK_SEL((CLKCFG >> 10u) & 0b11u);
    }

    /**
     * Set CLKCFG's GPCNT0_CLK_SEL field.
     *
     * General Purpose Counter 0 Clock Select
     */
    inline void set_CLKCFG_GPCNT0_CLK_SEL(
        EMVSIM1_CLKCFG_GPCNT0_CLK_SEL value) volatile
    {
        uint32_t curr = CLKCFG;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CLKCFG = curr;
    }

    /**
     * Get CLKCFG's GPCNT1_CLK_SEL field.
     *
     * General Purpose Counter 1 Clock Select
     */
    inline EMVSIM1_CLKCFG_GPCNT1_CLK_SEL get_CLKCFG_GPCNT1_CLK_SEL() volatile
    {
        return EMVSIM1_CLKCFG_GPCNT1_CLK_SEL((CLKCFG >> 8u) & 0b11u);
    }

    /**
     * Set CLKCFG's GPCNT1_CLK_SEL field.
     *
     * General Purpose Counter 1 Clock Select
     */
    inline void set_CLKCFG_GPCNT1_CLK_SEL(
        EMVSIM1_CLKCFG_GPCNT1_CLK_SEL value) volatile
    {
        uint32_t curr = CLKCFG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CLKCFG = curr;
    }

    /**
     * Get CLKCFG's CLK_PRSC field.
     *
     * Clock Prescaler Value
     */
    inline uint8_t get_CLKCFG_CLK_PRSC() volatile
    {
        return (CLKCFG >> 0u) & 0b11111111u;
    }

    /**
     * Set CLKCFG's CLK_PRSC field.
     *
     * Clock Prescaler Value
     */
    inline void set_CLKCFG_CLK_PRSC(uint8_t value) volatile
    {
        uint32_t curr = CLKCFG;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLKCFG = curr;
    }

    /**
     * Get all of CLKCFG's bit fields.
     *
     * (read-write) Clock Configuration Register
     */
    inline void get_CLKCFG(EMVSIM1_CLKCFG_GPCNT0_CLK_SEL &GPCNT0_CLK_SEL,
                           EMVSIM1_CLKCFG_GPCNT1_CLK_SEL &GPCNT1_CLK_SEL,
                           uint8_t &CLK_PRSC) volatile
    {
        uint32_t curr = CLKCFG;

        GPCNT0_CLK_SEL = EMVSIM1_CLKCFG_GPCNT0_CLK_SEL((curr >> 10u) & 0b11u);
        GPCNT1_CLK_SEL = EMVSIM1_CLKCFG_GPCNT1_CLK_SEL((curr >> 8u) & 0b11u);
        CLK_PRSC = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CLKCFG's bit fields.
     *
     * (read-write) Clock Configuration Register
     */
    inline void set_CLKCFG(EMVSIM1_CLKCFG_GPCNT0_CLK_SEL GPCNT0_CLK_SEL,
                           EMVSIM1_CLKCFG_GPCNT1_CLK_SEL GPCNT1_CLK_SEL,
                           uint8_t CLK_PRSC) volatile
    {
        uint32_t curr = CLKCFG;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(GPCNT0_CLK_SEL) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(GPCNT1_CLK_SEL) & 0b11u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (CLK_PRSC & 0b11111111u) << 0u;

        CLKCFG = curr;
    }

    /**
     * Get DIVISOR's DIVISOR_VALUE field.
     *
     * Divisor (F/D) Value
     */
    inline EMVSIM1_DIVISOR_DIVISOR_VALUE get_DIVISOR_DIVISOR_VALUE() volatile
    {
        return EMVSIM1_DIVISOR_DIVISOR_VALUE((DIVISOR >> 0u) & 0b111111111u);
    }

    /**
     * Set DIVISOR's DIVISOR_VALUE field.
     *
     * Divisor (F/D) Value
     */
    inline void set_DIVISOR_DIVISOR_VALUE(
        EMVSIM1_DIVISOR_DIVISOR_VALUE value) volatile
    {
        uint32_t curr = DIVISOR;

        curr &= ~(0b111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111111u) << 0u;

        DIVISOR = curr;
    }

    /**
     * Get CTRL's BWT_EN bit.
     *
     * Block Wait Time Counter Enable
     */
    inline bool get_CTRL_BWT_EN() volatile
    {
        return CTRL & (1u << 31u);
    }

    /**
     * Set CTRL's BWT_EN bit.
     *
     * Block Wait Time Counter Enable
     */
    inline void set_CTRL_BWT_EN() volatile
    {
        CTRL |= 1u << 31u;
    }

    /**
     * Clear CTRL's BWT_EN bit.
     *
     * Block Wait Time Counter Enable
     */
    inline void clear_CTRL_BWT_EN() volatile
    {
        CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL's BWT_EN bit.
     *
     * Block Wait Time Counter Enable
     */
    inline void toggle_CTRL_BWT_EN() volatile
    {
        CTRL ^= 1u << 31u;
    }

    /**
     * Get CTRL's XMT_CRC_LRC bit.
     *
     * Transmit CRC or LRC Enable
     */
    inline bool get_CTRL_XMT_CRC_LRC() volatile
    {
        return CTRL & (1u << 30u);
    }

    /**
     * Set CTRL's XMT_CRC_LRC bit.
     *
     * Transmit CRC or LRC Enable
     */
    inline void set_CTRL_XMT_CRC_LRC() volatile
    {
        CTRL |= 1u << 30u;
    }

    /**
     * Clear CTRL's XMT_CRC_LRC bit.
     *
     * Transmit CRC or LRC Enable
     */
    inline void clear_CTRL_XMT_CRC_LRC() volatile
    {
        CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL's XMT_CRC_LRC bit.
     *
     * Transmit CRC or LRC Enable
     */
    inline void toggle_CTRL_XMT_CRC_LRC() volatile
    {
        CTRL ^= 1u << 30u;
    }

    /**
     * Get CTRL's CRC_EN bit.
     *
     * CRC Enable
     */
    inline bool get_CTRL_CRC_EN() volatile
    {
        return CTRL & (1u << 29u);
    }

    /**
     * Set CTRL's CRC_EN bit.
     *
     * CRC Enable
     */
    inline void set_CTRL_CRC_EN() volatile
    {
        CTRL |= 1u << 29u;
    }

    /**
     * Clear CTRL's CRC_EN bit.
     *
     * CRC Enable
     */
    inline void clear_CTRL_CRC_EN() volatile
    {
        CTRL &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL's CRC_EN bit.
     *
     * CRC Enable
     */
    inline void toggle_CTRL_CRC_EN() volatile
    {
        CTRL ^= 1u << 29u;
    }

    /**
     * Get CTRL's LRC_EN bit.
     *
     * LRC Enable
     */
    inline bool get_CTRL_LRC_EN() volatile
    {
        return CTRL & (1u << 28u);
    }

    /**
     * Set CTRL's LRC_EN bit.
     *
     * LRC Enable
     */
    inline void set_CTRL_LRC_EN() volatile
    {
        CTRL |= 1u << 28u;
    }

    /**
     * Clear CTRL's LRC_EN bit.
     *
     * LRC Enable
     */
    inline void clear_CTRL_LRC_EN() volatile
    {
        CTRL &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL's LRC_EN bit.
     *
     * LRC Enable
     */
    inline void toggle_CTRL_LRC_EN() volatile
    {
        CTRL ^= 1u << 28u;
    }

    /**
     * Get CTRL's CWT_EN bit.
     *
     * Character Wait Time Counter Enable
     */
    inline bool get_CTRL_CWT_EN() volatile
    {
        return CTRL & (1u << 27u);
    }

    /**
     * Set CTRL's CWT_EN bit.
     *
     * Character Wait Time Counter Enable
     */
    inline void set_CTRL_CWT_EN() volatile
    {
        CTRL |= 1u << 27u;
    }

    /**
     * Clear CTRL's CWT_EN bit.
     *
     * Character Wait Time Counter Enable
     */
    inline void clear_CTRL_CWT_EN() volatile
    {
        CTRL &= ~(1u << 27u);
    }

    /**
     * Toggle CTRL's CWT_EN bit.
     *
     * Character Wait Time Counter Enable
     */
    inline void toggle_CTRL_CWT_EN() volatile
    {
        CTRL ^= 1u << 27u;
    }

    /**
     * Get CTRL's CRC_IN_FLIP bit.
     *
     * CRC Input Byte's Bit Reversal or Flip Control
     */
    inline bool get_CTRL_CRC_IN_FLIP() volatile
    {
        return CTRL & (1u << 26u);
    }

    /**
     * Set CTRL's CRC_IN_FLIP bit.
     *
     * CRC Input Byte's Bit Reversal or Flip Control
     */
    inline void set_CTRL_CRC_IN_FLIP() volatile
    {
        CTRL |= 1u << 26u;
    }

    /**
     * Clear CTRL's CRC_IN_FLIP bit.
     *
     * CRC Input Byte's Bit Reversal or Flip Control
     */
    inline void clear_CTRL_CRC_IN_FLIP() volatile
    {
        CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL's CRC_IN_FLIP bit.
     *
     * CRC Input Byte's Bit Reversal or Flip Control
     */
    inline void toggle_CTRL_CRC_IN_FLIP() volatile
    {
        CTRL ^= 1u << 26u;
    }

    /**
     * Get CTRL's CRC_OUT_FLIP bit.
     *
     * CRC Output Value Bit Reversal or Flip
     */
    inline bool get_CTRL_CRC_OUT_FLIP() volatile
    {
        return CTRL & (1u << 25u);
    }

    /**
     * Set CTRL's CRC_OUT_FLIP bit.
     *
     * CRC Output Value Bit Reversal or Flip
     */
    inline void set_CTRL_CRC_OUT_FLIP() volatile
    {
        CTRL |= 1u << 25u;
    }

    /**
     * Clear CTRL's CRC_OUT_FLIP bit.
     *
     * CRC Output Value Bit Reversal or Flip
     */
    inline void clear_CTRL_CRC_OUT_FLIP() volatile
    {
        CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle CTRL's CRC_OUT_FLIP bit.
     *
     * CRC Output Value Bit Reversal or Flip
     */
    inline void toggle_CTRL_CRC_OUT_FLIP() volatile
    {
        CTRL ^= 1u << 25u;
    }

    /**
     * Get CTRL's INV_CRC_VAL bit.
     *
     * Invert bits in the CRC Output Value
     */
    inline bool get_CTRL_INV_CRC_VAL() volatile
    {
        return CTRL & (1u << 24u);
    }

    /**
     * Set CTRL's INV_CRC_VAL bit.
     *
     * Invert bits in the CRC Output Value
     */
    inline void set_CTRL_INV_CRC_VAL() volatile
    {
        CTRL |= 1u << 24u;
    }

    /**
     * Clear CTRL's INV_CRC_VAL bit.
     *
     * Invert bits in the CRC Output Value
     */
    inline void clear_CTRL_INV_CRC_VAL() volatile
    {
        CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL's INV_CRC_VAL bit.
     *
     * Invert bits in the CRC Output Value
     */
    inline void toggle_CTRL_INV_CRC_VAL() volatile
    {
        CTRL ^= 1u << 24u;
    }

    /**
     * Get CTRL's TX_DMA_EN bit.
     *
     * Transmit DMA Enable
     */
    inline bool get_CTRL_TX_DMA_EN() volatile
    {
        return CTRL & (1u << 20u);
    }

    /**
     * Set CTRL's TX_DMA_EN bit.
     *
     * Transmit DMA Enable
     */
    inline void set_CTRL_TX_DMA_EN() volatile
    {
        CTRL |= 1u << 20u;
    }

    /**
     * Clear CTRL's TX_DMA_EN bit.
     *
     * Transmit DMA Enable
     */
    inline void clear_CTRL_TX_DMA_EN() volatile
    {
        CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL's TX_DMA_EN bit.
     *
     * Transmit DMA Enable
     */
    inline void toggle_CTRL_TX_DMA_EN() volatile
    {
        CTRL ^= 1u << 20u;
    }

    /**
     * Get CTRL's RX_DMA_EN bit.
     *
     * Receive DMA Enable
     */
    inline bool get_CTRL_RX_DMA_EN() volatile
    {
        return CTRL & (1u << 19u);
    }

    /**
     * Set CTRL's RX_DMA_EN bit.
     *
     * Receive DMA Enable
     */
    inline void set_CTRL_RX_DMA_EN() volatile
    {
        CTRL |= 1u << 19u;
    }

    /**
     * Clear CTRL's RX_DMA_EN bit.
     *
     * Receive DMA Enable
     */
    inline void clear_CTRL_RX_DMA_EN() volatile
    {
        CTRL &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL's RX_DMA_EN bit.
     *
     * Receive DMA Enable
     */
    inline void toggle_CTRL_RX_DMA_EN() volatile
    {
        CTRL ^= 1u << 19u;
    }

    /**
     * Get CTRL's RCVR_11 bit.
     *
     * Receiver 11 ETU Mode Enable
     */
    inline bool get_CTRL_RCVR_11() volatile
    {
        return CTRL & (1u << 18u);
    }

    /**
     * Set CTRL's RCVR_11 bit.
     *
     * Receiver 11 ETU Mode Enable
     */
    inline void set_CTRL_RCVR_11() volatile
    {
        CTRL |= 1u << 18u;
    }

    /**
     * Clear CTRL's RCVR_11 bit.
     *
     * Receiver 11 ETU Mode Enable
     */
    inline void clear_CTRL_RCVR_11() volatile
    {
        CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL's RCVR_11 bit.
     *
     * Receiver 11 ETU Mode Enable
     */
    inline void toggle_CTRL_RCVR_11() volatile
    {
        CTRL ^= 1u << 18u;
    }

    /**
     * Get CTRL's XMT_EN bit.
     *
     * Transmitter Enable
     */
    inline bool get_CTRL_XMT_EN() volatile
    {
        return CTRL & (1u << 17u);
    }

    /**
     * Set CTRL's XMT_EN bit.
     *
     * Transmitter Enable
     */
    inline void set_CTRL_XMT_EN() volatile
    {
        CTRL |= 1u << 17u;
    }

    /**
     * Clear CTRL's XMT_EN bit.
     *
     * Transmitter Enable
     */
    inline void clear_CTRL_XMT_EN() volatile
    {
        CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL's XMT_EN bit.
     *
     * Transmitter Enable
     */
    inline void toggle_CTRL_XMT_EN() volatile
    {
        CTRL ^= 1u << 17u;
    }

    /**
     * Get CTRL's RCV_EN bit.
     *
     * Receiver Enable
     */
    inline bool get_CTRL_RCV_EN() volatile
    {
        return CTRL & (1u << 16u);
    }

    /**
     * Set CTRL's RCV_EN bit.
     *
     * Receiver Enable
     */
    inline void set_CTRL_RCV_EN() volatile
    {
        CTRL |= 1u << 16u;
    }

    /**
     * Clear CTRL's RCV_EN bit.
     *
     * Receiver Enable
     */
    inline void clear_CTRL_RCV_EN() volatile
    {
        CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL's RCV_EN bit.
     *
     * Receiver Enable
     */
    inline void toggle_CTRL_RCV_EN() volatile
    {
        CTRL ^= 1u << 16u;
    }

    /**
     * Get CTRL's STOP_EN bit.
     *
     * STOP Enable
     */
    inline bool get_CTRL_STOP_EN() volatile
    {
        return CTRL & (1u << 13u);
    }

    /**
     * Set CTRL's STOP_EN bit.
     *
     * STOP Enable
     */
    inline void set_CTRL_STOP_EN() volatile
    {
        CTRL |= 1u << 13u;
    }

    /**
     * Clear CTRL's STOP_EN bit.
     *
     * STOP Enable
     */
    inline void clear_CTRL_STOP_EN() volatile
    {
        CTRL &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL's STOP_EN bit.
     *
     * STOP Enable
     */
    inline void toggle_CTRL_STOP_EN() volatile
    {
        CTRL ^= 1u << 13u;
    }

    /**
     * Get CTRL's DOZE_EN bit.
     *
     * Doze Enable
     */
    inline bool get_CTRL_DOZE_EN() volatile
    {
        return CTRL & (1u << 12u);
    }

    /**
     * Set CTRL's DOZE_EN bit.
     *
     * Doze Enable
     */
    inline void set_CTRL_DOZE_EN() volatile
    {
        CTRL |= 1u << 12u;
    }

    /**
     * Clear CTRL's DOZE_EN bit.
     *
     * Doze Enable
     */
    inline void clear_CTRL_DOZE_EN() volatile
    {
        CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL's DOZE_EN bit.
     *
     * Doze Enable
     */
    inline void toggle_CTRL_DOZE_EN() volatile
    {
        CTRL ^= 1u << 12u;
    }

    /**
     * Get CTRL's KILL_CLOCKS bit.
     *
     * Kill all internal clocks
     */
    inline bool get_CTRL_KILL_CLOCKS() volatile
    {
        return CTRL & (1u << 11u);
    }

    /**
     * Set CTRL's KILL_CLOCKS bit.
     *
     * Kill all internal clocks
     */
    inline void set_CTRL_KILL_CLOCKS() volatile
    {
        CTRL |= 1u << 11u;
    }

    /**
     * Clear CTRL's KILL_CLOCKS bit.
     *
     * Kill all internal clocks
     */
    inline void clear_CTRL_KILL_CLOCKS() volatile
    {
        CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL's KILL_CLOCKS bit.
     *
     * Kill all internal clocks
     */
    inline void toggle_CTRL_KILL_CLOCKS() volatile
    {
        CTRL ^= 1u << 11u;
    }

    /**
     * Get CTRL's SW_RST bit.
     *
     * Software Reset Bit
     */
    inline bool get_CTRL_SW_RST() volatile
    {
        return CTRL & (1u << 10u);
    }

    /**
     * Set CTRL's SW_RST bit.
     *
     * Software Reset Bit
     */
    inline void set_CTRL_SW_RST() volatile
    {
        CTRL |= 1u << 10u;
    }

    /**
     * Clear CTRL's SW_RST bit.
     *
     * Software Reset Bit
     */
    inline void clear_CTRL_SW_RST() volatile
    {
        CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL's SW_RST bit.
     *
     * Software Reset Bit
     */
    inline void toggle_CTRL_SW_RST() volatile
    {
        CTRL ^= 1u << 10u;
    }

    /**
     * Get CTRL's FLSH_TX bit.
     *
     * Flush Transmitter Bit
     */
    inline bool get_CTRL_FLSH_TX() volatile
    {
        return CTRL & (1u << 9u);
    }

    /**
     * Set CTRL's FLSH_TX bit.
     *
     * Flush Transmitter Bit
     */
    inline void set_CTRL_FLSH_TX() volatile
    {
        CTRL |= 1u << 9u;
    }

    /**
     * Clear CTRL's FLSH_TX bit.
     *
     * Flush Transmitter Bit
     */
    inline void clear_CTRL_FLSH_TX() volatile
    {
        CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL's FLSH_TX bit.
     *
     * Flush Transmitter Bit
     */
    inline void toggle_CTRL_FLSH_TX() volatile
    {
        CTRL ^= 1u << 9u;
    }

    /**
     * Get CTRL's FLSH_RX bit.
     *
     * Flush Receiver Bit
     */
    inline bool get_CTRL_FLSH_RX() volatile
    {
        return CTRL & (1u << 8u);
    }

    /**
     * Set CTRL's FLSH_RX bit.
     *
     * Flush Receiver Bit
     */
    inline void set_CTRL_FLSH_RX() volatile
    {
        CTRL |= 1u << 8u;
    }

    /**
     * Clear CTRL's FLSH_RX bit.
     *
     * Flush Receiver Bit
     */
    inline void clear_CTRL_FLSH_RX() volatile
    {
        CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL's FLSH_RX bit.
     *
     * Flush Receiver Bit
     */
    inline void toggle_CTRL_FLSH_RX() volatile
    {
        CTRL ^= 1u << 8u;
    }

    /**
     * Get CTRL's ONACK bit.
     *
     * Overrun NACK Enable
     */
    inline bool get_CTRL_ONACK() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's ONACK bit.
     *
     * Overrun NACK Enable
     */
    inline void set_CTRL_ONACK() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's ONACK bit.
     *
     * Overrun NACK Enable
     */
    inline void clear_CTRL_ONACK() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's ONACK bit.
     *
     * Overrun NACK Enable
     */
    inline void toggle_CTRL_ONACK() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get CTRL's ANACK bit.
     *
     * Auto NACK Enable
     */
    inline bool get_CTRL_ANACK() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's ANACK bit.
     *
     * Auto NACK Enable
     */
    inline void set_CTRL_ANACK() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's ANACK bit.
     *
     * Auto NACK Enable
     */
    inline void clear_CTRL_ANACK() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's ANACK bit.
     *
     * Auto NACK Enable
     */
    inline void toggle_CTRL_ANACK() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's ICM bit.
     *
     * Initial Character Mode
     */
    inline bool get_CTRL_ICM() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's ICM bit.
     *
     * Initial Character Mode
     */
    inline void set_CTRL_ICM() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's ICM bit.
     *
     * Initial Character Mode
     */
    inline void clear_CTRL_ICM() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's ICM bit.
     *
     * Initial Character Mode
     */
    inline void toggle_CTRL_ICM() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's IC bit.
     *
     * Inverse Convention
     */
    inline bool get_CTRL_IC() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's IC bit.
     *
     * Inverse Convention
     */
    inline void set_CTRL_IC() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's IC bit.
     *
     * Inverse Convention
     */
    inline void clear_CTRL_IC() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's IC bit.
     *
     * Inverse Convention
     */
    inline void toggle_CTRL_IC() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) Control Register
     */
    inline void get_CTRL(bool &BWT_EN, bool &XMT_CRC_LRC, bool &CRC_EN,
                         bool &LRC_EN, bool &CWT_EN, bool &CRC_IN_FLIP,
                         bool &CRC_OUT_FLIP, bool &INV_CRC_VAL,
                         bool &TX_DMA_EN, bool &RX_DMA_EN, bool &RCVR_11,
                         bool &XMT_EN, bool &RCV_EN, bool &STOP_EN,
                         bool &DOZE_EN, bool &KILL_CLOCKS, bool &SW_RST,
                         bool &FLSH_TX, bool &FLSH_RX, bool &ONACK,
                         bool &ANACK, bool &ICM, bool &IC) volatile
    {
        uint32_t curr = CTRL;

        BWT_EN = curr & (1u << 31u);
        XMT_CRC_LRC = curr & (1u << 30u);
        CRC_EN = curr & (1u << 29u);
        LRC_EN = curr & (1u << 28u);
        CWT_EN = curr & (1u << 27u);
        CRC_IN_FLIP = curr & (1u << 26u);
        CRC_OUT_FLIP = curr & (1u << 25u);
        INV_CRC_VAL = curr & (1u << 24u);
        TX_DMA_EN = curr & (1u << 20u);
        RX_DMA_EN = curr & (1u << 19u);
        RCVR_11 = curr & (1u << 18u);
        XMT_EN = curr & (1u << 17u);
        RCV_EN = curr & (1u << 16u);
        STOP_EN = curr & (1u << 13u);
        DOZE_EN = curr & (1u << 12u);
        KILL_CLOCKS = curr & (1u << 11u);
        SW_RST = curr & (1u << 10u);
        FLSH_TX = curr & (1u << 9u);
        FLSH_RX = curr & (1u << 8u);
        ONACK = curr & (1u << 3u);
        ANACK = curr & (1u << 2u);
        ICM = curr & (1u << 1u);
        IC = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) Control Register
     */
    inline void set_CTRL(bool BWT_EN, bool XMT_CRC_LRC, bool CRC_EN,
                         bool LRC_EN, bool CWT_EN, bool CRC_IN_FLIP,
                         bool CRC_OUT_FLIP, bool INV_CRC_VAL, bool TX_DMA_EN,
                         bool RX_DMA_EN, bool RCVR_11, bool XMT_EN,
                         bool RCV_EN, bool STOP_EN, bool DOZE_EN,
                         bool KILL_CLOCKS, bool SW_RST, bool FLSH_TX,
                         bool FLSH_RX, bool ONACK, bool ANACK, bool ICM,
                         bool IC) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (BWT_EN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (XMT_CRC_LRC & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (CRC_EN & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (LRC_EN & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (CWT_EN & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (CRC_IN_FLIP & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (CRC_OUT_FLIP & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (INV_CRC_VAL & 0b1u) << 24u;
        curr &= ~(0b1u << 20u);
        curr |= (TX_DMA_EN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RX_DMA_EN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RCVR_11 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (XMT_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RCV_EN & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (STOP_EN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (DOZE_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (KILL_CLOCKS & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SW_RST & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (FLSH_TX & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (FLSH_RX & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (ONACK & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ANACK & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ICM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IC & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get INT_MASK's PEF_IM bit.
     *
     * Parity Error Interrupt Mask
     */
    inline bool get_INT_MASK_PEF_IM() volatile
    {
        return INT_MASK & (1u << 15u);
    }

    /**
     * Set INT_MASK's PEF_IM bit.
     *
     * Parity Error Interrupt Mask
     */
    inline void set_INT_MASK_PEF_IM() volatile
    {
        INT_MASK |= 1u << 15u;
    }

    /**
     * Clear INT_MASK's PEF_IM bit.
     *
     * Parity Error Interrupt Mask
     */
    inline void clear_INT_MASK_PEF_IM() volatile
    {
        INT_MASK &= ~(1u << 15u);
    }

    /**
     * Toggle INT_MASK's PEF_IM bit.
     *
     * Parity Error Interrupt Mask
     */
    inline void toggle_INT_MASK_PEF_IM() volatile
    {
        INT_MASK ^= 1u << 15u;
    }

    /**
     * Get INT_MASK's RX_DATA_IM bit.
     *
     * Receive Data Interrupt Mask
     */
    inline bool get_INT_MASK_RX_DATA_IM() volatile
    {
        return INT_MASK & (1u << 14u);
    }

    /**
     * Set INT_MASK's RX_DATA_IM bit.
     *
     * Receive Data Interrupt Mask
     */
    inline void set_INT_MASK_RX_DATA_IM() volatile
    {
        INT_MASK |= 1u << 14u;
    }

    /**
     * Clear INT_MASK's RX_DATA_IM bit.
     *
     * Receive Data Interrupt Mask
     */
    inline void clear_INT_MASK_RX_DATA_IM() volatile
    {
        INT_MASK &= ~(1u << 14u);
    }

    /**
     * Toggle INT_MASK's RX_DATA_IM bit.
     *
     * Receive Data Interrupt Mask
     */
    inline void toggle_INT_MASK_RX_DATA_IM() volatile
    {
        INT_MASK ^= 1u << 14u;
    }

    /**
     * Get INT_MASK's GPCNT1_IM bit.
     *
     * General Purpose Counter 1 Timeout Interrupt Mask
     */
    inline bool get_INT_MASK_GPCNT1_IM() volatile
    {
        return INT_MASK & (1u << 13u);
    }

    /**
     * Set INT_MASK's GPCNT1_IM bit.
     *
     * General Purpose Counter 1 Timeout Interrupt Mask
     */
    inline void set_INT_MASK_GPCNT1_IM() volatile
    {
        INT_MASK |= 1u << 13u;
    }

    /**
     * Clear INT_MASK's GPCNT1_IM bit.
     *
     * General Purpose Counter 1 Timeout Interrupt Mask
     */
    inline void clear_INT_MASK_GPCNT1_IM() volatile
    {
        INT_MASK &= ~(1u << 13u);
    }

    /**
     * Toggle INT_MASK's GPCNT1_IM bit.
     *
     * General Purpose Counter 1 Timeout Interrupt Mask
     */
    inline void toggle_INT_MASK_GPCNT1_IM() volatile
    {
        INT_MASK ^= 1u << 13u;
    }

    /**
     * Get INT_MASK's BGT_ERR_IM bit.
     *
     * Block Guard Time Error Interrupt
     */
    inline bool get_INT_MASK_BGT_ERR_IM() volatile
    {
        return INT_MASK & (1u << 12u);
    }

    /**
     * Set INT_MASK's BGT_ERR_IM bit.
     *
     * Block Guard Time Error Interrupt
     */
    inline void set_INT_MASK_BGT_ERR_IM() volatile
    {
        INT_MASK |= 1u << 12u;
    }

    /**
     * Clear INT_MASK's BGT_ERR_IM bit.
     *
     * Block Guard Time Error Interrupt
     */
    inline void clear_INT_MASK_BGT_ERR_IM() volatile
    {
        INT_MASK &= ~(1u << 12u);
    }

    /**
     * Toggle INT_MASK's BGT_ERR_IM bit.
     *
     * Block Guard Time Error Interrupt
     */
    inline void toggle_INT_MASK_BGT_ERR_IM() volatile
    {
        INT_MASK ^= 1u << 12u;
    }

    /**
     * Get INT_MASK's BWT_ERR_IM bit.
     *
     * Block Wait Time Error Interrupt Mask
     */
    inline bool get_INT_MASK_BWT_ERR_IM() volatile
    {
        return INT_MASK & (1u << 11u);
    }

    /**
     * Set INT_MASK's BWT_ERR_IM bit.
     *
     * Block Wait Time Error Interrupt Mask
     */
    inline void set_INT_MASK_BWT_ERR_IM() volatile
    {
        INT_MASK |= 1u << 11u;
    }

    /**
     * Clear INT_MASK's BWT_ERR_IM bit.
     *
     * Block Wait Time Error Interrupt Mask
     */
    inline void clear_INT_MASK_BWT_ERR_IM() volatile
    {
        INT_MASK &= ~(1u << 11u);
    }

    /**
     * Toggle INT_MASK's BWT_ERR_IM bit.
     *
     * Block Wait Time Error Interrupt Mask
     */
    inline void toggle_INT_MASK_BWT_ERR_IM() volatile
    {
        INT_MASK ^= 1u << 11u;
    }

    /**
     * Get INT_MASK's RNACK_IM bit.
     *
     * Receiver NACK Threshold Interrupt Mask
     */
    inline bool get_INT_MASK_RNACK_IM() volatile
    {
        return INT_MASK & (1u << 10u);
    }

    /**
     * Set INT_MASK's RNACK_IM bit.
     *
     * Receiver NACK Threshold Interrupt Mask
     */
    inline void set_INT_MASK_RNACK_IM() volatile
    {
        INT_MASK |= 1u << 10u;
    }

    /**
     * Clear INT_MASK's RNACK_IM bit.
     *
     * Receiver NACK Threshold Interrupt Mask
     */
    inline void clear_INT_MASK_RNACK_IM() volatile
    {
        INT_MASK &= ~(1u << 10u);
    }

    /**
     * Toggle INT_MASK's RNACK_IM bit.
     *
     * Receiver NACK Threshold Interrupt Mask
     */
    inline void toggle_INT_MASK_RNACK_IM() volatile
    {
        INT_MASK ^= 1u << 10u;
    }

    /**
     * Get INT_MASK's CWT_ERR_IM bit.
     *
     * Character Wait Time Error Interrupt Mask
     */
    inline bool get_INT_MASK_CWT_ERR_IM() volatile
    {
        return INT_MASK & (1u << 9u);
    }

    /**
     * Set INT_MASK's CWT_ERR_IM bit.
     *
     * Character Wait Time Error Interrupt Mask
     */
    inline void set_INT_MASK_CWT_ERR_IM() volatile
    {
        INT_MASK |= 1u << 9u;
    }

    /**
     * Clear INT_MASK's CWT_ERR_IM bit.
     *
     * Character Wait Time Error Interrupt Mask
     */
    inline void clear_INT_MASK_CWT_ERR_IM() volatile
    {
        INT_MASK &= ~(1u << 9u);
    }

    /**
     * Toggle INT_MASK's CWT_ERR_IM bit.
     *
     * Character Wait Time Error Interrupt Mask
     */
    inline void toggle_INT_MASK_CWT_ERR_IM() volatile
    {
        INT_MASK ^= 1u << 9u;
    }

    /**
     * Get INT_MASK's GPCNT0_IM bit.
     *
     * General Purpose Timer 0 Timeout Interrupt Mask
     */
    inline bool get_INT_MASK_GPCNT0_IM() volatile
    {
        return INT_MASK & (1u << 8u);
    }

    /**
     * Set INT_MASK's GPCNT0_IM bit.
     *
     * General Purpose Timer 0 Timeout Interrupt Mask
     */
    inline void set_INT_MASK_GPCNT0_IM() volatile
    {
        INT_MASK |= 1u << 8u;
    }

    /**
     * Clear INT_MASK's GPCNT0_IM bit.
     *
     * General Purpose Timer 0 Timeout Interrupt Mask
     */
    inline void clear_INT_MASK_GPCNT0_IM() volatile
    {
        INT_MASK &= ~(1u << 8u);
    }

    /**
     * Toggle INT_MASK's GPCNT0_IM bit.
     *
     * General Purpose Timer 0 Timeout Interrupt Mask
     */
    inline void toggle_INT_MASK_GPCNT0_IM() volatile
    {
        INT_MASK ^= 1u << 8u;
    }

    /**
     * Get INT_MASK's TDT_IM bit.
     *
     * Transmit Data Threshold Interrupt Mask
     */
    inline bool get_INT_MASK_TDT_IM() volatile
    {
        return INT_MASK & (1u << 7u);
    }

    /**
     * Set INT_MASK's TDT_IM bit.
     *
     * Transmit Data Threshold Interrupt Mask
     */
    inline void set_INT_MASK_TDT_IM() volatile
    {
        INT_MASK |= 1u << 7u;
    }

    /**
     * Clear INT_MASK's TDT_IM bit.
     *
     * Transmit Data Threshold Interrupt Mask
     */
    inline void clear_INT_MASK_TDT_IM() volatile
    {
        INT_MASK &= ~(1u << 7u);
    }

    /**
     * Toggle INT_MASK's TDT_IM bit.
     *
     * Transmit Data Threshold Interrupt Mask
     */
    inline void toggle_INT_MASK_TDT_IM() volatile
    {
        INT_MASK ^= 1u << 7u;
    }

    /**
     * Get INT_MASK's TFF_IM bit.
     *
     * Transmit FIFO Full Interrupt Mask
     */
    inline bool get_INT_MASK_TFF_IM() volatile
    {
        return INT_MASK & (1u << 6u);
    }

    /**
     * Set INT_MASK's TFF_IM bit.
     *
     * Transmit FIFO Full Interrupt Mask
     */
    inline void set_INT_MASK_TFF_IM() volatile
    {
        INT_MASK |= 1u << 6u;
    }

    /**
     * Clear INT_MASK's TFF_IM bit.
     *
     * Transmit FIFO Full Interrupt Mask
     */
    inline void clear_INT_MASK_TFF_IM() volatile
    {
        INT_MASK &= ~(1u << 6u);
    }

    /**
     * Toggle INT_MASK's TFF_IM bit.
     *
     * Transmit FIFO Full Interrupt Mask
     */
    inline void toggle_INT_MASK_TFF_IM() volatile
    {
        INT_MASK ^= 1u << 6u;
    }

    /**
     * Get INT_MASK's TNACK_IM bit.
     *
     * Transmit NACK Threshold Interrupt Mask
     */
    inline bool get_INT_MASK_TNACK_IM() volatile
    {
        return INT_MASK & (1u << 5u);
    }

    /**
     * Set INT_MASK's TNACK_IM bit.
     *
     * Transmit NACK Threshold Interrupt Mask
     */
    inline void set_INT_MASK_TNACK_IM() volatile
    {
        INT_MASK |= 1u << 5u;
    }

    /**
     * Clear INT_MASK's TNACK_IM bit.
     *
     * Transmit NACK Threshold Interrupt Mask
     */
    inline void clear_INT_MASK_TNACK_IM() volatile
    {
        INT_MASK &= ~(1u << 5u);
    }

    /**
     * Toggle INT_MASK's TNACK_IM bit.
     *
     * Transmit NACK Threshold Interrupt Mask
     */
    inline void toggle_INT_MASK_TNACK_IM() volatile
    {
        INT_MASK ^= 1u << 5u;
    }

    /**
     * Get INT_MASK's TFE_IM bit.
     *
     * Transmit FIFO Empty Interrupt Mask
     */
    inline bool get_INT_MASK_TFE_IM() volatile
    {
        return INT_MASK & (1u << 4u);
    }

    /**
     * Set INT_MASK's TFE_IM bit.
     *
     * Transmit FIFO Empty Interrupt Mask
     */
    inline void set_INT_MASK_TFE_IM() volatile
    {
        INT_MASK |= 1u << 4u;
    }

    /**
     * Clear INT_MASK's TFE_IM bit.
     *
     * Transmit FIFO Empty Interrupt Mask
     */
    inline void clear_INT_MASK_TFE_IM() volatile
    {
        INT_MASK &= ~(1u << 4u);
    }

    /**
     * Toggle INT_MASK's TFE_IM bit.
     *
     * Transmit FIFO Empty Interrupt Mask
     */
    inline void toggle_INT_MASK_TFE_IM() volatile
    {
        INT_MASK ^= 1u << 4u;
    }

    /**
     * Get INT_MASK's ETC_IM bit.
     *
     * Early Transmit Complete Interrupt Mask
     */
    inline bool get_INT_MASK_ETC_IM() volatile
    {
        return INT_MASK & (1u << 3u);
    }

    /**
     * Set INT_MASK's ETC_IM bit.
     *
     * Early Transmit Complete Interrupt Mask
     */
    inline void set_INT_MASK_ETC_IM() volatile
    {
        INT_MASK |= 1u << 3u;
    }

    /**
     * Clear INT_MASK's ETC_IM bit.
     *
     * Early Transmit Complete Interrupt Mask
     */
    inline void clear_INT_MASK_ETC_IM() volatile
    {
        INT_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle INT_MASK's ETC_IM bit.
     *
     * Early Transmit Complete Interrupt Mask
     */
    inline void toggle_INT_MASK_ETC_IM() volatile
    {
        INT_MASK ^= 1u << 3u;
    }

    /**
     * Get INT_MASK's RFO_IM bit.
     *
     * Receive FIFO Overflow Interrupt Mask
     */
    inline bool get_INT_MASK_RFO_IM() volatile
    {
        return INT_MASK & (1u << 2u);
    }

    /**
     * Set INT_MASK's RFO_IM bit.
     *
     * Receive FIFO Overflow Interrupt Mask
     */
    inline void set_INT_MASK_RFO_IM() volatile
    {
        INT_MASK |= 1u << 2u;
    }

    /**
     * Clear INT_MASK's RFO_IM bit.
     *
     * Receive FIFO Overflow Interrupt Mask
     */
    inline void clear_INT_MASK_RFO_IM() volatile
    {
        INT_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle INT_MASK's RFO_IM bit.
     *
     * Receive FIFO Overflow Interrupt Mask
     */
    inline void toggle_INT_MASK_RFO_IM() volatile
    {
        INT_MASK ^= 1u << 2u;
    }

    /**
     * Get INT_MASK's TC_IM bit.
     *
     * Transmit Complete Interrupt Mask
     */
    inline bool get_INT_MASK_TC_IM() volatile
    {
        return INT_MASK & (1u << 1u);
    }

    /**
     * Set INT_MASK's TC_IM bit.
     *
     * Transmit Complete Interrupt Mask
     */
    inline void set_INT_MASK_TC_IM() volatile
    {
        INT_MASK |= 1u << 1u;
    }

    /**
     * Clear INT_MASK's TC_IM bit.
     *
     * Transmit Complete Interrupt Mask
     */
    inline void clear_INT_MASK_TC_IM() volatile
    {
        INT_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle INT_MASK's TC_IM bit.
     *
     * Transmit Complete Interrupt Mask
     */
    inline void toggle_INT_MASK_TC_IM() volatile
    {
        INT_MASK ^= 1u << 1u;
    }

    /**
     * Get INT_MASK's RDT_IM bit.
     *
     * Receive Data Threshold Interrupt Mask
     */
    inline bool get_INT_MASK_RDT_IM() volatile
    {
        return INT_MASK & (1u << 0u);
    }

    /**
     * Set INT_MASK's RDT_IM bit.
     *
     * Receive Data Threshold Interrupt Mask
     */
    inline void set_INT_MASK_RDT_IM() volatile
    {
        INT_MASK |= 1u << 0u;
    }

    /**
     * Clear INT_MASK's RDT_IM bit.
     *
     * Receive Data Threshold Interrupt Mask
     */
    inline void clear_INT_MASK_RDT_IM() volatile
    {
        INT_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle INT_MASK's RDT_IM bit.
     *
     * Receive Data Threshold Interrupt Mask
     */
    inline void toggle_INT_MASK_RDT_IM() volatile
    {
        INT_MASK ^= 1u << 0u;
    }

    /**
     * Get all of INT_MASK's bit fields.
     *
     * (read-write) Interrupt Mask Register
     */
    inline void get_INT_MASK(bool &PEF_IM, bool &RX_DATA_IM, bool &GPCNT1_IM,
                             bool &BGT_ERR_IM, bool &BWT_ERR_IM,
                             bool &RNACK_IM, bool &CWT_ERR_IM, bool &GPCNT0_IM,
                             bool &TDT_IM, bool &TFF_IM, bool &TNACK_IM,
                             bool &TFE_IM, bool &ETC_IM, bool &RFO_IM,
                             bool &TC_IM, bool &RDT_IM) volatile
    {
        uint32_t curr = INT_MASK;

        PEF_IM = curr & (1u << 15u);
        RX_DATA_IM = curr & (1u << 14u);
        GPCNT1_IM = curr & (1u << 13u);
        BGT_ERR_IM = curr & (1u << 12u);
        BWT_ERR_IM = curr & (1u << 11u);
        RNACK_IM = curr & (1u << 10u);
        CWT_ERR_IM = curr & (1u << 9u);
        GPCNT0_IM = curr & (1u << 8u);
        TDT_IM = curr & (1u << 7u);
        TFF_IM = curr & (1u << 6u);
        TNACK_IM = curr & (1u << 5u);
        TFE_IM = curr & (1u << 4u);
        ETC_IM = curr & (1u << 3u);
        RFO_IM = curr & (1u << 2u);
        TC_IM = curr & (1u << 1u);
        RDT_IM = curr & (1u << 0u);
    }

    /**
     * Set all of INT_MASK's bit fields.
     *
     * (read-write) Interrupt Mask Register
     */
    inline void set_INT_MASK(bool PEF_IM, bool RX_DATA_IM, bool GPCNT1_IM,
                             bool BGT_ERR_IM, bool BWT_ERR_IM, bool RNACK_IM,
                             bool CWT_ERR_IM, bool GPCNT0_IM, bool TDT_IM,
                             bool TFF_IM, bool TNACK_IM, bool TFE_IM,
                             bool ETC_IM, bool RFO_IM, bool TC_IM,
                             bool RDT_IM) volatile
    {
        uint32_t curr = INT_MASK;

        curr &= ~(0b1u << 15u);
        curr |= (PEF_IM & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (RX_DATA_IM & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (GPCNT1_IM & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (BGT_ERR_IM & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (BWT_ERR_IM & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RNACK_IM & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (CWT_ERR_IM & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (GPCNT0_IM & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (TDT_IM & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TFF_IM & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TNACK_IM & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TFE_IM & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ETC_IM & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RFO_IM & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TC_IM & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RDT_IM & 0b1u) << 0u;

        INT_MASK = curr;
    }

    /**
     * Get RX_THD's RNCK_THD field.
     *
     * Receiver NACK Threshold Value
     */
    inline uint8_t get_RX_THD_RNCK_THD() volatile
    {
        return (RX_THD >> 8u) & 0b1111u;
    }

    /**
     * Set RX_THD's RNCK_THD field.
     *
     * Receiver NACK Threshold Value
     */
    inline void set_RX_THD_RNCK_THD(uint8_t value) volatile
    {
        uint32_t curr = RX_THD;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        RX_THD = curr;
    }

    /**
     * Get RX_THD's RDT field.
     *
     * Receiver Data Threshold Value
     */
    inline uint8_t get_RX_THD_RDT() volatile
    {
        return (RX_THD >> 0u) & 0b1111u;
    }

    /**
     * Set RX_THD's RDT field.
     *
     * Receiver Data Threshold Value
     */
    inline void set_RX_THD_RDT(uint8_t value) volatile
    {
        uint32_t curr = RX_THD;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        RX_THD = curr;
    }

    /**
     * Get all of RX_THD's bit fields.
     *
     * (read-write) Receiver Threshold Register
     */
    inline void get_RX_THD(uint8_t &RNCK_THD, uint8_t &RDT) volatile
    {
        uint32_t curr = RX_THD;

        RNCK_THD = (curr >> 8u) & 0b1111u;
        RDT = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of RX_THD's bit fields.
     *
     * (read-write) Receiver Threshold Register
     */
    inline void set_RX_THD(uint8_t RNCK_THD, uint8_t RDT) volatile
    {
        uint32_t curr = RX_THD;

        curr &= ~(0b1111u << 8u);
        curr |= (RNCK_THD & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (RDT & 0b1111u) << 0u;

        RX_THD = curr;
    }

    /**
     * Get TX_THD's TNCK_THD field.
     *
     * Transmitter NACK Threshold Value
     */
    inline uint8_t get_TX_THD_TNCK_THD() volatile
    {
        return (TX_THD >> 8u) & 0b1111u;
    }

    /**
     * Set TX_THD's TNCK_THD field.
     *
     * Transmitter NACK Threshold Value
     */
    inline void set_TX_THD_TNCK_THD(uint8_t value) volatile
    {
        uint32_t curr = TX_THD;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TX_THD = curr;
    }

    /**
     * Get TX_THD's TDT field.
     *
     * Transmitter Data Threshold Value
     */
    inline uint8_t get_TX_THD_TDT() volatile
    {
        return (TX_THD >> 0u) & 0b1111u;
    }

    /**
     * Set TX_THD's TDT field.
     *
     * Transmitter Data Threshold Value
     */
    inline void set_TX_THD_TDT(uint8_t value) volatile
    {
        uint32_t curr = TX_THD;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        TX_THD = curr;
    }

    /**
     * Get all of TX_THD's bit fields.
     *
     * (read-write) Transmitter Threshold Register
     */
    inline void get_TX_THD(uint8_t &TNCK_THD, uint8_t &TDT) volatile
    {
        uint32_t curr = TX_THD;

        TNCK_THD = (curr >> 8u) & 0b1111u;
        TDT = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of TX_THD's bit fields.
     *
     * (read-write) Transmitter Threshold Register
     */
    inline void set_TX_THD(uint8_t TNCK_THD, uint8_t TDT) volatile
    {
        uint32_t curr = TX_THD;

        curr &= ~(0b1111u << 8u);
        curr |= (TNCK_THD & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (TDT & 0b1111u) << 0u;

        TX_THD = curr;
    }

    /**
     * Get RX_STATUS's RX_CNT field.
     *
     * Receive FIFO Byte Count
     */
    inline EMVSIM1_RX_STATUS_RX_CNT get_RX_STATUS_RX_CNT() volatile
    {
        return EMVSIM1_RX_STATUS_RX_CNT((RX_STATUS >> 24u) & 0b1111u);
    }

    /**
     * Get RX_STATUS's RX_WPTR field.
     *
     * Receive FIFO Write Pointer Value
     */
    inline uint8_t get_RX_STATUS_RX_WPTR() volatile
    {
        return (RX_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get RX_STATUS's FEF bit.
     *
     * Frame Error Flag
     */
    inline bool get_RX_STATUS_FEF() volatile
    {
        return RX_STATUS & (1u << 13u);
    }

    /**
     * Set RX_STATUS's FEF bit.
     *
     * Frame Error Flag
     */
    inline void set_RX_STATUS_FEF() volatile
    {
        RX_STATUS |= 1u << 13u;
    }

    /**
     * Clear RX_STATUS's FEF bit.
     *
     * Frame Error Flag
     */
    inline void clear_RX_STATUS_FEF() volatile
    {
        RX_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle RX_STATUS's FEF bit.
     *
     * Frame Error Flag
     */
    inline void toggle_RX_STATUS_FEF() volatile
    {
        RX_STATUS ^= 1u << 13u;
    }

    /**
     * Get RX_STATUS's PEF bit.
     *
     * Parity Error Flag
     */
    inline bool get_RX_STATUS_PEF() volatile
    {
        return RX_STATUS & (1u << 12u);
    }

    /**
     * Set RX_STATUS's PEF bit.
     *
     * Parity Error Flag
     */
    inline void set_RX_STATUS_PEF() volatile
    {
        RX_STATUS |= 1u << 12u;
    }

    /**
     * Clear RX_STATUS's PEF bit.
     *
     * Parity Error Flag
     */
    inline void clear_RX_STATUS_PEF() volatile
    {
        RX_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle RX_STATUS's PEF bit.
     *
     * Parity Error Flag
     */
    inline void toggle_RX_STATUS_PEF() volatile
    {
        RX_STATUS ^= 1u << 12u;
    }

    /**
     * Get RX_STATUS's BGT_ERR bit.
     *
     * Block Guard Time Error Flag
     */
    inline bool get_RX_STATUS_BGT_ERR() volatile
    {
        return RX_STATUS & (1u << 11u);
    }

    /**
     * Set RX_STATUS's BGT_ERR bit.
     *
     * Block Guard Time Error Flag
     */
    inline void set_RX_STATUS_BGT_ERR() volatile
    {
        RX_STATUS |= 1u << 11u;
    }

    /**
     * Clear RX_STATUS's BGT_ERR bit.
     *
     * Block Guard Time Error Flag
     */
    inline void clear_RX_STATUS_BGT_ERR() volatile
    {
        RX_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle RX_STATUS's BGT_ERR bit.
     *
     * Block Guard Time Error Flag
     */
    inline void toggle_RX_STATUS_BGT_ERR() volatile
    {
        RX_STATUS ^= 1u << 11u;
    }

    /**
     * Get RX_STATUS's BWT_ERR bit.
     *
     * Block Wait Time Error Flag
     */
    inline bool get_RX_STATUS_BWT_ERR() volatile
    {
        return RX_STATUS & (1u << 10u);
    }

    /**
     * Set RX_STATUS's BWT_ERR bit.
     *
     * Block Wait Time Error Flag
     */
    inline void set_RX_STATUS_BWT_ERR() volatile
    {
        RX_STATUS |= 1u << 10u;
    }

    /**
     * Clear RX_STATUS's BWT_ERR bit.
     *
     * Block Wait Time Error Flag
     */
    inline void clear_RX_STATUS_BWT_ERR() volatile
    {
        RX_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle RX_STATUS's BWT_ERR bit.
     *
     * Block Wait Time Error Flag
     */
    inline void toggle_RX_STATUS_BWT_ERR() volatile
    {
        RX_STATUS ^= 1u << 10u;
    }

    /**
     * Get RX_STATUS's RTE bit.
     *
     * Received NACK Threshold Error Flag
     */
    inline bool get_RX_STATUS_RTE() volatile
    {
        return RX_STATUS & (1u << 9u);
    }

    /**
     * Set RX_STATUS's RTE bit.
     *
     * Received NACK Threshold Error Flag
     */
    inline void set_RX_STATUS_RTE() volatile
    {
        RX_STATUS |= 1u << 9u;
    }

    /**
     * Clear RX_STATUS's RTE bit.
     *
     * Received NACK Threshold Error Flag
     */
    inline void clear_RX_STATUS_RTE() volatile
    {
        RX_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle RX_STATUS's RTE bit.
     *
     * Received NACK Threshold Error Flag
     */
    inline void toggle_RX_STATUS_RTE() volatile
    {
        RX_STATUS ^= 1u << 9u;
    }

    /**
     * Get RX_STATUS's CWT_ERR bit.
     *
     * Character Wait Time Error Flag
     */
    inline bool get_RX_STATUS_CWT_ERR() volatile
    {
        return RX_STATUS & (1u << 8u);
    }

    /**
     * Set RX_STATUS's CWT_ERR bit.
     *
     * Character Wait Time Error Flag
     */
    inline void set_RX_STATUS_CWT_ERR() volatile
    {
        RX_STATUS |= 1u << 8u;
    }

    /**
     * Clear RX_STATUS's CWT_ERR bit.
     *
     * Character Wait Time Error Flag
     */
    inline void clear_RX_STATUS_CWT_ERR() volatile
    {
        RX_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle RX_STATUS's CWT_ERR bit.
     *
     * Character Wait Time Error Flag
     */
    inline void toggle_RX_STATUS_CWT_ERR() volatile
    {
        RX_STATUS ^= 1u << 8u;
    }

    /**
     * Get RX_STATUS's CRC_OK bit.
     *
     * CRC Check OK Flag
     */
    inline bool get_RX_STATUS_CRC_OK() volatile
    {
        return RX_STATUS & (1u << 7u);
    }

    /**
     * Get RX_STATUS's LRC_OK bit.
     *
     * LRC Check OK Flag
     */
    inline bool get_RX_STATUS_LRC_OK() volatile
    {
        return RX_STATUS & (1u << 6u);
    }

    /**
     * Get RX_STATUS's RDTF bit.
     *
     * Receive Data Threshold Interrupt Flag
     */
    inline bool get_RX_STATUS_RDTF() volatile
    {
        return RX_STATUS & (1u << 5u);
    }

    /**
     * Get RX_STATUS's RX_DATA bit.
     *
     * Receive Data Interrupt Flag
     */
    inline bool get_RX_STATUS_RX_DATA() volatile
    {
        return RX_STATUS & (1u << 4u);
    }

    /**
     * Set RX_STATUS's RX_DATA bit.
     *
     * Receive Data Interrupt Flag
     */
    inline void set_RX_STATUS_RX_DATA() volatile
    {
        RX_STATUS |= 1u << 4u;
    }

    /**
     * Clear RX_STATUS's RX_DATA bit.
     *
     * Receive Data Interrupt Flag
     */
    inline void clear_RX_STATUS_RX_DATA() volatile
    {
        RX_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle RX_STATUS's RX_DATA bit.
     *
     * Receive Data Interrupt Flag
     */
    inline void toggle_RX_STATUS_RX_DATA() volatile
    {
        RX_STATUS ^= 1u << 4u;
    }

    /**
     * Get RX_STATUS's RFO bit.
     *
     * Receive FIFO Overflow Flag
     */
    inline bool get_RX_STATUS_RFO() volatile
    {
        return RX_STATUS & (1u << 0u);
    }

    /**
     * Set RX_STATUS's RFO bit.
     *
     * Receive FIFO Overflow Flag
     */
    inline void set_RX_STATUS_RFO() volatile
    {
        RX_STATUS |= 1u << 0u;
    }

    /**
     * Clear RX_STATUS's RFO bit.
     *
     * Receive FIFO Overflow Flag
     */
    inline void clear_RX_STATUS_RFO() volatile
    {
        RX_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle RX_STATUS's RFO bit.
     *
     * Receive FIFO Overflow Flag
     */
    inline void toggle_RX_STATUS_RFO() volatile
    {
        RX_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of RX_STATUS's bit fields.
     *
     * (read-write) Receive Status Register
     */
    inline void get_RX_STATUS(EMVSIM1_RX_STATUS_RX_CNT &RX_CNT,
                              uint8_t &RX_WPTR, bool &FEF, bool &PEF,
                              bool &BGT_ERR, bool &BWT_ERR, bool &RTE,
                              bool &CWT_ERR, bool &CRC_OK, bool &LRC_OK,
                              bool &RDTF, bool &RX_DATA, bool &RFO) volatile
    {
        uint32_t curr = RX_STATUS;

        RX_CNT = EMVSIM1_RX_STATUS_RX_CNT((curr >> 24u) & 0b1111u);
        RX_WPTR = (curr >> 16u) & 0b1111u;
        FEF = curr & (1u << 13u);
        PEF = curr & (1u << 12u);
        BGT_ERR = curr & (1u << 11u);
        BWT_ERR = curr & (1u << 10u);
        RTE = curr & (1u << 9u);
        CWT_ERR = curr & (1u << 8u);
        CRC_OK = curr & (1u << 7u);
        LRC_OK = curr & (1u << 6u);
        RDTF = curr & (1u << 5u);
        RX_DATA = curr & (1u << 4u);
        RFO = curr & (1u << 0u);
    }

    /**
     * Set all of RX_STATUS's bit fields.
     *
     * (read-write) Receive Status Register
     */
    inline void set_RX_STATUS(bool FEF, bool PEF, bool BGT_ERR, bool BWT_ERR,
                              bool RTE, bool CWT_ERR, bool RX_DATA,
                              bool RFO) volatile
    {
        uint32_t curr = RX_STATUS;

        curr &= ~(0b1u << 13u);
        curr |= (FEF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PEF & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (BGT_ERR & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (BWT_ERR & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (RTE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CWT_ERR & 0b1u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (RX_DATA & 0b1u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (RFO & 0b1u) << 0u;

        RX_STATUS = curr;
    }

    /**
     * Get TX_STATUS's TX_CNT field.
     *
     * Transmit FIFO Byte Count
     */
    inline EMVSIM1_TX_STATUS_TX_CNT get_TX_STATUS_TX_CNT() volatile
    {
        return EMVSIM1_TX_STATUS_TX_CNT((TX_STATUS >> 24u) & 0b1111u);
    }

    /**
     * Get TX_STATUS's TX_RPTR field.
     *
     * Transmit FIFO Read Pointer
     */
    inline uint8_t get_TX_STATUS_TX_RPTR() volatile
    {
        return (TX_STATUS >> 16u) & 0b1111u;
    }

    /**
     * Get TX_STATUS's GPCNT1_TO bit.
     *
     * General Purpose Counter 1 Timeout Flag
     */
    inline bool get_TX_STATUS_GPCNT1_TO() volatile
    {
        return TX_STATUS & (1u << 9u);
    }

    /**
     * Set TX_STATUS's GPCNT1_TO bit.
     *
     * General Purpose Counter 1 Timeout Flag
     */
    inline void set_TX_STATUS_GPCNT1_TO() volatile
    {
        TX_STATUS |= 1u << 9u;
    }

    /**
     * Clear TX_STATUS's GPCNT1_TO bit.
     *
     * General Purpose Counter 1 Timeout Flag
     */
    inline void clear_TX_STATUS_GPCNT1_TO() volatile
    {
        TX_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle TX_STATUS's GPCNT1_TO bit.
     *
     * General Purpose Counter 1 Timeout Flag
     */
    inline void toggle_TX_STATUS_GPCNT1_TO() volatile
    {
        TX_STATUS ^= 1u << 9u;
    }

    /**
     * Get TX_STATUS's GPCNT0_TO bit.
     *
     * General Purpose Counter 0 Timeout Flag
     */
    inline bool get_TX_STATUS_GPCNT0_TO() volatile
    {
        return TX_STATUS & (1u << 8u);
    }

    /**
     * Set TX_STATUS's GPCNT0_TO bit.
     *
     * General Purpose Counter 0 Timeout Flag
     */
    inline void set_TX_STATUS_GPCNT0_TO() volatile
    {
        TX_STATUS |= 1u << 8u;
    }

    /**
     * Clear TX_STATUS's GPCNT0_TO bit.
     *
     * General Purpose Counter 0 Timeout Flag
     */
    inline void clear_TX_STATUS_GPCNT0_TO() volatile
    {
        TX_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle TX_STATUS's GPCNT0_TO bit.
     *
     * General Purpose Counter 0 Timeout Flag
     */
    inline void toggle_TX_STATUS_GPCNT0_TO() volatile
    {
        TX_STATUS ^= 1u << 8u;
    }

    /**
     * Get TX_STATUS's TDTF bit.
     *
     * Transmit Data Threshold Flag
     */
    inline bool get_TX_STATUS_TDTF() volatile
    {
        return TX_STATUS & (1u << 7u);
    }

    /**
     * Get TX_STATUS's TFF bit.
     *
     * Transmit FIFO Full Flag
     */
    inline bool get_TX_STATUS_TFF() volatile
    {
        return TX_STATUS & (1u << 6u);
    }

    /**
     * Set TX_STATUS's TFF bit.
     *
     * Transmit FIFO Full Flag
     */
    inline void set_TX_STATUS_TFF() volatile
    {
        TX_STATUS |= 1u << 6u;
    }

    /**
     * Clear TX_STATUS's TFF bit.
     *
     * Transmit FIFO Full Flag
     */
    inline void clear_TX_STATUS_TFF() volatile
    {
        TX_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle TX_STATUS's TFF bit.
     *
     * Transmit FIFO Full Flag
     */
    inline void toggle_TX_STATUS_TFF() volatile
    {
        TX_STATUS ^= 1u << 6u;
    }

    /**
     * Get TX_STATUS's TCF bit.
     *
     * Transmit Complete Flag
     */
    inline bool get_TX_STATUS_TCF() volatile
    {
        return TX_STATUS & (1u << 5u);
    }

    /**
     * Set TX_STATUS's TCF bit.
     *
     * Transmit Complete Flag
     */
    inline void set_TX_STATUS_TCF() volatile
    {
        TX_STATUS |= 1u << 5u;
    }

    /**
     * Clear TX_STATUS's TCF bit.
     *
     * Transmit Complete Flag
     */
    inline void clear_TX_STATUS_TCF() volatile
    {
        TX_STATUS &= ~(1u << 5u);
    }

    /**
     * Toggle TX_STATUS's TCF bit.
     *
     * Transmit Complete Flag
     */
    inline void toggle_TX_STATUS_TCF() volatile
    {
        TX_STATUS ^= 1u << 5u;
    }

    /**
     * Get TX_STATUS's ETCF bit.
     *
     * Early Transmit Complete Flag
     */
    inline bool get_TX_STATUS_ETCF() volatile
    {
        return TX_STATUS & (1u << 4u);
    }

    /**
     * Set TX_STATUS's ETCF bit.
     *
     * Early Transmit Complete Flag
     */
    inline void set_TX_STATUS_ETCF() volatile
    {
        TX_STATUS |= 1u << 4u;
    }

    /**
     * Clear TX_STATUS's ETCF bit.
     *
     * Early Transmit Complete Flag
     */
    inline void clear_TX_STATUS_ETCF() volatile
    {
        TX_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle TX_STATUS's ETCF bit.
     *
     * Early Transmit Complete Flag
     */
    inline void toggle_TX_STATUS_ETCF() volatile
    {
        TX_STATUS ^= 1u << 4u;
    }

    /**
     * Get TX_STATUS's TFE bit.
     *
     * Transmit FIFO Empty Flag
     */
    inline bool get_TX_STATUS_TFE() volatile
    {
        return TX_STATUS & (1u << 3u);
    }

    /**
     * Set TX_STATUS's TFE bit.
     *
     * Transmit FIFO Empty Flag
     */
    inline void set_TX_STATUS_TFE() volatile
    {
        TX_STATUS |= 1u << 3u;
    }

    /**
     * Clear TX_STATUS's TFE bit.
     *
     * Transmit FIFO Empty Flag
     */
    inline void clear_TX_STATUS_TFE() volatile
    {
        TX_STATUS &= ~(1u << 3u);
    }

    /**
     * Toggle TX_STATUS's TFE bit.
     *
     * Transmit FIFO Empty Flag
     */
    inline void toggle_TX_STATUS_TFE() volatile
    {
        TX_STATUS ^= 1u << 3u;
    }

    /**
     * Get TX_STATUS's TNTE bit.
     *
     * Transmit NACK Threshold Error Flag
     */
    inline bool get_TX_STATUS_TNTE() volatile
    {
        return TX_STATUS & (1u << 0u);
    }

    /**
     * Set TX_STATUS's TNTE bit.
     *
     * Transmit NACK Threshold Error Flag
     */
    inline void set_TX_STATUS_TNTE() volatile
    {
        TX_STATUS |= 1u << 0u;
    }

    /**
     * Clear TX_STATUS's TNTE bit.
     *
     * Transmit NACK Threshold Error Flag
     */
    inline void clear_TX_STATUS_TNTE() volatile
    {
        TX_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle TX_STATUS's TNTE bit.
     *
     * Transmit NACK Threshold Error Flag
     */
    inline void toggle_TX_STATUS_TNTE() volatile
    {
        TX_STATUS ^= 1u << 0u;
    }

    /**
     * Get all of TX_STATUS's bit fields.
     *
     * (read-write) Transmitter Status Register
     */
    inline void get_TX_STATUS(EMVSIM1_TX_STATUS_TX_CNT &TX_CNT,
                              uint8_t &TX_RPTR, bool &GPCNT1_TO,
                              bool &GPCNT0_TO, bool &TDTF, bool &TFF,
                              bool &TCF, bool &ETCF, bool &TFE,
                              bool &TNTE) volatile
    {
        uint32_t curr = TX_STATUS;

        TX_CNT = EMVSIM1_TX_STATUS_TX_CNT((curr >> 24u) & 0b1111u);
        TX_RPTR = (curr >> 16u) & 0b1111u;
        GPCNT1_TO = curr & (1u << 9u);
        GPCNT0_TO = curr & (1u << 8u);
        TDTF = curr & (1u << 7u);
        TFF = curr & (1u << 6u);
        TCF = curr & (1u << 5u);
        ETCF = curr & (1u << 4u);
        TFE = curr & (1u << 3u);
        TNTE = curr & (1u << 0u);
    }

    /**
     * Set all of TX_STATUS's bit fields.
     *
     * (read-write) Transmitter Status Register
     */
    inline void set_TX_STATUS(bool GPCNT1_TO, bool GPCNT0_TO, bool TFF,
                              bool TCF, bool ETCF, bool TFE,
                              bool TNTE) volatile
    {
        uint32_t curr = TX_STATUS;

        curr &= ~(0b1u << 9u);
        curr |= (GPCNT1_TO & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (GPCNT0_TO & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (TFF & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TCF & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ETCF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TFE & 0b1u) << 3u;
        curr &= ~(0b1u << 0u);
        curr |= (TNTE & 0b1u) << 0u;

        TX_STATUS = curr;
    }

    /**
     * Get PCSR's SPDES bit.
     *
     * SIM Presence Detect Edge Select
     */
    inline bool get_PCSR_SPDES() volatile
    {
        return PCSR & (1u << 27u);
    }

    /**
     * Set PCSR's SPDES bit.
     *
     * SIM Presence Detect Edge Select
     */
    inline void set_PCSR_SPDES() volatile
    {
        PCSR |= 1u << 27u;
    }

    /**
     * Clear PCSR's SPDES bit.
     *
     * SIM Presence Detect Edge Select
     */
    inline void clear_PCSR_SPDES() volatile
    {
        PCSR &= ~(1u << 27u);
    }

    /**
     * Toggle PCSR's SPDES bit.
     *
     * SIM Presence Detect Edge Select
     */
    inline void toggle_PCSR_SPDES() volatile
    {
        PCSR ^= 1u << 27u;
    }

    /**
     * Get PCSR's SPDP bit.
     *
     * Smart Card Presence Detect Pin Status
     */
    inline bool get_PCSR_SPDP() volatile
    {
        return PCSR & (1u << 26u);
    }

    /**
     * Get PCSR's SPDIF bit.
     *
     * Smart Card Presence Detect Interrupt Flag
     */
    inline bool get_PCSR_SPDIF() volatile
    {
        return PCSR & (1u << 25u);
    }

    /**
     * Set PCSR's SPDIF bit.
     *
     * Smart Card Presence Detect Interrupt Flag
     */
    inline void set_PCSR_SPDIF() volatile
    {
        PCSR |= 1u << 25u;
    }

    /**
     * Clear PCSR's SPDIF bit.
     *
     * Smart Card Presence Detect Interrupt Flag
     */
    inline void clear_PCSR_SPDIF() volatile
    {
        PCSR &= ~(1u << 25u);
    }

    /**
     * Toggle PCSR's SPDIF bit.
     *
     * Smart Card Presence Detect Interrupt Flag
     */
    inline void toggle_PCSR_SPDIF() volatile
    {
        PCSR ^= 1u << 25u;
    }

    /**
     * Get PCSR's SPDIM bit.
     *
     * Smart Card Presence Detect Interrupt Mask
     */
    inline bool get_PCSR_SPDIM() volatile
    {
        return PCSR & (1u << 24u);
    }

    /**
     * Set PCSR's SPDIM bit.
     *
     * Smart Card Presence Detect Interrupt Mask
     */
    inline void set_PCSR_SPDIM() volatile
    {
        PCSR |= 1u << 24u;
    }

    /**
     * Clear PCSR's SPDIM bit.
     *
     * Smart Card Presence Detect Interrupt Mask
     */
    inline void clear_PCSR_SPDIM() volatile
    {
        PCSR &= ~(1u << 24u);
    }

    /**
     * Toggle PCSR's SPDIM bit.
     *
     * Smart Card Presence Detect Interrupt Mask
     */
    inline void toggle_PCSR_SPDIM() volatile
    {
        PCSR ^= 1u << 24u;
    }

    /**
     * Get PCSR's SPD bit.
     *
     * Auto Power Down Control
     */
    inline bool get_PCSR_SPD() volatile
    {
        return PCSR & (1u << 7u);
    }

    /**
     * Set PCSR's SPD bit.
     *
     * Auto Power Down Control
     */
    inline void set_PCSR_SPD() volatile
    {
        PCSR |= 1u << 7u;
    }

    /**
     * Clear PCSR's SPD bit.
     *
     * Auto Power Down Control
     */
    inline void clear_PCSR_SPD() volatile
    {
        PCSR &= ~(1u << 7u);
    }

    /**
     * Toggle PCSR's SPD bit.
     *
     * Auto Power Down Control
     */
    inline void toggle_PCSR_SPD() volatile
    {
        PCSR ^= 1u << 7u;
    }

    /**
     * Get PCSR's SCSP bit.
     *
     * Smart Card Clock Stop Polarity
     */
    inline bool get_PCSR_SCSP() volatile
    {
        return PCSR & (1u << 5u);
    }

    /**
     * Set PCSR's SCSP bit.
     *
     * Smart Card Clock Stop Polarity
     */
    inline void set_PCSR_SCSP() volatile
    {
        PCSR |= 1u << 5u;
    }

    /**
     * Clear PCSR's SCSP bit.
     *
     * Smart Card Clock Stop Polarity
     */
    inline void clear_PCSR_SCSP() volatile
    {
        PCSR &= ~(1u << 5u);
    }

    /**
     * Toggle PCSR's SCSP bit.
     *
     * Smart Card Clock Stop Polarity
     */
    inline void toggle_PCSR_SCSP() volatile
    {
        PCSR ^= 1u << 5u;
    }

    /**
     * Get PCSR's SCEN bit.
     *
     * Clock Enable for Smart Card
     */
    inline bool get_PCSR_SCEN() volatile
    {
        return PCSR & (1u << 4u);
    }

    /**
     * Set PCSR's SCEN bit.
     *
     * Clock Enable for Smart Card
     */
    inline void set_PCSR_SCEN() volatile
    {
        PCSR |= 1u << 4u;
    }

    /**
     * Clear PCSR's SCEN bit.
     *
     * Clock Enable for Smart Card
     */
    inline void clear_PCSR_SCEN() volatile
    {
        PCSR &= ~(1u << 4u);
    }

    /**
     * Toggle PCSR's SCEN bit.
     *
     * Clock Enable for Smart Card
     */
    inline void toggle_PCSR_SCEN() volatile
    {
        PCSR ^= 1u << 4u;
    }

    /**
     * Get PCSR's SRST bit.
     *
     * Reset to Smart Card
     */
    inline bool get_PCSR_SRST() volatile
    {
        return PCSR & (1u << 3u);
    }

    /**
     * Set PCSR's SRST bit.
     *
     * Reset to Smart Card
     */
    inline void set_PCSR_SRST() volatile
    {
        PCSR |= 1u << 3u;
    }

    /**
     * Clear PCSR's SRST bit.
     *
     * Reset to Smart Card
     */
    inline void clear_PCSR_SRST() volatile
    {
        PCSR &= ~(1u << 3u);
    }

    /**
     * Toggle PCSR's SRST bit.
     *
     * Reset to Smart Card
     */
    inline void toggle_PCSR_SRST() volatile
    {
        PCSR ^= 1u << 3u;
    }

    /**
     * Get PCSR's VCCENP bit.
     *
     * VCC Enable Polarity Control
     */
    inline bool get_PCSR_VCCENP() volatile
    {
        return PCSR & (1u << 2u);
    }

    /**
     * Set PCSR's VCCENP bit.
     *
     * VCC Enable Polarity Control
     */
    inline void set_PCSR_VCCENP() volatile
    {
        PCSR |= 1u << 2u;
    }

    /**
     * Clear PCSR's VCCENP bit.
     *
     * VCC Enable Polarity Control
     */
    inline void clear_PCSR_VCCENP() volatile
    {
        PCSR &= ~(1u << 2u);
    }

    /**
     * Toggle PCSR's VCCENP bit.
     *
     * VCC Enable Polarity Control
     */
    inline void toggle_PCSR_VCCENP() volatile
    {
        PCSR ^= 1u << 2u;
    }

    /**
     * Get PCSR's SVCC_EN bit.
     *
     * Vcc Enable for Smart Card
     */
    inline bool get_PCSR_SVCC_EN() volatile
    {
        return PCSR & (1u << 1u);
    }

    /**
     * Set PCSR's SVCC_EN bit.
     *
     * Vcc Enable for Smart Card
     */
    inline void set_PCSR_SVCC_EN() volatile
    {
        PCSR |= 1u << 1u;
    }

    /**
     * Clear PCSR's SVCC_EN bit.
     *
     * Vcc Enable for Smart Card
     */
    inline void clear_PCSR_SVCC_EN() volatile
    {
        PCSR &= ~(1u << 1u);
    }

    /**
     * Toggle PCSR's SVCC_EN bit.
     *
     * Vcc Enable for Smart Card
     */
    inline void toggle_PCSR_SVCC_EN() volatile
    {
        PCSR ^= 1u << 1u;
    }

    /**
     * Get PCSR's SAPD bit.
     *
     * Auto Power Down Enable
     */
    inline bool get_PCSR_SAPD() volatile
    {
        return PCSR & (1u << 0u);
    }

    /**
     * Set PCSR's SAPD bit.
     *
     * Auto Power Down Enable
     */
    inline void set_PCSR_SAPD() volatile
    {
        PCSR |= 1u << 0u;
    }

    /**
     * Clear PCSR's SAPD bit.
     *
     * Auto Power Down Enable
     */
    inline void clear_PCSR_SAPD() volatile
    {
        PCSR &= ~(1u << 0u);
    }

    /**
     * Toggle PCSR's SAPD bit.
     *
     * Auto Power Down Enable
     */
    inline void toggle_PCSR_SAPD() volatile
    {
        PCSR ^= 1u << 0u;
    }

    /**
     * Get all of PCSR's bit fields.
     *
     * (read-write) Port Control and Status Register
     */
    inline void get_PCSR(bool &SPDES, bool &SPDP, bool &SPDIF, bool &SPDIM,
                         bool &SPD, bool &SCSP, bool &SCEN, bool &SRST,
                         bool &VCCENP, bool &SVCC_EN, bool &SAPD) volatile
    {
        uint32_t curr = PCSR;

        SPDES = curr & (1u << 27u);
        SPDP = curr & (1u << 26u);
        SPDIF = curr & (1u << 25u);
        SPDIM = curr & (1u << 24u);
        SPD = curr & (1u << 7u);
        SCSP = curr & (1u << 5u);
        SCEN = curr & (1u << 4u);
        SRST = curr & (1u << 3u);
        VCCENP = curr & (1u << 2u);
        SVCC_EN = curr & (1u << 1u);
        SAPD = curr & (1u << 0u);
    }

    /**
     * Set all of PCSR's bit fields.
     *
     * (read-write) Port Control and Status Register
     */
    inline void set_PCSR(bool SPDES, bool SPDIF, bool SPDIM, bool SPD,
                         bool SCSP, bool SCEN, bool SRST, bool VCCENP,
                         bool SVCC_EN, bool SAPD) volatile
    {
        uint32_t curr = PCSR;

        curr &= ~(0b1u << 27u);
        curr |= (SPDES & 0b1u) << 27u;
        curr &= ~(0b1u << 25u);
        curr |= (SPDIF & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (SPDIM & 0b1u) << 24u;
        curr &= ~(0b1u << 7u);
        curr |= (SPD & 0b1u) << 7u;
        curr &= ~(0b1u << 5u);
        curr |= (SCSP & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SCEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SRST & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (VCCENP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SVCC_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SAPD & 0b1u) << 0u;

        PCSR = curr;
    }

    /**
     * Get RX_BUF's RX_BYTE field.
     *
     * Receive Data Byte Read
     */
    inline uint8_t get_RX_BUF_RX_BYTE() volatile
    {
        return (RX_BUF >> 0u) & 0b11111111u;
    }

    /**
     * Get TX_BUF's TX_BYTE field.
     *
     * Transmit Data Byte
     */
    inline uint8_t get_TX_BUF_TX_BYTE() volatile
    {
        return (TX_BUF >> 0u) & 0b11111111u;
    }

    /**
     * Set TX_BUF's TX_BYTE field.
     *
     * Transmit Data Byte
     */
    inline void set_TX_BUF_TX_BYTE(uint8_t value) volatile
    {
        uint32_t curr = TX_BUF;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TX_BUF = curr;
    }

    /**
     * Get TX_GETU's GETU field.
     *
     * Transmitter Guard Time Value in ETU
     */
    inline uint8_t get_TX_GETU_GETU() volatile
    {
        return (TX_GETU >> 0u) & 0b11111111u;
    }

    /**
     * Set TX_GETU's GETU field.
     *
     * Transmitter Guard Time Value in ETU
     */
    inline void set_TX_GETU_GETU(uint8_t value) volatile
    {
        uint32_t curr = TX_GETU;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TX_GETU = curr;
    }

    /**
     * Get CWT_VAL's CWT field.
     *
     * Character Wait Time Value
     */
    inline uint16_t get_CWT_VAL_CWT() volatile
    {
        return (CWT_VAL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CWT_VAL's CWT field.
     *
     * Character Wait Time Value
     */
    inline void set_CWT_VAL_CWT(uint16_t value) volatile
    {
        uint32_t curr = CWT_VAL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CWT_VAL = curr;
    }

    /**
     * Get BWT_VAL's BWT field.
     *
     * Block Wait Time Value
     */
    inline uint32_t get_BWT_VAL_BWT() volatile
    {
        return (BWT_VAL >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set BWT_VAL's BWT field.
     *
     * Block Wait Time Value
     */
    inline void set_BWT_VAL_BWT(uint32_t value) volatile
    {
        uint32_t curr = BWT_VAL;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        BWT_VAL = curr;
    }

    /**
     * Get BGT_VAL's BGT field.
     *
     * Block Guard Time Value
     */
    inline uint16_t get_BGT_VAL_BGT() volatile
    {
        return (BGT_VAL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set BGT_VAL's BGT field.
     *
     * Block Guard Time Value
     */
    inline void set_BGT_VAL_BGT(uint16_t value) volatile
    {
        uint32_t curr = BGT_VAL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        BGT_VAL = curr;
    }

    /**
     * Get GPCNT0_VAL's GPCNT0 field.
     *
     * General Purpose Counter 0 Timeout Value
     */
    inline uint16_t get_GPCNT0_VAL_GPCNT0() volatile
    {
        return (GPCNT0_VAL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPCNT0_VAL's GPCNT0 field.
     *
     * General Purpose Counter 0 Timeout Value
     */
    inline void set_GPCNT0_VAL_GPCNT0(uint16_t value) volatile
    {
        uint32_t curr = GPCNT0_VAL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPCNT0_VAL = curr;
    }

    /**
     * Get GPCNT1_VAL's GPCNT1 field.
     *
     * General Purpose Counter 1 Timeout Value
     */
    inline uint16_t get_GPCNT1_VAL_GPCNT1() volatile
    {
        return (GPCNT1_VAL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPCNT1_VAL's GPCNT1 field.
     *
     * General Purpose Counter 1 Timeout Value
     */
    inline void set_GPCNT1_VAL_GPCNT1(uint16_t value) volatile
    {
        uint32_t curr = GPCNT1_VAL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPCNT1_VAL = curr;
    }
};

static_assert(sizeof(emvsim1) == emvsim1::size);

static volatile emvsim1 *const EMVSIM1 =
    reinterpret_cast<emvsim1 *>(0x40154000);

static volatile emvsim1 *const EMVSIM2 =
    reinterpret_cast<emvsim1 *>(0x40158000);

}; // namespace MIMXRT1176::CM7
