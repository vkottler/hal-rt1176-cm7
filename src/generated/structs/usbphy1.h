/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/USBPHY1_DEBUG1_ENTAILADJVD.h"
#include "../enums/USBPHY1_PLL_SIC_PLL_DIV_SEL.h"
#include "../enums/USBPHY1_RX_DISCONADJ.h"
#include "../enums/USBPHY1_RX_ENVADJ.h"
#include "../enums/USBPHY1_TX_D_CAL.h"
#include "../enums/USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS.h"
#include "../enums/USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH.h"
#include "../enums/USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * USBPHY
 */
struct [[gnu::packed]] usbphy1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 320; /*!< usbphy1's size in bytes. */

    /* Fields. */
    uint32_t PWD;     /*!< (read-write) USB PHY Power-Down Register */
    uint32_t PWD_SET; /*!< (read-write) USB PHY Power-Down Register */
    uint32_t PWD_CLR; /*!< (read-write) USB PHY Power-Down Register */
    uint32_t PWD_TOG; /*!< (read-write) USB PHY Power-Down Register */
    uint32_t TX;      /*!< (read-write) USB PHY Transmitter Control Register */
    uint32_t TX_SET;  /*!< (read-write) USB PHY Transmitter Control Register */
    uint32_t TX_CLR;  /*!< (read-write) USB PHY Transmitter Control Register */
    uint32_t TX_TOG;  /*!< (read-write) USB PHY Transmitter Control Register */
    uint32_t RX;      /*!< (read-write) USB PHY Receiver Control Register */
    uint32_t RX_SET;  /*!< (read-write) USB PHY Receiver Control Register */
    uint32_t RX_CLR;  /*!< (read-write) USB PHY Receiver Control Register */
    uint32_t RX_TOG;  /*!< (read-write) USB PHY Receiver Control Register */
    uint32_t CTRL;    /*!< (read-write) USB PHY General Control Register */
    uint32_t CTRL_SET; /*!< (read-write) USB PHY General Control Register */
    uint32_t CTRL_CLR; /*!< (read-write) USB PHY General Control Register */
    uint32_t CTRL_TOG; /*!< (read-write) USB PHY General Control Register */
    uint32_t STATUS;   /*!< (read-write) USB PHY Status Register */
    static constexpr std::size_t reserved_padding0_length = 3;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t DEBUG;         /*!< (read-write) USB PHY Debug Register */
    uint32_t DEBUG_SET;     /*!< (read-write) USB PHY Debug Register */
    uint32_t DEBUG_CLR;     /*!< (read-write) USB PHY Debug Register */
    uint32_t DEBUG_TOG;     /*!< (read-write) USB PHY Debug Register */
    uint32_t DEBUG0_STATUS; /*!< (read-write) UTMI Debug Status Register 0 */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t DEBUG1;     /*!< (read-write) UTMI Debug Status Register 1 */
    uint32_t DEBUG1_SET; /*!< (read-write) UTMI Debug Status Register 1 */
    uint32_t DEBUG1_CLR; /*!< (read-write) UTMI Debug Status Register 1 */
    uint32_t DEBUG1_TOG; /*!< (read-write) UTMI Debug Status Register 1 */
    uint32_t VERSION;    /*!< (read-write) UTMI RTL Version */
    static constexpr std::size_t reserved_padding2_length = 7;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t PLL_SIC; /*!< (read-write) USB PHY PLL Control/Status Register */
    uint32_t
        PLL_SIC_SET; /*!< (read-write) USB PHY PLL Control/Status Register */
    uint32_t
        PLL_SIC_CLR; /*!< (read-write) USB PHY PLL Control/Status Register */
    uint32_t
        PLL_SIC_TOG; /*!< (read-write) USB PHY PLL Control/Status Register */
    static constexpr std::size_t reserved_padding3_length = 4;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t USB1_VBUS_DETECT; /*!< (read-write) USB PHY VBUS Detect Control
                                  Register */
    uint32_t USB1_VBUS_DETECT_SET; /*!< (read-write) USB PHY VBUS Detect
                                      Control Register */
    uint32_t USB1_VBUS_DETECT_CLR; /*!< (read-write) USB PHY VBUS Detect
                                      Control Register */
    uint32_t USB1_VBUS_DETECT_TOG; /*!< (read-write) USB PHY VBUS Detect
                                      Control Register */
    uint32_t USB1_VBUS_DET_STAT; /*!< (read-write) USB PHY VBUS Detector Status
                                    Register */
    static constexpr std::size_t reserved_padding4_length = 3;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t USB1_CHRG_DETECT; /*!< (read-write) USB PHY Charger Detect Control
                                  Register */
    uint32_t USB1_CHRG_DETECT_SET; /*!< (read-write) USB PHY Charger Detect
                                      Control Register */
    uint32_t USB1_CHRG_DETECT_CLR; /*!< (read-write) USB PHY Charger Detect
                                      Control Register */
    uint32_t USB1_CHRG_DETECT_TOG; /*!< (read-write) USB PHY Charger Detect
                                      Control Register */
    uint32_t USB1_CHRG_DET_STAT;   /*!< (read-write) USB PHY Charger Detect
                                      Status Register */
    static constexpr std::size_t reserved_padding5_length = 3;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t ANACTRL;     /*!< (read-write) USB PHY Analog Control Register */
    uint32_t ANACTRL_SET; /*!< (read-write) USB PHY Analog Control Register */
    uint32_t ANACTRL_CLR; /*!< (read-write) USB PHY Analog Control Register */
    uint32_t ANACTRL_TOG; /*!< (read-write) USB PHY Analog Control Register */
    uint32_t USB1_LOOPBACK; /*!< (read-write) USB PHY Loopback Control/Status
                               Register */
    uint32_t USB1_LOOPBACK_SET;     /*!< (read-write) USB PHY Loopback
                                       Control/Status Register */
    uint32_t USB1_LOOPBACK_CLR;     /*!< (read-write) USB PHY Loopback
                                       Control/Status Register */
    uint32_t USB1_LOOPBACK_TOG;     /*!< (read-write) USB PHY Loopback
                                       Control/Status Register */
    uint32_t USB1_LOOPBACK_HSFSCNT; /*!< (read-write) USB PHY Loopback Packet
                                       Number Select Register */
    uint32_t USB1_LOOPBACK_HSFSCNT_SET; /*!< (read-write) USB PHY Loopback
                                           Packet Number Select Register */
    uint32_t USB1_LOOPBACK_HSFSCNT_CLR; /*!< (read-write) USB PHY Loopback
                                           Packet Number Select Register */
    uint32_t USB1_LOOPBACK_HSFSCNT_TOG; /*!< (read-write) USB PHY Loopback
                                           Packet Number Select Register */
    uint32_t TRIM_OVERRIDE_EN; /*!< (read-write) USB PHY Trim Override Enable
                                  Register */
    uint32_t TRIM_OVERRIDE_EN_SET; /*!< (read-write) USB PHY Trim Override
                                      Enable Register */
    uint32_t TRIM_OVERRIDE_EN_CLR; /*!< (read-write) USB PHY Trim Override
                                      Enable Register */
    uint32_t TRIM_OVERRIDE_EN_TOG; /*!< (read-write) USB PHY Trim Override
                                      Enable Register */

    /* Methods. */

    /**
     * Get PWD's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline bool get_PWD_RXPWDRX() volatile
    {
        return PWD & (1u << 20u);
    }

    /**
     * Set PWD's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void set_PWD_RXPWDRX() volatile
    {
        PWD |= 1u << 20u;
    }

    /**
     * Clear PWD's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void clear_PWD_RXPWDRX() volatile
    {
        PWD &= ~(1u << 20u);
    }

    /**
     * Toggle PWD's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void toggle_PWD_RXPWDRX() volatile
    {
        PWD ^= 1u << 20u;
    }

    /**
     * Get PWD's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline bool get_PWD_RXPWDDIFF() volatile
    {
        return PWD & (1u << 19u);
    }

    /**
     * Set PWD's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void set_PWD_RXPWDDIFF() volatile
    {
        PWD |= 1u << 19u;
    }

    /**
     * Clear PWD's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void clear_PWD_RXPWDDIFF() volatile
    {
        PWD &= ~(1u << 19u);
    }

    /**
     * Toggle PWD's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void toggle_PWD_RXPWDDIFF() volatile
    {
        PWD ^= 1u << 19u;
    }

    /**
     * Get PWD's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline bool get_PWD_RXPWD1PT1() volatile
    {
        return PWD & (1u << 18u);
    }

    /**
     * Set PWD's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void set_PWD_RXPWD1PT1() volatile
    {
        PWD |= 1u << 18u;
    }

    /**
     * Clear PWD's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void clear_PWD_RXPWD1PT1() volatile
    {
        PWD &= ~(1u << 18u);
    }

    /**
     * Toggle PWD's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void toggle_PWD_RXPWD1PT1() volatile
    {
        PWD ^= 1u << 18u;
    }

    /**
     * Get PWD's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline bool get_PWD_RXPWDENV() volatile
    {
        return PWD & (1u << 17u);
    }

    /**
     * Set PWD's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void set_PWD_RXPWDENV() volatile
    {
        PWD |= 1u << 17u;
    }

    /**
     * Clear PWD's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void clear_PWD_RXPWDENV() volatile
    {
        PWD &= ~(1u << 17u);
    }

    /**
     * Toggle PWD's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void toggle_PWD_RXPWDENV() volatile
    {
        PWD ^= 1u << 17u;
    }

    /**
     * Get PWD's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline bool get_PWD_TXPWDV2I() volatile
    {
        return PWD & (1u << 12u);
    }

    /**
     * Set PWD's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void set_PWD_TXPWDV2I() volatile
    {
        PWD |= 1u << 12u;
    }

    /**
     * Clear PWD's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void clear_PWD_TXPWDV2I() volatile
    {
        PWD &= ~(1u << 12u);
    }

    /**
     * Toggle PWD's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void toggle_PWD_TXPWDV2I() volatile
    {
        PWD ^= 1u << 12u;
    }

    /**
     * Get PWD's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline bool get_PWD_TXPWDIBIAS() volatile
    {
        return PWD & (1u << 11u);
    }

    /**
     * Set PWD's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void set_PWD_TXPWDIBIAS() volatile
    {
        PWD |= 1u << 11u;
    }

    /**
     * Clear PWD's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void clear_PWD_TXPWDIBIAS() volatile
    {
        PWD &= ~(1u << 11u);
    }

    /**
     * Toggle PWD's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void toggle_PWD_TXPWDIBIAS() volatile
    {
        PWD ^= 1u << 11u;
    }

    /**
     * Get PWD's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline bool get_PWD_TXPWDFS() volatile
    {
        return PWD & (1u << 10u);
    }

    /**
     * Set PWD's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void set_PWD_TXPWDFS() volatile
    {
        PWD |= 1u << 10u;
    }

    /**
     * Clear PWD's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void clear_PWD_TXPWDFS() volatile
    {
        PWD &= ~(1u << 10u);
    }

    /**
     * Toggle PWD's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void toggle_PWD_TXPWDFS() volatile
    {
        PWD ^= 1u << 10u;
    }

    /**
     * Get all of PWD's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void get_PWD(bool &RXPWDRX, bool &RXPWDDIFF, bool &RXPWD1PT1,
                        bool &RXPWDENV, bool &TXPWDV2I, bool &TXPWDIBIAS,
                        bool &TXPWDFS) volatile
    {
        uint32_t curr = PWD;

        RXPWDRX = curr & (1u << 20u);
        RXPWDDIFF = curr & (1u << 19u);
        RXPWD1PT1 = curr & (1u << 18u);
        RXPWDENV = curr & (1u << 17u);
        TXPWDV2I = curr & (1u << 12u);
        TXPWDIBIAS = curr & (1u << 11u);
        TXPWDFS = curr & (1u << 10u);
    }

    /**
     * Set all of PWD's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void set_PWD(bool RXPWDRX, bool RXPWDDIFF, bool RXPWD1PT1,
                        bool RXPWDENV, bool TXPWDV2I, bool TXPWDIBIAS,
                        bool TXPWDFS) volatile
    {
        uint32_t curr = PWD;

        curr &= ~(0b1u << 20u);
        curr |= (RXPWDRX & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXPWDDIFF & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXPWD1PT1 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RXPWDENV & 0b1u) << 17u;
        curr &= ~(0b1u << 12u);
        curr |= (TXPWDV2I & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TXPWDIBIAS & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TXPWDFS & 0b1u) << 10u;

        PWD = curr;
    }

    /**
     * Get PWD_SET's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline bool get_PWD_SET_RXPWDRX() volatile
    {
        return PWD_SET & (1u << 20u);
    }

    /**
     * Set PWD_SET's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void set_PWD_SET_RXPWDRX() volatile
    {
        PWD_SET |= 1u << 20u;
    }

    /**
     * Clear PWD_SET's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void clear_PWD_SET_RXPWDRX() volatile
    {
        PWD_SET &= ~(1u << 20u);
    }

    /**
     * Toggle PWD_SET's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void toggle_PWD_SET_RXPWDRX() volatile
    {
        PWD_SET ^= 1u << 20u;
    }

    /**
     * Get PWD_SET's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline bool get_PWD_SET_RXPWDDIFF() volatile
    {
        return PWD_SET & (1u << 19u);
    }

    /**
     * Set PWD_SET's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void set_PWD_SET_RXPWDDIFF() volatile
    {
        PWD_SET |= 1u << 19u;
    }

    /**
     * Clear PWD_SET's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void clear_PWD_SET_RXPWDDIFF() volatile
    {
        PWD_SET &= ~(1u << 19u);
    }

    /**
     * Toggle PWD_SET's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void toggle_PWD_SET_RXPWDDIFF() volatile
    {
        PWD_SET ^= 1u << 19u;
    }

    /**
     * Get PWD_SET's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline bool get_PWD_SET_RXPWD1PT1() volatile
    {
        return PWD_SET & (1u << 18u);
    }

    /**
     * Set PWD_SET's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void set_PWD_SET_RXPWD1PT1() volatile
    {
        PWD_SET |= 1u << 18u;
    }

    /**
     * Clear PWD_SET's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void clear_PWD_SET_RXPWD1PT1() volatile
    {
        PWD_SET &= ~(1u << 18u);
    }

    /**
     * Toggle PWD_SET's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void toggle_PWD_SET_RXPWD1PT1() volatile
    {
        PWD_SET ^= 1u << 18u;
    }

    /**
     * Get PWD_SET's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline bool get_PWD_SET_RXPWDENV() volatile
    {
        return PWD_SET & (1u << 17u);
    }

    /**
     * Set PWD_SET's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void set_PWD_SET_RXPWDENV() volatile
    {
        PWD_SET |= 1u << 17u;
    }

    /**
     * Clear PWD_SET's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void clear_PWD_SET_RXPWDENV() volatile
    {
        PWD_SET &= ~(1u << 17u);
    }

    /**
     * Toggle PWD_SET's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void toggle_PWD_SET_RXPWDENV() volatile
    {
        PWD_SET ^= 1u << 17u;
    }

    /**
     * Get PWD_SET's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline bool get_PWD_SET_TXPWDV2I() volatile
    {
        return PWD_SET & (1u << 12u);
    }

    /**
     * Set PWD_SET's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void set_PWD_SET_TXPWDV2I() volatile
    {
        PWD_SET |= 1u << 12u;
    }

    /**
     * Clear PWD_SET's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void clear_PWD_SET_TXPWDV2I() volatile
    {
        PWD_SET &= ~(1u << 12u);
    }

    /**
     * Toggle PWD_SET's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void toggle_PWD_SET_TXPWDV2I() volatile
    {
        PWD_SET ^= 1u << 12u;
    }

    /**
     * Get PWD_SET's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline bool get_PWD_SET_TXPWDIBIAS() volatile
    {
        return PWD_SET & (1u << 11u);
    }

    /**
     * Set PWD_SET's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void set_PWD_SET_TXPWDIBIAS() volatile
    {
        PWD_SET |= 1u << 11u;
    }

    /**
     * Clear PWD_SET's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void clear_PWD_SET_TXPWDIBIAS() volatile
    {
        PWD_SET &= ~(1u << 11u);
    }

    /**
     * Toggle PWD_SET's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void toggle_PWD_SET_TXPWDIBIAS() volatile
    {
        PWD_SET ^= 1u << 11u;
    }

    /**
     * Get PWD_SET's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline bool get_PWD_SET_TXPWDFS() volatile
    {
        return PWD_SET & (1u << 10u);
    }

    /**
     * Set PWD_SET's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void set_PWD_SET_TXPWDFS() volatile
    {
        PWD_SET |= 1u << 10u;
    }

    /**
     * Clear PWD_SET's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void clear_PWD_SET_TXPWDFS() volatile
    {
        PWD_SET &= ~(1u << 10u);
    }

    /**
     * Toggle PWD_SET's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void toggle_PWD_SET_TXPWDFS() volatile
    {
        PWD_SET ^= 1u << 10u;
    }

    /**
     * Get all of PWD_SET's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void get_PWD_SET(bool &RXPWDRX, bool &RXPWDDIFF, bool &RXPWD1PT1,
                            bool &RXPWDENV, bool &TXPWDV2I, bool &TXPWDIBIAS,
                            bool &TXPWDFS) volatile
    {
        uint32_t curr = PWD_SET;

        RXPWDRX = curr & (1u << 20u);
        RXPWDDIFF = curr & (1u << 19u);
        RXPWD1PT1 = curr & (1u << 18u);
        RXPWDENV = curr & (1u << 17u);
        TXPWDV2I = curr & (1u << 12u);
        TXPWDIBIAS = curr & (1u << 11u);
        TXPWDFS = curr & (1u << 10u);
    }

    /**
     * Set all of PWD_SET's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void set_PWD_SET(bool RXPWDRX, bool RXPWDDIFF, bool RXPWD1PT1,
                            bool RXPWDENV, bool TXPWDV2I, bool TXPWDIBIAS,
                            bool TXPWDFS) volatile
    {
        uint32_t curr = PWD_SET;

        curr &= ~(0b1u << 20u);
        curr |= (RXPWDRX & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXPWDDIFF & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXPWD1PT1 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RXPWDENV & 0b1u) << 17u;
        curr &= ~(0b1u << 12u);
        curr |= (TXPWDV2I & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TXPWDIBIAS & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TXPWDFS & 0b1u) << 10u;

        PWD_SET = curr;
    }

    /**
     * Get PWD_CLR's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline bool get_PWD_CLR_RXPWDRX() volatile
    {
        return PWD_CLR & (1u << 20u);
    }

    /**
     * Set PWD_CLR's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void set_PWD_CLR_RXPWDRX() volatile
    {
        PWD_CLR |= 1u << 20u;
    }

    /**
     * Clear PWD_CLR's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void clear_PWD_CLR_RXPWDRX() volatile
    {
        PWD_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle PWD_CLR's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void toggle_PWD_CLR_RXPWDRX() volatile
    {
        PWD_CLR ^= 1u << 20u;
    }

    /**
     * Get PWD_CLR's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline bool get_PWD_CLR_RXPWDDIFF() volatile
    {
        return PWD_CLR & (1u << 19u);
    }

    /**
     * Set PWD_CLR's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void set_PWD_CLR_RXPWDDIFF() volatile
    {
        PWD_CLR |= 1u << 19u;
    }

    /**
     * Clear PWD_CLR's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void clear_PWD_CLR_RXPWDDIFF() volatile
    {
        PWD_CLR &= ~(1u << 19u);
    }

    /**
     * Toggle PWD_CLR's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void toggle_PWD_CLR_RXPWDDIFF() volatile
    {
        PWD_CLR ^= 1u << 19u;
    }

    /**
     * Get PWD_CLR's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline bool get_PWD_CLR_RXPWD1PT1() volatile
    {
        return PWD_CLR & (1u << 18u);
    }

    /**
     * Set PWD_CLR's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void set_PWD_CLR_RXPWD1PT1() volatile
    {
        PWD_CLR |= 1u << 18u;
    }

    /**
     * Clear PWD_CLR's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void clear_PWD_CLR_RXPWD1PT1() volatile
    {
        PWD_CLR &= ~(1u << 18u);
    }

    /**
     * Toggle PWD_CLR's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void toggle_PWD_CLR_RXPWD1PT1() volatile
    {
        PWD_CLR ^= 1u << 18u;
    }

    /**
     * Get PWD_CLR's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline bool get_PWD_CLR_RXPWDENV() volatile
    {
        return PWD_CLR & (1u << 17u);
    }

    /**
     * Set PWD_CLR's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void set_PWD_CLR_RXPWDENV() volatile
    {
        PWD_CLR |= 1u << 17u;
    }

    /**
     * Clear PWD_CLR's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void clear_PWD_CLR_RXPWDENV() volatile
    {
        PWD_CLR &= ~(1u << 17u);
    }

    /**
     * Toggle PWD_CLR's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void toggle_PWD_CLR_RXPWDENV() volatile
    {
        PWD_CLR ^= 1u << 17u;
    }

    /**
     * Get PWD_CLR's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline bool get_PWD_CLR_TXPWDV2I() volatile
    {
        return PWD_CLR & (1u << 12u);
    }

    /**
     * Set PWD_CLR's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void set_PWD_CLR_TXPWDV2I() volatile
    {
        PWD_CLR |= 1u << 12u;
    }

    /**
     * Clear PWD_CLR's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void clear_PWD_CLR_TXPWDV2I() volatile
    {
        PWD_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle PWD_CLR's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void toggle_PWD_CLR_TXPWDV2I() volatile
    {
        PWD_CLR ^= 1u << 12u;
    }

    /**
     * Get PWD_CLR's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline bool get_PWD_CLR_TXPWDIBIAS() volatile
    {
        return PWD_CLR & (1u << 11u);
    }

    /**
     * Set PWD_CLR's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void set_PWD_CLR_TXPWDIBIAS() volatile
    {
        PWD_CLR |= 1u << 11u;
    }

    /**
     * Clear PWD_CLR's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void clear_PWD_CLR_TXPWDIBIAS() volatile
    {
        PWD_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle PWD_CLR's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void toggle_PWD_CLR_TXPWDIBIAS() volatile
    {
        PWD_CLR ^= 1u << 11u;
    }

    /**
     * Get PWD_CLR's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline bool get_PWD_CLR_TXPWDFS() volatile
    {
        return PWD_CLR & (1u << 10u);
    }

    /**
     * Set PWD_CLR's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void set_PWD_CLR_TXPWDFS() volatile
    {
        PWD_CLR |= 1u << 10u;
    }

    /**
     * Clear PWD_CLR's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void clear_PWD_CLR_TXPWDFS() volatile
    {
        PWD_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle PWD_CLR's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void toggle_PWD_CLR_TXPWDFS() volatile
    {
        PWD_CLR ^= 1u << 10u;
    }

    /**
     * Get all of PWD_CLR's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void get_PWD_CLR(bool &RXPWDRX, bool &RXPWDDIFF, bool &RXPWD1PT1,
                            bool &RXPWDENV, bool &TXPWDV2I, bool &TXPWDIBIAS,
                            bool &TXPWDFS) volatile
    {
        uint32_t curr = PWD_CLR;

        RXPWDRX = curr & (1u << 20u);
        RXPWDDIFF = curr & (1u << 19u);
        RXPWD1PT1 = curr & (1u << 18u);
        RXPWDENV = curr & (1u << 17u);
        TXPWDV2I = curr & (1u << 12u);
        TXPWDIBIAS = curr & (1u << 11u);
        TXPWDFS = curr & (1u << 10u);
    }

    /**
     * Set all of PWD_CLR's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void set_PWD_CLR(bool RXPWDRX, bool RXPWDDIFF, bool RXPWD1PT1,
                            bool RXPWDENV, bool TXPWDV2I, bool TXPWDIBIAS,
                            bool TXPWDFS) volatile
    {
        uint32_t curr = PWD_CLR;

        curr &= ~(0b1u << 20u);
        curr |= (RXPWDRX & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXPWDDIFF & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXPWD1PT1 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RXPWDENV & 0b1u) << 17u;
        curr &= ~(0b1u << 12u);
        curr |= (TXPWDV2I & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TXPWDIBIAS & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TXPWDFS & 0b1u) << 10u;

        PWD_CLR = curr;
    }

    /**
     * Get PWD_TOG's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline bool get_PWD_TOG_RXPWDRX() volatile
    {
        return PWD_TOG & (1u << 20u);
    }

    /**
     * Set PWD_TOG's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void set_PWD_TOG_RXPWDRX() volatile
    {
        PWD_TOG |= 1u << 20u;
    }

    /**
     * Clear PWD_TOG's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void clear_PWD_TOG_RXPWDRX() volatile
    {
        PWD_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle PWD_TOG's RXPWDRX bit.
     *
     * RXPWDRX
     */
    inline void toggle_PWD_TOG_RXPWDRX() volatile
    {
        PWD_TOG ^= 1u << 20u;
    }

    /**
     * Get PWD_TOG's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline bool get_PWD_TOG_RXPWDDIFF() volatile
    {
        return PWD_TOG & (1u << 19u);
    }

    /**
     * Set PWD_TOG's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void set_PWD_TOG_RXPWDDIFF() volatile
    {
        PWD_TOG |= 1u << 19u;
    }

    /**
     * Clear PWD_TOG's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void clear_PWD_TOG_RXPWDDIFF() volatile
    {
        PWD_TOG &= ~(1u << 19u);
    }

    /**
     * Toggle PWD_TOG's RXPWDDIFF bit.
     *
     * RXPWDDIFF
     */
    inline void toggle_PWD_TOG_RXPWDDIFF() volatile
    {
        PWD_TOG ^= 1u << 19u;
    }

    /**
     * Get PWD_TOG's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline bool get_PWD_TOG_RXPWD1PT1() volatile
    {
        return PWD_TOG & (1u << 18u);
    }

    /**
     * Set PWD_TOG's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void set_PWD_TOG_RXPWD1PT1() volatile
    {
        PWD_TOG |= 1u << 18u;
    }

    /**
     * Clear PWD_TOG's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void clear_PWD_TOG_RXPWD1PT1() volatile
    {
        PWD_TOG &= ~(1u << 18u);
    }

    /**
     * Toggle PWD_TOG's RXPWD1PT1 bit.
     *
     * RXPWD1PT1
     */
    inline void toggle_PWD_TOG_RXPWD1PT1() volatile
    {
        PWD_TOG ^= 1u << 18u;
    }

    /**
     * Get PWD_TOG's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline bool get_PWD_TOG_RXPWDENV() volatile
    {
        return PWD_TOG & (1u << 17u);
    }

    /**
     * Set PWD_TOG's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void set_PWD_TOG_RXPWDENV() volatile
    {
        PWD_TOG |= 1u << 17u;
    }

    /**
     * Clear PWD_TOG's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void clear_PWD_TOG_RXPWDENV() volatile
    {
        PWD_TOG &= ~(1u << 17u);
    }

    /**
     * Toggle PWD_TOG's RXPWDENV bit.
     *
     * RXPWDENV
     */
    inline void toggle_PWD_TOG_RXPWDENV() volatile
    {
        PWD_TOG ^= 1u << 17u;
    }

    /**
     * Get PWD_TOG's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline bool get_PWD_TOG_TXPWDV2I() volatile
    {
        return PWD_TOG & (1u << 12u);
    }

    /**
     * Set PWD_TOG's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void set_PWD_TOG_TXPWDV2I() volatile
    {
        PWD_TOG |= 1u << 12u;
    }

    /**
     * Clear PWD_TOG's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void clear_PWD_TOG_TXPWDV2I() volatile
    {
        PWD_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle PWD_TOG's TXPWDV2I bit.
     *
     * TXPWDV2I
     */
    inline void toggle_PWD_TOG_TXPWDV2I() volatile
    {
        PWD_TOG ^= 1u << 12u;
    }

    /**
     * Get PWD_TOG's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline bool get_PWD_TOG_TXPWDIBIAS() volatile
    {
        return PWD_TOG & (1u << 11u);
    }

    /**
     * Set PWD_TOG's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void set_PWD_TOG_TXPWDIBIAS() volatile
    {
        PWD_TOG |= 1u << 11u;
    }

    /**
     * Clear PWD_TOG's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void clear_PWD_TOG_TXPWDIBIAS() volatile
    {
        PWD_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle PWD_TOG's TXPWDIBIAS bit.
     *
     * TXPWDIBIAS
     */
    inline void toggle_PWD_TOG_TXPWDIBIAS() volatile
    {
        PWD_TOG ^= 1u << 11u;
    }

    /**
     * Get PWD_TOG's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline bool get_PWD_TOG_TXPWDFS() volatile
    {
        return PWD_TOG & (1u << 10u);
    }

    /**
     * Set PWD_TOG's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void set_PWD_TOG_TXPWDFS() volatile
    {
        PWD_TOG |= 1u << 10u;
    }

    /**
     * Clear PWD_TOG's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void clear_PWD_TOG_TXPWDFS() volatile
    {
        PWD_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle PWD_TOG's TXPWDFS bit.
     *
     * TXPWDFS
     */
    inline void toggle_PWD_TOG_TXPWDFS() volatile
    {
        PWD_TOG ^= 1u << 10u;
    }

    /**
     * Get all of PWD_TOG's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void get_PWD_TOG(bool &RXPWDRX, bool &RXPWDDIFF, bool &RXPWD1PT1,
                            bool &RXPWDENV, bool &TXPWDV2I, bool &TXPWDIBIAS,
                            bool &TXPWDFS) volatile
    {
        uint32_t curr = PWD_TOG;

        RXPWDRX = curr & (1u << 20u);
        RXPWDDIFF = curr & (1u << 19u);
        RXPWD1PT1 = curr & (1u << 18u);
        RXPWDENV = curr & (1u << 17u);
        TXPWDV2I = curr & (1u << 12u);
        TXPWDIBIAS = curr & (1u << 11u);
        TXPWDFS = curr & (1u << 10u);
    }

    /**
     * Set all of PWD_TOG's bit fields.
     *
     * (read-write) USB PHY Power-Down Register
     */
    inline void set_PWD_TOG(bool RXPWDRX, bool RXPWDDIFF, bool RXPWD1PT1,
                            bool RXPWDENV, bool TXPWDV2I, bool TXPWDIBIAS,
                            bool TXPWDFS) volatile
    {
        uint32_t curr = PWD_TOG;

        curr &= ~(0b1u << 20u);
        curr |= (RXPWDRX & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (RXPWDDIFF & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXPWD1PT1 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RXPWDENV & 0b1u) << 17u;
        curr &= ~(0b1u << 12u);
        curr |= (TXPWDV2I & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (TXPWDIBIAS & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TXPWDFS & 0b1u) << 10u;

        PWD_TOG = curr;
    }

    /**
     * Get TX's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline uint8_t get_TX_TXCAL45DP() volatile
    {
        return (TX >> 16u) & 0b1111u;
    }

    /**
     * Set TX's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline void set_TX_TXCAL45DP(uint8_t value) volatile
    {
        uint32_t curr = TX;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        TX = curr;
    }

    /**
     * Get TX's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline uint8_t get_TX_TXCAL45DN() volatile
    {
        return (TX >> 8u) & 0b1111u;
    }

    /**
     * Set TX's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline void set_TX_TXCAL45DN(uint8_t value) volatile
    {
        uint32_t curr = TX;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TX = curr;
    }

    /**
     * Get TX's D_CAL field.
     *
     * D_CAL
     */
    inline USBPHY1_TX_D_CAL get_TX_D_CAL() volatile
    {
        return USBPHY1_TX_D_CAL((TX >> 0u) & 0b1111u);
    }

    /**
     * Set TX's D_CAL field.
     *
     * D_CAL
     */
    inline void set_TX_D_CAL(USBPHY1_TX_D_CAL value) volatile
    {
        uint32_t curr = TX;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        TX = curr;
    }

    /**
     * Get all of TX's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void get_TX(uint8_t &TXCAL45DP, uint8_t &TXCAL45DN,
                       USBPHY1_TX_D_CAL &D_CAL) volatile
    {
        uint32_t curr = TX;

        TXCAL45DP = (curr >> 16u) & 0b1111u;
        TXCAL45DN = (curr >> 8u) & 0b1111u;
        D_CAL = USBPHY1_TX_D_CAL((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of TX's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void set_TX(uint8_t TXCAL45DP, uint8_t TXCAL45DN,
                       USBPHY1_TX_D_CAL D_CAL) volatile
    {
        uint32_t curr = TX;

        curr &= ~(0b1111u << 16u);
        curr |= (TXCAL45DP & 0b1111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (TXCAL45DN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(D_CAL) & 0b1111u) << 0u;

        TX = curr;
    }

    /**
     * Get TX_SET's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline uint8_t get_TX_SET_TXCAL45DP() volatile
    {
        return (TX_SET >> 16u) & 0b1111u;
    }

    /**
     * Set TX_SET's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline void set_TX_SET_TXCAL45DP(uint8_t value) volatile
    {
        uint32_t curr = TX_SET;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        TX_SET = curr;
    }

    /**
     * Get TX_SET's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline uint8_t get_TX_SET_TXCAL45DN() volatile
    {
        return (TX_SET >> 8u) & 0b1111u;
    }

    /**
     * Set TX_SET's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline void set_TX_SET_TXCAL45DN(uint8_t value) volatile
    {
        uint32_t curr = TX_SET;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TX_SET = curr;
    }

    /**
     * Get TX_SET's D_CAL field.
     *
     * D_CAL
     */
    inline uint8_t get_TX_SET_D_CAL() volatile
    {
        return (TX_SET >> 0u) & 0b1111u;
    }

    /**
     * Set TX_SET's D_CAL field.
     *
     * D_CAL
     */
    inline void set_TX_SET_D_CAL(uint8_t value) volatile
    {
        uint32_t curr = TX_SET;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        TX_SET = curr;
    }

    /**
     * Get all of TX_SET's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void get_TX_SET(uint8_t &TXCAL45DP, uint8_t &TXCAL45DN,
                           uint8_t &D_CAL) volatile
    {
        uint32_t curr = TX_SET;

        TXCAL45DP = (curr >> 16u) & 0b1111u;
        TXCAL45DN = (curr >> 8u) & 0b1111u;
        D_CAL = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of TX_SET's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void set_TX_SET(uint8_t TXCAL45DP, uint8_t TXCAL45DN,
                           uint8_t D_CAL) volatile
    {
        uint32_t curr = TX_SET;

        curr &= ~(0b1111u << 16u);
        curr |= (TXCAL45DP & 0b1111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (TXCAL45DN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (D_CAL & 0b1111u) << 0u;

        TX_SET = curr;
    }

    /**
     * Get TX_CLR's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline uint8_t get_TX_CLR_TXCAL45DP() volatile
    {
        return (TX_CLR >> 16u) & 0b1111u;
    }

    /**
     * Set TX_CLR's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline void set_TX_CLR_TXCAL45DP(uint8_t value) volatile
    {
        uint32_t curr = TX_CLR;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        TX_CLR = curr;
    }

    /**
     * Get TX_CLR's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline uint8_t get_TX_CLR_TXCAL45DN() volatile
    {
        return (TX_CLR >> 8u) & 0b1111u;
    }

    /**
     * Set TX_CLR's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline void set_TX_CLR_TXCAL45DN(uint8_t value) volatile
    {
        uint32_t curr = TX_CLR;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TX_CLR = curr;
    }

    /**
     * Get TX_CLR's D_CAL field.
     *
     * D_CAL
     */
    inline uint8_t get_TX_CLR_D_CAL() volatile
    {
        return (TX_CLR >> 0u) & 0b1111u;
    }

    /**
     * Set TX_CLR's D_CAL field.
     *
     * D_CAL
     */
    inline void set_TX_CLR_D_CAL(uint8_t value) volatile
    {
        uint32_t curr = TX_CLR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        TX_CLR = curr;
    }

    /**
     * Get all of TX_CLR's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void get_TX_CLR(uint8_t &TXCAL45DP, uint8_t &TXCAL45DN,
                           uint8_t &D_CAL) volatile
    {
        uint32_t curr = TX_CLR;

        TXCAL45DP = (curr >> 16u) & 0b1111u;
        TXCAL45DN = (curr >> 8u) & 0b1111u;
        D_CAL = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of TX_CLR's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void set_TX_CLR(uint8_t TXCAL45DP, uint8_t TXCAL45DN,
                           uint8_t D_CAL) volatile
    {
        uint32_t curr = TX_CLR;

        curr &= ~(0b1111u << 16u);
        curr |= (TXCAL45DP & 0b1111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (TXCAL45DN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (D_CAL & 0b1111u) << 0u;

        TX_CLR = curr;
    }

    /**
     * Get TX_TOG's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline uint8_t get_TX_TOG_TXCAL45DP() volatile
    {
        return (TX_TOG >> 16u) & 0b1111u;
    }

    /**
     * Set TX_TOG's TXCAL45DP field.
     *
     * TXCAL45DP
     */
    inline void set_TX_TOG_TXCAL45DP(uint8_t value) volatile
    {
        uint32_t curr = TX_TOG;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        TX_TOG = curr;
    }

    /**
     * Get TX_TOG's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline uint8_t get_TX_TOG_TXCAL45DN() volatile
    {
        return (TX_TOG >> 8u) & 0b1111u;
    }

    /**
     * Set TX_TOG's TXCAL45DN field.
     *
     * TXCAL45DN
     */
    inline void set_TX_TOG_TXCAL45DN(uint8_t value) volatile
    {
        uint32_t curr = TX_TOG;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TX_TOG = curr;
    }

    /**
     * Get TX_TOG's D_CAL field.
     *
     * D_CAL
     */
    inline uint8_t get_TX_TOG_D_CAL() volatile
    {
        return (TX_TOG >> 0u) & 0b1111u;
    }

    /**
     * Set TX_TOG's D_CAL field.
     *
     * D_CAL
     */
    inline void set_TX_TOG_D_CAL(uint8_t value) volatile
    {
        uint32_t curr = TX_TOG;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        TX_TOG = curr;
    }

    /**
     * Get all of TX_TOG's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void get_TX_TOG(uint8_t &TXCAL45DP, uint8_t &TXCAL45DN,
                           uint8_t &D_CAL) volatile
    {
        uint32_t curr = TX_TOG;

        TXCAL45DP = (curr >> 16u) & 0b1111u;
        TXCAL45DN = (curr >> 8u) & 0b1111u;
        D_CAL = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of TX_TOG's bit fields.
     *
     * (read-write) USB PHY Transmitter Control Register
     */
    inline void set_TX_TOG(uint8_t TXCAL45DP, uint8_t TXCAL45DN,
                           uint8_t D_CAL) volatile
    {
        uint32_t curr = TX_TOG;

        curr &= ~(0b1111u << 16u);
        curr |= (TXCAL45DP & 0b1111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (TXCAL45DN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (D_CAL & 0b1111u) << 0u;

        TX_TOG = curr;
    }

    /**
     * Get RX's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline bool get_RX_RXDBYPASS() volatile
    {
        return RX & (1u << 22u);
    }

    /**
     * Set RX's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void set_RX_RXDBYPASS() volatile
    {
        RX |= 1u << 22u;
    }

    /**
     * Clear RX's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void clear_RX_RXDBYPASS() volatile
    {
        RX &= ~(1u << 22u);
    }

    /**
     * Toggle RX's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void toggle_RX_RXDBYPASS() volatile
    {
        RX ^= 1u << 22u;
    }

    /**
     * Get RX's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline USBPHY1_RX_DISCONADJ get_RX_DISCONADJ() volatile
    {
        return USBPHY1_RX_DISCONADJ((RX >> 4u) & 0b111u);
    }

    /**
     * Set RX's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline void set_RX_DISCONADJ(USBPHY1_RX_DISCONADJ value) volatile
    {
        uint32_t curr = RX;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        RX = curr;
    }

    /**
     * Get RX's ENVADJ field.
     *
     * ENVADJ
     */
    inline USBPHY1_RX_ENVADJ get_RX_ENVADJ() volatile
    {
        return USBPHY1_RX_ENVADJ((RX >> 0u) & 0b111u);
    }

    /**
     * Set RX's ENVADJ field.
     *
     * ENVADJ
     */
    inline void set_RX_ENVADJ(USBPHY1_RX_ENVADJ value) volatile
    {
        uint32_t curr = RX;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        RX = curr;
    }

    /**
     * Get all of RX's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void get_RX(bool &RXDBYPASS, USBPHY1_RX_DISCONADJ &DISCONADJ,
                       USBPHY1_RX_ENVADJ &ENVADJ) volatile
    {
        uint32_t curr = RX;

        RXDBYPASS = curr & (1u << 22u);
        DISCONADJ = USBPHY1_RX_DISCONADJ((curr >> 4u) & 0b111u);
        ENVADJ = USBPHY1_RX_ENVADJ((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of RX's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void set_RX(bool RXDBYPASS, USBPHY1_RX_DISCONADJ DISCONADJ,
                       USBPHY1_RX_ENVADJ ENVADJ) volatile
    {
        uint32_t curr = RX;

        curr &= ~(0b1u << 22u);
        curr |= (RXDBYPASS & 0b1u) << 22u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(DISCONADJ) & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(ENVADJ) & 0b111u) << 0u;

        RX = curr;
    }

    /**
     * Get RX_SET's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline bool get_RX_SET_RXDBYPASS() volatile
    {
        return RX_SET & (1u << 22u);
    }

    /**
     * Set RX_SET's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void set_RX_SET_RXDBYPASS() volatile
    {
        RX_SET |= 1u << 22u;
    }

    /**
     * Clear RX_SET's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void clear_RX_SET_RXDBYPASS() volatile
    {
        RX_SET &= ~(1u << 22u);
    }

    /**
     * Toggle RX_SET's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void toggle_RX_SET_RXDBYPASS() volatile
    {
        RX_SET ^= 1u << 22u;
    }

    /**
     * Get RX_SET's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline uint8_t get_RX_SET_DISCONADJ() volatile
    {
        return (RX_SET >> 4u) & 0b111u;
    }

    /**
     * Set RX_SET's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline void set_RX_SET_DISCONADJ(uint8_t value) volatile
    {
        uint32_t curr = RX_SET;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        RX_SET = curr;
    }

    /**
     * Get RX_SET's ENVADJ field.
     *
     * ENVADJ
     */
    inline uint8_t get_RX_SET_ENVADJ() volatile
    {
        return (RX_SET >> 0u) & 0b111u;
    }

    /**
     * Set RX_SET's ENVADJ field.
     *
     * ENVADJ
     */
    inline void set_RX_SET_ENVADJ(uint8_t value) volatile
    {
        uint32_t curr = RX_SET;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        RX_SET = curr;
    }

    /**
     * Get all of RX_SET's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void get_RX_SET(bool &RXDBYPASS, uint8_t &DISCONADJ,
                           uint8_t &ENVADJ) volatile
    {
        uint32_t curr = RX_SET;

        RXDBYPASS = curr & (1u << 22u);
        DISCONADJ = (curr >> 4u) & 0b111u;
        ENVADJ = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of RX_SET's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void set_RX_SET(bool RXDBYPASS, uint8_t DISCONADJ,
                           uint8_t ENVADJ) volatile
    {
        uint32_t curr = RX_SET;

        curr &= ~(0b1u << 22u);
        curr |= (RXDBYPASS & 0b1u) << 22u;
        curr &= ~(0b111u << 4u);
        curr |= (DISCONADJ & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (ENVADJ & 0b111u) << 0u;

        RX_SET = curr;
    }

    /**
     * Get RX_CLR's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline bool get_RX_CLR_RXDBYPASS() volatile
    {
        return RX_CLR & (1u << 22u);
    }

    /**
     * Set RX_CLR's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void set_RX_CLR_RXDBYPASS() volatile
    {
        RX_CLR |= 1u << 22u;
    }

    /**
     * Clear RX_CLR's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void clear_RX_CLR_RXDBYPASS() volatile
    {
        RX_CLR &= ~(1u << 22u);
    }

    /**
     * Toggle RX_CLR's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void toggle_RX_CLR_RXDBYPASS() volatile
    {
        RX_CLR ^= 1u << 22u;
    }

    /**
     * Get RX_CLR's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline uint8_t get_RX_CLR_DISCONADJ() volatile
    {
        return (RX_CLR >> 4u) & 0b111u;
    }

    /**
     * Set RX_CLR's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline void set_RX_CLR_DISCONADJ(uint8_t value) volatile
    {
        uint32_t curr = RX_CLR;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        RX_CLR = curr;
    }

    /**
     * Get RX_CLR's ENVADJ field.
     *
     * ENVADJ
     */
    inline uint8_t get_RX_CLR_ENVADJ() volatile
    {
        return (RX_CLR >> 0u) & 0b111u;
    }

    /**
     * Set RX_CLR's ENVADJ field.
     *
     * ENVADJ
     */
    inline void set_RX_CLR_ENVADJ(uint8_t value) volatile
    {
        uint32_t curr = RX_CLR;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        RX_CLR = curr;
    }

    /**
     * Get all of RX_CLR's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void get_RX_CLR(bool &RXDBYPASS, uint8_t &DISCONADJ,
                           uint8_t &ENVADJ) volatile
    {
        uint32_t curr = RX_CLR;

        RXDBYPASS = curr & (1u << 22u);
        DISCONADJ = (curr >> 4u) & 0b111u;
        ENVADJ = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of RX_CLR's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void set_RX_CLR(bool RXDBYPASS, uint8_t DISCONADJ,
                           uint8_t ENVADJ) volatile
    {
        uint32_t curr = RX_CLR;

        curr &= ~(0b1u << 22u);
        curr |= (RXDBYPASS & 0b1u) << 22u;
        curr &= ~(0b111u << 4u);
        curr |= (DISCONADJ & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (ENVADJ & 0b111u) << 0u;

        RX_CLR = curr;
    }

    /**
     * Get RX_TOG's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline bool get_RX_TOG_RXDBYPASS() volatile
    {
        return RX_TOG & (1u << 22u);
    }

    /**
     * Set RX_TOG's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void set_RX_TOG_RXDBYPASS() volatile
    {
        RX_TOG |= 1u << 22u;
    }

    /**
     * Clear RX_TOG's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void clear_RX_TOG_RXDBYPASS() volatile
    {
        RX_TOG &= ~(1u << 22u);
    }

    /**
     * Toggle RX_TOG's RXDBYPASS bit.
     *
     * RXDBYPASS
     */
    inline void toggle_RX_TOG_RXDBYPASS() volatile
    {
        RX_TOG ^= 1u << 22u;
    }

    /**
     * Get RX_TOG's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline uint8_t get_RX_TOG_DISCONADJ() volatile
    {
        return (RX_TOG >> 4u) & 0b111u;
    }

    /**
     * Set RX_TOG's DISCONADJ field.
     *
     * DISCONADJ
     */
    inline void set_RX_TOG_DISCONADJ(uint8_t value) volatile
    {
        uint32_t curr = RX_TOG;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        RX_TOG = curr;
    }

    /**
     * Get RX_TOG's ENVADJ field.
     *
     * ENVADJ
     */
    inline uint8_t get_RX_TOG_ENVADJ() volatile
    {
        return (RX_TOG >> 0u) & 0b111u;
    }

    /**
     * Set RX_TOG's ENVADJ field.
     *
     * ENVADJ
     */
    inline void set_RX_TOG_ENVADJ(uint8_t value) volatile
    {
        uint32_t curr = RX_TOG;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        RX_TOG = curr;
    }

    /**
     * Get all of RX_TOG's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void get_RX_TOG(bool &RXDBYPASS, uint8_t &DISCONADJ,
                           uint8_t &ENVADJ) volatile
    {
        uint32_t curr = RX_TOG;

        RXDBYPASS = curr & (1u << 22u);
        DISCONADJ = (curr >> 4u) & 0b111u;
        ENVADJ = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of RX_TOG's bit fields.
     *
     * (read-write) USB PHY Receiver Control Register
     */
    inline void set_RX_TOG(bool RXDBYPASS, uint8_t DISCONADJ,
                           uint8_t ENVADJ) volatile
    {
        uint32_t curr = RX_TOG;

        curr &= ~(0b1u << 22u);
        curr |= (RXDBYPASS & 0b1u) << 22u;
        curr &= ~(0b111u << 4u);
        curr |= (DISCONADJ & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (ENVADJ & 0b111u) << 0u;

        RX_TOG = curr;
    }

    /**
     * Get CTRL's SFTRST bit.
     *
     * SFTRST
     */
    inline bool get_CTRL_SFTRST() volatile
    {
        return CTRL & (1u << 31u);
    }

    /**
     * Set CTRL's SFTRST bit.
     *
     * SFTRST
     */
    inline void set_CTRL_SFTRST() volatile
    {
        CTRL |= 1u << 31u;
    }

    /**
     * Clear CTRL's SFTRST bit.
     *
     * SFTRST
     */
    inline void clear_CTRL_SFTRST() volatile
    {
        CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL's SFTRST bit.
     *
     * SFTRST
     */
    inline void toggle_CTRL_SFTRST() volatile
    {
        CTRL ^= 1u << 31u;
    }

    /**
     * Get CTRL's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_CTRL_CLKGATE() volatile
    {
        return CTRL & (1u << 30u);
    }

    /**
     * Set CTRL's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_CTRL_CLKGATE() volatile
    {
        CTRL |= 1u << 30u;
    }

    /**
     * Clear CTRL's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_CTRL_CLKGATE() volatile
    {
        CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_CTRL_CLKGATE() volatile
    {
        CTRL ^= 1u << 30u;
    }

    /**
     * Get CTRL's UTMI_SUSPENDM bit.
     *
     * UTMI_SUSPENDM
     */
    inline bool get_CTRL_UTMI_SUSPENDM() volatile
    {
        return CTRL & (1u << 29u);
    }

    /**
     * Get CTRL's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline bool get_CTRL_HOST_FORCE_LS_SE0() volatile
    {
        return CTRL & (1u << 28u);
    }

    /**
     * Set CTRL's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void set_CTRL_HOST_FORCE_LS_SE0() volatile
    {
        CTRL |= 1u << 28u;
    }

    /**
     * Clear CTRL's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void clear_CTRL_HOST_FORCE_LS_SE0() volatile
    {
        CTRL &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void toggle_CTRL_HOST_FORCE_LS_SE0() volatile
    {
        CTRL ^= 1u << 28u;
    }

    /**
     * Get CTRL's OTG_ID_VALUE bit.
     *
     * OTG_ID_VALUE
     */
    inline bool get_CTRL_OTG_ID_VALUE() volatile
    {
        return CTRL & (1u << 27u);
    }

    /**
     * Get CTRL's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline bool get_CTRL_FSDLL_RST_EN() volatile
    {
        return CTRL & (1u << 24u);
    }

    /**
     * Set CTRL's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void set_CTRL_FSDLL_RST_EN() volatile
    {
        CTRL |= 1u << 24u;
    }

    /**
     * Clear CTRL's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void clear_CTRL_FSDLL_RST_EN() volatile
    {
        CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void toggle_CTRL_FSDLL_RST_EN() volatile
    {
        CTRL ^= 1u << 24u;
    }

    /**
     * Get CTRL's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline bool get_CTRL_ENVBUSCHG_WKUP() volatile
    {
        return CTRL & (1u << 23u);
    }

    /**
     * Set CTRL's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void set_CTRL_ENVBUSCHG_WKUP() volatile
    {
        CTRL |= 1u << 23u;
    }

    /**
     * Clear CTRL's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void clear_CTRL_ENVBUSCHG_WKUP() volatile
    {
        CTRL &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void toggle_CTRL_ENVBUSCHG_WKUP() volatile
    {
        CTRL ^= 1u << 23u;
    }

    /**
     * Get CTRL's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline bool get_CTRL_ENIDCHG_WKUP() volatile
    {
        return CTRL & (1u << 22u);
    }

    /**
     * Set CTRL's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void set_CTRL_ENIDCHG_WKUP() volatile
    {
        CTRL |= 1u << 22u;
    }

    /**
     * Clear CTRL's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void clear_CTRL_ENIDCHG_WKUP() volatile
    {
        CTRL &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void toggle_CTRL_ENIDCHG_WKUP() volatile
    {
        CTRL ^= 1u << 22u;
    }

    /**
     * Get CTRL's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline bool get_CTRL_ENDPDMCHG_WKUP() volatile
    {
        return CTRL & (1u << 21u);
    }

    /**
     * Set CTRL's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void set_CTRL_ENDPDMCHG_WKUP() volatile
    {
        CTRL |= 1u << 21u;
    }

    /**
     * Clear CTRL's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void clear_CTRL_ENDPDMCHG_WKUP() volatile
    {
        CTRL &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void toggle_CTRL_ENDPDMCHG_WKUP() volatile
    {
        CTRL ^= 1u << 21u;
    }

    /**
     * Get CTRL's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline bool get_CTRL_ENAUTOCLR_PHY_PWD() volatile
    {
        return CTRL & (1u << 20u);
    }

    /**
     * Set CTRL's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void set_CTRL_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL |= 1u << 20u;
    }

    /**
     * Clear CTRL's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void clear_CTRL_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void toggle_CTRL_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL ^= 1u << 20u;
    }

    /**
     * Get CTRL's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline bool get_CTRL_ENAUTOCLR_CLKGATE() volatile
    {
        return CTRL & (1u << 19u);
    }

    /**
     * Set CTRL's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void set_CTRL_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL |= 1u << 19u;
    }

    /**
     * Clear CTRL's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void clear_CTRL_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void toggle_CTRL_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL ^= 1u << 19u;
    }

    /**
     * Get CTRL's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline bool get_CTRL_AUTORESUME_EN() volatile
    {
        return CTRL & (1u << 18u);
    }

    /**
     * Set CTRL's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void set_CTRL_AUTORESUME_EN() volatile
    {
        CTRL |= 1u << 18u;
    }

    /**
     * Clear CTRL's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void clear_CTRL_AUTORESUME_EN() volatile
    {
        CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void toggle_CTRL_AUTORESUME_EN() volatile
    {
        CTRL ^= 1u << 18u;
    }

    /**
     * Get CTRL's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline bool get_CTRL_WAKEUP_IRQ() volatile
    {
        return CTRL & (1u << 17u);
    }

    /**
     * Set CTRL's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void set_CTRL_WAKEUP_IRQ() volatile
    {
        CTRL |= 1u << 17u;
    }

    /**
     * Clear CTRL's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void clear_CTRL_WAKEUP_IRQ() volatile
    {
        CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void toggle_CTRL_WAKEUP_IRQ() volatile
    {
        CTRL ^= 1u << 17u;
    }

    /**
     * Get CTRL's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline bool get_CTRL_ENIRQWAKEUP() volatile
    {
        return CTRL & (1u << 16u);
    }

    /**
     * Set CTRL's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void set_CTRL_ENIRQWAKEUP() volatile
    {
        CTRL |= 1u << 16u;
    }

    /**
     * Clear CTRL's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void clear_CTRL_ENIRQWAKEUP() volatile
    {
        CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void toggle_CTRL_ENIRQWAKEUP() volatile
    {
        CTRL ^= 1u << 16u;
    }

    /**
     * Get CTRL's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline bool get_CTRL_ENUTMILEVEL3() volatile
    {
        return CTRL & (1u << 15u);
    }

    /**
     * Set CTRL's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void set_CTRL_ENUTMILEVEL3() volatile
    {
        CTRL |= 1u << 15u;
    }

    /**
     * Clear CTRL's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void clear_CTRL_ENUTMILEVEL3() volatile
    {
        CTRL &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void toggle_CTRL_ENUTMILEVEL3() volatile
    {
        CTRL ^= 1u << 15u;
    }

    /**
     * Get CTRL's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline bool get_CTRL_ENUTMILEVEL2() volatile
    {
        return CTRL & (1u << 14u);
    }

    /**
     * Set CTRL's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void set_CTRL_ENUTMILEVEL2() volatile
    {
        CTRL |= 1u << 14u;
    }

    /**
     * Clear CTRL's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void clear_CTRL_ENUTMILEVEL2() volatile
    {
        CTRL &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void toggle_CTRL_ENUTMILEVEL2() volatile
    {
        CTRL ^= 1u << 14u;
    }

    /**
     * Get CTRL's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline bool get_CTRL_DEVPLUGIN_IRQ() volatile
    {
        return CTRL & (1u << 12u);
    }

    /**
     * Set CTRL's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void set_CTRL_DEVPLUGIN_IRQ() volatile
    {
        CTRL |= 1u << 12u;
    }

    /**
     * Clear CTRL's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void clear_CTRL_DEVPLUGIN_IRQ() volatile
    {
        CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void toggle_CTRL_DEVPLUGIN_IRQ() volatile
    {
        CTRL ^= 1u << 12u;
    }

    /**
     * Get CTRL's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline bool get_CTRL_ENIRQDEVPLUGIN() volatile
    {
        return CTRL & (1u << 11u);
    }

    /**
     * Set CTRL's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void set_CTRL_ENIRQDEVPLUGIN() volatile
    {
        CTRL |= 1u << 11u;
    }

    /**
     * Clear CTRL's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void clear_CTRL_ENIRQDEVPLUGIN() volatile
    {
        CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void toggle_CTRL_ENIRQDEVPLUGIN() volatile
    {
        CTRL ^= 1u << 11u;
    }

    /**
     * Get CTRL's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline bool get_CTRL_RESUME_IRQ() volatile
    {
        return CTRL & (1u << 10u);
    }

    /**
     * Set CTRL's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void set_CTRL_RESUME_IRQ() volatile
    {
        CTRL |= 1u << 10u;
    }

    /**
     * Clear CTRL's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void clear_CTRL_RESUME_IRQ() volatile
    {
        CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void toggle_CTRL_RESUME_IRQ() volatile
    {
        CTRL ^= 1u << 10u;
    }

    /**
     * Get CTRL's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline bool get_CTRL_ENIRQRESUMEDETECT() volatile
    {
        return CTRL & (1u << 9u);
    }

    /**
     * Set CTRL's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void set_CTRL_ENIRQRESUMEDETECT() volatile
    {
        CTRL |= 1u << 9u;
    }

    /**
     * Clear CTRL's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void clear_CTRL_ENIRQRESUMEDETECT() volatile
    {
        CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void toggle_CTRL_ENIRQRESUMEDETECT() volatile
    {
        CTRL ^= 1u << 9u;
    }

    /**
     * Get CTRL's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline bool get_CTRL_RESUMEIRQSTICKY() volatile
    {
        return CTRL & (1u << 8u);
    }

    /**
     * Set CTRL's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void set_CTRL_RESUMEIRQSTICKY() volatile
    {
        CTRL |= 1u << 8u;
    }

    /**
     * Clear CTRL's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void clear_CTRL_RESUMEIRQSTICKY() volatile
    {
        CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void toggle_CTRL_RESUMEIRQSTICKY() volatile
    {
        CTRL ^= 1u << 8u;
    }

    /**
     * Get CTRL's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline bool get_CTRL_ENOTGIDDETECT() volatile
    {
        return CTRL & (1u << 7u);
    }

    /**
     * Set CTRL's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void set_CTRL_ENOTGIDDETECT() volatile
    {
        CTRL |= 1u << 7u;
    }

    /**
     * Clear CTRL's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void clear_CTRL_ENOTGIDDETECT() volatile
    {
        CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void toggle_CTRL_ENOTGIDDETECT() volatile
    {
        CTRL ^= 1u << 7u;
    }

    /**
     * Get CTRL's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_OTG_ID_CHG_IRQ() volatile
    {
        return CTRL & (1u << 6u);
    }

    /**
     * Set CTRL's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void set_CTRL_OTG_ID_CHG_IRQ() volatile
    {
        CTRL |= 1u << 6u;
    }

    /**
     * Clear CTRL's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_OTG_ID_CHG_IRQ() volatile
    {
        CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_OTG_ID_CHG_IRQ() volatile
    {
        CTRL ^= 1u << 6u;
    }

    /**
     * Get CTRL's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline bool get_CTRL_DEVPLUGIN_POLARITY() volatile
    {
        return CTRL & (1u << 5u);
    }

    /**
     * Set CTRL's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void set_CTRL_DEVPLUGIN_POLARITY() volatile
    {
        CTRL |= 1u << 5u;
    }

    /**
     * Clear CTRL's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void clear_CTRL_DEVPLUGIN_POLARITY() volatile
    {
        CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void toggle_CTRL_DEVPLUGIN_POLARITY() volatile
    {
        CTRL ^= 1u << 5u;
    }

    /**
     * Get CTRL's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline bool get_CTRL_ENDEVPLUGINDETECT() volatile
    {
        return CTRL & (1u << 4u);
    }

    /**
     * Set CTRL's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void set_CTRL_ENDEVPLUGINDETECT() volatile
    {
        CTRL |= 1u << 4u;
    }

    /**
     * Clear CTRL's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void clear_CTRL_ENDEVPLUGINDETECT() volatile
    {
        CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void toggle_CTRL_ENDEVPLUGINDETECT() volatile
    {
        CTRL ^= 1u << 4u;
    }

    /**
     * Get CTRL's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline bool get_CTRL_HOSTDISCONDETECT_IRQ() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void set_CTRL_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void clear_CTRL_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void toggle_CTRL_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get CTRL's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline bool get_CTRL_ENIRQHOSTDISCON() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void set_CTRL_ENIRQHOSTDISCON() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void clear_CTRL_ENIRQHOSTDISCON() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void toggle_CTRL_ENIRQHOSTDISCON() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline bool get_CTRL_ENHOSTDISCONDETECT() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void set_CTRL_ENHOSTDISCONDETECT() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void clear_CTRL_ENHOSTDISCONDETECT() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void toggle_CTRL_ENHOSTDISCONDETECT() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_ENOTG_ID_CHG_IRQ() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void set_CTRL_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void get_CTRL(
        bool &SFTRST, bool &CLKGATE, bool &UTMI_SUSPENDM,
        bool &HOST_FORCE_LS_SE0, bool &OTG_ID_VALUE, bool &FSDLL_RST_EN,
        bool &ENVBUSCHG_WKUP, bool &ENIDCHG_WKUP, bool &ENDPDMCHG_WKUP,
        bool &ENAUTOCLR_PHY_PWD, bool &ENAUTOCLR_CLKGATE, bool &AUTORESUME_EN,
        bool &WAKEUP_IRQ, bool &ENIRQWAKEUP, bool &ENUTMILEVEL3,
        bool &ENUTMILEVEL2, bool &DEVPLUGIN_IRQ, bool &ENIRQDEVPLUGIN,
        bool &RESUME_IRQ, bool &ENIRQRESUMEDETECT, bool &RESUMEIRQSTICKY,
        bool &ENOTGIDDETECT, bool &OTG_ID_CHG_IRQ, bool &DEVPLUGIN_POLARITY,
        bool &ENDEVPLUGINDETECT, bool &HOSTDISCONDETECT_IRQ,
        bool &ENIRQHOSTDISCON, bool &ENHOSTDISCONDETECT,
        bool &ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        UTMI_SUSPENDM = curr & (1u << 29u);
        HOST_FORCE_LS_SE0 = curr & (1u << 28u);
        OTG_ID_VALUE = curr & (1u << 27u);
        FSDLL_RST_EN = curr & (1u << 24u);
        ENVBUSCHG_WKUP = curr & (1u << 23u);
        ENIDCHG_WKUP = curr & (1u << 22u);
        ENDPDMCHG_WKUP = curr & (1u << 21u);
        ENAUTOCLR_PHY_PWD = curr & (1u << 20u);
        ENAUTOCLR_CLKGATE = curr & (1u << 19u);
        AUTORESUME_EN = curr & (1u << 18u);
        WAKEUP_IRQ = curr & (1u << 17u);
        ENIRQWAKEUP = curr & (1u << 16u);
        ENUTMILEVEL3 = curr & (1u << 15u);
        ENUTMILEVEL2 = curr & (1u << 14u);
        DEVPLUGIN_IRQ = curr & (1u << 12u);
        ENIRQDEVPLUGIN = curr & (1u << 11u);
        RESUME_IRQ = curr & (1u << 10u);
        ENIRQRESUMEDETECT = curr & (1u << 9u);
        RESUMEIRQSTICKY = curr & (1u << 8u);
        ENOTGIDDETECT = curr & (1u << 7u);
        OTG_ID_CHG_IRQ = curr & (1u << 6u);
        DEVPLUGIN_POLARITY = curr & (1u << 5u);
        ENDEVPLUGINDETECT = curr & (1u << 4u);
        HOSTDISCONDETECT_IRQ = curr & (1u << 3u);
        ENIRQHOSTDISCON = curr & (1u << 2u);
        ENHOSTDISCONDETECT = curr & (1u << 1u);
        ENOTG_ID_CHG_IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void set_CTRL(bool SFTRST, bool CLKGATE, bool HOST_FORCE_LS_SE0,
                         bool FSDLL_RST_EN, bool ENVBUSCHG_WKUP,
                         bool ENIDCHG_WKUP, bool ENDPDMCHG_WKUP,
                         bool ENAUTOCLR_PHY_PWD, bool ENAUTOCLR_CLKGATE,
                         bool AUTORESUME_EN, bool WAKEUP_IRQ, bool ENIRQWAKEUP,
                         bool ENUTMILEVEL3, bool ENUTMILEVEL2,
                         bool DEVPLUGIN_IRQ, bool ENIRQDEVPLUGIN,
                         bool RESUME_IRQ, bool ENIRQRESUMEDETECT,
                         bool RESUMEIRQSTICKY, bool ENOTGIDDETECT,
                         bool OTG_ID_CHG_IRQ, bool DEVPLUGIN_POLARITY,
                         bool ENDEVPLUGINDETECT, bool HOSTDISCONDETECT_IRQ,
                         bool ENIRQHOSTDISCON, bool ENHOSTDISCONDETECT,
                         bool ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (HOST_FORCE_LS_SE0 & 0b1u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (FSDLL_RST_EN & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ENVBUSCHG_WKUP & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ENIDCHG_WKUP & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (ENDPDMCHG_WKUP & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ENAUTOCLR_PHY_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ENAUTOCLR_CLKGATE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (AUTORESUME_EN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (WAKEUP_IRQ & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ENIRQWAKEUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENUTMILEVEL3 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ENUTMILEVEL2 & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (DEVPLUGIN_IRQ & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ENIRQDEVPLUGIN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RESUME_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ENIRQRESUMEDETECT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RESUMEIRQSTICKY & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ENOTGIDDETECT & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (OTG_ID_CHG_IRQ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DEVPLUGIN_POLARITY & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ENDEVPLUGINDETECT & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (HOSTDISCONDETECT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENIRQHOSTDISCON & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENHOSTDISCONDETECT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENOTG_ID_CHG_IRQ & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL_SET's SFTRST bit.
     *
     * SFTRST
     */
    inline bool get_CTRL_SET_SFTRST() volatile
    {
        return CTRL_SET & (1u << 31u);
    }

    /**
     * Set CTRL_SET's SFTRST bit.
     *
     * SFTRST
     */
    inline void set_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET |= 1u << 31u;
    }

    /**
     * Clear CTRL_SET's SFTRST bit.
     *
     * SFTRST
     */
    inline void clear_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_SET's SFTRST bit.
     *
     * SFTRST
     */
    inline void toggle_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET ^= 1u << 31u;
    }

    /**
     * Get CTRL_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_CTRL_SET_CLKGATE() volatile
    {
        return CTRL_SET & (1u << 30u);
    }

    /**
     * Set CTRL_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET |= 1u << 30u;
    }

    /**
     * Clear CTRL_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET ^= 1u << 30u;
    }

    /**
     * Get CTRL_SET's UTMI_SUSPENDM bit.
     *
     * UTMI_SUSPENDM
     */
    inline bool get_CTRL_SET_UTMI_SUSPENDM() volatile
    {
        return CTRL_SET & (1u << 29u);
    }

    /**
     * Get CTRL_SET's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline bool get_CTRL_SET_HOST_FORCE_LS_SE0() volatile
    {
        return CTRL_SET & (1u << 28u);
    }

    /**
     * Set CTRL_SET's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void set_CTRL_SET_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_SET |= 1u << 28u;
    }

    /**
     * Clear CTRL_SET's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void clear_CTRL_SET_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_SET &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL_SET's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void toggle_CTRL_SET_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_SET ^= 1u << 28u;
    }

    /**
     * Get CTRL_SET's OTG_ID_VALUE bit.
     *
     * OTG_ID_VALUE
     */
    inline bool get_CTRL_SET_OTG_ID_VALUE() volatile
    {
        return CTRL_SET & (1u << 27u);
    }

    /**
     * Get CTRL_SET's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline bool get_CTRL_SET_FSDLL_RST_EN() volatile
    {
        return CTRL_SET & (1u << 24u);
    }

    /**
     * Set CTRL_SET's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void set_CTRL_SET_FSDLL_RST_EN() volatile
    {
        CTRL_SET |= 1u << 24u;
    }

    /**
     * Clear CTRL_SET's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void clear_CTRL_SET_FSDLL_RST_EN() volatile
    {
        CTRL_SET &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL_SET's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void toggle_CTRL_SET_FSDLL_RST_EN() volatile
    {
        CTRL_SET ^= 1u << 24u;
    }

    /**
     * Get CTRL_SET's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline bool get_CTRL_SET_ENVBUSCHG_WKUP() volatile
    {
        return CTRL_SET & (1u << 23u);
    }

    /**
     * Set CTRL_SET's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void set_CTRL_SET_ENVBUSCHG_WKUP() volatile
    {
        CTRL_SET |= 1u << 23u;
    }

    /**
     * Clear CTRL_SET's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void clear_CTRL_SET_ENVBUSCHG_WKUP() volatile
    {
        CTRL_SET &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL_SET's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void toggle_CTRL_SET_ENVBUSCHG_WKUP() volatile
    {
        CTRL_SET ^= 1u << 23u;
    }

    /**
     * Get CTRL_SET's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline bool get_CTRL_SET_ENIDCHG_WKUP() volatile
    {
        return CTRL_SET & (1u << 22u);
    }

    /**
     * Set CTRL_SET's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void set_CTRL_SET_ENIDCHG_WKUP() volatile
    {
        CTRL_SET |= 1u << 22u;
    }

    /**
     * Clear CTRL_SET's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void clear_CTRL_SET_ENIDCHG_WKUP() volatile
    {
        CTRL_SET &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL_SET's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void toggle_CTRL_SET_ENIDCHG_WKUP() volatile
    {
        CTRL_SET ^= 1u << 22u;
    }

    /**
     * Get CTRL_SET's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline bool get_CTRL_SET_ENDPDMCHG_WKUP() volatile
    {
        return CTRL_SET & (1u << 21u);
    }

    /**
     * Set CTRL_SET's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void set_CTRL_SET_ENDPDMCHG_WKUP() volatile
    {
        CTRL_SET |= 1u << 21u;
    }

    /**
     * Clear CTRL_SET's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void clear_CTRL_SET_ENDPDMCHG_WKUP() volatile
    {
        CTRL_SET &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL_SET's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void toggle_CTRL_SET_ENDPDMCHG_WKUP() volatile
    {
        CTRL_SET ^= 1u << 21u;
    }

    /**
     * Get CTRL_SET's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline bool get_CTRL_SET_ENAUTOCLR_PHY_PWD() volatile
    {
        return CTRL_SET & (1u << 20u);
    }

    /**
     * Set CTRL_SET's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void set_CTRL_SET_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_SET |= 1u << 20u;
    }

    /**
     * Clear CTRL_SET's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void clear_CTRL_SET_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_SET &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL_SET's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void toggle_CTRL_SET_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_SET ^= 1u << 20u;
    }

    /**
     * Get CTRL_SET's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline bool get_CTRL_SET_ENAUTOCLR_CLKGATE() volatile
    {
        return CTRL_SET & (1u << 19u);
    }

    /**
     * Set CTRL_SET's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void set_CTRL_SET_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_SET |= 1u << 19u;
    }

    /**
     * Clear CTRL_SET's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void clear_CTRL_SET_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_SET &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL_SET's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void toggle_CTRL_SET_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_SET ^= 1u << 19u;
    }

    /**
     * Get CTRL_SET's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline bool get_CTRL_SET_AUTORESUME_EN() volatile
    {
        return CTRL_SET & (1u << 18u);
    }

    /**
     * Set CTRL_SET's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void set_CTRL_SET_AUTORESUME_EN() volatile
    {
        CTRL_SET |= 1u << 18u;
    }

    /**
     * Clear CTRL_SET's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void clear_CTRL_SET_AUTORESUME_EN() volatile
    {
        CTRL_SET &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL_SET's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void toggle_CTRL_SET_AUTORESUME_EN() volatile
    {
        CTRL_SET ^= 1u << 18u;
    }

    /**
     * Get CTRL_SET's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline bool get_CTRL_SET_WAKEUP_IRQ() volatile
    {
        return CTRL_SET & (1u << 17u);
    }

    /**
     * Set CTRL_SET's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void set_CTRL_SET_WAKEUP_IRQ() volatile
    {
        CTRL_SET |= 1u << 17u;
    }

    /**
     * Clear CTRL_SET's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void clear_CTRL_SET_WAKEUP_IRQ() volatile
    {
        CTRL_SET &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL_SET's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void toggle_CTRL_SET_WAKEUP_IRQ() volatile
    {
        CTRL_SET ^= 1u << 17u;
    }

    /**
     * Get CTRL_SET's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline bool get_CTRL_SET_ENIRQWAKEUP() volatile
    {
        return CTRL_SET & (1u << 16u);
    }

    /**
     * Set CTRL_SET's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void set_CTRL_SET_ENIRQWAKEUP() volatile
    {
        CTRL_SET |= 1u << 16u;
    }

    /**
     * Clear CTRL_SET's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void clear_CTRL_SET_ENIRQWAKEUP() volatile
    {
        CTRL_SET &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL_SET's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void toggle_CTRL_SET_ENIRQWAKEUP() volatile
    {
        CTRL_SET ^= 1u << 16u;
    }

    /**
     * Get CTRL_SET's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline bool get_CTRL_SET_ENUTMILEVEL3() volatile
    {
        return CTRL_SET & (1u << 15u);
    }

    /**
     * Set CTRL_SET's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void set_CTRL_SET_ENUTMILEVEL3() volatile
    {
        CTRL_SET |= 1u << 15u;
    }

    /**
     * Clear CTRL_SET's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void clear_CTRL_SET_ENUTMILEVEL3() volatile
    {
        CTRL_SET &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL_SET's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void toggle_CTRL_SET_ENUTMILEVEL3() volatile
    {
        CTRL_SET ^= 1u << 15u;
    }

    /**
     * Get CTRL_SET's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline bool get_CTRL_SET_ENUTMILEVEL2() volatile
    {
        return CTRL_SET & (1u << 14u);
    }

    /**
     * Set CTRL_SET's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void set_CTRL_SET_ENUTMILEVEL2() volatile
    {
        CTRL_SET |= 1u << 14u;
    }

    /**
     * Clear CTRL_SET's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void clear_CTRL_SET_ENUTMILEVEL2() volatile
    {
        CTRL_SET &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL_SET's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void toggle_CTRL_SET_ENUTMILEVEL2() volatile
    {
        CTRL_SET ^= 1u << 14u;
    }

    /**
     * Get CTRL_SET's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline bool get_CTRL_SET_DEVPLUGIN_IRQ() volatile
    {
        return CTRL_SET & (1u << 12u);
    }

    /**
     * Set CTRL_SET's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void set_CTRL_SET_DEVPLUGIN_IRQ() volatile
    {
        CTRL_SET |= 1u << 12u;
    }

    /**
     * Clear CTRL_SET's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void clear_CTRL_SET_DEVPLUGIN_IRQ() volatile
    {
        CTRL_SET &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL_SET's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void toggle_CTRL_SET_DEVPLUGIN_IRQ() volatile
    {
        CTRL_SET ^= 1u << 12u;
    }

    /**
     * Get CTRL_SET's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline bool get_CTRL_SET_ENIRQDEVPLUGIN() volatile
    {
        return CTRL_SET & (1u << 11u);
    }

    /**
     * Set CTRL_SET's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void set_CTRL_SET_ENIRQDEVPLUGIN() volatile
    {
        CTRL_SET |= 1u << 11u;
    }

    /**
     * Clear CTRL_SET's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void clear_CTRL_SET_ENIRQDEVPLUGIN() volatile
    {
        CTRL_SET &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_SET's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void toggle_CTRL_SET_ENIRQDEVPLUGIN() volatile
    {
        CTRL_SET ^= 1u << 11u;
    }

    /**
     * Get CTRL_SET's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline bool get_CTRL_SET_RESUME_IRQ() volatile
    {
        return CTRL_SET & (1u << 10u);
    }

    /**
     * Set CTRL_SET's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void set_CTRL_SET_RESUME_IRQ() volatile
    {
        CTRL_SET |= 1u << 10u;
    }

    /**
     * Clear CTRL_SET's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void clear_CTRL_SET_RESUME_IRQ() volatile
    {
        CTRL_SET &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL_SET's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void toggle_CTRL_SET_RESUME_IRQ() volatile
    {
        CTRL_SET ^= 1u << 10u;
    }

    /**
     * Get CTRL_SET's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline bool get_CTRL_SET_ENIRQRESUMEDETECT() volatile
    {
        return CTRL_SET & (1u << 9u);
    }

    /**
     * Set CTRL_SET's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void set_CTRL_SET_ENIRQRESUMEDETECT() volatile
    {
        CTRL_SET |= 1u << 9u;
    }

    /**
     * Clear CTRL_SET's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void clear_CTRL_SET_ENIRQRESUMEDETECT() volatile
    {
        CTRL_SET &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL_SET's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void toggle_CTRL_SET_ENIRQRESUMEDETECT() volatile
    {
        CTRL_SET ^= 1u << 9u;
    }

    /**
     * Get CTRL_SET's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline bool get_CTRL_SET_RESUMEIRQSTICKY() volatile
    {
        return CTRL_SET & (1u << 8u);
    }

    /**
     * Set CTRL_SET's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void set_CTRL_SET_RESUMEIRQSTICKY() volatile
    {
        CTRL_SET |= 1u << 8u;
    }

    /**
     * Clear CTRL_SET's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void clear_CTRL_SET_RESUMEIRQSTICKY() volatile
    {
        CTRL_SET &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL_SET's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void toggle_CTRL_SET_RESUMEIRQSTICKY() volatile
    {
        CTRL_SET ^= 1u << 8u;
    }

    /**
     * Get CTRL_SET's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline bool get_CTRL_SET_ENOTGIDDETECT() volatile
    {
        return CTRL_SET & (1u << 7u);
    }

    /**
     * Set CTRL_SET's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void set_CTRL_SET_ENOTGIDDETECT() volatile
    {
        CTRL_SET |= 1u << 7u;
    }

    /**
     * Clear CTRL_SET's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void clear_CTRL_SET_ENOTGIDDETECT() volatile
    {
        CTRL_SET &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL_SET's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void toggle_CTRL_SET_ENOTGIDDETECT() volatile
    {
        CTRL_SET ^= 1u << 7u;
    }

    /**
     * Get CTRL_SET's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_SET_OTG_ID_CHG_IRQ() volatile
    {
        return CTRL_SET & (1u << 6u);
    }

    /**
     * Set CTRL_SET's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void set_CTRL_SET_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_SET |= 1u << 6u;
    }

    /**
     * Clear CTRL_SET's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_SET_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_SET &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL_SET's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_SET_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_SET ^= 1u << 6u;
    }

    /**
     * Get CTRL_SET's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline bool get_CTRL_SET_DEVPLUGIN_POLARITY() volatile
    {
        return CTRL_SET & (1u << 5u);
    }

    /**
     * Set CTRL_SET's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void set_CTRL_SET_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_SET |= 1u << 5u;
    }

    /**
     * Clear CTRL_SET's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void clear_CTRL_SET_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_SET &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL_SET's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void toggle_CTRL_SET_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_SET ^= 1u << 5u;
    }

    /**
     * Get CTRL_SET's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline bool get_CTRL_SET_ENDEVPLUGINDETECT() volatile
    {
        return CTRL_SET & (1u << 4u);
    }

    /**
     * Set CTRL_SET's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void set_CTRL_SET_ENDEVPLUGINDETECT() volatile
    {
        CTRL_SET |= 1u << 4u;
    }

    /**
     * Clear CTRL_SET's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void clear_CTRL_SET_ENDEVPLUGINDETECT() volatile
    {
        CTRL_SET &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL_SET's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void toggle_CTRL_SET_ENDEVPLUGINDETECT() volatile
    {
        CTRL_SET ^= 1u << 4u;
    }

    /**
     * Get CTRL_SET's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline bool get_CTRL_SET_HOSTDISCONDETECT_IRQ() volatile
    {
        return CTRL_SET & (1u << 3u);
    }

    /**
     * Set CTRL_SET's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void set_CTRL_SET_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_SET |= 1u << 3u;
    }

    /**
     * Clear CTRL_SET's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void clear_CTRL_SET_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_SET &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL_SET's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void toggle_CTRL_SET_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_SET ^= 1u << 3u;
    }

    /**
     * Get CTRL_SET's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline bool get_CTRL_SET_ENIRQHOSTDISCON() volatile
    {
        return CTRL_SET & (1u << 2u);
    }

    /**
     * Set CTRL_SET's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void set_CTRL_SET_ENIRQHOSTDISCON() volatile
    {
        CTRL_SET |= 1u << 2u;
    }

    /**
     * Clear CTRL_SET's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void clear_CTRL_SET_ENIRQHOSTDISCON() volatile
    {
        CTRL_SET &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_SET's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void toggle_CTRL_SET_ENIRQHOSTDISCON() volatile
    {
        CTRL_SET ^= 1u << 2u;
    }

    /**
     * Get CTRL_SET's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline bool get_CTRL_SET_ENHOSTDISCONDETECT() volatile
    {
        return CTRL_SET & (1u << 1u);
    }

    /**
     * Set CTRL_SET's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void set_CTRL_SET_ENHOSTDISCONDETECT() volatile
    {
        CTRL_SET |= 1u << 1u;
    }

    /**
     * Clear CTRL_SET's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void clear_CTRL_SET_ENHOSTDISCONDETECT() volatile
    {
        CTRL_SET &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_SET's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void toggle_CTRL_SET_ENHOSTDISCONDETECT() volatile
    {
        CTRL_SET ^= 1u << 1u;
    }

    /**
     * Get CTRL_SET's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_SET_ENOTG_ID_CHG_IRQ() volatile
    {
        return CTRL_SET & (1u << 0u);
    }

    /**
     * Set CTRL_SET's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void set_CTRL_SET_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_SET |= 1u << 0u;
    }

    /**
     * Clear CTRL_SET's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_SET_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_SET &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_SET's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_SET_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_SET ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_SET's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void get_CTRL_SET(
        bool &SFTRST, bool &CLKGATE, bool &UTMI_SUSPENDM,
        bool &HOST_FORCE_LS_SE0, bool &OTG_ID_VALUE, bool &FSDLL_RST_EN,
        bool &ENVBUSCHG_WKUP, bool &ENIDCHG_WKUP, bool &ENDPDMCHG_WKUP,
        bool &ENAUTOCLR_PHY_PWD, bool &ENAUTOCLR_CLKGATE, bool &AUTORESUME_EN,
        bool &WAKEUP_IRQ, bool &ENIRQWAKEUP, bool &ENUTMILEVEL3,
        bool &ENUTMILEVEL2, bool &DEVPLUGIN_IRQ, bool &ENIRQDEVPLUGIN,
        bool &RESUME_IRQ, bool &ENIRQRESUMEDETECT, bool &RESUMEIRQSTICKY,
        bool &ENOTGIDDETECT, bool &OTG_ID_CHG_IRQ, bool &DEVPLUGIN_POLARITY,
        bool &ENDEVPLUGINDETECT, bool &HOSTDISCONDETECT_IRQ,
        bool &ENIRQHOSTDISCON, bool &ENHOSTDISCONDETECT,
        bool &ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL_SET;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        UTMI_SUSPENDM = curr & (1u << 29u);
        HOST_FORCE_LS_SE0 = curr & (1u << 28u);
        OTG_ID_VALUE = curr & (1u << 27u);
        FSDLL_RST_EN = curr & (1u << 24u);
        ENVBUSCHG_WKUP = curr & (1u << 23u);
        ENIDCHG_WKUP = curr & (1u << 22u);
        ENDPDMCHG_WKUP = curr & (1u << 21u);
        ENAUTOCLR_PHY_PWD = curr & (1u << 20u);
        ENAUTOCLR_CLKGATE = curr & (1u << 19u);
        AUTORESUME_EN = curr & (1u << 18u);
        WAKEUP_IRQ = curr & (1u << 17u);
        ENIRQWAKEUP = curr & (1u << 16u);
        ENUTMILEVEL3 = curr & (1u << 15u);
        ENUTMILEVEL2 = curr & (1u << 14u);
        DEVPLUGIN_IRQ = curr & (1u << 12u);
        ENIRQDEVPLUGIN = curr & (1u << 11u);
        RESUME_IRQ = curr & (1u << 10u);
        ENIRQRESUMEDETECT = curr & (1u << 9u);
        RESUMEIRQSTICKY = curr & (1u << 8u);
        ENOTGIDDETECT = curr & (1u << 7u);
        OTG_ID_CHG_IRQ = curr & (1u << 6u);
        DEVPLUGIN_POLARITY = curr & (1u << 5u);
        ENDEVPLUGINDETECT = curr & (1u << 4u);
        HOSTDISCONDETECT_IRQ = curr & (1u << 3u);
        ENIRQHOSTDISCON = curr & (1u << 2u);
        ENHOSTDISCONDETECT = curr & (1u << 1u);
        ENOTG_ID_CHG_IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_SET's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void set_CTRL_SET(
        bool SFTRST, bool CLKGATE, bool HOST_FORCE_LS_SE0, bool FSDLL_RST_EN,
        bool ENVBUSCHG_WKUP, bool ENIDCHG_WKUP, bool ENDPDMCHG_WKUP,
        bool ENAUTOCLR_PHY_PWD, bool ENAUTOCLR_CLKGATE, bool AUTORESUME_EN,
        bool WAKEUP_IRQ, bool ENIRQWAKEUP, bool ENUTMILEVEL3,
        bool ENUTMILEVEL2, bool DEVPLUGIN_IRQ, bool ENIRQDEVPLUGIN,
        bool RESUME_IRQ, bool ENIRQRESUMEDETECT, bool RESUMEIRQSTICKY,
        bool ENOTGIDDETECT, bool OTG_ID_CHG_IRQ, bool DEVPLUGIN_POLARITY,
        bool ENDEVPLUGINDETECT, bool HOSTDISCONDETECT_IRQ,
        bool ENIRQHOSTDISCON, bool ENHOSTDISCONDETECT,
        bool ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (HOST_FORCE_LS_SE0 & 0b1u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (FSDLL_RST_EN & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ENVBUSCHG_WKUP & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ENIDCHG_WKUP & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (ENDPDMCHG_WKUP & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ENAUTOCLR_PHY_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ENAUTOCLR_CLKGATE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (AUTORESUME_EN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (WAKEUP_IRQ & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ENIRQWAKEUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENUTMILEVEL3 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ENUTMILEVEL2 & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (DEVPLUGIN_IRQ & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ENIRQDEVPLUGIN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RESUME_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ENIRQRESUMEDETECT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RESUMEIRQSTICKY & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ENOTGIDDETECT & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (OTG_ID_CHG_IRQ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DEVPLUGIN_POLARITY & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ENDEVPLUGINDETECT & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (HOSTDISCONDETECT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENIRQHOSTDISCON & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENHOSTDISCONDETECT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENOTG_ID_CHG_IRQ & 0b1u) << 0u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_CLR's SFTRST bit.
     *
     * SFTRST
     */
    inline bool get_CTRL_CLR_SFTRST() volatile
    {
        return CTRL_CLR & (1u << 31u);
    }

    /**
     * Set CTRL_CLR's SFTRST bit.
     *
     * SFTRST
     */
    inline void set_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR |= 1u << 31u;
    }

    /**
     * Clear CTRL_CLR's SFTRST bit.
     *
     * SFTRST
     */
    inline void clear_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_CLR's SFTRST bit.
     *
     * SFTRST
     */
    inline void toggle_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR ^= 1u << 31u;
    }

    /**
     * Get CTRL_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_CTRL_CLR_CLKGATE() volatile
    {
        return CTRL_CLR & (1u << 30u);
    }

    /**
     * Set CTRL_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR |= 1u << 30u;
    }

    /**
     * Clear CTRL_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR ^= 1u << 30u;
    }

    /**
     * Get CTRL_CLR's UTMI_SUSPENDM bit.
     *
     * UTMI_SUSPENDM
     */
    inline bool get_CTRL_CLR_UTMI_SUSPENDM() volatile
    {
        return CTRL_CLR & (1u << 29u);
    }

    /**
     * Get CTRL_CLR's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline bool get_CTRL_CLR_HOST_FORCE_LS_SE0() volatile
    {
        return CTRL_CLR & (1u << 28u);
    }

    /**
     * Set CTRL_CLR's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void set_CTRL_CLR_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_CLR |= 1u << 28u;
    }

    /**
     * Clear CTRL_CLR's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void clear_CTRL_CLR_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_CLR &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL_CLR's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void toggle_CTRL_CLR_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_CLR ^= 1u << 28u;
    }

    /**
     * Get CTRL_CLR's OTG_ID_VALUE bit.
     *
     * OTG_ID_VALUE
     */
    inline bool get_CTRL_CLR_OTG_ID_VALUE() volatile
    {
        return CTRL_CLR & (1u << 27u);
    }

    /**
     * Get CTRL_CLR's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline bool get_CTRL_CLR_FSDLL_RST_EN() volatile
    {
        return CTRL_CLR & (1u << 24u);
    }

    /**
     * Set CTRL_CLR's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void set_CTRL_CLR_FSDLL_RST_EN() volatile
    {
        CTRL_CLR |= 1u << 24u;
    }

    /**
     * Clear CTRL_CLR's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void clear_CTRL_CLR_FSDLL_RST_EN() volatile
    {
        CTRL_CLR &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL_CLR's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void toggle_CTRL_CLR_FSDLL_RST_EN() volatile
    {
        CTRL_CLR ^= 1u << 24u;
    }

    /**
     * Get CTRL_CLR's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline bool get_CTRL_CLR_ENVBUSCHG_WKUP() volatile
    {
        return CTRL_CLR & (1u << 23u);
    }

    /**
     * Set CTRL_CLR's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void set_CTRL_CLR_ENVBUSCHG_WKUP() volatile
    {
        CTRL_CLR |= 1u << 23u;
    }

    /**
     * Clear CTRL_CLR's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void clear_CTRL_CLR_ENVBUSCHG_WKUP() volatile
    {
        CTRL_CLR &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL_CLR's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void toggle_CTRL_CLR_ENVBUSCHG_WKUP() volatile
    {
        CTRL_CLR ^= 1u << 23u;
    }

    /**
     * Get CTRL_CLR's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline bool get_CTRL_CLR_ENIDCHG_WKUP() volatile
    {
        return CTRL_CLR & (1u << 22u);
    }

    /**
     * Set CTRL_CLR's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void set_CTRL_CLR_ENIDCHG_WKUP() volatile
    {
        CTRL_CLR |= 1u << 22u;
    }

    /**
     * Clear CTRL_CLR's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void clear_CTRL_CLR_ENIDCHG_WKUP() volatile
    {
        CTRL_CLR &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL_CLR's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void toggle_CTRL_CLR_ENIDCHG_WKUP() volatile
    {
        CTRL_CLR ^= 1u << 22u;
    }

    /**
     * Get CTRL_CLR's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline bool get_CTRL_CLR_ENDPDMCHG_WKUP() volatile
    {
        return CTRL_CLR & (1u << 21u);
    }

    /**
     * Set CTRL_CLR's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void set_CTRL_CLR_ENDPDMCHG_WKUP() volatile
    {
        CTRL_CLR |= 1u << 21u;
    }

    /**
     * Clear CTRL_CLR's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void clear_CTRL_CLR_ENDPDMCHG_WKUP() volatile
    {
        CTRL_CLR &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL_CLR's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void toggle_CTRL_CLR_ENDPDMCHG_WKUP() volatile
    {
        CTRL_CLR ^= 1u << 21u;
    }

    /**
     * Get CTRL_CLR's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline bool get_CTRL_CLR_ENAUTOCLR_PHY_PWD() volatile
    {
        return CTRL_CLR & (1u << 20u);
    }

    /**
     * Set CTRL_CLR's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void set_CTRL_CLR_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_CLR |= 1u << 20u;
    }

    /**
     * Clear CTRL_CLR's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void clear_CTRL_CLR_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL_CLR's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void toggle_CTRL_CLR_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_CLR ^= 1u << 20u;
    }

    /**
     * Get CTRL_CLR's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline bool get_CTRL_CLR_ENAUTOCLR_CLKGATE() volatile
    {
        return CTRL_CLR & (1u << 19u);
    }

    /**
     * Set CTRL_CLR's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void set_CTRL_CLR_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_CLR |= 1u << 19u;
    }

    /**
     * Clear CTRL_CLR's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void clear_CTRL_CLR_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_CLR &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL_CLR's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void toggle_CTRL_CLR_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_CLR ^= 1u << 19u;
    }

    /**
     * Get CTRL_CLR's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline bool get_CTRL_CLR_AUTORESUME_EN() volatile
    {
        return CTRL_CLR & (1u << 18u);
    }

    /**
     * Set CTRL_CLR's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void set_CTRL_CLR_AUTORESUME_EN() volatile
    {
        CTRL_CLR |= 1u << 18u;
    }

    /**
     * Clear CTRL_CLR's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void clear_CTRL_CLR_AUTORESUME_EN() volatile
    {
        CTRL_CLR &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL_CLR's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void toggle_CTRL_CLR_AUTORESUME_EN() volatile
    {
        CTRL_CLR ^= 1u << 18u;
    }

    /**
     * Get CTRL_CLR's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline bool get_CTRL_CLR_WAKEUP_IRQ() volatile
    {
        return CTRL_CLR & (1u << 17u);
    }

    /**
     * Set CTRL_CLR's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void set_CTRL_CLR_WAKEUP_IRQ() volatile
    {
        CTRL_CLR |= 1u << 17u;
    }

    /**
     * Clear CTRL_CLR's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void clear_CTRL_CLR_WAKEUP_IRQ() volatile
    {
        CTRL_CLR &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL_CLR's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void toggle_CTRL_CLR_WAKEUP_IRQ() volatile
    {
        CTRL_CLR ^= 1u << 17u;
    }

    /**
     * Get CTRL_CLR's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline bool get_CTRL_CLR_ENIRQWAKEUP() volatile
    {
        return CTRL_CLR & (1u << 16u);
    }

    /**
     * Set CTRL_CLR's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void set_CTRL_CLR_ENIRQWAKEUP() volatile
    {
        CTRL_CLR |= 1u << 16u;
    }

    /**
     * Clear CTRL_CLR's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void clear_CTRL_CLR_ENIRQWAKEUP() volatile
    {
        CTRL_CLR &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL_CLR's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void toggle_CTRL_CLR_ENIRQWAKEUP() volatile
    {
        CTRL_CLR ^= 1u << 16u;
    }

    /**
     * Get CTRL_CLR's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline bool get_CTRL_CLR_ENUTMILEVEL3() volatile
    {
        return CTRL_CLR & (1u << 15u);
    }

    /**
     * Set CTRL_CLR's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void set_CTRL_CLR_ENUTMILEVEL3() volatile
    {
        CTRL_CLR |= 1u << 15u;
    }

    /**
     * Clear CTRL_CLR's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void clear_CTRL_CLR_ENUTMILEVEL3() volatile
    {
        CTRL_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL_CLR's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void toggle_CTRL_CLR_ENUTMILEVEL3() volatile
    {
        CTRL_CLR ^= 1u << 15u;
    }

    /**
     * Get CTRL_CLR's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline bool get_CTRL_CLR_ENUTMILEVEL2() volatile
    {
        return CTRL_CLR & (1u << 14u);
    }

    /**
     * Set CTRL_CLR's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void set_CTRL_CLR_ENUTMILEVEL2() volatile
    {
        CTRL_CLR |= 1u << 14u;
    }

    /**
     * Clear CTRL_CLR's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void clear_CTRL_CLR_ENUTMILEVEL2() volatile
    {
        CTRL_CLR &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL_CLR's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void toggle_CTRL_CLR_ENUTMILEVEL2() volatile
    {
        CTRL_CLR ^= 1u << 14u;
    }

    /**
     * Get CTRL_CLR's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline bool get_CTRL_CLR_DEVPLUGIN_IRQ() volatile
    {
        return CTRL_CLR & (1u << 12u);
    }

    /**
     * Set CTRL_CLR's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void set_CTRL_CLR_DEVPLUGIN_IRQ() volatile
    {
        CTRL_CLR |= 1u << 12u;
    }

    /**
     * Clear CTRL_CLR's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void clear_CTRL_CLR_DEVPLUGIN_IRQ() volatile
    {
        CTRL_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL_CLR's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void toggle_CTRL_CLR_DEVPLUGIN_IRQ() volatile
    {
        CTRL_CLR ^= 1u << 12u;
    }

    /**
     * Get CTRL_CLR's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline bool get_CTRL_CLR_ENIRQDEVPLUGIN() volatile
    {
        return CTRL_CLR & (1u << 11u);
    }

    /**
     * Set CTRL_CLR's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void set_CTRL_CLR_ENIRQDEVPLUGIN() volatile
    {
        CTRL_CLR |= 1u << 11u;
    }

    /**
     * Clear CTRL_CLR's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void clear_CTRL_CLR_ENIRQDEVPLUGIN() volatile
    {
        CTRL_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_CLR's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void toggle_CTRL_CLR_ENIRQDEVPLUGIN() volatile
    {
        CTRL_CLR ^= 1u << 11u;
    }

    /**
     * Get CTRL_CLR's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline bool get_CTRL_CLR_RESUME_IRQ() volatile
    {
        return CTRL_CLR & (1u << 10u);
    }

    /**
     * Set CTRL_CLR's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void set_CTRL_CLR_RESUME_IRQ() volatile
    {
        CTRL_CLR |= 1u << 10u;
    }

    /**
     * Clear CTRL_CLR's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void clear_CTRL_CLR_RESUME_IRQ() volatile
    {
        CTRL_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL_CLR's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void toggle_CTRL_CLR_RESUME_IRQ() volatile
    {
        CTRL_CLR ^= 1u << 10u;
    }

    /**
     * Get CTRL_CLR's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline bool get_CTRL_CLR_ENIRQRESUMEDETECT() volatile
    {
        return CTRL_CLR & (1u << 9u);
    }

    /**
     * Set CTRL_CLR's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void set_CTRL_CLR_ENIRQRESUMEDETECT() volatile
    {
        CTRL_CLR |= 1u << 9u;
    }

    /**
     * Clear CTRL_CLR's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void clear_CTRL_CLR_ENIRQRESUMEDETECT() volatile
    {
        CTRL_CLR &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL_CLR's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void toggle_CTRL_CLR_ENIRQRESUMEDETECT() volatile
    {
        CTRL_CLR ^= 1u << 9u;
    }

    /**
     * Get CTRL_CLR's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline bool get_CTRL_CLR_RESUMEIRQSTICKY() volatile
    {
        return CTRL_CLR & (1u << 8u);
    }

    /**
     * Set CTRL_CLR's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void set_CTRL_CLR_RESUMEIRQSTICKY() volatile
    {
        CTRL_CLR |= 1u << 8u;
    }

    /**
     * Clear CTRL_CLR's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void clear_CTRL_CLR_RESUMEIRQSTICKY() volatile
    {
        CTRL_CLR &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL_CLR's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void toggle_CTRL_CLR_RESUMEIRQSTICKY() volatile
    {
        CTRL_CLR ^= 1u << 8u;
    }

    /**
     * Get CTRL_CLR's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline bool get_CTRL_CLR_ENOTGIDDETECT() volatile
    {
        return CTRL_CLR & (1u << 7u);
    }

    /**
     * Set CTRL_CLR's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void set_CTRL_CLR_ENOTGIDDETECT() volatile
    {
        CTRL_CLR |= 1u << 7u;
    }

    /**
     * Clear CTRL_CLR's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void clear_CTRL_CLR_ENOTGIDDETECT() volatile
    {
        CTRL_CLR &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL_CLR's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void toggle_CTRL_CLR_ENOTGIDDETECT() volatile
    {
        CTRL_CLR ^= 1u << 7u;
    }

    /**
     * Get CTRL_CLR's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_CLR_OTG_ID_CHG_IRQ() volatile
    {
        return CTRL_CLR & (1u << 6u);
    }

    /**
     * Set CTRL_CLR's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void set_CTRL_CLR_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_CLR |= 1u << 6u;
    }

    /**
     * Clear CTRL_CLR's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_CLR_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL_CLR's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_CLR_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_CLR ^= 1u << 6u;
    }

    /**
     * Get CTRL_CLR's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline bool get_CTRL_CLR_DEVPLUGIN_POLARITY() volatile
    {
        return CTRL_CLR & (1u << 5u);
    }

    /**
     * Set CTRL_CLR's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void set_CTRL_CLR_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_CLR |= 1u << 5u;
    }

    /**
     * Clear CTRL_CLR's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void clear_CTRL_CLR_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_CLR &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL_CLR's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void toggle_CTRL_CLR_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_CLR ^= 1u << 5u;
    }

    /**
     * Get CTRL_CLR's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline bool get_CTRL_CLR_ENDEVPLUGINDETECT() volatile
    {
        return CTRL_CLR & (1u << 4u);
    }

    /**
     * Set CTRL_CLR's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void set_CTRL_CLR_ENDEVPLUGINDETECT() volatile
    {
        CTRL_CLR |= 1u << 4u;
    }

    /**
     * Clear CTRL_CLR's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void clear_CTRL_CLR_ENDEVPLUGINDETECT() volatile
    {
        CTRL_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL_CLR's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void toggle_CTRL_CLR_ENDEVPLUGINDETECT() volatile
    {
        CTRL_CLR ^= 1u << 4u;
    }

    /**
     * Get CTRL_CLR's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline bool get_CTRL_CLR_HOSTDISCONDETECT_IRQ() volatile
    {
        return CTRL_CLR & (1u << 3u);
    }

    /**
     * Set CTRL_CLR's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void set_CTRL_CLR_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_CLR |= 1u << 3u;
    }

    /**
     * Clear CTRL_CLR's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void clear_CTRL_CLR_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL_CLR's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void toggle_CTRL_CLR_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_CLR ^= 1u << 3u;
    }

    /**
     * Get CTRL_CLR's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline bool get_CTRL_CLR_ENIRQHOSTDISCON() volatile
    {
        return CTRL_CLR & (1u << 2u);
    }

    /**
     * Set CTRL_CLR's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void set_CTRL_CLR_ENIRQHOSTDISCON() volatile
    {
        CTRL_CLR |= 1u << 2u;
    }

    /**
     * Clear CTRL_CLR's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void clear_CTRL_CLR_ENIRQHOSTDISCON() volatile
    {
        CTRL_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_CLR's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void toggle_CTRL_CLR_ENIRQHOSTDISCON() volatile
    {
        CTRL_CLR ^= 1u << 2u;
    }

    /**
     * Get CTRL_CLR's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline bool get_CTRL_CLR_ENHOSTDISCONDETECT() volatile
    {
        return CTRL_CLR & (1u << 1u);
    }

    /**
     * Set CTRL_CLR's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void set_CTRL_CLR_ENHOSTDISCONDETECT() volatile
    {
        CTRL_CLR |= 1u << 1u;
    }

    /**
     * Clear CTRL_CLR's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void clear_CTRL_CLR_ENHOSTDISCONDETECT() volatile
    {
        CTRL_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_CLR's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void toggle_CTRL_CLR_ENHOSTDISCONDETECT() volatile
    {
        CTRL_CLR ^= 1u << 1u;
    }

    /**
     * Get CTRL_CLR's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_CLR_ENOTG_ID_CHG_IRQ() volatile
    {
        return CTRL_CLR & (1u << 0u);
    }

    /**
     * Set CTRL_CLR's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void set_CTRL_CLR_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_CLR |= 1u << 0u;
    }

    /**
     * Clear CTRL_CLR's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_CLR_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_CLR's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_CLR_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_CLR ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_CLR's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void get_CTRL_CLR(
        bool &SFTRST, bool &CLKGATE, bool &UTMI_SUSPENDM,
        bool &HOST_FORCE_LS_SE0, bool &OTG_ID_VALUE, bool &FSDLL_RST_EN,
        bool &ENVBUSCHG_WKUP, bool &ENIDCHG_WKUP, bool &ENDPDMCHG_WKUP,
        bool &ENAUTOCLR_PHY_PWD, bool &ENAUTOCLR_CLKGATE, bool &AUTORESUME_EN,
        bool &WAKEUP_IRQ, bool &ENIRQWAKEUP, bool &ENUTMILEVEL3,
        bool &ENUTMILEVEL2, bool &DEVPLUGIN_IRQ, bool &ENIRQDEVPLUGIN,
        bool &RESUME_IRQ, bool &ENIRQRESUMEDETECT, bool &RESUMEIRQSTICKY,
        bool &ENOTGIDDETECT, bool &OTG_ID_CHG_IRQ, bool &DEVPLUGIN_POLARITY,
        bool &ENDEVPLUGINDETECT, bool &HOSTDISCONDETECT_IRQ,
        bool &ENIRQHOSTDISCON, bool &ENHOSTDISCONDETECT,
        bool &ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL_CLR;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        UTMI_SUSPENDM = curr & (1u << 29u);
        HOST_FORCE_LS_SE0 = curr & (1u << 28u);
        OTG_ID_VALUE = curr & (1u << 27u);
        FSDLL_RST_EN = curr & (1u << 24u);
        ENVBUSCHG_WKUP = curr & (1u << 23u);
        ENIDCHG_WKUP = curr & (1u << 22u);
        ENDPDMCHG_WKUP = curr & (1u << 21u);
        ENAUTOCLR_PHY_PWD = curr & (1u << 20u);
        ENAUTOCLR_CLKGATE = curr & (1u << 19u);
        AUTORESUME_EN = curr & (1u << 18u);
        WAKEUP_IRQ = curr & (1u << 17u);
        ENIRQWAKEUP = curr & (1u << 16u);
        ENUTMILEVEL3 = curr & (1u << 15u);
        ENUTMILEVEL2 = curr & (1u << 14u);
        DEVPLUGIN_IRQ = curr & (1u << 12u);
        ENIRQDEVPLUGIN = curr & (1u << 11u);
        RESUME_IRQ = curr & (1u << 10u);
        ENIRQRESUMEDETECT = curr & (1u << 9u);
        RESUMEIRQSTICKY = curr & (1u << 8u);
        ENOTGIDDETECT = curr & (1u << 7u);
        OTG_ID_CHG_IRQ = curr & (1u << 6u);
        DEVPLUGIN_POLARITY = curr & (1u << 5u);
        ENDEVPLUGINDETECT = curr & (1u << 4u);
        HOSTDISCONDETECT_IRQ = curr & (1u << 3u);
        ENIRQHOSTDISCON = curr & (1u << 2u);
        ENHOSTDISCONDETECT = curr & (1u << 1u);
        ENOTG_ID_CHG_IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_CLR's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void set_CTRL_CLR(
        bool SFTRST, bool CLKGATE, bool HOST_FORCE_LS_SE0, bool FSDLL_RST_EN,
        bool ENVBUSCHG_WKUP, bool ENIDCHG_WKUP, bool ENDPDMCHG_WKUP,
        bool ENAUTOCLR_PHY_PWD, bool ENAUTOCLR_CLKGATE, bool AUTORESUME_EN,
        bool WAKEUP_IRQ, bool ENIRQWAKEUP, bool ENUTMILEVEL3,
        bool ENUTMILEVEL2, bool DEVPLUGIN_IRQ, bool ENIRQDEVPLUGIN,
        bool RESUME_IRQ, bool ENIRQRESUMEDETECT, bool RESUMEIRQSTICKY,
        bool ENOTGIDDETECT, bool OTG_ID_CHG_IRQ, bool DEVPLUGIN_POLARITY,
        bool ENDEVPLUGINDETECT, bool HOSTDISCONDETECT_IRQ,
        bool ENIRQHOSTDISCON, bool ENHOSTDISCONDETECT,
        bool ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (HOST_FORCE_LS_SE0 & 0b1u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (FSDLL_RST_EN & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ENVBUSCHG_WKUP & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ENIDCHG_WKUP & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (ENDPDMCHG_WKUP & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ENAUTOCLR_PHY_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ENAUTOCLR_CLKGATE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (AUTORESUME_EN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (WAKEUP_IRQ & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ENIRQWAKEUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENUTMILEVEL3 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ENUTMILEVEL2 & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (DEVPLUGIN_IRQ & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ENIRQDEVPLUGIN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RESUME_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ENIRQRESUMEDETECT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RESUMEIRQSTICKY & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ENOTGIDDETECT & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (OTG_ID_CHG_IRQ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DEVPLUGIN_POLARITY & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ENDEVPLUGINDETECT & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (HOSTDISCONDETECT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENIRQHOSTDISCON & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENHOSTDISCONDETECT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENOTG_ID_CHG_IRQ & 0b1u) << 0u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_TOG's SFTRST bit.
     *
     * SFTRST
     */
    inline bool get_CTRL_TOG_SFTRST() volatile
    {
        return CTRL_TOG & (1u << 31u);
    }

    /**
     * Set CTRL_TOG's SFTRST bit.
     *
     * SFTRST
     */
    inline void set_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG |= 1u << 31u;
    }

    /**
     * Clear CTRL_TOG's SFTRST bit.
     *
     * SFTRST
     */
    inline void clear_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_TOG's SFTRST bit.
     *
     * SFTRST
     */
    inline void toggle_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG ^= 1u << 31u;
    }

    /**
     * Get CTRL_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_CTRL_TOG_CLKGATE() volatile
    {
        return CTRL_TOG & (1u << 30u);
    }

    /**
     * Set CTRL_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG |= 1u << 30u;
    }

    /**
     * Clear CTRL_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG ^= 1u << 30u;
    }

    /**
     * Get CTRL_TOG's UTMI_SUSPENDM bit.
     *
     * UTMI_SUSPENDM
     */
    inline bool get_CTRL_TOG_UTMI_SUSPENDM() volatile
    {
        return CTRL_TOG & (1u << 29u);
    }

    /**
     * Get CTRL_TOG's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline bool get_CTRL_TOG_HOST_FORCE_LS_SE0() volatile
    {
        return CTRL_TOG & (1u << 28u);
    }

    /**
     * Set CTRL_TOG's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void set_CTRL_TOG_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_TOG |= 1u << 28u;
    }

    /**
     * Clear CTRL_TOG's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void clear_CTRL_TOG_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_TOG &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL_TOG's HOST_FORCE_LS_SE0 bit.
     *
     * HOST_FORCE_LS_SE0
     */
    inline void toggle_CTRL_TOG_HOST_FORCE_LS_SE0() volatile
    {
        CTRL_TOG ^= 1u << 28u;
    }

    /**
     * Get CTRL_TOG's OTG_ID_VALUE bit.
     *
     * OTG_ID_VALUE
     */
    inline bool get_CTRL_TOG_OTG_ID_VALUE() volatile
    {
        return CTRL_TOG & (1u << 27u);
    }

    /**
     * Get CTRL_TOG's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline bool get_CTRL_TOG_FSDLL_RST_EN() volatile
    {
        return CTRL_TOG & (1u << 24u);
    }

    /**
     * Set CTRL_TOG's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void set_CTRL_TOG_FSDLL_RST_EN() volatile
    {
        CTRL_TOG |= 1u << 24u;
    }

    /**
     * Clear CTRL_TOG's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void clear_CTRL_TOG_FSDLL_RST_EN() volatile
    {
        CTRL_TOG &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL_TOG's FSDLL_RST_EN bit.
     *
     * FSDLL_RST_EN
     */
    inline void toggle_CTRL_TOG_FSDLL_RST_EN() volatile
    {
        CTRL_TOG ^= 1u << 24u;
    }

    /**
     * Get CTRL_TOG's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline bool get_CTRL_TOG_ENVBUSCHG_WKUP() volatile
    {
        return CTRL_TOG & (1u << 23u);
    }

    /**
     * Set CTRL_TOG's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void set_CTRL_TOG_ENVBUSCHG_WKUP() volatile
    {
        CTRL_TOG |= 1u << 23u;
    }

    /**
     * Clear CTRL_TOG's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void clear_CTRL_TOG_ENVBUSCHG_WKUP() volatile
    {
        CTRL_TOG &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL_TOG's ENVBUSCHG_WKUP bit.
     *
     * ENVBUSCHG_WKUP
     */
    inline void toggle_CTRL_TOG_ENVBUSCHG_WKUP() volatile
    {
        CTRL_TOG ^= 1u << 23u;
    }

    /**
     * Get CTRL_TOG's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline bool get_CTRL_TOG_ENIDCHG_WKUP() volatile
    {
        return CTRL_TOG & (1u << 22u);
    }

    /**
     * Set CTRL_TOG's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void set_CTRL_TOG_ENIDCHG_WKUP() volatile
    {
        CTRL_TOG |= 1u << 22u;
    }

    /**
     * Clear CTRL_TOG's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void clear_CTRL_TOG_ENIDCHG_WKUP() volatile
    {
        CTRL_TOG &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL_TOG's ENIDCHG_WKUP bit.
     *
     * ENIDCHG_WKUP
     */
    inline void toggle_CTRL_TOG_ENIDCHG_WKUP() volatile
    {
        CTRL_TOG ^= 1u << 22u;
    }

    /**
     * Get CTRL_TOG's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline bool get_CTRL_TOG_ENDPDMCHG_WKUP() volatile
    {
        return CTRL_TOG & (1u << 21u);
    }

    /**
     * Set CTRL_TOG's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void set_CTRL_TOG_ENDPDMCHG_WKUP() volatile
    {
        CTRL_TOG |= 1u << 21u;
    }

    /**
     * Clear CTRL_TOG's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void clear_CTRL_TOG_ENDPDMCHG_WKUP() volatile
    {
        CTRL_TOG &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL_TOG's ENDPDMCHG_WKUP bit.
     *
     * ENDPDMCHG_WKUP
     */
    inline void toggle_CTRL_TOG_ENDPDMCHG_WKUP() volatile
    {
        CTRL_TOG ^= 1u << 21u;
    }

    /**
     * Get CTRL_TOG's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline bool get_CTRL_TOG_ENAUTOCLR_PHY_PWD() volatile
    {
        return CTRL_TOG & (1u << 20u);
    }

    /**
     * Set CTRL_TOG's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void set_CTRL_TOG_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_TOG |= 1u << 20u;
    }

    /**
     * Clear CTRL_TOG's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void clear_CTRL_TOG_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL_TOG's ENAUTOCLR_PHY_PWD bit.
     *
     * ENAUTOCLR_PHY_PWD
     */
    inline void toggle_CTRL_TOG_ENAUTOCLR_PHY_PWD() volatile
    {
        CTRL_TOG ^= 1u << 20u;
    }

    /**
     * Get CTRL_TOG's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline bool get_CTRL_TOG_ENAUTOCLR_CLKGATE() volatile
    {
        return CTRL_TOG & (1u << 19u);
    }

    /**
     * Set CTRL_TOG's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void set_CTRL_TOG_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_TOG |= 1u << 19u;
    }

    /**
     * Clear CTRL_TOG's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void clear_CTRL_TOG_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_TOG &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL_TOG's ENAUTOCLR_CLKGATE bit.
     *
     * ENAUTOCLR_CLKGATE
     */
    inline void toggle_CTRL_TOG_ENAUTOCLR_CLKGATE() volatile
    {
        CTRL_TOG ^= 1u << 19u;
    }

    /**
     * Get CTRL_TOG's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline bool get_CTRL_TOG_AUTORESUME_EN() volatile
    {
        return CTRL_TOG & (1u << 18u);
    }

    /**
     * Set CTRL_TOG's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void set_CTRL_TOG_AUTORESUME_EN() volatile
    {
        CTRL_TOG |= 1u << 18u;
    }

    /**
     * Clear CTRL_TOG's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void clear_CTRL_TOG_AUTORESUME_EN() volatile
    {
        CTRL_TOG &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL_TOG's AUTORESUME_EN bit.
     *
     * AUTORESUME_EN
     */
    inline void toggle_CTRL_TOG_AUTORESUME_EN() volatile
    {
        CTRL_TOG ^= 1u << 18u;
    }

    /**
     * Get CTRL_TOG's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline bool get_CTRL_TOG_WAKEUP_IRQ() volatile
    {
        return CTRL_TOG & (1u << 17u);
    }

    /**
     * Set CTRL_TOG's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void set_CTRL_TOG_WAKEUP_IRQ() volatile
    {
        CTRL_TOG |= 1u << 17u;
    }

    /**
     * Clear CTRL_TOG's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void clear_CTRL_TOG_WAKEUP_IRQ() volatile
    {
        CTRL_TOG &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL_TOG's WAKEUP_IRQ bit.
     *
     * WAKEUP_IRQ
     */
    inline void toggle_CTRL_TOG_WAKEUP_IRQ() volatile
    {
        CTRL_TOG ^= 1u << 17u;
    }

    /**
     * Get CTRL_TOG's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline bool get_CTRL_TOG_ENIRQWAKEUP() volatile
    {
        return CTRL_TOG & (1u << 16u);
    }

    /**
     * Set CTRL_TOG's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void set_CTRL_TOG_ENIRQWAKEUP() volatile
    {
        CTRL_TOG |= 1u << 16u;
    }

    /**
     * Clear CTRL_TOG's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void clear_CTRL_TOG_ENIRQWAKEUP() volatile
    {
        CTRL_TOG &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL_TOG's ENIRQWAKEUP bit.
     *
     * ENIRQWAKEUP
     */
    inline void toggle_CTRL_TOG_ENIRQWAKEUP() volatile
    {
        CTRL_TOG ^= 1u << 16u;
    }

    /**
     * Get CTRL_TOG's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline bool get_CTRL_TOG_ENUTMILEVEL3() volatile
    {
        return CTRL_TOG & (1u << 15u);
    }

    /**
     * Set CTRL_TOG's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void set_CTRL_TOG_ENUTMILEVEL3() volatile
    {
        CTRL_TOG |= 1u << 15u;
    }

    /**
     * Clear CTRL_TOG's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void clear_CTRL_TOG_ENUTMILEVEL3() volatile
    {
        CTRL_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL_TOG's ENUTMILEVEL3 bit.
     *
     * ENUTMILEVEL3
     */
    inline void toggle_CTRL_TOG_ENUTMILEVEL3() volatile
    {
        CTRL_TOG ^= 1u << 15u;
    }

    /**
     * Get CTRL_TOG's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline bool get_CTRL_TOG_ENUTMILEVEL2() volatile
    {
        return CTRL_TOG & (1u << 14u);
    }

    /**
     * Set CTRL_TOG's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void set_CTRL_TOG_ENUTMILEVEL2() volatile
    {
        CTRL_TOG |= 1u << 14u;
    }

    /**
     * Clear CTRL_TOG's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void clear_CTRL_TOG_ENUTMILEVEL2() volatile
    {
        CTRL_TOG &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL_TOG's ENUTMILEVEL2 bit.
     *
     * ENUTMILEVEL2
     */
    inline void toggle_CTRL_TOG_ENUTMILEVEL2() volatile
    {
        CTRL_TOG ^= 1u << 14u;
    }

    /**
     * Get CTRL_TOG's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline bool get_CTRL_TOG_DEVPLUGIN_IRQ() volatile
    {
        return CTRL_TOG & (1u << 12u);
    }

    /**
     * Set CTRL_TOG's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void set_CTRL_TOG_DEVPLUGIN_IRQ() volatile
    {
        CTRL_TOG |= 1u << 12u;
    }

    /**
     * Clear CTRL_TOG's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void clear_CTRL_TOG_DEVPLUGIN_IRQ() volatile
    {
        CTRL_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL_TOG's DEVPLUGIN_IRQ bit.
     *
     * DEVPLUGIN_IRQ
     */
    inline void toggle_CTRL_TOG_DEVPLUGIN_IRQ() volatile
    {
        CTRL_TOG ^= 1u << 12u;
    }

    /**
     * Get CTRL_TOG's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline bool get_CTRL_TOG_ENIRQDEVPLUGIN() volatile
    {
        return CTRL_TOG & (1u << 11u);
    }

    /**
     * Set CTRL_TOG's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void set_CTRL_TOG_ENIRQDEVPLUGIN() volatile
    {
        CTRL_TOG |= 1u << 11u;
    }

    /**
     * Clear CTRL_TOG's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void clear_CTRL_TOG_ENIRQDEVPLUGIN() volatile
    {
        CTRL_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_TOG's ENIRQDEVPLUGIN bit.
     *
     * ENIRQDEVPLUGIN
     */
    inline void toggle_CTRL_TOG_ENIRQDEVPLUGIN() volatile
    {
        CTRL_TOG ^= 1u << 11u;
    }

    /**
     * Get CTRL_TOG's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline bool get_CTRL_TOG_RESUME_IRQ() volatile
    {
        return CTRL_TOG & (1u << 10u);
    }

    /**
     * Set CTRL_TOG's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void set_CTRL_TOG_RESUME_IRQ() volatile
    {
        CTRL_TOG |= 1u << 10u;
    }

    /**
     * Clear CTRL_TOG's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void clear_CTRL_TOG_RESUME_IRQ() volatile
    {
        CTRL_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL_TOG's RESUME_IRQ bit.
     *
     * RESUME_IRQ
     */
    inline void toggle_CTRL_TOG_RESUME_IRQ() volatile
    {
        CTRL_TOG ^= 1u << 10u;
    }

    /**
     * Get CTRL_TOG's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline bool get_CTRL_TOG_ENIRQRESUMEDETECT() volatile
    {
        return CTRL_TOG & (1u << 9u);
    }

    /**
     * Set CTRL_TOG's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void set_CTRL_TOG_ENIRQRESUMEDETECT() volatile
    {
        CTRL_TOG |= 1u << 9u;
    }

    /**
     * Clear CTRL_TOG's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void clear_CTRL_TOG_ENIRQRESUMEDETECT() volatile
    {
        CTRL_TOG &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL_TOG's ENIRQRESUMEDETECT bit.
     *
     * ENIRQRESUMEDETECT
     */
    inline void toggle_CTRL_TOG_ENIRQRESUMEDETECT() volatile
    {
        CTRL_TOG ^= 1u << 9u;
    }

    /**
     * Get CTRL_TOG's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline bool get_CTRL_TOG_RESUMEIRQSTICKY() volatile
    {
        return CTRL_TOG & (1u << 8u);
    }

    /**
     * Set CTRL_TOG's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void set_CTRL_TOG_RESUMEIRQSTICKY() volatile
    {
        CTRL_TOG |= 1u << 8u;
    }

    /**
     * Clear CTRL_TOG's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void clear_CTRL_TOG_RESUMEIRQSTICKY() volatile
    {
        CTRL_TOG &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL_TOG's RESUMEIRQSTICKY bit.
     *
     * RESUMEIRQSTICKY
     */
    inline void toggle_CTRL_TOG_RESUMEIRQSTICKY() volatile
    {
        CTRL_TOG ^= 1u << 8u;
    }

    /**
     * Get CTRL_TOG's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline bool get_CTRL_TOG_ENOTGIDDETECT() volatile
    {
        return CTRL_TOG & (1u << 7u);
    }

    /**
     * Set CTRL_TOG's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void set_CTRL_TOG_ENOTGIDDETECT() volatile
    {
        CTRL_TOG |= 1u << 7u;
    }

    /**
     * Clear CTRL_TOG's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void clear_CTRL_TOG_ENOTGIDDETECT() volatile
    {
        CTRL_TOG &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL_TOG's ENOTGIDDETECT bit.
     *
     * ENOTGIDDETECT
     */
    inline void toggle_CTRL_TOG_ENOTGIDDETECT() volatile
    {
        CTRL_TOG ^= 1u << 7u;
    }

    /**
     * Get CTRL_TOG's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_TOG_OTG_ID_CHG_IRQ() volatile
    {
        return CTRL_TOG & (1u << 6u);
    }

    /**
     * Set CTRL_TOG's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void set_CTRL_TOG_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_TOG |= 1u << 6u;
    }

    /**
     * Clear CTRL_TOG's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_TOG_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL_TOG's OTG_ID_CHG_IRQ bit.
     *
     * OTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_TOG_OTG_ID_CHG_IRQ() volatile
    {
        CTRL_TOG ^= 1u << 6u;
    }

    /**
     * Get CTRL_TOG's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline bool get_CTRL_TOG_DEVPLUGIN_POLARITY() volatile
    {
        return CTRL_TOG & (1u << 5u);
    }

    /**
     * Set CTRL_TOG's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void set_CTRL_TOG_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_TOG |= 1u << 5u;
    }

    /**
     * Clear CTRL_TOG's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void clear_CTRL_TOG_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_TOG &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL_TOG's DEVPLUGIN_POLARITY bit.
     *
     * DEVPLUGIN_POLARITY
     */
    inline void toggle_CTRL_TOG_DEVPLUGIN_POLARITY() volatile
    {
        CTRL_TOG ^= 1u << 5u;
    }

    /**
     * Get CTRL_TOG's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline bool get_CTRL_TOG_ENDEVPLUGINDETECT() volatile
    {
        return CTRL_TOG & (1u << 4u);
    }

    /**
     * Set CTRL_TOG's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void set_CTRL_TOG_ENDEVPLUGINDETECT() volatile
    {
        CTRL_TOG |= 1u << 4u;
    }

    /**
     * Clear CTRL_TOG's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void clear_CTRL_TOG_ENDEVPLUGINDETECT() volatile
    {
        CTRL_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL_TOG's ENDEVPLUGINDETECT bit.
     *
     * Enables non-standard resistive plugged-in detection
     */
    inline void toggle_CTRL_TOG_ENDEVPLUGINDETECT() volatile
    {
        CTRL_TOG ^= 1u << 4u;
    }

    /**
     * Get CTRL_TOG's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline bool get_CTRL_TOG_HOSTDISCONDETECT_IRQ() volatile
    {
        return CTRL_TOG & (1u << 3u);
    }

    /**
     * Set CTRL_TOG's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void set_CTRL_TOG_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_TOG |= 1u << 3u;
    }

    /**
     * Clear CTRL_TOG's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void clear_CTRL_TOG_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL_TOG's HOSTDISCONDETECT_IRQ bit.
     *
     * HOSTDISCONDETECT_IRQ
     */
    inline void toggle_CTRL_TOG_HOSTDISCONDETECT_IRQ() volatile
    {
        CTRL_TOG ^= 1u << 3u;
    }

    /**
     * Get CTRL_TOG's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline bool get_CTRL_TOG_ENIRQHOSTDISCON() volatile
    {
        return CTRL_TOG & (1u << 2u);
    }

    /**
     * Set CTRL_TOG's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void set_CTRL_TOG_ENIRQHOSTDISCON() volatile
    {
        CTRL_TOG |= 1u << 2u;
    }

    /**
     * Clear CTRL_TOG's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void clear_CTRL_TOG_ENIRQHOSTDISCON() volatile
    {
        CTRL_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_TOG's ENIRQHOSTDISCON bit.
     *
     * ENIRQHOSTDISCON
     */
    inline void toggle_CTRL_TOG_ENIRQHOSTDISCON() volatile
    {
        CTRL_TOG ^= 1u << 2u;
    }

    /**
     * Get CTRL_TOG's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline bool get_CTRL_TOG_ENHOSTDISCONDETECT() volatile
    {
        return CTRL_TOG & (1u << 1u);
    }

    /**
     * Set CTRL_TOG's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void set_CTRL_TOG_ENHOSTDISCONDETECT() volatile
    {
        CTRL_TOG |= 1u << 1u;
    }

    /**
     * Clear CTRL_TOG's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void clear_CTRL_TOG_ENHOSTDISCONDETECT() volatile
    {
        CTRL_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_TOG's ENHOSTDISCONDETECT bit.
     *
     * ENHOSTDISCONDETECT
     */
    inline void toggle_CTRL_TOG_ENHOSTDISCONDETECT() volatile
    {
        CTRL_TOG ^= 1u << 1u;
    }

    /**
     * Get CTRL_TOG's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline bool get_CTRL_TOG_ENOTG_ID_CHG_IRQ() volatile
    {
        return CTRL_TOG & (1u << 0u);
    }

    /**
     * Set CTRL_TOG's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void set_CTRL_TOG_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_TOG |= 1u << 0u;
    }

    /**
     * Clear CTRL_TOG's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void clear_CTRL_TOG_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_TOG's ENOTG_ID_CHG_IRQ bit.
     *
     * ENOTG_ID_CHG_IRQ
     */
    inline void toggle_CTRL_TOG_ENOTG_ID_CHG_IRQ() volatile
    {
        CTRL_TOG ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_TOG's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void get_CTRL_TOG(
        bool &SFTRST, bool &CLKGATE, bool &UTMI_SUSPENDM,
        bool &HOST_FORCE_LS_SE0, bool &OTG_ID_VALUE, bool &FSDLL_RST_EN,
        bool &ENVBUSCHG_WKUP, bool &ENIDCHG_WKUP, bool &ENDPDMCHG_WKUP,
        bool &ENAUTOCLR_PHY_PWD, bool &ENAUTOCLR_CLKGATE, bool &AUTORESUME_EN,
        bool &WAKEUP_IRQ, bool &ENIRQWAKEUP, bool &ENUTMILEVEL3,
        bool &ENUTMILEVEL2, bool &DEVPLUGIN_IRQ, bool &ENIRQDEVPLUGIN,
        bool &RESUME_IRQ, bool &ENIRQRESUMEDETECT, bool &RESUMEIRQSTICKY,
        bool &ENOTGIDDETECT, bool &OTG_ID_CHG_IRQ, bool &DEVPLUGIN_POLARITY,
        bool &ENDEVPLUGINDETECT, bool &HOSTDISCONDETECT_IRQ,
        bool &ENIRQHOSTDISCON, bool &ENHOSTDISCONDETECT,
        bool &ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL_TOG;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        UTMI_SUSPENDM = curr & (1u << 29u);
        HOST_FORCE_LS_SE0 = curr & (1u << 28u);
        OTG_ID_VALUE = curr & (1u << 27u);
        FSDLL_RST_EN = curr & (1u << 24u);
        ENVBUSCHG_WKUP = curr & (1u << 23u);
        ENIDCHG_WKUP = curr & (1u << 22u);
        ENDPDMCHG_WKUP = curr & (1u << 21u);
        ENAUTOCLR_PHY_PWD = curr & (1u << 20u);
        ENAUTOCLR_CLKGATE = curr & (1u << 19u);
        AUTORESUME_EN = curr & (1u << 18u);
        WAKEUP_IRQ = curr & (1u << 17u);
        ENIRQWAKEUP = curr & (1u << 16u);
        ENUTMILEVEL3 = curr & (1u << 15u);
        ENUTMILEVEL2 = curr & (1u << 14u);
        DEVPLUGIN_IRQ = curr & (1u << 12u);
        ENIRQDEVPLUGIN = curr & (1u << 11u);
        RESUME_IRQ = curr & (1u << 10u);
        ENIRQRESUMEDETECT = curr & (1u << 9u);
        RESUMEIRQSTICKY = curr & (1u << 8u);
        ENOTGIDDETECT = curr & (1u << 7u);
        OTG_ID_CHG_IRQ = curr & (1u << 6u);
        DEVPLUGIN_POLARITY = curr & (1u << 5u);
        ENDEVPLUGINDETECT = curr & (1u << 4u);
        HOSTDISCONDETECT_IRQ = curr & (1u << 3u);
        ENIRQHOSTDISCON = curr & (1u << 2u);
        ENHOSTDISCONDETECT = curr & (1u << 1u);
        ENOTG_ID_CHG_IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_TOG's bit fields.
     *
     * (read-write) USB PHY General Control Register
     */
    inline void set_CTRL_TOG(
        bool SFTRST, bool CLKGATE, bool HOST_FORCE_LS_SE0, bool FSDLL_RST_EN,
        bool ENVBUSCHG_WKUP, bool ENIDCHG_WKUP, bool ENDPDMCHG_WKUP,
        bool ENAUTOCLR_PHY_PWD, bool ENAUTOCLR_CLKGATE, bool AUTORESUME_EN,
        bool WAKEUP_IRQ, bool ENIRQWAKEUP, bool ENUTMILEVEL3,
        bool ENUTMILEVEL2, bool DEVPLUGIN_IRQ, bool ENIRQDEVPLUGIN,
        bool RESUME_IRQ, bool ENIRQRESUMEDETECT, bool RESUMEIRQSTICKY,
        bool ENOTGIDDETECT, bool OTG_ID_CHG_IRQ, bool DEVPLUGIN_POLARITY,
        bool ENDEVPLUGINDETECT, bool HOSTDISCONDETECT_IRQ,
        bool ENIRQHOSTDISCON, bool ENHOSTDISCONDETECT,
        bool ENOTG_ID_CHG_IRQ) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (HOST_FORCE_LS_SE0 & 0b1u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (FSDLL_RST_EN & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ENVBUSCHG_WKUP & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ENIDCHG_WKUP & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (ENDPDMCHG_WKUP & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ENAUTOCLR_PHY_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ENAUTOCLR_CLKGATE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (AUTORESUME_EN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (WAKEUP_IRQ & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ENIRQWAKEUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ENUTMILEVEL3 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ENUTMILEVEL2 & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (DEVPLUGIN_IRQ & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ENIRQDEVPLUGIN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RESUME_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ENIRQRESUMEDETECT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RESUMEIRQSTICKY & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ENOTGIDDETECT & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (OTG_ID_CHG_IRQ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DEVPLUGIN_POLARITY & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ENDEVPLUGINDETECT & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (HOSTDISCONDETECT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENIRQHOSTDISCON & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENHOSTDISCONDETECT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENOTG_ID_CHG_IRQ & 0b1u) << 0u;

        CTRL_TOG = curr;
    }

    /**
     * Get STATUS's RESUME_STATUS bit.
     *
     * RESUME_STATUS
     */
    inline bool get_STATUS_RESUME_STATUS() volatile
    {
        return STATUS & (1u << 10u);
    }

    /**
     * Get STATUS's OTGID_STATUS bit.
     *
     * OTGID_STATUS
     */
    inline bool get_STATUS_OTGID_STATUS() volatile
    {
        return STATUS & (1u << 8u);
    }

    /**
     * Set STATUS's OTGID_STATUS bit.
     *
     * OTGID_STATUS
     */
    inline void set_STATUS_OTGID_STATUS() volatile
    {
        STATUS |= 1u << 8u;
    }

    /**
     * Clear STATUS's OTGID_STATUS bit.
     *
     * OTGID_STATUS
     */
    inline void clear_STATUS_OTGID_STATUS() volatile
    {
        STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle STATUS's OTGID_STATUS bit.
     *
     * OTGID_STATUS
     */
    inline void toggle_STATUS_OTGID_STATUS() volatile
    {
        STATUS ^= 1u << 8u;
    }

    /**
     * Get STATUS's DEVPLUGIN_STATUS bit.
     *
     * Status indicator for non-standard resistive plugged-in detection
     */
    inline bool get_STATUS_DEVPLUGIN_STATUS() volatile
    {
        return STATUS & (1u << 6u);
    }

    /**
     * Get STATUS's HOSTDISCONDETECT_STATUS bit.
     *
     * HOSTDISCONDETECT_STATUS
     */
    inline bool get_STATUS_HOSTDISCONDETECT_STATUS() volatile
    {
        return STATUS & (1u << 3u);
    }

    /**
     * Get all of STATUS's bit fields.
     *
     * (read-write) USB PHY Status Register
     */
    inline void get_STATUS(bool &RESUME_STATUS, bool &OTGID_STATUS,
                           bool &DEVPLUGIN_STATUS,
                           bool &HOSTDISCONDETECT_STATUS) volatile
    {
        uint32_t curr = STATUS;

        RESUME_STATUS = curr & (1u << 10u);
        OTGID_STATUS = curr & (1u << 8u);
        DEVPLUGIN_STATUS = curr & (1u << 6u);
        HOSTDISCONDETECT_STATUS = curr & (1u << 3u);
    }

    /**
     * Get DEBUG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_DEBUG_CLKGATE() volatile
    {
        return DEBUG & (1u << 30u);
    }

    /**
     * Set DEBUG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_DEBUG_CLKGATE() volatile
    {
        DEBUG |= 1u << 30u;
    }

    /**
     * Clear DEBUG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_DEBUG_CLKGATE() volatile
    {
        DEBUG &= ~(1u << 30u);
    }

    /**
     * Toggle DEBUG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_DEBUG_CLKGATE() volatile
    {
        DEBUG ^= 1u << 30u;
    }

    /**
     * Get DEBUG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline bool get_DEBUG_HOST_RESUME_DEBUG() volatile
    {
        return DEBUG & (1u << 29u);
    }

    /**
     * Set DEBUG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void set_DEBUG_HOST_RESUME_DEBUG() volatile
    {
        DEBUG |= 1u << 29u;
    }

    /**
     * Clear DEBUG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void clear_DEBUG_HOST_RESUME_DEBUG() volatile
    {
        DEBUG &= ~(1u << 29u);
    }

    /**
     * Toggle DEBUG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void toggle_DEBUG_HOST_RESUME_DEBUG() volatile
    {
        DEBUG ^= 1u << 29u;
    }

    /**
     * Get DEBUG's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline uint8_t get_DEBUG_SQUELCHRESETLENGTH() volatile
    {
        return (DEBUG >> 25u) & 0b1111u;
    }

    /**
     * Set DEBUG's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline void set_DEBUG_SQUELCHRESETLENGTH(uint8_t value) volatile
    {
        uint32_t curr = DEBUG;

        curr &= ~(0b1111u << 25u);
        curr |= (value & 0b1111u) << 25u;

        DEBUG = curr;
    }

    /**
     * Get DEBUG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline bool get_DEBUG_ENSQUELCHRESET() volatile
    {
        return DEBUG & (1u << 24u);
    }

    /**
     * Set DEBUG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void set_DEBUG_ENSQUELCHRESET() volatile
    {
        DEBUG |= 1u << 24u;
    }

    /**
     * Clear DEBUG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void clear_DEBUG_ENSQUELCHRESET() volatile
    {
        DEBUG &= ~(1u << 24u);
    }

    /**
     * Toggle DEBUG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void toggle_DEBUG_ENSQUELCHRESET() volatile
    {
        DEBUG ^= 1u << 24u;
    }

    /**
     * Get DEBUG's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline uint8_t get_DEBUG_SQUELCHRESETCOUNT() volatile
    {
        return (DEBUG >> 16u) & 0b11111u;
    }

    /**
     * Set DEBUG's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline void set_DEBUG_SQUELCHRESETCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        DEBUG = curr;
    }

    /**
     * Get DEBUG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline bool get_DEBUG_ENTX2RXCOUNT() volatile
    {
        return DEBUG & (1u << 12u);
    }

    /**
     * Set DEBUG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void set_DEBUG_ENTX2RXCOUNT() volatile
    {
        DEBUG |= 1u << 12u;
    }

    /**
     * Clear DEBUG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void clear_DEBUG_ENTX2RXCOUNT() volatile
    {
        DEBUG &= ~(1u << 12u);
    }

    /**
     * Toggle DEBUG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void toggle_DEBUG_ENTX2RXCOUNT() volatile
    {
        DEBUG ^= 1u << 12u;
    }

    /**
     * Get DEBUG's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline uint8_t get_DEBUG_TX2RXCOUNT() volatile
    {
        return (DEBUG >> 8u) & 0b1111u;
    }

    /**
     * Set DEBUG's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline void set_DEBUG_TX2RXCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        DEBUG = curr;
    }

    /**
     * Get DEBUG's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline uint8_t get_DEBUG_ENHSTPULLDOWN() volatile
    {
        return (DEBUG >> 4u) & 0b11u;
    }

    /**
     * Set DEBUG's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline void set_DEBUG_ENHSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG;

        curr &= ~(0b11u << 4u);
        curr |= (value & 0b11u) << 4u;

        DEBUG = curr;
    }

    /**
     * Get DEBUG's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline uint8_t get_DEBUG_HSTPULLDOWN() volatile
    {
        return (DEBUG >> 2u) & 0b11u;
    }

    /**
     * Set DEBUG's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline void set_DEBUG_HSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG;

        curr &= ~(0b11u << 2u);
        curr |= (value & 0b11u) << 2u;

        DEBUG = curr;
    }

    /**
     * Get DEBUG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline bool get_DEBUG_DEBUG_INTERFACE_HOLD() volatile
    {
        return DEBUG & (1u << 1u);
    }

    /**
     * Set DEBUG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void set_DEBUG_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG |= 1u << 1u;
    }

    /**
     * Clear DEBUG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void clear_DEBUG_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG &= ~(1u << 1u);
    }

    /**
     * Toggle DEBUG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void toggle_DEBUG_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG ^= 1u << 1u;
    }

    /**
     * Get DEBUG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline bool get_DEBUG_OTGIDPIOLOCK() volatile
    {
        return DEBUG & (1u << 0u);
    }

    /**
     * Set DEBUG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void set_DEBUG_OTGIDPIOLOCK() volatile
    {
        DEBUG |= 1u << 0u;
    }

    /**
     * Clear DEBUG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void clear_DEBUG_OTGIDPIOLOCK() volatile
    {
        DEBUG &= ~(1u << 0u);
    }

    /**
     * Toggle DEBUG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void toggle_DEBUG_OTGIDPIOLOCK() volatile
    {
        DEBUG ^= 1u << 0u;
    }

    /**
     * Get all of DEBUG's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void get_DEBUG(bool &CLKGATE, bool &HOST_RESUME_DEBUG,
                          uint8_t &SQUELCHRESETLENGTH, bool &ENSQUELCHRESET,
                          uint8_t &SQUELCHRESETCOUNT, bool &ENTX2RXCOUNT,
                          uint8_t &TX2RXCOUNT, uint8_t &ENHSTPULLDOWN,
                          uint8_t &HSTPULLDOWN, bool &DEBUG_INTERFACE_HOLD,
                          bool &OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG;

        CLKGATE = curr & (1u << 30u);
        HOST_RESUME_DEBUG = curr & (1u << 29u);
        SQUELCHRESETLENGTH = (curr >> 25u) & 0b1111u;
        ENSQUELCHRESET = curr & (1u << 24u);
        SQUELCHRESETCOUNT = (curr >> 16u) & 0b11111u;
        ENTX2RXCOUNT = curr & (1u << 12u);
        TX2RXCOUNT = (curr >> 8u) & 0b1111u;
        ENHSTPULLDOWN = (curr >> 4u) & 0b11u;
        HSTPULLDOWN = (curr >> 2u) & 0b11u;
        DEBUG_INTERFACE_HOLD = curr & (1u << 1u);
        OTGIDPIOLOCK = curr & (1u << 0u);
    }

    /**
     * Set all of DEBUG's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void set_DEBUG(bool CLKGATE, bool HOST_RESUME_DEBUG,
                          uint8_t SQUELCHRESETLENGTH, bool ENSQUELCHRESET,
                          uint8_t SQUELCHRESETCOUNT, bool ENTX2RXCOUNT,
                          uint8_t TX2RXCOUNT, uint8_t ENHSTPULLDOWN,
                          uint8_t HSTPULLDOWN, bool DEBUG_INTERFACE_HOLD,
                          bool OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG;

        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (HOST_RESUME_DEBUG & 0b1u) << 29u;
        curr &= ~(0b1111u << 25u);
        curr |= (SQUELCHRESETLENGTH & 0b1111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENSQUELCHRESET & 0b1u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (SQUELCHRESETCOUNT & 0b11111u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (ENTX2RXCOUNT & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TX2RXCOUNT & 0b1111u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (ENHSTPULLDOWN & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (HSTPULLDOWN & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DEBUG_INTERFACE_HOLD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OTGIDPIOLOCK & 0b1u) << 0u;

        DEBUG = curr;
    }

    /**
     * Get DEBUG_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_DEBUG_SET_CLKGATE() volatile
    {
        return DEBUG_SET & (1u << 30u);
    }

    /**
     * Set DEBUG_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_DEBUG_SET_CLKGATE() volatile
    {
        DEBUG_SET |= 1u << 30u;
    }

    /**
     * Clear DEBUG_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_DEBUG_SET_CLKGATE() volatile
    {
        DEBUG_SET &= ~(1u << 30u);
    }

    /**
     * Toggle DEBUG_SET's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_DEBUG_SET_CLKGATE() volatile
    {
        DEBUG_SET ^= 1u << 30u;
    }

    /**
     * Get DEBUG_SET's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline bool get_DEBUG_SET_HOST_RESUME_DEBUG() volatile
    {
        return DEBUG_SET & (1u << 29u);
    }

    /**
     * Set DEBUG_SET's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void set_DEBUG_SET_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_SET |= 1u << 29u;
    }

    /**
     * Clear DEBUG_SET's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void clear_DEBUG_SET_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_SET &= ~(1u << 29u);
    }

    /**
     * Toggle DEBUG_SET's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void toggle_DEBUG_SET_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_SET ^= 1u << 29u;
    }

    /**
     * Get DEBUG_SET's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline uint8_t get_DEBUG_SET_SQUELCHRESETLENGTH() volatile
    {
        return (DEBUG_SET >> 25u) & 0b1111u;
    }

    /**
     * Set DEBUG_SET's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline void set_DEBUG_SET_SQUELCHRESETLENGTH(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_SET;

        curr &= ~(0b1111u << 25u);
        curr |= (value & 0b1111u) << 25u;

        DEBUG_SET = curr;
    }

    /**
     * Get DEBUG_SET's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline bool get_DEBUG_SET_ENSQUELCHRESET() volatile
    {
        return DEBUG_SET & (1u << 24u);
    }

    /**
     * Set DEBUG_SET's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void set_DEBUG_SET_ENSQUELCHRESET() volatile
    {
        DEBUG_SET |= 1u << 24u;
    }

    /**
     * Clear DEBUG_SET's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void clear_DEBUG_SET_ENSQUELCHRESET() volatile
    {
        DEBUG_SET &= ~(1u << 24u);
    }

    /**
     * Toggle DEBUG_SET's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void toggle_DEBUG_SET_ENSQUELCHRESET() volatile
    {
        DEBUG_SET ^= 1u << 24u;
    }

    /**
     * Get DEBUG_SET's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline uint8_t get_DEBUG_SET_SQUELCHRESETCOUNT() volatile
    {
        return (DEBUG_SET >> 16u) & 0b11111u;
    }

    /**
     * Set DEBUG_SET's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline void set_DEBUG_SET_SQUELCHRESETCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_SET;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        DEBUG_SET = curr;
    }

    /**
     * Get DEBUG_SET's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline bool get_DEBUG_SET_ENTX2RXCOUNT() volatile
    {
        return DEBUG_SET & (1u << 12u);
    }

    /**
     * Set DEBUG_SET's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void set_DEBUG_SET_ENTX2RXCOUNT() volatile
    {
        DEBUG_SET |= 1u << 12u;
    }

    /**
     * Clear DEBUG_SET's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void clear_DEBUG_SET_ENTX2RXCOUNT() volatile
    {
        DEBUG_SET &= ~(1u << 12u);
    }

    /**
     * Toggle DEBUG_SET's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void toggle_DEBUG_SET_ENTX2RXCOUNT() volatile
    {
        DEBUG_SET ^= 1u << 12u;
    }

    /**
     * Get DEBUG_SET's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline uint8_t get_DEBUG_SET_TX2RXCOUNT() volatile
    {
        return (DEBUG_SET >> 8u) & 0b1111u;
    }

    /**
     * Set DEBUG_SET's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline void set_DEBUG_SET_TX2RXCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_SET;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        DEBUG_SET = curr;
    }

    /**
     * Get DEBUG_SET's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline uint8_t get_DEBUG_SET_ENHSTPULLDOWN() volatile
    {
        return (DEBUG_SET >> 4u) & 0b11u;
    }

    /**
     * Set DEBUG_SET's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline void set_DEBUG_SET_ENHSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_SET;

        curr &= ~(0b11u << 4u);
        curr |= (value & 0b11u) << 4u;

        DEBUG_SET = curr;
    }

    /**
     * Get DEBUG_SET's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline uint8_t get_DEBUG_SET_HSTPULLDOWN() volatile
    {
        return (DEBUG_SET >> 2u) & 0b11u;
    }

    /**
     * Set DEBUG_SET's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline void set_DEBUG_SET_HSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_SET;

        curr &= ~(0b11u << 2u);
        curr |= (value & 0b11u) << 2u;

        DEBUG_SET = curr;
    }

    /**
     * Get DEBUG_SET's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline bool get_DEBUG_SET_DEBUG_INTERFACE_HOLD() volatile
    {
        return DEBUG_SET & (1u << 1u);
    }

    /**
     * Set DEBUG_SET's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void set_DEBUG_SET_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_SET |= 1u << 1u;
    }

    /**
     * Clear DEBUG_SET's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void clear_DEBUG_SET_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_SET &= ~(1u << 1u);
    }

    /**
     * Toggle DEBUG_SET's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void toggle_DEBUG_SET_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_SET ^= 1u << 1u;
    }

    /**
     * Get DEBUG_SET's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline bool get_DEBUG_SET_OTGIDPIOLOCK() volatile
    {
        return DEBUG_SET & (1u << 0u);
    }

    /**
     * Set DEBUG_SET's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void set_DEBUG_SET_OTGIDPIOLOCK() volatile
    {
        DEBUG_SET |= 1u << 0u;
    }

    /**
     * Clear DEBUG_SET's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void clear_DEBUG_SET_OTGIDPIOLOCK() volatile
    {
        DEBUG_SET &= ~(1u << 0u);
    }

    /**
     * Toggle DEBUG_SET's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void toggle_DEBUG_SET_OTGIDPIOLOCK() volatile
    {
        DEBUG_SET ^= 1u << 0u;
    }

    /**
     * Get all of DEBUG_SET's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void get_DEBUG_SET(bool &CLKGATE, bool &HOST_RESUME_DEBUG,
                              uint8_t &SQUELCHRESETLENGTH,
                              bool &ENSQUELCHRESET, uint8_t &SQUELCHRESETCOUNT,
                              bool &ENTX2RXCOUNT, uint8_t &TX2RXCOUNT,
                              uint8_t &ENHSTPULLDOWN, uint8_t &HSTPULLDOWN,
                              bool &DEBUG_INTERFACE_HOLD,
                              bool &OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG_SET;

        CLKGATE = curr & (1u << 30u);
        HOST_RESUME_DEBUG = curr & (1u << 29u);
        SQUELCHRESETLENGTH = (curr >> 25u) & 0b1111u;
        ENSQUELCHRESET = curr & (1u << 24u);
        SQUELCHRESETCOUNT = (curr >> 16u) & 0b11111u;
        ENTX2RXCOUNT = curr & (1u << 12u);
        TX2RXCOUNT = (curr >> 8u) & 0b1111u;
        ENHSTPULLDOWN = (curr >> 4u) & 0b11u;
        HSTPULLDOWN = (curr >> 2u) & 0b11u;
        DEBUG_INTERFACE_HOLD = curr & (1u << 1u);
        OTGIDPIOLOCK = curr & (1u << 0u);
    }

    /**
     * Set all of DEBUG_SET's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void set_DEBUG_SET(bool CLKGATE, bool HOST_RESUME_DEBUG,
                              uint8_t SQUELCHRESETLENGTH, bool ENSQUELCHRESET,
                              uint8_t SQUELCHRESETCOUNT, bool ENTX2RXCOUNT,
                              uint8_t TX2RXCOUNT, uint8_t ENHSTPULLDOWN,
                              uint8_t HSTPULLDOWN, bool DEBUG_INTERFACE_HOLD,
                              bool OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG_SET;

        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (HOST_RESUME_DEBUG & 0b1u) << 29u;
        curr &= ~(0b1111u << 25u);
        curr |= (SQUELCHRESETLENGTH & 0b1111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENSQUELCHRESET & 0b1u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (SQUELCHRESETCOUNT & 0b11111u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (ENTX2RXCOUNT & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TX2RXCOUNT & 0b1111u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (ENHSTPULLDOWN & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (HSTPULLDOWN & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DEBUG_INTERFACE_HOLD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OTGIDPIOLOCK & 0b1u) << 0u;

        DEBUG_SET = curr;
    }

    /**
     * Get DEBUG_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_DEBUG_CLR_CLKGATE() volatile
    {
        return DEBUG_CLR & (1u << 30u);
    }

    /**
     * Set DEBUG_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_DEBUG_CLR_CLKGATE() volatile
    {
        DEBUG_CLR |= 1u << 30u;
    }

    /**
     * Clear DEBUG_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_DEBUG_CLR_CLKGATE() volatile
    {
        DEBUG_CLR &= ~(1u << 30u);
    }

    /**
     * Toggle DEBUG_CLR's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_DEBUG_CLR_CLKGATE() volatile
    {
        DEBUG_CLR ^= 1u << 30u;
    }

    /**
     * Get DEBUG_CLR's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline bool get_DEBUG_CLR_HOST_RESUME_DEBUG() volatile
    {
        return DEBUG_CLR & (1u << 29u);
    }

    /**
     * Set DEBUG_CLR's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void set_DEBUG_CLR_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_CLR |= 1u << 29u;
    }

    /**
     * Clear DEBUG_CLR's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void clear_DEBUG_CLR_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_CLR &= ~(1u << 29u);
    }

    /**
     * Toggle DEBUG_CLR's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void toggle_DEBUG_CLR_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_CLR ^= 1u << 29u;
    }

    /**
     * Get DEBUG_CLR's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline uint8_t get_DEBUG_CLR_SQUELCHRESETLENGTH() volatile
    {
        return (DEBUG_CLR >> 25u) & 0b1111u;
    }

    /**
     * Set DEBUG_CLR's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline void set_DEBUG_CLR_SQUELCHRESETLENGTH(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_CLR;

        curr &= ~(0b1111u << 25u);
        curr |= (value & 0b1111u) << 25u;

        DEBUG_CLR = curr;
    }

    /**
     * Get DEBUG_CLR's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline bool get_DEBUG_CLR_ENSQUELCHRESET() volatile
    {
        return DEBUG_CLR & (1u << 24u);
    }

    /**
     * Set DEBUG_CLR's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void set_DEBUG_CLR_ENSQUELCHRESET() volatile
    {
        DEBUG_CLR |= 1u << 24u;
    }

    /**
     * Clear DEBUG_CLR's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void clear_DEBUG_CLR_ENSQUELCHRESET() volatile
    {
        DEBUG_CLR &= ~(1u << 24u);
    }

    /**
     * Toggle DEBUG_CLR's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void toggle_DEBUG_CLR_ENSQUELCHRESET() volatile
    {
        DEBUG_CLR ^= 1u << 24u;
    }

    /**
     * Get DEBUG_CLR's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline uint8_t get_DEBUG_CLR_SQUELCHRESETCOUNT() volatile
    {
        return (DEBUG_CLR >> 16u) & 0b11111u;
    }

    /**
     * Set DEBUG_CLR's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline void set_DEBUG_CLR_SQUELCHRESETCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_CLR;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        DEBUG_CLR = curr;
    }

    /**
     * Get DEBUG_CLR's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline bool get_DEBUG_CLR_ENTX2RXCOUNT() volatile
    {
        return DEBUG_CLR & (1u << 12u);
    }

    /**
     * Set DEBUG_CLR's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void set_DEBUG_CLR_ENTX2RXCOUNT() volatile
    {
        DEBUG_CLR |= 1u << 12u;
    }

    /**
     * Clear DEBUG_CLR's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void clear_DEBUG_CLR_ENTX2RXCOUNT() volatile
    {
        DEBUG_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle DEBUG_CLR's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void toggle_DEBUG_CLR_ENTX2RXCOUNT() volatile
    {
        DEBUG_CLR ^= 1u << 12u;
    }

    /**
     * Get DEBUG_CLR's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline uint8_t get_DEBUG_CLR_TX2RXCOUNT() volatile
    {
        return (DEBUG_CLR >> 8u) & 0b1111u;
    }

    /**
     * Set DEBUG_CLR's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline void set_DEBUG_CLR_TX2RXCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_CLR;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        DEBUG_CLR = curr;
    }

    /**
     * Get DEBUG_CLR's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline uint8_t get_DEBUG_CLR_ENHSTPULLDOWN() volatile
    {
        return (DEBUG_CLR >> 4u) & 0b11u;
    }

    /**
     * Set DEBUG_CLR's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline void set_DEBUG_CLR_ENHSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_CLR;

        curr &= ~(0b11u << 4u);
        curr |= (value & 0b11u) << 4u;

        DEBUG_CLR = curr;
    }

    /**
     * Get DEBUG_CLR's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline uint8_t get_DEBUG_CLR_HSTPULLDOWN() volatile
    {
        return (DEBUG_CLR >> 2u) & 0b11u;
    }

    /**
     * Set DEBUG_CLR's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline void set_DEBUG_CLR_HSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_CLR;

        curr &= ~(0b11u << 2u);
        curr |= (value & 0b11u) << 2u;

        DEBUG_CLR = curr;
    }

    /**
     * Get DEBUG_CLR's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline bool get_DEBUG_CLR_DEBUG_INTERFACE_HOLD() volatile
    {
        return DEBUG_CLR & (1u << 1u);
    }

    /**
     * Set DEBUG_CLR's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void set_DEBUG_CLR_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_CLR |= 1u << 1u;
    }

    /**
     * Clear DEBUG_CLR's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void clear_DEBUG_CLR_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle DEBUG_CLR's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void toggle_DEBUG_CLR_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_CLR ^= 1u << 1u;
    }

    /**
     * Get DEBUG_CLR's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline bool get_DEBUG_CLR_OTGIDPIOLOCK() volatile
    {
        return DEBUG_CLR & (1u << 0u);
    }

    /**
     * Set DEBUG_CLR's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void set_DEBUG_CLR_OTGIDPIOLOCK() volatile
    {
        DEBUG_CLR |= 1u << 0u;
    }

    /**
     * Clear DEBUG_CLR's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void clear_DEBUG_CLR_OTGIDPIOLOCK() volatile
    {
        DEBUG_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle DEBUG_CLR's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void toggle_DEBUG_CLR_OTGIDPIOLOCK() volatile
    {
        DEBUG_CLR ^= 1u << 0u;
    }

    /**
     * Get all of DEBUG_CLR's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void get_DEBUG_CLR(bool &CLKGATE, bool &HOST_RESUME_DEBUG,
                              uint8_t &SQUELCHRESETLENGTH,
                              bool &ENSQUELCHRESET, uint8_t &SQUELCHRESETCOUNT,
                              bool &ENTX2RXCOUNT, uint8_t &TX2RXCOUNT,
                              uint8_t &ENHSTPULLDOWN, uint8_t &HSTPULLDOWN,
                              bool &DEBUG_INTERFACE_HOLD,
                              bool &OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG_CLR;

        CLKGATE = curr & (1u << 30u);
        HOST_RESUME_DEBUG = curr & (1u << 29u);
        SQUELCHRESETLENGTH = (curr >> 25u) & 0b1111u;
        ENSQUELCHRESET = curr & (1u << 24u);
        SQUELCHRESETCOUNT = (curr >> 16u) & 0b11111u;
        ENTX2RXCOUNT = curr & (1u << 12u);
        TX2RXCOUNT = (curr >> 8u) & 0b1111u;
        ENHSTPULLDOWN = (curr >> 4u) & 0b11u;
        HSTPULLDOWN = (curr >> 2u) & 0b11u;
        DEBUG_INTERFACE_HOLD = curr & (1u << 1u);
        OTGIDPIOLOCK = curr & (1u << 0u);
    }

    /**
     * Set all of DEBUG_CLR's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void set_DEBUG_CLR(bool CLKGATE, bool HOST_RESUME_DEBUG,
                              uint8_t SQUELCHRESETLENGTH, bool ENSQUELCHRESET,
                              uint8_t SQUELCHRESETCOUNT, bool ENTX2RXCOUNT,
                              uint8_t TX2RXCOUNT, uint8_t ENHSTPULLDOWN,
                              uint8_t HSTPULLDOWN, bool DEBUG_INTERFACE_HOLD,
                              bool OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG_CLR;

        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (HOST_RESUME_DEBUG & 0b1u) << 29u;
        curr &= ~(0b1111u << 25u);
        curr |= (SQUELCHRESETLENGTH & 0b1111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENSQUELCHRESET & 0b1u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (SQUELCHRESETCOUNT & 0b11111u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (ENTX2RXCOUNT & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TX2RXCOUNT & 0b1111u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (ENHSTPULLDOWN & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (HSTPULLDOWN & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DEBUG_INTERFACE_HOLD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OTGIDPIOLOCK & 0b1u) << 0u;

        DEBUG_CLR = curr;
    }

    /**
     * Get DEBUG_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline bool get_DEBUG_TOG_CLKGATE() volatile
    {
        return DEBUG_TOG & (1u << 30u);
    }

    /**
     * Set DEBUG_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void set_DEBUG_TOG_CLKGATE() volatile
    {
        DEBUG_TOG |= 1u << 30u;
    }

    /**
     * Clear DEBUG_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void clear_DEBUG_TOG_CLKGATE() volatile
    {
        DEBUG_TOG &= ~(1u << 30u);
    }

    /**
     * Toggle DEBUG_TOG's CLKGATE bit.
     *
     * CLKGATE
     */
    inline void toggle_DEBUG_TOG_CLKGATE() volatile
    {
        DEBUG_TOG ^= 1u << 30u;
    }

    /**
     * Get DEBUG_TOG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline bool get_DEBUG_TOG_HOST_RESUME_DEBUG() volatile
    {
        return DEBUG_TOG & (1u << 29u);
    }

    /**
     * Set DEBUG_TOG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void set_DEBUG_TOG_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_TOG |= 1u << 29u;
    }

    /**
     * Clear DEBUG_TOG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void clear_DEBUG_TOG_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_TOG &= ~(1u << 29u);
    }

    /**
     * Toggle DEBUG_TOG's HOST_RESUME_DEBUG bit.
     *
     * HOST_RESUME_DEBUG
     */
    inline void toggle_DEBUG_TOG_HOST_RESUME_DEBUG() volatile
    {
        DEBUG_TOG ^= 1u << 29u;
    }

    /**
     * Get DEBUG_TOG's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline uint8_t get_DEBUG_TOG_SQUELCHRESETLENGTH() volatile
    {
        return (DEBUG_TOG >> 25u) & 0b1111u;
    }

    /**
     * Set DEBUG_TOG's SQUELCHRESETLENGTH field.
     *
     * SQUELCHRESETLENGTH
     */
    inline void set_DEBUG_TOG_SQUELCHRESETLENGTH(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_TOG;

        curr &= ~(0b1111u << 25u);
        curr |= (value & 0b1111u) << 25u;

        DEBUG_TOG = curr;
    }

    /**
     * Get DEBUG_TOG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline bool get_DEBUG_TOG_ENSQUELCHRESET() volatile
    {
        return DEBUG_TOG & (1u << 24u);
    }

    /**
     * Set DEBUG_TOG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void set_DEBUG_TOG_ENSQUELCHRESET() volatile
    {
        DEBUG_TOG |= 1u << 24u;
    }

    /**
     * Clear DEBUG_TOG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void clear_DEBUG_TOG_ENSQUELCHRESET() volatile
    {
        DEBUG_TOG &= ~(1u << 24u);
    }

    /**
     * Toggle DEBUG_TOG's ENSQUELCHRESET bit.
     *
     * ENSQUELCHRESET
     */
    inline void toggle_DEBUG_TOG_ENSQUELCHRESET() volatile
    {
        DEBUG_TOG ^= 1u << 24u;
    }

    /**
     * Get DEBUG_TOG's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline uint8_t get_DEBUG_TOG_SQUELCHRESETCOUNT() volatile
    {
        return (DEBUG_TOG >> 16u) & 0b11111u;
    }

    /**
     * Set DEBUG_TOG's SQUELCHRESETCOUNT field.
     *
     * SQUELCHRESETCOUNT
     */
    inline void set_DEBUG_TOG_SQUELCHRESETCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_TOG;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        DEBUG_TOG = curr;
    }

    /**
     * Get DEBUG_TOG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline bool get_DEBUG_TOG_ENTX2RXCOUNT() volatile
    {
        return DEBUG_TOG & (1u << 12u);
    }

    /**
     * Set DEBUG_TOG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void set_DEBUG_TOG_ENTX2RXCOUNT() volatile
    {
        DEBUG_TOG |= 1u << 12u;
    }

    /**
     * Clear DEBUG_TOG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void clear_DEBUG_TOG_ENTX2RXCOUNT() volatile
    {
        DEBUG_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle DEBUG_TOG's ENTX2RXCOUNT bit.
     *
     * ENTX2RXCOUNT
     */
    inline void toggle_DEBUG_TOG_ENTX2RXCOUNT() volatile
    {
        DEBUG_TOG ^= 1u << 12u;
    }

    /**
     * Get DEBUG_TOG's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline uint8_t get_DEBUG_TOG_TX2RXCOUNT() volatile
    {
        return (DEBUG_TOG >> 8u) & 0b1111u;
    }

    /**
     * Set DEBUG_TOG's TX2RXCOUNT field.
     *
     * TX2RXCOUNT
     */
    inline void set_DEBUG_TOG_TX2RXCOUNT(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_TOG;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        DEBUG_TOG = curr;
    }

    /**
     * Get DEBUG_TOG's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline uint8_t get_DEBUG_TOG_ENHSTPULLDOWN() volatile
    {
        return (DEBUG_TOG >> 4u) & 0b11u;
    }

    /**
     * Set DEBUG_TOG's ENHSTPULLDOWN field.
     *
     * ENHSTPULLDOWN
     */
    inline void set_DEBUG_TOG_ENHSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_TOG;

        curr &= ~(0b11u << 4u);
        curr |= (value & 0b11u) << 4u;

        DEBUG_TOG = curr;
    }

    /**
     * Get DEBUG_TOG's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline uint8_t get_DEBUG_TOG_HSTPULLDOWN() volatile
    {
        return (DEBUG_TOG >> 2u) & 0b11u;
    }

    /**
     * Set DEBUG_TOG's HSTPULLDOWN field.
     *
     * HSTPULLDOWN
     */
    inline void set_DEBUG_TOG_HSTPULLDOWN(uint8_t value) volatile
    {
        uint32_t curr = DEBUG_TOG;

        curr &= ~(0b11u << 2u);
        curr |= (value & 0b11u) << 2u;

        DEBUG_TOG = curr;
    }

    /**
     * Get DEBUG_TOG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline bool get_DEBUG_TOG_DEBUG_INTERFACE_HOLD() volatile
    {
        return DEBUG_TOG & (1u << 1u);
    }

    /**
     * Set DEBUG_TOG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void set_DEBUG_TOG_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_TOG |= 1u << 1u;
    }

    /**
     * Clear DEBUG_TOG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void clear_DEBUG_TOG_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle DEBUG_TOG's DEBUG_INTERFACE_HOLD bit.
     *
     * DEBUG_INTERFACE_HOLD
     */
    inline void toggle_DEBUG_TOG_DEBUG_INTERFACE_HOLD() volatile
    {
        DEBUG_TOG ^= 1u << 1u;
    }

    /**
     * Get DEBUG_TOG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline bool get_DEBUG_TOG_OTGIDPIOLOCK() volatile
    {
        return DEBUG_TOG & (1u << 0u);
    }

    /**
     * Set DEBUG_TOG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void set_DEBUG_TOG_OTGIDPIOLOCK() volatile
    {
        DEBUG_TOG |= 1u << 0u;
    }

    /**
     * Clear DEBUG_TOG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void clear_DEBUG_TOG_OTGIDPIOLOCK() volatile
    {
        DEBUG_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle DEBUG_TOG's OTGIDPIOLOCK bit.
     *
     * OTGIDPIOLOCK
     */
    inline void toggle_DEBUG_TOG_OTGIDPIOLOCK() volatile
    {
        DEBUG_TOG ^= 1u << 0u;
    }

    /**
     * Get all of DEBUG_TOG's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void get_DEBUG_TOG(bool &CLKGATE, bool &HOST_RESUME_DEBUG,
                              uint8_t &SQUELCHRESETLENGTH,
                              bool &ENSQUELCHRESET, uint8_t &SQUELCHRESETCOUNT,
                              bool &ENTX2RXCOUNT, uint8_t &TX2RXCOUNT,
                              uint8_t &ENHSTPULLDOWN, uint8_t &HSTPULLDOWN,
                              bool &DEBUG_INTERFACE_HOLD,
                              bool &OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG_TOG;

        CLKGATE = curr & (1u << 30u);
        HOST_RESUME_DEBUG = curr & (1u << 29u);
        SQUELCHRESETLENGTH = (curr >> 25u) & 0b1111u;
        ENSQUELCHRESET = curr & (1u << 24u);
        SQUELCHRESETCOUNT = (curr >> 16u) & 0b11111u;
        ENTX2RXCOUNT = curr & (1u << 12u);
        TX2RXCOUNT = (curr >> 8u) & 0b1111u;
        ENHSTPULLDOWN = (curr >> 4u) & 0b11u;
        HSTPULLDOWN = (curr >> 2u) & 0b11u;
        DEBUG_INTERFACE_HOLD = curr & (1u << 1u);
        OTGIDPIOLOCK = curr & (1u << 0u);
    }

    /**
     * Set all of DEBUG_TOG's bit fields.
     *
     * (read-write) USB PHY Debug Register
     */
    inline void set_DEBUG_TOG(bool CLKGATE, bool HOST_RESUME_DEBUG,
                              uint8_t SQUELCHRESETLENGTH, bool ENSQUELCHRESET,
                              uint8_t SQUELCHRESETCOUNT, bool ENTX2RXCOUNT,
                              uint8_t TX2RXCOUNT, uint8_t ENHSTPULLDOWN,
                              uint8_t HSTPULLDOWN, bool DEBUG_INTERFACE_HOLD,
                              bool OTGIDPIOLOCK) volatile
    {
        uint32_t curr = DEBUG_TOG;

        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (HOST_RESUME_DEBUG & 0b1u) << 29u;
        curr &= ~(0b1111u << 25u);
        curr |= (SQUELCHRESETLENGTH & 0b1111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENSQUELCHRESET & 0b1u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (SQUELCHRESETCOUNT & 0b11111u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (ENTX2RXCOUNT & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TX2RXCOUNT & 0b1111u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (ENHSTPULLDOWN & 0b11u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (HSTPULLDOWN & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DEBUG_INTERFACE_HOLD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OTGIDPIOLOCK & 0b1u) << 0u;

        DEBUG_TOG = curr;
    }

    /**
     * Get DEBUG0_STATUS's SQUELCH_COUNT field.
     *
     * SQUELCH_COUNT
     */
    inline uint8_t get_DEBUG0_STATUS_SQUELCH_COUNT() volatile
    {
        return (DEBUG0_STATUS >> 26u) & 0b111111u;
    }

    /**
     * Get DEBUG0_STATUS's UTMI_RXERROR_FAIL_COUNT field.
     *
     * UTMI_RXERROR_FAIL_COUNT
     */
    inline uint16_t get_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT() volatile
    {
        return (DEBUG0_STATUS >> 16u) & 0b1111111111u;
    }

    /**
     * Get DEBUG0_STATUS's LOOP_BACK_FAIL_COUNT field.
     *
     * LOOP_BACK_FAIL_COUNT
     */
    inline uint16_t get_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT() volatile
    {
        return (DEBUG0_STATUS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of DEBUG0_STATUS's bit fields.
     *
     * (read-write) UTMI Debug Status Register 0
     */
    inline void get_DEBUG0_STATUS(uint8_t &SQUELCH_COUNT,
                                  uint16_t &UTMI_RXERROR_FAIL_COUNT,
                                  uint16_t &LOOP_BACK_FAIL_COUNT) volatile
    {
        uint32_t curr = DEBUG0_STATUS;

        SQUELCH_COUNT = (curr >> 26u) & 0b111111u;
        UTMI_RXERROR_FAIL_COUNT = (curr >> 16u) & 0b1111111111u;
        LOOP_BACK_FAIL_COUNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get DEBUG1's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline uint8_t get_DEBUG1_USB2_REFBIAS_TST() volatile
    {
        return (DEBUG1 >> 21u) & 0b11u;
    }

    /**
     * Set DEBUG1's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline void set_DEBUG1_USB2_REFBIAS_TST(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1;

        curr &= ~(0b11u << 21u);
        curr |= (value & 0b11u) << 21u;

        DEBUG1 = curr;
    }

    /**
     * Get DEBUG1's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline uint8_t get_DEBUG1_USB2_REFBIAS_VBGADJ() volatile
    {
        return (DEBUG1 >> 18u) & 0b111u;
    }

    /**
     * Set DEBUG1's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline void set_DEBUG1_USB2_REFBIAS_VBGADJ(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DEBUG1 = curr;
    }

    /**
     * Get DEBUG1's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline bool get_DEBUG1_USB2_REFBIAS_LOWPWR() volatile
    {
        return DEBUG1 & (1u << 17u);
    }

    /**
     * Set DEBUG1's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void set_DEBUG1_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1 |= 1u << 17u;
    }

    /**
     * Clear DEBUG1's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void clear_DEBUG1_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1 &= ~(1u << 17u);
    }

    /**
     * Toggle DEBUG1's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void toggle_DEBUG1_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1 ^= 1u << 17u;
    }

    /**
     * Get DEBUG1's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline bool get_DEBUG1_USB2_REFBIAS_PWDVBGUP() volatile
    {
        return DEBUG1 & (1u << 16u);
    }

    /**
     * Set DEBUG1's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void set_DEBUG1_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1 |= 1u << 16u;
    }

    /**
     * Clear DEBUG1's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void clear_DEBUG1_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1 &= ~(1u << 16u);
    }

    /**
     * Toggle DEBUG1's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void toggle_DEBUG1_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1 ^= 1u << 16u;
    }

    /**
     * Get DEBUG1's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline bool get_DEBUG1_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        return DEBUG1 & (1u << 15u);
    }

    /**
     * Set DEBUG1's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void set_DEBUG1_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1 |= 1u << 15u;
    }

    /**
     * Clear DEBUG1's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void clear_DEBUG1_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1 &= ~(1u << 15u);
    }

    /**
     * Toggle DEBUG1's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void toggle_DEBUG1_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1 ^= 1u << 15u;
    }

    /**
     * Get DEBUG1's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline USBPHY1_DEBUG1_ENTAILADJVD get_DEBUG1_ENTAILADJVD() volatile
    {
        return USBPHY1_DEBUG1_ENTAILADJVD((DEBUG1 >> 13u) & 0b11u);
    }

    /**
     * Set DEBUG1's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline void set_DEBUG1_ENTAILADJVD(
        USBPHY1_DEBUG1_ENTAILADJVD value) volatile
    {
        uint32_t curr = DEBUG1;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        DEBUG1 = curr;
    }

    /**
     * Get all of DEBUG1's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void get_DEBUG1(uint8_t &USB2_REFBIAS_TST,
                           uint8_t &USB2_REFBIAS_VBGADJ,
                           bool &USB2_REFBIAS_LOWPWR,
                           bool &USB2_REFBIAS_PWDVBGUP,
                           bool &USB2_REFBIAS_SELFBIASOFF,
                           USBPHY1_DEBUG1_ENTAILADJVD &ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1;

        USB2_REFBIAS_TST = (curr >> 21u) & 0b11u;
        USB2_REFBIAS_VBGADJ = (curr >> 18u) & 0b111u;
        USB2_REFBIAS_LOWPWR = curr & (1u << 17u);
        USB2_REFBIAS_PWDVBGUP = curr & (1u << 16u);
        USB2_REFBIAS_SELFBIASOFF = curr & (1u << 15u);
        ENTAILADJVD = USBPHY1_DEBUG1_ENTAILADJVD((curr >> 13u) & 0b11u);
    }

    /**
     * Set all of DEBUG1's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void set_DEBUG1(uint8_t USB2_REFBIAS_TST,
                           uint8_t USB2_REFBIAS_VBGADJ,
                           bool USB2_REFBIAS_LOWPWR,
                           bool USB2_REFBIAS_PWDVBGUP,
                           bool USB2_REFBIAS_SELFBIASOFF,
                           USBPHY1_DEBUG1_ENTAILADJVD ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1;

        curr &= ~(0b11u << 21u);
        curr |= (USB2_REFBIAS_TST & 0b11u) << 21u;
        curr &= ~(0b111u << 18u);
        curr |= (USB2_REFBIAS_VBGADJ & 0b111u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (USB2_REFBIAS_LOWPWR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USB2_REFBIAS_PWDVBGUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (USB2_REFBIAS_SELFBIASOFF & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(ENTAILADJVD) & 0b11u) << 13u;

        DEBUG1 = curr;
    }

    /**
     * Get DEBUG1_SET's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline uint8_t get_DEBUG1_SET_USB2_REFBIAS_TST() volatile
    {
        return (DEBUG1_SET >> 21u) & 0b11u;
    }

    /**
     * Set DEBUG1_SET's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline void set_DEBUG1_SET_USB2_REFBIAS_TST(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_SET;

        curr &= ~(0b11u << 21u);
        curr |= (value & 0b11u) << 21u;

        DEBUG1_SET = curr;
    }

    /**
     * Get DEBUG1_SET's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline uint8_t get_DEBUG1_SET_USB2_REFBIAS_VBGADJ() volatile
    {
        return (DEBUG1_SET >> 18u) & 0b111u;
    }

    /**
     * Set DEBUG1_SET's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline void set_DEBUG1_SET_USB2_REFBIAS_VBGADJ(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_SET;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DEBUG1_SET = curr;
    }

    /**
     * Get DEBUG1_SET's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline bool get_DEBUG1_SET_USB2_REFBIAS_LOWPWR() volatile
    {
        return DEBUG1_SET & (1u << 17u);
    }

    /**
     * Set DEBUG1_SET's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void set_DEBUG1_SET_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_SET |= 1u << 17u;
    }

    /**
     * Clear DEBUG1_SET's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void clear_DEBUG1_SET_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_SET &= ~(1u << 17u);
    }

    /**
     * Toggle DEBUG1_SET's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void toggle_DEBUG1_SET_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_SET ^= 1u << 17u;
    }

    /**
     * Get DEBUG1_SET's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline bool get_DEBUG1_SET_USB2_REFBIAS_PWDVBGUP() volatile
    {
        return DEBUG1_SET & (1u << 16u);
    }

    /**
     * Set DEBUG1_SET's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void set_DEBUG1_SET_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_SET |= 1u << 16u;
    }

    /**
     * Clear DEBUG1_SET's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void clear_DEBUG1_SET_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_SET &= ~(1u << 16u);
    }

    /**
     * Toggle DEBUG1_SET's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void toggle_DEBUG1_SET_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_SET ^= 1u << 16u;
    }

    /**
     * Get DEBUG1_SET's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline bool get_DEBUG1_SET_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        return DEBUG1_SET & (1u << 15u);
    }

    /**
     * Set DEBUG1_SET's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void set_DEBUG1_SET_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_SET |= 1u << 15u;
    }

    /**
     * Clear DEBUG1_SET's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void clear_DEBUG1_SET_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_SET &= ~(1u << 15u);
    }

    /**
     * Toggle DEBUG1_SET's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void toggle_DEBUG1_SET_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_SET ^= 1u << 15u;
    }

    /**
     * Get DEBUG1_SET's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline uint8_t get_DEBUG1_SET_ENTAILADJVD() volatile
    {
        return (DEBUG1_SET >> 13u) & 0b11u;
    }

    /**
     * Set DEBUG1_SET's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline void set_DEBUG1_SET_ENTAILADJVD(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_SET;

        curr &= ~(0b11u << 13u);
        curr |= (value & 0b11u) << 13u;

        DEBUG1_SET = curr;
    }

    /**
     * Get all of DEBUG1_SET's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void get_DEBUG1_SET(uint8_t &USB2_REFBIAS_TST,
                               uint8_t &USB2_REFBIAS_VBGADJ,
                               bool &USB2_REFBIAS_LOWPWR,
                               bool &USB2_REFBIAS_PWDVBGUP,
                               bool &USB2_REFBIAS_SELFBIASOFF,
                               uint8_t &ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1_SET;

        USB2_REFBIAS_TST = (curr >> 21u) & 0b11u;
        USB2_REFBIAS_VBGADJ = (curr >> 18u) & 0b111u;
        USB2_REFBIAS_LOWPWR = curr & (1u << 17u);
        USB2_REFBIAS_PWDVBGUP = curr & (1u << 16u);
        USB2_REFBIAS_SELFBIASOFF = curr & (1u << 15u);
        ENTAILADJVD = (curr >> 13u) & 0b11u;
    }

    /**
     * Set all of DEBUG1_SET's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void set_DEBUG1_SET(uint8_t USB2_REFBIAS_TST,
                               uint8_t USB2_REFBIAS_VBGADJ,
                               bool USB2_REFBIAS_LOWPWR,
                               bool USB2_REFBIAS_PWDVBGUP,
                               bool USB2_REFBIAS_SELFBIASOFF,
                               uint8_t ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1_SET;

        curr &= ~(0b11u << 21u);
        curr |= (USB2_REFBIAS_TST & 0b11u) << 21u;
        curr &= ~(0b111u << 18u);
        curr |= (USB2_REFBIAS_VBGADJ & 0b111u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (USB2_REFBIAS_LOWPWR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USB2_REFBIAS_PWDVBGUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (USB2_REFBIAS_SELFBIASOFF & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (ENTAILADJVD & 0b11u) << 13u;

        DEBUG1_SET = curr;
    }

    /**
     * Get DEBUG1_CLR's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline uint8_t get_DEBUG1_CLR_USB2_REFBIAS_TST() volatile
    {
        return (DEBUG1_CLR >> 21u) & 0b11u;
    }

    /**
     * Set DEBUG1_CLR's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline void set_DEBUG1_CLR_USB2_REFBIAS_TST(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_CLR;

        curr &= ~(0b11u << 21u);
        curr |= (value & 0b11u) << 21u;

        DEBUG1_CLR = curr;
    }

    /**
     * Get DEBUG1_CLR's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline uint8_t get_DEBUG1_CLR_USB2_REFBIAS_VBGADJ() volatile
    {
        return (DEBUG1_CLR >> 18u) & 0b111u;
    }

    /**
     * Set DEBUG1_CLR's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline void set_DEBUG1_CLR_USB2_REFBIAS_VBGADJ(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_CLR;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DEBUG1_CLR = curr;
    }

    /**
     * Get DEBUG1_CLR's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline bool get_DEBUG1_CLR_USB2_REFBIAS_LOWPWR() volatile
    {
        return DEBUG1_CLR & (1u << 17u);
    }

    /**
     * Set DEBUG1_CLR's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void set_DEBUG1_CLR_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_CLR |= 1u << 17u;
    }

    /**
     * Clear DEBUG1_CLR's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void clear_DEBUG1_CLR_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_CLR &= ~(1u << 17u);
    }

    /**
     * Toggle DEBUG1_CLR's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void toggle_DEBUG1_CLR_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_CLR ^= 1u << 17u;
    }

    /**
     * Get DEBUG1_CLR's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline bool get_DEBUG1_CLR_USB2_REFBIAS_PWDVBGUP() volatile
    {
        return DEBUG1_CLR & (1u << 16u);
    }

    /**
     * Set DEBUG1_CLR's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void set_DEBUG1_CLR_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_CLR |= 1u << 16u;
    }

    /**
     * Clear DEBUG1_CLR's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void clear_DEBUG1_CLR_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_CLR &= ~(1u << 16u);
    }

    /**
     * Toggle DEBUG1_CLR's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void toggle_DEBUG1_CLR_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_CLR ^= 1u << 16u;
    }

    /**
     * Get DEBUG1_CLR's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline bool get_DEBUG1_CLR_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        return DEBUG1_CLR & (1u << 15u);
    }

    /**
     * Set DEBUG1_CLR's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void set_DEBUG1_CLR_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_CLR |= 1u << 15u;
    }

    /**
     * Clear DEBUG1_CLR's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void clear_DEBUG1_CLR_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle DEBUG1_CLR's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void toggle_DEBUG1_CLR_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_CLR ^= 1u << 15u;
    }

    /**
     * Get DEBUG1_CLR's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline uint8_t get_DEBUG1_CLR_ENTAILADJVD() volatile
    {
        return (DEBUG1_CLR >> 13u) & 0b11u;
    }

    /**
     * Set DEBUG1_CLR's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline void set_DEBUG1_CLR_ENTAILADJVD(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_CLR;

        curr &= ~(0b11u << 13u);
        curr |= (value & 0b11u) << 13u;

        DEBUG1_CLR = curr;
    }

    /**
     * Get all of DEBUG1_CLR's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void get_DEBUG1_CLR(uint8_t &USB2_REFBIAS_TST,
                               uint8_t &USB2_REFBIAS_VBGADJ,
                               bool &USB2_REFBIAS_LOWPWR,
                               bool &USB2_REFBIAS_PWDVBGUP,
                               bool &USB2_REFBIAS_SELFBIASOFF,
                               uint8_t &ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1_CLR;

        USB2_REFBIAS_TST = (curr >> 21u) & 0b11u;
        USB2_REFBIAS_VBGADJ = (curr >> 18u) & 0b111u;
        USB2_REFBIAS_LOWPWR = curr & (1u << 17u);
        USB2_REFBIAS_PWDVBGUP = curr & (1u << 16u);
        USB2_REFBIAS_SELFBIASOFF = curr & (1u << 15u);
        ENTAILADJVD = (curr >> 13u) & 0b11u;
    }

    /**
     * Set all of DEBUG1_CLR's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void set_DEBUG1_CLR(uint8_t USB2_REFBIAS_TST,
                               uint8_t USB2_REFBIAS_VBGADJ,
                               bool USB2_REFBIAS_LOWPWR,
                               bool USB2_REFBIAS_PWDVBGUP,
                               bool USB2_REFBIAS_SELFBIASOFF,
                               uint8_t ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1_CLR;

        curr &= ~(0b11u << 21u);
        curr |= (USB2_REFBIAS_TST & 0b11u) << 21u;
        curr &= ~(0b111u << 18u);
        curr |= (USB2_REFBIAS_VBGADJ & 0b111u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (USB2_REFBIAS_LOWPWR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USB2_REFBIAS_PWDVBGUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (USB2_REFBIAS_SELFBIASOFF & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (ENTAILADJVD & 0b11u) << 13u;

        DEBUG1_CLR = curr;
    }

    /**
     * Get DEBUG1_TOG's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline uint8_t get_DEBUG1_TOG_USB2_REFBIAS_TST() volatile
    {
        return (DEBUG1_TOG >> 21u) & 0b11u;
    }

    /**
     * Set DEBUG1_TOG's USB2_REFBIAS_TST field.
     *
     * Bias current control for usb2_phy
     */
    inline void set_DEBUG1_TOG_USB2_REFBIAS_TST(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_TOG;

        curr &= ~(0b11u << 21u);
        curr |= (value & 0b11u) << 21u;

        DEBUG1_TOG = curr;
    }

    /**
     * Get DEBUG1_TOG's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline uint8_t get_DEBUG1_TOG_USB2_REFBIAS_VBGADJ() volatile
    {
        return (DEBUG1_TOG >> 18u) & 0b111u;
    }

    /**
     * Set DEBUG1_TOG's USB2_REFBIAS_VBGADJ field.
     *
     * Adjustment bits on bandgap
     */
    inline void set_DEBUG1_TOG_USB2_REFBIAS_VBGADJ(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_TOG;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        DEBUG1_TOG = curr;
    }

    /**
     * Get DEBUG1_TOG's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline bool get_DEBUG1_TOG_USB2_REFBIAS_LOWPWR() volatile
    {
        return DEBUG1_TOG & (1u << 17u);
    }

    /**
     * Set DEBUG1_TOG's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void set_DEBUG1_TOG_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_TOG |= 1u << 17u;
    }

    /**
     * Clear DEBUG1_TOG's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void clear_DEBUG1_TOG_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_TOG &= ~(1u << 17u);
    }

    /**
     * Toggle DEBUG1_TOG's USB2_REFBIAS_LOWPWR bit.
     *
     * to be added
     */
    inline void toggle_DEBUG1_TOG_USB2_REFBIAS_LOWPWR() volatile
    {
        DEBUG1_TOG ^= 1u << 17u;
    }

    /**
     * Get DEBUG1_TOG's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline bool get_DEBUG1_TOG_USB2_REFBIAS_PWDVBGUP() volatile
    {
        return DEBUG1_TOG & (1u << 16u);
    }

    /**
     * Set DEBUG1_TOG's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void set_DEBUG1_TOG_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_TOG |= 1u << 16u;
    }

    /**
     * Clear DEBUG1_TOG's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void clear_DEBUG1_TOG_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_TOG &= ~(1u << 16u);
    }

    /**
     * Toggle DEBUG1_TOG's USB2_REFBIAS_PWDVBGUP bit.
     *
     * Powers down the bandgap detect logic, will affect vbgup on misc1
     * register.
     */
    inline void toggle_DEBUG1_TOG_USB2_REFBIAS_PWDVBGUP() volatile
    {
        DEBUG1_TOG ^= 1u << 16u;
    }

    /**
     * Get DEBUG1_TOG's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline bool get_DEBUG1_TOG_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        return DEBUG1_TOG & (1u << 15u);
    }

    /**
     * Set DEBUG1_TOG's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void set_DEBUG1_TOG_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_TOG |= 1u << 15u;
    }

    /**
     * Clear DEBUG1_TOG's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void clear_DEBUG1_TOG_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle DEBUG1_TOG's USB2_REFBIAS_SELFBIASOFF bit.
     *
     * Set to 1 to disable self bias, 100 us after power up
     * refbias(usb2_refbias_pwd).This can reduce noise on power.
     */
    inline void toggle_DEBUG1_TOG_USB2_REFBIAS_SELFBIASOFF() volatile
    {
        DEBUG1_TOG ^= 1u << 15u;
    }

    /**
     * Get DEBUG1_TOG's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline uint8_t get_DEBUG1_TOG_ENTAILADJVD() volatile
    {
        return (DEBUG1_TOG >> 13u) & 0b11u;
    }

    /**
     * Set DEBUG1_TOG's ENTAILADJVD field.
     *
     * ENTAILADJVD
     */
    inline void set_DEBUG1_TOG_ENTAILADJVD(uint8_t value) volatile
    {
        uint32_t curr = DEBUG1_TOG;

        curr &= ~(0b11u << 13u);
        curr |= (value & 0b11u) << 13u;

        DEBUG1_TOG = curr;
    }

    /**
     * Get all of DEBUG1_TOG's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void get_DEBUG1_TOG(uint8_t &USB2_REFBIAS_TST,
                               uint8_t &USB2_REFBIAS_VBGADJ,
                               bool &USB2_REFBIAS_LOWPWR,
                               bool &USB2_REFBIAS_PWDVBGUP,
                               bool &USB2_REFBIAS_SELFBIASOFF,
                               uint8_t &ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1_TOG;

        USB2_REFBIAS_TST = (curr >> 21u) & 0b11u;
        USB2_REFBIAS_VBGADJ = (curr >> 18u) & 0b111u;
        USB2_REFBIAS_LOWPWR = curr & (1u << 17u);
        USB2_REFBIAS_PWDVBGUP = curr & (1u << 16u);
        USB2_REFBIAS_SELFBIASOFF = curr & (1u << 15u);
        ENTAILADJVD = (curr >> 13u) & 0b11u;
    }

    /**
     * Set all of DEBUG1_TOG's bit fields.
     *
     * (read-write) UTMI Debug Status Register 1
     */
    inline void set_DEBUG1_TOG(uint8_t USB2_REFBIAS_TST,
                               uint8_t USB2_REFBIAS_VBGADJ,
                               bool USB2_REFBIAS_LOWPWR,
                               bool USB2_REFBIAS_PWDVBGUP,
                               bool USB2_REFBIAS_SELFBIASOFF,
                               uint8_t ENTAILADJVD) volatile
    {
        uint32_t curr = DEBUG1_TOG;

        curr &= ~(0b11u << 21u);
        curr |= (USB2_REFBIAS_TST & 0b11u) << 21u;
        curr &= ~(0b111u << 18u);
        curr |= (USB2_REFBIAS_VBGADJ & 0b111u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (USB2_REFBIAS_LOWPWR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USB2_REFBIAS_PWDVBGUP & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (USB2_REFBIAS_SELFBIASOFF & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (ENTAILADJVD & 0b11u) << 13u;

        DEBUG1_TOG = curr;
    }

    /**
     * Get VERSION's MAJOR field.
     *
     * MAJOR
     */
    inline uint8_t get_VERSION_MAJOR() volatile
    {
        return (VERSION >> 24u) & 0b11111111u;
    }

    /**
     * Get VERSION's MINOR field.
     *
     * MINOR
     */
    inline uint8_t get_VERSION_MINOR() volatile
    {
        return (VERSION >> 16u) & 0b11111111u;
    }

    /**
     * Get VERSION's STEP field.
     *
     * STEP
     */
    inline uint16_t get_VERSION_STEP() volatile
    {
        return (VERSION >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get all of VERSION's bit fields.
     *
     * (read-write) UTMI RTL Version
     */
    inline void get_VERSION(uint8_t &MAJOR, uint8_t &MINOR,
                            uint16_t &STEP) volatile
    {
        uint32_t curr = VERSION;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        STEP = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get PLL_SIC's PLL_LOCK bit.
     *
     * PLL_LOCK
     */
    inline bool get_PLL_SIC_PLL_LOCK() volatile
    {
        return PLL_SIC & (1u << 31u);
    }

    /**
     * Get PLL_SIC's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline USBPHY1_PLL_SIC_PLL_DIV_SEL get_PLL_SIC_PLL_DIV_SEL() volatile
    {
        return USBPHY1_PLL_SIC_PLL_DIV_SEL((PLL_SIC >> 22u) & 0b111u);
    }

    /**
     * Set PLL_SIC's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline void set_PLL_SIC_PLL_DIV_SEL(
        USBPHY1_PLL_SIC_PLL_DIV_SEL value) volatile
    {
        uint32_t curr = PLL_SIC;

        curr &= ~(0b111u << 22u);
        curr |= (std::to_underlying(value) & 0b111u) << 22u;

        PLL_SIC = curr;
    }

    /**
     * Get PLL_SIC's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline bool get_PLL_SIC_PLL_REG_ENABLE() volatile
    {
        return PLL_SIC & (1u << 21u);
    }

    /**
     * Set PLL_SIC's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void set_PLL_SIC_PLL_REG_ENABLE() volatile
    {
        PLL_SIC |= 1u << 21u;
    }

    /**
     * Clear PLL_SIC's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void clear_PLL_SIC_PLL_REG_ENABLE() volatile
    {
        PLL_SIC &= ~(1u << 21u);
    }

    /**
     * Toggle PLL_SIC's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void toggle_PLL_SIC_PLL_REG_ENABLE() volatile
    {
        PLL_SIC ^= 1u << 21u;
    }

    /**
     * Get PLL_SIC's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline bool get_PLL_SIC_REFBIAS_PWD() volatile
    {
        return PLL_SIC & (1u << 20u);
    }

    /**
     * Set PLL_SIC's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void set_PLL_SIC_REFBIAS_PWD() volatile
    {
        PLL_SIC |= 1u << 20u;
    }

    /**
     * Clear PLL_SIC's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void clear_PLL_SIC_REFBIAS_PWD() volatile
    {
        PLL_SIC &= ~(1u << 20u);
    }

    /**
     * Toggle PLL_SIC's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void toggle_PLL_SIC_REFBIAS_PWD() volatile
    {
        PLL_SIC ^= 1u << 20u;
    }

    /**
     * Get PLL_SIC's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline bool get_PLL_SIC_REFBIAS_PWD_SEL() volatile
    {
        return PLL_SIC & (1u << 19u);
    }

    /**
     * Set PLL_SIC's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void set_PLL_SIC_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC |= 1u << 19u;
    }

    /**
     * Clear PLL_SIC's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void clear_PLL_SIC_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC &= ~(1u << 19u);
    }

    /**
     * Toggle PLL_SIC's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void toggle_PLL_SIC_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC ^= 1u << 19u;
    }

    /**
     * Get PLL_SIC's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline bool get_PLL_SIC_PLL_BYPASS() volatile
    {
        return PLL_SIC & (1u << 16u);
    }

    /**
     * Set PLL_SIC's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void set_PLL_SIC_PLL_BYPASS() volatile
    {
        PLL_SIC |= 1u << 16u;
    }

    /**
     * Clear PLL_SIC's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void clear_PLL_SIC_PLL_BYPASS() volatile
    {
        PLL_SIC &= ~(1u << 16u);
    }

    /**
     * Toggle PLL_SIC's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void toggle_PLL_SIC_PLL_BYPASS() volatile
    {
        PLL_SIC ^= 1u << 16u;
    }

    /**
     * Get PLL_SIC's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline bool get_PLL_SIC_PLL_ENABLE() volatile
    {
        return PLL_SIC & (1u << 13u);
    }

    /**
     * Set PLL_SIC's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void set_PLL_SIC_PLL_ENABLE() volatile
    {
        PLL_SIC |= 1u << 13u;
    }

    /**
     * Clear PLL_SIC's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void clear_PLL_SIC_PLL_ENABLE() volatile
    {
        PLL_SIC &= ~(1u << 13u);
    }

    /**
     * Toggle PLL_SIC's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void toggle_PLL_SIC_PLL_ENABLE() volatile
    {
        PLL_SIC ^= 1u << 13u;
    }

    /**
     * Get PLL_SIC's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline bool get_PLL_SIC_PLL_POWER() volatile
    {
        return PLL_SIC & (1u << 12u);
    }

    /**
     * Set PLL_SIC's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void set_PLL_SIC_PLL_POWER() volatile
    {
        PLL_SIC |= 1u << 12u;
    }

    /**
     * Clear PLL_SIC's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void clear_PLL_SIC_PLL_POWER() volatile
    {
        PLL_SIC &= ~(1u << 12u);
    }

    /**
     * Toggle PLL_SIC's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void toggle_PLL_SIC_PLL_POWER() volatile
    {
        PLL_SIC ^= 1u << 12u;
    }

    /**
     * Get PLL_SIC's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline bool get_PLL_SIC_PLL_EN_USB_CLKS() volatile
    {
        return PLL_SIC & (1u << 6u);
    }

    /**
     * Set PLL_SIC's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void set_PLL_SIC_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC |= 1u << 6u;
    }

    /**
     * Clear PLL_SIC's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void clear_PLL_SIC_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC &= ~(1u << 6u);
    }

    /**
     * Toggle PLL_SIC's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void toggle_PLL_SIC_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC ^= 1u << 6u;
    }

    /**
     * Get PLL_SIC's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline uint8_t get_PLL_SIC_PLL_POSTDIV() volatile
    {
        return (PLL_SIC >> 2u) & 0b111u;
    }

    /**
     * Set PLL_SIC's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline void set_PLL_SIC_PLL_POSTDIV(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        PLL_SIC = curr;
    }

    /**
     * Get all of PLL_SIC's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void get_PLL_SIC(bool &PLL_LOCK,
                            USBPHY1_PLL_SIC_PLL_DIV_SEL &PLL_DIV_SEL,
                            bool &PLL_REG_ENABLE, bool &REFBIAS_PWD,
                            bool &REFBIAS_PWD_SEL, bool &PLL_BYPASS,
                            bool &PLL_ENABLE, bool &PLL_POWER,
                            bool &PLL_EN_USB_CLKS,
                            uint8_t &PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC;

        PLL_LOCK = curr & (1u << 31u);
        PLL_DIV_SEL = USBPHY1_PLL_SIC_PLL_DIV_SEL((curr >> 22u) & 0b111u);
        PLL_REG_ENABLE = curr & (1u << 21u);
        REFBIAS_PWD = curr & (1u << 20u);
        REFBIAS_PWD_SEL = curr & (1u << 19u);
        PLL_BYPASS = curr & (1u << 16u);
        PLL_ENABLE = curr & (1u << 13u);
        PLL_POWER = curr & (1u << 12u);
        PLL_EN_USB_CLKS = curr & (1u << 6u);
        PLL_POSTDIV = (curr >> 2u) & 0b111u;
    }

    /**
     * Set all of PLL_SIC's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void set_PLL_SIC(USBPHY1_PLL_SIC_PLL_DIV_SEL PLL_DIV_SEL,
                            bool PLL_REG_ENABLE, bool REFBIAS_PWD,
                            bool REFBIAS_PWD_SEL, bool PLL_BYPASS,
                            bool PLL_ENABLE, bool PLL_POWER,
                            bool PLL_EN_USB_CLKS, uint8_t PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC;

        curr &= ~(0b111u << 22u);
        curr |= (std::to_underlying(PLL_DIV_SEL) & 0b111u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (PLL_REG_ENABLE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (REFBIAS_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (REFBIAS_PWD_SEL & 0b1u) << 19u;
        curr &= ~(0b1u << 16u);
        curr |= (PLL_BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (PLL_ENABLE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PLL_POWER & 0b1u) << 12u;
        curr &= ~(0b1u << 6u);
        curr |= (PLL_EN_USB_CLKS & 0b1u) << 6u;
        curr &= ~(0b111u << 2u);
        curr |= (PLL_POSTDIV & 0b111u) << 2u;

        PLL_SIC = curr;
    }

    /**
     * Get PLL_SIC_SET's PLL_LOCK bit.
     *
     * PLL_LOCK
     */
    inline bool get_PLL_SIC_SET_PLL_LOCK() volatile
    {
        return PLL_SIC_SET & (1u << 31u);
    }

    /**
     * Get PLL_SIC_SET's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline uint8_t get_PLL_SIC_SET_PLL_DIV_SEL() volatile
    {
        return (PLL_SIC_SET >> 22u) & 0b111u;
    }

    /**
     * Set PLL_SIC_SET's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline void set_PLL_SIC_SET_PLL_DIV_SEL(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC_SET;

        curr &= ~(0b111u << 22u);
        curr |= (value & 0b111u) << 22u;

        PLL_SIC_SET = curr;
    }

    /**
     * Get PLL_SIC_SET's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline bool get_PLL_SIC_SET_PLL_REG_ENABLE() volatile
    {
        return PLL_SIC_SET & (1u << 21u);
    }

    /**
     * Set PLL_SIC_SET's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void set_PLL_SIC_SET_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_SET |= 1u << 21u;
    }

    /**
     * Clear PLL_SIC_SET's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void clear_PLL_SIC_SET_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_SET &= ~(1u << 21u);
    }

    /**
     * Toggle PLL_SIC_SET's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void toggle_PLL_SIC_SET_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_SET ^= 1u << 21u;
    }

    /**
     * Get PLL_SIC_SET's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline bool get_PLL_SIC_SET_REFBIAS_PWD() volatile
    {
        return PLL_SIC_SET & (1u << 20u);
    }

    /**
     * Set PLL_SIC_SET's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void set_PLL_SIC_SET_REFBIAS_PWD() volatile
    {
        PLL_SIC_SET |= 1u << 20u;
    }

    /**
     * Clear PLL_SIC_SET's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void clear_PLL_SIC_SET_REFBIAS_PWD() volatile
    {
        PLL_SIC_SET &= ~(1u << 20u);
    }

    /**
     * Toggle PLL_SIC_SET's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void toggle_PLL_SIC_SET_REFBIAS_PWD() volatile
    {
        PLL_SIC_SET ^= 1u << 20u;
    }

    /**
     * Get PLL_SIC_SET's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline bool get_PLL_SIC_SET_REFBIAS_PWD_SEL() volatile
    {
        return PLL_SIC_SET & (1u << 19u);
    }

    /**
     * Set PLL_SIC_SET's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void set_PLL_SIC_SET_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_SET |= 1u << 19u;
    }

    /**
     * Clear PLL_SIC_SET's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void clear_PLL_SIC_SET_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_SET &= ~(1u << 19u);
    }

    /**
     * Toggle PLL_SIC_SET's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void toggle_PLL_SIC_SET_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_SET ^= 1u << 19u;
    }

    /**
     * Get PLL_SIC_SET's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline bool get_PLL_SIC_SET_PLL_BYPASS() volatile
    {
        return PLL_SIC_SET & (1u << 16u);
    }

    /**
     * Set PLL_SIC_SET's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void set_PLL_SIC_SET_PLL_BYPASS() volatile
    {
        PLL_SIC_SET |= 1u << 16u;
    }

    /**
     * Clear PLL_SIC_SET's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void clear_PLL_SIC_SET_PLL_BYPASS() volatile
    {
        PLL_SIC_SET &= ~(1u << 16u);
    }

    /**
     * Toggle PLL_SIC_SET's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void toggle_PLL_SIC_SET_PLL_BYPASS() volatile
    {
        PLL_SIC_SET ^= 1u << 16u;
    }

    /**
     * Get PLL_SIC_SET's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline bool get_PLL_SIC_SET_PLL_ENABLE() volatile
    {
        return PLL_SIC_SET & (1u << 13u);
    }

    /**
     * Set PLL_SIC_SET's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void set_PLL_SIC_SET_PLL_ENABLE() volatile
    {
        PLL_SIC_SET |= 1u << 13u;
    }

    /**
     * Clear PLL_SIC_SET's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void clear_PLL_SIC_SET_PLL_ENABLE() volatile
    {
        PLL_SIC_SET &= ~(1u << 13u);
    }

    /**
     * Toggle PLL_SIC_SET's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void toggle_PLL_SIC_SET_PLL_ENABLE() volatile
    {
        PLL_SIC_SET ^= 1u << 13u;
    }

    /**
     * Get PLL_SIC_SET's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline bool get_PLL_SIC_SET_PLL_POWER() volatile
    {
        return PLL_SIC_SET & (1u << 12u);
    }

    /**
     * Set PLL_SIC_SET's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void set_PLL_SIC_SET_PLL_POWER() volatile
    {
        PLL_SIC_SET |= 1u << 12u;
    }

    /**
     * Clear PLL_SIC_SET's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void clear_PLL_SIC_SET_PLL_POWER() volatile
    {
        PLL_SIC_SET &= ~(1u << 12u);
    }

    /**
     * Toggle PLL_SIC_SET's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void toggle_PLL_SIC_SET_PLL_POWER() volatile
    {
        PLL_SIC_SET ^= 1u << 12u;
    }

    /**
     * Get PLL_SIC_SET's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline bool get_PLL_SIC_SET_PLL_EN_USB_CLKS() volatile
    {
        return PLL_SIC_SET & (1u << 6u);
    }

    /**
     * Set PLL_SIC_SET's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void set_PLL_SIC_SET_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_SET |= 1u << 6u;
    }

    /**
     * Clear PLL_SIC_SET's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void clear_PLL_SIC_SET_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_SET &= ~(1u << 6u);
    }

    /**
     * Toggle PLL_SIC_SET's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void toggle_PLL_SIC_SET_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_SET ^= 1u << 6u;
    }

    /**
     * Get PLL_SIC_SET's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline uint8_t get_PLL_SIC_SET_PLL_POSTDIV() volatile
    {
        return (PLL_SIC_SET >> 2u) & 0b111u;
    }

    /**
     * Set PLL_SIC_SET's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline void set_PLL_SIC_SET_PLL_POSTDIV(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC_SET;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        PLL_SIC_SET = curr;
    }

    /**
     * Get all of PLL_SIC_SET's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void get_PLL_SIC_SET(bool &PLL_LOCK, uint8_t &PLL_DIV_SEL,
                                bool &PLL_REG_ENABLE, bool &REFBIAS_PWD,
                                bool &REFBIAS_PWD_SEL, bool &PLL_BYPASS,
                                bool &PLL_ENABLE, bool &PLL_POWER,
                                bool &PLL_EN_USB_CLKS,
                                uint8_t &PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC_SET;

        PLL_LOCK = curr & (1u << 31u);
        PLL_DIV_SEL = (curr >> 22u) & 0b111u;
        PLL_REG_ENABLE = curr & (1u << 21u);
        REFBIAS_PWD = curr & (1u << 20u);
        REFBIAS_PWD_SEL = curr & (1u << 19u);
        PLL_BYPASS = curr & (1u << 16u);
        PLL_ENABLE = curr & (1u << 13u);
        PLL_POWER = curr & (1u << 12u);
        PLL_EN_USB_CLKS = curr & (1u << 6u);
        PLL_POSTDIV = (curr >> 2u) & 0b111u;
    }

    /**
     * Set all of PLL_SIC_SET's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void set_PLL_SIC_SET(uint8_t PLL_DIV_SEL, bool PLL_REG_ENABLE,
                                bool REFBIAS_PWD, bool REFBIAS_PWD_SEL,
                                bool PLL_BYPASS, bool PLL_ENABLE,
                                bool PLL_POWER, bool PLL_EN_USB_CLKS,
                                uint8_t PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC_SET;

        curr &= ~(0b111u << 22u);
        curr |= (PLL_DIV_SEL & 0b111u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (PLL_REG_ENABLE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (REFBIAS_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (REFBIAS_PWD_SEL & 0b1u) << 19u;
        curr &= ~(0b1u << 16u);
        curr |= (PLL_BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (PLL_ENABLE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PLL_POWER & 0b1u) << 12u;
        curr &= ~(0b1u << 6u);
        curr |= (PLL_EN_USB_CLKS & 0b1u) << 6u;
        curr &= ~(0b111u << 2u);
        curr |= (PLL_POSTDIV & 0b111u) << 2u;

        PLL_SIC_SET = curr;
    }

    /**
     * Get PLL_SIC_CLR's PLL_LOCK bit.
     *
     * PLL_LOCK
     */
    inline bool get_PLL_SIC_CLR_PLL_LOCK() volatile
    {
        return PLL_SIC_CLR & (1u << 31u);
    }

    /**
     * Get PLL_SIC_CLR's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline uint8_t get_PLL_SIC_CLR_PLL_DIV_SEL() volatile
    {
        return (PLL_SIC_CLR >> 22u) & 0b111u;
    }

    /**
     * Set PLL_SIC_CLR's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline void set_PLL_SIC_CLR_PLL_DIV_SEL(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC_CLR;

        curr &= ~(0b111u << 22u);
        curr |= (value & 0b111u) << 22u;

        PLL_SIC_CLR = curr;
    }

    /**
     * Get PLL_SIC_CLR's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline bool get_PLL_SIC_CLR_PLL_REG_ENABLE() volatile
    {
        return PLL_SIC_CLR & (1u << 21u);
    }

    /**
     * Set PLL_SIC_CLR's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void set_PLL_SIC_CLR_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_CLR |= 1u << 21u;
    }

    /**
     * Clear PLL_SIC_CLR's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void clear_PLL_SIC_CLR_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_CLR &= ~(1u << 21u);
    }

    /**
     * Toggle PLL_SIC_CLR's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void toggle_PLL_SIC_CLR_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_CLR ^= 1u << 21u;
    }

    /**
     * Get PLL_SIC_CLR's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline bool get_PLL_SIC_CLR_REFBIAS_PWD() volatile
    {
        return PLL_SIC_CLR & (1u << 20u);
    }

    /**
     * Set PLL_SIC_CLR's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void set_PLL_SIC_CLR_REFBIAS_PWD() volatile
    {
        PLL_SIC_CLR |= 1u << 20u;
    }

    /**
     * Clear PLL_SIC_CLR's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void clear_PLL_SIC_CLR_REFBIAS_PWD() volatile
    {
        PLL_SIC_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle PLL_SIC_CLR's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void toggle_PLL_SIC_CLR_REFBIAS_PWD() volatile
    {
        PLL_SIC_CLR ^= 1u << 20u;
    }

    /**
     * Get PLL_SIC_CLR's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline bool get_PLL_SIC_CLR_REFBIAS_PWD_SEL() volatile
    {
        return PLL_SIC_CLR & (1u << 19u);
    }

    /**
     * Set PLL_SIC_CLR's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void set_PLL_SIC_CLR_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_CLR |= 1u << 19u;
    }

    /**
     * Clear PLL_SIC_CLR's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void clear_PLL_SIC_CLR_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_CLR &= ~(1u << 19u);
    }

    /**
     * Toggle PLL_SIC_CLR's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void toggle_PLL_SIC_CLR_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_CLR ^= 1u << 19u;
    }

    /**
     * Get PLL_SIC_CLR's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline bool get_PLL_SIC_CLR_PLL_BYPASS() volatile
    {
        return PLL_SIC_CLR & (1u << 16u);
    }

    /**
     * Set PLL_SIC_CLR's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void set_PLL_SIC_CLR_PLL_BYPASS() volatile
    {
        PLL_SIC_CLR |= 1u << 16u;
    }

    /**
     * Clear PLL_SIC_CLR's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void clear_PLL_SIC_CLR_PLL_BYPASS() volatile
    {
        PLL_SIC_CLR &= ~(1u << 16u);
    }

    /**
     * Toggle PLL_SIC_CLR's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void toggle_PLL_SIC_CLR_PLL_BYPASS() volatile
    {
        PLL_SIC_CLR ^= 1u << 16u;
    }

    /**
     * Get PLL_SIC_CLR's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline bool get_PLL_SIC_CLR_PLL_ENABLE() volatile
    {
        return PLL_SIC_CLR & (1u << 13u);
    }

    /**
     * Set PLL_SIC_CLR's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void set_PLL_SIC_CLR_PLL_ENABLE() volatile
    {
        PLL_SIC_CLR |= 1u << 13u;
    }

    /**
     * Clear PLL_SIC_CLR's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void clear_PLL_SIC_CLR_PLL_ENABLE() volatile
    {
        PLL_SIC_CLR &= ~(1u << 13u);
    }

    /**
     * Toggle PLL_SIC_CLR's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void toggle_PLL_SIC_CLR_PLL_ENABLE() volatile
    {
        PLL_SIC_CLR ^= 1u << 13u;
    }

    /**
     * Get PLL_SIC_CLR's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline bool get_PLL_SIC_CLR_PLL_POWER() volatile
    {
        return PLL_SIC_CLR & (1u << 12u);
    }

    /**
     * Set PLL_SIC_CLR's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void set_PLL_SIC_CLR_PLL_POWER() volatile
    {
        PLL_SIC_CLR |= 1u << 12u;
    }

    /**
     * Clear PLL_SIC_CLR's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void clear_PLL_SIC_CLR_PLL_POWER() volatile
    {
        PLL_SIC_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle PLL_SIC_CLR's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void toggle_PLL_SIC_CLR_PLL_POWER() volatile
    {
        PLL_SIC_CLR ^= 1u << 12u;
    }

    /**
     * Get PLL_SIC_CLR's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline bool get_PLL_SIC_CLR_PLL_EN_USB_CLKS() volatile
    {
        return PLL_SIC_CLR & (1u << 6u);
    }

    /**
     * Set PLL_SIC_CLR's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void set_PLL_SIC_CLR_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_CLR |= 1u << 6u;
    }

    /**
     * Clear PLL_SIC_CLR's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void clear_PLL_SIC_CLR_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle PLL_SIC_CLR's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void toggle_PLL_SIC_CLR_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_CLR ^= 1u << 6u;
    }

    /**
     * Get PLL_SIC_CLR's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline uint8_t get_PLL_SIC_CLR_PLL_POSTDIV() volatile
    {
        return (PLL_SIC_CLR >> 2u) & 0b111u;
    }

    /**
     * Set PLL_SIC_CLR's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline void set_PLL_SIC_CLR_PLL_POSTDIV(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC_CLR;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        PLL_SIC_CLR = curr;
    }

    /**
     * Get all of PLL_SIC_CLR's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void get_PLL_SIC_CLR(bool &PLL_LOCK, uint8_t &PLL_DIV_SEL,
                                bool &PLL_REG_ENABLE, bool &REFBIAS_PWD,
                                bool &REFBIAS_PWD_SEL, bool &PLL_BYPASS,
                                bool &PLL_ENABLE, bool &PLL_POWER,
                                bool &PLL_EN_USB_CLKS,
                                uint8_t &PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC_CLR;

        PLL_LOCK = curr & (1u << 31u);
        PLL_DIV_SEL = (curr >> 22u) & 0b111u;
        PLL_REG_ENABLE = curr & (1u << 21u);
        REFBIAS_PWD = curr & (1u << 20u);
        REFBIAS_PWD_SEL = curr & (1u << 19u);
        PLL_BYPASS = curr & (1u << 16u);
        PLL_ENABLE = curr & (1u << 13u);
        PLL_POWER = curr & (1u << 12u);
        PLL_EN_USB_CLKS = curr & (1u << 6u);
        PLL_POSTDIV = (curr >> 2u) & 0b111u;
    }

    /**
     * Set all of PLL_SIC_CLR's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void set_PLL_SIC_CLR(uint8_t PLL_DIV_SEL, bool PLL_REG_ENABLE,
                                bool REFBIAS_PWD, bool REFBIAS_PWD_SEL,
                                bool PLL_BYPASS, bool PLL_ENABLE,
                                bool PLL_POWER, bool PLL_EN_USB_CLKS,
                                uint8_t PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC_CLR;

        curr &= ~(0b111u << 22u);
        curr |= (PLL_DIV_SEL & 0b111u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (PLL_REG_ENABLE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (REFBIAS_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (REFBIAS_PWD_SEL & 0b1u) << 19u;
        curr &= ~(0b1u << 16u);
        curr |= (PLL_BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (PLL_ENABLE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PLL_POWER & 0b1u) << 12u;
        curr &= ~(0b1u << 6u);
        curr |= (PLL_EN_USB_CLKS & 0b1u) << 6u;
        curr &= ~(0b111u << 2u);
        curr |= (PLL_POSTDIV & 0b111u) << 2u;

        PLL_SIC_CLR = curr;
    }

    /**
     * Get PLL_SIC_TOG's PLL_LOCK bit.
     *
     * PLL_LOCK
     */
    inline bool get_PLL_SIC_TOG_PLL_LOCK() volatile
    {
        return PLL_SIC_TOG & (1u << 31u);
    }

    /**
     * Get PLL_SIC_TOG's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline uint8_t get_PLL_SIC_TOG_PLL_DIV_SEL() volatile
    {
        return (PLL_SIC_TOG >> 22u) & 0b111u;
    }

    /**
     * Set PLL_SIC_TOG's PLL_DIV_SEL field.
     *
     * PLL_DIV_SEL
     */
    inline void set_PLL_SIC_TOG_PLL_DIV_SEL(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC_TOG;

        curr &= ~(0b111u << 22u);
        curr |= (value & 0b111u) << 22u;

        PLL_SIC_TOG = curr;
    }

    /**
     * Get PLL_SIC_TOG's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline bool get_PLL_SIC_TOG_PLL_REG_ENABLE() volatile
    {
        return PLL_SIC_TOG & (1u << 21u);
    }

    /**
     * Set PLL_SIC_TOG's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void set_PLL_SIC_TOG_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_TOG |= 1u << 21u;
    }

    /**
     * Clear PLL_SIC_TOG's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void clear_PLL_SIC_TOG_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_TOG &= ~(1u << 21u);
    }

    /**
     * Toggle PLL_SIC_TOG's PLL_REG_ENABLE bit.
     *
     * PLL_REG_ENABLE
     */
    inline void toggle_PLL_SIC_TOG_PLL_REG_ENABLE() volatile
    {
        PLL_SIC_TOG ^= 1u << 21u;
    }

    /**
     * Get PLL_SIC_TOG's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline bool get_PLL_SIC_TOG_REFBIAS_PWD() volatile
    {
        return PLL_SIC_TOG & (1u << 20u);
    }

    /**
     * Set PLL_SIC_TOG's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void set_PLL_SIC_TOG_REFBIAS_PWD() volatile
    {
        PLL_SIC_TOG |= 1u << 20u;
    }

    /**
     * Clear PLL_SIC_TOG's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void clear_PLL_SIC_TOG_REFBIAS_PWD() volatile
    {
        PLL_SIC_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle PLL_SIC_TOG's REFBIAS_PWD bit.
     *
     * Power down the reference bias
     */
    inline void toggle_PLL_SIC_TOG_REFBIAS_PWD() volatile
    {
        PLL_SIC_TOG ^= 1u << 20u;
    }

    /**
     * Get PLL_SIC_TOG's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline bool get_PLL_SIC_TOG_REFBIAS_PWD_SEL() volatile
    {
        return PLL_SIC_TOG & (1u << 19u);
    }

    /**
     * Set PLL_SIC_TOG's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void set_PLL_SIC_TOG_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_TOG |= 1u << 19u;
    }

    /**
     * Clear PLL_SIC_TOG's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void clear_PLL_SIC_TOG_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_TOG &= ~(1u << 19u);
    }

    /**
     * Toggle PLL_SIC_TOG's REFBIAS_PWD_SEL bit.
     *
     * REFBIAS_PWD_SEL
     */
    inline void toggle_PLL_SIC_TOG_REFBIAS_PWD_SEL() volatile
    {
        PLL_SIC_TOG ^= 1u << 19u;
    }

    /**
     * Get PLL_SIC_TOG's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline bool get_PLL_SIC_TOG_PLL_BYPASS() volatile
    {
        return PLL_SIC_TOG & (1u << 16u);
    }

    /**
     * Set PLL_SIC_TOG's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void set_PLL_SIC_TOG_PLL_BYPASS() volatile
    {
        PLL_SIC_TOG |= 1u << 16u;
    }

    /**
     * Clear PLL_SIC_TOG's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void clear_PLL_SIC_TOG_PLL_BYPASS() volatile
    {
        PLL_SIC_TOG &= ~(1u << 16u);
    }

    /**
     * Toggle PLL_SIC_TOG's PLL_BYPASS bit.
     *
     * PLL_BYPASS
     */
    inline void toggle_PLL_SIC_TOG_PLL_BYPASS() volatile
    {
        PLL_SIC_TOG ^= 1u << 16u;
    }

    /**
     * Get PLL_SIC_TOG's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline bool get_PLL_SIC_TOG_PLL_ENABLE() volatile
    {
        return PLL_SIC_TOG & (1u << 13u);
    }

    /**
     * Set PLL_SIC_TOG's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void set_PLL_SIC_TOG_PLL_ENABLE() volatile
    {
        PLL_SIC_TOG |= 1u << 13u;
    }

    /**
     * Clear PLL_SIC_TOG's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void clear_PLL_SIC_TOG_PLL_ENABLE() volatile
    {
        PLL_SIC_TOG &= ~(1u << 13u);
    }

    /**
     * Toggle PLL_SIC_TOG's PLL_ENABLE bit.
     *
     * PLL_ENABLE
     */
    inline void toggle_PLL_SIC_TOG_PLL_ENABLE() volatile
    {
        PLL_SIC_TOG ^= 1u << 13u;
    }

    /**
     * Get PLL_SIC_TOG's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline bool get_PLL_SIC_TOG_PLL_POWER() volatile
    {
        return PLL_SIC_TOG & (1u << 12u);
    }

    /**
     * Set PLL_SIC_TOG's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void set_PLL_SIC_TOG_PLL_POWER() volatile
    {
        PLL_SIC_TOG |= 1u << 12u;
    }

    /**
     * Clear PLL_SIC_TOG's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void clear_PLL_SIC_TOG_PLL_POWER() volatile
    {
        PLL_SIC_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle PLL_SIC_TOG's PLL_POWER bit.
     *
     * PLL_POWER
     */
    inline void toggle_PLL_SIC_TOG_PLL_POWER() volatile
    {
        PLL_SIC_TOG ^= 1u << 12u;
    }

    /**
     * Get PLL_SIC_TOG's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline bool get_PLL_SIC_TOG_PLL_EN_USB_CLKS() volatile
    {
        return PLL_SIC_TOG & (1u << 6u);
    }

    /**
     * Set PLL_SIC_TOG's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void set_PLL_SIC_TOG_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_TOG |= 1u << 6u;
    }

    /**
     * Clear PLL_SIC_TOG's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void clear_PLL_SIC_TOG_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle PLL_SIC_TOG's PLL_EN_USB_CLKS bit.
     *
     * PLL_EN_USB_CLKS
     */
    inline void toggle_PLL_SIC_TOG_PLL_EN_USB_CLKS() volatile
    {
        PLL_SIC_TOG ^= 1u << 6u;
    }

    /**
     * Get PLL_SIC_TOG's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline uint8_t get_PLL_SIC_TOG_PLL_POSTDIV() volatile
    {
        return (PLL_SIC_TOG >> 2u) & 0b111u;
    }

    /**
     * Set PLL_SIC_TOG's PLL_POSTDIV field.
     *
     * PLL_POSTDIV
     */
    inline void set_PLL_SIC_TOG_PLL_POSTDIV(uint8_t value) volatile
    {
        uint32_t curr = PLL_SIC_TOG;

        curr &= ~(0b111u << 2u);
        curr |= (value & 0b111u) << 2u;

        PLL_SIC_TOG = curr;
    }

    /**
     * Get all of PLL_SIC_TOG's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void get_PLL_SIC_TOG(bool &PLL_LOCK, uint8_t &PLL_DIV_SEL,
                                bool &PLL_REG_ENABLE, bool &REFBIAS_PWD,
                                bool &REFBIAS_PWD_SEL, bool &PLL_BYPASS,
                                bool &PLL_ENABLE, bool &PLL_POWER,
                                bool &PLL_EN_USB_CLKS,
                                uint8_t &PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC_TOG;

        PLL_LOCK = curr & (1u << 31u);
        PLL_DIV_SEL = (curr >> 22u) & 0b111u;
        PLL_REG_ENABLE = curr & (1u << 21u);
        REFBIAS_PWD = curr & (1u << 20u);
        REFBIAS_PWD_SEL = curr & (1u << 19u);
        PLL_BYPASS = curr & (1u << 16u);
        PLL_ENABLE = curr & (1u << 13u);
        PLL_POWER = curr & (1u << 12u);
        PLL_EN_USB_CLKS = curr & (1u << 6u);
        PLL_POSTDIV = (curr >> 2u) & 0b111u;
    }

    /**
     * Set all of PLL_SIC_TOG's bit fields.
     *
     * (read-write) USB PHY PLL Control/Status Register
     */
    inline void set_PLL_SIC_TOG(uint8_t PLL_DIV_SEL, bool PLL_REG_ENABLE,
                                bool REFBIAS_PWD, bool REFBIAS_PWD_SEL,
                                bool PLL_BYPASS, bool PLL_ENABLE,
                                bool PLL_POWER, bool PLL_EN_USB_CLKS,
                                uint8_t PLL_POSTDIV) volatile
    {
        uint32_t curr = PLL_SIC_TOG;

        curr &= ~(0b111u << 22u);
        curr |= (PLL_DIV_SEL & 0b111u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (PLL_REG_ENABLE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (REFBIAS_PWD & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (REFBIAS_PWD_SEL & 0b1u) << 19u;
        curr &= ~(0b1u << 16u);
        curr |= (PLL_BYPASS & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (PLL_ENABLE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PLL_POWER & 0b1u) << 12u;
        curr &= ~(0b1u << 6u);
        curr |= (PLL_EN_USB_CLKS & 0b1u) << 6u;
        curr &= ~(0b111u << 2u);
        curr |= (PLL_POSTDIV & 0b111u) << 2u;

        PLL_SIC_TOG = curr;
    }

    /**
     * Get USB1_VBUS_DETECT's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline bool get_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR() volatile
    {
        return USB1_VBUS_DETECT & (1u << 31u);
    }

    /**
     * Set USB1_VBUS_DETECT's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void set_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT |= 1u << 31u;
    }

    /**
     * Clear USB1_VBUS_DETECT's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void clear_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 31u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void toggle_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 31u;
    }

    /**
     * Get USB1_VBUS_DETECT's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline bool get_USB1_VBUS_DETECT_DISCHARGE_VBUS() volatile
    {
        return USB1_VBUS_DETECT & (1u << 26u);
    }

    /**
     * Set USB1_VBUS_DETECT's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void set_USB1_VBUS_DETECT_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT |= 1u << 26u;
    }

    /**
     * Clear USB1_VBUS_DETECT's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void clear_USB1_VBUS_DETECT_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 26u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void toggle_USB1_VBUS_DETECT_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 26u;
    }

    /**
     * Get USB1_VBUS_DETECT's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS
    get_USB1_VBUS_DETECT_PWRUP_CMPS() volatile
    {
        return USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS((USB1_VBUS_DETECT >> 20u) &
                                                   0b111u);
    }

    /**
     * Set USB1_VBUS_DETECT's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline void set_USB1_VBUS_DETECT_PWRUP_CMPS(
        USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT;

        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(value) & 0b111u) << 20u;

        USB1_VBUS_DETECT = curr;
    }

    /**
     * Get USB1_VBUS_DETECT's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline bool get_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID() volatile
    {
        return USB1_VBUS_DETECT & (1u << 18u);
    }

    /**
     * Set USB1_VBUS_DETECT's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void set_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT |= 1u << 18u;
    }

    /**
     * Clear USB1_VBUS_DETECT's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void clear_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 18u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void toggle_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 18u;
    }

    /**
     * Get USB1_VBUS_DETECT's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_ID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT & (1u << 12u);
    }

    /**
     * Set USB1_VBUS_DETECT's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT |= 1u << 12u;
    }

    /**
     * Clear USB1_VBUS_DETECT's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 12u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 12u;
    }

    /**
     * Get USB1_VBUS_DETECT's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_ID_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT & (1u << 11u);
    }

    /**
     * Set USB1_VBUS_DETECT's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT |= 1u << 11u;
    }

    /**
     * Clear USB1_VBUS_DETECT's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 11u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 11u;
    }

    /**
     * Get USB1_VBUS_DETECT's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL
    get_USB1_VBUS_DETECT_VBUS_SOURCE_SEL() volatile
    {
        return USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL(
            (USB1_VBUS_DETECT >> 9u) & 0b11u);
    }

    /**
     * Set USB1_VBUS_DETECT's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_VBUS_SOURCE_SEL(
        USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT;

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(value) & 0b11u) << 9u;

        USB1_VBUS_DETECT = curr;
    }

    /**
     * Get USB1_VBUS_DETECT's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline bool get_USB1_VBUS_DETECT_VBUSVALID_SEL() volatile
    {
        return USB1_VBUS_DETECT & (1u << 8u);
    }

    /**
     * Set USB1_VBUS_DETECT's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT |= 1u << 8u;
    }

    /**
     * Clear USB1_VBUS_DETECT's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void clear_USB1_VBUS_DETECT_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 8u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void toggle_USB1_VBUS_DETECT_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 8u;
    }

    /**
     * Get USB1_VBUS_DETECT's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline bool get_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT & (1u << 7u);
    }

    /**
     * Set USB1_VBUS_DETECT's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void set_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT |= 1u << 7u;
    }

    /**
     * Clear USB1_VBUS_DETECT's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void clear_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 7u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void toggle_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 7u;
    }

    /**
     * Get USB1_VBUS_DETECT's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_AVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT & (1u << 6u);
    }

    /**
     * Set USB1_VBUS_DETECT's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT |= 1u << 6u;
    }

    /**
     * Clear USB1_VBUS_DETECT's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 6u;
    }

    /**
     * Get USB1_VBUS_DETECT's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_BVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT & (1u << 5u);
    }

    /**
     * Set USB1_VBUS_DETECT's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT |= 1u << 5u;
    }

    /**
     * Clear USB1_VBUS_DETECT's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 5u;
    }

    /**
     * Get USB1_VBUS_DETECT's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline bool get_USB1_VBUS_DETECT_SESSEND_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT & (1u << 4u);
    }

    /**
     * Set USB1_VBUS_DETECT's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void set_USB1_VBUS_DETECT_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT |= 1u << 4u;
    }

    /**
     * Clear USB1_VBUS_DETECT's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void clear_USB1_VBUS_DETECT_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void toggle_USB1_VBUS_DETECT_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 4u;
    }

    /**
     * Get USB1_VBUS_DETECT's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline bool get_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT & (1u << 3u);
    }

    /**
     * Set USB1_VBUS_DETECT's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void set_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT |= 1u << 3u;
    }

    /**
     * Clear USB1_VBUS_DETECT's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void clear_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_VBUS_DETECT's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void toggle_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT ^= 1u << 3u;
    }

    /**
     * Get USB1_VBUS_DETECT's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH
    get_USB1_VBUS_DETECT_VBUSVALID_THRESH() volatile
    {
        return USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH(
            (USB1_VBUS_DETECT >> 0u) & 0b111u);
    }

    /**
     * Set USB1_VBUS_DETECT's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline void set_USB1_VBUS_DETECT_VBUSVALID_THRESH(
        USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        USB1_VBUS_DETECT = curr;
    }

    /**
     * Get all of USB1_VBUS_DETECT's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void get_USB1_VBUS_DETECT(
        bool &EN_CHARGER_RESISTOR, bool &DISCHARGE_VBUS,
        USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS &PWRUP_CMPS,
        bool &VBUSVALID_TO_SESSVALID, bool &ID_OVERRIDE, bool &ID_OVERRIDE_EN,
        USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL &VBUS_SOURCE_SEL,
        bool &VBUSVALID_SEL, bool &VBUSVALID_OVERRIDE, bool &AVALID_OVERRIDE,
        bool &BVALID_OVERRIDE, bool &SESSEND_OVERRIDE, bool &VBUS_OVERRIDE_EN,
        USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH &VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT;

        EN_CHARGER_RESISTOR = curr & (1u << 31u);
        DISCHARGE_VBUS = curr & (1u << 26u);
        PWRUP_CMPS =
            USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS((curr >> 20u) & 0b111u);
        VBUSVALID_TO_SESSVALID = curr & (1u << 18u);
        ID_OVERRIDE = curr & (1u << 12u);
        ID_OVERRIDE_EN = curr & (1u << 11u);
        VBUS_SOURCE_SEL =
            USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL((curr >> 9u) & 0b11u);
        VBUSVALID_SEL = curr & (1u << 8u);
        VBUSVALID_OVERRIDE = curr & (1u << 7u);
        AVALID_OVERRIDE = curr & (1u << 6u);
        BVALID_OVERRIDE = curr & (1u << 5u);
        SESSEND_OVERRIDE = curr & (1u << 4u);
        VBUS_OVERRIDE_EN = curr & (1u << 3u);
        VBUSVALID_THRESH =
            USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of USB1_VBUS_DETECT's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void set_USB1_VBUS_DETECT(
        bool EN_CHARGER_RESISTOR, bool DISCHARGE_VBUS,
        USBPHY1_USB1_VBUS_DETECT_PWRUP_CMPS PWRUP_CMPS,
        bool VBUSVALID_TO_SESSVALID, bool ID_OVERRIDE, bool ID_OVERRIDE_EN,
        USBPHY1_USB1_VBUS_DETECT_VBUS_SOURCE_SEL VBUS_SOURCE_SEL,
        bool VBUSVALID_SEL, bool VBUSVALID_OVERRIDE, bool AVALID_OVERRIDE,
        bool BVALID_OVERRIDE, bool SESSEND_OVERRIDE, bool VBUS_OVERRIDE_EN,
        USBPHY1_USB1_VBUS_DETECT_VBUSVALID_THRESH VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT;

        curr &= ~(0b1u << 31u);
        curr |= (EN_CHARGER_RESISTOR & 0b1u) << 31u;
        curr &= ~(0b1u << 26u);
        curr |= (DISCHARGE_VBUS & 0b1u) << 26u;
        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(PWRUP_CMPS) & 0b111u) << 20u;
        curr &= ~(0b1u << 18u);
        curr |= (VBUSVALID_TO_SESSVALID & 0b1u) << 18u;
        curr &= ~(0b1u << 12u);
        curr |= (ID_OVERRIDE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ID_OVERRIDE_EN & 0b1u) << 11u;
        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(VBUS_SOURCE_SEL) & 0b11u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VBUSVALID_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (VBUSVALID_OVERRIDE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (AVALID_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BVALID_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SESSEND_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VBUS_OVERRIDE_EN & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(VBUSVALID_THRESH) & 0b111u) << 0u;

        USB1_VBUS_DETECT = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline bool get_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 31u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void set_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 31u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void clear_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 31u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void toggle_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 31u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline bool get_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 26u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void set_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 26u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void clear_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 26u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void toggle_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 26u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline uint8_t get_USB1_VBUS_DETECT_SET_PWRUP_CMPS() volatile
    {
        return (USB1_VBUS_DETECT_SET >> 20u) & 0b111u;
    }

    /**
     * Set USB1_VBUS_DETECT_SET's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline void set_USB1_VBUS_DETECT_SET_PWRUP_CMPS(uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_SET;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        USB1_VBUS_DETECT_SET = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline bool get_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 18u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void set_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 18u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void clear_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 18u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void toggle_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 18u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_SET_ID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 12u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_SET_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 12u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_SET_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 12u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_SET_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 12u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_SET_ID_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 11u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_SET_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 11u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_SET_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 11u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_SET_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 11u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline uint8_t get_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL() volatile
    {
        return (USB1_VBUS_DETECT_SET >> 9u) & 0b11u;
    }

    /**
     * Set USB1_VBUS_DETECT_SET's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL(
        uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_SET;

        curr &= ~(0b11u << 9u);
        curr |= (value & 0b11u) << 9u;

        USB1_VBUS_DETECT_SET = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline bool get_USB1_VBUS_DETECT_SET_VBUSVALID_SEL() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 8u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_SET_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 8u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void clear_USB1_VBUS_DETECT_SET_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 8u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void toggle_USB1_VBUS_DETECT_SET_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 8u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline bool get_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 7u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void set_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 7u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void clear_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 7u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void toggle_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 7u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 6u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 6u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 6u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 5u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 5u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 5u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline bool get_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 4u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void set_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 4u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void clear_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void toggle_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 4u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline bool get_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT_SET & (1u << 3u);
    }

    /**
     * Set USB1_VBUS_DETECT_SET's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void set_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_SET |= 1u << 3u;
    }

    /**
     * Clear USB1_VBUS_DETECT_SET's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void clear_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_SET &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_SET's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void toggle_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_SET ^= 1u << 3u;
    }

    /**
     * Get USB1_VBUS_DETECT_SET's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline uint8_t get_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH() volatile
    {
        return (USB1_VBUS_DETECT_SET >> 0u) & 0b111u;
    }

    /**
     * Set USB1_VBUS_DETECT_SET's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline void set_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH(
        uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_SET;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        USB1_VBUS_DETECT_SET = curr;
    }

    /**
     * Get all of USB1_VBUS_DETECT_SET's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void get_USB1_VBUS_DETECT_SET(
        bool &EN_CHARGER_RESISTOR, bool &DISCHARGE_VBUS, uint8_t &PWRUP_CMPS,
        bool &VBUSVALID_TO_SESSVALID, bool &ID_OVERRIDE, bool &ID_OVERRIDE_EN,
        uint8_t &VBUS_SOURCE_SEL, bool &VBUSVALID_SEL,
        bool &VBUSVALID_OVERRIDE, bool &AVALID_OVERRIDE, bool &BVALID_OVERRIDE,
        bool &SESSEND_OVERRIDE, bool &VBUS_OVERRIDE_EN,
        uint8_t &VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_SET;

        EN_CHARGER_RESISTOR = curr & (1u << 31u);
        DISCHARGE_VBUS = curr & (1u << 26u);
        PWRUP_CMPS = (curr >> 20u) & 0b111u;
        VBUSVALID_TO_SESSVALID = curr & (1u << 18u);
        ID_OVERRIDE = curr & (1u << 12u);
        ID_OVERRIDE_EN = curr & (1u << 11u);
        VBUS_SOURCE_SEL = (curr >> 9u) & 0b11u;
        VBUSVALID_SEL = curr & (1u << 8u);
        VBUSVALID_OVERRIDE = curr & (1u << 7u);
        AVALID_OVERRIDE = curr & (1u << 6u);
        BVALID_OVERRIDE = curr & (1u << 5u);
        SESSEND_OVERRIDE = curr & (1u << 4u);
        VBUS_OVERRIDE_EN = curr & (1u << 3u);
        VBUSVALID_THRESH = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of USB1_VBUS_DETECT_SET's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void set_USB1_VBUS_DETECT_SET(
        bool EN_CHARGER_RESISTOR, bool DISCHARGE_VBUS, uint8_t PWRUP_CMPS,
        bool VBUSVALID_TO_SESSVALID, bool ID_OVERRIDE, bool ID_OVERRIDE_EN,
        uint8_t VBUS_SOURCE_SEL, bool VBUSVALID_SEL, bool VBUSVALID_OVERRIDE,
        bool AVALID_OVERRIDE, bool BVALID_OVERRIDE, bool SESSEND_OVERRIDE,
        bool VBUS_OVERRIDE_EN, uint8_t VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_SET;

        curr &= ~(0b1u << 31u);
        curr |= (EN_CHARGER_RESISTOR & 0b1u) << 31u;
        curr &= ~(0b1u << 26u);
        curr |= (DISCHARGE_VBUS & 0b1u) << 26u;
        curr &= ~(0b111u << 20u);
        curr |= (PWRUP_CMPS & 0b111u) << 20u;
        curr &= ~(0b1u << 18u);
        curr |= (VBUSVALID_TO_SESSVALID & 0b1u) << 18u;
        curr &= ~(0b1u << 12u);
        curr |= (ID_OVERRIDE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ID_OVERRIDE_EN & 0b1u) << 11u;
        curr &= ~(0b11u << 9u);
        curr |= (VBUS_SOURCE_SEL & 0b11u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VBUSVALID_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (VBUSVALID_OVERRIDE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (AVALID_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BVALID_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SESSEND_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VBUS_OVERRIDE_EN & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (VBUSVALID_THRESH & 0b111u) << 0u;

        USB1_VBUS_DETECT_SET = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline bool get_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 31u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void set_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 31u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void clear_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 31u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 31u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline bool get_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 26u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void set_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 26u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void clear_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 26u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 26u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline uint8_t get_USB1_VBUS_DETECT_CLR_PWRUP_CMPS() volatile
    {
        return (USB1_VBUS_DETECT_CLR >> 20u) & 0b111u;
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline void set_USB1_VBUS_DETECT_CLR_PWRUP_CMPS(uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_CLR;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        USB1_VBUS_DETECT_CLR = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline bool get_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 18u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void set_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 18u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void clear_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 18u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 18u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_CLR_ID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 12u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_CLR_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 12u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_CLR_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 12u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_CLR_ID_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 11u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_CLR_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 11u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_CLR_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 11u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline uint8_t get_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL() volatile
    {
        return (USB1_VBUS_DETECT_CLR >> 9u) & 0b11u;
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL(
        uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_CLR;

        curr &= ~(0b11u << 9u);
        curr |= (value & 0b11u) << 9u;

        USB1_VBUS_DETECT_CLR = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline bool get_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 8u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 8u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void clear_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 8u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 8u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline bool get_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 7u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void set_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 7u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void clear_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 7u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 7u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 6u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 6u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 6u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 5u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 5u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 5u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline bool get_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 4u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void set_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 4u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void clear_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 4u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline bool get_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT_CLR & (1u << 3u);
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void set_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_CLR |= 1u << 3u;
    }

    /**
     * Clear USB1_VBUS_DETECT_CLR's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void clear_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_CLR's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void toggle_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_CLR ^= 1u << 3u;
    }

    /**
     * Get USB1_VBUS_DETECT_CLR's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline uint8_t get_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH() volatile
    {
        return (USB1_VBUS_DETECT_CLR >> 0u) & 0b111u;
    }

    /**
     * Set USB1_VBUS_DETECT_CLR's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline void set_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH(
        uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_CLR;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        USB1_VBUS_DETECT_CLR = curr;
    }

    /**
     * Get all of USB1_VBUS_DETECT_CLR's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void get_USB1_VBUS_DETECT_CLR(
        bool &EN_CHARGER_RESISTOR, bool &DISCHARGE_VBUS, uint8_t &PWRUP_CMPS,
        bool &VBUSVALID_TO_SESSVALID, bool &ID_OVERRIDE, bool &ID_OVERRIDE_EN,
        uint8_t &VBUS_SOURCE_SEL, bool &VBUSVALID_SEL,
        bool &VBUSVALID_OVERRIDE, bool &AVALID_OVERRIDE, bool &BVALID_OVERRIDE,
        bool &SESSEND_OVERRIDE, bool &VBUS_OVERRIDE_EN,
        uint8_t &VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_CLR;

        EN_CHARGER_RESISTOR = curr & (1u << 31u);
        DISCHARGE_VBUS = curr & (1u << 26u);
        PWRUP_CMPS = (curr >> 20u) & 0b111u;
        VBUSVALID_TO_SESSVALID = curr & (1u << 18u);
        ID_OVERRIDE = curr & (1u << 12u);
        ID_OVERRIDE_EN = curr & (1u << 11u);
        VBUS_SOURCE_SEL = (curr >> 9u) & 0b11u;
        VBUSVALID_SEL = curr & (1u << 8u);
        VBUSVALID_OVERRIDE = curr & (1u << 7u);
        AVALID_OVERRIDE = curr & (1u << 6u);
        BVALID_OVERRIDE = curr & (1u << 5u);
        SESSEND_OVERRIDE = curr & (1u << 4u);
        VBUS_OVERRIDE_EN = curr & (1u << 3u);
        VBUSVALID_THRESH = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of USB1_VBUS_DETECT_CLR's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void set_USB1_VBUS_DETECT_CLR(
        bool EN_CHARGER_RESISTOR, bool DISCHARGE_VBUS, uint8_t PWRUP_CMPS,
        bool VBUSVALID_TO_SESSVALID, bool ID_OVERRIDE, bool ID_OVERRIDE_EN,
        uint8_t VBUS_SOURCE_SEL, bool VBUSVALID_SEL, bool VBUSVALID_OVERRIDE,
        bool AVALID_OVERRIDE, bool BVALID_OVERRIDE, bool SESSEND_OVERRIDE,
        bool VBUS_OVERRIDE_EN, uint8_t VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_CLR;

        curr &= ~(0b1u << 31u);
        curr |= (EN_CHARGER_RESISTOR & 0b1u) << 31u;
        curr &= ~(0b1u << 26u);
        curr |= (DISCHARGE_VBUS & 0b1u) << 26u;
        curr &= ~(0b111u << 20u);
        curr |= (PWRUP_CMPS & 0b111u) << 20u;
        curr &= ~(0b1u << 18u);
        curr |= (VBUSVALID_TO_SESSVALID & 0b1u) << 18u;
        curr &= ~(0b1u << 12u);
        curr |= (ID_OVERRIDE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ID_OVERRIDE_EN & 0b1u) << 11u;
        curr &= ~(0b11u << 9u);
        curr |= (VBUS_SOURCE_SEL & 0b11u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VBUSVALID_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (VBUSVALID_OVERRIDE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (AVALID_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BVALID_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SESSEND_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VBUS_OVERRIDE_EN & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (VBUSVALID_THRESH & 0b111u) << 0u;

        USB1_VBUS_DETECT_CLR = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline bool get_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 31u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void set_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 31u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void clear_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 31u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's EN_CHARGER_RESISTOR bit.
     *
     * Enables resistors used for an older method of resistive battery charger
     * detection
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 31u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline bool get_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 26u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void set_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 26u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void clear_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 26u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's DISCHARGE_VBUS bit.
     *
     * Controls VBUS discharge resistor
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 26u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline uint8_t get_USB1_VBUS_DETECT_TOG_PWRUP_CMPS() volatile
    {
        return (USB1_VBUS_DETECT_TOG >> 20u) & 0b111u;
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's PWRUP_CMPS field.
     *
     * Enables the VBUS_VALID comparator
     */
    inline void set_USB1_VBUS_DETECT_TOG_PWRUP_CMPS(uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_TOG;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        USB1_VBUS_DETECT_TOG = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline bool get_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 18u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void set_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 18u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void clear_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 18u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's VBUSVALID_TO_SESSVALID bit.
     *
     * Selects the comparator used for VBUS_VALID
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 18u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_TOG_ID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 12u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_TOG_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 12u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_TOG_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's ID_OVERRIDE bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_ID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 12u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline bool get_USB1_VBUS_DETECT_TOG_ID_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 11u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void set_USB1_VBUS_DETECT_TOG_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 11u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void clear_USB1_VBUS_DETECT_TOG_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's ID_OVERRIDE_EN bit.
     *
     * TBA
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_ID_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 11u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline uint8_t get_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL() volatile
    {
        return (USB1_VBUS_DETECT_TOG >> 9u) & 0b11u;
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's VBUS_SOURCE_SEL field.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL(
        uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_TOG;

        curr &= ~(0b11u << 9u);
        curr |= (value & 0b11u) << 9u;

        USB1_VBUS_DETECT_TOG = curr;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline bool get_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 8u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void set_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 8u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void clear_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 8u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's VBUSVALID_SEL bit.
     *
     * Selects the source of the VBUS_VALID signal reported to the USB
     * controller
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 8u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline bool get_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 7u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void set_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 7u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void clear_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 7u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's VBUSVALID_OVERRIDE bit.
     *
     * Override value for VBUS_VALID signal sent to USB controller
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 7u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 6u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 6u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's AVALID_OVERRIDE bit.
     *
     * Override value for A-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 6u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline bool get_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 5u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void set_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 5u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void clear_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's BVALID_OVERRIDE bit.
     *
     * Override value for B-Device Session Valid
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 5u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline bool get_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 4u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void set_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 4u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void clear_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's SESSEND_OVERRIDE bit.
     *
     * Override value for SESSEND
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 4u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline bool get_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN() volatile
    {
        return USB1_VBUS_DETECT_TOG & (1u << 3u);
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void set_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_TOG |= 1u << 3u;
    }

    /**
     * Clear USB1_VBUS_DETECT_TOG's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void clear_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_VBUS_DETECT_TOG's VBUS_OVERRIDE_EN bit.
     *
     * VBUS detect signal override enable
     */
    inline void toggle_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN() volatile
    {
        USB1_VBUS_DETECT_TOG ^= 1u << 3u;
    }

    /**
     * Get USB1_VBUS_DETECT_TOG's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline uint8_t get_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH() volatile
    {
        return (USB1_VBUS_DETECT_TOG >> 0u) & 0b111u;
    }

    /**
     * Set USB1_VBUS_DETECT_TOG's VBUSVALID_THRESH field.
     *
     * VBUSVALID_THRESH
     */
    inline void set_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH(
        uint8_t value) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_TOG;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        USB1_VBUS_DETECT_TOG = curr;
    }

    /**
     * Get all of USB1_VBUS_DETECT_TOG's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void get_USB1_VBUS_DETECT_TOG(
        bool &EN_CHARGER_RESISTOR, bool &DISCHARGE_VBUS, uint8_t &PWRUP_CMPS,
        bool &VBUSVALID_TO_SESSVALID, bool &ID_OVERRIDE, bool &ID_OVERRIDE_EN,
        uint8_t &VBUS_SOURCE_SEL, bool &VBUSVALID_SEL,
        bool &VBUSVALID_OVERRIDE, bool &AVALID_OVERRIDE, bool &BVALID_OVERRIDE,
        bool &SESSEND_OVERRIDE, bool &VBUS_OVERRIDE_EN,
        uint8_t &VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_TOG;

        EN_CHARGER_RESISTOR = curr & (1u << 31u);
        DISCHARGE_VBUS = curr & (1u << 26u);
        PWRUP_CMPS = (curr >> 20u) & 0b111u;
        VBUSVALID_TO_SESSVALID = curr & (1u << 18u);
        ID_OVERRIDE = curr & (1u << 12u);
        ID_OVERRIDE_EN = curr & (1u << 11u);
        VBUS_SOURCE_SEL = (curr >> 9u) & 0b11u;
        VBUSVALID_SEL = curr & (1u << 8u);
        VBUSVALID_OVERRIDE = curr & (1u << 7u);
        AVALID_OVERRIDE = curr & (1u << 6u);
        BVALID_OVERRIDE = curr & (1u << 5u);
        SESSEND_OVERRIDE = curr & (1u << 4u);
        VBUS_OVERRIDE_EN = curr & (1u << 3u);
        VBUSVALID_THRESH = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of USB1_VBUS_DETECT_TOG's bit fields.
     *
     * (read-write) USB PHY VBUS Detect Control Register
     */
    inline void set_USB1_VBUS_DETECT_TOG(
        bool EN_CHARGER_RESISTOR, bool DISCHARGE_VBUS, uint8_t PWRUP_CMPS,
        bool VBUSVALID_TO_SESSVALID, bool ID_OVERRIDE, bool ID_OVERRIDE_EN,
        uint8_t VBUS_SOURCE_SEL, bool VBUSVALID_SEL, bool VBUSVALID_OVERRIDE,
        bool AVALID_OVERRIDE, bool BVALID_OVERRIDE, bool SESSEND_OVERRIDE,
        bool VBUS_OVERRIDE_EN, uint8_t VBUSVALID_THRESH) volatile
    {
        uint32_t curr = USB1_VBUS_DETECT_TOG;

        curr &= ~(0b1u << 31u);
        curr |= (EN_CHARGER_RESISTOR & 0b1u) << 31u;
        curr &= ~(0b1u << 26u);
        curr |= (DISCHARGE_VBUS & 0b1u) << 26u;
        curr &= ~(0b111u << 20u);
        curr |= (PWRUP_CMPS & 0b111u) << 20u;
        curr &= ~(0b1u << 18u);
        curr |= (VBUSVALID_TO_SESSVALID & 0b1u) << 18u;
        curr &= ~(0b1u << 12u);
        curr |= (ID_OVERRIDE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ID_OVERRIDE_EN & 0b1u) << 11u;
        curr &= ~(0b11u << 9u);
        curr |= (VBUS_SOURCE_SEL & 0b11u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VBUSVALID_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (VBUSVALID_OVERRIDE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (AVALID_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BVALID_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SESSEND_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VBUS_OVERRIDE_EN & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (VBUSVALID_THRESH & 0b111u) << 0u;

        USB1_VBUS_DETECT_TOG = curr;
    }

    /**
     * Get USB1_VBUS_DET_STAT's VBUS_VALID_3V bit.
     *
     * VBUS_VALID_3V detector status
     */
    inline bool get_USB1_VBUS_DET_STAT_VBUS_VALID_3V() volatile
    {
        return USB1_VBUS_DET_STAT & (1u << 4u);
    }

    /**
     * Get USB1_VBUS_DET_STAT's VBUS_VALID bit.
     *
     * VBUS voltage status
     */
    inline bool get_USB1_VBUS_DET_STAT_VBUS_VALID() volatile
    {
        return USB1_VBUS_DET_STAT & (1u << 3u);
    }

    /**
     * Get USB1_VBUS_DET_STAT's AVALID bit.
     *
     * A-Device Session Valid status
     */
    inline bool get_USB1_VBUS_DET_STAT_AVALID() volatile
    {
        return USB1_VBUS_DET_STAT & (1u << 2u);
    }

    /**
     * Get USB1_VBUS_DET_STAT's BVALID bit.
     *
     * B-Device Session Valid status
     */
    inline bool get_USB1_VBUS_DET_STAT_BVALID() volatile
    {
        return USB1_VBUS_DET_STAT & (1u << 1u);
    }

    /**
     * Get USB1_VBUS_DET_STAT's SESSEND bit.
     *
     * Session End indicator
     */
    inline bool get_USB1_VBUS_DET_STAT_SESSEND() volatile
    {
        return USB1_VBUS_DET_STAT & (1u << 0u);
    }

    /**
     * Get all of USB1_VBUS_DET_STAT's bit fields.
     *
     * (read-write) USB PHY VBUS Detector Status Register
     */
    inline void get_USB1_VBUS_DET_STAT(bool &VBUS_VALID_3V, bool &VBUS_VALID,
                                       bool &AVALID, bool &BVALID,
                                       bool &SESSEND) volatile
    {
        uint32_t curr = USB1_VBUS_DET_STAT;

        VBUS_VALID_3V = curr & (1u << 4u);
        VBUS_VALID = curr & (1u << 3u);
        AVALID = curr & (1u << 2u);
        BVALID = curr & (1u << 1u);
        SESSEND = curr & (1u << 0u);
    }

    /**
     * Get USB1_CHRG_DETECT's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline bool get_USB1_CHRG_DETECT_BGR_BIAS() volatile
    {
        return USB1_CHRG_DETECT & (1u << 23u);
    }

    /**
     * Set USB1_CHRG_DETECT's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void set_USB1_CHRG_DETECT_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT |= 1u << 23u;
    }

    /**
     * Clear USB1_CHRG_DETECT's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void clear_USB1_CHRG_DETECT_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT &= ~(1u << 23u);
    }

    /**
     * Toggle USB1_CHRG_DETECT's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void toggle_USB1_CHRG_DETECT_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT ^= 1u << 23u;
    }

    /**
     * Get USB1_CHRG_DETECT's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline bool get_USB1_CHRG_DETECT_PULLUP_DP() volatile
    {
        return USB1_CHRG_DETECT & (1u << 2u);
    }

    /**
     * Set USB1_CHRG_DETECT's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void set_USB1_CHRG_DETECT_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT |= 1u << 2u;
    }

    /**
     * Clear USB1_CHRG_DETECT's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void clear_USB1_CHRG_DETECT_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_CHRG_DETECT's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void toggle_USB1_CHRG_DETECT_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT ^= 1u << 2u;
    }

    /**
     * Get all of USB1_CHRG_DETECT's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void get_USB1_CHRG_DETECT(bool &BGR_BIAS, bool &PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT;

        BGR_BIAS = curr & (1u << 23u);
        PULLUP_DP = curr & (1u << 2u);
    }

    /**
     * Set all of USB1_CHRG_DETECT's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void set_USB1_CHRG_DETECT(bool BGR_BIAS, bool PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT;

        curr &= ~(0b1u << 23u);
        curr |= (BGR_BIAS & 0b1u) << 23u;
        curr &= ~(0b1u << 2u);
        curr |= (PULLUP_DP & 0b1u) << 2u;

        USB1_CHRG_DETECT = curr;
    }

    /**
     * Get USB1_CHRG_DETECT_SET's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline bool get_USB1_CHRG_DETECT_SET_BGR_BIAS() volatile
    {
        return USB1_CHRG_DETECT_SET & (1u << 23u);
    }

    /**
     * Set USB1_CHRG_DETECT_SET's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void set_USB1_CHRG_DETECT_SET_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_SET |= 1u << 23u;
    }

    /**
     * Clear USB1_CHRG_DETECT_SET's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void clear_USB1_CHRG_DETECT_SET_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_SET &= ~(1u << 23u);
    }

    /**
     * Toggle USB1_CHRG_DETECT_SET's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void toggle_USB1_CHRG_DETECT_SET_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_SET ^= 1u << 23u;
    }

    /**
     * Get USB1_CHRG_DETECT_SET's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline bool get_USB1_CHRG_DETECT_SET_PULLUP_DP() volatile
    {
        return USB1_CHRG_DETECT_SET & (1u << 2u);
    }

    /**
     * Set USB1_CHRG_DETECT_SET's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void set_USB1_CHRG_DETECT_SET_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_SET |= 1u << 2u;
    }

    /**
     * Clear USB1_CHRG_DETECT_SET's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void clear_USB1_CHRG_DETECT_SET_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_SET &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_CHRG_DETECT_SET's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void toggle_USB1_CHRG_DETECT_SET_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_SET ^= 1u << 2u;
    }

    /**
     * Get all of USB1_CHRG_DETECT_SET's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void get_USB1_CHRG_DETECT_SET(bool &BGR_BIAS,
                                         bool &PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT_SET;

        BGR_BIAS = curr & (1u << 23u);
        PULLUP_DP = curr & (1u << 2u);
    }

    /**
     * Set all of USB1_CHRG_DETECT_SET's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void set_USB1_CHRG_DETECT_SET(bool BGR_BIAS,
                                         bool PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT_SET;

        curr &= ~(0b1u << 23u);
        curr |= (BGR_BIAS & 0b1u) << 23u;
        curr &= ~(0b1u << 2u);
        curr |= (PULLUP_DP & 0b1u) << 2u;

        USB1_CHRG_DETECT_SET = curr;
    }

    /**
     * Get USB1_CHRG_DETECT_CLR's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline bool get_USB1_CHRG_DETECT_CLR_BGR_BIAS() volatile
    {
        return USB1_CHRG_DETECT_CLR & (1u << 23u);
    }

    /**
     * Set USB1_CHRG_DETECT_CLR's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void set_USB1_CHRG_DETECT_CLR_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_CLR |= 1u << 23u;
    }

    /**
     * Clear USB1_CHRG_DETECT_CLR's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void clear_USB1_CHRG_DETECT_CLR_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_CLR &= ~(1u << 23u);
    }

    /**
     * Toggle USB1_CHRG_DETECT_CLR's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void toggle_USB1_CHRG_DETECT_CLR_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_CLR ^= 1u << 23u;
    }

    /**
     * Get USB1_CHRG_DETECT_CLR's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline bool get_USB1_CHRG_DETECT_CLR_PULLUP_DP() volatile
    {
        return USB1_CHRG_DETECT_CLR & (1u << 2u);
    }

    /**
     * Set USB1_CHRG_DETECT_CLR's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void set_USB1_CHRG_DETECT_CLR_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_CLR |= 1u << 2u;
    }

    /**
     * Clear USB1_CHRG_DETECT_CLR's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void clear_USB1_CHRG_DETECT_CLR_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_CHRG_DETECT_CLR's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void toggle_USB1_CHRG_DETECT_CLR_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_CLR ^= 1u << 2u;
    }

    /**
     * Get all of USB1_CHRG_DETECT_CLR's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void get_USB1_CHRG_DETECT_CLR(bool &BGR_BIAS,
                                         bool &PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT_CLR;

        BGR_BIAS = curr & (1u << 23u);
        PULLUP_DP = curr & (1u << 2u);
    }

    /**
     * Set all of USB1_CHRG_DETECT_CLR's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void set_USB1_CHRG_DETECT_CLR(bool BGR_BIAS,
                                         bool PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT_CLR;

        curr &= ~(0b1u << 23u);
        curr |= (BGR_BIAS & 0b1u) << 23u;
        curr &= ~(0b1u << 2u);
        curr |= (PULLUP_DP & 0b1u) << 2u;

        USB1_CHRG_DETECT_CLR = curr;
    }

    /**
     * Get USB1_CHRG_DETECT_TOG's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline bool get_USB1_CHRG_DETECT_TOG_BGR_BIAS() volatile
    {
        return USB1_CHRG_DETECT_TOG & (1u << 23u);
    }

    /**
     * Set USB1_CHRG_DETECT_TOG's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void set_USB1_CHRG_DETECT_TOG_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_TOG |= 1u << 23u;
    }

    /**
     * Clear USB1_CHRG_DETECT_TOG's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void clear_USB1_CHRG_DETECT_TOG_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_TOG &= ~(1u << 23u);
    }

    /**
     * Toggle USB1_CHRG_DETECT_TOG's BGR_BIAS bit.
     *
     * BGR_BIAS
     */
    inline void toggle_USB1_CHRG_DETECT_TOG_BGR_BIAS() volatile
    {
        USB1_CHRG_DETECT_TOG ^= 1u << 23u;
    }

    /**
     * Get USB1_CHRG_DETECT_TOG's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline bool get_USB1_CHRG_DETECT_TOG_PULLUP_DP() volatile
    {
        return USB1_CHRG_DETECT_TOG & (1u << 2u);
    }

    /**
     * Set USB1_CHRG_DETECT_TOG's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void set_USB1_CHRG_DETECT_TOG_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_TOG |= 1u << 2u;
    }

    /**
     * Clear USB1_CHRG_DETECT_TOG's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void clear_USB1_CHRG_DETECT_TOG_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_CHRG_DETECT_TOG's PULLUP_DP bit.
     *
     * PULLUP_DP
     */
    inline void toggle_USB1_CHRG_DETECT_TOG_PULLUP_DP() volatile
    {
        USB1_CHRG_DETECT_TOG ^= 1u << 2u;
    }

    /**
     * Get all of USB1_CHRG_DETECT_TOG's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void get_USB1_CHRG_DETECT_TOG(bool &BGR_BIAS,
                                         bool &PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT_TOG;

        BGR_BIAS = curr & (1u << 23u);
        PULLUP_DP = curr & (1u << 2u);
    }

    /**
     * Set all of USB1_CHRG_DETECT_TOG's bit fields.
     *
     * (read-write) USB PHY Charger Detect Control Register
     */
    inline void set_USB1_CHRG_DETECT_TOG(bool BGR_BIAS,
                                         bool PULLUP_DP) volatile
    {
        uint32_t curr = USB1_CHRG_DETECT_TOG;

        curr &= ~(0b1u << 23u);
        curr |= (BGR_BIAS & 0b1u) << 23u;
        curr &= ~(0b1u << 2u);
        curr |= (PULLUP_DP & 0b1u) << 2u;

        USB1_CHRG_DETECT_TOG = curr;
    }

    /**
     * Get USB1_CHRG_DET_STAT's SECDET_DCP bit.
     *
     * Battery Charging Secondary Detection phase output
     */
    inline bool get_USB1_CHRG_DET_STAT_SECDET_DCP() volatile
    {
        return USB1_CHRG_DET_STAT & (1u << 4u);
    }

    /**
     * Get USB1_CHRG_DET_STAT's DP_STATE bit.
     *
     * DP_STATE
     */
    inline bool get_USB1_CHRG_DET_STAT_DP_STATE() volatile
    {
        return USB1_CHRG_DET_STAT & (1u << 3u);
    }

    /**
     * Get USB1_CHRG_DET_STAT's DN_STATE bit.
     *
     * DN_STATE
     */
    inline bool get_USB1_CHRG_DET_STAT_DN_STATE() volatile
    {
        return USB1_CHRG_DET_STAT & (1u << 2u);
    }

    /**
     * Get USB1_CHRG_DET_STAT's CHRG_DETECTED bit.
     *
     * Battery Charging Primary Detection phase output
     */
    inline bool get_USB1_CHRG_DET_STAT_CHRG_DETECTED() volatile
    {
        return USB1_CHRG_DET_STAT & (1u << 1u);
    }

    /**
     * Get USB1_CHRG_DET_STAT's PLUG_CONTACT bit.
     *
     * Battery Charging Data Contact Detection phase output
     */
    inline bool get_USB1_CHRG_DET_STAT_PLUG_CONTACT() volatile
    {
        return USB1_CHRG_DET_STAT & (1u << 0u);
    }

    /**
     * Get all of USB1_CHRG_DET_STAT's bit fields.
     *
     * (read-write) USB PHY Charger Detect Status Register
     */
    inline void get_USB1_CHRG_DET_STAT(bool &SECDET_DCP, bool &DP_STATE,
                                       bool &DN_STATE, bool &CHRG_DETECTED,
                                       bool &PLUG_CONTACT) volatile
    {
        uint32_t curr = USB1_CHRG_DET_STAT;

        SECDET_DCP = curr & (1u << 4u);
        DP_STATE = curr & (1u << 3u);
        DN_STATE = curr & (1u << 2u);
        CHRG_DETECTED = curr & (1u << 1u);
        PLUG_CONTACT = curr & (1u << 0u);
    }

    /**
     * Get ANACTRL's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline bool get_ANACTRL_DEV_PULLDOWN() volatile
    {
        return ANACTRL & (1u << 10u);
    }

    /**
     * Set ANACTRL's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void set_ANACTRL_DEV_PULLDOWN() volatile
    {
        ANACTRL |= 1u << 10u;
    }

    /**
     * Clear ANACTRL's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void clear_ANACTRL_DEV_PULLDOWN() volatile
    {
        ANACTRL &= ~(1u << 10u);
    }

    /**
     * Toggle ANACTRL's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void toggle_ANACTRL_DEV_PULLDOWN() volatile
    {
        ANACTRL ^= 1u << 10u;
    }

    /**
     * Get ANACTRL_SET's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline bool get_ANACTRL_SET_DEV_PULLDOWN() volatile
    {
        return ANACTRL_SET & (1u << 10u);
    }

    /**
     * Set ANACTRL_SET's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void set_ANACTRL_SET_DEV_PULLDOWN() volatile
    {
        ANACTRL_SET |= 1u << 10u;
    }

    /**
     * Clear ANACTRL_SET's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void clear_ANACTRL_SET_DEV_PULLDOWN() volatile
    {
        ANACTRL_SET &= ~(1u << 10u);
    }

    /**
     * Toggle ANACTRL_SET's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void toggle_ANACTRL_SET_DEV_PULLDOWN() volatile
    {
        ANACTRL_SET ^= 1u << 10u;
    }

    /**
     * Get ANACTRL_CLR's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline bool get_ANACTRL_CLR_DEV_PULLDOWN() volatile
    {
        return ANACTRL_CLR & (1u << 10u);
    }

    /**
     * Set ANACTRL_CLR's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void set_ANACTRL_CLR_DEV_PULLDOWN() volatile
    {
        ANACTRL_CLR |= 1u << 10u;
    }

    /**
     * Clear ANACTRL_CLR's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void clear_ANACTRL_CLR_DEV_PULLDOWN() volatile
    {
        ANACTRL_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle ANACTRL_CLR's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void toggle_ANACTRL_CLR_DEV_PULLDOWN() volatile
    {
        ANACTRL_CLR ^= 1u << 10u;
    }

    /**
     * Get ANACTRL_TOG's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline bool get_ANACTRL_TOG_DEV_PULLDOWN() volatile
    {
        return ANACTRL_TOG & (1u << 10u);
    }

    /**
     * Set ANACTRL_TOG's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void set_ANACTRL_TOG_DEV_PULLDOWN() volatile
    {
        ANACTRL_TOG |= 1u << 10u;
    }

    /**
     * Clear ANACTRL_TOG's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void clear_ANACTRL_TOG_DEV_PULLDOWN() volatile
    {
        ANACTRL_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle ANACTRL_TOG's DEV_PULLDOWN bit.
     *
     * DEV_PULLDOWN
     */
    inline void toggle_ANACTRL_TOG_DEV_PULLDOWN() volatile
    {
        ANACTRL_TOG ^= 1u << 10u;
    }

    /**
     * Get USB1_LOOPBACK's TSTPKT field.
     *
     * TSTPKT
     */
    inline uint8_t get_USB1_LOOPBACK_TSTPKT() volatile
    {
        return (USB1_LOOPBACK >> 16u) & 0b11111111u;
    }

    /**
     * Set USB1_LOOPBACK's TSTPKT field.
     *
     * TSTPKT
     */
    inline void set_USB1_LOOPBACK_TSTPKT(uint8_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        USB1_LOOPBACK = curr;
    }

    /**
     * Get USB1_LOOPBACK's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline bool get_USB1_LOOPBACK_TSTI_HSFS_MODE_EN() volatile
    {
        return USB1_LOOPBACK & (1u << 15u);
    }

    /**
     * Set USB1_LOOPBACK's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void set_USB1_LOOPBACK_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK |= 1u << 15u;
    }

    /**
     * Clear USB1_LOOPBACK's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void clear_USB1_LOOPBACK_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK &= ~(1u << 15u);
    }

    /**
     * Toggle USB1_LOOPBACK's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void toggle_USB1_LOOPBACK_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK ^= 1u << 15u;
    }

    /**
     * Get USB1_LOOPBACK's UTMO_DIG_TST1 bit.
     *
     * UTMO_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_UTMO_DIG_TST1() volatile
    {
        return USB1_LOOPBACK & (1u << 8u);
    }

    /**
     * Get USB1_LOOPBACK's UTMO_DIG_TST0 bit.
     *
     * UTMO_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_UTMO_DIG_TST0() volatile
    {
        return USB1_LOOPBACK & (1u << 7u);
    }

    /**
     * Get USB1_LOOPBACK's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline bool get_USB1_LOOPBACK_TSTI_TX_HIZ() volatile
    {
        return USB1_LOOPBACK & (1u << 6u);
    }

    /**
     * Set USB1_LOOPBACK's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void set_USB1_LOOPBACK_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK |= 1u << 6u;
    }

    /**
     * Clear USB1_LOOPBACK's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void clear_USB1_LOOPBACK_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_LOOPBACK's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void toggle_USB1_LOOPBACK_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK ^= 1u << 6u;
    }

    /**
     * Get USB1_LOOPBACK's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline bool get_USB1_LOOPBACK_TSTI_TX_EN() volatile
    {
        return USB1_LOOPBACK & (1u << 5u);
    }

    /**
     * Set USB1_LOOPBACK's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void set_USB1_LOOPBACK_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK |= 1u << 5u;
    }

    /**
     * Clear USB1_LOOPBACK's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void clear_USB1_LOOPBACK_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_LOOPBACK's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void toggle_USB1_LOOPBACK_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK ^= 1u << 5u;
    }

    /**
     * Get USB1_LOOPBACK's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline bool get_USB1_LOOPBACK_TSTI_TX_LS_MODE() volatile
    {
        return USB1_LOOPBACK & (1u << 4u);
    }

    /**
     * Set USB1_LOOPBACK's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void set_USB1_LOOPBACK_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK |= 1u << 4u;
    }

    /**
     * Clear USB1_LOOPBACK's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void clear_USB1_LOOPBACK_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_LOOPBACK's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void toggle_USB1_LOOPBACK_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK ^= 1u << 4u;
    }

    /**
     * Get USB1_LOOPBACK's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline bool get_USB1_LOOPBACK_TSTI_TX_HS_MODE() volatile
    {
        return USB1_LOOPBACK & (1u << 3u);
    }

    /**
     * Set USB1_LOOPBACK's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void set_USB1_LOOPBACK_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK |= 1u << 3u;
    }

    /**
     * Clear USB1_LOOPBACK's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void clear_USB1_LOOPBACK_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_LOOPBACK's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void toggle_USB1_LOOPBACK_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK ^= 1u << 3u;
    }

    /**
     * Get USB1_LOOPBACK's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_UTMI_DIG_TST1() volatile
    {
        return USB1_LOOPBACK & (1u << 2u);
    }

    /**
     * Set USB1_LOOPBACK's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void set_USB1_LOOPBACK_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK |= 1u << 2u;
    }

    /**
     * Clear USB1_LOOPBACK's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void clear_USB1_LOOPBACK_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_LOOPBACK's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void toggle_USB1_LOOPBACK_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK ^= 1u << 2u;
    }

    /**
     * Get USB1_LOOPBACK's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_UTMI_DIG_TST0() volatile
    {
        return USB1_LOOPBACK & (1u << 1u);
    }

    /**
     * Set USB1_LOOPBACK's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void set_USB1_LOOPBACK_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK |= 1u << 1u;
    }

    /**
     * Clear USB1_LOOPBACK's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void clear_USB1_LOOPBACK_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK &= ~(1u << 1u);
    }

    /**
     * Toggle USB1_LOOPBACK's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void toggle_USB1_LOOPBACK_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK ^= 1u << 1u;
    }

    /**
     * Get USB1_LOOPBACK's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline bool get_USB1_LOOPBACK_UTMI_TESTSTART() volatile
    {
        return USB1_LOOPBACK & (1u << 0u);
    }

    /**
     * Set USB1_LOOPBACK's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void set_USB1_LOOPBACK_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK |= 1u << 0u;
    }

    /**
     * Clear USB1_LOOPBACK's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void clear_USB1_LOOPBACK_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK &= ~(1u << 0u);
    }

    /**
     * Toggle USB1_LOOPBACK's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void toggle_USB1_LOOPBACK_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK ^= 1u << 0u;
    }

    /**
     * Get all of USB1_LOOPBACK's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void get_USB1_LOOPBACK(uint8_t &TSTPKT, bool &TSTI_HSFS_MODE_EN,
                                  bool &UTMO_DIG_TST1, bool &UTMO_DIG_TST0,
                                  bool &TSTI_TX_HIZ, bool &TSTI_TX_EN,
                                  bool &TSTI_TX_LS_MODE, bool &TSTI_TX_HS_MODE,
                                  bool &UTMI_DIG_TST1, bool &UTMI_DIG_TST0,
                                  bool &UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK;

        TSTPKT = (curr >> 16u) & 0b11111111u;
        TSTI_HSFS_MODE_EN = curr & (1u << 15u);
        UTMO_DIG_TST1 = curr & (1u << 8u);
        UTMO_DIG_TST0 = curr & (1u << 7u);
        TSTI_TX_HIZ = curr & (1u << 6u);
        TSTI_TX_EN = curr & (1u << 5u);
        TSTI_TX_LS_MODE = curr & (1u << 4u);
        TSTI_TX_HS_MODE = curr & (1u << 3u);
        UTMI_DIG_TST1 = curr & (1u << 2u);
        UTMI_DIG_TST0 = curr & (1u << 1u);
        UTMI_TESTSTART = curr & (1u << 0u);
    }

    /**
     * Set all of USB1_LOOPBACK's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void set_USB1_LOOPBACK(uint8_t TSTPKT, bool TSTI_HSFS_MODE_EN,
                                  bool TSTI_TX_HIZ, bool TSTI_TX_EN,
                                  bool TSTI_TX_LS_MODE, bool TSTI_TX_HS_MODE,
                                  bool UTMI_DIG_TST1, bool UTMI_DIG_TST0,
                                  bool UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK;

        curr &= ~(0b11111111u << 16u);
        curr |= (TSTPKT & 0b11111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TSTI_HSFS_MODE_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 6u);
        curr |= (TSTI_TX_HIZ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TSTI_TX_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TSTI_TX_LS_MODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TSTI_TX_HS_MODE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (UTMI_DIG_TST1 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (UTMI_DIG_TST0 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (UTMI_TESTSTART & 0b1u) << 0u;

        USB1_LOOPBACK = curr;
    }

    /**
     * Get USB1_LOOPBACK_SET's TSTPKT field.
     *
     * TSTPKT
     */
    inline uint8_t get_USB1_LOOPBACK_SET_TSTPKT() volatile
    {
        return (USB1_LOOPBACK_SET >> 16u) & 0b11111111u;
    }

    /**
     * Set USB1_LOOPBACK_SET's TSTPKT field.
     *
     * TSTPKT
     */
    inline void set_USB1_LOOPBACK_SET_TSTPKT(uint8_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_SET;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        USB1_LOOPBACK_SET = curr;
    }

    /**
     * Get USB1_LOOPBACK_SET's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline bool get_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 15u);
    }

    /**
     * Set USB1_LOOPBACK_SET's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void set_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 15u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void clear_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 15u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void toggle_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 15u;
    }

    /**
     * Get USB1_LOOPBACK_SET's UTMO_DIG_TST1 bit.
     *
     * UTMO_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_SET_UTMO_DIG_TST1() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 8u);
    }

    /**
     * Get USB1_LOOPBACK_SET's UTMO_DIG_TST0 bit.
     *
     * UTMO_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_SET_UTMO_DIG_TST0() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 7u);
    }

    /**
     * Get USB1_LOOPBACK_SET's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline bool get_USB1_LOOPBACK_SET_TSTI_TX_HIZ() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 6u);
    }

    /**
     * Set USB1_LOOPBACK_SET's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void set_USB1_LOOPBACK_SET_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 6u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void clear_USB1_LOOPBACK_SET_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void toggle_USB1_LOOPBACK_SET_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 6u;
    }

    /**
     * Get USB1_LOOPBACK_SET's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline bool get_USB1_LOOPBACK_SET_TSTI_TX_EN() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 5u);
    }

    /**
     * Set USB1_LOOPBACK_SET's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void set_USB1_LOOPBACK_SET_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 5u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void clear_USB1_LOOPBACK_SET_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void toggle_USB1_LOOPBACK_SET_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 5u;
    }

    /**
     * Get USB1_LOOPBACK_SET's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline bool get_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 4u);
    }

    /**
     * Set USB1_LOOPBACK_SET's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void set_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 4u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void clear_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void toggle_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 4u;
    }

    /**
     * Get USB1_LOOPBACK_SET's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline bool get_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 3u);
    }

    /**
     * Set USB1_LOOPBACK_SET's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void set_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 3u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void clear_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void toggle_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 3u;
    }

    /**
     * Get USB1_LOOPBACK_SET's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_SET_UTMI_DIG_TST1() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 2u);
    }

    /**
     * Set USB1_LOOPBACK_SET's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void set_USB1_LOOPBACK_SET_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 2u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void clear_USB1_LOOPBACK_SET_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void toggle_USB1_LOOPBACK_SET_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 2u;
    }

    /**
     * Get USB1_LOOPBACK_SET's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_SET_UTMI_DIG_TST0() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 1u);
    }

    /**
     * Set USB1_LOOPBACK_SET's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void set_USB1_LOOPBACK_SET_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 1u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void clear_USB1_LOOPBACK_SET_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 1u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void toggle_USB1_LOOPBACK_SET_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 1u;
    }

    /**
     * Get USB1_LOOPBACK_SET's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline bool get_USB1_LOOPBACK_SET_UTMI_TESTSTART() volatile
    {
        return USB1_LOOPBACK_SET & (1u << 0u);
    }

    /**
     * Set USB1_LOOPBACK_SET's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void set_USB1_LOOPBACK_SET_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_SET |= 1u << 0u;
    }

    /**
     * Clear USB1_LOOPBACK_SET's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void clear_USB1_LOOPBACK_SET_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_SET &= ~(1u << 0u);
    }

    /**
     * Toggle USB1_LOOPBACK_SET's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void toggle_USB1_LOOPBACK_SET_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_SET ^= 1u << 0u;
    }

    /**
     * Get all of USB1_LOOPBACK_SET's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void get_USB1_LOOPBACK_SET(uint8_t &TSTPKT, bool &TSTI_HSFS_MODE_EN,
                                      bool &UTMO_DIG_TST1, bool &UTMO_DIG_TST0,
                                      bool &TSTI_TX_HIZ, bool &TSTI_TX_EN,
                                      bool &TSTI_TX_LS_MODE,
                                      bool &TSTI_TX_HS_MODE,
                                      bool &UTMI_DIG_TST1, bool &UTMI_DIG_TST0,
                                      bool &UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK_SET;

        TSTPKT = (curr >> 16u) & 0b11111111u;
        TSTI_HSFS_MODE_EN = curr & (1u << 15u);
        UTMO_DIG_TST1 = curr & (1u << 8u);
        UTMO_DIG_TST0 = curr & (1u << 7u);
        TSTI_TX_HIZ = curr & (1u << 6u);
        TSTI_TX_EN = curr & (1u << 5u);
        TSTI_TX_LS_MODE = curr & (1u << 4u);
        TSTI_TX_HS_MODE = curr & (1u << 3u);
        UTMI_DIG_TST1 = curr & (1u << 2u);
        UTMI_DIG_TST0 = curr & (1u << 1u);
        UTMI_TESTSTART = curr & (1u << 0u);
    }

    /**
     * Set all of USB1_LOOPBACK_SET's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void set_USB1_LOOPBACK_SET(uint8_t TSTPKT, bool TSTI_HSFS_MODE_EN,
                                      bool TSTI_TX_HIZ, bool TSTI_TX_EN,
                                      bool TSTI_TX_LS_MODE,
                                      bool TSTI_TX_HS_MODE, bool UTMI_DIG_TST1,
                                      bool UTMI_DIG_TST0,
                                      bool UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK_SET;

        curr &= ~(0b11111111u << 16u);
        curr |= (TSTPKT & 0b11111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TSTI_HSFS_MODE_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 6u);
        curr |= (TSTI_TX_HIZ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TSTI_TX_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TSTI_TX_LS_MODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TSTI_TX_HS_MODE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (UTMI_DIG_TST1 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (UTMI_DIG_TST0 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (UTMI_TESTSTART & 0b1u) << 0u;

        USB1_LOOPBACK_SET = curr;
    }

    /**
     * Get USB1_LOOPBACK_CLR's TSTPKT field.
     *
     * TSTPKT
     */
    inline uint8_t get_USB1_LOOPBACK_CLR_TSTPKT() volatile
    {
        return (USB1_LOOPBACK_CLR >> 16u) & 0b11111111u;
    }

    /**
     * Set USB1_LOOPBACK_CLR's TSTPKT field.
     *
     * TSTPKT
     */
    inline void set_USB1_LOOPBACK_CLR_TSTPKT(uint8_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_CLR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        USB1_LOOPBACK_CLR = curr;
    }

    /**
     * Get USB1_LOOPBACK_CLR's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline bool get_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 15u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void set_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 15u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void clear_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void toggle_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 15u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's UTMO_DIG_TST1 bit.
     *
     * UTMO_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_CLR_UTMO_DIG_TST1() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 8u);
    }

    /**
     * Get USB1_LOOPBACK_CLR's UTMO_DIG_TST0 bit.
     *
     * UTMO_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_CLR_UTMO_DIG_TST0() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 7u);
    }

    /**
     * Get USB1_LOOPBACK_CLR's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline bool get_USB1_LOOPBACK_CLR_TSTI_TX_HIZ() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 6u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void set_USB1_LOOPBACK_CLR_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 6u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void clear_USB1_LOOPBACK_CLR_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void toggle_USB1_LOOPBACK_CLR_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 6u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline bool get_USB1_LOOPBACK_CLR_TSTI_TX_EN() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 5u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void set_USB1_LOOPBACK_CLR_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 5u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void clear_USB1_LOOPBACK_CLR_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void toggle_USB1_LOOPBACK_CLR_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 5u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline bool get_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 4u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void set_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 4u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void clear_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void toggle_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 4u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline bool get_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 3u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void set_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 3u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void clear_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void toggle_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 3u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_CLR_UTMI_DIG_TST1() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 2u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void set_USB1_LOOPBACK_CLR_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 2u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void clear_USB1_LOOPBACK_CLR_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void toggle_USB1_LOOPBACK_CLR_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 2u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_CLR_UTMI_DIG_TST0() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 1u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void set_USB1_LOOPBACK_CLR_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 1u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void clear_USB1_LOOPBACK_CLR_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void toggle_USB1_LOOPBACK_CLR_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 1u;
    }

    /**
     * Get USB1_LOOPBACK_CLR's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline bool get_USB1_LOOPBACK_CLR_UTMI_TESTSTART() volatile
    {
        return USB1_LOOPBACK_CLR & (1u << 0u);
    }

    /**
     * Set USB1_LOOPBACK_CLR's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void set_USB1_LOOPBACK_CLR_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_CLR |= 1u << 0u;
    }

    /**
     * Clear USB1_LOOPBACK_CLR's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void clear_USB1_LOOPBACK_CLR_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle USB1_LOOPBACK_CLR's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void toggle_USB1_LOOPBACK_CLR_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_CLR ^= 1u << 0u;
    }

    /**
     * Get all of USB1_LOOPBACK_CLR's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void get_USB1_LOOPBACK_CLR(uint8_t &TSTPKT, bool &TSTI_HSFS_MODE_EN,
                                      bool &UTMO_DIG_TST1, bool &UTMO_DIG_TST0,
                                      bool &TSTI_TX_HIZ, bool &TSTI_TX_EN,
                                      bool &TSTI_TX_LS_MODE,
                                      bool &TSTI_TX_HS_MODE,
                                      bool &UTMI_DIG_TST1, bool &UTMI_DIG_TST0,
                                      bool &UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK_CLR;

        TSTPKT = (curr >> 16u) & 0b11111111u;
        TSTI_HSFS_MODE_EN = curr & (1u << 15u);
        UTMO_DIG_TST1 = curr & (1u << 8u);
        UTMO_DIG_TST0 = curr & (1u << 7u);
        TSTI_TX_HIZ = curr & (1u << 6u);
        TSTI_TX_EN = curr & (1u << 5u);
        TSTI_TX_LS_MODE = curr & (1u << 4u);
        TSTI_TX_HS_MODE = curr & (1u << 3u);
        UTMI_DIG_TST1 = curr & (1u << 2u);
        UTMI_DIG_TST0 = curr & (1u << 1u);
        UTMI_TESTSTART = curr & (1u << 0u);
    }

    /**
     * Set all of USB1_LOOPBACK_CLR's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void set_USB1_LOOPBACK_CLR(uint8_t TSTPKT, bool TSTI_HSFS_MODE_EN,
                                      bool TSTI_TX_HIZ, bool TSTI_TX_EN,
                                      bool TSTI_TX_LS_MODE,
                                      bool TSTI_TX_HS_MODE, bool UTMI_DIG_TST1,
                                      bool UTMI_DIG_TST0,
                                      bool UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK_CLR;

        curr &= ~(0b11111111u << 16u);
        curr |= (TSTPKT & 0b11111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TSTI_HSFS_MODE_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 6u);
        curr |= (TSTI_TX_HIZ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TSTI_TX_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TSTI_TX_LS_MODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TSTI_TX_HS_MODE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (UTMI_DIG_TST1 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (UTMI_DIG_TST0 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (UTMI_TESTSTART & 0b1u) << 0u;

        USB1_LOOPBACK_CLR = curr;
    }

    /**
     * Get USB1_LOOPBACK_TOG's TSTPKT field.
     *
     * TSTPKT
     */
    inline uint8_t get_USB1_LOOPBACK_TOG_TSTPKT() volatile
    {
        return (USB1_LOOPBACK_TOG >> 16u) & 0b11111111u;
    }

    /**
     * Set USB1_LOOPBACK_TOG's TSTPKT field.
     *
     * TSTPKT
     */
    inline void set_USB1_LOOPBACK_TOG_TSTPKT(uint8_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_TOG;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        USB1_LOOPBACK_TOG = curr;
    }

    /**
     * Get USB1_LOOPBACK_TOG's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline bool get_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 15u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void set_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 15u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void clear_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's TSTI_HSFS_MODE_EN bit.
     *
     * TSTI_HSFS_MODE_EN
     */
    inline void toggle_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 15u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's UTMO_DIG_TST1 bit.
     *
     * UTMO_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_TOG_UTMO_DIG_TST1() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 8u);
    }

    /**
     * Get USB1_LOOPBACK_TOG's UTMO_DIG_TST0 bit.
     *
     * UTMO_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_TOG_UTMO_DIG_TST0() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 7u);
    }

    /**
     * Get USB1_LOOPBACK_TOG's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline bool get_USB1_LOOPBACK_TOG_TSTI_TX_HIZ() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 6u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void set_USB1_LOOPBACK_TOG_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 6u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void clear_USB1_LOOPBACK_TOG_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's TSTI_TX_HIZ bit.
     *
     * TSTI_TX_HIZ
     */
    inline void toggle_USB1_LOOPBACK_TOG_TSTI_TX_HIZ() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 6u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline bool get_USB1_LOOPBACK_TOG_TSTI_TX_EN() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 5u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void set_USB1_LOOPBACK_TOG_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 5u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void clear_USB1_LOOPBACK_TOG_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 5u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's TSTI_TX_EN bit.
     *
     * TSTI_TX_EN
     */
    inline void toggle_USB1_LOOPBACK_TOG_TSTI_TX_EN() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 5u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline bool get_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 4u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void set_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 4u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void clear_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's TSTI_TX_LS_MODE bit.
     *
     * TSTI_TX_LS_MODE
     */
    inline void toggle_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 4u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline bool get_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 3u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void set_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 3u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void clear_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's TSTI_TX_HS_MODE bit.
     *
     * TSTI_TX_HS_MODE
     */
    inline void toggle_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 3u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline bool get_USB1_LOOPBACK_TOG_UTMI_DIG_TST1() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 2u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void set_USB1_LOOPBACK_TOG_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 2u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void clear_USB1_LOOPBACK_TOG_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's UTMI_DIG_TST1 bit.
     *
     * UTMI_DIG_TST1
     */
    inline void toggle_USB1_LOOPBACK_TOG_UTMI_DIG_TST1() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 2u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline bool get_USB1_LOOPBACK_TOG_UTMI_DIG_TST0() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 1u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void set_USB1_LOOPBACK_TOG_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 1u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void clear_USB1_LOOPBACK_TOG_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's UTMI_DIG_TST0 bit.
     *
     * UTMI_DIG_TST0
     */
    inline void toggle_USB1_LOOPBACK_TOG_UTMI_DIG_TST0() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 1u;
    }

    /**
     * Get USB1_LOOPBACK_TOG's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline bool get_USB1_LOOPBACK_TOG_UTMI_TESTSTART() volatile
    {
        return USB1_LOOPBACK_TOG & (1u << 0u);
    }

    /**
     * Set USB1_LOOPBACK_TOG's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void set_USB1_LOOPBACK_TOG_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_TOG |= 1u << 0u;
    }

    /**
     * Clear USB1_LOOPBACK_TOG's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void clear_USB1_LOOPBACK_TOG_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle USB1_LOOPBACK_TOG's UTMI_TESTSTART bit.
     *
     * UTMI_TESTSTART
     */
    inline void toggle_USB1_LOOPBACK_TOG_UTMI_TESTSTART() volatile
    {
        USB1_LOOPBACK_TOG ^= 1u << 0u;
    }

    /**
     * Get all of USB1_LOOPBACK_TOG's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void get_USB1_LOOPBACK_TOG(uint8_t &TSTPKT, bool &TSTI_HSFS_MODE_EN,
                                      bool &UTMO_DIG_TST1, bool &UTMO_DIG_TST0,
                                      bool &TSTI_TX_HIZ, bool &TSTI_TX_EN,
                                      bool &TSTI_TX_LS_MODE,
                                      bool &TSTI_TX_HS_MODE,
                                      bool &UTMI_DIG_TST1, bool &UTMI_DIG_TST0,
                                      bool &UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK_TOG;

        TSTPKT = (curr >> 16u) & 0b11111111u;
        TSTI_HSFS_MODE_EN = curr & (1u << 15u);
        UTMO_DIG_TST1 = curr & (1u << 8u);
        UTMO_DIG_TST0 = curr & (1u << 7u);
        TSTI_TX_HIZ = curr & (1u << 6u);
        TSTI_TX_EN = curr & (1u << 5u);
        TSTI_TX_LS_MODE = curr & (1u << 4u);
        TSTI_TX_HS_MODE = curr & (1u << 3u);
        UTMI_DIG_TST1 = curr & (1u << 2u);
        UTMI_DIG_TST0 = curr & (1u << 1u);
        UTMI_TESTSTART = curr & (1u << 0u);
    }

    /**
     * Set all of USB1_LOOPBACK_TOG's bit fields.
     *
     * (read-write) USB PHY Loopback Control/Status Register
     */
    inline void set_USB1_LOOPBACK_TOG(uint8_t TSTPKT, bool TSTI_HSFS_MODE_EN,
                                      bool TSTI_TX_HIZ, bool TSTI_TX_EN,
                                      bool TSTI_TX_LS_MODE,
                                      bool TSTI_TX_HS_MODE, bool UTMI_DIG_TST1,
                                      bool UTMI_DIG_TST0,
                                      bool UTMI_TESTSTART) volatile
    {
        uint32_t curr = USB1_LOOPBACK_TOG;

        curr &= ~(0b11111111u << 16u);
        curr |= (TSTPKT & 0b11111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TSTI_HSFS_MODE_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 6u);
        curr |= (TSTI_TX_HIZ & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TSTI_TX_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TSTI_TX_LS_MODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TSTI_TX_HS_MODE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (UTMI_DIG_TST1 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (UTMI_DIG_TST0 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (UTMI_TESTSTART & 0b1u) << 0u;

        USB1_LOOPBACK_TOG = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_TSTI_FS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_TSTI_FS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        USB1_LOOPBACK_HSFSCNT = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_TSTI_HS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_TSTI_HS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT = curr;
    }

    /**
     * Get all of USB1_LOOPBACK_HSFSCNT's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void get_USB1_LOOPBACK_HSFSCNT(uint16_t &TSTI_FS_NUMBER,
                                          uint16_t &TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT;

        TSTI_FS_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        TSTI_HS_NUMBER = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of USB1_LOOPBACK_HSFSCNT's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void set_USB1_LOOPBACK_HSFSCNT(uint16_t TSTI_FS_NUMBER,
                                          uint16_t TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TSTI_FS_NUMBER & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (TSTI_HS_NUMBER & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT_SET's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_SET_TSTI_FS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT_SET >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT_SET's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_SET_TSTI_FS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        USB1_LOOPBACK_HSFSCNT_SET = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT_SET's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_SET_TSTI_HS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT_SET >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT_SET's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_SET_TSTI_HS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_SET;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT_SET = curr;
    }

    /**
     * Get all of USB1_LOOPBACK_HSFSCNT_SET's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void get_USB1_LOOPBACK_HSFSCNT_SET(
        uint16_t &TSTI_FS_NUMBER, uint16_t &TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_SET;

        TSTI_FS_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        TSTI_HS_NUMBER = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of USB1_LOOPBACK_HSFSCNT_SET's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_SET(uint16_t TSTI_FS_NUMBER,
                                              uint16_t TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TSTI_FS_NUMBER & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (TSTI_HS_NUMBER & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT_SET = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT_CLR's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_FS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT_CLR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT_CLR's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_FS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        USB1_LOOPBACK_HSFSCNT_CLR = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT_CLR's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_HS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT_CLR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT_CLR's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_HS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_CLR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT_CLR = curr;
    }

    /**
     * Get all of USB1_LOOPBACK_HSFSCNT_CLR's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void get_USB1_LOOPBACK_HSFSCNT_CLR(
        uint16_t &TSTI_FS_NUMBER, uint16_t &TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_CLR;

        TSTI_FS_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        TSTI_HS_NUMBER = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of USB1_LOOPBACK_HSFSCNT_CLR's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_CLR(uint16_t TSTI_FS_NUMBER,
                                              uint16_t TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TSTI_FS_NUMBER & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (TSTI_HS_NUMBER & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT_CLR = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT_TOG's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_FS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT_TOG >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT_TOG's TSTI_FS_NUMBER field.
     *
     * TSTI_FS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_FS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        USB1_LOOPBACK_HSFSCNT_TOG = curr;
    }

    /**
     * Get USB1_LOOPBACK_HSFSCNT_TOG's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline uint16_t get_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_HS_NUMBER() volatile
    {
        return (USB1_LOOPBACK_HSFSCNT_TOG >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set USB1_LOOPBACK_HSFSCNT_TOG's TSTI_HS_NUMBER field.
     *
     * TSTI_HS_NUMBER
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_HS_NUMBER(
        uint16_t value) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_TOG;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT_TOG = curr;
    }

    /**
     * Get all of USB1_LOOPBACK_HSFSCNT_TOG's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void get_USB1_LOOPBACK_HSFSCNT_TOG(
        uint16_t &TSTI_FS_NUMBER, uint16_t &TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_TOG;

        TSTI_FS_NUMBER = (curr >> 16u) & 0b1111111111111111u;
        TSTI_HS_NUMBER = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of USB1_LOOPBACK_HSFSCNT_TOG's bit fields.
     *
     * (read-write) USB PHY Loopback Packet Number Select Register
     */
    inline void set_USB1_LOOPBACK_HSFSCNT_TOG(uint16_t TSTI_FS_NUMBER,
                                              uint16_t TSTI_HS_NUMBER) volatile
    {
        uint32_t curr = USB1_LOOPBACK_HSFSCNT_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TSTI_FS_NUMBER & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (TSTI_HS_NUMBER & 0b1111111111111111u) << 0u;

        USB1_LOOPBACK_HSFSCNT_TOG = curr;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_USBPHY_TX_CAL45DN field.
     *
     * TRIM_USBPHY_TX_CAL45DN
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DN() volatile
    {
        return (TRIM_OVERRIDE_EN >> 28u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_USBPHY_TX_CAL45DP field.
     *
     * TRIM_USBPHY_TX_CAL45DP
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DP() volatile
    {
        return (TRIM_OVERRIDE_EN >> 24u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_USBPHY_TX_D_CAL field.
     *
     * TRIM_USBPHY_TX_D_CAL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_D_CAL() volatile
    {
        return (TRIM_OVERRIDE_EN >> 20u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
     *
     * TRIM_USB_REG_ENV_TAIL_ADJ_VD
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_USB_REG_ENV_TAIL_ADJ_VD() volatile
    {
        return (TRIM_OVERRIDE_EN >> 18u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_PLL_CTRL0_DIV_SEL field.
     *
     * TRIM_PLL_CTRL0_DIV_SEL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_PLL_CTRL0_DIV_SEL() volatile
    {
        return (TRIM_OVERRIDE_EN >> 15u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_USB2_REFBIAS_TST field.
     *
     * TRIM_USB2_REFBIAS_TST
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_USB2_REFBIAS_TST() volatile
    {
        return (TRIM_OVERRIDE_EN >> 13u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_USB2_REFBIAS_VBGADJ field.
     *
     * TRIM_USB2_REFBIAS_VBGADJ
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TRIM_USB2_REFBIAS_VBGADJ() volatile
    {
        return (TRIM_OVERRIDE_EN >> 10u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 6u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 6u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 6u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void toggle_TRIM_OVERRIDE_EN_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 6u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 5u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 5u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 5u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void toggle_TRIM_OVERRIDE_EN_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 5u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 4u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 4u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 4u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 4u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 3u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 3u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 3u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 3u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 2u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 2u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 2u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 2u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 1u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 1u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 1u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 1u;
    }

    /**
     * Get TRIM_OVERRIDE_EN's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN & (1u << 0u);
    }

    /**
     * Set TRIM_OVERRIDE_EN's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN |= 1u << 0u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN &= ~(1u << 0u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN ^= 1u << 0u;
    }

    /**
     * Get all of TRIM_OVERRIDE_EN's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void get_TRIM_OVERRIDE_EN(
        uint8_t &TRIM_USBPHY_TX_CAL45DN, uint8_t &TRIM_USBPHY_TX_CAL45DP,
        uint8_t &TRIM_USBPHY_TX_D_CAL, uint8_t &TRIM_USB_REG_ENV_TAIL_ADJ_VD,
        uint8_t &TRIM_PLL_CTRL0_DIV_SEL, uint8_t &TRIM_USB2_REFBIAS_TST,
        uint8_t &TRIM_USB2_REFBIAS_VBGADJ, bool &TRIM_REFBIAS_TST_OVERRIDE,
        bool &TRIM_REFBIAS_VBGADJ_OVERRIDE, bool &TRIM_TX_CAL45DN_OVERRIDE,
        bool &TRIM_TX_CAL45DP_OVERRIDE, bool &TRIM_TX_D_CAL_OVERRIDE,
        bool &TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
        bool &TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN;

        TRIM_USBPHY_TX_CAL45DN = (curr >> 28u) & 0b1111u;
        TRIM_USBPHY_TX_CAL45DP = (curr >> 24u) & 0b1111u;
        TRIM_USBPHY_TX_D_CAL = (curr >> 20u) & 0b1111u;
        TRIM_USB_REG_ENV_TAIL_ADJ_VD = (curr >> 18u) & 0b11u;
        TRIM_PLL_CTRL0_DIV_SEL = (curr >> 15u) & 0b111u;
        TRIM_USB2_REFBIAS_TST = (curr >> 13u) & 0b11u;
        TRIM_USB2_REFBIAS_VBGADJ = (curr >> 10u) & 0b111u;
        TRIM_REFBIAS_TST_OVERRIDE = curr & (1u << 6u);
        TRIM_REFBIAS_VBGADJ_OVERRIDE = curr & (1u << 5u);
        TRIM_TX_CAL45DN_OVERRIDE = curr & (1u << 4u);
        TRIM_TX_CAL45DP_OVERRIDE = curr & (1u << 3u);
        TRIM_TX_D_CAL_OVERRIDE = curr & (1u << 2u);
        TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = curr & (1u << 1u);
        TRIM_DIV_SEL_OVERRIDE = curr & (1u << 0u);
    }

    /**
     * Set all of TRIM_OVERRIDE_EN's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void set_TRIM_OVERRIDE_EN(bool TRIM_REFBIAS_TST_OVERRIDE,
                                     bool TRIM_REFBIAS_VBGADJ_OVERRIDE,
                                     bool TRIM_TX_CAL45DN_OVERRIDE,
                                     bool TRIM_TX_CAL45DP_OVERRIDE,
                                     bool TRIM_TX_D_CAL_OVERRIDE,
                                     bool TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
                                     bool TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN;

        curr &= ~(0b1u << 6u);
        curr |= (TRIM_REFBIAS_TST_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TRIM_REFBIAS_VBGADJ_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TRIM_TX_CAL45DN_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TRIM_TX_CAL45DP_OVERRIDE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TRIM_TX_D_CAL_OVERRIDE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TRIM_ENV_TAIL_ADJ_VD_OVERRIDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TRIM_DIV_SEL_OVERRIDE & 0b1u) << 0u;

        TRIM_OVERRIDE_EN = curr;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_USBPHY_TX_CAL45DN field.
     *
     * TRIM_USBPHY_TX_CAL45DN
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DN() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 28u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_USBPHY_TX_CAL45DP field.
     *
     * TRIM_USBPHY_TX_CAL45DP
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DP() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 24u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_USBPHY_TX_D_CAL field.
     *
     * TRIM_USBPHY_TX_D_CAL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_D_CAL() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 20u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
     *
     * TRIM_USB_REG_ENV_TAIL_ADJ_VD
     */
    inline uint8_t
    get_TRIM_OVERRIDE_EN_SET_TRIM_USB_REG_ENV_TAIL_ADJ_VD() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 18u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_PLL_CTRL0_DIV_SEL field.
     *
     * TRIM_PLL_CTRL0_DIV_SEL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_SET_TRIM_PLL_CTRL0_DIV_SEL() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 15u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_USB2_REFBIAS_TST field.
     *
     * TRIM_USB2_REFBIAS_TST
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_SET_TRIM_USB2_REFBIAS_TST() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 13u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_USB2_REFBIAS_VBGADJ field.
     *
     * TRIM_USB2_REFBIAS_VBGADJ
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_SET_TRIM_USB2_REFBIAS_VBGADJ() volatile
    {
        return (TRIM_OVERRIDE_EN_SET >> 10u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline bool get_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 6u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void set_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 6u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void clear_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 6u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 6u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline bool
    get_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 5u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    set_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 5u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    clear_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 5u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_SET_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 5u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 4u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 4u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 4u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 4u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 3u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 3u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 3u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 3u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 2u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 2u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 2u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 2u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline bool
    get_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 1u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    set_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 1u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    clear_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 1u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 1u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_SET's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_SET & (1u << 0u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_SET's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET |= 1u << 0u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_SET's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET &= ~(1u << 0u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_SET's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_SET ^= 1u << 0u;
    }

    /**
     * Get all of TRIM_OVERRIDE_EN_SET's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void get_TRIM_OVERRIDE_EN_SET(
        uint8_t &TRIM_USBPHY_TX_CAL45DN, uint8_t &TRIM_USBPHY_TX_CAL45DP,
        uint8_t &TRIM_USBPHY_TX_D_CAL, uint8_t &TRIM_USB_REG_ENV_TAIL_ADJ_VD,
        uint8_t &TRIM_PLL_CTRL0_DIV_SEL, uint8_t &TRIM_USB2_REFBIAS_TST,
        uint8_t &TRIM_USB2_REFBIAS_VBGADJ, bool &TRIM_REFBIAS_TST_OVERRIDE,
        bool &TRIM_REFBIAS_VBGADJ_OVERRIDE, bool &TRIM_TX_CAL45DN_OVERRIDE,
        bool &TRIM_TX_CAL45DP_OVERRIDE, bool &TRIM_TX_D_CAL_OVERRIDE,
        bool &TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
        bool &TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN_SET;

        TRIM_USBPHY_TX_CAL45DN = (curr >> 28u) & 0b1111u;
        TRIM_USBPHY_TX_CAL45DP = (curr >> 24u) & 0b1111u;
        TRIM_USBPHY_TX_D_CAL = (curr >> 20u) & 0b1111u;
        TRIM_USB_REG_ENV_TAIL_ADJ_VD = (curr >> 18u) & 0b11u;
        TRIM_PLL_CTRL0_DIV_SEL = (curr >> 15u) & 0b111u;
        TRIM_USB2_REFBIAS_TST = (curr >> 13u) & 0b11u;
        TRIM_USB2_REFBIAS_VBGADJ = (curr >> 10u) & 0b111u;
        TRIM_REFBIAS_TST_OVERRIDE = curr & (1u << 6u);
        TRIM_REFBIAS_VBGADJ_OVERRIDE = curr & (1u << 5u);
        TRIM_TX_CAL45DN_OVERRIDE = curr & (1u << 4u);
        TRIM_TX_CAL45DP_OVERRIDE = curr & (1u << 3u);
        TRIM_TX_D_CAL_OVERRIDE = curr & (1u << 2u);
        TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = curr & (1u << 1u);
        TRIM_DIV_SEL_OVERRIDE = curr & (1u << 0u);
    }

    /**
     * Set all of TRIM_OVERRIDE_EN_SET's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void set_TRIM_OVERRIDE_EN_SET(bool TRIM_REFBIAS_TST_OVERRIDE,
                                         bool TRIM_REFBIAS_VBGADJ_OVERRIDE,
                                         bool TRIM_TX_CAL45DN_OVERRIDE,
                                         bool TRIM_TX_CAL45DP_OVERRIDE,
                                         bool TRIM_TX_D_CAL_OVERRIDE,
                                         bool TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
                                         bool TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN_SET;

        curr &= ~(0b1u << 6u);
        curr |= (TRIM_REFBIAS_TST_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TRIM_REFBIAS_VBGADJ_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TRIM_TX_CAL45DN_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TRIM_TX_CAL45DP_OVERRIDE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TRIM_TX_D_CAL_OVERRIDE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TRIM_ENV_TAIL_ADJ_VD_OVERRIDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TRIM_DIV_SEL_OVERRIDE & 0b1u) << 0u;

        TRIM_OVERRIDE_EN_SET = curr;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_USBPHY_TX_CAL45DN field.
     *
     * TRIM_USBPHY_TX_CAL45DN
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DN() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 28u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_USBPHY_TX_CAL45DP field.
     *
     * TRIM_USBPHY_TX_CAL45DP
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DP() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 24u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_USBPHY_TX_D_CAL field.
     *
     * TRIM_USBPHY_TX_D_CAL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_D_CAL() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 20u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
     *
     * TRIM_USB_REG_ENV_TAIL_ADJ_VD
     */
    inline uint8_t
    get_TRIM_OVERRIDE_EN_CLR_TRIM_USB_REG_ENV_TAIL_ADJ_VD() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 18u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_PLL_CTRL0_DIV_SEL field.
     *
     * TRIM_PLL_CTRL0_DIV_SEL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_CLR_TRIM_PLL_CTRL0_DIV_SEL() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 15u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_USB2_REFBIAS_TST field.
     *
     * TRIM_USB2_REFBIAS_TST
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_CLR_TRIM_USB2_REFBIAS_TST() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 13u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_USB2_REFBIAS_VBGADJ field.
     *
     * TRIM_USB2_REFBIAS_VBGADJ
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_CLR_TRIM_USB2_REFBIAS_VBGADJ() volatile
    {
        return (TRIM_OVERRIDE_EN_CLR >> 10u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline bool get_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 6u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void set_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 6u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void clear_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 6u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline bool
    get_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 5u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    set_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 5u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    clear_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 5u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_CLR_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 5u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 4u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 4u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 4u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 3u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 3u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 3u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 2u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 2u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 2u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline bool
    get_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 1u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    set_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 1u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    clear_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 1u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_CLR's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_CLR & (1u << 0u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_CLR's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR |= 1u << 0u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_CLR's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_CLR's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_CLR ^= 1u << 0u;
    }

    /**
     * Get all of TRIM_OVERRIDE_EN_CLR's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void get_TRIM_OVERRIDE_EN_CLR(
        uint8_t &TRIM_USBPHY_TX_CAL45DN, uint8_t &TRIM_USBPHY_TX_CAL45DP,
        uint8_t &TRIM_USBPHY_TX_D_CAL, uint8_t &TRIM_USB_REG_ENV_TAIL_ADJ_VD,
        uint8_t &TRIM_PLL_CTRL0_DIV_SEL, uint8_t &TRIM_USB2_REFBIAS_TST,
        uint8_t &TRIM_USB2_REFBIAS_VBGADJ, bool &TRIM_REFBIAS_TST_OVERRIDE,
        bool &TRIM_REFBIAS_VBGADJ_OVERRIDE, bool &TRIM_TX_CAL45DN_OVERRIDE,
        bool &TRIM_TX_CAL45DP_OVERRIDE, bool &TRIM_TX_D_CAL_OVERRIDE,
        bool &TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
        bool &TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN_CLR;

        TRIM_USBPHY_TX_CAL45DN = (curr >> 28u) & 0b1111u;
        TRIM_USBPHY_TX_CAL45DP = (curr >> 24u) & 0b1111u;
        TRIM_USBPHY_TX_D_CAL = (curr >> 20u) & 0b1111u;
        TRIM_USB_REG_ENV_TAIL_ADJ_VD = (curr >> 18u) & 0b11u;
        TRIM_PLL_CTRL0_DIV_SEL = (curr >> 15u) & 0b111u;
        TRIM_USB2_REFBIAS_TST = (curr >> 13u) & 0b11u;
        TRIM_USB2_REFBIAS_VBGADJ = (curr >> 10u) & 0b111u;
        TRIM_REFBIAS_TST_OVERRIDE = curr & (1u << 6u);
        TRIM_REFBIAS_VBGADJ_OVERRIDE = curr & (1u << 5u);
        TRIM_TX_CAL45DN_OVERRIDE = curr & (1u << 4u);
        TRIM_TX_CAL45DP_OVERRIDE = curr & (1u << 3u);
        TRIM_TX_D_CAL_OVERRIDE = curr & (1u << 2u);
        TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = curr & (1u << 1u);
        TRIM_DIV_SEL_OVERRIDE = curr & (1u << 0u);
    }

    /**
     * Set all of TRIM_OVERRIDE_EN_CLR's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void set_TRIM_OVERRIDE_EN_CLR(bool TRIM_REFBIAS_TST_OVERRIDE,
                                         bool TRIM_REFBIAS_VBGADJ_OVERRIDE,
                                         bool TRIM_TX_CAL45DN_OVERRIDE,
                                         bool TRIM_TX_CAL45DP_OVERRIDE,
                                         bool TRIM_TX_D_CAL_OVERRIDE,
                                         bool TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
                                         bool TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN_CLR;

        curr &= ~(0b1u << 6u);
        curr |= (TRIM_REFBIAS_TST_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TRIM_REFBIAS_VBGADJ_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TRIM_TX_CAL45DN_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TRIM_TX_CAL45DP_OVERRIDE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TRIM_TX_D_CAL_OVERRIDE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TRIM_ENV_TAIL_ADJ_VD_OVERRIDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TRIM_DIV_SEL_OVERRIDE & 0b1u) << 0u;

        TRIM_OVERRIDE_EN_CLR = curr;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_USBPHY_TX_CAL45DN field.
     *
     * TRIM_USBPHY_TX_CAL45DN
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DN() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 28u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_USBPHY_TX_CAL45DP field.
     *
     * TRIM_USBPHY_TX_CAL45DP
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DP() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 24u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_USBPHY_TX_D_CAL field.
     *
     * TRIM_USBPHY_TX_D_CAL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_D_CAL() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 20u) & 0b1111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
     *
     * TRIM_USB_REG_ENV_TAIL_ADJ_VD
     */
    inline uint8_t
    get_TRIM_OVERRIDE_EN_TOG_TRIM_USB_REG_ENV_TAIL_ADJ_VD() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 18u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_PLL_CTRL0_DIV_SEL field.
     *
     * TRIM_PLL_CTRL0_DIV_SEL
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TOG_TRIM_PLL_CTRL0_DIV_SEL() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 15u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_USB2_REFBIAS_TST field.
     *
     * TRIM_USB2_REFBIAS_TST
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TOG_TRIM_USB2_REFBIAS_TST() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 13u) & 0b11u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_USB2_REFBIAS_VBGADJ field.
     *
     * TRIM_USB2_REFBIAS_VBGADJ
     */
    inline uint8_t get_TRIM_OVERRIDE_EN_TOG_TRIM_USB2_REFBIAS_VBGADJ() volatile
    {
        return (TRIM_OVERRIDE_EN_TOG >> 10u) & 0b111u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline bool get_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 6u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void set_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 6u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void clear_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_TST_OVERRIDE bit.
     *
     * Override enable for bias current control
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_TST_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 6u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline bool
    get_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 5u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    set_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 5u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    clear_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 5u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_REFBIAS_VBGADJ_OVERRIDE bit.
     *
     * Override enable for bandgap adjustment.
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_TOG_TRIM_REFBIAS_VBGADJ_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 5u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 4u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 4u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DN_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DN_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DN_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 4u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 3u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 3u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_TX_CAL45DP_OVERRIDE bit.
     *
     * TRIM_TX_CAL45DP_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 3u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 2u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 2u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_TX_D_CAL_OVERRIDE bit.
     *
     * TRIM_TX_D_CAL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 2u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline bool
    get_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 1u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    set_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 1u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    clear_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_ENV_TAIL_ADJ_VD_OVERRIDE bit.
     *
     * TRIM_ENV_TAIL_ADJ_VD_OVERRIDE
     */
    inline void
    toggle_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 1u;
    }

    /**
     * Get TRIM_OVERRIDE_EN_TOG's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline bool get_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        return TRIM_OVERRIDE_EN_TOG & (1u << 0u);
    }

    /**
     * Set TRIM_OVERRIDE_EN_TOG's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void set_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG |= 1u << 0u;
    }

    /**
     * Clear TRIM_OVERRIDE_EN_TOG's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void clear_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle TRIM_OVERRIDE_EN_TOG's TRIM_DIV_SEL_OVERRIDE bit.
     *
     * TRIM_DIV_SEL_OVERRIDE
     */
    inline void toggle_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE() volatile
    {
        TRIM_OVERRIDE_EN_TOG ^= 1u << 0u;
    }

    /**
     * Get all of TRIM_OVERRIDE_EN_TOG's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void get_TRIM_OVERRIDE_EN_TOG(
        uint8_t &TRIM_USBPHY_TX_CAL45DN, uint8_t &TRIM_USBPHY_TX_CAL45DP,
        uint8_t &TRIM_USBPHY_TX_D_CAL, uint8_t &TRIM_USB_REG_ENV_TAIL_ADJ_VD,
        uint8_t &TRIM_PLL_CTRL0_DIV_SEL, uint8_t &TRIM_USB2_REFBIAS_TST,
        uint8_t &TRIM_USB2_REFBIAS_VBGADJ, bool &TRIM_REFBIAS_TST_OVERRIDE,
        bool &TRIM_REFBIAS_VBGADJ_OVERRIDE, bool &TRIM_TX_CAL45DN_OVERRIDE,
        bool &TRIM_TX_CAL45DP_OVERRIDE, bool &TRIM_TX_D_CAL_OVERRIDE,
        bool &TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
        bool &TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN_TOG;

        TRIM_USBPHY_TX_CAL45DN = (curr >> 28u) & 0b1111u;
        TRIM_USBPHY_TX_CAL45DP = (curr >> 24u) & 0b1111u;
        TRIM_USBPHY_TX_D_CAL = (curr >> 20u) & 0b1111u;
        TRIM_USB_REG_ENV_TAIL_ADJ_VD = (curr >> 18u) & 0b11u;
        TRIM_PLL_CTRL0_DIV_SEL = (curr >> 15u) & 0b111u;
        TRIM_USB2_REFBIAS_TST = (curr >> 13u) & 0b11u;
        TRIM_USB2_REFBIAS_VBGADJ = (curr >> 10u) & 0b111u;
        TRIM_REFBIAS_TST_OVERRIDE = curr & (1u << 6u);
        TRIM_REFBIAS_VBGADJ_OVERRIDE = curr & (1u << 5u);
        TRIM_TX_CAL45DN_OVERRIDE = curr & (1u << 4u);
        TRIM_TX_CAL45DP_OVERRIDE = curr & (1u << 3u);
        TRIM_TX_D_CAL_OVERRIDE = curr & (1u << 2u);
        TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = curr & (1u << 1u);
        TRIM_DIV_SEL_OVERRIDE = curr & (1u << 0u);
    }

    /**
     * Set all of TRIM_OVERRIDE_EN_TOG's bit fields.
     *
     * (read-write) USB PHY Trim Override Enable Register
     */
    inline void set_TRIM_OVERRIDE_EN_TOG(bool TRIM_REFBIAS_TST_OVERRIDE,
                                         bool TRIM_REFBIAS_VBGADJ_OVERRIDE,
                                         bool TRIM_TX_CAL45DN_OVERRIDE,
                                         bool TRIM_TX_CAL45DP_OVERRIDE,
                                         bool TRIM_TX_D_CAL_OVERRIDE,
                                         bool TRIM_ENV_TAIL_ADJ_VD_OVERRIDE,
                                         bool TRIM_DIV_SEL_OVERRIDE) volatile
    {
        uint32_t curr = TRIM_OVERRIDE_EN_TOG;

        curr &= ~(0b1u << 6u);
        curr |= (TRIM_REFBIAS_TST_OVERRIDE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TRIM_REFBIAS_VBGADJ_OVERRIDE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TRIM_TX_CAL45DN_OVERRIDE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (TRIM_TX_CAL45DP_OVERRIDE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TRIM_TX_D_CAL_OVERRIDE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TRIM_ENV_TAIL_ADJ_VD_OVERRIDE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TRIM_DIV_SEL_OVERRIDE & 0b1u) << 0u;

        TRIM_OVERRIDE_EN_TOG = curr;
    }
};

static_assert(sizeof(usbphy1) == usbphy1::size);

static volatile usbphy1 *const USBPHY1 =
    reinterpret_cast<usbphy1 *>(0x40434000);

static volatile usbphy1 *const USBPHY2 =
    reinterpret_cast<usbphy1 *>(0x40438000);

}; // namespace MIMXRT1176::CM7
