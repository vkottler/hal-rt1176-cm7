/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/PGMC_CPC0_CPC_CACHE_MODE_CTRL_MODE.h"
#include "../enums/PGMC_CPC0_CPC_CORE_MODE_CTRL_MODE.h"
#include "../enums/PGMC_CPC0_CPC_LMEM_MODE_CTRL_MODE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * PGMC_CPC
 */
struct [[gnu::packed]] pgmc_cpc0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 208; /*!< pgmc_cpc0's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint32_t CPC_AUTHEN_CTRL; /*!< (read-write) CPC Authentication Control */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CPC_CORE_MODE;       /*!< (read-write) CPC Core Mode */
    uint32_t CPC_CORE_POWER_CTRL; /*!< (read-write) CPC core power control */
    static constexpr std::size_t reserved_padding2_length = 5;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t CPC_FLAG; /*!< (read-write) CPC flag */
    static constexpr std::size_t reserved_padding3_length = 4;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t CPC_CACHE_MODE;    /*!< (read-write) CPC Cache Mode */
    uint32_t CPC_CACHE_CM_CTRL; /*!< (read-write) CPC cache CPU mode control */
    uint32_t
        CPC_CACHE_SP_CTRL_0; /*!< (read-write) CPC cache Setpoint control 0 */
    uint32_t
        CPC_CACHE_SP_CTRL_1; /*!< (read-write) CPC cache Setpoint control 1 */
    static constexpr std::size_t reserved_padding4_length = 28;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t CPC_LMEM_MODE;      /*!< (read-write) CPC local memory Mode */
    uint32_t CPC_LMEM_CM_CTRL;   /*!< (read-write) CPC local memory CPU mode
                                    control */
    uint32_t CPC_LMEM_SP_CTRL_0; /*!< (read-write) CPC local memory Setpoint
                                    control 0 */
    uint32_t CPC_LMEM_SP_CTRL_1; /*!< (read-write) CPC local memory Setpoint
                                    control 1 */

    /* Methods. */

    /**
     * Get CPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline bool get_CPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        return CPC_AUTHEN_CTRL & (1u << 20u);
    }

    /**
     * Set CPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void set_CPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        CPC_AUTHEN_CTRL |= 1u << 20u;
    }

    /**
     * Clear CPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void clear_CPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        CPC_AUTHEN_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void toggle_CPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        CPC_AUTHEN_CTRL ^= 1u << 20u;
    }

    /**
     * Get CPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline bool get_CPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        return CPC_AUTHEN_CTRL & (1u << 12u);
    }

    /**
     * Set CPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void set_CPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        CPC_AUTHEN_CTRL |= 1u << 12u;
    }

    /**
     * Clear CPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void clear_CPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        CPC_AUTHEN_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void toggle_CPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        CPC_AUTHEN_CTRL ^= 1u << 12u;
    }

    /**
     * Get CPC_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline uint8_t get_CPC_AUTHEN_CTRL_WHITE_LIST() volatile
    {
        return (CPC_AUTHEN_CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline void set_CPC_AUTHEN_CTRL_WHITE_LIST(uint8_t value) volatile
    {
        uint32_t curr = CPC_AUTHEN_CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_AUTHEN_CTRL = curr;
    }

    /**
     * Get CPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline bool get_CPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        return CPC_AUTHEN_CTRL & (1u << 4u);
    }

    /**
     * Set CPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void set_CPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        CPC_AUTHEN_CTRL |= 1u << 4u;
    }

    /**
     * Clear CPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void clear_CPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        CPC_AUTHEN_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void toggle_CPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        CPC_AUTHEN_CTRL ^= 1u << 4u;
    }

    /**
     * Get CPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline bool get_CPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        return CPC_AUTHEN_CTRL & (1u << 1u);
    }

    /**
     * Set CPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void set_CPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        CPC_AUTHEN_CTRL |= 1u << 1u;
    }

    /**
     * Clear CPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void clear_CPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        CPC_AUTHEN_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void toggle_CPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        CPC_AUTHEN_CTRL ^= 1u << 1u;
    }

    /**
     * Get CPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline bool get_CPC_AUTHEN_CTRL_USER() volatile
    {
        return CPC_AUTHEN_CTRL & (1u << 0u);
    }

    /**
     * Set CPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void set_CPC_AUTHEN_CTRL_USER() volatile
    {
        CPC_AUTHEN_CTRL |= 1u << 0u;
    }

    /**
     * Clear CPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void clear_CPC_AUTHEN_CTRL_USER() volatile
    {
        CPC_AUTHEN_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void toggle_CPC_AUTHEN_CTRL_USER() volatile
    {
        CPC_AUTHEN_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CPC_AUTHEN_CTRL's bit fields.
     *
     * (read-write) CPC Authentication Control
     */
    inline void get_CPC_AUTHEN_CTRL(bool &LOCK_CFG, bool &LOCK_LIST,
                                    uint8_t &WHITE_LIST, bool &LOCK_SETTING,
                                    bool &NONSECURE, bool &USER) volatile
    {
        uint32_t curr = CPC_AUTHEN_CTRL;

        LOCK_CFG = curr & (1u << 20u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_SETTING = curr & (1u << 4u);
        NONSECURE = curr & (1u << 1u);
        USER = curr & (1u << 0u);
    }

    /**
     * Set all of CPC_AUTHEN_CTRL's bit fields.
     *
     * (read-write) CPC Authentication Control
     */
    inline void set_CPC_AUTHEN_CTRL(bool LOCK_CFG, bool LOCK_LIST,
                                    uint8_t WHITE_LIST, bool LOCK_SETTING,
                                    bool NONSECURE, bool USER) volatile
    {
        uint32_t curr = CPC_AUTHEN_CTRL;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_CFG & 0b1u) << 20u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_SETTING & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (NONSECURE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (USER & 0b1u) << 0u;

        CPC_AUTHEN_CTRL = curr;
    }

    /**
     * Get CPC_CORE_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline PGMC_CPC0_CPC_CORE_MODE_CTRL_MODE
    get_CPC_CORE_MODE_CTRL_MODE() volatile
    {
        return PGMC_CPC0_CPC_CORE_MODE_CTRL_MODE((CPC_CORE_MODE >> 0u) &
                                                 0b11u);
    }

    /**
     * Set CPC_CORE_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CORE_MODE_CTRL_MODE(
        PGMC_CPC0_CPC_CORE_MODE_CTRL_MODE value) volatile
    {
        uint32_t curr = CPC_CORE_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CPC_CORE_MODE = curr;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline bool get_CPC_CORE_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 11u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline void set_CPC_CORE_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 11u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline void clear_CPC_CORE_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline void toggle_CPC_CORE_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 11u;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline bool get_CPC_CORE_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 10u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline void set_CPC_CORE_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 10u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline void clear_CPC_CORE_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline void toggle_CPC_CORE_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 10u;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline bool get_CPC_CORE_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 9u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline void set_CPC_CORE_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 9u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline void clear_CPC_CORE_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline void toggle_CPC_CORE_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 9u;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline bool get_CPC_CORE_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 8u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline void set_CPC_CORE_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 8u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline void clear_CPC_CORE_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline void toggle_CPC_CORE_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 8u;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * Power off when domain enters SUSPEND mode
     */
    inline bool get_CPC_CORE_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 3u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * Power off when domain enters SUSPEND mode
     */
    inline void set_CPC_CORE_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 3u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * Power off when domain enters SUSPEND mode
     */
    inline void clear_CPC_CORE_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * Power off when domain enters SUSPEND mode
     */
    inline void toggle_CPC_CORE_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 3u;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * Power off when domain enters STOP mode
     */
    inline bool get_CPC_CORE_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 2u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * Power off when domain enters STOP mode
     */
    inline void set_CPC_CORE_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 2u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * Power off when domain enters STOP mode
     */
    inline void clear_CPC_CORE_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * Power off when domain enters STOP mode
     */
    inline void toggle_CPC_CORE_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 2u;
    }

    /**
     * Get CPC_CORE_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * Power off when domain enters WAIT mode
     */
    inline bool get_CPC_CORE_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        return CPC_CORE_POWER_CTRL & (1u << 1u);
    }

    /**
     * Set CPC_CORE_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * Power off when domain enters WAIT mode
     */
    inline void set_CPC_CORE_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        CPC_CORE_POWER_CTRL |= 1u << 1u;
    }

    /**
     * Clear CPC_CORE_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * Power off when domain enters WAIT mode
     */
    inline void clear_CPC_CORE_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        CPC_CORE_POWER_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CPC_CORE_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * Power off when domain enters WAIT mode
     */
    inline void toggle_CPC_CORE_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        CPC_CORE_POWER_CTRL ^= 1u << 1u;
    }

    /**
     * Get all of CPC_CORE_POWER_CTRL's bit fields.
     *
     * (read-write) CPC core power control
     */
    inline void get_CPC_CORE_POWER_CTRL(bool &ISO_OFF_SOFT, bool &PSW_ON_SOFT,
                                        bool &PSW_OFF_SOFT, bool &ISO_ON_SOFT,
                                        bool &PWR_OFF_AT_SUSPEND,
                                        bool &PWR_OFF_AT_STOP,
                                        bool &PWR_OFF_AT_WAIT) volatile
    {
        uint32_t curr = CPC_CORE_POWER_CTRL;

        ISO_OFF_SOFT = curr & (1u << 11u);
        PSW_ON_SOFT = curr & (1u << 10u);
        PSW_OFF_SOFT = curr & (1u << 9u);
        ISO_ON_SOFT = curr & (1u << 8u);
        PWR_OFF_AT_SUSPEND = curr & (1u << 3u);
        PWR_OFF_AT_STOP = curr & (1u << 2u);
        PWR_OFF_AT_WAIT = curr & (1u << 1u);
    }

    /**
     * Set all of CPC_CORE_POWER_CTRL's bit fields.
     *
     * (read-write) CPC core power control
     */
    inline void set_CPC_CORE_POWER_CTRL(bool ISO_OFF_SOFT, bool PSW_ON_SOFT,
                                        bool PSW_OFF_SOFT, bool ISO_ON_SOFT,
                                        bool PWR_OFF_AT_SUSPEND,
                                        bool PWR_OFF_AT_STOP,
                                        bool PWR_OFF_AT_WAIT) volatile
    {
        uint32_t curr = CPC_CORE_POWER_CTRL;

        curr &= ~(0b1u << 11u);
        curr |= (ISO_OFF_SOFT & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (PSW_ON_SOFT & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (PSW_OFF_SOFT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (ISO_ON_SOFT & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (PWR_OFF_AT_SUSPEND & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PWR_OFF_AT_STOP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PWR_OFF_AT_WAIT & 0b1u) << 1u;

        CPC_CORE_POWER_CTRL = curr;
    }

    /**
     * Get CPC_FLAG's CORE_PDN_FLAG bit.
     *
     * set to 1 after core power switch off, cleared by writing 1
     */
    inline bool get_CPC_FLAG_CORE_PDN_FLAG() volatile
    {
        return CPC_FLAG & (1u << 0u);
    }

    /**
     * Set CPC_FLAG's CORE_PDN_FLAG bit.
     *
     * set to 1 after core power switch off, cleared by writing 1
     */
    inline void set_CPC_FLAG_CORE_PDN_FLAG() volatile
    {
        CPC_FLAG |= 1u << 0u;
    }

    /**
     * Clear CPC_FLAG's CORE_PDN_FLAG bit.
     *
     * set to 1 after core power switch off, cleared by writing 1
     */
    inline void clear_CPC_FLAG_CORE_PDN_FLAG() volatile
    {
        CPC_FLAG &= ~(1u << 0u);
    }

    /**
     * Toggle CPC_FLAG's CORE_PDN_FLAG bit.
     *
     * set to 1 after core power switch off, cleared by writing 1
     */
    inline void toggle_CPC_FLAG_CORE_PDN_FLAG() volatile
    {
        CPC_FLAG ^= 1u << 0u;
    }

    /**
     * Get CPC_CACHE_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline PGMC_CPC0_CPC_CACHE_MODE_CTRL_MODE
    get_CPC_CACHE_MODE_CTRL_MODE() volatile
    {
        return PGMC_CPC0_CPC_CACHE_MODE_CTRL_MODE((CPC_CACHE_MODE >> 0u) &
                                                  0b11u);
    }

    /**
     * Set CPC_CACHE_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_MODE_CTRL_MODE(
        PGMC_CPC0_CPC_CACHE_MODE_CTRL_MODE value) volatile
    {
        uint32_t curr = CPC_CACHE_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CPC_CACHE_MODE = curr;
    }

    /**
     * Get CPC_CACHE_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline bool get_CPC_CACHE_CM_CTRL_MLPL_SOFT() volatile
    {
        return CPC_CACHE_CM_CTRL & (1u << 16u);
    }

    /**
     * Set CPC_CACHE_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline void set_CPC_CACHE_CM_CTRL_MLPL_SOFT() volatile
    {
        CPC_CACHE_CM_CTRL |= 1u << 16u;
    }

    /**
     * Clear CPC_CACHE_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline void clear_CPC_CACHE_CM_CTRL_MLPL_SOFT() volatile
    {
        CPC_CACHE_CM_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CPC_CACHE_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline void toggle_CPC_CACHE_CM_CTRL_MLPL_SOFT() volatile
    {
        CPC_CACHE_CM_CTRL ^= 1u << 16u;
    }

    /**
     * Get CPC_CACHE_CM_CTRL's MLPL_AT_SUSPEND field.
     *
     * Memory Low Power Level (MLPL) at SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_CM_CTRL_MLPL_AT_SUSPEND() volatile
    {
        return (CPC_CACHE_CM_CTRL >> 12u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_CM_CTRL's MLPL_AT_SUSPEND field.
     *
     * Memory Low Power Level (MLPL) at SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_CM_CTRL_MLPL_AT_SUSPEND(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_CM_CTRL;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CPC_CACHE_CM_CTRL = curr;
    }

    /**
     * Get CPC_CACHE_CM_CTRL's MLPL_AT_STOP field.
     *
     * Memory Low Power Level (MLPL) at STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_CM_CTRL_MLPL_AT_STOP() volatile
    {
        return (CPC_CACHE_CM_CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_CM_CTRL's MLPL_AT_STOP field.
     *
     * Memory Low Power Level (MLPL) at STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_CM_CTRL_MLPL_AT_STOP(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_CM_CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_CACHE_CM_CTRL = curr;
    }

    /**
     * Get CPC_CACHE_CM_CTRL's MLPL_AT_WAIT field.
     *
     * Memory Low Power Level (MLPL) at WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_CM_CTRL_MLPL_AT_WAIT() volatile
    {
        return (CPC_CACHE_CM_CTRL >> 4u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_CM_CTRL's MLPL_AT_WAIT field.
     *
     * Memory Low Power Level (MLPL) at WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_CM_CTRL_MLPL_AT_WAIT(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_CM_CTRL;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CPC_CACHE_CM_CTRL = curr;
    }

    /**
     * Get CPC_CACHE_CM_CTRL's MLPL_AT_RUN field.
     *
     * Memory Low Power Level (MLPL) at RUN mode
     */
    inline uint8_t get_CPC_CACHE_CM_CTRL_MLPL_AT_RUN() volatile
    {
        return (CPC_CACHE_CM_CTRL >> 0u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_CM_CTRL's MLPL_AT_RUN field.
     *
     * Memory Low Power Level (MLPL) at RUN mode
     */
    inline void set_CPC_CACHE_CM_CTRL_MLPL_AT_RUN(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_CM_CTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CPC_CACHE_CM_CTRL = curr;
    }

    /**
     * Get all of CPC_CACHE_CM_CTRL's bit fields.
     *
     * (read-write) CPC cache CPU mode control
     */
    inline void get_CPC_CACHE_CM_CTRL(bool &MLPL_SOFT,
                                      uint8_t &MLPL_AT_SUSPEND,
                                      uint8_t &MLPL_AT_STOP,
                                      uint8_t &MLPL_AT_WAIT,
                                      uint8_t &MLPL_AT_RUN) volatile
    {
        uint32_t curr = CPC_CACHE_CM_CTRL;

        MLPL_SOFT = curr & (1u << 16u);
        MLPL_AT_SUSPEND = (curr >> 12u) & 0b1111u;
        MLPL_AT_STOP = (curr >> 8u) & 0b1111u;
        MLPL_AT_WAIT = (curr >> 4u) & 0b1111u;
        MLPL_AT_RUN = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CPC_CACHE_CM_CTRL's bit fields.
     *
     * (read-write) CPC cache CPU mode control
     */
    inline void set_CPC_CACHE_CM_CTRL(bool MLPL_SOFT, uint8_t MLPL_AT_SUSPEND,
                                      uint8_t MLPL_AT_STOP,
                                      uint8_t MLPL_AT_WAIT,
                                      uint8_t MLPL_AT_RUN) volatile
    {
        uint32_t curr = CPC_CACHE_CM_CTRL;

        curr &= ~(0b1u << 16u);
        curr |= (MLPL_SOFT & 0b1u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (MLPL_AT_SUSPEND & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (MLPL_AT_STOP & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (MLPL_AT_WAIT & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (MLPL_AT_RUN & 0b1111u) << 0u;

        CPC_CACHE_CM_CTRL = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP7 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 7. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP7() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 28u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP7 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 7. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP7(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP6 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 6. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP6() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 24u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP6 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 6. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP6(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP5 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 5. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP5() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 20u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP5 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 5. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP5(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP4 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 4. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP4() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 16u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP4 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 4. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP4(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP3 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 3. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP3() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 12u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP3 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 3. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP3(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP2 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 2. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP2() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP2 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 2. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP2(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP1 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 1. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP1() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 4u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP1 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 1. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP1(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_0's MLPL_AT_SP0 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 0. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP0() volatile
    {
        return (CPC_CACHE_SP_CTRL_0 >> 0u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_0's MLPL_AT_SP0 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 0. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP0(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get all of CPC_CACHE_SP_CTRL_0's bit fields.
     *
     * (read-write) CPC cache Setpoint control 0
     */
    inline void get_CPC_CACHE_SP_CTRL_0(
        uint8_t &MLPL_AT_SP7, uint8_t &MLPL_AT_SP6, uint8_t &MLPL_AT_SP5,
        uint8_t &MLPL_AT_SP4, uint8_t &MLPL_AT_SP3, uint8_t &MLPL_AT_SP2,
        uint8_t &MLPL_AT_SP1, uint8_t &MLPL_AT_SP0) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        MLPL_AT_SP7 = (curr >> 28u) & 0b1111u;
        MLPL_AT_SP6 = (curr >> 24u) & 0b1111u;
        MLPL_AT_SP5 = (curr >> 20u) & 0b1111u;
        MLPL_AT_SP4 = (curr >> 16u) & 0b1111u;
        MLPL_AT_SP3 = (curr >> 12u) & 0b1111u;
        MLPL_AT_SP2 = (curr >> 8u) & 0b1111u;
        MLPL_AT_SP1 = (curr >> 4u) & 0b1111u;
        MLPL_AT_SP0 = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CPC_CACHE_SP_CTRL_0's bit fields.
     *
     * (read-write) CPC cache Setpoint control 0
     */
    inline void set_CPC_CACHE_SP_CTRL_0(
        uint8_t MLPL_AT_SP7, uint8_t MLPL_AT_SP6, uint8_t MLPL_AT_SP5,
        uint8_t MLPL_AT_SP4, uint8_t MLPL_AT_SP3, uint8_t MLPL_AT_SP2,
        uint8_t MLPL_AT_SP1, uint8_t MLPL_AT_SP0) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_0;

        curr &= ~(0b1111u << 28u);
        curr |= (MLPL_AT_SP7 & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (MLPL_AT_SP6 & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (MLPL_AT_SP5 & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (MLPL_AT_SP4 & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (MLPL_AT_SP3 & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (MLPL_AT_SP2 & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (MLPL_AT_SP1 & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (MLPL_AT_SP0 & 0b1111u) << 0u;

        CPC_CACHE_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP15 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 15. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP15() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 28u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP15 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 15. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP15(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP14 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 14. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP14() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 24u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP14 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 14. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP14(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP13 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 13. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP13() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 20u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP13 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 13. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP13(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP12 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 12. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP12() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 16u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP12 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 12. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP12(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP11 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 11. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP11() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 12u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP11 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 11. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP11(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP10 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 10. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP10() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP10 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 10. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP10(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP9 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 9. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP9() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 4u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP9 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 9. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP9(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_CACHE_SP_CTRL_1's MLPL_AT_SP8 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 8. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP8() volatile
    {
        return (CPC_CACHE_SP_CTRL_1 >> 0u) & 0b1111u;
    }

    /**
     * Set CPC_CACHE_SP_CTRL_1's MLPL_AT_SP8 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 8. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_CACHE_SP_CTRL_1_MLPL_AT_SP8(uint8_t value) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get all of CPC_CACHE_SP_CTRL_1's bit fields.
     *
     * (read-write) CPC cache Setpoint control 1
     */
    inline void get_CPC_CACHE_SP_CTRL_1(
        uint8_t &MLPL_AT_SP15, uint8_t &MLPL_AT_SP14, uint8_t &MLPL_AT_SP13,
        uint8_t &MLPL_AT_SP12, uint8_t &MLPL_AT_SP11, uint8_t &MLPL_AT_SP10,
        uint8_t &MLPL_AT_SP9, uint8_t &MLPL_AT_SP8) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        MLPL_AT_SP15 = (curr >> 28u) & 0b1111u;
        MLPL_AT_SP14 = (curr >> 24u) & 0b1111u;
        MLPL_AT_SP13 = (curr >> 20u) & 0b1111u;
        MLPL_AT_SP12 = (curr >> 16u) & 0b1111u;
        MLPL_AT_SP11 = (curr >> 12u) & 0b1111u;
        MLPL_AT_SP10 = (curr >> 8u) & 0b1111u;
        MLPL_AT_SP9 = (curr >> 4u) & 0b1111u;
        MLPL_AT_SP8 = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CPC_CACHE_SP_CTRL_1's bit fields.
     *
     * (read-write) CPC cache Setpoint control 1
     */
    inline void set_CPC_CACHE_SP_CTRL_1(
        uint8_t MLPL_AT_SP15, uint8_t MLPL_AT_SP14, uint8_t MLPL_AT_SP13,
        uint8_t MLPL_AT_SP12, uint8_t MLPL_AT_SP11, uint8_t MLPL_AT_SP10,
        uint8_t MLPL_AT_SP9, uint8_t MLPL_AT_SP8) volatile
    {
        uint32_t curr = CPC_CACHE_SP_CTRL_1;

        curr &= ~(0b1111u << 28u);
        curr |= (MLPL_AT_SP15 & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (MLPL_AT_SP14 & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (MLPL_AT_SP13 & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (MLPL_AT_SP12 & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (MLPL_AT_SP11 & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (MLPL_AT_SP10 & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (MLPL_AT_SP9 & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (MLPL_AT_SP8 & 0b1111u) << 0u;

        CPC_CACHE_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline PGMC_CPC0_CPC_LMEM_MODE_CTRL_MODE
    get_CPC_LMEM_MODE_CTRL_MODE() volatile
    {
        return PGMC_CPC0_CPC_LMEM_MODE_CTRL_MODE((CPC_LMEM_MODE >> 0u) &
                                                 0b11u);
    }

    /**
     * Set CPC_LMEM_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_MODE_CTRL_MODE(
        PGMC_CPC0_CPC_LMEM_MODE_CTRL_MODE value) volatile
    {
        uint32_t curr = CPC_LMEM_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CPC_LMEM_MODE = curr;
    }

    /**
     * Get CPC_LMEM_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline bool get_CPC_LMEM_CM_CTRL_MLPL_SOFT() volatile
    {
        return CPC_LMEM_CM_CTRL & (1u << 16u);
    }

    /**
     * Set CPC_LMEM_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline void set_CPC_LMEM_CM_CTRL_MLPL_SOFT() volatile
    {
        CPC_LMEM_CM_CTRL |= 1u << 16u;
    }

    /**
     * Clear CPC_LMEM_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline void clear_CPC_LMEM_CM_CTRL_MLPL_SOFT() volatile
    {
        CPC_LMEM_CM_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CPC_LMEM_CM_CTRL's MLPL_SOFT bit.
     *
     * Memory Low Power Level (MLPL) software change request, keep 1 until MLPL
     * transition complete
     */
    inline void toggle_CPC_LMEM_CM_CTRL_MLPL_SOFT() volatile
    {
        CPC_LMEM_CM_CTRL ^= 1u << 16u;
    }

    /**
     * Get CPC_LMEM_CM_CTRL's MLPL_AT_SUSPEND field.
     *
     * Memory Low Power Level (MLPL) at SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_CM_CTRL_MLPL_AT_SUSPEND() volatile
    {
        return (CPC_LMEM_CM_CTRL >> 12u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_CM_CTRL's MLPL_AT_SUSPEND field.
     *
     * Memory Low Power Level (MLPL) at SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_CM_CTRL_MLPL_AT_SUSPEND(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_CM_CTRL;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CPC_LMEM_CM_CTRL = curr;
    }

    /**
     * Get CPC_LMEM_CM_CTRL's MLPL_AT_STOP field.
     *
     * Memory Low Power Level (MLPL) at STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_CM_CTRL_MLPL_AT_STOP() volatile
    {
        return (CPC_LMEM_CM_CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_CM_CTRL's MLPL_AT_STOP field.
     *
     * Memory Low Power Level (MLPL) at STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_CM_CTRL_MLPL_AT_STOP(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_CM_CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_LMEM_CM_CTRL = curr;
    }

    /**
     * Get CPC_LMEM_CM_CTRL's MLPL_AT_WAIT field.
     *
     * Memory Low Power Level (MLPL) at WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_CM_CTRL_MLPL_AT_WAIT() volatile
    {
        return (CPC_LMEM_CM_CTRL >> 4u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_CM_CTRL's MLPL_AT_WAIT field.
     *
     * Memory Low Power Level (MLPL) at WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_CM_CTRL_MLPL_AT_WAIT(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_CM_CTRL;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CPC_LMEM_CM_CTRL = curr;
    }

    /**
     * Get CPC_LMEM_CM_CTRL's MLPL_AT_RUN field.
     *
     * Memory Low Power Level (MLPL) at RUN mode
     */
    inline uint8_t get_CPC_LMEM_CM_CTRL_MLPL_AT_RUN() volatile
    {
        return (CPC_LMEM_CM_CTRL >> 0u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_CM_CTRL's MLPL_AT_RUN field.
     *
     * Memory Low Power Level (MLPL) at RUN mode
     */
    inline void set_CPC_LMEM_CM_CTRL_MLPL_AT_RUN(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_CM_CTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CPC_LMEM_CM_CTRL = curr;
    }

    /**
     * Get all of CPC_LMEM_CM_CTRL's bit fields.
     *
     * (read-write) CPC local memory CPU mode control
     */
    inline void get_CPC_LMEM_CM_CTRL(bool &MLPL_SOFT, uint8_t &MLPL_AT_SUSPEND,
                                     uint8_t &MLPL_AT_STOP,
                                     uint8_t &MLPL_AT_WAIT,
                                     uint8_t &MLPL_AT_RUN) volatile
    {
        uint32_t curr = CPC_LMEM_CM_CTRL;

        MLPL_SOFT = curr & (1u << 16u);
        MLPL_AT_SUSPEND = (curr >> 12u) & 0b1111u;
        MLPL_AT_STOP = (curr >> 8u) & 0b1111u;
        MLPL_AT_WAIT = (curr >> 4u) & 0b1111u;
        MLPL_AT_RUN = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CPC_LMEM_CM_CTRL's bit fields.
     *
     * (read-write) CPC local memory CPU mode control
     */
    inline void set_CPC_LMEM_CM_CTRL(bool MLPL_SOFT, uint8_t MLPL_AT_SUSPEND,
                                     uint8_t MLPL_AT_STOP,
                                     uint8_t MLPL_AT_WAIT,
                                     uint8_t MLPL_AT_RUN) volatile
    {
        uint32_t curr = CPC_LMEM_CM_CTRL;

        curr &= ~(0b1u << 16u);
        curr |= (MLPL_SOFT & 0b1u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (MLPL_AT_SUSPEND & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (MLPL_AT_STOP & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (MLPL_AT_WAIT & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (MLPL_AT_RUN & 0b1111u) << 0u;

        CPC_LMEM_CM_CTRL = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP7 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 7. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP7() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 28u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP7 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 7. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP7(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP6 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 6. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP6() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 24u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP6 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 6. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP6(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP5 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 5. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP5() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 20u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP5 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 5. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP5(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP4 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 4. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP4() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 16u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP4 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 4. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP4(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP3 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 3. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP3() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 12u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP3 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 3. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP3(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP2 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 2. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP2() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP2 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 2. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP2(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP1 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 1. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP1() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 4u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP1 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 1. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP1(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_0's MLPL_AT_SP0 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 0. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP0() volatile
    {
        return (CPC_LMEM_SP_CTRL_0 >> 0u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_0's MLPL_AT_SP0 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 0. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP0(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get all of CPC_LMEM_SP_CTRL_0's bit fields.
     *
     * (read-write) CPC local memory Setpoint control 0
     */
    inline void get_CPC_LMEM_SP_CTRL_0(
        uint8_t &MLPL_AT_SP7, uint8_t &MLPL_AT_SP6, uint8_t &MLPL_AT_SP5,
        uint8_t &MLPL_AT_SP4, uint8_t &MLPL_AT_SP3, uint8_t &MLPL_AT_SP2,
        uint8_t &MLPL_AT_SP1, uint8_t &MLPL_AT_SP0) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        MLPL_AT_SP7 = (curr >> 28u) & 0b1111u;
        MLPL_AT_SP6 = (curr >> 24u) & 0b1111u;
        MLPL_AT_SP5 = (curr >> 20u) & 0b1111u;
        MLPL_AT_SP4 = (curr >> 16u) & 0b1111u;
        MLPL_AT_SP3 = (curr >> 12u) & 0b1111u;
        MLPL_AT_SP2 = (curr >> 8u) & 0b1111u;
        MLPL_AT_SP1 = (curr >> 4u) & 0b1111u;
        MLPL_AT_SP0 = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CPC_LMEM_SP_CTRL_0's bit fields.
     *
     * (read-write) CPC local memory Setpoint control 0
     */
    inline void set_CPC_LMEM_SP_CTRL_0(
        uint8_t MLPL_AT_SP7, uint8_t MLPL_AT_SP6, uint8_t MLPL_AT_SP5,
        uint8_t MLPL_AT_SP4, uint8_t MLPL_AT_SP3, uint8_t MLPL_AT_SP2,
        uint8_t MLPL_AT_SP1, uint8_t MLPL_AT_SP0) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_0;

        curr &= ~(0b1111u << 28u);
        curr |= (MLPL_AT_SP7 & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (MLPL_AT_SP6 & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (MLPL_AT_SP5 & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (MLPL_AT_SP4 & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (MLPL_AT_SP3 & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (MLPL_AT_SP2 & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (MLPL_AT_SP1 & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (MLPL_AT_SP0 & 0b1111u) << 0u;

        CPC_LMEM_SP_CTRL_0 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP15 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 15. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP15() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 28u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP15 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 15. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP15(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP14 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 14. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP14() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 24u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP14 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 14. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP14(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP13 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 13. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP13() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 20u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP13 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 13. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP13(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP12 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 12. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP12() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 16u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP12 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 12. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP12(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP11 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 11. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP11() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 12u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP11 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 11. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP11(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP10 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 10. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP10() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 8u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP10 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 10. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP10(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP9 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 9. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP9() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 4u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP9 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 9. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP9(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get CPC_LMEM_SP_CTRL_1's MLPL_AT_SP8 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 8. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint8_t get_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP8() volatile
    {
        return (CPC_LMEM_SP_CTRL_1 >> 0u) & 0b1111u;
    }

    /**
     * Set CPC_LMEM_SP_CTRL_1's MLPL_AT_SP8 field.
     *
     * Memory Low Power Level (MLPL) at Setpoint 8. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_CPC_LMEM_SP_CTRL_1_MLPL_AT_SP8(uint8_t value) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }

    /**
     * Get all of CPC_LMEM_SP_CTRL_1's bit fields.
     *
     * (read-write) CPC local memory Setpoint control 1
     */
    inline void get_CPC_LMEM_SP_CTRL_1(
        uint8_t &MLPL_AT_SP15, uint8_t &MLPL_AT_SP14, uint8_t &MLPL_AT_SP13,
        uint8_t &MLPL_AT_SP12, uint8_t &MLPL_AT_SP11, uint8_t &MLPL_AT_SP10,
        uint8_t &MLPL_AT_SP9, uint8_t &MLPL_AT_SP8) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        MLPL_AT_SP15 = (curr >> 28u) & 0b1111u;
        MLPL_AT_SP14 = (curr >> 24u) & 0b1111u;
        MLPL_AT_SP13 = (curr >> 20u) & 0b1111u;
        MLPL_AT_SP12 = (curr >> 16u) & 0b1111u;
        MLPL_AT_SP11 = (curr >> 12u) & 0b1111u;
        MLPL_AT_SP10 = (curr >> 8u) & 0b1111u;
        MLPL_AT_SP9 = (curr >> 4u) & 0b1111u;
        MLPL_AT_SP8 = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CPC_LMEM_SP_CTRL_1's bit fields.
     *
     * (read-write) CPC local memory Setpoint control 1
     */
    inline void set_CPC_LMEM_SP_CTRL_1(
        uint8_t MLPL_AT_SP15, uint8_t MLPL_AT_SP14, uint8_t MLPL_AT_SP13,
        uint8_t MLPL_AT_SP12, uint8_t MLPL_AT_SP11, uint8_t MLPL_AT_SP10,
        uint8_t MLPL_AT_SP9, uint8_t MLPL_AT_SP8) volatile
    {
        uint32_t curr = CPC_LMEM_SP_CTRL_1;

        curr &= ~(0b1111u << 28u);
        curr |= (MLPL_AT_SP15 & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (MLPL_AT_SP14 & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (MLPL_AT_SP13 & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (MLPL_AT_SP12 & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (MLPL_AT_SP11 & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (MLPL_AT_SP10 & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (MLPL_AT_SP9 & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (MLPL_AT_SP8 & 0b1111u) << 0u;

        CPC_LMEM_SP_CTRL_1 = curr;
    }
};

static_assert(sizeof(pgmc_cpc0) == pgmc_cpc0::size);

static volatile pgmc_cpc0 *const PGMC_CPC0 =
    reinterpret_cast<pgmc_cpc0 *>(0x40C89000);

static volatile pgmc_cpc0 *const PGMC_CPC1 =
    reinterpret_cast<pgmc_cpc0 *>(0x40C89400);

}; // namespace MIMXRT1176::CM7
