/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/USBHSDCD1_SIGNAL_OVERRIDE_PS.h"
#include "../enums/USBHSDCD1_STATUS_SEQ_RES.h"
#include "../enums/USBHSDCD1_STATUS_SEQ_STAT.h"
#include "../enums/USBHSDCD1_TIMER0_TSEQ_INIT.h"
#include "../enums/USBHSDCD1_TIMER1_TDCD_DBNC.h"
#include "../enums/USBHSDCD1_TIMER1_TVDPSRC_ON.h"
#include "../enums/USBHSDCD1_TIMER2_BC11_CHECK_DM.h"
#include "../enums/USBHSDCD1_TIMER2_BC11_TVDPSRC_CON.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * USBDCD
 */
struct [[gnu::packed]] usbhsdcd1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 28; /*!< usbhsdcd1's size in bytes. */

    /* Fields. */
    uint32_t CONTROL;         /*!< (read-write) Control register */
    uint32_t CLOCK;           /*!< (read-write) Clock register */
    uint32_t STATUS;          /*!< (read-write) Status register */
    uint32_t SIGNAL_OVERRIDE; /*!< (read-write) Signal Override Register */
    uint32_t TIMER0;          /*!< (read-write) TIMER0 register */
    uint32_t TIMER1;          /*!< (read-write) TIMER1 register */
    uint32_t TIMER2_BC11;     /*!< (read-write) TIMER2_BC11 register */

    /* Methods. */

    /**
     * Get CONTROL's SR bit.
     *
     * Software Reset
     */
    inline bool get_CONTROL_SR() volatile
    {
        return CONTROL & (1u << 25u);
    }

    /**
     * Set CONTROL's SR bit.
     *
     * Software Reset
     */
    inline void set_CONTROL_SR() volatile
    {
        CONTROL |= 1u << 25u;
    }

    /**
     * Clear CONTROL's SR bit.
     *
     * Software Reset
     */
    inline void clear_CONTROL_SR() volatile
    {
        CONTROL &= ~(1u << 25u);
    }

    /**
     * Toggle CONTROL's SR bit.
     *
     * Software Reset
     */
    inline void toggle_CONTROL_SR() volatile
    {
        CONTROL ^= 1u << 25u;
    }

    /**
     * Get CONTROL's START bit.
     *
     * Start Change Detection Sequence
     */
    inline bool get_CONTROL_START() volatile
    {
        return CONTROL & (1u << 24u);
    }

    /**
     * Set CONTROL's START bit.
     *
     * Start Change Detection Sequence
     */
    inline void set_CONTROL_START() volatile
    {
        CONTROL |= 1u << 24u;
    }

    /**
     * Clear CONTROL's START bit.
     *
     * Start Change Detection Sequence
     */
    inline void clear_CONTROL_START() volatile
    {
        CONTROL &= ~(1u << 24u);
    }

    /**
     * Toggle CONTROL's START bit.
     *
     * Start Change Detection Sequence
     */
    inline void toggle_CONTROL_START() volatile
    {
        CONTROL ^= 1u << 24u;
    }

    /**
     * Get CONTROL's BC12 bit.
     *
     * BC12
     */
    inline bool get_CONTROL_BC12() volatile
    {
        return CONTROL & (1u << 17u);
    }

    /**
     * Set CONTROL's BC12 bit.
     *
     * BC12
     */
    inline void set_CONTROL_BC12() volatile
    {
        CONTROL |= 1u << 17u;
    }

    /**
     * Clear CONTROL's BC12 bit.
     *
     * BC12
     */
    inline void clear_CONTROL_BC12() volatile
    {
        CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle CONTROL's BC12 bit.
     *
     * BC12
     */
    inline void toggle_CONTROL_BC12() volatile
    {
        CONTROL ^= 1u << 17u;
    }

    /**
     * Get CONTROL's IE bit.
     *
     * Interrupt Enable
     */
    inline bool get_CONTROL_IE() volatile
    {
        return CONTROL & (1u << 16u);
    }

    /**
     * Set CONTROL's IE bit.
     *
     * Interrupt Enable
     */
    inline void set_CONTROL_IE() volatile
    {
        CONTROL |= 1u << 16u;
    }

    /**
     * Clear CONTROL's IE bit.
     *
     * Interrupt Enable
     */
    inline void clear_CONTROL_IE() volatile
    {
        CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle CONTROL's IE bit.
     *
     * Interrupt Enable
     */
    inline void toggle_CONTROL_IE() volatile
    {
        CONTROL ^= 1u << 16u;
    }

    /**
     * Get CONTROL's IF bit.
     *
     * Interrupt Flag
     */
    inline bool get_CONTROL_IF() volatile
    {
        return CONTROL & (1u << 8u);
    }

    /**
     * Get CONTROL's IACK bit.
     *
     * Interrupt Acknowledge
     */
    inline bool get_CONTROL_IACK() volatile
    {
        return CONTROL & (1u << 0u);
    }

    /**
     * Set CONTROL's IACK bit.
     *
     * Interrupt Acknowledge
     */
    inline void set_CONTROL_IACK() volatile
    {
        CONTROL |= 1u << 0u;
    }

    /**
     * Clear CONTROL's IACK bit.
     *
     * Interrupt Acknowledge
     */
    inline void clear_CONTROL_IACK() volatile
    {
        CONTROL &= ~(1u << 0u);
    }

    /**
     * Toggle CONTROL's IACK bit.
     *
     * Interrupt Acknowledge
     */
    inline void toggle_CONTROL_IACK() volatile
    {
        CONTROL ^= 1u << 0u;
    }

    /**
     * Get all of CONTROL's bit fields.
     *
     * (read-write) Control register
     */
    inline void get_CONTROL(bool &SR, bool &START, bool &BC12, bool &IE,
                            bool &IF, bool &IACK) volatile
    {
        uint32_t curr = CONTROL;

        SR = curr & (1u << 25u);
        START = curr & (1u << 24u);
        BC12 = curr & (1u << 17u);
        IE = curr & (1u << 16u);
        IF = curr & (1u << 8u);
        IACK = curr & (1u << 0u);
    }

    /**
     * Set all of CONTROL's bit fields.
     *
     * (read-write) Control register
     */
    inline void set_CONTROL(bool SR, bool START, bool BC12, bool IE,
                            bool IACK) volatile
    {
        uint32_t curr = CONTROL;

        curr &= ~(0b1u << 25u);
        curr |= (SR & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (START & 0b1u) << 24u;
        curr &= ~(0b1u << 17u);
        curr |= (BC12 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (IE & 0b1u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (IACK & 0b1u) << 0u;

        CONTROL = curr;
    }

    /**
     * Get CLOCK's CLOCK_SPEED field.
     *
     * Numerical Value of Clock Speed in Binary
     */
    inline uint16_t get_CLOCK_CLOCK_SPEED() volatile
    {
        return (CLOCK >> 2u) & 0b1111111111u;
    }

    /**
     * Set CLOCK's CLOCK_SPEED field.
     *
     * Numerical Value of Clock Speed in Binary
     */
    inline void set_CLOCK_CLOCK_SPEED(uint16_t value) volatile
    {
        uint32_t curr = CLOCK;

        curr &= ~(0b1111111111u << 2u);
        curr |= (value & 0b1111111111u) << 2u;

        CLOCK = curr;
    }

    /**
     * Get CLOCK's CLOCK_UNIT bit.
     *
     * Unit of Measurement Encoding for Clock Speed
     */
    inline bool get_CLOCK_CLOCK_UNIT() volatile
    {
        return CLOCK & (1u << 0u);
    }

    /**
     * Set CLOCK's CLOCK_UNIT bit.
     *
     * Unit of Measurement Encoding for Clock Speed
     */
    inline void set_CLOCK_CLOCK_UNIT() volatile
    {
        CLOCK |= 1u << 0u;
    }

    /**
     * Clear CLOCK's CLOCK_UNIT bit.
     *
     * Unit of Measurement Encoding for Clock Speed
     */
    inline void clear_CLOCK_CLOCK_UNIT() volatile
    {
        CLOCK &= ~(1u << 0u);
    }

    /**
     * Toggle CLOCK's CLOCK_UNIT bit.
     *
     * Unit of Measurement Encoding for Clock Speed
     */
    inline void toggle_CLOCK_CLOCK_UNIT() volatile
    {
        CLOCK ^= 1u << 0u;
    }

    /**
     * Get all of CLOCK's bit fields.
     *
     * (read-write) Clock register
     */
    inline void get_CLOCK(uint16_t &CLOCK_SPEED, bool &CLOCK_UNIT) volatile
    {
        uint32_t curr = CLOCK;

        CLOCK_SPEED = (curr >> 2u) & 0b1111111111u;
        CLOCK_UNIT = curr & (1u << 0u);
    }

    /**
     * Set all of CLOCK's bit fields.
     *
     * (read-write) Clock register
     */
    inline void set_CLOCK(uint16_t CLOCK_SPEED, bool CLOCK_UNIT) volatile
    {
        uint32_t curr = CLOCK;

        curr &= ~(0b1111111111u << 2u);
        curr |= (CLOCK_SPEED & 0b1111111111u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (CLOCK_UNIT & 0b1u) << 0u;

        CLOCK = curr;
    }

    /**
     * Get STATUS's ACTIVE bit.
     *
     * Active Status Indicator
     */
    inline bool get_STATUS_ACTIVE() volatile
    {
        return STATUS & (1u << 22u);
    }

    /**
     * Get STATUS's TO bit.
     *
     * Timeout Flag
     */
    inline bool get_STATUS_TO() volatile
    {
        return STATUS & (1u << 21u);
    }

    /**
     * Get STATUS's ERR bit.
     *
     * Error Flag
     */
    inline bool get_STATUS_ERR() volatile
    {
        return STATUS & (1u << 20u);
    }

    /**
     * Get STATUS's SEQ_STAT field.
     *
     * Charger Detection Sequence Status
     */
    inline USBHSDCD1_STATUS_SEQ_STAT get_STATUS_SEQ_STAT() volatile
    {
        return USBHSDCD1_STATUS_SEQ_STAT((STATUS >> 18u) & 0b11u);
    }

    /**
     * Get STATUS's SEQ_RES field.
     *
     * Charger Detection Sequence Results
     */
    inline USBHSDCD1_STATUS_SEQ_RES get_STATUS_SEQ_RES() volatile
    {
        return USBHSDCD1_STATUS_SEQ_RES((STATUS >> 16u) & 0b11u);
    }

    /**
     * Get all of STATUS's bit fields.
     *
     * (read-write) Status register
     */
    inline void get_STATUS(bool &ACTIVE, bool &TO, bool &ERR,
                           USBHSDCD1_STATUS_SEQ_STAT &SEQ_STAT,
                           USBHSDCD1_STATUS_SEQ_RES &SEQ_RES) volatile
    {
        uint32_t curr = STATUS;

        ACTIVE = curr & (1u << 22u);
        TO = curr & (1u << 21u);
        ERR = curr & (1u << 20u);
        SEQ_STAT = USBHSDCD1_STATUS_SEQ_STAT((curr >> 18u) & 0b11u);
        SEQ_RES = USBHSDCD1_STATUS_SEQ_RES((curr >> 16u) & 0b11u);
    }

    /**
     * Get SIGNAL_OVERRIDE's PS field.
     *
     * Phase Selection
     */
    inline USBHSDCD1_SIGNAL_OVERRIDE_PS get_SIGNAL_OVERRIDE_PS() volatile
    {
        return USBHSDCD1_SIGNAL_OVERRIDE_PS((SIGNAL_OVERRIDE >> 0u) & 0b11u);
    }

    /**
     * Set SIGNAL_OVERRIDE's PS field.
     *
     * Phase Selection
     */
    inline void set_SIGNAL_OVERRIDE_PS(
        USBHSDCD1_SIGNAL_OVERRIDE_PS value) volatile
    {
        uint32_t curr = SIGNAL_OVERRIDE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SIGNAL_OVERRIDE = curr;
    }

    /**
     * Get TIMER0's TSEQ_INIT field.
     *
     * Sequence Initiation Time
     */
    inline USBHSDCD1_TIMER0_TSEQ_INIT get_TIMER0_TSEQ_INIT() volatile
    {
        return USBHSDCD1_TIMER0_TSEQ_INIT((TIMER0 >> 16u) & 0b1111111111u);
    }

    /**
     * Set TIMER0's TSEQ_INIT field.
     *
     * Sequence Initiation Time
     */
    inline void set_TIMER0_TSEQ_INIT(USBHSDCD1_TIMER0_TSEQ_INIT value) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0b1111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111u) << 16u;

        TIMER0 = curr;
    }

    /**
     * Get TIMER0's TUNITCON field.
     *
     * Unit Connection Timer Elapse (in ms)
     */
    inline uint16_t get_TIMER0_TUNITCON() volatile
    {
        return (TIMER0 >> 0u) & 0b111111111111u;
    }

    /**
     * Get all of TIMER0's bit fields.
     *
     * (read-write) TIMER0 register
     */
    inline void get_TIMER0(USBHSDCD1_TIMER0_TSEQ_INIT &TSEQ_INIT,
                           uint16_t &TUNITCON) volatile
    {
        uint32_t curr = TIMER0;

        TSEQ_INIT = USBHSDCD1_TIMER0_TSEQ_INIT((curr >> 16u) & 0b1111111111u);
        TUNITCON = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Get TIMER1's TDCD_DBNC field.
     *
     * Time Period to Debounce D+ Signal
     */
    inline USBHSDCD1_TIMER1_TDCD_DBNC get_TIMER1_TDCD_DBNC() volatile
    {
        return USBHSDCD1_TIMER1_TDCD_DBNC((TIMER1 >> 16u) & 0b1111111111u);
    }

    /**
     * Set TIMER1's TDCD_DBNC field.
     *
     * Time Period to Debounce D+ Signal
     */
    inline void set_TIMER1_TDCD_DBNC(USBHSDCD1_TIMER1_TDCD_DBNC value) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0b1111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111u) << 16u;

        TIMER1 = curr;
    }

    /**
     * Get TIMER1's TVDPSRC_ON field.
     *
     * Time Period Comparator Enabled
     */
    inline USBHSDCD1_TIMER1_TVDPSRC_ON get_TIMER1_TVDPSRC_ON() volatile
    {
        return USBHSDCD1_TIMER1_TVDPSRC_ON((TIMER1 >> 0u) & 0b1111111111u);
    }

    /**
     * Set TIMER1's TVDPSRC_ON field.
     *
     * Time Period Comparator Enabled
     */
    inline void set_TIMER1_TVDPSRC_ON(
        USBHSDCD1_TIMER1_TVDPSRC_ON value) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0b1111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111u) << 0u;

        TIMER1 = curr;
    }

    /**
     * Get all of TIMER1's bit fields.
     *
     * (read-write) TIMER1 register
     */
    inline void get_TIMER1(USBHSDCD1_TIMER1_TDCD_DBNC &TDCD_DBNC,
                           USBHSDCD1_TIMER1_TVDPSRC_ON &TVDPSRC_ON) volatile
    {
        uint32_t curr = TIMER1;

        TDCD_DBNC = USBHSDCD1_TIMER1_TDCD_DBNC((curr >> 16u) & 0b1111111111u);
        TVDPSRC_ON = USBHSDCD1_TIMER1_TVDPSRC_ON((curr >> 0u) & 0b1111111111u);
    }

    /**
     * Set all of TIMER1's bit fields.
     *
     * (read-write) TIMER1 register
     */
    inline void set_TIMER1(USBHSDCD1_TIMER1_TDCD_DBNC TDCD_DBNC,
                           USBHSDCD1_TIMER1_TVDPSRC_ON TVDPSRC_ON) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0b1111111111u << 16u);
        curr |= (std::to_underlying(TDCD_DBNC) & 0b1111111111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (std::to_underlying(TVDPSRC_ON) & 0b1111111111u) << 0u;

        TIMER1 = curr;
    }

    /**
     * Get TIMER2_BC11's TVDPSRC_CON field.
     *
     * Time Period Before Enabling D+ Pullup
     */
    inline USBHSDCD1_TIMER2_BC11_TVDPSRC_CON
    get_TIMER2_BC11_TVDPSRC_CON() volatile
    {
        return USBHSDCD1_TIMER2_BC11_TVDPSRC_CON((TIMER2_BC11 >> 16u) &
                                                 0b1111111111u);
    }

    /**
     * Set TIMER2_BC11's TVDPSRC_CON field.
     *
     * Time Period Before Enabling D+ Pullup
     */
    inline void set_TIMER2_BC11_TVDPSRC_CON(
        USBHSDCD1_TIMER2_BC11_TVDPSRC_CON value) volatile
    {
        uint32_t curr = TIMER2_BC11;

        curr &= ~(0b1111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111u) << 16u;

        TIMER2_BC11 = curr;
    }

    /**
     * Get TIMER2_BC11's CHECK_DM field.
     *
     * Time Before Check of D- Line
     */
    inline USBHSDCD1_TIMER2_BC11_CHECK_DM get_TIMER2_BC11_CHECK_DM() volatile
    {
        return USBHSDCD1_TIMER2_BC11_CHECK_DM((TIMER2_BC11 >> 0u) & 0b1111u);
    }

    /**
     * Set TIMER2_BC11's CHECK_DM field.
     *
     * Time Before Check of D- Line
     */
    inline void set_TIMER2_BC11_CHECK_DM(
        USBHSDCD1_TIMER2_BC11_CHECK_DM value) volatile
    {
        uint32_t curr = TIMER2_BC11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        TIMER2_BC11 = curr;
    }

    /**
     * Get all of TIMER2_BC11's bit fields.
     *
     * (read-write) TIMER2_BC11 register
     */
    inline void get_TIMER2_BC11(
        USBHSDCD1_TIMER2_BC11_TVDPSRC_CON &TVDPSRC_CON,
        USBHSDCD1_TIMER2_BC11_CHECK_DM &CHECK_DM) volatile
    {
        uint32_t curr = TIMER2_BC11;

        TVDPSRC_CON =
            USBHSDCD1_TIMER2_BC11_TVDPSRC_CON((curr >> 16u) & 0b1111111111u);
        CHECK_DM = USBHSDCD1_TIMER2_BC11_CHECK_DM((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of TIMER2_BC11's bit fields.
     *
     * (read-write) TIMER2_BC11 register
     */
    inline void set_TIMER2_BC11(
        USBHSDCD1_TIMER2_BC11_TVDPSRC_CON TVDPSRC_CON,
        USBHSDCD1_TIMER2_BC11_CHECK_DM CHECK_DM) volatile
    {
        uint32_t curr = TIMER2_BC11;

        curr &= ~(0b1111111111u << 16u);
        curr |= (std::to_underlying(TVDPSRC_CON) & 0b1111111111u) << 16u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(CHECK_DM) & 0b1111u) << 0u;

        TIMER2_BC11 = curr;
    }
};

static_assert(sizeof(usbhsdcd1) == usbhsdcd1::size);

static volatile usbhsdcd1 *const USBHSDCD1 =
    reinterpret_cast<usbhsdcd1 *>(0x40434800);

static volatile usbhsdcd1 *const USBHSDCD2 =
    reinterpret_cast<usbhsdcd1 *>(0x40438800);

}; // namespace MIMXRT1176::CM7
