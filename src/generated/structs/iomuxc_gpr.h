/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/IOMUXC_GPR_GPR0_DWP.h"
#include "../enums/IOMUXC_GPR_GPR0_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR10_DWP.h"
#include "../enums/IOMUXC_GPR_GPR10_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR11_DWP.h"
#include "../enums/IOMUXC_GPR_GPR11_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR12_DWP.h"
#include "../enums/IOMUXC_GPR_GPR12_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR13_DWP.h"
#include "../enums/IOMUXC_GPR_GPR13_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR14_DWP.h"
#include "../enums/IOMUXC_GPR_GPR14_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR15_DWP.h"
#include "../enums/IOMUXC_GPR_GPR15_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR16_DWP.h"
#include "../enums/IOMUXC_GPR_GPR16_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR17_DWP.h"
#include "../enums/IOMUXC_GPR_GPR17_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR18_DWP.h"
#include "../enums/IOMUXC_GPR_GPR18_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR1_DWP.h"
#include "../enums/IOMUXC_GPR_GPR1_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR20_DWP.h"
#include "../enums/IOMUXC_GPR_GPR20_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR21_DWP.h"
#include "../enums/IOMUXC_GPR_GPR21_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR22_DWP.h"
#include "../enums/IOMUXC_GPR_GPR22_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR23_DWP.h"
#include "../enums/IOMUXC_GPR_GPR23_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR24_DWP.h"
#include "../enums/IOMUXC_GPR_GPR24_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR25_DWP.h"
#include "../enums/IOMUXC_GPR_GPR25_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR26_DWP.h"
#include "../enums/IOMUXC_GPR_GPR26_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR27_DWP.h"
#include "../enums/IOMUXC_GPR_GPR27_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR28_DWP.h"
#include "../enums/IOMUXC_GPR_GPR28_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR29_DWP.h"
#include "../enums/IOMUXC_GPR_GPR29_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR2_DWP.h"
#include "../enums/IOMUXC_GPR_GPR2_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR30_DWP.h"
#include "../enums/IOMUXC_GPR_GPR30_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR31_DWP.h"
#include "../enums/IOMUXC_GPR_GPR31_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR32_DWP.h"
#include "../enums/IOMUXC_GPR_GPR32_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR33_DWP.h"
#include "../enums/IOMUXC_GPR_GPR33_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR34_DWP.h"
#include "../enums/IOMUXC_GPR_GPR34_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR35_DWP.h"
#include "../enums/IOMUXC_GPR_GPR35_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR36_DWP.h"
#include "../enums/IOMUXC_GPR_GPR36_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR37_DWP.h"
#include "../enums/IOMUXC_GPR_GPR37_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR38_DWP.h"
#include "../enums/IOMUXC_GPR_GPR38_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR39_DWP.h"
#include "../enums/IOMUXC_GPR_GPR39_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR3_DWP.h"
#include "../enums/IOMUXC_GPR_GPR3_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR40_DWP.h"
#include "../enums/IOMUXC_GPR_GPR40_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR41_DWP.h"
#include "../enums/IOMUXC_GPR_GPR41_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR42_DWP.h"
#include "../enums/IOMUXC_GPR_GPR42_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR43_DWP.h"
#include "../enums/IOMUXC_GPR_GPR43_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR44_DWP.h"
#include "../enums/IOMUXC_GPR_GPR44_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR45_DWP.h"
#include "../enums/IOMUXC_GPR_GPR45_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR46_DWP.h"
#include "../enums/IOMUXC_GPR_GPR46_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR47_DWP.h"
#include "../enums/IOMUXC_GPR_GPR47_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR48_DWP.h"
#include "../enums/IOMUXC_GPR_GPR48_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR49_DWP.h"
#include "../enums/IOMUXC_GPR_GPR49_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR4_DWP.h"
#include "../enums/IOMUXC_GPR_GPR4_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR50_DWP.h"
#include "../enums/IOMUXC_GPR_GPR50_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR51_DWP.h"
#include "../enums/IOMUXC_GPR_GPR51_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR52_DWP.h"
#include "../enums/IOMUXC_GPR_GPR52_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR53_DWP.h"
#include "../enums/IOMUXC_GPR_GPR53_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR54_DWP.h"
#include "../enums/IOMUXC_GPR_GPR54_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR55_DWP.h"
#include "../enums/IOMUXC_GPR_GPR55_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR59_DWP.h"
#include "../enums/IOMUXC_GPR_GPR59_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP.h"
#include "../enums/IOMUXC_GPR_GPR5_DWP.h"
#include "../enums/IOMUXC_GPR_GPR5_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR62_DWP.h"
#include "../enums/IOMUXC_GPR_GPR62_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR64_DWP.h"
#include "../enums/IOMUXC_GPR_GPR64_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR65_DWP.h"
#include "../enums/IOMUXC_GPR_GPR65_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR66_DWP.h"
#include "../enums/IOMUXC_GPR_GPR66_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR67_DWP.h"
#include "../enums/IOMUXC_GPR_GPR67_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR68_DWP.h"
#include "../enums/IOMUXC_GPR_GPR68_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR69_DWP.h"
#include "../enums/IOMUXC_GPR_GPR69_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR6_DWP.h"
#include "../enums/IOMUXC_GPR_GPR6_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR70_DWP.h"
#include "../enums/IOMUXC_GPR_GPR70_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR71_DWP.h"
#include "../enums/IOMUXC_GPR_GPR71_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR72_DWP.h"
#include "../enums/IOMUXC_GPR_GPR72_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR73_DWP.h"
#include "../enums/IOMUXC_GPR_GPR73_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR74_DWP.h"
#include "../enums/IOMUXC_GPR_GPR74_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR7_DWP.h"
#include "../enums/IOMUXC_GPR_GPR7_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR8_DWP.h"
#include "../enums/IOMUXC_GPR_GPR8_DWP_LOCK.h"
#include "../enums/IOMUXC_GPR_GPR9_DWP.h"
#include "../enums/IOMUXC_GPR_GPR9_DWP_LOCK.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * IOMUXC GPR
 */
struct [[gnu::packed]] iomuxc_gpr
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        308; /*!< iomuxc_gpr's size in bytes. */

    /* Fields. */
    uint32_t GPR0;  /*!< (read-write) GPR0 General Purpose Register */
    uint32_t GPR1;  /*!< (read-write) GPR1 General Purpose Register */
    uint32_t GPR2;  /*!< (read-write) GPR2 General Purpose Register */
    uint32_t GPR3;  /*!< (read-write) GPR3 General Purpose Register */
    uint32_t GPR4;  /*!< (read-write) GPR4 General Purpose Register */
    uint32_t GPR5;  /*!< (read-write) GPR5 General Purpose Register */
    uint32_t GPR6;  /*!< (read-write) GPR6 General Purpose Register */
    uint32_t GPR7;  /*!< (read-write) GPR7 General Purpose Register */
    uint32_t GPR8;  /*!< (read-write) GPR8 General Purpose Register */
    uint32_t GPR9;  /*!< (read-write) GPR9 General Purpose Register */
    uint32_t GPR10; /*!< (read-write) GPR10 General Purpose Register */
    uint32_t GPR11; /*!< (read-write) GPR11 General Purpose Register */
    uint32_t GPR12; /*!< (read-write) GPR12 General Purpose Register */
    uint32_t GPR13; /*!< (read-write) GPR13 General Purpose Register */
    uint32_t GPR14; /*!< (read-write) GPR14 General Purpose Register */
    uint32_t GPR15; /*!< (read-write) GPR15 General Purpose Register */
    uint32_t GPR16; /*!< (read-write) GPR16 General Purpose Register */
    uint32_t GPR17; /*!< (read-write) GPR17 General Purpose Register */
    uint32_t GPR18; /*!< (read-write) GPR18 General Purpose Register */
    const uint32_t reserved_padding0 = {};
    uint32_t GPR20; /*!< (read-write) GPR20 General Purpose Register */
    uint32_t GPR21; /*!< (read-write) GPR21 General Purpose Register */
    uint32_t GPR22; /*!< (read-write) GPR22 General Purpose Register */
    uint32_t GPR23; /*!< (read-write) GPR23 General Purpose Register */
    uint32_t GPR24; /*!< (read-write) GPR24 General Purpose Register */
    uint32_t GPR25; /*!< (read-write) GPR25 General Purpose Register */
    uint32_t GPR26; /*!< (read-write) GPR26 General Purpose Register */
    uint32_t GPR27; /*!< (read-write) GPR27 General Purpose Register */
    uint32_t GPR28; /*!< (read-write) GPR28 General Purpose Register */
    uint32_t GPR29; /*!< (read-write) GPR29 General Purpose Register */
    uint32_t GPR30; /*!< (read-write) GPR30 General Purpose Register */
    uint32_t GPR31; /*!< (read-write) GPR31 General Purpose Register */
    uint32_t GPR32; /*!< (read-write) GPR32 General Purpose Register */
    uint32_t GPR33; /*!< (read-write) GPR33 General Purpose Register */
    uint32_t GPR34; /*!< (read-write) GPR34 General Purpose Register */
    uint32_t GPR35; /*!< (read-write) GPR35 General Purpose Register */
    uint32_t GPR36; /*!< (read-write) GPR36 General Purpose Register */
    uint32_t GPR37; /*!< (read-write) GPR37 General Purpose Register */
    uint32_t GPR38; /*!< (read-write) GPR38 General Purpose Register */
    uint32_t GPR39; /*!< (read-write) GPR39 General Purpose Register */
    uint32_t GPR40; /*!< (read-write) GPR40 General Purpose Register */
    uint32_t GPR41; /*!< (read-write) GPR41 General Purpose Register */
    uint32_t GPR42; /*!< (read-write) GPR42 General Purpose Register */
    uint32_t GPR43; /*!< (read-write) GPR43 General Purpose Register */
    uint32_t GPR44; /*!< (read-write) GPR44 General Purpose Register */
    uint32_t GPR45; /*!< (read-write) GPR45 General Purpose Register */
    uint32_t GPR46; /*!< (read-write) GPR46 General Purpose Register */
    uint32_t GPR47; /*!< (read-write) GPR47 General Purpose Register */
    uint32_t GPR48; /*!< (read-write) GPR48 General Purpose Register */
    uint32_t GPR49; /*!< (read-write) GPR49 General Purpose Register */
    uint32_t GPR50; /*!< (read-write) GPR50 General Purpose Register */
    uint32_t GPR51; /*!< (read-write) GPR51 General Purpose Register */
    uint32_t GPR52; /*!< (read-write) GPR52 General Purpose Register */
    uint32_t GPR53; /*!< (read-write) GPR53 General Purpose Register */
    uint32_t GPR54; /*!< (read-write) GPR54 General Purpose Register */
    uint32_t GPR55; /*!< (read-write) GPR55 General Purpose Register */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t GPR59; /*!< (read-write) GPR59 General Purpose Register */
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t GPR62; /*!< (read-write) GPR62 General Purpose Register */
    uint32_t GPR63; /*!< (read-write) GPR63 General Purpose Register */
    uint32_t GPR64; /*!< (read-write) GPR64 General Purpose Register */
    uint32_t GPR65; /*!< (read-write) GPR65 General Purpose Register */
    uint32_t GPR66; /*!< (read-write) GPR66 General Purpose Register */
    uint32_t GPR67; /*!< (read-write) GPR67 General Purpose Register */
    uint32_t GPR68; /*!< (read-write) GPR68 General Purpose Register */
    uint32_t GPR69; /*!< (read-write) GPR69 General Purpose Register */
    uint32_t GPR70; /*!< (read-write) GPR70 General Purpose Register */
    uint32_t GPR71; /*!< (read-write) GPR71 General Purpose Register */
    uint32_t GPR72; /*!< (read-write) GPR72 General Purpose Register */
    uint32_t GPR73; /*!< (read-write) GPR73 General Purpose Register */
    uint32_t GPR74; /*!< (read-write) GPR74 General Purpose Register */
    uint32_t GPR75; /*!< (read-write) GPR75 General Purpose Register */
    uint32_t GPR76; /*!< (read-write) GPR76 General Purpose Register */

    /* Methods. */

    /**
     * Get GPR0's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR0_DWP_LOCK get_GPR0_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR0_DWP_LOCK((GPR0 >> 30u) & 0b11u);
    }

    /**
     * Set GPR0's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR0_DWP_LOCK(IOMUXC_GPR_GPR0_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR0;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR0 = curr;
    }

    /**
     * Get GPR0's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR0_DWP get_GPR0_DWP() volatile
    {
        return IOMUXC_GPR_GPR0_DWP((GPR0 >> 28u) & 0b11u);
    }

    /**
     * Set GPR0's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR0_DWP(IOMUXC_GPR_GPR0_DWP value) volatile
    {
        uint32_t curr = GPR0;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR0 = curr;
    }

    /**
     * Get GPR0's SAI1_MCLK_DIR bit.
     *
     * SAI1_MCLK signal direction control
     */
    inline bool get_GPR0_SAI1_MCLK_DIR() volatile
    {
        return GPR0 & (1u << 8u);
    }

    /**
     * Set GPR0's SAI1_MCLK_DIR bit.
     *
     * SAI1_MCLK signal direction control
     */
    inline void set_GPR0_SAI1_MCLK_DIR() volatile
    {
        GPR0 |= 1u << 8u;
    }

    /**
     * Clear GPR0's SAI1_MCLK_DIR bit.
     *
     * SAI1_MCLK signal direction control
     */
    inline void clear_GPR0_SAI1_MCLK_DIR() volatile
    {
        GPR0 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR0's SAI1_MCLK_DIR bit.
     *
     * SAI1_MCLK signal direction control
     */
    inline void toggle_GPR0_SAI1_MCLK_DIR() volatile
    {
        GPR0 ^= 1u << 8u;
    }

    /**
     * Get GPR0's SAI1_MCLK3_SEL field.
     *
     * SAI1 MCLK3 source select
     */
    inline uint8_t get_GPR0_SAI1_MCLK3_SEL() volatile
    {
        return (GPR0 >> 6u) & 0b11u;
    }

    /**
     * Set GPR0's SAI1_MCLK3_SEL field.
     *
     * SAI1 MCLK3 source select
     */
    inline void set_GPR0_SAI1_MCLK3_SEL(uint8_t value) volatile
    {
        uint32_t curr = GPR0;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        GPR0 = curr;
    }

    /**
     * Get GPR0's SAI1_MCLK2_SEL field.
     *
     * SAI1 MCLK2 source select
     */
    inline uint8_t get_GPR0_SAI1_MCLK2_SEL() volatile
    {
        return (GPR0 >> 3u) & 0b111u;
    }

    /**
     * Set GPR0's SAI1_MCLK2_SEL field.
     *
     * SAI1 MCLK2 source select
     */
    inline void set_GPR0_SAI1_MCLK2_SEL(uint8_t value) volatile
    {
        uint32_t curr = GPR0;

        curr &= ~(0b111u << 3u);
        curr |= (value & 0b111u) << 3u;

        GPR0 = curr;
    }

    /**
     * Get GPR0's SAI1_MCLK1_SEL field.
     *
     * SAI1 MCLK1 source select
     */
    inline uint8_t get_GPR0_SAI1_MCLK1_SEL() volatile
    {
        return (GPR0 >> 0u) & 0b111u;
    }

    /**
     * Set GPR0's SAI1_MCLK1_SEL field.
     *
     * SAI1 MCLK1 source select
     */
    inline void set_GPR0_SAI1_MCLK1_SEL(uint8_t value) volatile
    {
        uint32_t curr = GPR0;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        GPR0 = curr;
    }

    /**
     * Get all of GPR0's bit fields.
     *
     * (read-write) GPR0 General Purpose Register
     */
    inline void get_GPR0(IOMUXC_GPR_GPR0_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR0_DWP &DWP, bool &SAI1_MCLK_DIR,
                         uint8_t &SAI1_MCLK3_SEL, uint8_t &SAI1_MCLK2_SEL,
                         uint8_t &SAI1_MCLK1_SEL) volatile
    {
        uint32_t curr = GPR0;

        DWP_LOCK = IOMUXC_GPR_GPR0_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR0_DWP((curr >> 28u) & 0b11u);
        SAI1_MCLK_DIR = curr & (1u << 8u);
        SAI1_MCLK3_SEL = (curr >> 6u) & 0b11u;
        SAI1_MCLK2_SEL = (curr >> 3u) & 0b111u;
        SAI1_MCLK1_SEL = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of GPR0's bit fields.
     *
     * (read-write) GPR0 General Purpose Register
     */
    inline void set_GPR0(IOMUXC_GPR_GPR0_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR0_DWP DWP, bool SAI1_MCLK_DIR,
                         uint8_t SAI1_MCLK3_SEL, uint8_t SAI1_MCLK2_SEL,
                         uint8_t SAI1_MCLK1_SEL) volatile
    {
        uint32_t curr = GPR0;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 8u);
        curr |= (SAI1_MCLK_DIR & 0b1u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (SAI1_MCLK3_SEL & 0b11u) << 6u;
        curr &= ~(0b111u << 3u);
        curr |= (SAI1_MCLK2_SEL & 0b111u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (SAI1_MCLK1_SEL & 0b111u) << 0u;

        GPR0 = curr;
    }

    /**
     * Get GPR1's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR1_DWP_LOCK get_GPR1_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR1_DWP_LOCK((GPR1 >> 30u) & 0b11u);
    }

    /**
     * Set GPR1's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR1_DWP_LOCK(IOMUXC_GPR_GPR1_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR1;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR1 = curr;
    }

    /**
     * Get GPR1's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR1_DWP get_GPR1_DWP() volatile
    {
        return IOMUXC_GPR_GPR1_DWP((GPR1 >> 28u) & 0b11u);
    }

    /**
     * Set GPR1's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR1_DWP(IOMUXC_GPR_GPR1_DWP value) volatile
    {
        uint32_t curr = GPR1;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR1 = curr;
    }

    /**
     * Get GPR1's SAI2_MCLK_DIR bit.
     *
     * SAI2_MCLK signal direction control
     */
    inline bool get_GPR1_SAI2_MCLK_DIR() volatile
    {
        return GPR1 & (1u << 8u);
    }

    /**
     * Set GPR1's SAI2_MCLK_DIR bit.
     *
     * SAI2_MCLK signal direction control
     */
    inline void set_GPR1_SAI2_MCLK_DIR() volatile
    {
        GPR1 |= 1u << 8u;
    }

    /**
     * Clear GPR1's SAI2_MCLK_DIR bit.
     *
     * SAI2_MCLK signal direction control
     */
    inline void clear_GPR1_SAI2_MCLK_DIR() volatile
    {
        GPR1 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR1's SAI2_MCLK_DIR bit.
     *
     * SAI2_MCLK signal direction control
     */
    inline void toggle_GPR1_SAI2_MCLK_DIR() volatile
    {
        GPR1 ^= 1u << 8u;
    }

    /**
     * Get GPR1's SAI2_MCLK3_SEL field.
     *
     * SAI2 MCLK3 source select
     */
    inline uint8_t get_GPR1_SAI2_MCLK3_SEL() volatile
    {
        return (GPR1 >> 0u) & 0b11u;
    }

    /**
     * Set GPR1's SAI2_MCLK3_SEL field.
     *
     * SAI2 MCLK3 source select
     */
    inline void set_GPR1_SAI2_MCLK3_SEL(uint8_t value) volatile
    {
        uint32_t curr = GPR1;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        GPR1 = curr;
    }

    /**
     * Get all of GPR1's bit fields.
     *
     * (read-write) GPR1 General Purpose Register
     */
    inline void get_GPR1(IOMUXC_GPR_GPR1_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR1_DWP &DWP, bool &SAI2_MCLK_DIR,
                         uint8_t &SAI2_MCLK3_SEL) volatile
    {
        uint32_t curr = GPR1;

        DWP_LOCK = IOMUXC_GPR_GPR1_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR1_DWP((curr >> 28u) & 0b11u);
        SAI2_MCLK_DIR = curr & (1u << 8u);
        SAI2_MCLK3_SEL = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of GPR1's bit fields.
     *
     * (read-write) GPR1 General Purpose Register
     */
    inline void set_GPR1(IOMUXC_GPR_GPR1_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR1_DWP DWP, bool SAI2_MCLK_DIR,
                         uint8_t SAI2_MCLK3_SEL) volatile
    {
        uint32_t curr = GPR1;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 8u);
        curr |= (SAI2_MCLK_DIR & 0b1u) << 8u;
        curr &= ~(0b11u << 0u);
        curr |= (SAI2_MCLK3_SEL & 0b11u) << 0u;

        GPR1 = curr;
    }

    /**
     * Get GPR2's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR2_DWP_LOCK get_GPR2_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR2_DWP_LOCK((GPR2 >> 30u) & 0b11u);
    }

    /**
     * Set GPR2's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR2_DWP_LOCK(IOMUXC_GPR_GPR2_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR2;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR2 = curr;
    }

    /**
     * Get GPR2's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR2_DWP get_GPR2_DWP() volatile
    {
        return IOMUXC_GPR_GPR2_DWP((GPR2 >> 28u) & 0b11u);
    }

    /**
     * Set GPR2's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR2_DWP(IOMUXC_GPR_GPR2_DWP value) volatile
    {
        uint32_t curr = GPR2;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR2 = curr;
    }

    /**
     * Get GPR2's SAI4_MCLK_DIR bit.
     *
     * SAI4_MCLK signal direction control
     */
    inline bool get_GPR2_SAI4_MCLK_DIR() volatile
    {
        return GPR2 & (1u << 9u);
    }

    /**
     * Set GPR2's SAI4_MCLK_DIR bit.
     *
     * SAI4_MCLK signal direction control
     */
    inline void set_GPR2_SAI4_MCLK_DIR() volatile
    {
        GPR2 |= 1u << 9u;
    }

    /**
     * Clear GPR2's SAI4_MCLK_DIR bit.
     *
     * SAI4_MCLK signal direction control
     */
    inline void clear_GPR2_SAI4_MCLK_DIR() volatile
    {
        GPR2 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR2's SAI4_MCLK_DIR bit.
     *
     * SAI4_MCLK signal direction control
     */
    inline void toggle_GPR2_SAI4_MCLK_DIR() volatile
    {
        GPR2 ^= 1u << 9u;
    }

    /**
     * Get GPR2's SAI3_MCLK_DIR bit.
     *
     * SAI3_MCLK signal direction control
     */
    inline bool get_GPR2_SAI3_MCLK_DIR() volatile
    {
        return GPR2 & (1u << 8u);
    }

    /**
     * Set GPR2's SAI3_MCLK_DIR bit.
     *
     * SAI3_MCLK signal direction control
     */
    inline void set_GPR2_SAI3_MCLK_DIR() volatile
    {
        GPR2 |= 1u << 8u;
    }

    /**
     * Clear GPR2's SAI3_MCLK_DIR bit.
     *
     * SAI3_MCLK signal direction control
     */
    inline void clear_GPR2_SAI3_MCLK_DIR() volatile
    {
        GPR2 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR2's SAI3_MCLK_DIR bit.
     *
     * SAI3_MCLK signal direction control
     */
    inline void toggle_GPR2_SAI3_MCLK_DIR() volatile
    {
        GPR2 ^= 1u << 8u;
    }

    /**
     * Get GPR2's SAI3_MCLK3_SEL field.
     *
     * SAI3 MCLK3 source select
     */
    inline uint8_t get_GPR2_SAI3_MCLK3_SEL() volatile
    {
        return (GPR2 >> 0u) & 0b11u;
    }

    /**
     * Set GPR2's SAI3_MCLK3_SEL field.
     *
     * SAI3 MCLK3 source select
     */
    inline void set_GPR2_SAI3_MCLK3_SEL(uint8_t value) volatile
    {
        uint32_t curr = GPR2;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        GPR2 = curr;
    }

    /**
     * Get all of GPR2's bit fields.
     *
     * (read-write) GPR2 General Purpose Register
     */
    inline void get_GPR2(IOMUXC_GPR_GPR2_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR2_DWP &DWP, bool &SAI4_MCLK_DIR,
                         bool &SAI3_MCLK_DIR, uint8_t &SAI3_MCLK3_SEL) volatile
    {
        uint32_t curr = GPR2;

        DWP_LOCK = IOMUXC_GPR_GPR2_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR2_DWP((curr >> 28u) & 0b11u);
        SAI4_MCLK_DIR = curr & (1u << 9u);
        SAI3_MCLK_DIR = curr & (1u << 8u);
        SAI3_MCLK3_SEL = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of GPR2's bit fields.
     *
     * (read-write) GPR2 General Purpose Register
     */
    inline void set_GPR2(IOMUXC_GPR_GPR2_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR2_DWP DWP, bool SAI4_MCLK_DIR,
                         bool SAI3_MCLK_DIR, uint8_t SAI3_MCLK3_SEL) volatile
    {
        uint32_t curr = GPR2;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 9u);
        curr |= (SAI4_MCLK_DIR & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SAI3_MCLK_DIR & 0b1u) << 8u;
        curr &= ~(0b11u << 0u);
        curr |= (SAI3_MCLK3_SEL & 0b11u) << 0u;

        GPR2 = curr;
    }

    /**
     * Get GPR3's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR3_DWP_LOCK get_GPR3_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR3_DWP_LOCK((GPR3 >> 30u) & 0b11u);
    }

    /**
     * Set GPR3's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR3_DWP_LOCK(IOMUXC_GPR_GPR3_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR3;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR3 = curr;
    }

    /**
     * Get GPR3's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR3_DWP get_GPR3_DWP() volatile
    {
        return IOMUXC_GPR_GPR3_DWP((GPR3 >> 28u) & 0b11u);
    }

    /**
     * Set GPR3's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR3_DWP(IOMUXC_GPR_GPR3_DWP value) volatile
    {
        uint32_t curr = GPR3;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR3 = curr;
    }

    /**
     * Get GPR3's MQS_OVERSAMPLE bit.
     *
     * Medium Quality Sound (MQS) Oversample
     */
    inline bool get_GPR3_MQS_OVERSAMPLE() volatile
    {
        return GPR3 & (1u << 10u);
    }

    /**
     * Set GPR3's MQS_OVERSAMPLE bit.
     *
     * Medium Quality Sound (MQS) Oversample
     */
    inline void set_GPR3_MQS_OVERSAMPLE() volatile
    {
        GPR3 |= 1u << 10u;
    }

    /**
     * Clear GPR3's MQS_OVERSAMPLE bit.
     *
     * Medium Quality Sound (MQS) Oversample
     */
    inline void clear_GPR3_MQS_OVERSAMPLE() volatile
    {
        GPR3 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR3's MQS_OVERSAMPLE bit.
     *
     * Medium Quality Sound (MQS) Oversample
     */
    inline void toggle_GPR3_MQS_OVERSAMPLE() volatile
    {
        GPR3 ^= 1u << 10u;
    }

    /**
     * Get GPR3's MQS_EN bit.
     *
     * MQS enable
     */
    inline bool get_GPR3_MQS_EN() volatile
    {
        return GPR3 & (1u << 9u);
    }

    /**
     * Set GPR3's MQS_EN bit.
     *
     * MQS enable
     */
    inline void set_GPR3_MQS_EN() volatile
    {
        GPR3 |= 1u << 9u;
    }

    /**
     * Clear GPR3's MQS_EN bit.
     *
     * MQS enable
     */
    inline void clear_GPR3_MQS_EN() volatile
    {
        GPR3 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR3's MQS_EN bit.
     *
     * MQS enable
     */
    inline void toggle_GPR3_MQS_EN() volatile
    {
        GPR3 ^= 1u << 9u;
    }

    /**
     * Get GPR3's MQS_SW_RST bit.
     *
     * MQS software reset
     */
    inline bool get_GPR3_MQS_SW_RST() volatile
    {
        return GPR3 & (1u << 8u);
    }

    /**
     * Set GPR3's MQS_SW_RST bit.
     *
     * MQS software reset
     */
    inline void set_GPR3_MQS_SW_RST() volatile
    {
        GPR3 |= 1u << 8u;
    }

    /**
     * Clear GPR3's MQS_SW_RST bit.
     *
     * MQS software reset
     */
    inline void clear_GPR3_MQS_SW_RST() volatile
    {
        GPR3 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR3's MQS_SW_RST bit.
     *
     * MQS software reset
     */
    inline void toggle_GPR3_MQS_SW_RST() volatile
    {
        GPR3 ^= 1u << 8u;
    }

    /**
     * Get GPR3's MQS_CLK_DIV field.
     *
     * Divider ratio control for mclk from hmclk.
     */
    inline uint8_t get_GPR3_MQS_CLK_DIV() volatile
    {
        return (GPR3 >> 0u) & 0b11111111u;
    }

    /**
     * Set GPR3's MQS_CLK_DIV field.
     *
     * Divider ratio control for mclk from hmclk.
     */
    inline void set_GPR3_MQS_CLK_DIV(uint8_t value) volatile
    {
        uint32_t curr = GPR3;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        GPR3 = curr;
    }

    /**
     * Get all of GPR3's bit fields.
     *
     * (read-write) GPR3 General Purpose Register
     */
    inline void get_GPR3(IOMUXC_GPR_GPR3_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR3_DWP &DWP, bool &MQS_OVERSAMPLE,
                         bool &MQS_EN, bool &MQS_SW_RST,
                         uint8_t &MQS_CLK_DIV) volatile
    {
        uint32_t curr = GPR3;

        DWP_LOCK = IOMUXC_GPR_GPR3_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR3_DWP((curr >> 28u) & 0b11u);
        MQS_OVERSAMPLE = curr & (1u << 10u);
        MQS_EN = curr & (1u << 9u);
        MQS_SW_RST = curr & (1u << 8u);
        MQS_CLK_DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of GPR3's bit fields.
     *
     * (read-write) GPR3 General Purpose Register
     */
    inline void set_GPR3(IOMUXC_GPR_GPR3_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR3_DWP DWP, bool MQS_OVERSAMPLE,
                         bool MQS_EN, bool MQS_SW_RST,
                         uint8_t MQS_CLK_DIV) volatile
    {
        uint32_t curr = GPR3;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 10u);
        curr |= (MQS_OVERSAMPLE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (MQS_EN & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (MQS_SW_RST & 0b1u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (MQS_CLK_DIV & 0b11111111u) << 0u;

        GPR3 = curr;
    }

    /**
     * Get GPR4's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR4_DWP_LOCK get_GPR4_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR4_DWP_LOCK((GPR4 >> 30u) & 0b11u);
    }

    /**
     * Set GPR4's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR4_DWP_LOCK(IOMUXC_GPR_GPR4_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR4;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR4 = curr;
    }

    /**
     * Get GPR4's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR4_DWP get_GPR4_DWP() volatile
    {
        return IOMUXC_GPR_GPR4_DWP((GPR4 >> 28u) & 0b11u);
    }

    /**
     * Set GPR4's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR4_DWP(IOMUXC_GPR_GPR4_DWP value) volatile
    {
        uint32_t curr = GPR4;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR4 = curr;
    }

    /**
     * Get GPR4's ENET_EVENT0IN_SEL bit.
     *
     * ENET ENET_1588_EVENT0_IN source select
     */
    inline bool get_GPR4_ENET_EVENT0IN_SEL() volatile
    {
        return GPR4 & (1u << 3u);
    }

    /**
     * Set GPR4's ENET_EVENT0IN_SEL bit.
     *
     * ENET ENET_1588_EVENT0_IN source select
     */
    inline void set_GPR4_ENET_EVENT0IN_SEL() volatile
    {
        GPR4 |= 1u << 3u;
    }

    /**
     * Clear GPR4's ENET_EVENT0IN_SEL bit.
     *
     * ENET ENET_1588_EVENT0_IN source select
     */
    inline void clear_GPR4_ENET_EVENT0IN_SEL() volatile
    {
        GPR4 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR4's ENET_EVENT0IN_SEL bit.
     *
     * ENET ENET_1588_EVENT0_IN source select
     */
    inline void toggle_GPR4_ENET_EVENT0IN_SEL() volatile
    {
        GPR4 ^= 1u << 3u;
    }

    /**
     * Get GPR4's ENET_TIME_SEL bit.
     *
     * ENET master timer source select
     */
    inline bool get_GPR4_ENET_TIME_SEL() volatile
    {
        return GPR4 & (1u << 2u);
    }

    /**
     * Set GPR4's ENET_TIME_SEL bit.
     *
     * ENET master timer source select
     */
    inline void set_GPR4_ENET_TIME_SEL() volatile
    {
        GPR4 |= 1u << 2u;
    }

    /**
     * Clear GPR4's ENET_TIME_SEL bit.
     *
     * ENET master timer source select
     */
    inline void clear_GPR4_ENET_TIME_SEL() volatile
    {
        GPR4 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR4's ENET_TIME_SEL bit.
     *
     * ENET master timer source select
     */
    inline void toggle_GPR4_ENET_TIME_SEL() volatile
    {
        GPR4 ^= 1u << 2u;
    }

    /**
     * Get GPR4's ENET_REF_CLK_DIR bit.
     *
     * ENET_REF_CLK direction control
     */
    inline bool get_GPR4_ENET_REF_CLK_DIR() volatile
    {
        return GPR4 & (1u << 1u);
    }

    /**
     * Set GPR4's ENET_REF_CLK_DIR bit.
     *
     * ENET_REF_CLK direction control
     */
    inline void set_GPR4_ENET_REF_CLK_DIR() volatile
    {
        GPR4 |= 1u << 1u;
    }

    /**
     * Clear GPR4's ENET_REF_CLK_DIR bit.
     *
     * ENET_REF_CLK direction control
     */
    inline void clear_GPR4_ENET_REF_CLK_DIR() volatile
    {
        GPR4 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR4's ENET_REF_CLK_DIR bit.
     *
     * ENET_REF_CLK direction control
     */
    inline void toggle_GPR4_ENET_REF_CLK_DIR() volatile
    {
        GPR4 ^= 1u << 1u;
    }

    /**
     * Get GPR4's ENET_TX_CLK_SEL bit.
     *
     * ENET TX_CLK select
     */
    inline bool get_GPR4_ENET_TX_CLK_SEL() volatile
    {
        return GPR4 & (1u << 0u);
    }

    /**
     * Set GPR4's ENET_TX_CLK_SEL bit.
     *
     * ENET TX_CLK select
     */
    inline void set_GPR4_ENET_TX_CLK_SEL() volatile
    {
        GPR4 |= 1u << 0u;
    }

    /**
     * Clear GPR4's ENET_TX_CLK_SEL bit.
     *
     * ENET TX_CLK select
     */
    inline void clear_GPR4_ENET_TX_CLK_SEL() volatile
    {
        GPR4 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR4's ENET_TX_CLK_SEL bit.
     *
     * ENET TX_CLK select
     */
    inline void toggle_GPR4_ENET_TX_CLK_SEL() volatile
    {
        GPR4 ^= 1u << 0u;
    }

    /**
     * Get all of GPR4's bit fields.
     *
     * (read-write) GPR4 General Purpose Register
     */
    inline void get_GPR4(IOMUXC_GPR_GPR4_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR4_DWP &DWP, bool &ENET_EVENT0IN_SEL,
                         bool &ENET_TIME_SEL, bool &ENET_REF_CLK_DIR,
                         bool &ENET_TX_CLK_SEL) volatile
    {
        uint32_t curr = GPR4;

        DWP_LOCK = IOMUXC_GPR_GPR4_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR4_DWP((curr >> 28u) & 0b11u);
        ENET_EVENT0IN_SEL = curr & (1u << 3u);
        ENET_TIME_SEL = curr & (1u << 2u);
        ENET_REF_CLK_DIR = curr & (1u << 1u);
        ENET_TX_CLK_SEL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR4's bit fields.
     *
     * (read-write) GPR4 General Purpose Register
     */
    inline void set_GPR4(IOMUXC_GPR_GPR4_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR4_DWP DWP, bool ENET_EVENT0IN_SEL,
                         bool ENET_TIME_SEL, bool ENET_REF_CLK_DIR,
                         bool ENET_TX_CLK_SEL) volatile
    {
        uint32_t curr = GPR4;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 3u);
        curr |= (ENET_EVENT0IN_SEL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENET_TIME_SEL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENET_REF_CLK_DIR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENET_TX_CLK_SEL & 0b1u) << 0u;

        GPR4 = curr;
    }

    /**
     * Get GPR5's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR5_DWP_LOCK get_GPR5_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR5_DWP_LOCK((GPR5 >> 30u) & 0b11u);
    }

    /**
     * Set GPR5's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR5_DWP_LOCK(IOMUXC_GPR_GPR5_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR5;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR5 = curr;
    }

    /**
     * Get GPR5's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR5_DWP get_GPR5_DWP() volatile
    {
        return IOMUXC_GPR_GPR5_DWP((GPR5 >> 28u) & 0b11u);
    }

    /**
     * Set GPR5's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR5_DWP(IOMUXC_GPR_GPR5_DWP value) volatile
    {
        uint32_t curr = GPR5;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR5 = curr;
    }

    /**
     * Get GPR5's ENET1G_EVENT0IN_SEL bit.
     *
     * ENET1G ENET_1588_EVENT0_IN source select
     */
    inline bool get_GPR5_ENET1G_EVENT0IN_SEL() volatile
    {
        return GPR5 & (1u << 4u);
    }

    /**
     * Set GPR5's ENET1G_EVENT0IN_SEL bit.
     *
     * ENET1G ENET_1588_EVENT0_IN source select
     */
    inline void set_GPR5_ENET1G_EVENT0IN_SEL() volatile
    {
        GPR5 |= 1u << 4u;
    }

    /**
     * Clear GPR5's ENET1G_EVENT0IN_SEL bit.
     *
     * ENET1G ENET_1588_EVENT0_IN source select
     */
    inline void clear_GPR5_ENET1G_EVENT0IN_SEL() volatile
    {
        GPR5 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR5's ENET1G_EVENT0IN_SEL bit.
     *
     * ENET1G ENET_1588_EVENT0_IN source select
     */
    inline void toggle_GPR5_ENET1G_EVENT0IN_SEL() volatile
    {
        GPR5 ^= 1u << 4u;
    }

    /**
     * Get GPR5's ENET1G_TIME_SEL bit.
     *
     * ENET1G master timer source select
     */
    inline bool get_GPR5_ENET1G_TIME_SEL() volatile
    {
        return GPR5 & (1u << 3u);
    }

    /**
     * Set GPR5's ENET1G_TIME_SEL bit.
     *
     * ENET1G master timer source select
     */
    inline void set_GPR5_ENET1G_TIME_SEL() volatile
    {
        GPR5 |= 1u << 3u;
    }

    /**
     * Clear GPR5's ENET1G_TIME_SEL bit.
     *
     * ENET1G master timer source select
     */
    inline void clear_GPR5_ENET1G_TIME_SEL() volatile
    {
        GPR5 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR5's ENET1G_TIME_SEL bit.
     *
     * ENET1G master timer source select
     */
    inline void toggle_GPR5_ENET1G_TIME_SEL() volatile
    {
        GPR5 ^= 1u << 3u;
    }

    /**
     * Get GPR5's ENET1G_RGMII_EN bit.
     *
     * ENET1G RGMII TX clock output enable
     */
    inline bool get_GPR5_ENET1G_RGMII_EN() volatile
    {
        return GPR5 & (1u << 2u);
    }

    /**
     * Set GPR5's ENET1G_RGMII_EN bit.
     *
     * ENET1G RGMII TX clock output enable
     */
    inline void set_GPR5_ENET1G_RGMII_EN() volatile
    {
        GPR5 |= 1u << 2u;
    }

    /**
     * Clear GPR5's ENET1G_RGMII_EN bit.
     *
     * ENET1G RGMII TX clock output enable
     */
    inline void clear_GPR5_ENET1G_RGMII_EN() volatile
    {
        GPR5 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR5's ENET1G_RGMII_EN bit.
     *
     * ENET1G RGMII TX clock output enable
     */
    inline void toggle_GPR5_ENET1G_RGMII_EN() volatile
    {
        GPR5 ^= 1u << 2u;
    }

    /**
     * Get GPR5's ENET1G_REF_CLK_DIR bit.
     *
     * ENET1G_REF_CLK direction control
     */
    inline bool get_GPR5_ENET1G_REF_CLK_DIR() volatile
    {
        return GPR5 & (1u << 1u);
    }

    /**
     * Set GPR5's ENET1G_REF_CLK_DIR bit.
     *
     * ENET1G_REF_CLK direction control
     */
    inline void set_GPR5_ENET1G_REF_CLK_DIR() volatile
    {
        GPR5 |= 1u << 1u;
    }

    /**
     * Clear GPR5's ENET1G_REF_CLK_DIR bit.
     *
     * ENET1G_REF_CLK direction control
     */
    inline void clear_GPR5_ENET1G_REF_CLK_DIR() volatile
    {
        GPR5 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR5's ENET1G_REF_CLK_DIR bit.
     *
     * ENET1G_REF_CLK direction control
     */
    inline void toggle_GPR5_ENET1G_REF_CLK_DIR() volatile
    {
        GPR5 ^= 1u << 1u;
    }

    /**
     * Get GPR5's ENET1G_TX_CLK_SEL bit.
     *
     * ENET1G TX_CLK select
     */
    inline bool get_GPR5_ENET1G_TX_CLK_SEL() volatile
    {
        return GPR5 & (1u << 0u);
    }

    /**
     * Set GPR5's ENET1G_TX_CLK_SEL bit.
     *
     * ENET1G TX_CLK select
     */
    inline void set_GPR5_ENET1G_TX_CLK_SEL() volatile
    {
        GPR5 |= 1u << 0u;
    }

    /**
     * Clear GPR5's ENET1G_TX_CLK_SEL bit.
     *
     * ENET1G TX_CLK select
     */
    inline void clear_GPR5_ENET1G_TX_CLK_SEL() volatile
    {
        GPR5 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR5's ENET1G_TX_CLK_SEL bit.
     *
     * ENET1G TX_CLK select
     */
    inline void toggle_GPR5_ENET1G_TX_CLK_SEL() volatile
    {
        GPR5 ^= 1u << 0u;
    }

    /**
     * Get all of GPR5's bit fields.
     *
     * (read-write) GPR5 General Purpose Register
     */
    inline void get_GPR5(IOMUXC_GPR_GPR5_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR5_DWP &DWP, bool &ENET1G_EVENT0IN_SEL,
                         bool &ENET1G_TIME_SEL, bool &ENET1G_RGMII_EN,
                         bool &ENET1G_REF_CLK_DIR,
                         bool &ENET1G_TX_CLK_SEL) volatile
    {
        uint32_t curr = GPR5;

        DWP_LOCK = IOMUXC_GPR_GPR5_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR5_DWP((curr >> 28u) & 0b11u);
        ENET1G_EVENT0IN_SEL = curr & (1u << 4u);
        ENET1G_TIME_SEL = curr & (1u << 3u);
        ENET1G_RGMII_EN = curr & (1u << 2u);
        ENET1G_REF_CLK_DIR = curr & (1u << 1u);
        ENET1G_TX_CLK_SEL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR5's bit fields.
     *
     * (read-write) GPR5 General Purpose Register
     */
    inline void set_GPR5(IOMUXC_GPR_GPR5_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR5_DWP DWP, bool ENET1G_EVENT0IN_SEL,
                         bool ENET1G_TIME_SEL, bool ENET1G_RGMII_EN,
                         bool ENET1G_REF_CLK_DIR,
                         bool ENET1G_TX_CLK_SEL) volatile
    {
        uint32_t curr = GPR5;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ENET1G_EVENT0IN_SEL & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ENET1G_TIME_SEL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENET1G_RGMII_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENET1G_REF_CLK_DIR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENET1G_TX_CLK_SEL & 0b1u) << 0u;

        GPR5 = curr;
    }

    /**
     * Get GPR6's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR6_DWP_LOCK get_GPR6_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR6_DWP_LOCK((GPR6 >> 30u) & 0b11u);
    }

    /**
     * Set GPR6's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR6_DWP_LOCK(IOMUXC_GPR_GPR6_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR6;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR6 = curr;
    }

    /**
     * Get GPR6's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR6_DWP get_GPR6_DWP() volatile
    {
        return IOMUXC_GPR_GPR6_DWP((GPR6 >> 28u) & 0b11u);
    }

    /**
     * Set GPR6's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR6_DWP(IOMUXC_GPR_GPR6_DWP value) volatile
    {
        uint32_t curr = GPR6;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR6 = curr;
    }

    /**
     * Get GPR6's ENET_QOS_EVENT0IN_SEL bit.
     *
     * ENET_QOS ENET_1588_EVENT0_IN source select
     */
    inline bool get_GPR6_ENET_QOS_EVENT0IN_SEL() volatile
    {
        return GPR6 & (1u << 7u);
    }

    /**
     * Set GPR6's ENET_QOS_EVENT0IN_SEL bit.
     *
     * ENET_QOS ENET_1588_EVENT0_IN source select
     */
    inline void set_GPR6_ENET_QOS_EVENT0IN_SEL() volatile
    {
        GPR6 |= 1u << 7u;
    }

    /**
     * Clear GPR6's ENET_QOS_EVENT0IN_SEL bit.
     *
     * ENET_QOS ENET_1588_EVENT0_IN source select
     */
    inline void clear_GPR6_ENET_QOS_EVENT0IN_SEL() volatile
    {
        GPR6 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR6's ENET_QOS_EVENT0IN_SEL bit.
     *
     * ENET_QOS ENET_1588_EVENT0_IN source select
     */
    inline void toggle_GPR6_ENET_QOS_EVENT0IN_SEL() volatile
    {
        GPR6 ^= 1u << 7u;
    }

    /**
     * Get GPR6's ENET_QOS_CLKGEN_EN bit.
     *
     * ENET_QOS clock generator enable
     */
    inline bool get_GPR6_ENET_QOS_CLKGEN_EN() volatile
    {
        return GPR6 & (1u << 6u);
    }

    /**
     * Set GPR6's ENET_QOS_CLKGEN_EN bit.
     *
     * ENET_QOS clock generator enable
     */
    inline void set_GPR6_ENET_QOS_CLKGEN_EN() volatile
    {
        GPR6 |= 1u << 6u;
    }

    /**
     * Clear GPR6's ENET_QOS_CLKGEN_EN bit.
     *
     * ENET_QOS clock generator enable
     */
    inline void clear_GPR6_ENET_QOS_CLKGEN_EN() volatile
    {
        GPR6 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR6's ENET_QOS_CLKGEN_EN bit.
     *
     * ENET_QOS clock generator enable
     */
    inline void toggle_GPR6_ENET_QOS_CLKGEN_EN() volatile
    {
        GPR6 ^= 1u << 6u;
    }

    /**
     * Get GPR6's ENET_QOS_INTF_SEL field.
     *
     * ENET_QOS PHY Interface Select
     */
    inline uint8_t get_GPR6_ENET_QOS_INTF_SEL() volatile
    {
        return (GPR6 >> 3u) & 0b111u;
    }

    /**
     * Set GPR6's ENET_QOS_INTF_SEL field.
     *
     * ENET_QOS PHY Interface Select
     */
    inline void set_GPR6_ENET_QOS_INTF_SEL(uint8_t value) volatile
    {
        uint32_t curr = GPR6;

        curr &= ~(0b111u << 3u);
        curr |= (value & 0b111u) << 3u;

        GPR6 = curr;
    }

    /**
     * Get GPR6's ENET_QOS_TIME_SEL bit.
     *
     * ENET_QOS master timer source select
     */
    inline bool get_GPR6_ENET_QOS_TIME_SEL() volatile
    {
        return GPR6 & (1u << 2u);
    }

    /**
     * Set GPR6's ENET_QOS_TIME_SEL bit.
     *
     * ENET_QOS master timer source select
     */
    inline void set_GPR6_ENET_QOS_TIME_SEL() volatile
    {
        GPR6 |= 1u << 2u;
    }

    /**
     * Clear GPR6's ENET_QOS_TIME_SEL bit.
     *
     * ENET_QOS master timer source select
     */
    inline void clear_GPR6_ENET_QOS_TIME_SEL() volatile
    {
        GPR6 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR6's ENET_QOS_TIME_SEL bit.
     *
     * ENET_QOS master timer source select
     */
    inline void toggle_GPR6_ENET_QOS_TIME_SEL() volatile
    {
        GPR6 ^= 1u << 2u;
    }

    /**
     * Get GPR6's ENET_QOS_RGMII_EN bit.
     *
     * ENET_QOS RGMII TX clock output enable
     */
    inline bool get_GPR6_ENET_QOS_RGMII_EN() volatile
    {
        return GPR6 & (1u << 1u);
    }

    /**
     * Set GPR6's ENET_QOS_RGMII_EN bit.
     *
     * ENET_QOS RGMII TX clock output enable
     */
    inline void set_GPR6_ENET_QOS_RGMII_EN() volatile
    {
        GPR6 |= 1u << 1u;
    }

    /**
     * Clear GPR6's ENET_QOS_RGMII_EN bit.
     *
     * ENET_QOS RGMII TX clock output enable
     */
    inline void clear_GPR6_ENET_QOS_RGMII_EN() volatile
    {
        GPR6 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR6's ENET_QOS_RGMII_EN bit.
     *
     * ENET_QOS RGMII TX clock output enable
     */
    inline void toggle_GPR6_ENET_QOS_RGMII_EN() volatile
    {
        GPR6 ^= 1u << 1u;
    }

    /**
     * Get GPR6's ENET_QOS_REF_CLK_DIR bit.
     *
     * ENET_QOS_REF_CLK direction control
     */
    inline bool get_GPR6_ENET_QOS_REF_CLK_DIR() volatile
    {
        return GPR6 & (1u << 0u);
    }

    /**
     * Set GPR6's ENET_QOS_REF_CLK_DIR bit.
     *
     * ENET_QOS_REF_CLK direction control
     */
    inline void set_GPR6_ENET_QOS_REF_CLK_DIR() volatile
    {
        GPR6 |= 1u << 0u;
    }

    /**
     * Clear GPR6's ENET_QOS_REF_CLK_DIR bit.
     *
     * ENET_QOS_REF_CLK direction control
     */
    inline void clear_GPR6_ENET_QOS_REF_CLK_DIR() volatile
    {
        GPR6 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR6's ENET_QOS_REF_CLK_DIR bit.
     *
     * ENET_QOS_REF_CLK direction control
     */
    inline void toggle_GPR6_ENET_QOS_REF_CLK_DIR() volatile
    {
        GPR6 ^= 1u << 0u;
    }

    /**
     * Get all of GPR6's bit fields.
     *
     * (read-write) GPR6 General Purpose Register
     */
    inline void get_GPR6(IOMUXC_GPR_GPR6_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR6_DWP &DWP, bool &ENET_QOS_EVENT0IN_SEL,
                         bool &ENET_QOS_CLKGEN_EN, uint8_t &ENET_QOS_INTF_SEL,
                         bool &ENET_QOS_TIME_SEL, bool &ENET_QOS_RGMII_EN,
                         bool &ENET_QOS_REF_CLK_DIR) volatile
    {
        uint32_t curr = GPR6;

        DWP_LOCK = IOMUXC_GPR_GPR6_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR6_DWP((curr >> 28u) & 0b11u);
        ENET_QOS_EVENT0IN_SEL = curr & (1u << 7u);
        ENET_QOS_CLKGEN_EN = curr & (1u << 6u);
        ENET_QOS_INTF_SEL = (curr >> 3u) & 0b111u;
        ENET_QOS_TIME_SEL = curr & (1u << 2u);
        ENET_QOS_RGMII_EN = curr & (1u << 1u);
        ENET_QOS_REF_CLK_DIR = curr & (1u << 0u);
    }

    /**
     * Set all of GPR6's bit fields.
     *
     * (read-write) GPR6 General Purpose Register
     */
    inline void set_GPR6(IOMUXC_GPR_GPR6_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR6_DWP DWP, bool ENET_QOS_EVENT0IN_SEL,
                         bool ENET_QOS_CLKGEN_EN, uint8_t ENET_QOS_INTF_SEL,
                         bool ENET_QOS_TIME_SEL, bool ENET_QOS_RGMII_EN,
                         bool ENET_QOS_REF_CLK_DIR) volatile
    {
        uint32_t curr = GPR6;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 7u);
        curr |= (ENET_QOS_EVENT0IN_SEL & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ENET_QOS_CLKGEN_EN & 0b1u) << 6u;
        curr &= ~(0b111u << 3u);
        curr |= (ENET_QOS_INTF_SEL & 0b111u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ENET_QOS_TIME_SEL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENET_QOS_RGMII_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENET_QOS_REF_CLK_DIR & 0b1u) << 0u;

        GPR6 = curr;
    }

    /**
     * Get GPR7's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR7_DWP_LOCK get_GPR7_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR7_DWP_LOCK((GPR7 >> 30u) & 0b11u);
    }

    /**
     * Set GPR7's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR7_DWP_LOCK(IOMUXC_GPR_GPR7_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR7;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR7 = curr;
    }

    /**
     * Get GPR7's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR7_DWP get_GPR7_DWP() volatile
    {
        return IOMUXC_GPR_GPR7_DWP((GPR7 >> 28u) & 0b11u);
    }

    /**
     * Set GPR7's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR7_DWP(IOMUXC_GPR_GPR7_DWP value) volatile
    {
        uint32_t curr = GPR7;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR7 = curr;
    }

    /**
     * Get GPR7's GINT bit.
     *
     * Global interrupt
     */
    inline bool get_GPR7_GINT() volatile
    {
        return GPR7 & (1u << 0u);
    }

    /**
     * Set GPR7's GINT bit.
     *
     * Global interrupt
     */
    inline void set_GPR7_GINT() volatile
    {
        GPR7 |= 1u << 0u;
    }

    /**
     * Clear GPR7's GINT bit.
     *
     * Global interrupt
     */
    inline void clear_GPR7_GINT() volatile
    {
        GPR7 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR7's GINT bit.
     *
     * Global interrupt
     */
    inline void toggle_GPR7_GINT() volatile
    {
        GPR7 ^= 1u << 0u;
    }

    /**
     * Get all of GPR7's bit fields.
     *
     * (read-write) GPR7 General Purpose Register
     */
    inline void get_GPR7(IOMUXC_GPR_GPR7_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR7_DWP &DWP, bool &GINT) volatile
    {
        uint32_t curr = GPR7;

        DWP_LOCK = IOMUXC_GPR_GPR7_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR7_DWP((curr >> 28u) & 0b11u);
        GINT = curr & (1u << 0u);
    }

    /**
     * Set all of GPR7's bit fields.
     *
     * (read-write) GPR7 General Purpose Register
     */
    inline void set_GPR7(IOMUXC_GPR_GPR7_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR7_DWP DWP, bool GINT) volatile
    {
        uint32_t curr = GPR7;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (GINT & 0b1u) << 0u;

        GPR7 = curr;
    }

    /**
     * Get GPR8's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR8_DWP_LOCK get_GPR8_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR8_DWP_LOCK((GPR8 >> 30u) & 0b11u);
    }

    /**
     * Set GPR8's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR8_DWP_LOCK(IOMUXC_GPR_GPR8_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR8;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR8 = curr;
    }

    /**
     * Get GPR8's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR8_DWP get_GPR8_DWP() volatile
    {
        return IOMUXC_GPR_GPR8_DWP((GPR8 >> 28u) & 0b11u);
    }

    /**
     * Set GPR8's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR8_DWP(IOMUXC_GPR_GPR8_DWP value) volatile
    {
        uint32_t curr = GPR8;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR8 = curr;
    }

    /**
     * Get GPR8's WDOG1_MASK bit.
     *
     * WDOG1 timeout mask for WDOG_ANY
     */
    inline bool get_GPR8_WDOG1_MASK() volatile
    {
        return GPR8 & (1u << 0u);
    }

    /**
     * Set GPR8's WDOG1_MASK bit.
     *
     * WDOG1 timeout mask for WDOG_ANY
     */
    inline void set_GPR8_WDOG1_MASK() volatile
    {
        GPR8 |= 1u << 0u;
    }

    /**
     * Clear GPR8's WDOG1_MASK bit.
     *
     * WDOG1 timeout mask for WDOG_ANY
     */
    inline void clear_GPR8_WDOG1_MASK() volatile
    {
        GPR8 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR8's WDOG1_MASK bit.
     *
     * WDOG1 timeout mask for WDOG_ANY
     */
    inline void toggle_GPR8_WDOG1_MASK() volatile
    {
        GPR8 ^= 1u << 0u;
    }

    /**
     * Get all of GPR8's bit fields.
     *
     * (read-write) GPR8 General Purpose Register
     */
    inline void get_GPR8(IOMUXC_GPR_GPR8_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR8_DWP &DWP, bool &WDOG1_MASK) volatile
    {
        uint32_t curr = GPR8;

        DWP_LOCK = IOMUXC_GPR_GPR8_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR8_DWP((curr >> 28u) & 0b11u);
        WDOG1_MASK = curr & (1u << 0u);
    }

    /**
     * Set all of GPR8's bit fields.
     *
     * (read-write) GPR8 General Purpose Register
     */
    inline void set_GPR8(IOMUXC_GPR_GPR8_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR8_DWP DWP, bool WDOG1_MASK) volatile
    {
        uint32_t curr = GPR8;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (WDOG1_MASK & 0b1u) << 0u;

        GPR8 = curr;
    }

    /**
     * Get GPR9's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR9_DWP_LOCK get_GPR9_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR9_DWP_LOCK((GPR9 >> 30u) & 0b11u);
    }

    /**
     * Set GPR9's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR9_DWP_LOCK(IOMUXC_GPR_GPR9_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR9;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR9 = curr;
    }

    /**
     * Get GPR9's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR9_DWP get_GPR9_DWP() volatile
    {
        return IOMUXC_GPR_GPR9_DWP((GPR9 >> 28u) & 0b11u);
    }

    /**
     * Set GPR9's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR9_DWP(IOMUXC_GPR_GPR9_DWP value) volatile
    {
        uint32_t curr = GPR9;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR9 = curr;
    }

    /**
     * Get GPR9's WDOG2_MASK bit.
     *
     * WDOG2 timeout mask for WDOG_ANY
     */
    inline bool get_GPR9_WDOG2_MASK() volatile
    {
        return GPR9 & (1u << 0u);
    }

    /**
     * Set GPR9's WDOG2_MASK bit.
     *
     * WDOG2 timeout mask for WDOG_ANY
     */
    inline void set_GPR9_WDOG2_MASK() volatile
    {
        GPR9 |= 1u << 0u;
    }

    /**
     * Clear GPR9's WDOG2_MASK bit.
     *
     * WDOG2 timeout mask for WDOG_ANY
     */
    inline void clear_GPR9_WDOG2_MASK() volatile
    {
        GPR9 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR9's WDOG2_MASK bit.
     *
     * WDOG2 timeout mask for WDOG_ANY
     */
    inline void toggle_GPR9_WDOG2_MASK() volatile
    {
        GPR9 ^= 1u << 0u;
    }

    /**
     * Get all of GPR9's bit fields.
     *
     * (read-write) GPR9 General Purpose Register
     */
    inline void get_GPR9(IOMUXC_GPR_GPR9_DWP_LOCK &DWP_LOCK,
                         IOMUXC_GPR_GPR9_DWP &DWP, bool &WDOG2_MASK) volatile
    {
        uint32_t curr = GPR9;

        DWP_LOCK = IOMUXC_GPR_GPR9_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR9_DWP((curr >> 28u) & 0b11u);
        WDOG2_MASK = curr & (1u << 0u);
    }

    /**
     * Set all of GPR9's bit fields.
     *
     * (read-write) GPR9 General Purpose Register
     */
    inline void set_GPR9(IOMUXC_GPR_GPR9_DWP_LOCK DWP_LOCK,
                         IOMUXC_GPR_GPR9_DWP DWP, bool WDOG2_MASK) volatile
    {
        uint32_t curr = GPR9;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (WDOG2_MASK & 0b1u) << 0u;

        GPR9 = curr;
    }

    /**
     * Get GPR10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR10_DWP_LOCK get_GPR10_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR10_DWP_LOCK((GPR10 >> 30u) & 0b11u);
    }

    /**
     * Set GPR10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR10_DWP_LOCK(IOMUXC_GPR_GPR10_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR10 = curr;
    }

    /**
     * Get GPR10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR10_DWP get_GPR10_DWP() volatile
    {
        return IOMUXC_GPR_GPR10_DWP((GPR10 >> 28u) & 0b11u);
    }

    /**
     * Set GPR10's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR10_DWP(IOMUXC_GPR_GPR10_DWP value) volatile
    {
        uint32_t curr = GPR10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR10 = curr;
    }

    /**
     * Get all of GPR10's bit fields.
     *
     * (read-write) GPR10 General Purpose Register
     */
    inline void get_GPR10(IOMUXC_GPR_GPR10_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR10_DWP &DWP) volatile
    {
        uint32_t curr = GPR10;

        DWP_LOCK = IOMUXC_GPR_GPR10_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR10_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR10's bit fields.
     *
     * (read-write) GPR10 General Purpose Register
     */
    inline void set_GPR10(IOMUXC_GPR_GPR10_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR10_DWP DWP) volatile
    {
        uint32_t curr = GPR10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR10 = curr;
    }

    /**
     * Get GPR11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR11_DWP_LOCK get_GPR11_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR11_DWP_LOCK((GPR11 >> 30u) & 0b11u);
    }

    /**
     * Set GPR11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR11_DWP_LOCK(IOMUXC_GPR_GPR11_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR11 = curr;
    }

    /**
     * Get GPR11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR11_DWP get_GPR11_DWP() volatile
    {
        return IOMUXC_GPR_GPR11_DWP((GPR11 >> 28u) & 0b11u);
    }

    /**
     * Set GPR11's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR11_DWP(IOMUXC_GPR_GPR11_DWP value) volatile
    {
        uint32_t curr = GPR11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR11 = curr;
    }

    /**
     * Get all of GPR11's bit fields.
     *
     * (read-write) GPR11 General Purpose Register
     */
    inline void get_GPR11(IOMUXC_GPR_GPR11_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR11_DWP &DWP) volatile
    {
        uint32_t curr = GPR11;

        DWP_LOCK = IOMUXC_GPR_GPR11_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR11_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR11's bit fields.
     *
     * (read-write) GPR11 General Purpose Register
     */
    inline void set_GPR11(IOMUXC_GPR_GPR11_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR11_DWP DWP) volatile
    {
        uint32_t curr = GPR11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR11 = curr;
    }

    /**
     * Get GPR12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR12_DWP_LOCK get_GPR12_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR12_DWP_LOCK((GPR12 >> 30u) & 0b11u);
    }

    /**
     * Set GPR12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR12_DWP_LOCK(IOMUXC_GPR_GPR12_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR12 = curr;
    }

    /**
     * Get GPR12's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR12_DWP get_GPR12_DWP() volatile
    {
        return IOMUXC_GPR_GPR12_DWP((GPR12 >> 28u) & 0b11u);
    }

    /**
     * Set GPR12's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR12_DWP(IOMUXC_GPR_GPR12_DWP value) volatile
    {
        uint32_t curr = GPR12;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR12 = curr;
    }

    /**
     * Get GPR12's QTIMER1_TRM3_INPUT_SEL bit.
     *
     * QTIMER1 TMR3 input select
     */
    inline bool get_GPR12_QTIMER1_TRM3_INPUT_SEL() volatile
    {
        return GPR12 & (1u << 11u);
    }

    /**
     * Set GPR12's QTIMER1_TRM3_INPUT_SEL bit.
     *
     * QTIMER1 TMR3 input select
     */
    inline void set_GPR12_QTIMER1_TRM3_INPUT_SEL() volatile
    {
        GPR12 |= 1u << 11u;
    }

    /**
     * Clear GPR12's QTIMER1_TRM3_INPUT_SEL bit.
     *
     * QTIMER1 TMR3 input select
     */
    inline void clear_GPR12_QTIMER1_TRM3_INPUT_SEL() volatile
    {
        GPR12 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR12's QTIMER1_TRM3_INPUT_SEL bit.
     *
     * QTIMER1 TMR3 input select
     */
    inline void toggle_GPR12_QTIMER1_TRM3_INPUT_SEL() volatile
    {
        GPR12 ^= 1u << 11u;
    }

    /**
     * Get GPR12's QTIMER1_TRM2_INPUT_SEL bit.
     *
     * QTIMER1 TMR2 input select
     */
    inline bool get_GPR12_QTIMER1_TRM2_INPUT_SEL() volatile
    {
        return GPR12 & (1u << 10u);
    }

    /**
     * Set GPR12's QTIMER1_TRM2_INPUT_SEL bit.
     *
     * QTIMER1 TMR2 input select
     */
    inline void set_GPR12_QTIMER1_TRM2_INPUT_SEL() volatile
    {
        GPR12 |= 1u << 10u;
    }

    /**
     * Clear GPR12's QTIMER1_TRM2_INPUT_SEL bit.
     *
     * QTIMER1 TMR2 input select
     */
    inline void clear_GPR12_QTIMER1_TRM2_INPUT_SEL() volatile
    {
        GPR12 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR12's QTIMER1_TRM2_INPUT_SEL bit.
     *
     * QTIMER1 TMR2 input select
     */
    inline void toggle_GPR12_QTIMER1_TRM2_INPUT_SEL() volatile
    {
        GPR12 ^= 1u << 10u;
    }

    /**
     * Get GPR12's QTIMER1_TRM1_INPUT_SEL bit.
     *
     * QTIMER1 TMR1 input select
     */
    inline bool get_GPR12_QTIMER1_TRM1_INPUT_SEL() volatile
    {
        return GPR12 & (1u << 9u);
    }

    /**
     * Set GPR12's QTIMER1_TRM1_INPUT_SEL bit.
     *
     * QTIMER1 TMR1 input select
     */
    inline void set_GPR12_QTIMER1_TRM1_INPUT_SEL() volatile
    {
        GPR12 |= 1u << 9u;
    }

    /**
     * Clear GPR12's QTIMER1_TRM1_INPUT_SEL bit.
     *
     * QTIMER1 TMR1 input select
     */
    inline void clear_GPR12_QTIMER1_TRM1_INPUT_SEL() volatile
    {
        GPR12 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR12's QTIMER1_TRM1_INPUT_SEL bit.
     *
     * QTIMER1 TMR1 input select
     */
    inline void toggle_GPR12_QTIMER1_TRM1_INPUT_SEL() volatile
    {
        GPR12 ^= 1u << 9u;
    }

    /**
     * Get GPR12's QTIMER1_TRM0_INPUT_SEL bit.
     *
     * QTIMER1 TMR0 input select
     */
    inline bool get_GPR12_QTIMER1_TRM0_INPUT_SEL() volatile
    {
        return GPR12 & (1u << 8u);
    }

    /**
     * Set GPR12's QTIMER1_TRM0_INPUT_SEL bit.
     *
     * QTIMER1 TMR0 input select
     */
    inline void set_GPR12_QTIMER1_TRM0_INPUT_SEL() volatile
    {
        GPR12 |= 1u << 8u;
    }

    /**
     * Clear GPR12's QTIMER1_TRM0_INPUT_SEL bit.
     *
     * QTIMER1 TMR0 input select
     */
    inline void clear_GPR12_QTIMER1_TRM0_INPUT_SEL() volatile
    {
        GPR12 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR12's QTIMER1_TRM0_INPUT_SEL bit.
     *
     * QTIMER1 TMR0 input select
     */
    inline void toggle_GPR12_QTIMER1_TRM0_INPUT_SEL() volatile
    {
        GPR12 ^= 1u << 8u;
    }

    /**
     * Get GPR12's QTIMER1_TMR_CNTS_FREEZE bit.
     *
     * QTIMER1 timer counter freeze
     */
    inline bool get_GPR12_QTIMER1_TMR_CNTS_FREEZE() volatile
    {
        return GPR12 & (1u << 0u);
    }

    /**
     * Set GPR12's QTIMER1_TMR_CNTS_FREEZE bit.
     *
     * QTIMER1 timer counter freeze
     */
    inline void set_GPR12_QTIMER1_TMR_CNTS_FREEZE() volatile
    {
        GPR12 |= 1u << 0u;
    }

    /**
     * Clear GPR12's QTIMER1_TMR_CNTS_FREEZE bit.
     *
     * QTIMER1 timer counter freeze
     */
    inline void clear_GPR12_QTIMER1_TMR_CNTS_FREEZE() volatile
    {
        GPR12 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR12's QTIMER1_TMR_CNTS_FREEZE bit.
     *
     * QTIMER1 timer counter freeze
     */
    inline void toggle_GPR12_QTIMER1_TMR_CNTS_FREEZE() volatile
    {
        GPR12 ^= 1u << 0u;
    }

    /**
     * Get all of GPR12's bit fields.
     *
     * (read-write) GPR12 General Purpose Register
     */
    inline void get_GPR12(IOMUXC_GPR_GPR12_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR12_DWP &DWP,
                          bool &QTIMER1_TRM3_INPUT_SEL,
                          bool &QTIMER1_TRM2_INPUT_SEL,
                          bool &QTIMER1_TRM1_INPUT_SEL,
                          bool &QTIMER1_TRM0_INPUT_SEL,
                          bool &QTIMER1_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR12;

        DWP_LOCK = IOMUXC_GPR_GPR12_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR12_DWP((curr >> 28u) & 0b11u);
        QTIMER1_TRM3_INPUT_SEL = curr & (1u << 11u);
        QTIMER1_TRM2_INPUT_SEL = curr & (1u << 10u);
        QTIMER1_TRM1_INPUT_SEL = curr & (1u << 9u);
        QTIMER1_TRM0_INPUT_SEL = curr & (1u << 8u);
        QTIMER1_TMR_CNTS_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR12's bit fields.
     *
     * (read-write) GPR12 General Purpose Register
     */
    inline void set_GPR12(IOMUXC_GPR_GPR12_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR12_DWP DWP,
                          bool QTIMER1_TRM3_INPUT_SEL,
                          bool QTIMER1_TRM2_INPUT_SEL,
                          bool QTIMER1_TRM1_INPUT_SEL,
                          bool QTIMER1_TRM0_INPUT_SEL,
                          bool QTIMER1_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 11u);
        curr |= (QTIMER1_TRM3_INPUT_SEL & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (QTIMER1_TRM2_INPUT_SEL & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (QTIMER1_TRM1_INPUT_SEL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (QTIMER1_TRM0_INPUT_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (QTIMER1_TMR_CNTS_FREEZE & 0b1u) << 0u;

        GPR12 = curr;
    }

    /**
     * Get GPR13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR13_DWP_LOCK get_GPR13_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR13_DWP_LOCK((GPR13 >> 30u) & 0b11u);
    }

    /**
     * Set GPR13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR13_DWP_LOCK(IOMUXC_GPR_GPR13_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR13 = curr;
    }

    /**
     * Get GPR13's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR13_DWP get_GPR13_DWP() volatile
    {
        return IOMUXC_GPR_GPR13_DWP((GPR13 >> 28u) & 0b11u);
    }

    /**
     * Set GPR13's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR13_DWP(IOMUXC_GPR_GPR13_DWP value) volatile
    {
        uint32_t curr = GPR13;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR13 = curr;
    }

    /**
     * Get GPR13's QTIMER2_TRM3_INPUT_SEL bit.
     *
     * QTIMER2 TMR3 input select
     */
    inline bool get_GPR13_QTIMER2_TRM3_INPUT_SEL() volatile
    {
        return GPR13 & (1u << 11u);
    }

    /**
     * Set GPR13's QTIMER2_TRM3_INPUT_SEL bit.
     *
     * QTIMER2 TMR3 input select
     */
    inline void set_GPR13_QTIMER2_TRM3_INPUT_SEL() volatile
    {
        GPR13 |= 1u << 11u;
    }

    /**
     * Clear GPR13's QTIMER2_TRM3_INPUT_SEL bit.
     *
     * QTIMER2 TMR3 input select
     */
    inline void clear_GPR13_QTIMER2_TRM3_INPUT_SEL() volatile
    {
        GPR13 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR13's QTIMER2_TRM3_INPUT_SEL bit.
     *
     * QTIMER2 TMR3 input select
     */
    inline void toggle_GPR13_QTIMER2_TRM3_INPUT_SEL() volatile
    {
        GPR13 ^= 1u << 11u;
    }

    /**
     * Get GPR13's QTIMER2_TRM2_INPUT_SEL bit.
     *
     * QTIMER2 TMR2 input select
     */
    inline bool get_GPR13_QTIMER2_TRM2_INPUT_SEL() volatile
    {
        return GPR13 & (1u << 10u);
    }

    /**
     * Set GPR13's QTIMER2_TRM2_INPUT_SEL bit.
     *
     * QTIMER2 TMR2 input select
     */
    inline void set_GPR13_QTIMER2_TRM2_INPUT_SEL() volatile
    {
        GPR13 |= 1u << 10u;
    }

    /**
     * Clear GPR13's QTIMER2_TRM2_INPUT_SEL bit.
     *
     * QTIMER2 TMR2 input select
     */
    inline void clear_GPR13_QTIMER2_TRM2_INPUT_SEL() volatile
    {
        GPR13 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR13's QTIMER2_TRM2_INPUT_SEL bit.
     *
     * QTIMER2 TMR2 input select
     */
    inline void toggle_GPR13_QTIMER2_TRM2_INPUT_SEL() volatile
    {
        GPR13 ^= 1u << 10u;
    }

    /**
     * Get GPR13's QTIMER2_TRM1_INPUT_SEL bit.
     *
     * QTIMER2 TMR1 input select
     */
    inline bool get_GPR13_QTIMER2_TRM1_INPUT_SEL() volatile
    {
        return GPR13 & (1u << 9u);
    }

    /**
     * Set GPR13's QTIMER2_TRM1_INPUT_SEL bit.
     *
     * QTIMER2 TMR1 input select
     */
    inline void set_GPR13_QTIMER2_TRM1_INPUT_SEL() volatile
    {
        GPR13 |= 1u << 9u;
    }

    /**
     * Clear GPR13's QTIMER2_TRM1_INPUT_SEL bit.
     *
     * QTIMER2 TMR1 input select
     */
    inline void clear_GPR13_QTIMER2_TRM1_INPUT_SEL() volatile
    {
        GPR13 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR13's QTIMER2_TRM1_INPUT_SEL bit.
     *
     * QTIMER2 TMR1 input select
     */
    inline void toggle_GPR13_QTIMER2_TRM1_INPUT_SEL() volatile
    {
        GPR13 ^= 1u << 9u;
    }

    /**
     * Get GPR13's QTIMER2_TRM0_INPUT_SEL bit.
     *
     * QTIMER2 TMR0 input select
     */
    inline bool get_GPR13_QTIMER2_TRM0_INPUT_SEL() volatile
    {
        return GPR13 & (1u << 8u);
    }

    /**
     * Set GPR13's QTIMER2_TRM0_INPUT_SEL bit.
     *
     * QTIMER2 TMR0 input select
     */
    inline void set_GPR13_QTIMER2_TRM0_INPUT_SEL() volatile
    {
        GPR13 |= 1u << 8u;
    }

    /**
     * Clear GPR13's QTIMER2_TRM0_INPUT_SEL bit.
     *
     * QTIMER2 TMR0 input select
     */
    inline void clear_GPR13_QTIMER2_TRM0_INPUT_SEL() volatile
    {
        GPR13 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR13's QTIMER2_TRM0_INPUT_SEL bit.
     *
     * QTIMER2 TMR0 input select
     */
    inline void toggle_GPR13_QTIMER2_TRM0_INPUT_SEL() volatile
    {
        GPR13 ^= 1u << 8u;
    }

    /**
     * Get GPR13's QTIMER2_TMR_CNTS_FREEZE bit.
     *
     * QTIMER2 timer counter freeze
     */
    inline bool get_GPR13_QTIMER2_TMR_CNTS_FREEZE() volatile
    {
        return GPR13 & (1u << 0u);
    }

    /**
     * Set GPR13's QTIMER2_TMR_CNTS_FREEZE bit.
     *
     * QTIMER2 timer counter freeze
     */
    inline void set_GPR13_QTIMER2_TMR_CNTS_FREEZE() volatile
    {
        GPR13 |= 1u << 0u;
    }

    /**
     * Clear GPR13's QTIMER2_TMR_CNTS_FREEZE bit.
     *
     * QTIMER2 timer counter freeze
     */
    inline void clear_GPR13_QTIMER2_TMR_CNTS_FREEZE() volatile
    {
        GPR13 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR13's QTIMER2_TMR_CNTS_FREEZE bit.
     *
     * QTIMER2 timer counter freeze
     */
    inline void toggle_GPR13_QTIMER2_TMR_CNTS_FREEZE() volatile
    {
        GPR13 ^= 1u << 0u;
    }

    /**
     * Get all of GPR13's bit fields.
     *
     * (read-write) GPR13 General Purpose Register
     */
    inline void get_GPR13(IOMUXC_GPR_GPR13_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR13_DWP &DWP,
                          bool &QTIMER2_TRM3_INPUT_SEL,
                          bool &QTIMER2_TRM2_INPUT_SEL,
                          bool &QTIMER2_TRM1_INPUT_SEL,
                          bool &QTIMER2_TRM0_INPUT_SEL,
                          bool &QTIMER2_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR13;

        DWP_LOCK = IOMUXC_GPR_GPR13_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR13_DWP((curr >> 28u) & 0b11u);
        QTIMER2_TRM3_INPUT_SEL = curr & (1u << 11u);
        QTIMER2_TRM2_INPUT_SEL = curr & (1u << 10u);
        QTIMER2_TRM1_INPUT_SEL = curr & (1u << 9u);
        QTIMER2_TRM0_INPUT_SEL = curr & (1u << 8u);
        QTIMER2_TMR_CNTS_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR13's bit fields.
     *
     * (read-write) GPR13 General Purpose Register
     */
    inline void set_GPR13(IOMUXC_GPR_GPR13_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR13_DWP DWP,
                          bool QTIMER2_TRM3_INPUT_SEL,
                          bool QTIMER2_TRM2_INPUT_SEL,
                          bool QTIMER2_TRM1_INPUT_SEL,
                          bool QTIMER2_TRM0_INPUT_SEL,
                          bool QTIMER2_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 11u);
        curr |= (QTIMER2_TRM3_INPUT_SEL & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (QTIMER2_TRM2_INPUT_SEL & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (QTIMER2_TRM1_INPUT_SEL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (QTIMER2_TRM0_INPUT_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (QTIMER2_TMR_CNTS_FREEZE & 0b1u) << 0u;

        GPR13 = curr;
    }

    /**
     * Get GPR14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR14_DWP_LOCK get_GPR14_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR14_DWP_LOCK((GPR14 >> 30u) & 0b11u);
    }

    /**
     * Set GPR14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR14_DWP_LOCK(IOMUXC_GPR_GPR14_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR14 = curr;
    }

    /**
     * Get GPR14's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR14_DWP get_GPR14_DWP() volatile
    {
        return IOMUXC_GPR_GPR14_DWP((GPR14 >> 28u) & 0b11u);
    }

    /**
     * Set GPR14's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR14_DWP(IOMUXC_GPR_GPR14_DWP value) volatile
    {
        uint32_t curr = GPR14;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR14 = curr;
    }

    /**
     * Get GPR14's QTIMER3_TRM3_INPUT_SEL bit.
     *
     * QTIMER3 TMR3 input select
     */
    inline bool get_GPR14_QTIMER3_TRM3_INPUT_SEL() volatile
    {
        return GPR14 & (1u << 11u);
    }

    /**
     * Set GPR14's QTIMER3_TRM3_INPUT_SEL bit.
     *
     * QTIMER3 TMR3 input select
     */
    inline void set_GPR14_QTIMER3_TRM3_INPUT_SEL() volatile
    {
        GPR14 |= 1u << 11u;
    }

    /**
     * Clear GPR14's QTIMER3_TRM3_INPUT_SEL bit.
     *
     * QTIMER3 TMR3 input select
     */
    inline void clear_GPR14_QTIMER3_TRM3_INPUT_SEL() volatile
    {
        GPR14 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR14's QTIMER3_TRM3_INPUT_SEL bit.
     *
     * QTIMER3 TMR3 input select
     */
    inline void toggle_GPR14_QTIMER3_TRM3_INPUT_SEL() volatile
    {
        GPR14 ^= 1u << 11u;
    }

    /**
     * Get GPR14's QTIMER3_TRM2_INPUT_SEL bit.
     *
     * QTIMER3 TMR2 input select
     */
    inline bool get_GPR14_QTIMER3_TRM2_INPUT_SEL() volatile
    {
        return GPR14 & (1u << 10u);
    }

    /**
     * Set GPR14's QTIMER3_TRM2_INPUT_SEL bit.
     *
     * QTIMER3 TMR2 input select
     */
    inline void set_GPR14_QTIMER3_TRM2_INPUT_SEL() volatile
    {
        GPR14 |= 1u << 10u;
    }

    /**
     * Clear GPR14's QTIMER3_TRM2_INPUT_SEL bit.
     *
     * QTIMER3 TMR2 input select
     */
    inline void clear_GPR14_QTIMER3_TRM2_INPUT_SEL() volatile
    {
        GPR14 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR14's QTIMER3_TRM2_INPUT_SEL bit.
     *
     * QTIMER3 TMR2 input select
     */
    inline void toggle_GPR14_QTIMER3_TRM2_INPUT_SEL() volatile
    {
        GPR14 ^= 1u << 10u;
    }

    /**
     * Get GPR14's QTIMER3_TRM1_INPUT_SEL bit.
     *
     * QTIMER3 TMR1 input select
     */
    inline bool get_GPR14_QTIMER3_TRM1_INPUT_SEL() volatile
    {
        return GPR14 & (1u << 9u);
    }

    /**
     * Set GPR14's QTIMER3_TRM1_INPUT_SEL bit.
     *
     * QTIMER3 TMR1 input select
     */
    inline void set_GPR14_QTIMER3_TRM1_INPUT_SEL() volatile
    {
        GPR14 |= 1u << 9u;
    }

    /**
     * Clear GPR14's QTIMER3_TRM1_INPUT_SEL bit.
     *
     * QTIMER3 TMR1 input select
     */
    inline void clear_GPR14_QTIMER3_TRM1_INPUT_SEL() volatile
    {
        GPR14 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR14's QTIMER3_TRM1_INPUT_SEL bit.
     *
     * QTIMER3 TMR1 input select
     */
    inline void toggle_GPR14_QTIMER3_TRM1_INPUT_SEL() volatile
    {
        GPR14 ^= 1u << 9u;
    }

    /**
     * Get GPR14's QTIMER3_TRM0_INPUT_SEL bit.
     *
     * QTIMER3 TMR0 input select
     */
    inline bool get_GPR14_QTIMER3_TRM0_INPUT_SEL() volatile
    {
        return GPR14 & (1u << 8u);
    }

    /**
     * Set GPR14's QTIMER3_TRM0_INPUT_SEL bit.
     *
     * QTIMER3 TMR0 input select
     */
    inline void set_GPR14_QTIMER3_TRM0_INPUT_SEL() volatile
    {
        GPR14 |= 1u << 8u;
    }

    /**
     * Clear GPR14's QTIMER3_TRM0_INPUT_SEL bit.
     *
     * QTIMER3 TMR0 input select
     */
    inline void clear_GPR14_QTIMER3_TRM0_INPUT_SEL() volatile
    {
        GPR14 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR14's QTIMER3_TRM0_INPUT_SEL bit.
     *
     * QTIMER3 TMR0 input select
     */
    inline void toggle_GPR14_QTIMER3_TRM0_INPUT_SEL() volatile
    {
        GPR14 ^= 1u << 8u;
    }

    /**
     * Get GPR14's QTIMER3_TMR_CNTS_FREEZE bit.
     *
     * QTIMER3 timer counter freeze
     */
    inline bool get_GPR14_QTIMER3_TMR_CNTS_FREEZE() volatile
    {
        return GPR14 & (1u << 0u);
    }

    /**
     * Set GPR14's QTIMER3_TMR_CNTS_FREEZE bit.
     *
     * QTIMER3 timer counter freeze
     */
    inline void set_GPR14_QTIMER3_TMR_CNTS_FREEZE() volatile
    {
        GPR14 |= 1u << 0u;
    }

    /**
     * Clear GPR14's QTIMER3_TMR_CNTS_FREEZE bit.
     *
     * QTIMER3 timer counter freeze
     */
    inline void clear_GPR14_QTIMER3_TMR_CNTS_FREEZE() volatile
    {
        GPR14 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR14's QTIMER3_TMR_CNTS_FREEZE bit.
     *
     * QTIMER3 timer counter freeze
     */
    inline void toggle_GPR14_QTIMER3_TMR_CNTS_FREEZE() volatile
    {
        GPR14 ^= 1u << 0u;
    }

    /**
     * Get all of GPR14's bit fields.
     *
     * (read-write) GPR14 General Purpose Register
     */
    inline void get_GPR14(IOMUXC_GPR_GPR14_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR14_DWP &DWP,
                          bool &QTIMER3_TRM3_INPUT_SEL,
                          bool &QTIMER3_TRM2_INPUT_SEL,
                          bool &QTIMER3_TRM1_INPUT_SEL,
                          bool &QTIMER3_TRM0_INPUT_SEL,
                          bool &QTIMER3_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR14;

        DWP_LOCK = IOMUXC_GPR_GPR14_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR14_DWP((curr >> 28u) & 0b11u);
        QTIMER3_TRM3_INPUT_SEL = curr & (1u << 11u);
        QTIMER3_TRM2_INPUT_SEL = curr & (1u << 10u);
        QTIMER3_TRM1_INPUT_SEL = curr & (1u << 9u);
        QTIMER3_TRM0_INPUT_SEL = curr & (1u << 8u);
        QTIMER3_TMR_CNTS_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR14's bit fields.
     *
     * (read-write) GPR14 General Purpose Register
     */
    inline void set_GPR14(IOMUXC_GPR_GPR14_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR14_DWP DWP,
                          bool QTIMER3_TRM3_INPUT_SEL,
                          bool QTIMER3_TRM2_INPUT_SEL,
                          bool QTIMER3_TRM1_INPUT_SEL,
                          bool QTIMER3_TRM0_INPUT_SEL,
                          bool QTIMER3_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 11u);
        curr |= (QTIMER3_TRM3_INPUT_SEL & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (QTIMER3_TRM2_INPUT_SEL & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (QTIMER3_TRM1_INPUT_SEL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (QTIMER3_TRM0_INPUT_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (QTIMER3_TMR_CNTS_FREEZE & 0b1u) << 0u;

        GPR14 = curr;
    }

    /**
     * Get GPR15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR15_DWP_LOCK get_GPR15_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR15_DWP_LOCK((GPR15 >> 30u) & 0b11u);
    }

    /**
     * Set GPR15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR15_DWP_LOCK(IOMUXC_GPR_GPR15_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR15 = curr;
    }

    /**
     * Get GPR15's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR15_DWP get_GPR15_DWP() volatile
    {
        return IOMUXC_GPR_GPR15_DWP((GPR15 >> 28u) & 0b11u);
    }

    /**
     * Set GPR15's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR15_DWP(IOMUXC_GPR_GPR15_DWP value) volatile
    {
        uint32_t curr = GPR15;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR15 = curr;
    }

    /**
     * Get GPR15's QTIMER4_TRM3_INPUT_SEL bit.
     *
     * QTIMER4 TMR3 input select
     */
    inline bool get_GPR15_QTIMER4_TRM3_INPUT_SEL() volatile
    {
        return GPR15 & (1u << 11u);
    }

    /**
     * Set GPR15's QTIMER4_TRM3_INPUT_SEL bit.
     *
     * QTIMER4 TMR3 input select
     */
    inline void set_GPR15_QTIMER4_TRM3_INPUT_SEL() volatile
    {
        GPR15 |= 1u << 11u;
    }

    /**
     * Clear GPR15's QTIMER4_TRM3_INPUT_SEL bit.
     *
     * QTIMER4 TMR3 input select
     */
    inline void clear_GPR15_QTIMER4_TRM3_INPUT_SEL() volatile
    {
        GPR15 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR15's QTIMER4_TRM3_INPUT_SEL bit.
     *
     * QTIMER4 TMR3 input select
     */
    inline void toggle_GPR15_QTIMER4_TRM3_INPUT_SEL() volatile
    {
        GPR15 ^= 1u << 11u;
    }

    /**
     * Get GPR15's QTIMER4_TRM2_INPUT_SEL bit.
     *
     * QTIMER4 TMR2 input select
     */
    inline bool get_GPR15_QTIMER4_TRM2_INPUT_SEL() volatile
    {
        return GPR15 & (1u << 10u);
    }

    /**
     * Set GPR15's QTIMER4_TRM2_INPUT_SEL bit.
     *
     * QTIMER4 TMR2 input select
     */
    inline void set_GPR15_QTIMER4_TRM2_INPUT_SEL() volatile
    {
        GPR15 |= 1u << 10u;
    }

    /**
     * Clear GPR15's QTIMER4_TRM2_INPUT_SEL bit.
     *
     * QTIMER4 TMR2 input select
     */
    inline void clear_GPR15_QTIMER4_TRM2_INPUT_SEL() volatile
    {
        GPR15 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR15's QTIMER4_TRM2_INPUT_SEL bit.
     *
     * QTIMER4 TMR2 input select
     */
    inline void toggle_GPR15_QTIMER4_TRM2_INPUT_SEL() volatile
    {
        GPR15 ^= 1u << 10u;
    }

    /**
     * Get GPR15's QTIMER4_TRM1_INPUT_SEL bit.
     *
     * QTIMER4 TMR1 input select
     */
    inline bool get_GPR15_QTIMER4_TRM1_INPUT_SEL() volatile
    {
        return GPR15 & (1u << 9u);
    }

    /**
     * Set GPR15's QTIMER4_TRM1_INPUT_SEL bit.
     *
     * QTIMER4 TMR1 input select
     */
    inline void set_GPR15_QTIMER4_TRM1_INPUT_SEL() volatile
    {
        GPR15 |= 1u << 9u;
    }

    /**
     * Clear GPR15's QTIMER4_TRM1_INPUT_SEL bit.
     *
     * QTIMER4 TMR1 input select
     */
    inline void clear_GPR15_QTIMER4_TRM1_INPUT_SEL() volatile
    {
        GPR15 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR15's QTIMER4_TRM1_INPUT_SEL bit.
     *
     * QTIMER4 TMR1 input select
     */
    inline void toggle_GPR15_QTIMER4_TRM1_INPUT_SEL() volatile
    {
        GPR15 ^= 1u << 9u;
    }

    /**
     * Get GPR15's QTIMER4_TRM0_INPUT_SEL bit.
     *
     * QTIMER4 TMR0 input select
     */
    inline bool get_GPR15_QTIMER4_TRM0_INPUT_SEL() volatile
    {
        return GPR15 & (1u << 8u);
    }

    /**
     * Set GPR15's QTIMER4_TRM0_INPUT_SEL bit.
     *
     * QTIMER4 TMR0 input select
     */
    inline void set_GPR15_QTIMER4_TRM0_INPUT_SEL() volatile
    {
        GPR15 |= 1u << 8u;
    }

    /**
     * Clear GPR15's QTIMER4_TRM0_INPUT_SEL bit.
     *
     * QTIMER4 TMR0 input select
     */
    inline void clear_GPR15_QTIMER4_TRM0_INPUT_SEL() volatile
    {
        GPR15 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR15's QTIMER4_TRM0_INPUT_SEL bit.
     *
     * QTIMER4 TMR0 input select
     */
    inline void toggle_GPR15_QTIMER4_TRM0_INPUT_SEL() volatile
    {
        GPR15 ^= 1u << 8u;
    }

    /**
     * Get GPR15's QTIMER4_TMR_CNTS_FREEZE bit.
     *
     * QTIMER4 timer counter freeze
     */
    inline bool get_GPR15_QTIMER4_TMR_CNTS_FREEZE() volatile
    {
        return GPR15 & (1u << 0u);
    }

    /**
     * Set GPR15's QTIMER4_TMR_CNTS_FREEZE bit.
     *
     * QTIMER4 timer counter freeze
     */
    inline void set_GPR15_QTIMER4_TMR_CNTS_FREEZE() volatile
    {
        GPR15 |= 1u << 0u;
    }

    /**
     * Clear GPR15's QTIMER4_TMR_CNTS_FREEZE bit.
     *
     * QTIMER4 timer counter freeze
     */
    inline void clear_GPR15_QTIMER4_TMR_CNTS_FREEZE() volatile
    {
        GPR15 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR15's QTIMER4_TMR_CNTS_FREEZE bit.
     *
     * QTIMER4 timer counter freeze
     */
    inline void toggle_GPR15_QTIMER4_TMR_CNTS_FREEZE() volatile
    {
        GPR15 ^= 1u << 0u;
    }

    /**
     * Get all of GPR15's bit fields.
     *
     * (read-write) GPR15 General Purpose Register
     */
    inline void get_GPR15(IOMUXC_GPR_GPR15_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR15_DWP &DWP,
                          bool &QTIMER4_TRM3_INPUT_SEL,
                          bool &QTIMER4_TRM2_INPUT_SEL,
                          bool &QTIMER4_TRM1_INPUT_SEL,
                          bool &QTIMER4_TRM0_INPUT_SEL,
                          bool &QTIMER4_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR15;

        DWP_LOCK = IOMUXC_GPR_GPR15_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR15_DWP((curr >> 28u) & 0b11u);
        QTIMER4_TRM3_INPUT_SEL = curr & (1u << 11u);
        QTIMER4_TRM2_INPUT_SEL = curr & (1u << 10u);
        QTIMER4_TRM1_INPUT_SEL = curr & (1u << 9u);
        QTIMER4_TRM0_INPUT_SEL = curr & (1u << 8u);
        QTIMER4_TMR_CNTS_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR15's bit fields.
     *
     * (read-write) GPR15 General Purpose Register
     */
    inline void set_GPR15(IOMUXC_GPR_GPR15_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR15_DWP DWP,
                          bool QTIMER4_TRM3_INPUT_SEL,
                          bool QTIMER4_TRM2_INPUT_SEL,
                          bool QTIMER4_TRM1_INPUT_SEL,
                          bool QTIMER4_TRM0_INPUT_SEL,
                          bool QTIMER4_TMR_CNTS_FREEZE) volatile
    {
        uint32_t curr = GPR15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 11u);
        curr |= (QTIMER4_TRM3_INPUT_SEL & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (QTIMER4_TRM2_INPUT_SEL & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (QTIMER4_TRM1_INPUT_SEL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (QTIMER4_TRM0_INPUT_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (QTIMER4_TMR_CNTS_FREEZE & 0b1u) << 0u;

        GPR15 = curr;
    }

    /**
     * Get GPR16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR16_DWP_LOCK get_GPR16_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR16_DWP_LOCK((GPR16 >> 30u) & 0b11u);
    }

    /**
     * Set GPR16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR16_DWP_LOCK(IOMUXC_GPR_GPR16_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR16 = curr;
    }

    /**
     * Get GPR16's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR16_DWP get_GPR16_DWP() volatile
    {
        return IOMUXC_GPR_GPR16_DWP((GPR16 >> 28u) & 0b11u);
    }

    /**
     * Set GPR16's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR16_DWP(IOMUXC_GPR_GPR16_DWP value) volatile
    {
        uint32_t curr = GPR16;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR16 = curr;
    }

    /**
     * Get GPR16's M7_GPC_SLEEP_SEL bit.
     *
     * CM7 sleep request selection
     */
    inline bool get_GPR16_M7_GPC_SLEEP_SEL() volatile
    {
        return GPR16 & (1u << 5u);
    }

    /**
     * Set GPR16's M7_GPC_SLEEP_SEL bit.
     *
     * CM7 sleep request selection
     */
    inline void set_GPR16_M7_GPC_SLEEP_SEL() volatile
    {
        GPR16 |= 1u << 5u;
    }

    /**
     * Clear GPR16's M7_GPC_SLEEP_SEL bit.
     *
     * CM7 sleep request selection
     */
    inline void clear_GPR16_M7_GPC_SLEEP_SEL() volatile
    {
        GPR16 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR16's M7_GPC_SLEEP_SEL bit.
     *
     * CM7 sleep request selection
     */
    inline void toggle_GPR16_M7_GPC_SLEEP_SEL() volatile
    {
        GPR16 ^= 1u << 5u;
    }

    /**
     * Get GPR16's CM7_FORCE_HCLK_EN bit.
     *
     * CM7 platform AHB clock enable
     */
    inline bool get_GPR16_CM7_FORCE_HCLK_EN() volatile
    {
        return GPR16 & (1u << 3u);
    }

    /**
     * Set GPR16's CM7_FORCE_HCLK_EN bit.
     *
     * CM7 platform AHB clock enable
     */
    inline void set_GPR16_CM7_FORCE_HCLK_EN() volatile
    {
        GPR16 |= 1u << 3u;
    }

    /**
     * Clear GPR16's CM7_FORCE_HCLK_EN bit.
     *
     * CM7 platform AHB clock enable
     */
    inline void clear_GPR16_CM7_FORCE_HCLK_EN() volatile
    {
        GPR16 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR16's CM7_FORCE_HCLK_EN bit.
     *
     * CM7 platform AHB clock enable
     */
    inline void toggle_GPR16_CM7_FORCE_HCLK_EN() volatile
    {
        GPR16 ^= 1u << 3u;
    }

    /**
     * Get GPR16's FLEXRAM_BANK_CFG_SEL bit.
     *
     * FlexRAM bank config source select
     */
    inline bool get_GPR16_FLEXRAM_BANK_CFG_SEL() volatile
    {
        return GPR16 & (1u << 2u);
    }

    /**
     * Set GPR16's FLEXRAM_BANK_CFG_SEL bit.
     *
     * FlexRAM bank config source select
     */
    inline void set_GPR16_FLEXRAM_BANK_CFG_SEL() volatile
    {
        GPR16 |= 1u << 2u;
    }

    /**
     * Clear GPR16's FLEXRAM_BANK_CFG_SEL bit.
     *
     * FlexRAM bank config source select
     */
    inline void clear_GPR16_FLEXRAM_BANK_CFG_SEL() volatile
    {
        GPR16 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR16's FLEXRAM_BANK_CFG_SEL bit.
     *
     * FlexRAM bank config source select
     */
    inline void toggle_GPR16_FLEXRAM_BANK_CFG_SEL() volatile
    {
        GPR16 ^= 1u << 2u;
    }

    /**
     * Get all of GPR16's bit fields.
     *
     * (read-write) GPR16 General Purpose Register
     */
    inline void get_GPR16(IOMUXC_GPR_GPR16_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR16_DWP &DWP, bool &M7_GPC_SLEEP_SEL,
                          bool &CM7_FORCE_HCLK_EN,
                          bool &FLEXRAM_BANK_CFG_SEL) volatile
    {
        uint32_t curr = GPR16;

        DWP_LOCK = IOMUXC_GPR_GPR16_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR16_DWP((curr >> 28u) & 0b11u);
        M7_GPC_SLEEP_SEL = curr & (1u << 5u);
        CM7_FORCE_HCLK_EN = curr & (1u << 3u);
        FLEXRAM_BANK_CFG_SEL = curr & (1u << 2u);
    }

    /**
     * Set all of GPR16's bit fields.
     *
     * (read-write) GPR16 General Purpose Register
     */
    inline void set_GPR16(IOMUXC_GPR_GPR16_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR16_DWP DWP, bool M7_GPC_SLEEP_SEL,
                          bool CM7_FORCE_HCLK_EN,
                          bool FLEXRAM_BANK_CFG_SEL) volatile
    {
        uint32_t curr = GPR16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 5u);
        curr |= (M7_GPC_SLEEP_SEL & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (CM7_FORCE_HCLK_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FLEXRAM_BANK_CFG_SEL & 0b1u) << 2u;

        GPR16 = curr;
    }

    /**
     * Get GPR17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR17_DWP_LOCK get_GPR17_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR17_DWP_LOCK((GPR17 >> 30u) & 0b11u);
    }

    /**
     * Set GPR17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR17_DWP_LOCK(IOMUXC_GPR_GPR17_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR17 = curr;
    }

    /**
     * Get GPR17's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR17_DWP get_GPR17_DWP() volatile
    {
        return IOMUXC_GPR_GPR17_DWP((GPR17 >> 28u) & 0b11u);
    }

    /**
     * Set GPR17's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR17_DWP(IOMUXC_GPR_GPR17_DWP value) volatile
    {
        uint32_t curr = GPR17;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR17 = curr;
    }

    /**
     * Get GPR17's FLEXRAM_BANK_CFG_LOW field.
     *
     * FlexRAM bank config value
     */
    inline uint16_t get_GPR17_FLEXRAM_BANK_CFG_LOW() volatile
    {
        return (GPR17 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPR17's FLEXRAM_BANK_CFG_LOW field.
     *
     * FlexRAM bank config value
     */
    inline void set_GPR17_FLEXRAM_BANK_CFG_LOW(uint16_t value) volatile
    {
        uint32_t curr = GPR17;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPR17 = curr;
    }

    /**
     * Get all of GPR17's bit fields.
     *
     * (read-write) GPR17 General Purpose Register
     */
    inline void get_GPR17(IOMUXC_GPR_GPR17_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR17_DWP &DWP,
                          uint16_t &FLEXRAM_BANK_CFG_LOW) volatile
    {
        uint32_t curr = GPR17;

        DWP_LOCK = IOMUXC_GPR_GPR17_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR17_DWP((curr >> 28u) & 0b11u);
        FLEXRAM_BANK_CFG_LOW = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GPR17's bit fields.
     *
     * (read-write) GPR17 General Purpose Register
     */
    inline void set_GPR17(IOMUXC_GPR_GPR17_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR17_DWP DWP,
                          uint16_t FLEXRAM_BANK_CFG_LOW) volatile
    {
        uint32_t curr = GPR17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (FLEXRAM_BANK_CFG_LOW & 0b1111111111111111u) << 0u;

        GPR17 = curr;
    }

    /**
     * Get GPR18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR18_DWP_LOCK get_GPR18_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR18_DWP_LOCK((GPR18 >> 30u) & 0b11u);
    }

    /**
     * Set GPR18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR18_DWP_LOCK(IOMUXC_GPR_GPR18_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR18 = curr;
    }

    /**
     * Get GPR18's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR18_DWP get_GPR18_DWP() volatile
    {
        return IOMUXC_GPR_GPR18_DWP((GPR18 >> 28u) & 0b11u);
    }

    /**
     * Set GPR18's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR18_DWP(IOMUXC_GPR_GPR18_DWP value) volatile
    {
        uint32_t curr = GPR18;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR18 = curr;
    }

    /**
     * Get GPR18's FLEXRAM_BANK_CFG_HIGH field.
     *
     * FlexRAM bank config value
     */
    inline uint16_t get_GPR18_FLEXRAM_BANK_CFG_HIGH() volatile
    {
        return (GPR18 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPR18's FLEXRAM_BANK_CFG_HIGH field.
     *
     * FlexRAM bank config value
     */
    inline void set_GPR18_FLEXRAM_BANK_CFG_HIGH(uint16_t value) volatile
    {
        uint32_t curr = GPR18;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPR18 = curr;
    }

    /**
     * Get all of GPR18's bit fields.
     *
     * (read-write) GPR18 General Purpose Register
     */
    inline void get_GPR18(IOMUXC_GPR_GPR18_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR18_DWP &DWP,
                          uint16_t &FLEXRAM_BANK_CFG_HIGH) volatile
    {
        uint32_t curr = GPR18;

        DWP_LOCK = IOMUXC_GPR_GPR18_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR18_DWP((curr >> 28u) & 0b11u);
        FLEXRAM_BANK_CFG_HIGH = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GPR18's bit fields.
     *
     * (read-write) GPR18 General Purpose Register
     */
    inline void set_GPR18(IOMUXC_GPR_GPR18_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR18_DWP DWP,
                          uint16_t FLEXRAM_BANK_CFG_HIGH) volatile
    {
        uint32_t curr = GPR18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (FLEXRAM_BANK_CFG_HIGH & 0b1111111111111111u) << 0u;

        GPR18 = curr;
    }

    /**
     * Get GPR20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR20_DWP_LOCK get_GPR20_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR20_DWP_LOCK((GPR20 >> 30u) & 0b11u);
    }

    /**
     * Set GPR20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR20_DWP_LOCK(IOMUXC_GPR_GPR20_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR20 = curr;
    }

    /**
     * Get GPR20's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR20_DWP get_GPR20_DWP() volatile
    {
        return IOMUXC_GPR_GPR20_DWP((GPR20 >> 28u) & 0b11u);
    }

    /**
     * Set GPR20's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR20_DWP(IOMUXC_GPR_GPR20_DWP value) volatile
    {
        uint32_t curr = GPR20;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR20 = curr;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_31 bit.
     *
     * IOMUXC XBAR_INOUT31 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_31() volatile
    {
        return GPR20 & (1u << 27u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_31 bit.
     *
     * IOMUXC XBAR_INOUT31 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_31() volatile
    {
        GPR20 |= 1u << 27u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_31 bit.
     *
     * IOMUXC XBAR_INOUT31 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_31() volatile
    {
        GPR20 &= ~(1u << 27u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_31 bit.
     *
     * IOMUXC XBAR_INOUT31 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_31() volatile
    {
        GPR20 ^= 1u << 27u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_30 bit.
     *
     * IOMUXC XBAR_INOUT30 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_30() volatile
    {
        return GPR20 & (1u << 26u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_30 bit.
     *
     * IOMUXC XBAR_INOUT30 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_30() volatile
    {
        GPR20 |= 1u << 26u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_30 bit.
     *
     * IOMUXC XBAR_INOUT30 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_30() volatile
    {
        GPR20 &= ~(1u << 26u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_30 bit.
     *
     * IOMUXC XBAR_INOUT30 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_30() volatile
    {
        GPR20 ^= 1u << 26u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_29 bit.
     *
     * IOMUXC XBAR_INOUT29 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_29() volatile
    {
        return GPR20 & (1u << 25u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_29 bit.
     *
     * IOMUXC XBAR_INOUT29 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_29() volatile
    {
        GPR20 |= 1u << 25u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_29 bit.
     *
     * IOMUXC XBAR_INOUT29 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_29() volatile
    {
        GPR20 &= ~(1u << 25u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_29 bit.
     *
     * IOMUXC XBAR_INOUT29 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_29() volatile
    {
        GPR20 ^= 1u << 25u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_28 bit.
     *
     * IOMUXC XBAR_INOUT28 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_28() volatile
    {
        return GPR20 & (1u << 24u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_28 bit.
     *
     * IOMUXC XBAR_INOUT28 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_28() volatile
    {
        GPR20 |= 1u << 24u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_28 bit.
     *
     * IOMUXC XBAR_INOUT28 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_28() volatile
    {
        GPR20 &= ~(1u << 24u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_28 bit.
     *
     * IOMUXC XBAR_INOUT28 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_28() volatile
    {
        GPR20 ^= 1u << 24u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_27 bit.
     *
     * IOMUXC XBAR_INOUT27 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_27() volatile
    {
        return GPR20 & (1u << 23u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_27 bit.
     *
     * IOMUXC XBAR_INOUT27 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_27() volatile
    {
        GPR20 |= 1u << 23u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_27 bit.
     *
     * IOMUXC XBAR_INOUT27 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_27() volatile
    {
        GPR20 &= ~(1u << 23u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_27 bit.
     *
     * IOMUXC XBAR_INOUT27 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_27() volatile
    {
        GPR20 ^= 1u << 23u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_26 bit.
     *
     * IOMUXC XBAR_INOUT26 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_26() volatile
    {
        return GPR20 & (1u << 22u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_26 bit.
     *
     * IOMUXC XBAR_INOUT26 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_26() volatile
    {
        GPR20 |= 1u << 22u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_26 bit.
     *
     * IOMUXC XBAR_INOUT26 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_26() volatile
    {
        GPR20 &= ~(1u << 22u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_26 bit.
     *
     * IOMUXC XBAR_INOUT26 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_26() volatile
    {
        GPR20 ^= 1u << 22u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_25 bit.
     *
     * IOMUXC XBAR_INOUT25 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_25() volatile
    {
        return GPR20 & (1u << 21u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_25 bit.
     *
     * IOMUXC XBAR_INOUT25 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_25() volatile
    {
        GPR20 |= 1u << 21u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_25 bit.
     *
     * IOMUXC XBAR_INOUT25 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_25() volatile
    {
        GPR20 &= ~(1u << 21u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_25 bit.
     *
     * IOMUXC XBAR_INOUT25 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_25() volatile
    {
        GPR20 ^= 1u << 21u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_24 bit.
     *
     * IOMUXC XBAR_INOUT24 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_24() volatile
    {
        return GPR20 & (1u << 20u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_24 bit.
     *
     * IOMUXC XBAR_INOUT24 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_24() volatile
    {
        GPR20 |= 1u << 20u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_24 bit.
     *
     * IOMUXC XBAR_INOUT24 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_24() volatile
    {
        GPR20 &= ~(1u << 20u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_24 bit.
     *
     * IOMUXC XBAR_INOUT24 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_24() volatile
    {
        GPR20 ^= 1u << 20u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_23 bit.
     *
     * IOMUXC XBAR_INOUT23 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_23() volatile
    {
        return GPR20 & (1u << 19u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_23 bit.
     *
     * IOMUXC XBAR_INOUT23 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_23() volatile
    {
        GPR20 |= 1u << 19u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_23 bit.
     *
     * IOMUXC XBAR_INOUT23 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_23() volatile
    {
        GPR20 &= ~(1u << 19u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_23 bit.
     *
     * IOMUXC XBAR_INOUT23 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_23() volatile
    {
        GPR20 ^= 1u << 19u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_22 bit.
     *
     * IOMUXC XBAR_INOUT22 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_22() volatile
    {
        return GPR20 & (1u << 18u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_22 bit.
     *
     * IOMUXC XBAR_INOUT22 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_22() volatile
    {
        GPR20 |= 1u << 18u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_22 bit.
     *
     * IOMUXC XBAR_INOUT22 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_22() volatile
    {
        GPR20 &= ~(1u << 18u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_22 bit.
     *
     * IOMUXC XBAR_INOUT22 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_22() volatile
    {
        GPR20 ^= 1u << 18u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_21 bit.
     *
     * IOMUXC XBAR_INOUT21 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_21() volatile
    {
        return GPR20 & (1u << 17u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_21 bit.
     *
     * IOMUXC XBAR_INOUT21 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_21() volatile
    {
        GPR20 |= 1u << 17u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_21 bit.
     *
     * IOMUXC XBAR_INOUT21 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_21() volatile
    {
        GPR20 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_21 bit.
     *
     * IOMUXC XBAR_INOUT21 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_21() volatile
    {
        GPR20 ^= 1u << 17u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_20 bit.
     *
     * IOMUXC XBAR_INOUT20 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_20() volatile
    {
        return GPR20 & (1u << 16u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_20 bit.
     *
     * IOMUXC XBAR_INOUT20 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_20() volatile
    {
        GPR20 |= 1u << 16u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_20 bit.
     *
     * IOMUXC XBAR_INOUT20 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_20() volatile
    {
        GPR20 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_20 bit.
     *
     * IOMUXC XBAR_INOUT20 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_20() volatile
    {
        GPR20 ^= 1u << 16u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_19 bit.
     *
     * IOMUXC XBAR_INOUT19 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_19() volatile
    {
        return GPR20 & (1u << 15u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_19 bit.
     *
     * IOMUXC XBAR_INOUT19 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_19() volatile
    {
        GPR20 |= 1u << 15u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_19 bit.
     *
     * IOMUXC XBAR_INOUT19 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_19() volatile
    {
        GPR20 &= ~(1u << 15u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_19 bit.
     *
     * IOMUXC XBAR_INOUT19 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_19() volatile
    {
        GPR20 ^= 1u << 15u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_18 bit.
     *
     * IOMUXC XBAR_INOUT18 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_18() volatile
    {
        return GPR20 & (1u << 14u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_18 bit.
     *
     * IOMUXC XBAR_INOUT18 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_18() volatile
    {
        GPR20 |= 1u << 14u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_18 bit.
     *
     * IOMUXC XBAR_INOUT18 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_18() volatile
    {
        GPR20 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_18 bit.
     *
     * IOMUXC XBAR_INOUT18 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_18() volatile
    {
        GPR20 ^= 1u << 14u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_17 bit.
     *
     * IOMUXC XBAR_INOUT17 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_17() volatile
    {
        return GPR20 & (1u << 13u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_17 bit.
     *
     * IOMUXC XBAR_INOUT17 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_17() volatile
    {
        GPR20 |= 1u << 13u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_17 bit.
     *
     * IOMUXC XBAR_INOUT17 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_17() volatile
    {
        GPR20 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_17 bit.
     *
     * IOMUXC XBAR_INOUT17 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_17() volatile
    {
        GPR20 ^= 1u << 13u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_16 bit.
     *
     * IOMUXC XBAR_INOUT16 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_16() volatile
    {
        return GPR20 & (1u << 12u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_16 bit.
     *
     * IOMUXC XBAR_INOUT16 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_16() volatile
    {
        GPR20 |= 1u << 12u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_16 bit.
     *
     * IOMUXC XBAR_INOUT16 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_16() volatile
    {
        GPR20 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_16 bit.
     *
     * IOMUXC XBAR_INOUT16 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_16() volatile
    {
        GPR20 ^= 1u << 12u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_15 bit.
     *
     * IOMUXC XBAR_INOUT15 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_15() volatile
    {
        return GPR20 & (1u << 11u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_15 bit.
     *
     * IOMUXC XBAR_INOUT15 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_15() volatile
    {
        GPR20 |= 1u << 11u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_15 bit.
     *
     * IOMUXC XBAR_INOUT15 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_15() volatile
    {
        GPR20 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_15 bit.
     *
     * IOMUXC XBAR_INOUT15 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_15() volatile
    {
        GPR20 ^= 1u << 11u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_14 bit.
     *
     * IOMUXC XBAR_INOUT14 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_14() volatile
    {
        return GPR20 & (1u << 10u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_14 bit.
     *
     * IOMUXC XBAR_INOUT14 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_14() volatile
    {
        GPR20 |= 1u << 10u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_14 bit.
     *
     * IOMUXC XBAR_INOUT14 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_14() volatile
    {
        GPR20 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_14 bit.
     *
     * IOMUXC XBAR_INOUT14 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_14() volatile
    {
        GPR20 ^= 1u << 10u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_13 bit.
     *
     * IOMUXC XBAR_INOUT13 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_13() volatile
    {
        return GPR20 & (1u << 9u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_13 bit.
     *
     * IOMUXC XBAR_INOUT13 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_13() volatile
    {
        GPR20 |= 1u << 9u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_13 bit.
     *
     * IOMUXC XBAR_INOUT13 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_13() volatile
    {
        GPR20 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_13 bit.
     *
     * IOMUXC XBAR_INOUT13 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_13() volatile
    {
        GPR20 ^= 1u << 9u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_12 bit.
     *
     * IOMUXC XBAR_INOUT12 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_12() volatile
    {
        return GPR20 & (1u << 8u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_12 bit.
     *
     * IOMUXC XBAR_INOUT12 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_12() volatile
    {
        GPR20 |= 1u << 8u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_12 bit.
     *
     * IOMUXC XBAR_INOUT12 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_12() volatile
    {
        GPR20 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_12 bit.
     *
     * IOMUXC XBAR_INOUT12 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_12() volatile
    {
        GPR20 ^= 1u << 8u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_11 bit.
     *
     * IOMUXC XBAR_INOUT11 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_11() volatile
    {
        return GPR20 & (1u << 7u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_11 bit.
     *
     * IOMUXC XBAR_INOUT11 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_11() volatile
    {
        GPR20 |= 1u << 7u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_11 bit.
     *
     * IOMUXC XBAR_INOUT11 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_11() volatile
    {
        GPR20 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_11 bit.
     *
     * IOMUXC XBAR_INOUT11 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_11() volatile
    {
        GPR20 ^= 1u << 7u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_10 bit.
     *
     * IOMUXC XBAR_INOUT10 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_10() volatile
    {
        return GPR20 & (1u << 6u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_10 bit.
     *
     * IOMUXC XBAR_INOUT10 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_10() volatile
    {
        GPR20 |= 1u << 6u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_10 bit.
     *
     * IOMUXC XBAR_INOUT10 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_10() volatile
    {
        GPR20 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_10 bit.
     *
     * IOMUXC XBAR_INOUT10 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_10() volatile
    {
        GPR20 ^= 1u << 6u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_9 bit.
     *
     * IOMUXC XBAR_INOUT9 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_9() volatile
    {
        return GPR20 & (1u << 5u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_9 bit.
     *
     * IOMUXC XBAR_INOUT9 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_9() volatile
    {
        GPR20 |= 1u << 5u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_9 bit.
     *
     * IOMUXC XBAR_INOUT9 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_9() volatile
    {
        GPR20 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_9 bit.
     *
     * IOMUXC XBAR_INOUT9 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_9() volatile
    {
        GPR20 ^= 1u << 5u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_8 bit.
     *
     * IOMUXC XBAR_INOUT8 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_8() volatile
    {
        return GPR20 & (1u << 4u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_8 bit.
     *
     * IOMUXC XBAR_INOUT8 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_8() volatile
    {
        GPR20 |= 1u << 4u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_8 bit.
     *
     * IOMUXC XBAR_INOUT8 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_8() volatile
    {
        GPR20 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_8 bit.
     *
     * IOMUXC XBAR_INOUT8 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_8() volatile
    {
        GPR20 ^= 1u << 4u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_7 bit.
     *
     * IOMUXC XBAR_INOUT7 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_7() volatile
    {
        return GPR20 & (1u << 3u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_7 bit.
     *
     * IOMUXC XBAR_INOUT7 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_7() volatile
    {
        GPR20 |= 1u << 3u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_7 bit.
     *
     * IOMUXC XBAR_INOUT7 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_7() volatile
    {
        GPR20 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_7 bit.
     *
     * IOMUXC XBAR_INOUT7 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_7() volatile
    {
        GPR20 ^= 1u << 3u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_6 bit.
     *
     * IOMUXC XBAR_INOUT6 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_6() volatile
    {
        return GPR20 & (1u << 2u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_6 bit.
     *
     * IOMUXC XBAR_INOUT6 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_6() volatile
    {
        GPR20 |= 1u << 2u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_6 bit.
     *
     * IOMUXC XBAR_INOUT6 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_6() volatile
    {
        GPR20 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_6 bit.
     *
     * IOMUXC XBAR_INOUT6 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_6() volatile
    {
        GPR20 ^= 1u << 2u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_5 bit.
     *
     * IOMUXC XBAR_INOUT5 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_5() volatile
    {
        return GPR20 & (1u << 1u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_5 bit.
     *
     * IOMUXC XBAR_INOUT5 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_5() volatile
    {
        GPR20 |= 1u << 1u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_5 bit.
     *
     * IOMUXC XBAR_INOUT5 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_5() volatile
    {
        GPR20 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_5 bit.
     *
     * IOMUXC XBAR_INOUT5 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_5() volatile
    {
        GPR20 ^= 1u << 1u;
    }

    /**
     * Get GPR20's IOMUXC_XBAR_DIR_SEL_4 bit.
     *
     * IOMUXC XBAR_INOUT4 function direction select
     */
    inline bool get_GPR20_IOMUXC_XBAR_DIR_SEL_4() volatile
    {
        return GPR20 & (1u << 0u);
    }

    /**
     * Set GPR20's IOMUXC_XBAR_DIR_SEL_4 bit.
     *
     * IOMUXC XBAR_INOUT4 function direction select
     */
    inline void set_GPR20_IOMUXC_XBAR_DIR_SEL_4() volatile
    {
        GPR20 |= 1u << 0u;
    }

    /**
     * Clear GPR20's IOMUXC_XBAR_DIR_SEL_4 bit.
     *
     * IOMUXC XBAR_INOUT4 function direction select
     */
    inline void clear_GPR20_IOMUXC_XBAR_DIR_SEL_4() volatile
    {
        GPR20 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR20's IOMUXC_XBAR_DIR_SEL_4 bit.
     *
     * IOMUXC XBAR_INOUT4 function direction select
     */
    inline void toggle_GPR20_IOMUXC_XBAR_DIR_SEL_4() volatile
    {
        GPR20 ^= 1u << 0u;
    }

    /**
     * Get all of GPR20's bit fields.
     *
     * (read-write) GPR20 General Purpose Register
     */
    inline void get_GPR20(
        IOMUXC_GPR_GPR20_DWP_LOCK &DWP_LOCK, IOMUXC_GPR_GPR20_DWP &DWP,
        bool &IOMUXC_XBAR_DIR_SEL_31, bool &IOMUXC_XBAR_DIR_SEL_30,
        bool &IOMUXC_XBAR_DIR_SEL_29, bool &IOMUXC_XBAR_DIR_SEL_28,
        bool &IOMUXC_XBAR_DIR_SEL_27, bool &IOMUXC_XBAR_DIR_SEL_26,
        bool &IOMUXC_XBAR_DIR_SEL_25, bool &IOMUXC_XBAR_DIR_SEL_24,
        bool &IOMUXC_XBAR_DIR_SEL_23, bool &IOMUXC_XBAR_DIR_SEL_22,
        bool &IOMUXC_XBAR_DIR_SEL_21, bool &IOMUXC_XBAR_DIR_SEL_20,
        bool &IOMUXC_XBAR_DIR_SEL_19, bool &IOMUXC_XBAR_DIR_SEL_18,
        bool &IOMUXC_XBAR_DIR_SEL_17, bool &IOMUXC_XBAR_DIR_SEL_16,
        bool &IOMUXC_XBAR_DIR_SEL_15, bool &IOMUXC_XBAR_DIR_SEL_14,
        bool &IOMUXC_XBAR_DIR_SEL_13, bool &IOMUXC_XBAR_DIR_SEL_12,
        bool &IOMUXC_XBAR_DIR_SEL_11, bool &IOMUXC_XBAR_DIR_SEL_10,
        bool &IOMUXC_XBAR_DIR_SEL_9, bool &IOMUXC_XBAR_DIR_SEL_8,
        bool &IOMUXC_XBAR_DIR_SEL_7, bool &IOMUXC_XBAR_DIR_SEL_6,
        bool &IOMUXC_XBAR_DIR_SEL_5, bool &IOMUXC_XBAR_DIR_SEL_4) volatile
    {
        uint32_t curr = GPR20;

        DWP_LOCK = IOMUXC_GPR_GPR20_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR20_DWP((curr >> 28u) & 0b11u);
        IOMUXC_XBAR_DIR_SEL_31 = curr & (1u << 27u);
        IOMUXC_XBAR_DIR_SEL_30 = curr & (1u << 26u);
        IOMUXC_XBAR_DIR_SEL_29 = curr & (1u << 25u);
        IOMUXC_XBAR_DIR_SEL_28 = curr & (1u << 24u);
        IOMUXC_XBAR_DIR_SEL_27 = curr & (1u << 23u);
        IOMUXC_XBAR_DIR_SEL_26 = curr & (1u << 22u);
        IOMUXC_XBAR_DIR_SEL_25 = curr & (1u << 21u);
        IOMUXC_XBAR_DIR_SEL_24 = curr & (1u << 20u);
        IOMUXC_XBAR_DIR_SEL_23 = curr & (1u << 19u);
        IOMUXC_XBAR_DIR_SEL_22 = curr & (1u << 18u);
        IOMUXC_XBAR_DIR_SEL_21 = curr & (1u << 17u);
        IOMUXC_XBAR_DIR_SEL_20 = curr & (1u << 16u);
        IOMUXC_XBAR_DIR_SEL_19 = curr & (1u << 15u);
        IOMUXC_XBAR_DIR_SEL_18 = curr & (1u << 14u);
        IOMUXC_XBAR_DIR_SEL_17 = curr & (1u << 13u);
        IOMUXC_XBAR_DIR_SEL_16 = curr & (1u << 12u);
        IOMUXC_XBAR_DIR_SEL_15 = curr & (1u << 11u);
        IOMUXC_XBAR_DIR_SEL_14 = curr & (1u << 10u);
        IOMUXC_XBAR_DIR_SEL_13 = curr & (1u << 9u);
        IOMUXC_XBAR_DIR_SEL_12 = curr & (1u << 8u);
        IOMUXC_XBAR_DIR_SEL_11 = curr & (1u << 7u);
        IOMUXC_XBAR_DIR_SEL_10 = curr & (1u << 6u);
        IOMUXC_XBAR_DIR_SEL_9 = curr & (1u << 5u);
        IOMUXC_XBAR_DIR_SEL_8 = curr & (1u << 4u);
        IOMUXC_XBAR_DIR_SEL_7 = curr & (1u << 3u);
        IOMUXC_XBAR_DIR_SEL_6 = curr & (1u << 2u);
        IOMUXC_XBAR_DIR_SEL_5 = curr & (1u << 1u);
        IOMUXC_XBAR_DIR_SEL_4 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR20's bit fields.
     *
     * (read-write) GPR20 General Purpose Register
     */
    inline void set_GPR20(
        IOMUXC_GPR_GPR20_DWP_LOCK DWP_LOCK, IOMUXC_GPR_GPR20_DWP DWP,
        bool IOMUXC_XBAR_DIR_SEL_31, bool IOMUXC_XBAR_DIR_SEL_30,
        bool IOMUXC_XBAR_DIR_SEL_29, bool IOMUXC_XBAR_DIR_SEL_28,
        bool IOMUXC_XBAR_DIR_SEL_27, bool IOMUXC_XBAR_DIR_SEL_26,
        bool IOMUXC_XBAR_DIR_SEL_25, bool IOMUXC_XBAR_DIR_SEL_24,
        bool IOMUXC_XBAR_DIR_SEL_23, bool IOMUXC_XBAR_DIR_SEL_22,
        bool IOMUXC_XBAR_DIR_SEL_21, bool IOMUXC_XBAR_DIR_SEL_20,
        bool IOMUXC_XBAR_DIR_SEL_19, bool IOMUXC_XBAR_DIR_SEL_18,
        bool IOMUXC_XBAR_DIR_SEL_17, bool IOMUXC_XBAR_DIR_SEL_16,
        bool IOMUXC_XBAR_DIR_SEL_15, bool IOMUXC_XBAR_DIR_SEL_14,
        bool IOMUXC_XBAR_DIR_SEL_13, bool IOMUXC_XBAR_DIR_SEL_12,
        bool IOMUXC_XBAR_DIR_SEL_11, bool IOMUXC_XBAR_DIR_SEL_10,
        bool IOMUXC_XBAR_DIR_SEL_9, bool IOMUXC_XBAR_DIR_SEL_8,
        bool IOMUXC_XBAR_DIR_SEL_7, bool IOMUXC_XBAR_DIR_SEL_6,
        bool IOMUXC_XBAR_DIR_SEL_5, bool IOMUXC_XBAR_DIR_SEL_4) volatile
    {
        uint32_t curr = GPR20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (IOMUXC_XBAR_DIR_SEL_31 & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (IOMUXC_XBAR_DIR_SEL_30 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (IOMUXC_XBAR_DIR_SEL_29 & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (IOMUXC_XBAR_DIR_SEL_28 & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (IOMUXC_XBAR_DIR_SEL_27 & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (IOMUXC_XBAR_DIR_SEL_26 & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (IOMUXC_XBAR_DIR_SEL_25 & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (IOMUXC_XBAR_DIR_SEL_24 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (IOMUXC_XBAR_DIR_SEL_23 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (IOMUXC_XBAR_DIR_SEL_22 & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (IOMUXC_XBAR_DIR_SEL_21 & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (IOMUXC_XBAR_DIR_SEL_20 & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IOMUXC_XBAR_DIR_SEL_19 & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (IOMUXC_XBAR_DIR_SEL_18 & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (IOMUXC_XBAR_DIR_SEL_17 & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (IOMUXC_XBAR_DIR_SEL_16 & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (IOMUXC_XBAR_DIR_SEL_15 & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IOMUXC_XBAR_DIR_SEL_14 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IOMUXC_XBAR_DIR_SEL_13 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (IOMUXC_XBAR_DIR_SEL_12 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (IOMUXC_XBAR_DIR_SEL_11 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (IOMUXC_XBAR_DIR_SEL_10 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (IOMUXC_XBAR_DIR_SEL_9 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (IOMUXC_XBAR_DIR_SEL_8 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IOMUXC_XBAR_DIR_SEL_7 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (IOMUXC_XBAR_DIR_SEL_6 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IOMUXC_XBAR_DIR_SEL_5 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IOMUXC_XBAR_DIR_SEL_4 & 0b1u) << 0u;

        GPR20 = curr;
    }

    /**
     * Get GPR21's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR21_DWP_LOCK get_GPR21_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR21_DWP_LOCK((GPR21 >> 30u) & 0b11u);
    }

    /**
     * Set GPR21's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR21_DWP_LOCK(IOMUXC_GPR_GPR21_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR21;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR21 = curr;
    }

    /**
     * Get GPR21's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR21_DWP get_GPR21_DWP() volatile
    {
        return IOMUXC_GPR_GPR21_DWP((GPR21 >> 28u) & 0b11u);
    }

    /**
     * Set GPR21's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR21_DWP(IOMUXC_GPR_GPR21_DWP value) volatile
    {
        uint32_t curr = GPR21;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR21 = curr;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_42 bit.
     *
     * IOMUXC XBAR_INOUT42 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_42() volatile
    {
        return GPR21 & (1u << 10u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_42 bit.
     *
     * IOMUXC XBAR_INOUT42 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_42() volatile
    {
        GPR21 |= 1u << 10u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_42 bit.
     *
     * IOMUXC XBAR_INOUT42 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_42() volatile
    {
        GPR21 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_42 bit.
     *
     * IOMUXC XBAR_INOUT42 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_42() volatile
    {
        GPR21 ^= 1u << 10u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_41 bit.
     *
     * IOMUXC XBAR_INOUT41 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_41() volatile
    {
        return GPR21 & (1u << 9u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_41 bit.
     *
     * IOMUXC XBAR_INOUT41 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_41() volatile
    {
        GPR21 |= 1u << 9u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_41 bit.
     *
     * IOMUXC XBAR_INOUT41 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_41() volatile
    {
        GPR21 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_41 bit.
     *
     * IOMUXC XBAR_INOUT41 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_41() volatile
    {
        GPR21 ^= 1u << 9u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_40 bit.
     *
     * IOMUXC XBAR_INOUT40 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_40() volatile
    {
        return GPR21 & (1u << 8u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_40 bit.
     *
     * IOMUXC XBAR_INOUT40 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_40() volatile
    {
        GPR21 |= 1u << 8u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_40 bit.
     *
     * IOMUXC XBAR_INOUT40 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_40() volatile
    {
        GPR21 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_40 bit.
     *
     * IOMUXC XBAR_INOUT40 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_40() volatile
    {
        GPR21 ^= 1u << 8u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_39 bit.
     *
     * IOMUXC XBAR_INOUT39 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_39() volatile
    {
        return GPR21 & (1u << 7u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_39 bit.
     *
     * IOMUXC XBAR_INOUT39 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_39() volatile
    {
        GPR21 |= 1u << 7u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_39 bit.
     *
     * IOMUXC XBAR_INOUT39 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_39() volatile
    {
        GPR21 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_39 bit.
     *
     * IOMUXC XBAR_INOUT39 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_39() volatile
    {
        GPR21 ^= 1u << 7u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_38 bit.
     *
     * IOMUXC XBAR_INOUT38 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_38() volatile
    {
        return GPR21 & (1u << 6u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_38 bit.
     *
     * IOMUXC XBAR_INOUT38 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_38() volatile
    {
        GPR21 |= 1u << 6u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_38 bit.
     *
     * IOMUXC XBAR_INOUT38 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_38() volatile
    {
        GPR21 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_38 bit.
     *
     * IOMUXC XBAR_INOUT38 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_38() volatile
    {
        GPR21 ^= 1u << 6u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_37 bit.
     *
     * IOMUXC XBAR_INOUT37 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_37() volatile
    {
        return GPR21 & (1u << 5u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_37 bit.
     *
     * IOMUXC XBAR_INOUT37 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_37() volatile
    {
        GPR21 |= 1u << 5u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_37 bit.
     *
     * IOMUXC XBAR_INOUT37 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_37() volatile
    {
        GPR21 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_37 bit.
     *
     * IOMUXC XBAR_INOUT37 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_37() volatile
    {
        GPR21 ^= 1u << 5u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_36 bit.
     *
     * IOMUXC XBAR_INOUT36 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_36() volatile
    {
        return GPR21 & (1u << 4u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_36 bit.
     *
     * IOMUXC XBAR_INOUT36 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_36() volatile
    {
        GPR21 |= 1u << 4u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_36 bit.
     *
     * IOMUXC XBAR_INOUT36 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_36() volatile
    {
        GPR21 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_36 bit.
     *
     * IOMUXC XBAR_INOUT36 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_36() volatile
    {
        GPR21 ^= 1u << 4u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_35 bit.
     *
     * IOMUXC XBAR_INOUT35 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_35() volatile
    {
        return GPR21 & (1u << 3u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_35 bit.
     *
     * IOMUXC XBAR_INOUT35 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_35() volatile
    {
        GPR21 |= 1u << 3u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_35 bit.
     *
     * IOMUXC XBAR_INOUT35 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_35() volatile
    {
        GPR21 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_35 bit.
     *
     * IOMUXC XBAR_INOUT35 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_35() volatile
    {
        GPR21 ^= 1u << 3u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_34 bit.
     *
     * IOMUXC XBAR_INOUT34 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_34() volatile
    {
        return GPR21 & (1u << 2u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_34 bit.
     *
     * IOMUXC XBAR_INOUT34 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_34() volatile
    {
        GPR21 |= 1u << 2u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_34 bit.
     *
     * IOMUXC XBAR_INOUT34 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_34() volatile
    {
        GPR21 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_34 bit.
     *
     * IOMUXC XBAR_INOUT34 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_34() volatile
    {
        GPR21 ^= 1u << 2u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_33 bit.
     *
     * IOMUXC XBAR_INOUT33 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_33() volatile
    {
        return GPR21 & (1u << 1u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_33 bit.
     *
     * IOMUXC XBAR_INOUT33 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_33() volatile
    {
        GPR21 |= 1u << 1u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_33 bit.
     *
     * IOMUXC XBAR_INOUT33 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_33() volatile
    {
        GPR21 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_33 bit.
     *
     * IOMUXC XBAR_INOUT33 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_33() volatile
    {
        GPR21 ^= 1u << 1u;
    }

    /**
     * Get GPR21's IOMUXC_XBAR_DIR_SEL_32 bit.
     *
     * IOMUXC XBAR_INOUT32 function direction select
     */
    inline bool get_GPR21_IOMUXC_XBAR_DIR_SEL_32() volatile
    {
        return GPR21 & (1u << 0u);
    }

    /**
     * Set GPR21's IOMUXC_XBAR_DIR_SEL_32 bit.
     *
     * IOMUXC XBAR_INOUT32 function direction select
     */
    inline void set_GPR21_IOMUXC_XBAR_DIR_SEL_32() volatile
    {
        GPR21 |= 1u << 0u;
    }

    /**
     * Clear GPR21's IOMUXC_XBAR_DIR_SEL_32 bit.
     *
     * IOMUXC XBAR_INOUT32 function direction select
     */
    inline void clear_GPR21_IOMUXC_XBAR_DIR_SEL_32() volatile
    {
        GPR21 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR21's IOMUXC_XBAR_DIR_SEL_32 bit.
     *
     * IOMUXC XBAR_INOUT32 function direction select
     */
    inline void toggle_GPR21_IOMUXC_XBAR_DIR_SEL_32() volatile
    {
        GPR21 ^= 1u << 0u;
    }

    /**
     * Get all of GPR21's bit fields.
     *
     * (read-write) GPR21 General Purpose Register
     */
    inline void get_GPR21(
        IOMUXC_GPR_GPR21_DWP_LOCK &DWP_LOCK, IOMUXC_GPR_GPR21_DWP &DWP,
        bool &IOMUXC_XBAR_DIR_SEL_42, bool &IOMUXC_XBAR_DIR_SEL_41,
        bool &IOMUXC_XBAR_DIR_SEL_40, bool &IOMUXC_XBAR_DIR_SEL_39,
        bool &IOMUXC_XBAR_DIR_SEL_38, bool &IOMUXC_XBAR_DIR_SEL_37,
        bool &IOMUXC_XBAR_DIR_SEL_36, bool &IOMUXC_XBAR_DIR_SEL_35,
        bool &IOMUXC_XBAR_DIR_SEL_34, bool &IOMUXC_XBAR_DIR_SEL_33,
        bool &IOMUXC_XBAR_DIR_SEL_32) volatile
    {
        uint32_t curr = GPR21;

        DWP_LOCK = IOMUXC_GPR_GPR21_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR21_DWP((curr >> 28u) & 0b11u);
        IOMUXC_XBAR_DIR_SEL_42 = curr & (1u << 10u);
        IOMUXC_XBAR_DIR_SEL_41 = curr & (1u << 9u);
        IOMUXC_XBAR_DIR_SEL_40 = curr & (1u << 8u);
        IOMUXC_XBAR_DIR_SEL_39 = curr & (1u << 7u);
        IOMUXC_XBAR_DIR_SEL_38 = curr & (1u << 6u);
        IOMUXC_XBAR_DIR_SEL_37 = curr & (1u << 5u);
        IOMUXC_XBAR_DIR_SEL_36 = curr & (1u << 4u);
        IOMUXC_XBAR_DIR_SEL_35 = curr & (1u << 3u);
        IOMUXC_XBAR_DIR_SEL_34 = curr & (1u << 2u);
        IOMUXC_XBAR_DIR_SEL_33 = curr & (1u << 1u);
        IOMUXC_XBAR_DIR_SEL_32 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR21's bit fields.
     *
     * (read-write) GPR21 General Purpose Register
     */
    inline void set_GPR21(
        IOMUXC_GPR_GPR21_DWP_LOCK DWP_LOCK, IOMUXC_GPR_GPR21_DWP DWP,
        bool IOMUXC_XBAR_DIR_SEL_42, bool IOMUXC_XBAR_DIR_SEL_41,
        bool IOMUXC_XBAR_DIR_SEL_40, bool IOMUXC_XBAR_DIR_SEL_39,
        bool IOMUXC_XBAR_DIR_SEL_38, bool IOMUXC_XBAR_DIR_SEL_37,
        bool IOMUXC_XBAR_DIR_SEL_36, bool IOMUXC_XBAR_DIR_SEL_35,
        bool IOMUXC_XBAR_DIR_SEL_34, bool IOMUXC_XBAR_DIR_SEL_33,
        bool IOMUXC_XBAR_DIR_SEL_32) volatile
    {
        uint32_t curr = GPR21;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 10u);
        curr |= (IOMUXC_XBAR_DIR_SEL_42 & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IOMUXC_XBAR_DIR_SEL_41 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (IOMUXC_XBAR_DIR_SEL_40 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (IOMUXC_XBAR_DIR_SEL_39 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (IOMUXC_XBAR_DIR_SEL_38 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (IOMUXC_XBAR_DIR_SEL_37 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (IOMUXC_XBAR_DIR_SEL_36 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IOMUXC_XBAR_DIR_SEL_35 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (IOMUXC_XBAR_DIR_SEL_34 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IOMUXC_XBAR_DIR_SEL_33 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IOMUXC_XBAR_DIR_SEL_32 & 0b1u) << 0u;

        GPR21 = curr;
    }

    /**
     * Get GPR22's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR22_DWP_LOCK get_GPR22_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR22_DWP_LOCK((GPR22 >> 30u) & 0b11u);
    }

    /**
     * Set GPR22's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR22_DWP_LOCK(IOMUXC_GPR_GPR22_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR22;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR22 = curr;
    }

    /**
     * Get GPR22's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR22_DWP get_GPR22_DWP() volatile
    {
        return IOMUXC_GPR_GPR22_DWP((GPR22 >> 28u) & 0b11u);
    }

    /**
     * Set GPR22's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR22_DWP(IOMUXC_GPR_GPR22_DWP value) volatile
    {
        uint32_t curr = GPR22;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR22 = curr;
    }

    /**
     * Get GPR22's REF_1M_CLK_GPT1 bit.
     *
     * GPT1 1 MHz clock source select
     */
    inline bool get_GPR22_REF_1M_CLK_GPT1() volatile
    {
        return GPR22 & (1u << 0u);
    }

    /**
     * Set GPR22's REF_1M_CLK_GPT1 bit.
     *
     * GPT1 1 MHz clock source select
     */
    inline void set_GPR22_REF_1M_CLK_GPT1() volatile
    {
        GPR22 |= 1u << 0u;
    }

    /**
     * Clear GPR22's REF_1M_CLK_GPT1 bit.
     *
     * GPT1 1 MHz clock source select
     */
    inline void clear_GPR22_REF_1M_CLK_GPT1() volatile
    {
        GPR22 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR22's REF_1M_CLK_GPT1 bit.
     *
     * GPT1 1 MHz clock source select
     */
    inline void toggle_GPR22_REF_1M_CLK_GPT1() volatile
    {
        GPR22 ^= 1u << 0u;
    }

    /**
     * Get all of GPR22's bit fields.
     *
     * (read-write) GPR22 General Purpose Register
     */
    inline void get_GPR22(IOMUXC_GPR_GPR22_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR22_DWP &DWP,
                          bool &REF_1M_CLK_GPT1) volatile
    {
        uint32_t curr = GPR22;

        DWP_LOCK = IOMUXC_GPR_GPR22_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR22_DWP((curr >> 28u) & 0b11u);
        REF_1M_CLK_GPT1 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR22's bit fields.
     *
     * (read-write) GPR22 General Purpose Register
     */
    inline void set_GPR22(IOMUXC_GPR_GPR22_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR22_DWP DWP,
                          bool REF_1M_CLK_GPT1) volatile
    {
        uint32_t curr = GPR22;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (REF_1M_CLK_GPT1 & 0b1u) << 0u;

        GPR22 = curr;
    }

    /**
     * Get GPR23's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR23_DWP_LOCK get_GPR23_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR23_DWP_LOCK((GPR23 >> 30u) & 0b11u);
    }

    /**
     * Set GPR23's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR23_DWP_LOCK(IOMUXC_GPR_GPR23_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR23;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR23 = curr;
    }

    /**
     * Get GPR23's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR23_DWP get_GPR23_DWP() volatile
    {
        return IOMUXC_GPR_GPR23_DWP((GPR23 >> 28u) & 0b11u);
    }

    /**
     * Set GPR23's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR23_DWP(IOMUXC_GPR_GPR23_DWP value) volatile
    {
        uint32_t curr = GPR23;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR23 = curr;
    }

    /**
     * Get GPR23's GPT2_CAPIN2_SEL bit.
     *
     * GPT2 input capture channel 2 source select
     */
    inline bool get_GPR23_GPT2_CAPIN2_SEL() volatile
    {
        return GPR23 & (1u << 2u);
    }

    /**
     * Set GPR23's GPT2_CAPIN2_SEL bit.
     *
     * GPT2 input capture channel 2 source select
     */
    inline void set_GPR23_GPT2_CAPIN2_SEL() volatile
    {
        GPR23 |= 1u << 2u;
    }

    /**
     * Clear GPR23's GPT2_CAPIN2_SEL bit.
     *
     * GPT2 input capture channel 2 source select
     */
    inline void clear_GPR23_GPT2_CAPIN2_SEL() volatile
    {
        GPR23 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR23's GPT2_CAPIN2_SEL bit.
     *
     * GPT2 input capture channel 2 source select
     */
    inline void toggle_GPR23_GPT2_CAPIN2_SEL() volatile
    {
        GPR23 ^= 1u << 2u;
    }

    /**
     * Get GPR23's GPT2_CAPIN1_SEL bit.
     *
     * GPT2 input capture channel 1 source select
     */
    inline bool get_GPR23_GPT2_CAPIN1_SEL() volatile
    {
        return GPR23 & (1u << 1u);
    }

    /**
     * Set GPR23's GPT2_CAPIN1_SEL bit.
     *
     * GPT2 input capture channel 1 source select
     */
    inline void set_GPR23_GPT2_CAPIN1_SEL() volatile
    {
        GPR23 |= 1u << 1u;
    }

    /**
     * Clear GPR23's GPT2_CAPIN1_SEL bit.
     *
     * GPT2 input capture channel 1 source select
     */
    inline void clear_GPR23_GPT2_CAPIN1_SEL() volatile
    {
        GPR23 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR23's GPT2_CAPIN1_SEL bit.
     *
     * GPT2 input capture channel 1 source select
     */
    inline void toggle_GPR23_GPT2_CAPIN1_SEL() volatile
    {
        GPR23 ^= 1u << 1u;
    }

    /**
     * Get GPR23's REF_1M_CLK_GPT2 bit.
     *
     * GPT2 1 MHz clock source select
     */
    inline bool get_GPR23_REF_1M_CLK_GPT2() volatile
    {
        return GPR23 & (1u << 0u);
    }

    /**
     * Set GPR23's REF_1M_CLK_GPT2 bit.
     *
     * GPT2 1 MHz clock source select
     */
    inline void set_GPR23_REF_1M_CLK_GPT2() volatile
    {
        GPR23 |= 1u << 0u;
    }

    /**
     * Clear GPR23's REF_1M_CLK_GPT2 bit.
     *
     * GPT2 1 MHz clock source select
     */
    inline void clear_GPR23_REF_1M_CLK_GPT2() volatile
    {
        GPR23 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR23's REF_1M_CLK_GPT2 bit.
     *
     * GPT2 1 MHz clock source select
     */
    inline void toggle_GPR23_REF_1M_CLK_GPT2() volatile
    {
        GPR23 ^= 1u << 0u;
    }

    /**
     * Get all of GPR23's bit fields.
     *
     * (read-write) GPR23 General Purpose Register
     */
    inline void get_GPR23(IOMUXC_GPR_GPR23_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR23_DWP &DWP, bool &GPT2_CAPIN2_SEL,
                          bool &GPT2_CAPIN1_SEL,
                          bool &REF_1M_CLK_GPT2) volatile
    {
        uint32_t curr = GPR23;

        DWP_LOCK = IOMUXC_GPR_GPR23_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR23_DWP((curr >> 28u) & 0b11u);
        GPT2_CAPIN2_SEL = curr & (1u << 2u);
        GPT2_CAPIN1_SEL = curr & (1u << 1u);
        REF_1M_CLK_GPT2 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR23's bit fields.
     *
     * (read-write) GPR23 General Purpose Register
     */
    inline void set_GPR23(IOMUXC_GPR_GPR23_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR23_DWP DWP, bool GPT2_CAPIN2_SEL,
                          bool GPT2_CAPIN1_SEL, bool REF_1M_CLK_GPT2) volatile
    {
        uint32_t curr = GPR23;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 2u);
        curr |= (GPT2_CAPIN2_SEL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPT2_CAPIN1_SEL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REF_1M_CLK_GPT2 & 0b1u) << 0u;

        GPR23 = curr;
    }

    /**
     * Get GPR24's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR24_DWP_LOCK get_GPR24_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR24_DWP_LOCK((GPR24 >> 30u) & 0b11u);
    }

    /**
     * Set GPR24's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR24_DWP_LOCK(IOMUXC_GPR_GPR24_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR24;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR24 = curr;
    }

    /**
     * Get GPR24's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR24_DWP get_GPR24_DWP() volatile
    {
        return IOMUXC_GPR_GPR24_DWP((GPR24 >> 28u) & 0b11u);
    }

    /**
     * Set GPR24's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR24_DWP(IOMUXC_GPR_GPR24_DWP value) volatile
    {
        uint32_t curr = GPR24;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR24 = curr;
    }

    /**
     * Get GPR24's GPT3_CAPIN1_SEL bit.
     *
     * GPT3 input capture channel 1 source select
     */
    inline bool get_GPR24_GPT3_CAPIN1_SEL() volatile
    {
        return GPR24 & (1u << 1u);
    }

    /**
     * Set GPR24's GPT3_CAPIN1_SEL bit.
     *
     * GPT3 input capture channel 1 source select
     */
    inline void set_GPR24_GPT3_CAPIN1_SEL() volatile
    {
        GPR24 |= 1u << 1u;
    }

    /**
     * Clear GPR24's GPT3_CAPIN1_SEL bit.
     *
     * GPT3 input capture channel 1 source select
     */
    inline void clear_GPR24_GPT3_CAPIN1_SEL() volatile
    {
        GPR24 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR24's GPT3_CAPIN1_SEL bit.
     *
     * GPT3 input capture channel 1 source select
     */
    inline void toggle_GPR24_GPT3_CAPIN1_SEL() volatile
    {
        GPR24 ^= 1u << 1u;
    }

    /**
     * Get GPR24's REF_1M_CLK_GPT3 bit.
     *
     * GPT3 1 MHz clock source select
     */
    inline bool get_GPR24_REF_1M_CLK_GPT3() volatile
    {
        return GPR24 & (1u << 0u);
    }

    /**
     * Set GPR24's REF_1M_CLK_GPT3 bit.
     *
     * GPT3 1 MHz clock source select
     */
    inline void set_GPR24_REF_1M_CLK_GPT3() volatile
    {
        GPR24 |= 1u << 0u;
    }

    /**
     * Clear GPR24's REF_1M_CLK_GPT3 bit.
     *
     * GPT3 1 MHz clock source select
     */
    inline void clear_GPR24_REF_1M_CLK_GPT3() volatile
    {
        GPR24 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR24's REF_1M_CLK_GPT3 bit.
     *
     * GPT3 1 MHz clock source select
     */
    inline void toggle_GPR24_REF_1M_CLK_GPT3() volatile
    {
        GPR24 ^= 1u << 0u;
    }

    /**
     * Get all of GPR24's bit fields.
     *
     * (read-write) GPR24 General Purpose Register
     */
    inline void get_GPR24(IOMUXC_GPR_GPR24_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR24_DWP &DWP, bool &GPT3_CAPIN1_SEL,
                          bool &REF_1M_CLK_GPT3) volatile
    {
        uint32_t curr = GPR24;

        DWP_LOCK = IOMUXC_GPR_GPR24_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR24_DWP((curr >> 28u) & 0b11u);
        GPT3_CAPIN1_SEL = curr & (1u << 1u);
        REF_1M_CLK_GPT3 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR24's bit fields.
     *
     * (read-write) GPR24 General Purpose Register
     */
    inline void set_GPR24(IOMUXC_GPR_GPR24_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR24_DWP DWP, bool GPT3_CAPIN1_SEL,
                          bool REF_1M_CLK_GPT3) volatile
    {
        uint32_t curr = GPR24;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 1u);
        curr |= (GPT3_CAPIN1_SEL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REF_1M_CLK_GPT3 & 0b1u) << 0u;

        GPR24 = curr;
    }

    /**
     * Get GPR25's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR25_DWP_LOCK get_GPR25_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR25_DWP_LOCK((GPR25 >> 30u) & 0b11u);
    }

    /**
     * Set GPR25's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR25_DWP_LOCK(IOMUXC_GPR_GPR25_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR25;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR25 = curr;
    }

    /**
     * Get GPR25's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR25_DWP get_GPR25_DWP() volatile
    {
        return IOMUXC_GPR_GPR25_DWP((GPR25 >> 28u) & 0b11u);
    }

    /**
     * Set GPR25's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR25_DWP(IOMUXC_GPR_GPR25_DWP value) volatile
    {
        uint32_t curr = GPR25;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR25 = curr;
    }

    /**
     * Get GPR25's REF_1M_CLK_GPT4 bit.
     *
     * GPT4 1 MHz clock source select
     */
    inline bool get_GPR25_REF_1M_CLK_GPT4() volatile
    {
        return GPR25 & (1u << 0u);
    }

    /**
     * Set GPR25's REF_1M_CLK_GPT4 bit.
     *
     * GPT4 1 MHz clock source select
     */
    inline void set_GPR25_REF_1M_CLK_GPT4() volatile
    {
        GPR25 |= 1u << 0u;
    }

    /**
     * Clear GPR25's REF_1M_CLK_GPT4 bit.
     *
     * GPT4 1 MHz clock source select
     */
    inline void clear_GPR25_REF_1M_CLK_GPT4() volatile
    {
        GPR25 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR25's REF_1M_CLK_GPT4 bit.
     *
     * GPT4 1 MHz clock source select
     */
    inline void toggle_GPR25_REF_1M_CLK_GPT4() volatile
    {
        GPR25 ^= 1u << 0u;
    }

    /**
     * Get all of GPR25's bit fields.
     *
     * (read-write) GPR25 General Purpose Register
     */
    inline void get_GPR25(IOMUXC_GPR_GPR25_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR25_DWP &DWP,
                          bool &REF_1M_CLK_GPT4) volatile
    {
        uint32_t curr = GPR25;

        DWP_LOCK = IOMUXC_GPR_GPR25_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR25_DWP((curr >> 28u) & 0b11u);
        REF_1M_CLK_GPT4 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR25's bit fields.
     *
     * (read-write) GPR25 General Purpose Register
     */
    inline void set_GPR25(IOMUXC_GPR_GPR25_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR25_DWP DWP,
                          bool REF_1M_CLK_GPT4) volatile
    {
        uint32_t curr = GPR25;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (REF_1M_CLK_GPT4 & 0b1u) << 0u;

        GPR25 = curr;
    }

    /**
     * Get GPR26's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR26_DWP_LOCK get_GPR26_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR26_DWP_LOCK((GPR26 >> 30u) & 0b11u);
    }

    /**
     * Set GPR26's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR26_DWP_LOCK(IOMUXC_GPR_GPR26_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR26;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR26 = curr;
    }

    /**
     * Get GPR26's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR26_DWP get_GPR26_DWP() volatile
    {
        return IOMUXC_GPR_GPR26_DWP((GPR26 >> 28u) & 0b11u);
    }

    /**
     * Set GPR26's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR26_DWP(IOMUXC_GPR_GPR26_DWP value) volatile
    {
        uint32_t curr = GPR26;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR26 = curr;
    }

    /**
     * Get GPR26's REF_1M_CLK_GPT5 bit.
     *
     * GPT5 1 MHz clock source select
     */
    inline bool get_GPR26_REF_1M_CLK_GPT5() volatile
    {
        return GPR26 & (1u << 0u);
    }

    /**
     * Set GPR26's REF_1M_CLK_GPT5 bit.
     *
     * GPT5 1 MHz clock source select
     */
    inline void set_GPR26_REF_1M_CLK_GPT5() volatile
    {
        GPR26 |= 1u << 0u;
    }

    /**
     * Clear GPR26's REF_1M_CLK_GPT5 bit.
     *
     * GPT5 1 MHz clock source select
     */
    inline void clear_GPR26_REF_1M_CLK_GPT5() volatile
    {
        GPR26 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR26's REF_1M_CLK_GPT5 bit.
     *
     * GPT5 1 MHz clock source select
     */
    inline void toggle_GPR26_REF_1M_CLK_GPT5() volatile
    {
        GPR26 ^= 1u << 0u;
    }

    /**
     * Get all of GPR26's bit fields.
     *
     * (read-write) GPR26 General Purpose Register
     */
    inline void get_GPR26(IOMUXC_GPR_GPR26_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR26_DWP &DWP,
                          bool &REF_1M_CLK_GPT5) volatile
    {
        uint32_t curr = GPR26;

        DWP_LOCK = IOMUXC_GPR_GPR26_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR26_DWP((curr >> 28u) & 0b11u);
        REF_1M_CLK_GPT5 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR26's bit fields.
     *
     * (read-write) GPR26 General Purpose Register
     */
    inline void set_GPR26(IOMUXC_GPR_GPR26_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR26_DWP DWP,
                          bool REF_1M_CLK_GPT5) volatile
    {
        uint32_t curr = GPR26;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (REF_1M_CLK_GPT5 & 0b1u) << 0u;

        GPR26 = curr;
    }

    /**
     * Get GPR27's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR27_DWP_LOCK get_GPR27_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR27_DWP_LOCK((GPR27 >> 30u) & 0b11u);
    }

    /**
     * Set GPR27's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR27_DWP_LOCK(IOMUXC_GPR_GPR27_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR27;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR27 = curr;
    }

    /**
     * Get GPR27's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR27_DWP get_GPR27_DWP() volatile
    {
        return IOMUXC_GPR_GPR27_DWP((GPR27 >> 28u) & 0b11u);
    }

    /**
     * Set GPR27's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR27_DWP(IOMUXC_GPR_GPR27_DWP value) volatile
    {
        uint32_t curr = GPR27;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR27 = curr;
    }

    /**
     * Get GPR27's REF_1M_CLK_GPT6 bit.
     *
     * GPT6 1 MHz clock source select
     */
    inline bool get_GPR27_REF_1M_CLK_GPT6() volatile
    {
        return GPR27 & (1u << 0u);
    }

    /**
     * Set GPR27's REF_1M_CLK_GPT6 bit.
     *
     * GPT6 1 MHz clock source select
     */
    inline void set_GPR27_REF_1M_CLK_GPT6() volatile
    {
        GPR27 |= 1u << 0u;
    }

    /**
     * Clear GPR27's REF_1M_CLK_GPT6 bit.
     *
     * GPT6 1 MHz clock source select
     */
    inline void clear_GPR27_REF_1M_CLK_GPT6() volatile
    {
        GPR27 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR27's REF_1M_CLK_GPT6 bit.
     *
     * GPT6 1 MHz clock source select
     */
    inline void toggle_GPR27_REF_1M_CLK_GPT6() volatile
    {
        GPR27 ^= 1u << 0u;
    }

    /**
     * Get all of GPR27's bit fields.
     *
     * (read-write) GPR27 General Purpose Register
     */
    inline void get_GPR27(IOMUXC_GPR_GPR27_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR27_DWP &DWP,
                          bool &REF_1M_CLK_GPT6) volatile
    {
        uint32_t curr = GPR27;

        DWP_LOCK = IOMUXC_GPR_GPR27_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR27_DWP((curr >> 28u) & 0b11u);
        REF_1M_CLK_GPT6 = curr & (1u << 0u);
    }

    /**
     * Set all of GPR27's bit fields.
     *
     * (read-write) GPR27 General Purpose Register
     */
    inline void set_GPR27(IOMUXC_GPR_GPR27_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR27_DWP DWP,
                          bool REF_1M_CLK_GPT6) volatile
    {
        uint32_t curr = GPR27;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (REF_1M_CLK_GPT6 & 0b1u) << 0u;

        GPR27 = curr;
    }

    /**
     * Get GPR28's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR28_DWP_LOCK get_GPR28_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR28_DWP_LOCK((GPR28 >> 30u) & 0b11u);
    }

    /**
     * Set GPR28's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR28_DWP_LOCK(IOMUXC_GPR_GPR28_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR28;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR28 = curr;
    }

    /**
     * Get GPR28's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR28_DWP get_GPR28_DWP() volatile
    {
        return IOMUXC_GPR_GPR28_DWP((GPR28 >> 28u) & 0b11u);
    }

    /**
     * Set GPR28's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR28_DWP(IOMUXC_GPR_GPR28_DWP value) volatile
    {
        uint32_t curr = GPR28;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR28 = curr;
    }

    /**
     * Get GPR28's CACHE_USB bit.
     *
     * USB block cacheable attribute value of AXI transactions
     */
    inline bool get_GPR28_CACHE_USB() volatile
    {
        return GPR28 & (1u << 13u);
    }

    /**
     * Set GPR28's CACHE_USB bit.
     *
     * USB block cacheable attribute value of AXI transactions
     */
    inline void set_GPR28_CACHE_USB() volatile
    {
        GPR28 |= 1u << 13u;
    }

    /**
     * Clear GPR28's CACHE_USB bit.
     *
     * USB block cacheable attribute value of AXI transactions
     */
    inline void clear_GPR28_CACHE_USB() volatile
    {
        GPR28 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR28's CACHE_USB bit.
     *
     * USB block cacheable attribute value of AXI transactions
     */
    inline void toggle_GPR28_CACHE_USB() volatile
    {
        GPR28 ^= 1u << 13u;
    }

    /**
     * Get GPR28's CACHE_ENET bit.
     *
     * ENET block cacheable attribute value of AXI transactions
     */
    inline bool get_GPR28_CACHE_ENET() volatile
    {
        return GPR28 & (1u << 7u);
    }

    /**
     * Set GPR28's CACHE_ENET bit.
     *
     * ENET block cacheable attribute value of AXI transactions
     */
    inline void set_GPR28_CACHE_ENET() volatile
    {
        GPR28 |= 1u << 7u;
    }

    /**
     * Clear GPR28's CACHE_ENET bit.
     *
     * ENET block cacheable attribute value of AXI transactions
     */
    inline void clear_GPR28_CACHE_ENET() volatile
    {
        GPR28 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR28's CACHE_ENET bit.
     *
     * ENET block cacheable attribute value of AXI transactions
     */
    inline void toggle_GPR28_CACHE_ENET() volatile
    {
        GPR28 ^= 1u << 7u;
    }

    /**
     * Get GPR28's CACHE_ENET1G bit.
     *
     * no description available
     */
    inline bool get_GPR28_CACHE_ENET1G() volatile
    {
        return GPR28 & (1u << 5u);
    }

    /**
     * Set GPR28's CACHE_ENET1G bit.
     *
     * no description available
     */
    inline void set_GPR28_CACHE_ENET1G() volatile
    {
        GPR28 |= 1u << 5u;
    }

    /**
     * Clear GPR28's CACHE_ENET1G bit.
     *
     * no description available
     */
    inline void clear_GPR28_CACHE_ENET1G() volatile
    {
        GPR28 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR28's CACHE_ENET1G bit.
     *
     * no description available
     */
    inline void toggle_GPR28_CACHE_ENET1G() volatile
    {
        GPR28 ^= 1u << 5u;
    }

    /**
     * Get GPR28's AWCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI write transactions
     */
    inline bool get_GPR28_AWCACHE_USDHC() volatile
    {
        return GPR28 & (1u << 1u);
    }

    /**
     * Set GPR28's AWCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI write transactions
     */
    inline void set_GPR28_AWCACHE_USDHC() volatile
    {
        GPR28 |= 1u << 1u;
    }

    /**
     * Clear GPR28's AWCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI write transactions
     */
    inline void clear_GPR28_AWCACHE_USDHC() volatile
    {
        GPR28 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR28's AWCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI write transactions
     */
    inline void toggle_GPR28_AWCACHE_USDHC() volatile
    {
        GPR28 ^= 1u << 1u;
    }

    /**
     * Get GPR28's ARCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI read transactions
     */
    inline bool get_GPR28_ARCACHE_USDHC() volatile
    {
        return GPR28 & (1u << 0u);
    }

    /**
     * Set GPR28's ARCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI read transactions
     */
    inline void set_GPR28_ARCACHE_USDHC() volatile
    {
        GPR28 |= 1u << 0u;
    }

    /**
     * Clear GPR28's ARCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI read transactions
     */
    inline void clear_GPR28_ARCACHE_USDHC() volatile
    {
        GPR28 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR28's ARCACHE_USDHC bit.
     *
     * uSDHC block cacheable attribute value of AXI read transactions
     */
    inline void toggle_GPR28_ARCACHE_USDHC() volatile
    {
        GPR28 ^= 1u << 0u;
    }

    /**
     * Get all of GPR28's bit fields.
     *
     * (read-write) GPR28 General Purpose Register
     */
    inline void get_GPR28(IOMUXC_GPR_GPR28_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR28_DWP &DWP, bool &CACHE_USB,
                          bool &CACHE_ENET, bool &CACHE_ENET1G,
                          bool &AWCACHE_USDHC, bool &ARCACHE_USDHC) volatile
    {
        uint32_t curr = GPR28;

        DWP_LOCK = IOMUXC_GPR_GPR28_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR28_DWP((curr >> 28u) & 0b11u);
        CACHE_USB = curr & (1u << 13u);
        CACHE_ENET = curr & (1u << 7u);
        CACHE_ENET1G = curr & (1u << 5u);
        AWCACHE_USDHC = curr & (1u << 1u);
        ARCACHE_USDHC = curr & (1u << 0u);
    }

    /**
     * Set all of GPR28's bit fields.
     *
     * (read-write) GPR28 General Purpose Register
     */
    inline void set_GPR28(IOMUXC_GPR_GPR28_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR28_DWP DWP, bool CACHE_USB,
                          bool CACHE_ENET, bool CACHE_ENET1G,
                          bool AWCACHE_USDHC, bool ARCACHE_USDHC) volatile
    {
        uint32_t curr = GPR28;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 13u);
        curr |= (CACHE_USB & 0b1u) << 13u;
        curr &= ~(0b1u << 7u);
        curr |= (CACHE_ENET & 0b1u) << 7u;
        curr &= ~(0b1u << 5u);
        curr |= (CACHE_ENET1G & 0b1u) << 5u;
        curr &= ~(0b1u << 1u);
        curr |= (AWCACHE_USDHC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ARCACHE_USDHC & 0b1u) << 0u;

        GPR28 = curr;
    }

    /**
     * Get GPR29's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR29_DWP_LOCK get_GPR29_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR29_DWP_LOCK((GPR29 >> 30u) & 0b11u);
    }

    /**
     * Set GPR29's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR29_DWP_LOCK(IOMUXC_GPR_GPR29_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR29;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR29 = curr;
    }

    /**
     * Get GPR29's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR29_DWP get_GPR29_DWP() volatile
    {
        return IOMUXC_GPR_GPR29_DWP((GPR29 >> 28u) & 0b11u);
    }

    /**
     * Set GPR29's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR29_DWP(IOMUXC_GPR_GPR29_DWP value) volatile
    {
        uint32_t curr = GPR29;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR29 = curr;
    }

    /**
     * Get GPR29's USBPHY1_IPG_CLK_ACTIVE bit.
     *
     * USBPHY1 register access clock enable
     */
    inline bool get_GPR29_USBPHY1_IPG_CLK_ACTIVE() volatile
    {
        return GPR29 & (1u << 0u);
    }

    /**
     * Set GPR29's USBPHY1_IPG_CLK_ACTIVE bit.
     *
     * USBPHY1 register access clock enable
     */
    inline void set_GPR29_USBPHY1_IPG_CLK_ACTIVE() volatile
    {
        GPR29 |= 1u << 0u;
    }

    /**
     * Clear GPR29's USBPHY1_IPG_CLK_ACTIVE bit.
     *
     * USBPHY1 register access clock enable
     */
    inline void clear_GPR29_USBPHY1_IPG_CLK_ACTIVE() volatile
    {
        GPR29 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR29's USBPHY1_IPG_CLK_ACTIVE bit.
     *
     * USBPHY1 register access clock enable
     */
    inline void toggle_GPR29_USBPHY1_IPG_CLK_ACTIVE() volatile
    {
        GPR29 ^= 1u << 0u;
    }

    /**
     * Get all of GPR29's bit fields.
     *
     * (read-write) GPR29 General Purpose Register
     */
    inline void get_GPR29(IOMUXC_GPR_GPR29_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR29_DWP &DWP,
                          bool &USBPHY1_IPG_CLK_ACTIVE) volatile
    {
        uint32_t curr = GPR29;

        DWP_LOCK = IOMUXC_GPR_GPR29_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR29_DWP((curr >> 28u) & 0b11u);
        USBPHY1_IPG_CLK_ACTIVE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR29's bit fields.
     *
     * (read-write) GPR29 General Purpose Register
     */
    inline void set_GPR29(IOMUXC_GPR_GPR29_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR29_DWP DWP,
                          bool USBPHY1_IPG_CLK_ACTIVE) volatile
    {
        uint32_t curr = GPR29;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (USBPHY1_IPG_CLK_ACTIVE & 0b1u) << 0u;

        GPR29 = curr;
    }

    /**
     * Get GPR30's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR30_DWP_LOCK get_GPR30_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR30_DWP_LOCK((GPR30 >> 30u) & 0b11u);
    }

    /**
     * Set GPR30's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR30_DWP_LOCK(IOMUXC_GPR_GPR30_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR30;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR30 = curr;
    }

    /**
     * Get GPR30's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR30_DWP get_GPR30_DWP() volatile
    {
        return IOMUXC_GPR_GPR30_DWP((GPR30 >> 28u) & 0b11u);
    }

    /**
     * Set GPR30's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR30_DWP(IOMUXC_GPR_GPR30_DWP value) volatile
    {
        uint32_t curr = GPR30;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR30 = curr;
    }

    /**
     * Get GPR30's USBPHY2_IPG_CLK_ACTIVE bit.
     *
     * USBPHY2 register access clock enable
     */
    inline bool get_GPR30_USBPHY2_IPG_CLK_ACTIVE() volatile
    {
        return GPR30 & (1u << 0u);
    }

    /**
     * Set GPR30's USBPHY2_IPG_CLK_ACTIVE bit.
     *
     * USBPHY2 register access clock enable
     */
    inline void set_GPR30_USBPHY2_IPG_CLK_ACTIVE() volatile
    {
        GPR30 |= 1u << 0u;
    }

    /**
     * Clear GPR30's USBPHY2_IPG_CLK_ACTIVE bit.
     *
     * USBPHY2 register access clock enable
     */
    inline void clear_GPR30_USBPHY2_IPG_CLK_ACTIVE() volatile
    {
        GPR30 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR30's USBPHY2_IPG_CLK_ACTIVE bit.
     *
     * USBPHY2 register access clock enable
     */
    inline void toggle_GPR30_USBPHY2_IPG_CLK_ACTIVE() volatile
    {
        GPR30 ^= 1u << 0u;
    }

    /**
     * Get all of GPR30's bit fields.
     *
     * (read-write) GPR30 General Purpose Register
     */
    inline void get_GPR30(IOMUXC_GPR_GPR30_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR30_DWP &DWP,
                          bool &USBPHY2_IPG_CLK_ACTIVE) volatile
    {
        uint32_t curr = GPR30;

        DWP_LOCK = IOMUXC_GPR_GPR30_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR30_DWP((curr >> 28u) & 0b11u);
        USBPHY2_IPG_CLK_ACTIVE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR30's bit fields.
     *
     * (read-write) GPR30 General Purpose Register
     */
    inline void set_GPR30(IOMUXC_GPR_GPR30_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR30_DWP DWP,
                          bool USBPHY2_IPG_CLK_ACTIVE) volatile
    {
        uint32_t curr = GPR30;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (USBPHY2_IPG_CLK_ACTIVE & 0b1u) << 0u;

        GPR30 = curr;
    }

    /**
     * Get GPR31's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR31_DWP_LOCK get_GPR31_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR31_DWP_LOCK((GPR31 >> 30u) & 0b11u);
    }

    /**
     * Set GPR31's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR31_DWP_LOCK(IOMUXC_GPR_GPR31_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR31;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR31 = curr;
    }

    /**
     * Get GPR31's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR31_DWP get_GPR31_DWP() volatile
    {
        return IOMUXC_GPR_GPR31_DWP((GPR31 >> 28u) & 0b11u);
    }

    /**
     * Set GPR31's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR31_DWP(IOMUXC_GPR_GPR31_DWP value) volatile
    {
        uint32_t curr = GPR31;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR31 = curr;
    }

    /**
     * Get GPR31's OCRAM_M7_CLK_GATING bit.
     *
     * OCRAM M7 clock gating enable
     */
    inline bool get_GPR31_OCRAM_M7_CLK_GATING() volatile
    {
        return GPR31 & (1u << 2u);
    }

    /**
     * Set GPR31's OCRAM_M7_CLK_GATING bit.
     *
     * OCRAM M7 clock gating enable
     */
    inline void set_GPR31_OCRAM_M7_CLK_GATING() volatile
    {
        GPR31 |= 1u << 2u;
    }

    /**
     * Clear GPR31's OCRAM_M7_CLK_GATING bit.
     *
     * OCRAM M7 clock gating enable
     */
    inline void clear_GPR31_OCRAM_M7_CLK_GATING() volatile
    {
        GPR31 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR31's OCRAM_M7_CLK_GATING bit.
     *
     * OCRAM M7 clock gating enable
     */
    inline void toggle_GPR31_OCRAM_M7_CLK_GATING() volatile
    {
        GPR31 ^= 1u << 2u;
    }

    /**
     * Get GPR31's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM M7 RMW wait enable
     */
    inline bool get_GPR31_RMW2_WAIT_BVALID_CPL() volatile
    {
        return GPR31 & (1u << 0u);
    }

    /**
     * Set GPR31's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM M7 RMW wait enable
     */
    inline void set_GPR31_RMW2_WAIT_BVALID_CPL() volatile
    {
        GPR31 |= 1u << 0u;
    }

    /**
     * Clear GPR31's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM M7 RMW wait enable
     */
    inline void clear_GPR31_RMW2_WAIT_BVALID_CPL() volatile
    {
        GPR31 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR31's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM M7 RMW wait enable
     */
    inline void toggle_GPR31_RMW2_WAIT_BVALID_CPL() volatile
    {
        GPR31 ^= 1u << 0u;
    }

    /**
     * Get all of GPR31's bit fields.
     *
     * (read-write) GPR31 General Purpose Register
     */
    inline void get_GPR31(IOMUXC_GPR_GPR31_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR31_DWP &DWP, bool &OCRAM_M7_CLK_GATING,
                          bool &RMW2_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR31;

        DWP_LOCK = IOMUXC_GPR_GPR31_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR31_DWP((curr >> 28u) & 0b11u);
        OCRAM_M7_CLK_GATING = curr & (1u << 2u);
        RMW2_WAIT_BVALID_CPL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR31's bit fields.
     *
     * (read-write) GPR31 General Purpose Register
     */
    inline void set_GPR31(IOMUXC_GPR_GPR31_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR31_DWP DWP, bool OCRAM_M7_CLK_GATING,
                          bool RMW2_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR31;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 2u);
        curr |= (OCRAM_M7_CLK_GATING & 0b1u) << 2u;
        curr &= ~(0b1u << 0u);
        curr |= (RMW2_WAIT_BVALID_CPL & 0b1u) << 0u;

        GPR31 = curr;
    }

    /**
     * Get GPR32's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR32_DWP_LOCK get_GPR32_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR32_DWP_LOCK((GPR32 >> 30u) & 0b11u);
    }

    /**
     * Set GPR32's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR32_DWP_LOCK(IOMUXC_GPR_GPR32_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR32;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR32 = curr;
    }

    /**
     * Get GPR32's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR32_DWP get_GPR32_DWP() volatile
    {
        return IOMUXC_GPR_GPR32_DWP((GPR32 >> 28u) & 0b11u);
    }

    /**
     * Set GPR32's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR32_DWP(IOMUXC_GPR_GPR32_DWP value) volatile
    {
        uint32_t curr = GPR32;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR32 = curr;
    }

    /**
     * Get GPR32's RMW1_WAIT_BVALID_CPL bit.
     *
     * OCRAM1 RMW wait enable
     */
    inline bool get_GPR32_RMW1_WAIT_BVALID_CPL() volatile
    {
        return GPR32 & (1u << 0u);
    }

    /**
     * Set GPR32's RMW1_WAIT_BVALID_CPL bit.
     *
     * OCRAM1 RMW wait enable
     */
    inline void set_GPR32_RMW1_WAIT_BVALID_CPL() volatile
    {
        GPR32 |= 1u << 0u;
    }

    /**
     * Clear GPR32's RMW1_WAIT_BVALID_CPL bit.
     *
     * OCRAM1 RMW wait enable
     */
    inline void clear_GPR32_RMW1_WAIT_BVALID_CPL() volatile
    {
        GPR32 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR32's RMW1_WAIT_BVALID_CPL bit.
     *
     * OCRAM1 RMW wait enable
     */
    inline void toggle_GPR32_RMW1_WAIT_BVALID_CPL() volatile
    {
        GPR32 ^= 1u << 0u;
    }

    /**
     * Get all of GPR32's bit fields.
     *
     * (read-write) GPR32 General Purpose Register
     */
    inline void get_GPR32(IOMUXC_GPR_GPR32_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR32_DWP &DWP,
                          bool &RMW1_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR32;

        DWP_LOCK = IOMUXC_GPR_GPR32_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR32_DWP((curr >> 28u) & 0b11u);
        RMW1_WAIT_BVALID_CPL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR32's bit fields.
     *
     * (read-write) GPR32 General Purpose Register
     */
    inline void set_GPR32(IOMUXC_GPR_GPR32_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR32_DWP DWP,
                          bool RMW1_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR32;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (RMW1_WAIT_BVALID_CPL & 0b1u) << 0u;

        GPR32 = curr;
    }

    /**
     * Get GPR33's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR33_DWP_LOCK get_GPR33_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR33_DWP_LOCK((GPR33 >> 30u) & 0b11u);
    }

    /**
     * Set GPR33's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR33_DWP_LOCK(IOMUXC_GPR_GPR33_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR33;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR33 = curr;
    }

    /**
     * Get GPR33's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR33_DWP get_GPR33_DWP() volatile
    {
        return IOMUXC_GPR_GPR33_DWP((GPR33 >> 28u) & 0b11u);
    }

    /**
     * Set GPR33's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR33_DWP(IOMUXC_GPR_GPR33_DWP value) volatile
    {
        uint32_t curr = GPR33;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR33 = curr;
    }

    /**
     * Get GPR33's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM2 RMW wait enable
     */
    inline bool get_GPR33_RMW2_WAIT_BVALID_CPL() volatile
    {
        return GPR33 & (1u << 0u);
    }

    /**
     * Set GPR33's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM2 RMW wait enable
     */
    inline void set_GPR33_RMW2_WAIT_BVALID_CPL() volatile
    {
        GPR33 |= 1u << 0u;
    }

    /**
     * Clear GPR33's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM2 RMW wait enable
     */
    inline void clear_GPR33_RMW2_WAIT_BVALID_CPL() volatile
    {
        GPR33 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR33's RMW2_WAIT_BVALID_CPL bit.
     *
     * OCRAM2 RMW wait enable
     */
    inline void toggle_GPR33_RMW2_WAIT_BVALID_CPL() volatile
    {
        GPR33 ^= 1u << 0u;
    }

    /**
     * Get all of GPR33's bit fields.
     *
     * (read-write) GPR33 General Purpose Register
     */
    inline void get_GPR33(IOMUXC_GPR_GPR33_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR33_DWP &DWP,
                          bool &RMW2_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR33;

        DWP_LOCK = IOMUXC_GPR_GPR33_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR33_DWP((curr >> 28u) & 0b11u);
        RMW2_WAIT_BVALID_CPL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR33's bit fields.
     *
     * (read-write) GPR33 General Purpose Register
     */
    inline void set_GPR33(IOMUXC_GPR_GPR33_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR33_DWP DWP,
                          bool RMW2_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR33;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (RMW2_WAIT_BVALID_CPL & 0b1u) << 0u;

        GPR33 = curr;
    }

    /**
     * Get GPR34's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR34_DWP_LOCK get_GPR34_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR34_DWP_LOCK((GPR34 >> 30u) & 0b11u);
    }

    /**
     * Set GPR34's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR34_DWP_LOCK(IOMUXC_GPR_GPR34_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR34;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR34 = curr;
    }

    /**
     * Get GPR34's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR34_DWP get_GPR34_DWP() volatile
    {
        return IOMUXC_GPR_GPR34_DWP((GPR34 >> 28u) & 0b11u);
    }

    /**
     * Set GPR34's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR34_DWP(IOMUXC_GPR_GPR34_DWP value) volatile
    {
        uint32_t curr = GPR34;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR34 = curr;
    }

    /**
     * Get GPR34's FLEXSPI1_OTFAD_EN bit.
     *
     * FlexSPI1 OTFAD enable
     */
    inline bool get_GPR34_FLEXSPI1_OTFAD_EN() volatile
    {
        return GPR34 & (1u << 1u);
    }

    /**
     * Set GPR34's FLEXSPI1_OTFAD_EN bit.
     *
     * FlexSPI1 OTFAD enable
     */
    inline void set_GPR34_FLEXSPI1_OTFAD_EN() volatile
    {
        GPR34 |= 1u << 1u;
    }

    /**
     * Clear GPR34's FLEXSPI1_OTFAD_EN bit.
     *
     * FlexSPI1 OTFAD enable
     */
    inline void clear_GPR34_FLEXSPI1_OTFAD_EN() volatile
    {
        GPR34 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR34's FLEXSPI1_OTFAD_EN bit.
     *
     * FlexSPI1 OTFAD enable
     */
    inline void toggle_GPR34_FLEXSPI1_OTFAD_EN() volatile
    {
        GPR34 ^= 1u << 1u;
    }

    /**
     * Get GPR34's XECC_FLEXSPI1_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI1 RMW wait enable
     */
    inline bool get_GPR34_XECC_FLEXSPI1_WAIT_BVALID_CPL() volatile
    {
        return GPR34 & (1u << 0u);
    }

    /**
     * Set GPR34's XECC_FLEXSPI1_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI1 RMW wait enable
     */
    inline void set_GPR34_XECC_FLEXSPI1_WAIT_BVALID_CPL() volatile
    {
        GPR34 |= 1u << 0u;
    }

    /**
     * Clear GPR34's XECC_FLEXSPI1_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI1 RMW wait enable
     */
    inline void clear_GPR34_XECC_FLEXSPI1_WAIT_BVALID_CPL() volatile
    {
        GPR34 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR34's XECC_FLEXSPI1_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI1 RMW wait enable
     */
    inline void toggle_GPR34_XECC_FLEXSPI1_WAIT_BVALID_CPL() volatile
    {
        GPR34 ^= 1u << 0u;
    }

    /**
     * Get all of GPR34's bit fields.
     *
     * (read-write) GPR34 General Purpose Register
     */
    inline void get_GPR34(IOMUXC_GPR_GPR34_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR34_DWP &DWP, bool &FLEXSPI1_OTFAD_EN,
                          bool &XECC_FLEXSPI1_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR34;

        DWP_LOCK = IOMUXC_GPR_GPR34_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR34_DWP((curr >> 28u) & 0b11u);
        FLEXSPI1_OTFAD_EN = curr & (1u << 1u);
        XECC_FLEXSPI1_WAIT_BVALID_CPL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR34's bit fields.
     *
     * (read-write) GPR34 General Purpose Register
     */
    inline void set_GPR34(IOMUXC_GPR_GPR34_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR34_DWP DWP, bool FLEXSPI1_OTFAD_EN,
                          bool XECC_FLEXSPI1_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR34;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 1u);
        curr |= (FLEXSPI1_OTFAD_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (XECC_FLEXSPI1_WAIT_BVALID_CPL & 0b1u) << 0u;

        GPR34 = curr;
    }

    /**
     * Get GPR35's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR35_DWP_LOCK get_GPR35_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR35_DWP_LOCK((GPR35 >> 30u) & 0b11u);
    }

    /**
     * Set GPR35's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR35_DWP_LOCK(IOMUXC_GPR_GPR35_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR35;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR35 = curr;
    }

    /**
     * Get GPR35's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR35_DWP get_GPR35_DWP() volatile
    {
        return IOMUXC_GPR_GPR35_DWP((GPR35 >> 28u) & 0b11u);
    }

    /**
     * Set GPR35's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR35_DWP(IOMUXC_GPR_GPR35_DWP value) volatile
    {
        uint32_t curr = GPR35;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR35 = curr;
    }

    /**
     * Get GPR35's FLEXSPI2_OTFAD_EN bit.
     *
     * FlexSPI2 OTFAD enable
     */
    inline bool get_GPR35_FLEXSPI2_OTFAD_EN() volatile
    {
        return GPR35 & (1u << 1u);
    }

    /**
     * Set GPR35's FLEXSPI2_OTFAD_EN bit.
     *
     * FlexSPI2 OTFAD enable
     */
    inline void set_GPR35_FLEXSPI2_OTFAD_EN() volatile
    {
        GPR35 |= 1u << 1u;
    }

    /**
     * Clear GPR35's FLEXSPI2_OTFAD_EN bit.
     *
     * FlexSPI2 OTFAD enable
     */
    inline void clear_GPR35_FLEXSPI2_OTFAD_EN() volatile
    {
        GPR35 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR35's FLEXSPI2_OTFAD_EN bit.
     *
     * FlexSPI2 OTFAD enable
     */
    inline void toggle_GPR35_FLEXSPI2_OTFAD_EN() volatile
    {
        GPR35 ^= 1u << 1u;
    }

    /**
     * Get GPR35's XECC_FLEXSPI2_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI2 RMW wait enable
     */
    inline bool get_GPR35_XECC_FLEXSPI2_WAIT_BVALID_CPL() volatile
    {
        return GPR35 & (1u << 0u);
    }

    /**
     * Set GPR35's XECC_FLEXSPI2_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI2 RMW wait enable
     */
    inline void set_GPR35_XECC_FLEXSPI2_WAIT_BVALID_CPL() volatile
    {
        GPR35 |= 1u << 0u;
    }

    /**
     * Clear GPR35's XECC_FLEXSPI2_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI2 RMW wait enable
     */
    inline void clear_GPR35_XECC_FLEXSPI2_WAIT_BVALID_CPL() volatile
    {
        GPR35 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR35's XECC_FLEXSPI2_WAIT_BVALID_CPL bit.
     *
     * XECC_FLEXSPI2 RMW wait enable
     */
    inline void toggle_GPR35_XECC_FLEXSPI2_WAIT_BVALID_CPL() volatile
    {
        GPR35 ^= 1u << 0u;
    }

    /**
     * Get all of GPR35's bit fields.
     *
     * (read-write) GPR35 General Purpose Register
     */
    inline void get_GPR35(IOMUXC_GPR_GPR35_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR35_DWP &DWP, bool &FLEXSPI2_OTFAD_EN,
                          bool &XECC_FLEXSPI2_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR35;

        DWP_LOCK = IOMUXC_GPR_GPR35_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR35_DWP((curr >> 28u) & 0b11u);
        FLEXSPI2_OTFAD_EN = curr & (1u << 1u);
        XECC_FLEXSPI2_WAIT_BVALID_CPL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR35's bit fields.
     *
     * (read-write) GPR35 General Purpose Register
     */
    inline void set_GPR35(IOMUXC_GPR_GPR35_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR35_DWP DWP, bool FLEXSPI2_OTFAD_EN,
                          bool XECC_FLEXSPI2_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR35;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 1u);
        curr |= (FLEXSPI2_OTFAD_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (XECC_FLEXSPI2_WAIT_BVALID_CPL & 0b1u) << 0u;

        GPR35 = curr;
    }

    /**
     * Get GPR36's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR36_DWP_LOCK get_GPR36_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR36_DWP_LOCK((GPR36 >> 30u) & 0b11u);
    }

    /**
     * Set GPR36's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR36_DWP_LOCK(IOMUXC_GPR_GPR36_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR36;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR36 = curr;
    }

    /**
     * Get GPR36's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR36_DWP get_GPR36_DWP() volatile
    {
        return IOMUXC_GPR_GPR36_DWP((GPR36 >> 28u) & 0b11u);
    }

    /**
     * Set GPR36's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR36_DWP(IOMUXC_GPR_GPR36_DWP value) volatile
    {
        uint32_t curr = GPR36;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR36 = curr;
    }

    /**
     * Get GPR36's XECC_SEMC_WAIT_BVALID_CPL bit.
     *
     * XECC_SEMC RMW wait enable
     */
    inline bool get_GPR36_XECC_SEMC_WAIT_BVALID_CPL() volatile
    {
        return GPR36 & (1u << 0u);
    }

    /**
     * Set GPR36's XECC_SEMC_WAIT_BVALID_CPL bit.
     *
     * XECC_SEMC RMW wait enable
     */
    inline void set_GPR36_XECC_SEMC_WAIT_BVALID_CPL() volatile
    {
        GPR36 |= 1u << 0u;
    }

    /**
     * Clear GPR36's XECC_SEMC_WAIT_BVALID_CPL bit.
     *
     * XECC_SEMC RMW wait enable
     */
    inline void clear_GPR36_XECC_SEMC_WAIT_BVALID_CPL() volatile
    {
        GPR36 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR36's XECC_SEMC_WAIT_BVALID_CPL bit.
     *
     * XECC_SEMC RMW wait enable
     */
    inline void toggle_GPR36_XECC_SEMC_WAIT_BVALID_CPL() volatile
    {
        GPR36 ^= 1u << 0u;
    }

    /**
     * Get all of GPR36's bit fields.
     *
     * (read-write) GPR36 General Purpose Register
     */
    inline void get_GPR36(IOMUXC_GPR_GPR36_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR36_DWP &DWP,
                          bool &XECC_SEMC_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR36;

        DWP_LOCK = IOMUXC_GPR_GPR36_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR36_DWP((curr >> 28u) & 0b11u);
        XECC_SEMC_WAIT_BVALID_CPL = curr & (1u << 0u);
    }

    /**
     * Set all of GPR36's bit fields.
     *
     * (read-write) GPR36 General Purpose Register
     */
    inline void set_GPR36(IOMUXC_GPR_GPR36_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR36_DWP DWP,
                          bool XECC_SEMC_WAIT_BVALID_CPL) volatile
    {
        uint32_t curr = GPR36;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (XECC_SEMC_WAIT_BVALID_CPL & 0b1u) << 0u;

        GPR36 = curr;
    }

    /**
     * Get GPR37's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR37_DWP_LOCK get_GPR37_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR37_DWP_LOCK((GPR37 >> 30u) & 0b11u);
    }

    /**
     * Set GPR37's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR37_DWP_LOCK(IOMUXC_GPR_GPR37_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR37;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR37 = curr;
    }

    /**
     * Get GPR37's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR37_DWP get_GPR37_DWP() volatile
    {
        return IOMUXC_GPR_GPR37_DWP((GPR37 >> 28u) & 0b11u);
    }

    /**
     * Set GPR37's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR37_DWP(IOMUXC_GPR_GPR37_DWP value) volatile
    {
        uint32_t curr = GPR37;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR37 = curr;
    }

    /**
     * Get GPR37's M4_DBG_ACK_MASK bit.
     *
     * CM4 debug halt mask
     */
    inline bool get_GPR37_M4_DBG_ACK_MASK() volatile
    {
        return GPR37 & (1u << 6u);
    }

    /**
     * Set GPR37's M4_DBG_ACK_MASK bit.
     *
     * CM4 debug halt mask
     */
    inline void set_GPR37_M4_DBG_ACK_MASK() volatile
    {
        GPR37 |= 1u << 6u;
    }

    /**
     * Clear GPR37's M4_DBG_ACK_MASK bit.
     *
     * CM4 debug halt mask
     */
    inline void clear_GPR37_M4_DBG_ACK_MASK() volatile
    {
        GPR37 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR37's M4_DBG_ACK_MASK bit.
     *
     * CM4 debug halt mask
     */
    inline void toggle_GPR37_M4_DBG_ACK_MASK() volatile
    {
        GPR37 ^= 1u << 6u;
    }

    /**
     * Get GPR37's M7_DBG_ACK_MASK bit.
     *
     * CM7 debug halt mask
     */
    inline bool get_GPR37_M7_DBG_ACK_MASK() volatile
    {
        return GPR37 & (1u << 5u);
    }

    /**
     * Set GPR37's M7_DBG_ACK_MASK bit.
     *
     * CM7 debug halt mask
     */
    inline void set_GPR37_M7_DBG_ACK_MASK() volatile
    {
        GPR37 |= 1u << 5u;
    }

    /**
     * Clear GPR37's M7_DBG_ACK_MASK bit.
     *
     * CM7 debug halt mask
     */
    inline void clear_GPR37_M7_DBG_ACK_MASK() volatile
    {
        GPR37 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR37's M7_DBG_ACK_MASK bit.
     *
     * CM7 debug halt mask
     */
    inline void toggle_GPR37_M7_DBG_ACK_MASK() volatile
    {
        GPR37 ^= 1u << 5u;
    }

    /**
     * Get GPR37's EXC_MON bit.
     *
     * Exclusive monitor response select of illegal command
     */
    inline bool get_GPR37_EXC_MON() volatile
    {
        return GPR37 & (1u << 3u);
    }

    /**
     * Set GPR37's EXC_MON bit.
     *
     * Exclusive monitor response select of illegal command
     */
    inline void set_GPR37_EXC_MON() volatile
    {
        GPR37 |= 1u << 3u;
    }

    /**
     * Clear GPR37's EXC_MON bit.
     *
     * Exclusive monitor response select of illegal command
     */
    inline void clear_GPR37_EXC_MON() volatile
    {
        GPR37 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR37's EXC_MON bit.
     *
     * Exclusive monitor response select of illegal command
     */
    inline void toggle_GPR37_EXC_MON() volatile
    {
        GPR37 ^= 1u << 3u;
    }

    /**
     * Get GPR37's DBG_EN bit.
     *
     * ARM invasive debug enable
     */
    inline bool get_GPR37_DBG_EN() volatile
    {
        return GPR37 & (1u << 1u);
    }

    /**
     * Set GPR37's DBG_EN bit.
     *
     * ARM invasive debug enable
     */
    inline void set_GPR37_DBG_EN() volatile
    {
        GPR37 |= 1u << 1u;
    }

    /**
     * Clear GPR37's DBG_EN bit.
     *
     * ARM invasive debug enable
     */
    inline void clear_GPR37_DBG_EN() volatile
    {
        GPR37 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR37's DBG_EN bit.
     *
     * ARM invasive debug enable
     */
    inline void toggle_GPR37_DBG_EN() volatile
    {
        GPR37 ^= 1u << 1u;
    }

    /**
     * Get GPR37's NIDEN bit.
     *
     * ARM non-secure (non-invasive) debug enable
     */
    inline bool get_GPR37_NIDEN() volatile
    {
        return GPR37 & (1u << 0u);
    }

    /**
     * Set GPR37's NIDEN bit.
     *
     * ARM non-secure (non-invasive) debug enable
     */
    inline void set_GPR37_NIDEN() volatile
    {
        GPR37 |= 1u << 0u;
    }

    /**
     * Clear GPR37's NIDEN bit.
     *
     * ARM non-secure (non-invasive) debug enable
     */
    inline void clear_GPR37_NIDEN() volatile
    {
        GPR37 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR37's NIDEN bit.
     *
     * ARM non-secure (non-invasive) debug enable
     */
    inline void toggle_GPR37_NIDEN() volatile
    {
        GPR37 ^= 1u << 0u;
    }

    /**
     * Get all of GPR37's bit fields.
     *
     * (read-write) GPR37 General Purpose Register
     */
    inline void get_GPR37(IOMUXC_GPR_GPR37_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR37_DWP &DWP, bool &M4_DBG_ACK_MASK,
                          bool &M7_DBG_ACK_MASK, bool &EXC_MON, bool &DBG_EN,
                          bool &NIDEN) volatile
    {
        uint32_t curr = GPR37;

        DWP_LOCK = IOMUXC_GPR_GPR37_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR37_DWP((curr >> 28u) & 0b11u);
        M4_DBG_ACK_MASK = curr & (1u << 6u);
        M7_DBG_ACK_MASK = curr & (1u << 5u);
        EXC_MON = curr & (1u << 3u);
        DBG_EN = curr & (1u << 1u);
        NIDEN = curr & (1u << 0u);
    }

    /**
     * Set all of GPR37's bit fields.
     *
     * (read-write) GPR37 General Purpose Register
     */
    inline void set_GPR37(IOMUXC_GPR_GPR37_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR37_DWP DWP, bool M4_DBG_ACK_MASK,
                          bool M7_DBG_ACK_MASK, bool EXC_MON, bool DBG_EN,
                          bool NIDEN) volatile
    {
        uint32_t curr = GPR37;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 6u);
        curr |= (M4_DBG_ACK_MASK & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (M7_DBG_ACK_MASK & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (EXC_MON & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (DBG_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (NIDEN & 0b1u) << 0u;

        GPR37 = curr;
    }

    /**
     * Get GPR38's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR38_DWP_LOCK get_GPR38_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR38_DWP_LOCK((GPR38 >> 30u) & 0b11u);
    }

    /**
     * Set GPR38's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR38_DWP_LOCK(IOMUXC_GPR_GPR38_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR38;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR38 = curr;
    }

    /**
     * Get GPR38's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR38_DWP get_GPR38_DWP() volatile
    {
        return IOMUXC_GPR_GPR38_DWP((GPR38 >> 28u) & 0b11u);
    }

    /**
     * Set GPR38's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR38_DWP(IOMUXC_GPR_GPR38_DWP value) volatile
    {
        uint32_t curr = GPR38;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR38 = curr;
    }

    /**
     * Get all of GPR38's bit fields.
     *
     * (read-write) GPR38 General Purpose Register
     */
    inline void get_GPR38(IOMUXC_GPR_GPR38_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR38_DWP &DWP) volatile
    {
        uint32_t curr = GPR38;

        DWP_LOCK = IOMUXC_GPR_GPR38_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR38_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR38's bit fields.
     *
     * (read-write) GPR38 General Purpose Register
     */
    inline void set_GPR38(IOMUXC_GPR_GPR38_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR38_DWP DWP) volatile
    {
        uint32_t curr = GPR38;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR38 = curr;
    }

    /**
     * Get GPR39's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR39_DWP_LOCK get_GPR39_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR39_DWP_LOCK((GPR39 >> 30u) & 0b11u);
    }

    /**
     * Set GPR39's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR39_DWP_LOCK(IOMUXC_GPR_GPR39_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR39;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR39 = curr;
    }

    /**
     * Get GPR39's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR39_DWP get_GPR39_DWP() volatile
    {
        return IOMUXC_GPR_GPR39_DWP((GPR39 >> 28u) & 0b11u);
    }

    /**
     * Set GPR39's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR39_DWP(IOMUXC_GPR_GPR39_DWP value) volatile
    {
        uint32_t curr = GPR39;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR39 = curr;
    }

    /**
     * Get all of GPR39's bit fields.
     *
     * (read-write) GPR39 General Purpose Register
     */
    inline void get_GPR39(IOMUXC_GPR_GPR39_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR39_DWP &DWP) volatile
    {
        uint32_t curr = GPR39;

        DWP_LOCK = IOMUXC_GPR_GPR39_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR39_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR39's bit fields.
     *
     * (read-write) GPR39 General Purpose Register
     */
    inline void set_GPR39(IOMUXC_GPR_GPR39_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR39_DWP DWP) volatile
    {
        uint32_t curr = GPR39;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR39 = curr;
    }

    /**
     * Get GPR40's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR40_DWP_LOCK get_GPR40_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR40_DWP_LOCK((GPR40 >> 30u) & 0b11u);
    }

    /**
     * Set GPR40's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR40_DWP_LOCK(IOMUXC_GPR_GPR40_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR40;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR40 = curr;
    }

    /**
     * Get GPR40's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR40_DWP get_GPR40_DWP() volatile
    {
        return IOMUXC_GPR_GPR40_DWP((GPR40 >> 28u) & 0b11u);
    }

    /**
     * Set GPR40's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR40_DWP(IOMUXC_GPR_GPR40_DWP value) volatile
    {
        uint32_t curr = GPR40;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR40 = curr;
    }

    /**
     * Get GPR40's GPIO_MUX2_GPIO_SEL_LOW field.
     *
     * GPIO2 and CM7_GPIO2 share same IO MUX function, GPIO_MUX2 selects one
     * GPIO function.
     */
    inline uint16_t get_GPR40_GPIO_MUX2_GPIO_SEL_LOW() volatile
    {
        return (GPR40 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPR40's GPIO_MUX2_GPIO_SEL_LOW field.
     *
     * GPIO2 and CM7_GPIO2 share same IO MUX function, GPIO_MUX2 selects one
     * GPIO function.
     */
    inline void set_GPR40_GPIO_MUX2_GPIO_SEL_LOW(uint16_t value) volatile
    {
        uint32_t curr = GPR40;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPR40 = curr;
    }

    /**
     * Get all of GPR40's bit fields.
     *
     * (read-write) GPR40 General Purpose Register
     */
    inline void get_GPR40(IOMUXC_GPR_GPR40_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR40_DWP &DWP,
                          uint16_t &GPIO_MUX2_GPIO_SEL_LOW) volatile
    {
        uint32_t curr = GPR40;

        DWP_LOCK = IOMUXC_GPR_GPR40_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR40_DWP((curr >> 28u) & 0b11u);
        GPIO_MUX2_GPIO_SEL_LOW = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GPR40's bit fields.
     *
     * (read-write) GPR40 General Purpose Register
     */
    inline void set_GPR40(IOMUXC_GPR_GPR40_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR40_DWP DWP,
                          uint16_t GPIO_MUX2_GPIO_SEL_LOW) volatile
    {
        uint32_t curr = GPR40;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (GPIO_MUX2_GPIO_SEL_LOW & 0b1111111111111111u) << 0u;

        GPR40 = curr;
    }

    /**
     * Get GPR41's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR41_DWP_LOCK get_GPR41_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR41_DWP_LOCK((GPR41 >> 30u) & 0b11u);
    }

    /**
     * Set GPR41's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR41_DWP_LOCK(IOMUXC_GPR_GPR41_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR41;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR41 = curr;
    }

    /**
     * Get GPR41's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR41_DWP get_GPR41_DWP() volatile
    {
        return IOMUXC_GPR_GPR41_DWP((GPR41 >> 28u) & 0b11u);
    }

    /**
     * Set GPR41's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR41_DWP(IOMUXC_GPR_GPR41_DWP value) volatile
    {
        uint32_t curr = GPR41;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR41 = curr;
    }

    /**
     * Get GPR41's GPIO_MUX2_GPIO_SEL_HIGH field.
     *
     * GPIO2 and CM7_GPIO2 share same IO MUX function, GPIO_MUX2 selects one
     * GPIO function.
     */
    inline uint16_t get_GPR41_GPIO_MUX2_GPIO_SEL_HIGH() volatile
    {
        return (GPR41 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPR41's GPIO_MUX2_GPIO_SEL_HIGH field.
     *
     * GPIO2 and CM7_GPIO2 share same IO MUX function, GPIO_MUX2 selects one
     * GPIO function.
     */
    inline void set_GPR41_GPIO_MUX2_GPIO_SEL_HIGH(uint16_t value) volatile
    {
        uint32_t curr = GPR41;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPR41 = curr;
    }

    /**
     * Get all of GPR41's bit fields.
     *
     * (read-write) GPR41 General Purpose Register
     */
    inline void get_GPR41(IOMUXC_GPR_GPR41_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR41_DWP &DWP,
                          uint16_t &GPIO_MUX2_GPIO_SEL_HIGH) volatile
    {
        uint32_t curr = GPR41;

        DWP_LOCK = IOMUXC_GPR_GPR41_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR41_DWP((curr >> 28u) & 0b11u);
        GPIO_MUX2_GPIO_SEL_HIGH = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GPR41's bit fields.
     *
     * (read-write) GPR41 General Purpose Register
     */
    inline void set_GPR41(IOMUXC_GPR_GPR41_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR41_DWP DWP,
                          uint16_t GPIO_MUX2_GPIO_SEL_HIGH) volatile
    {
        uint32_t curr = GPR41;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (GPIO_MUX2_GPIO_SEL_HIGH & 0b1111111111111111u) << 0u;

        GPR41 = curr;
    }

    /**
     * Get GPR42's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR42_DWP_LOCK get_GPR42_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR42_DWP_LOCK((GPR42 >> 30u) & 0b11u);
    }

    /**
     * Set GPR42's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR42_DWP_LOCK(IOMUXC_GPR_GPR42_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR42;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR42 = curr;
    }

    /**
     * Get GPR42's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR42_DWP get_GPR42_DWP() volatile
    {
        return IOMUXC_GPR_GPR42_DWP((GPR42 >> 28u) & 0b11u);
    }

    /**
     * Set GPR42's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR42_DWP(IOMUXC_GPR_GPR42_DWP value) volatile
    {
        uint32_t curr = GPR42;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR42 = curr;
    }

    /**
     * Get GPR42's GPIO_MUX3_GPIO_SEL_LOW field.
     *
     * GPIO3 and CM7_GPIO3 share same IO MUX function, GPIO_MUX3 selects one
     * GPIO function.
     */
    inline uint16_t get_GPR42_GPIO_MUX3_GPIO_SEL_LOW() volatile
    {
        return (GPR42 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPR42's GPIO_MUX3_GPIO_SEL_LOW field.
     *
     * GPIO3 and CM7_GPIO3 share same IO MUX function, GPIO_MUX3 selects one
     * GPIO function.
     */
    inline void set_GPR42_GPIO_MUX3_GPIO_SEL_LOW(uint16_t value) volatile
    {
        uint32_t curr = GPR42;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPR42 = curr;
    }

    /**
     * Get all of GPR42's bit fields.
     *
     * (read-write) GPR42 General Purpose Register
     */
    inline void get_GPR42(IOMUXC_GPR_GPR42_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR42_DWP &DWP,
                          uint16_t &GPIO_MUX3_GPIO_SEL_LOW) volatile
    {
        uint32_t curr = GPR42;

        DWP_LOCK = IOMUXC_GPR_GPR42_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR42_DWP((curr >> 28u) & 0b11u);
        GPIO_MUX3_GPIO_SEL_LOW = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GPR42's bit fields.
     *
     * (read-write) GPR42 General Purpose Register
     */
    inline void set_GPR42(IOMUXC_GPR_GPR42_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR42_DWP DWP,
                          uint16_t GPIO_MUX3_GPIO_SEL_LOW) volatile
    {
        uint32_t curr = GPR42;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (GPIO_MUX3_GPIO_SEL_LOW & 0b1111111111111111u) << 0u;

        GPR42 = curr;
    }

    /**
     * Get GPR43's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR43_DWP_LOCK get_GPR43_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR43_DWP_LOCK((GPR43 >> 30u) & 0b11u);
    }

    /**
     * Set GPR43's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR43_DWP_LOCK(IOMUXC_GPR_GPR43_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR43;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR43 = curr;
    }

    /**
     * Get GPR43's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR43_DWP get_GPR43_DWP() volatile
    {
        return IOMUXC_GPR_GPR43_DWP((GPR43 >> 28u) & 0b11u);
    }

    /**
     * Set GPR43's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR43_DWP(IOMUXC_GPR_GPR43_DWP value) volatile
    {
        uint32_t curr = GPR43;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR43 = curr;
    }

    /**
     * Get GPR43's GPIO_MUX3_GPIO_SEL_HIGH field.
     *
     * GPIO3 and CM7_GPIO3 share same IO MUX function, GPIO_MUX3 selects one
     * GPIO function.
     */
    inline uint16_t get_GPR43_GPIO_MUX3_GPIO_SEL_HIGH() volatile
    {
        return (GPR43 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set GPR43's GPIO_MUX3_GPIO_SEL_HIGH field.
     *
     * GPIO3 and CM7_GPIO3 share same IO MUX function, GPIO_MUX3 selects one
     * GPIO function.
     */
    inline void set_GPR43_GPIO_MUX3_GPIO_SEL_HIGH(uint16_t value) volatile
    {
        uint32_t curr = GPR43;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        GPR43 = curr;
    }

    /**
     * Get all of GPR43's bit fields.
     *
     * (read-write) GPR43 General Purpose Register
     */
    inline void get_GPR43(IOMUXC_GPR_GPR43_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR43_DWP &DWP,
                          uint16_t &GPIO_MUX3_GPIO_SEL_HIGH) volatile
    {
        uint32_t curr = GPR43;

        DWP_LOCK = IOMUXC_GPR_GPR43_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR43_DWP((curr >> 28u) & 0b11u);
        GPIO_MUX3_GPIO_SEL_HIGH = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of GPR43's bit fields.
     *
     * (read-write) GPR43 General Purpose Register
     */
    inline void set_GPR43(IOMUXC_GPR_GPR43_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR43_DWP DWP,
                          uint16_t GPIO_MUX3_GPIO_SEL_HIGH) volatile
    {
        uint32_t curr = GPR43;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (GPIO_MUX3_GPIO_SEL_HIGH & 0b1111111111111111u) << 0u;

        GPR43 = curr;
    }

    /**
     * Get GPR44's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR44_DWP_LOCK get_GPR44_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR44_DWP_LOCK((GPR44 >> 30u) & 0b11u);
    }

    /**
     * Set GPR44's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR44_DWP_LOCK(IOMUXC_GPR_GPR44_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR44;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR44 = curr;
    }

    /**
     * Get GPR44's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR44_DWP get_GPR44_DWP() volatile
    {
        return IOMUXC_GPR_GPR44_DWP((GPR44 >> 28u) & 0b11u);
    }

    /**
     * Set GPR44's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR44_DWP(IOMUXC_GPR_GPR44_DWP value) volatile
    {
        uint32_t curr = GPR44;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR44 = curr;
    }

    /**
     * Get all of GPR44's bit fields.
     *
     * (read-write) GPR44 General Purpose Register
     */
    inline void get_GPR44(IOMUXC_GPR_GPR44_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR44_DWP &DWP) volatile
    {
        uint32_t curr = GPR44;

        DWP_LOCK = IOMUXC_GPR_GPR44_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR44_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR44's bit fields.
     *
     * (read-write) GPR44 General Purpose Register
     */
    inline void set_GPR44(IOMUXC_GPR_GPR44_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR44_DWP DWP) volatile
    {
        uint32_t curr = GPR44;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR44 = curr;
    }

    /**
     * Get GPR45's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR45_DWP_LOCK get_GPR45_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR45_DWP_LOCK((GPR45 >> 30u) & 0b11u);
    }

    /**
     * Set GPR45's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR45_DWP_LOCK(IOMUXC_GPR_GPR45_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR45;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR45 = curr;
    }

    /**
     * Get GPR45's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR45_DWP get_GPR45_DWP() volatile
    {
        return IOMUXC_GPR_GPR45_DWP((GPR45 >> 28u) & 0b11u);
    }

    /**
     * Set GPR45's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR45_DWP(IOMUXC_GPR_GPR45_DWP value) volatile
    {
        uint32_t curr = GPR45;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR45 = curr;
    }

    /**
     * Get all of GPR45's bit fields.
     *
     * (read-write) GPR45 General Purpose Register
     */
    inline void get_GPR45(IOMUXC_GPR_GPR45_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR45_DWP &DWP) volatile
    {
        uint32_t curr = GPR45;

        DWP_LOCK = IOMUXC_GPR_GPR45_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR45_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR45's bit fields.
     *
     * (read-write) GPR45 General Purpose Register
     */
    inline void set_GPR45(IOMUXC_GPR_GPR45_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR45_DWP DWP) volatile
    {
        uint32_t curr = GPR45;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR45 = curr;
    }

    /**
     * Get GPR46's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR46_DWP_LOCK get_GPR46_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR46_DWP_LOCK((GPR46 >> 30u) & 0b11u);
    }

    /**
     * Set GPR46's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR46_DWP_LOCK(IOMUXC_GPR_GPR46_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR46;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR46 = curr;
    }

    /**
     * Get GPR46's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR46_DWP get_GPR46_DWP() volatile
    {
        return IOMUXC_GPR_GPR46_DWP((GPR46 >> 28u) & 0b11u);
    }

    /**
     * Set GPR46's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR46_DWP(IOMUXC_GPR_GPR46_DWP value) volatile
    {
        uint32_t curr = GPR46;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR46 = curr;
    }

    /**
     * Get all of GPR46's bit fields.
     *
     * (read-write) GPR46 General Purpose Register
     */
    inline void get_GPR46(IOMUXC_GPR_GPR46_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR46_DWP &DWP) volatile
    {
        uint32_t curr = GPR46;

        DWP_LOCK = IOMUXC_GPR_GPR46_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR46_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR46's bit fields.
     *
     * (read-write) GPR46 General Purpose Register
     */
    inline void set_GPR46(IOMUXC_GPR_GPR46_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR46_DWP DWP) volatile
    {
        uint32_t curr = GPR46;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR46 = curr;
    }

    /**
     * Get GPR47's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR47_DWP_LOCK get_GPR47_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR47_DWP_LOCK((GPR47 >> 30u) & 0b11u);
    }

    /**
     * Set GPR47's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR47_DWP_LOCK(IOMUXC_GPR_GPR47_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR47;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR47 = curr;
    }

    /**
     * Get GPR47's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR47_DWP get_GPR47_DWP() volatile
    {
        return IOMUXC_GPR_GPR47_DWP((GPR47 >> 28u) & 0b11u);
    }

    /**
     * Set GPR47's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR47_DWP(IOMUXC_GPR_GPR47_DWP value) volatile
    {
        uint32_t curr = GPR47;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR47 = curr;
    }

    /**
     * Get all of GPR47's bit fields.
     *
     * (read-write) GPR47 General Purpose Register
     */
    inline void get_GPR47(IOMUXC_GPR_GPR47_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR47_DWP &DWP) volatile
    {
        uint32_t curr = GPR47;

        DWP_LOCK = IOMUXC_GPR_GPR47_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR47_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR47's bit fields.
     *
     * (read-write) GPR47 General Purpose Register
     */
    inline void set_GPR47(IOMUXC_GPR_GPR47_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR47_DWP DWP) volatile
    {
        uint32_t curr = GPR47;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR47 = curr;
    }

    /**
     * Get GPR48's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR48_DWP_LOCK get_GPR48_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR48_DWP_LOCK((GPR48 >> 30u) & 0b11u);
    }

    /**
     * Set GPR48's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR48_DWP_LOCK(IOMUXC_GPR_GPR48_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR48;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR48 = curr;
    }

    /**
     * Get GPR48's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR48_DWP get_GPR48_DWP() volatile
    {
        return IOMUXC_GPR_GPR48_DWP((GPR48 >> 28u) & 0b11u);
    }

    /**
     * Set GPR48's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR48_DWP(IOMUXC_GPR_GPR48_DWP value) volatile
    {
        uint32_t curr = GPR48;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR48 = curr;
    }

    /**
     * Get all of GPR48's bit fields.
     *
     * (read-write) GPR48 General Purpose Register
     */
    inline void get_GPR48(IOMUXC_GPR_GPR48_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR48_DWP &DWP) volatile
    {
        uint32_t curr = GPR48;

        DWP_LOCK = IOMUXC_GPR_GPR48_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR48_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR48's bit fields.
     *
     * (read-write) GPR48 General Purpose Register
     */
    inline void set_GPR48(IOMUXC_GPR_GPR48_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR48_DWP DWP) volatile
    {
        uint32_t curr = GPR48;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR48 = curr;
    }

    /**
     * Get GPR49's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR49_DWP_LOCK get_GPR49_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR49_DWP_LOCK((GPR49 >> 30u) & 0b11u);
    }

    /**
     * Set GPR49's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR49_DWP_LOCK(IOMUXC_GPR_GPR49_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR49;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR49 = curr;
    }

    /**
     * Get GPR49's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR49_DWP get_GPR49_DWP() volatile
    {
        return IOMUXC_GPR_GPR49_DWP((GPR49 >> 28u) & 0b11u);
    }

    /**
     * Set GPR49's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR49_DWP(IOMUXC_GPR_GPR49_DWP value) volatile
    {
        uint32_t curr = GPR49;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR49 = curr;
    }

    /**
     * Get all of GPR49's bit fields.
     *
     * (read-write) GPR49 General Purpose Register
     */
    inline void get_GPR49(IOMUXC_GPR_GPR49_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR49_DWP &DWP) volatile
    {
        uint32_t curr = GPR49;

        DWP_LOCK = IOMUXC_GPR_GPR49_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR49_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR49's bit fields.
     *
     * (read-write) GPR49 General Purpose Register
     */
    inline void set_GPR49(IOMUXC_GPR_GPR49_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR49_DWP DWP) volatile
    {
        uint32_t curr = GPR49;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR49 = curr;
    }

    /**
     * Get GPR50's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR50_DWP_LOCK get_GPR50_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR50_DWP_LOCK((GPR50 >> 30u) & 0b11u);
    }

    /**
     * Set GPR50's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR50_DWP_LOCK(IOMUXC_GPR_GPR50_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR50;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR50 = curr;
    }

    /**
     * Get GPR50's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR50_DWP get_GPR50_DWP() volatile
    {
        return IOMUXC_GPR_GPR50_DWP((GPR50 >> 28u) & 0b11u);
    }

    /**
     * Set GPR50's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR50_DWP(IOMUXC_GPR_GPR50_DWP value) volatile
    {
        uint32_t curr = GPR50;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR50 = curr;
    }

    /**
     * Get GPR50's CAAM_IPS_MGR field.
     *
     * CAAM manager processor identifier
     */
    inline uint8_t get_GPR50_CAAM_IPS_MGR() volatile
    {
        return (GPR50 >> 0u) & 0b11111u;
    }

    /**
     * Set GPR50's CAAM_IPS_MGR field.
     *
     * CAAM manager processor identifier
     */
    inline void set_GPR50_CAAM_IPS_MGR(uint8_t value) volatile
    {
        uint32_t curr = GPR50;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        GPR50 = curr;
    }

    /**
     * Get all of GPR50's bit fields.
     *
     * (read-write) GPR50 General Purpose Register
     */
    inline void get_GPR50(IOMUXC_GPR_GPR50_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR50_DWP &DWP,
                          uint8_t &CAAM_IPS_MGR) volatile
    {
        uint32_t curr = GPR50;

        DWP_LOCK = IOMUXC_GPR_GPR50_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR50_DWP((curr >> 28u) & 0b11u);
        CAAM_IPS_MGR = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of GPR50's bit fields.
     *
     * (read-write) GPR50 General Purpose Register
     */
    inline void set_GPR50(IOMUXC_GPR_GPR50_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR50_DWP DWP,
                          uint8_t CAAM_IPS_MGR) volatile
    {
        uint32_t curr = GPR50;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b11111u << 0u);
        curr |= (CAAM_IPS_MGR & 0b11111u) << 0u;

        GPR50 = curr;
    }

    /**
     * Get GPR51's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR51_DWP_LOCK get_GPR51_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR51_DWP_LOCK((GPR51 >> 30u) & 0b11u);
    }

    /**
     * Set GPR51's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR51_DWP_LOCK(IOMUXC_GPR_GPR51_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR51;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR51 = curr;
    }

    /**
     * Get GPR51's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR51_DWP get_GPR51_DWP() volatile
    {
        return IOMUXC_GPR_GPR51_DWP((GPR51 >> 28u) & 0b11u);
    }

    /**
     * Set GPR51's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR51_DWP(IOMUXC_GPR_GPR51_DWP value) volatile
    {
        uint32_t curr = GPR51;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR51 = curr;
    }

    /**
     * Get GPR51's M7_NMI_CLEAR bit.
     *
     * Clear CM7 NMI holding register
     */
    inline bool get_GPR51_M7_NMI_CLEAR() volatile
    {
        return GPR51 & (1u << 0u);
    }

    /**
     * Set GPR51's M7_NMI_CLEAR bit.
     *
     * Clear CM7 NMI holding register
     */
    inline void set_GPR51_M7_NMI_CLEAR() volatile
    {
        GPR51 |= 1u << 0u;
    }

    /**
     * Clear GPR51's M7_NMI_CLEAR bit.
     *
     * Clear CM7 NMI holding register
     */
    inline void clear_GPR51_M7_NMI_CLEAR() volatile
    {
        GPR51 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR51's M7_NMI_CLEAR bit.
     *
     * Clear CM7 NMI holding register
     */
    inline void toggle_GPR51_M7_NMI_CLEAR() volatile
    {
        GPR51 ^= 1u << 0u;
    }

    /**
     * Get all of GPR51's bit fields.
     *
     * (read-write) GPR51 General Purpose Register
     */
    inline void get_GPR51(IOMUXC_GPR_GPR51_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR51_DWP &DWP,
                          bool &M7_NMI_CLEAR) volatile
    {
        uint32_t curr = GPR51;

        DWP_LOCK = IOMUXC_GPR_GPR51_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR51_DWP((curr >> 28u) & 0b11u);
        M7_NMI_CLEAR = curr & (1u << 0u);
    }

    /**
     * Set all of GPR51's bit fields.
     *
     * (read-write) GPR51 General Purpose Register
     */
    inline void set_GPR51(IOMUXC_GPR_GPR51_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR51_DWP DWP, bool M7_NMI_CLEAR) volatile
    {
        uint32_t curr = GPR51;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 0u);
        curr |= (M7_NMI_CLEAR & 0b1u) << 0u;

        GPR51 = curr;
    }

    /**
     * Get GPR52's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR52_DWP_LOCK get_GPR52_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR52_DWP_LOCK((GPR52 >> 30u) & 0b11u);
    }

    /**
     * Set GPR52's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR52_DWP_LOCK(IOMUXC_GPR_GPR52_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR52;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR52 = curr;
    }

    /**
     * Get GPR52's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR52_DWP get_GPR52_DWP() volatile
    {
        return IOMUXC_GPR_GPR52_DWP((GPR52 >> 28u) & 0b11u);
    }

    /**
     * Set GPR52's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR52_DWP(IOMUXC_GPR_GPR52_DWP value) volatile
    {
        uint32_t curr = GPR52;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR52 = curr;
    }

    /**
     * Get all of GPR52's bit fields.
     *
     * (read-write) GPR52 General Purpose Register
     */
    inline void get_GPR52(IOMUXC_GPR_GPR52_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR52_DWP &DWP) volatile
    {
        uint32_t curr = GPR52;

        DWP_LOCK = IOMUXC_GPR_GPR52_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR52_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR52's bit fields.
     *
     * (read-write) GPR52 General Purpose Register
     */
    inline void set_GPR52(IOMUXC_GPR_GPR52_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR52_DWP DWP) volatile
    {
        uint32_t curr = GPR52;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR52 = curr;
    }

    /**
     * Get GPR53's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR53_DWP_LOCK get_GPR53_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR53_DWP_LOCK((GPR53 >> 30u) & 0b11u);
    }

    /**
     * Set GPR53's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR53_DWP_LOCK(IOMUXC_GPR_GPR53_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR53;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR53 = curr;
    }

    /**
     * Get GPR53's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR53_DWP get_GPR53_DWP() volatile
    {
        return IOMUXC_GPR_GPR53_DWP((GPR53 >> 28u) & 0b11u);
    }

    /**
     * Set GPR53's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR53_DWP(IOMUXC_GPR_GPR53_DWP value) volatile
    {
        uint32_t curr = GPR53;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR53 = curr;
    }

    /**
     * Get all of GPR53's bit fields.
     *
     * (read-write) GPR53 General Purpose Register
     */
    inline void get_GPR53(IOMUXC_GPR_GPR53_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR53_DWP &DWP) volatile
    {
        uint32_t curr = GPR53;

        DWP_LOCK = IOMUXC_GPR_GPR53_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR53_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR53's bit fields.
     *
     * (read-write) GPR53 General Purpose Register
     */
    inline void set_GPR53(IOMUXC_GPR_GPR53_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR53_DWP DWP) volatile
    {
        uint32_t curr = GPR53;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR53 = curr;
    }

    /**
     * Get GPR54's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR54_DWP_LOCK get_GPR54_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR54_DWP_LOCK((GPR54 >> 30u) & 0b11u);
    }

    /**
     * Set GPR54's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR54_DWP_LOCK(IOMUXC_GPR_GPR54_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR54;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR54 = curr;
    }

    /**
     * Get GPR54's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR54_DWP get_GPR54_DWP() volatile
    {
        return IOMUXC_GPR_GPR54_DWP((GPR54 >> 28u) & 0b11u);
    }

    /**
     * Set GPR54's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR54_DWP(IOMUXC_GPR_GPR54_DWP value) volatile
    {
        uint32_t curr = GPR54;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR54 = curr;
    }

    /**
     * Get all of GPR54's bit fields.
     *
     * (read-write) GPR54 General Purpose Register
     */
    inline void get_GPR54(IOMUXC_GPR_GPR54_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR54_DWP &DWP) volatile
    {
        uint32_t curr = GPR54;

        DWP_LOCK = IOMUXC_GPR_GPR54_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR54_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR54's bit fields.
     *
     * (read-write) GPR54 General Purpose Register
     */
    inline void set_GPR54(IOMUXC_GPR_GPR54_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR54_DWP DWP) volatile
    {
        uint32_t curr = GPR54;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR54 = curr;
    }

    /**
     * Get GPR55's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR55_DWP_LOCK get_GPR55_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR55_DWP_LOCK((GPR55 >> 30u) & 0b11u);
    }

    /**
     * Set GPR55's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR55_DWP_LOCK(IOMUXC_GPR_GPR55_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR55;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR55 = curr;
    }

    /**
     * Get GPR55's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR55_DWP get_GPR55_DWP() volatile
    {
        return IOMUXC_GPR_GPR55_DWP((GPR55 >> 28u) & 0b11u);
    }

    /**
     * Set GPR55's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR55_DWP(IOMUXC_GPR_GPR55_DWP value) volatile
    {
        uint32_t curr = GPR55;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR55 = curr;
    }

    /**
     * Get all of GPR55's bit fields.
     *
     * (read-write) GPR55 General Purpose Register
     */
    inline void get_GPR55(IOMUXC_GPR_GPR55_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR55_DWP &DWP) volatile
    {
        uint32_t curr = GPR55;

        DWP_LOCK = IOMUXC_GPR_GPR55_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR55_DWP((curr >> 28u) & 0b11u);
    }

    /**
     * Set all of GPR55's bit fields.
     *
     * (read-write) GPR55 General Purpose Register
     */
    inline void set_GPR55(IOMUXC_GPR_GPR55_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR55_DWP DWP) volatile
    {
        uint32_t curr = GPR55;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;

        GPR55 = curr;
    }

    /**
     * Get GPR59's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR59_DWP_LOCK get_GPR59_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR59_DWP_LOCK((GPR59 >> 30u) & 0b11u);
    }

    /**
     * Set GPR59's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR59_DWP_LOCK(IOMUXC_GPR_GPR59_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR59 = curr;
    }

    /**
     * Get GPR59's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR59_DWP get_GPR59_DWP() volatile
    {
        return IOMUXC_GPR_GPR59_DWP((GPR59 >> 28u) & 0b11u);
    }

    /**
     * Set GPR59's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR59_DWP(IOMUXC_GPR_GPR59_DWP value) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR59 = curr;
    }

    /**
     * Get GPR59's MIPI_CSI_S_PRG_RXHS_SETTLE field.
     *
     * Bits used to program T_HS_SETTLE.
     */
    inline uint8_t get_GPR59_MIPI_CSI_S_PRG_RXHS_SETTLE() volatile
    {
        return (GPR59 >> 12u) & 0b111111u;
    }

    /**
     * Set GPR59's MIPI_CSI_S_PRG_RXHS_SETTLE field.
     *
     * Bits used to program T_HS_SETTLE.
     */
    inline void set_GPR59_MIPI_CSI_S_PRG_RXHS_SETTLE(uint8_t value) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b111111u << 12u);
        curr |= (value & 0b111111u) << 12u;

        GPR59 = curr;
    }

    /**
     * Get GPR59's MIPI_CSI_RXLPRP field.
     *
     * Programming bits that adjust the threshold voltage of LP-RX, default
     * setting 2'b01
     */
    inline uint8_t get_GPR59_MIPI_CSI_RXLPRP() volatile
    {
        return (GPR59 >> 10u) & 0b11u;
    }

    /**
     * Set GPR59's MIPI_CSI_RXLPRP field.
     *
     * Programming bits that adjust the threshold voltage of LP-RX, default
     * setting 2'b01
     */
    inline void set_GPR59_MIPI_CSI_RXLPRP(uint8_t value) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b11u << 10u);
        curr |= (value & 0b11u) << 10u;

        GPR59 = curr;
    }

    /**
     * Get GPR59's MIPI_CSI_RXCDRP field.
     *
     * Programming bits that adjust the threshold voltage of LP-CD, default
     * setting 2'b01
     */
    inline IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP
    get_GPR59_MIPI_CSI_RXCDRP() volatile
    {
        return IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP((GPR59 >> 8u) & 0b11u);
    }

    /**
     * Set GPR59's MIPI_CSI_RXCDRP field.
     *
     * Programming bits that adjust the threshold voltage of LP-CD, default
     * setting 2'b01
     */
    inline void set_GPR59_MIPI_CSI_RXCDRP(
        IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP value) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        GPR59 = curr;
    }

    /**
     * Get GPR59's MIPI_CSI_RX_RCAL field.
     *
     * MIPI CSI PHY on-chip termination control bits
     */
    inline uint8_t get_GPR59_MIPI_CSI_RX_RCAL() volatile
    {
        return (GPR59 >> 6u) & 0b11u;
    }

    /**
     * Set GPR59's MIPI_CSI_RX_RCAL field.
     *
     * MIPI CSI PHY on-chip termination control bits
     */
    inline void set_GPR59_MIPI_CSI_RX_RCAL(uint8_t value) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        GPR59 = curr;
    }

    /**
     * Get GPR59's MIPI_CSI_RX_ENABLE bit.
     *
     * Assert to enable MIPI CSI Receive Enable
     */
    inline bool get_GPR59_MIPI_CSI_RX_ENABLE() volatile
    {
        return GPR59 & (1u << 5u);
    }

    /**
     * Set GPR59's MIPI_CSI_RX_ENABLE bit.
     *
     * Assert to enable MIPI CSI Receive Enable
     */
    inline void set_GPR59_MIPI_CSI_RX_ENABLE() volatile
    {
        GPR59 |= 1u << 5u;
    }

    /**
     * Clear GPR59's MIPI_CSI_RX_ENABLE bit.
     *
     * Assert to enable MIPI CSI Receive Enable
     */
    inline void clear_GPR59_MIPI_CSI_RX_ENABLE() volatile
    {
        GPR59 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR59's MIPI_CSI_RX_ENABLE bit.
     *
     * Assert to enable MIPI CSI Receive Enable
     */
    inline void toggle_GPR59_MIPI_CSI_RX_ENABLE() volatile
    {
        GPR59 ^= 1u << 5u;
    }

    /**
     * Get GPR59's MIPI_CSI_PD_RX bit.
     *
     * Power Down input for MIPI CSI PHY.
     */
    inline bool get_GPR59_MIPI_CSI_PD_RX() volatile
    {
        return GPR59 & (1u << 4u);
    }

    /**
     * Set GPR59's MIPI_CSI_PD_RX bit.
     *
     * Power Down input for MIPI CSI PHY.
     */
    inline void set_GPR59_MIPI_CSI_PD_RX() volatile
    {
        GPR59 |= 1u << 4u;
    }

    /**
     * Clear GPR59's MIPI_CSI_PD_RX bit.
     *
     * Power Down input for MIPI CSI PHY.
     */
    inline void clear_GPR59_MIPI_CSI_PD_RX() volatile
    {
        GPR59 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR59's MIPI_CSI_PD_RX bit.
     *
     * Power Down input for MIPI CSI PHY.
     */
    inline void toggle_GPR59_MIPI_CSI_PD_RX() volatile
    {
        GPR59 ^= 1u << 4u;
    }

    /**
     * Get GPR59's MIPI_CSI_DDRCLK_EN bit.
     *
     * When high, enables received DDR clock on CLK_DRXHS
     */
    inline bool get_GPR59_MIPI_CSI_DDRCLK_EN() volatile
    {
        return GPR59 & (1u << 3u);
    }

    /**
     * Set GPR59's MIPI_CSI_DDRCLK_EN bit.
     *
     * When high, enables received DDR clock on CLK_DRXHS
     */
    inline void set_GPR59_MIPI_CSI_DDRCLK_EN() volatile
    {
        GPR59 |= 1u << 3u;
    }

    /**
     * Clear GPR59's MIPI_CSI_DDRCLK_EN bit.
     *
     * When high, enables received DDR clock on CLK_DRXHS
     */
    inline void clear_GPR59_MIPI_CSI_DDRCLK_EN() volatile
    {
        GPR59 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR59's MIPI_CSI_DDRCLK_EN bit.
     *
     * When high, enables received DDR clock on CLK_DRXHS
     */
    inline void toggle_GPR59_MIPI_CSI_DDRCLK_EN() volatile
    {
        GPR59 ^= 1u << 3u;
    }

    /**
     * Get GPR59's MIPI_CSI_CONT_CLK_MODE bit.
     *
     * Enables the slave clock lane feature to maintain HS reception state
     * during continuous clock mode operation, despite line glitches.
     */
    inline bool get_GPR59_MIPI_CSI_CONT_CLK_MODE() volatile
    {
        return GPR59 & (1u << 2u);
    }

    /**
     * Set GPR59's MIPI_CSI_CONT_CLK_MODE bit.
     *
     * Enables the slave clock lane feature to maintain HS reception state
     * during continuous clock mode operation, despite line glitches.
     */
    inline void set_GPR59_MIPI_CSI_CONT_CLK_MODE() volatile
    {
        GPR59 |= 1u << 2u;
    }

    /**
     * Clear GPR59's MIPI_CSI_CONT_CLK_MODE bit.
     *
     * Enables the slave clock lane feature to maintain HS reception state
     * during continuous clock mode operation, despite line glitches.
     */
    inline void clear_GPR59_MIPI_CSI_CONT_CLK_MODE() volatile
    {
        GPR59 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR59's MIPI_CSI_CONT_CLK_MODE bit.
     *
     * Enables the slave clock lane feature to maintain HS reception state
     * during continuous clock mode operation, despite line glitches.
     */
    inline void toggle_GPR59_MIPI_CSI_CONT_CLK_MODE() volatile
    {
        GPR59 ^= 1u << 2u;
    }

    /**
     * Get GPR59's MIPI_CSI_SOFT_RST_N bit.
     *
     * MIPI CSI APB clock domain and User interface clock domain software reset
     * bit
     */
    inline bool get_GPR59_MIPI_CSI_SOFT_RST_N() volatile
    {
        return GPR59 & (1u << 1u);
    }

    /**
     * Set GPR59's MIPI_CSI_SOFT_RST_N bit.
     *
     * MIPI CSI APB clock domain and User interface clock domain software reset
     * bit
     */
    inline void set_GPR59_MIPI_CSI_SOFT_RST_N() volatile
    {
        GPR59 |= 1u << 1u;
    }

    /**
     * Clear GPR59's MIPI_CSI_SOFT_RST_N bit.
     *
     * MIPI CSI APB clock domain and User interface clock domain software reset
     * bit
     */
    inline void clear_GPR59_MIPI_CSI_SOFT_RST_N() volatile
    {
        GPR59 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR59's MIPI_CSI_SOFT_RST_N bit.
     *
     * MIPI CSI APB clock domain and User interface clock domain software reset
     * bit
     */
    inline void toggle_GPR59_MIPI_CSI_SOFT_RST_N() volatile
    {
        GPR59 ^= 1u << 1u;
    }

    /**
     * Get GPR59's MIPI_CSI_AUTO_PD_EN bit.
     *
     * Powers down inactive lanes reported by CSI2X_CFG_NUM_LANES.
     */
    inline bool get_GPR59_MIPI_CSI_AUTO_PD_EN() volatile
    {
        return GPR59 & (1u << 0u);
    }

    /**
     * Set GPR59's MIPI_CSI_AUTO_PD_EN bit.
     *
     * Powers down inactive lanes reported by CSI2X_CFG_NUM_LANES.
     */
    inline void set_GPR59_MIPI_CSI_AUTO_PD_EN() volatile
    {
        GPR59 |= 1u << 0u;
    }

    /**
     * Clear GPR59's MIPI_CSI_AUTO_PD_EN bit.
     *
     * Powers down inactive lanes reported by CSI2X_CFG_NUM_LANES.
     */
    inline void clear_GPR59_MIPI_CSI_AUTO_PD_EN() volatile
    {
        GPR59 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR59's MIPI_CSI_AUTO_PD_EN bit.
     *
     * Powers down inactive lanes reported by CSI2X_CFG_NUM_LANES.
     */
    inline void toggle_GPR59_MIPI_CSI_AUTO_PD_EN() volatile
    {
        GPR59 ^= 1u << 0u;
    }

    /**
     * Get all of GPR59's bit fields.
     *
     * (read-write) GPR59 General Purpose Register
     */
    inline void get_GPR59(IOMUXC_GPR_GPR59_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR59_DWP &DWP,
                          uint8_t &MIPI_CSI_S_PRG_RXHS_SETTLE,
                          uint8_t &MIPI_CSI_RXLPRP,
                          IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP &MIPI_CSI_RXCDRP,
                          uint8_t &MIPI_CSI_RX_RCAL, bool &MIPI_CSI_RX_ENABLE,
                          bool &MIPI_CSI_PD_RX, bool &MIPI_CSI_DDRCLK_EN,
                          bool &MIPI_CSI_CONT_CLK_MODE,
                          bool &MIPI_CSI_SOFT_RST_N,
                          bool &MIPI_CSI_AUTO_PD_EN) volatile
    {
        uint32_t curr = GPR59;

        DWP_LOCK = IOMUXC_GPR_GPR59_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR59_DWP((curr >> 28u) & 0b11u);
        MIPI_CSI_S_PRG_RXHS_SETTLE = (curr >> 12u) & 0b111111u;
        MIPI_CSI_RXLPRP = (curr >> 10u) & 0b11u;
        MIPI_CSI_RXCDRP =
            IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP((curr >> 8u) & 0b11u);
        MIPI_CSI_RX_RCAL = (curr >> 6u) & 0b11u;
        MIPI_CSI_RX_ENABLE = curr & (1u << 5u);
        MIPI_CSI_PD_RX = curr & (1u << 4u);
        MIPI_CSI_DDRCLK_EN = curr & (1u << 3u);
        MIPI_CSI_CONT_CLK_MODE = curr & (1u << 2u);
        MIPI_CSI_SOFT_RST_N = curr & (1u << 1u);
        MIPI_CSI_AUTO_PD_EN = curr & (1u << 0u);
    }

    /**
     * Set all of GPR59's bit fields.
     *
     * (read-write) GPR59 General Purpose Register
     */
    inline void set_GPR59(
        IOMUXC_GPR_GPR59_DWP_LOCK DWP_LOCK, IOMUXC_GPR_GPR59_DWP DWP,
        uint8_t MIPI_CSI_S_PRG_RXHS_SETTLE, uint8_t MIPI_CSI_RXLPRP,
        IOMUXC_GPR_GPR59_MIPI_CSI_RXCDRP MIPI_CSI_RXCDRP,
        uint8_t MIPI_CSI_RX_RCAL, bool MIPI_CSI_RX_ENABLE, bool MIPI_CSI_PD_RX,
        bool MIPI_CSI_DDRCLK_EN, bool MIPI_CSI_CONT_CLK_MODE,
        bool MIPI_CSI_SOFT_RST_N, bool MIPI_CSI_AUTO_PD_EN) volatile
    {
        uint32_t curr = GPR59;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b111111u << 12u);
        curr |= (MIPI_CSI_S_PRG_RXHS_SETTLE & 0b111111u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (MIPI_CSI_RXLPRP & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(MIPI_CSI_RXCDRP) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (MIPI_CSI_RX_RCAL & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MIPI_CSI_RX_ENABLE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MIPI_CSI_PD_RX & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (MIPI_CSI_DDRCLK_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (MIPI_CSI_CONT_CLK_MODE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (MIPI_CSI_SOFT_RST_N & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (MIPI_CSI_AUTO_PD_EN & 0b1u) << 0u;

        GPR59 = curr;
    }

    /**
     * Get GPR62's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR62_DWP_LOCK get_GPR62_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR62_DWP_LOCK((GPR62 >> 30u) & 0b11u);
    }

    /**
     * Set GPR62's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR62_DWP_LOCK(IOMUXC_GPR_GPR62_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR62 = curr;
    }

    /**
     * Get GPR62's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR62_DWP get_GPR62_DWP() volatile
    {
        return IOMUXC_GPR_GPR62_DWP((GPR62 >> 28u) & 0b11u);
    }

    /**
     * Set GPR62's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR62_DWP(IOMUXC_GPR_GPR62_DWP value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR62 = curr;
    }

    /**
     * Get GPR62's MIPI_DSI_ESC_SOFT_RESET_N bit.
     *
     * MIPI DSI Escape clock domain software reset bit
     */
    inline bool get_GPR62_MIPI_DSI_ESC_SOFT_RESET_N() volatile
    {
        return GPR62 & (1u << 19u);
    }

    /**
     * Set GPR62's MIPI_DSI_ESC_SOFT_RESET_N bit.
     *
     * MIPI DSI Escape clock domain software reset bit
     */
    inline void set_GPR62_MIPI_DSI_ESC_SOFT_RESET_N() volatile
    {
        GPR62 |= 1u << 19u;
    }

    /**
     * Clear GPR62's MIPI_DSI_ESC_SOFT_RESET_N bit.
     *
     * MIPI DSI Escape clock domain software reset bit
     */
    inline void clear_GPR62_MIPI_DSI_ESC_SOFT_RESET_N() volatile
    {
        GPR62 &= ~(1u << 19u);
    }

    /**
     * Toggle GPR62's MIPI_DSI_ESC_SOFT_RESET_N bit.
     *
     * MIPI DSI Escape clock domain software reset bit
     */
    inline void toggle_GPR62_MIPI_DSI_ESC_SOFT_RESET_N() volatile
    {
        GPR62 ^= 1u << 19u;
    }

    /**
     * Get GPR62's MIPI_DSI_DPI_SOFT_RESET_N bit.
     *
     * MIPI DSI Pixel clock domain software reset bit
     */
    inline bool get_GPR62_MIPI_DSI_DPI_SOFT_RESET_N() volatile
    {
        return GPR62 & (1u << 18u);
    }

    /**
     * Set GPR62's MIPI_DSI_DPI_SOFT_RESET_N bit.
     *
     * MIPI DSI Pixel clock domain software reset bit
     */
    inline void set_GPR62_MIPI_DSI_DPI_SOFT_RESET_N() volatile
    {
        GPR62 |= 1u << 18u;
    }

    /**
     * Clear GPR62's MIPI_DSI_DPI_SOFT_RESET_N bit.
     *
     * MIPI DSI Pixel clock domain software reset bit
     */
    inline void clear_GPR62_MIPI_DSI_DPI_SOFT_RESET_N() volatile
    {
        GPR62 &= ~(1u << 18u);
    }

    /**
     * Toggle GPR62's MIPI_DSI_DPI_SOFT_RESET_N bit.
     *
     * MIPI DSI Pixel clock domain software reset bit
     */
    inline void toggle_GPR62_MIPI_DSI_DPI_SOFT_RESET_N() volatile
    {
        GPR62 ^= 1u << 18u;
    }

    /**
     * Get GPR62's MIPI_DSI_BYTE_SOFT_RESET_N bit.
     *
     * MIPI DSI Byte clock domain software reset bit
     */
    inline bool get_GPR62_MIPI_DSI_BYTE_SOFT_RESET_N() volatile
    {
        return GPR62 & (1u << 17u);
    }

    /**
     * Set GPR62's MIPI_DSI_BYTE_SOFT_RESET_N bit.
     *
     * MIPI DSI Byte clock domain software reset bit
     */
    inline void set_GPR62_MIPI_DSI_BYTE_SOFT_RESET_N() volatile
    {
        GPR62 |= 1u << 17u;
    }

    /**
     * Clear GPR62's MIPI_DSI_BYTE_SOFT_RESET_N bit.
     *
     * MIPI DSI Byte clock domain software reset bit
     */
    inline void clear_GPR62_MIPI_DSI_BYTE_SOFT_RESET_N() volatile
    {
        GPR62 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR62's MIPI_DSI_BYTE_SOFT_RESET_N bit.
     *
     * MIPI DSI Byte clock domain software reset bit
     */
    inline void toggle_GPR62_MIPI_DSI_BYTE_SOFT_RESET_N() volatile
    {
        GPR62 ^= 1u << 17u;
    }

    /**
     * Get GPR62's MIPI_DSI_PCLK_SOFT_RESET_N bit.
     *
     * MIPI DSI APB clock domain software reset bit
     */
    inline bool get_GPR62_MIPI_DSI_PCLK_SOFT_RESET_N() volatile
    {
        return GPR62 & (1u << 16u);
    }

    /**
     * Set GPR62's MIPI_DSI_PCLK_SOFT_RESET_N bit.
     *
     * MIPI DSI APB clock domain software reset bit
     */
    inline void set_GPR62_MIPI_DSI_PCLK_SOFT_RESET_N() volatile
    {
        GPR62 |= 1u << 16u;
    }

    /**
     * Clear GPR62's MIPI_DSI_PCLK_SOFT_RESET_N bit.
     *
     * MIPI DSI APB clock domain software reset bit
     */
    inline void clear_GPR62_MIPI_DSI_PCLK_SOFT_RESET_N() volatile
    {
        GPR62 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR62's MIPI_DSI_PCLK_SOFT_RESET_N bit.
     *
     * MIPI DSI APB clock domain software reset bit
     */
    inline void toggle_GPR62_MIPI_DSI_PCLK_SOFT_RESET_N() volatile
    {
        GPR62 ^= 1u << 16u;
    }

    /**
     * Get GPR62's MIPI_DSI_TX_ULPS_ENABLE field.
     *
     * DSI transmit ULPS mode enable
     */
    inline uint8_t get_GPR62_MIPI_DSI_TX_ULPS_ENABLE() volatile
    {
        return (GPR62 >> 11u) & 0b111u;
    }

    /**
     * Set GPR62's MIPI_DSI_TX_ULPS_ENABLE field.
     *
     * DSI transmit ULPS mode enable
     */
    inline void set_GPR62_MIPI_DSI_TX_ULPS_ENABLE(uint8_t value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b111u << 11u);
        curr |= (value & 0b111u) << 11u;

        GPR62 = curr;
    }

    /**
     * Get GPR62's MIPI_DSI_TX_RCAL field.
     *
     * MIPI DSI PHY on-chip termination control bits
     */
    inline uint8_t get_GPR62_MIPI_DSI_TX_RCAL() volatile
    {
        return (GPR62 >> 9u) & 0b11u;
    }

    /**
     * Set GPR62's MIPI_DSI_TX_RCAL field.
     *
     * MIPI DSI PHY on-chip termination control bits
     */
    inline void set_GPR62_MIPI_DSI_TX_RCAL(uint8_t value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b11u << 9u);
        curr |= (value & 0b11u) << 9u;

        GPR62 = curr;
    }

    /**
     * Get GPR62's MIPI_DSI_D1_TM field.
     *
     * MIPI DSI Data Lane 1 triming bits
     */
    inline uint8_t get_GPR62_MIPI_DSI_D1_TM() volatile
    {
        return (GPR62 >> 6u) & 0b111u;
    }

    /**
     * Set GPR62's MIPI_DSI_D1_TM field.
     *
     * MIPI DSI Data Lane 1 triming bits
     */
    inline void set_GPR62_MIPI_DSI_D1_TM(uint8_t value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b111u << 6u);
        curr |= (value & 0b111u) << 6u;

        GPR62 = curr;
    }

    /**
     * Get GPR62's MIPI_DSI_D0_TM field.
     *
     * MIPI DSI Data Lane 0 triming bits
     */
    inline uint8_t get_GPR62_MIPI_DSI_D0_TM() volatile
    {
        return (GPR62 >> 3u) & 0b111u;
    }

    /**
     * Set GPR62's MIPI_DSI_D0_TM field.
     *
     * MIPI DSI Data Lane 0 triming bits
     */
    inline void set_GPR62_MIPI_DSI_D0_TM(uint8_t value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b111u << 3u);
        curr |= (value & 0b111u) << 3u;

        GPR62 = curr;
    }

    /**
     * Get GPR62's MIPI_DSI_CLK_TM field.
     *
     * MIPI DSI Clock Lane triming bits
     */
    inline uint8_t get_GPR62_MIPI_DSI_CLK_TM() volatile
    {
        return (GPR62 >> 0u) & 0b111u;
    }

    /**
     * Set GPR62's MIPI_DSI_CLK_TM field.
     *
     * MIPI DSI Clock Lane triming bits
     */
    inline void set_GPR62_MIPI_DSI_CLK_TM(uint8_t value) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        GPR62 = curr;
    }

    /**
     * Get all of GPR62's bit fields.
     *
     * (read-write) GPR62 General Purpose Register
     */
    inline void get_GPR62(
        IOMUXC_GPR_GPR62_DWP_LOCK &DWP_LOCK, IOMUXC_GPR_GPR62_DWP &DWP,
        bool &MIPI_DSI_ESC_SOFT_RESET_N, bool &MIPI_DSI_DPI_SOFT_RESET_N,
        bool &MIPI_DSI_BYTE_SOFT_RESET_N, bool &MIPI_DSI_PCLK_SOFT_RESET_N,
        uint8_t &MIPI_DSI_TX_ULPS_ENABLE, uint8_t &MIPI_DSI_TX_RCAL,
        uint8_t &MIPI_DSI_D1_TM, uint8_t &MIPI_DSI_D0_TM,
        uint8_t &MIPI_DSI_CLK_TM) volatile
    {
        uint32_t curr = GPR62;

        DWP_LOCK = IOMUXC_GPR_GPR62_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR62_DWP((curr >> 28u) & 0b11u);
        MIPI_DSI_ESC_SOFT_RESET_N = curr & (1u << 19u);
        MIPI_DSI_DPI_SOFT_RESET_N = curr & (1u << 18u);
        MIPI_DSI_BYTE_SOFT_RESET_N = curr & (1u << 17u);
        MIPI_DSI_PCLK_SOFT_RESET_N = curr & (1u << 16u);
        MIPI_DSI_TX_ULPS_ENABLE = (curr >> 11u) & 0b111u;
        MIPI_DSI_TX_RCAL = (curr >> 9u) & 0b11u;
        MIPI_DSI_D1_TM = (curr >> 6u) & 0b111u;
        MIPI_DSI_D0_TM = (curr >> 3u) & 0b111u;
        MIPI_DSI_CLK_TM = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of GPR62's bit fields.
     *
     * (read-write) GPR62 General Purpose Register
     */
    inline void set_GPR62(
        IOMUXC_GPR_GPR62_DWP_LOCK DWP_LOCK, IOMUXC_GPR_GPR62_DWP DWP,
        bool MIPI_DSI_ESC_SOFT_RESET_N, bool MIPI_DSI_DPI_SOFT_RESET_N,
        bool MIPI_DSI_BYTE_SOFT_RESET_N, bool MIPI_DSI_PCLK_SOFT_RESET_N,
        uint8_t MIPI_DSI_TX_ULPS_ENABLE, uint8_t MIPI_DSI_TX_RCAL,
        uint8_t MIPI_DSI_D1_TM, uint8_t MIPI_DSI_D0_TM,
        uint8_t MIPI_DSI_CLK_TM) volatile
    {
        uint32_t curr = GPR62;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 19u);
        curr |= (MIPI_DSI_ESC_SOFT_RESET_N & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (MIPI_DSI_DPI_SOFT_RESET_N & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (MIPI_DSI_BYTE_SOFT_RESET_N & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (MIPI_DSI_PCLK_SOFT_RESET_N & 0b1u) << 16u;
        curr &= ~(0b111u << 11u);
        curr |= (MIPI_DSI_TX_ULPS_ENABLE & 0b111u) << 11u;
        curr &= ~(0b11u << 9u);
        curr |= (MIPI_DSI_TX_RCAL & 0b11u) << 9u;
        curr &= ~(0b111u << 6u);
        curr |= (MIPI_DSI_D1_TM & 0b111u) << 6u;
        curr &= ~(0b111u << 3u);
        curr |= (MIPI_DSI_D0_TM & 0b111u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (MIPI_DSI_CLK_TM & 0b111u) << 0u;

        GPR62 = curr;
    }

    /**
     * Get GPR63's MIPI_DSI_TX_ULPS_ACTIVE field.
     *
     * DSI transmit ULPS mode active flag
     */
    inline uint8_t get_GPR63_MIPI_DSI_TX_ULPS_ACTIVE() volatile
    {
        return (GPR63 >> 0u) & 0b111u;
    }

    /**
     * Get GPR64's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR64_DWP_LOCK get_GPR64_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR64_DWP_LOCK((GPR64 >> 30u) & 0b11u);
    }

    /**
     * Set GPR64's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR64_DWP_LOCK(IOMUXC_GPR_GPR64_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR64;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR64 = curr;
    }

    /**
     * Get GPR64's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR64_DWP get_GPR64_DWP() volatile
    {
        return IOMUXC_GPR_GPR64_DWP((GPR64 >> 28u) & 0b11u);
    }

    /**
     * Set GPR64's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR64_DWP(IOMUXC_GPR_GPR64_DWP value) volatile
    {
        uint32_t curr = GPR64;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR64 = curr;
    }

    /**
     * Get GPR64's GPIO_DISP1_NASRC field.
     *
     * GPIO_DISP_B1 IO bank compensation codes
     */
    inline uint8_t get_GPR64_GPIO_DISP1_NASRC() volatile
    {
        return (GPR64 >> 21u) & 0b1111u;
    }

    /**
     * Get GPR64's GPIO_DISP1_COMPOK bit.
     *
     * GPIO_DISP_B1 IO bank compensation OK flag
     */
    inline bool get_GPR64_GPIO_DISP1_COMPOK() volatile
    {
        return GPR64 & (1u << 20u);
    }

    /**
     * Get GPR64's GPIO_DISP1_SUPLYDET_LATCH bit.
     *
     * GPIO_DISP_B1 IO bank power supply mode latch enable
     */
    inline bool get_GPR64_GPIO_DISP1_SUPLYDET_LATCH() volatile
    {
        return GPR64 & (1u << 14u);
    }

    /**
     * Set GPR64's GPIO_DISP1_SUPLYDET_LATCH bit.
     *
     * GPIO_DISP_B1 IO bank power supply mode latch enable
     */
    inline void set_GPR64_GPIO_DISP1_SUPLYDET_LATCH() volatile
    {
        GPR64 |= 1u << 14u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_SUPLYDET_LATCH bit.
     *
     * GPIO_DISP_B1 IO bank power supply mode latch enable
     */
    inline void clear_GPR64_GPIO_DISP1_SUPLYDET_LATCH() volatile
    {
        GPR64 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_SUPLYDET_LATCH bit.
     *
     * GPIO_DISP_B1 IO bank power supply mode latch enable
     */
    inline void toggle_GPR64_GPIO_DISP1_SUPLYDET_LATCH() volatile
    {
        GPR64 ^= 1u << 14u;
    }

    /**
     * Get GPR64's GPIO_DISP1_REFGEN_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank reference voltage generator cell sleep enable
     */
    inline bool get_GPR64_GPIO_DISP1_REFGEN_SLEEP() volatile
    {
        return GPR64 & (1u << 13u);
    }

    /**
     * Set GPR64's GPIO_DISP1_REFGEN_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void set_GPR64_GPIO_DISP1_REFGEN_SLEEP() volatile
    {
        GPR64 |= 1u << 13u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_REFGEN_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void clear_GPR64_GPIO_DISP1_REFGEN_SLEEP() volatile
    {
        GPR64 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_REFGEN_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void toggle_GPR64_GPIO_DISP1_REFGEN_SLEEP() volatile
    {
        GPR64 ^= 1u << 13u;
    }

    /**
     * Get GPR64's GPIO_DISP1_SELECT_NASRC bit.
     *
     * GPIO_DISP1_NASRC selection
     */
    inline bool get_GPR64_GPIO_DISP1_SELECT_NASRC() volatile
    {
        return GPR64 & (1u << 12u);
    }

    /**
     * Set GPR64's GPIO_DISP1_SELECT_NASRC bit.
     *
     * GPIO_DISP1_NASRC selection
     */
    inline void set_GPR64_GPIO_DISP1_SELECT_NASRC() volatile
    {
        GPR64 |= 1u << 12u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_SELECT_NASRC bit.
     *
     * GPIO_DISP1_NASRC selection
     */
    inline void clear_GPR64_GPIO_DISP1_SELECT_NASRC() volatile
    {
        GPR64 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_SELECT_NASRC bit.
     *
     * GPIO_DISP1_NASRC selection
     */
    inline void toggle_GPR64_GPIO_DISP1_SELECT_NASRC() volatile
    {
        GPR64 ^= 1u << 12u;
    }

    /**
     * Get GPR64's GPIO_DISP1_RASRCN field.
     *
     * GPIO_DISP_B1 IO bank's 4-bit NMOS compensation codes from core
     */
    inline uint8_t get_GPR64_GPIO_DISP1_RASRCN() volatile
    {
        return (GPR64 >> 8u) & 0b1111u;
    }

    /**
     * Set GPR64's GPIO_DISP1_RASRCN field.
     *
     * GPIO_DISP_B1 IO bank's 4-bit NMOS compensation codes from core
     */
    inline void set_GPR64_GPIO_DISP1_RASRCN(uint8_t value) volatile
    {
        uint32_t curr = GPR64;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        GPR64 = curr;
    }

    /**
     * Get GPR64's GPIO_DISP1_RASRCP field.
     *
     * GPIO_DISP_B1 IO bank's 4-bit PMOS compensation codes from core
     */
    inline uint8_t get_GPR64_GPIO_DISP1_RASRCP() volatile
    {
        return (GPR64 >> 4u) & 0b1111u;
    }

    /**
     * Set GPR64's GPIO_DISP1_RASRCP field.
     *
     * GPIO_DISP_B1 IO bank's 4-bit PMOS compensation codes from core
     */
    inline void set_GPR64_GPIO_DISP1_RASRCP(uint8_t value) volatile
    {
        uint32_t curr = GPR64;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        GPR64 = curr;
    }

    /**
     * Get GPR64's GPIO_DISP1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline bool get_GPR64_GPIO_DISP1_FASTFRZ_EN() volatile
    {
        return GPR64 & (1u << 3u);
    }

    /**
     * Set GPR64's GPIO_DISP1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void set_GPR64_GPIO_DISP1_FASTFRZ_EN() volatile
    {
        GPR64 |= 1u << 3u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void clear_GPR64_GPIO_DISP1_FASTFRZ_EN() volatile
    {
        GPR64 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void toggle_GPR64_GPIO_DISP1_FASTFRZ_EN() volatile
    {
        GPR64 ^= 1u << 3u;
    }

    /**
     * Get GPR64's GPIO_DISP1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR64_GPIO_DISP1_COMPEN() volatile
    {
        return GPR64 & (1u << 2u);
    }

    /**
     * Set GPR64's GPIO_DISP1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR64_GPIO_DISP1_COMPEN() volatile
    {
        GPR64 |= 1u << 2u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR64_GPIO_DISP1_COMPEN() volatile
    {
        GPR64 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR64_GPIO_DISP1_COMPEN() volatile
    {
        GPR64 ^= 1u << 2u;
    }

    /**
     * Get GPR64's GPIO_DISP1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR64_GPIO_DISP1_COMPTQ() volatile
    {
        return GPR64 & (1u << 1u);
    }

    /**
     * Set GPR64's GPIO_DISP1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR64_GPIO_DISP1_COMPTQ() volatile
    {
        GPR64 |= 1u << 1u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR64_GPIO_DISP1_COMPTQ() volatile
    {
        GPR64 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR64_GPIO_DISP1_COMPTQ() volatile
    {
        GPR64 ^= 1u << 1u;
    }

    /**
     * Get GPR64's GPIO_DISP1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline bool get_GPR64_GPIO_DISP1_FREEZE() volatile
    {
        return GPR64 & (1u << 0u);
    }

    /**
     * Set GPR64's GPIO_DISP1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void set_GPR64_GPIO_DISP1_FREEZE() volatile
    {
        GPR64 |= 1u << 0u;
    }

    /**
     * Clear GPR64's GPIO_DISP1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void clear_GPR64_GPIO_DISP1_FREEZE() volatile
    {
        GPR64 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR64's GPIO_DISP1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void toggle_GPR64_GPIO_DISP1_FREEZE() volatile
    {
        GPR64 ^= 1u << 0u;
    }

    /**
     * Get all of GPR64's bit fields.
     *
     * (read-write) GPR64 General Purpose Register
     */
    inline void get_GPR64(
        IOMUXC_GPR_GPR64_DWP_LOCK &DWP_LOCK, IOMUXC_GPR_GPR64_DWP &DWP,
        uint8_t &GPIO_DISP1_NASRC, bool &GPIO_DISP1_COMPOK,
        bool &GPIO_DISP1_SUPLYDET_LATCH, bool &GPIO_DISP1_REFGEN_SLEEP,
        bool &GPIO_DISP1_SELECT_NASRC, uint8_t &GPIO_DISP1_RASRCN,
        uint8_t &GPIO_DISP1_RASRCP, bool &GPIO_DISP1_FASTFRZ_EN,
        bool &GPIO_DISP1_COMPEN, bool &GPIO_DISP1_COMPTQ,
        bool &GPIO_DISP1_FREEZE) volatile
    {
        uint32_t curr = GPR64;

        DWP_LOCK = IOMUXC_GPR_GPR64_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR64_DWP((curr >> 28u) & 0b11u);
        GPIO_DISP1_NASRC = (curr >> 21u) & 0b1111u;
        GPIO_DISP1_COMPOK = curr & (1u << 20u);
        GPIO_DISP1_SUPLYDET_LATCH = curr & (1u << 14u);
        GPIO_DISP1_REFGEN_SLEEP = curr & (1u << 13u);
        GPIO_DISP1_SELECT_NASRC = curr & (1u << 12u);
        GPIO_DISP1_RASRCN = (curr >> 8u) & 0b1111u;
        GPIO_DISP1_RASRCP = (curr >> 4u) & 0b1111u;
        GPIO_DISP1_FASTFRZ_EN = curr & (1u << 3u);
        GPIO_DISP1_COMPEN = curr & (1u << 2u);
        GPIO_DISP1_COMPTQ = curr & (1u << 1u);
        GPIO_DISP1_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR64's bit fields.
     *
     * (read-write) GPR64 General Purpose Register
     */
    inline void set_GPR64(IOMUXC_GPR_GPR64_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR64_DWP DWP,
                          bool GPIO_DISP1_SUPLYDET_LATCH,
                          bool GPIO_DISP1_REFGEN_SLEEP,
                          bool GPIO_DISP1_SELECT_NASRC,
                          uint8_t GPIO_DISP1_RASRCN, uint8_t GPIO_DISP1_RASRCP,
                          bool GPIO_DISP1_FASTFRZ_EN, bool GPIO_DISP1_COMPEN,
                          bool GPIO_DISP1_COMPTQ,
                          bool GPIO_DISP1_FREEZE) volatile
    {
        uint32_t curr = GPR64;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 14u);
        curr |= (GPIO_DISP1_SUPLYDET_LATCH & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (GPIO_DISP1_REFGEN_SLEEP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (GPIO_DISP1_SELECT_NASRC & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (GPIO_DISP1_RASRCN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (GPIO_DISP1_RASRCP & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GPIO_DISP1_FASTFRZ_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GPIO_DISP1_COMPEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPIO_DISP1_COMPTQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GPIO_DISP1_FREEZE & 0b1u) << 0u;

        GPR64 = curr;
    }

    /**
     * Get GPR65's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR65_DWP_LOCK get_GPR65_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR65_DWP_LOCK((GPR65 >> 30u) & 0b11u);
    }

    /**
     * Set GPR65's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR65_DWP_LOCK(IOMUXC_GPR_GPR65_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR65;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR65 = curr;
    }

    /**
     * Get GPR65's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR65_DWP get_GPR65_DWP() volatile
    {
        return IOMUXC_GPR_GPR65_DWP((GPR65 >> 28u) & 0b11u);
    }

    /**
     * Set GPR65's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR65_DWP(IOMUXC_GPR_GPR65_DWP value) volatile
    {
        uint32_t curr = GPR65;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR65 = curr;
    }

    /**
     * Get GPR65's GPIO_EMC1_NASRC field.
     *
     * GPIO_EMC_B1 IO bank compensation codes
     */
    inline uint8_t get_GPR65_GPIO_EMC1_NASRC() volatile
    {
        return (GPR65 >> 21u) & 0b1111u;
    }

    /**
     * Get GPR65's GPIO_EMC1_COMPOK bit.
     *
     * GPIO_EMC_B1 IO bank compensation OK flag
     */
    inline bool get_GPR65_GPIO_EMC1_COMPOK() volatile
    {
        return GPR65 & (1u << 20u);
    }

    /**
     * Get GPR65's GPIO_EMC1_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B1 IO bank power supply mode latch enable
     */
    inline bool get_GPR65_GPIO_EMC1_SUPLYDET_LATCH() volatile
    {
        return GPR65 & (1u << 14u);
    }

    /**
     * Set GPR65's GPIO_EMC1_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B1 IO bank power supply mode latch enable
     */
    inline void set_GPR65_GPIO_EMC1_SUPLYDET_LATCH() volatile
    {
        GPR65 |= 1u << 14u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B1 IO bank power supply mode latch enable
     */
    inline void clear_GPR65_GPIO_EMC1_SUPLYDET_LATCH() volatile
    {
        GPR65 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B1 IO bank power supply mode latch enable
     */
    inline void toggle_GPR65_GPIO_EMC1_SUPLYDET_LATCH() volatile
    {
        GPR65 ^= 1u << 14u;
    }

    /**
     * Get GPR65's GPIO_EMC1_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank reference voltage generator cell sleep enable
     */
    inline bool get_GPR65_GPIO_EMC1_REFGEN_SLEEP() volatile
    {
        return GPR65 & (1u << 13u);
    }

    /**
     * Set GPR65's GPIO_EMC1_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void set_GPR65_GPIO_EMC1_REFGEN_SLEEP() volatile
    {
        GPR65 |= 1u << 13u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void clear_GPR65_GPIO_EMC1_REFGEN_SLEEP() volatile
    {
        GPR65 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void toggle_GPR65_GPIO_EMC1_REFGEN_SLEEP() volatile
    {
        GPR65 ^= 1u << 13u;
    }

    /**
     * Get GPR65's GPIO_EMC1_SELECT_NASRC bit.
     *
     * GPIO_EMC1_NASRC selection
     */
    inline bool get_GPR65_GPIO_EMC1_SELECT_NASRC() volatile
    {
        return GPR65 & (1u << 12u);
    }

    /**
     * Set GPR65's GPIO_EMC1_SELECT_NASRC bit.
     *
     * GPIO_EMC1_NASRC selection
     */
    inline void set_GPR65_GPIO_EMC1_SELECT_NASRC() volatile
    {
        GPR65 |= 1u << 12u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_SELECT_NASRC bit.
     *
     * GPIO_EMC1_NASRC selection
     */
    inline void clear_GPR65_GPIO_EMC1_SELECT_NASRC() volatile
    {
        GPR65 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_SELECT_NASRC bit.
     *
     * GPIO_EMC1_NASRC selection
     */
    inline void toggle_GPR65_GPIO_EMC1_SELECT_NASRC() volatile
    {
        GPR65 ^= 1u << 12u;
    }

    /**
     * Get GPR65's GPIO_EMC1_RASRCN field.
     *
     * GPIO_EMC_B1 IO bank's 4-bit NMOS compensation codes from core
     */
    inline uint8_t get_GPR65_GPIO_EMC1_RASRCN() volatile
    {
        return (GPR65 >> 8u) & 0b1111u;
    }

    /**
     * Set GPR65's GPIO_EMC1_RASRCN field.
     *
     * GPIO_EMC_B1 IO bank's 4-bit NMOS compensation codes from core
     */
    inline void set_GPR65_GPIO_EMC1_RASRCN(uint8_t value) volatile
    {
        uint32_t curr = GPR65;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        GPR65 = curr;
    }

    /**
     * Get GPR65's GPIO_EMC1_RASRCP field.
     *
     * GPIO_EMC_B1 IO bank's 4-bit PMOS compensation codes from core
     */
    inline uint8_t get_GPR65_GPIO_EMC1_RASRCP() volatile
    {
        return (GPR65 >> 4u) & 0b1111u;
    }

    /**
     * Set GPR65's GPIO_EMC1_RASRCP field.
     *
     * GPIO_EMC_B1 IO bank's 4-bit PMOS compensation codes from core
     */
    inline void set_GPR65_GPIO_EMC1_RASRCP(uint8_t value) volatile
    {
        uint32_t curr = GPR65;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        GPR65 = curr;
    }

    /**
     * Get GPR65's GPIO_EMC1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline bool get_GPR65_GPIO_EMC1_FASTFRZ_EN() volatile
    {
        return GPR65 & (1u << 3u);
    }

    /**
     * Set GPR65's GPIO_EMC1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void set_GPR65_GPIO_EMC1_FASTFRZ_EN() volatile
    {
        GPR65 |= 1u << 3u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void clear_GPR65_GPIO_EMC1_FASTFRZ_EN() volatile
    {
        GPR65 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void toggle_GPR65_GPIO_EMC1_FASTFRZ_EN() volatile
    {
        GPR65 ^= 1u << 3u;
    }

    /**
     * Get GPR65's GPIO_EMC1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR65_GPIO_EMC1_COMPEN() volatile
    {
        return GPR65 & (1u << 2u);
    }

    /**
     * Set GPR65's GPIO_EMC1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR65_GPIO_EMC1_COMPEN() volatile
    {
        GPR65 |= 1u << 2u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR65_GPIO_EMC1_COMPEN() volatile
    {
        GPR65 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR65_GPIO_EMC1_COMPEN() volatile
    {
        GPR65 ^= 1u << 2u;
    }

    /**
     * Get GPR65's GPIO_EMC1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR65_GPIO_EMC1_COMPTQ() volatile
    {
        return GPR65 & (1u << 1u);
    }

    /**
     * Set GPR65's GPIO_EMC1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR65_GPIO_EMC1_COMPTQ() volatile
    {
        GPR65 |= 1u << 1u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR65_GPIO_EMC1_COMPTQ() volatile
    {
        GPR65 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR65_GPIO_EMC1_COMPTQ() volatile
    {
        GPR65 ^= 1u << 1u;
    }

    /**
     * Get GPR65's GPIO_EMC1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline bool get_GPR65_GPIO_EMC1_FREEZE() volatile
    {
        return GPR65 & (1u << 0u);
    }

    /**
     * Set GPR65's GPIO_EMC1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void set_GPR65_GPIO_EMC1_FREEZE() volatile
    {
        GPR65 |= 1u << 0u;
    }

    /**
     * Clear GPR65's GPIO_EMC1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void clear_GPR65_GPIO_EMC1_FREEZE() volatile
    {
        GPR65 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR65's GPIO_EMC1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void toggle_GPR65_GPIO_EMC1_FREEZE() volatile
    {
        GPR65 ^= 1u << 0u;
    }

    /**
     * Get all of GPR65's bit fields.
     *
     * (read-write) GPR65 General Purpose Register
     */
    inline void get_GPR65(IOMUXC_GPR_GPR65_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR65_DWP &DWP, uint8_t &GPIO_EMC1_NASRC,
                          bool &GPIO_EMC1_COMPOK,
                          bool &GPIO_EMC1_SUPLYDET_LATCH,
                          bool &GPIO_EMC1_REFGEN_SLEEP,
                          bool &GPIO_EMC1_SELECT_NASRC,
                          uint8_t &GPIO_EMC1_RASRCN, uint8_t &GPIO_EMC1_RASRCP,
                          bool &GPIO_EMC1_FASTFRZ_EN, bool &GPIO_EMC1_COMPEN,
                          bool &GPIO_EMC1_COMPTQ,
                          bool &GPIO_EMC1_FREEZE) volatile
    {
        uint32_t curr = GPR65;

        DWP_LOCK = IOMUXC_GPR_GPR65_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR65_DWP((curr >> 28u) & 0b11u);
        GPIO_EMC1_NASRC = (curr >> 21u) & 0b1111u;
        GPIO_EMC1_COMPOK = curr & (1u << 20u);
        GPIO_EMC1_SUPLYDET_LATCH = curr & (1u << 14u);
        GPIO_EMC1_REFGEN_SLEEP = curr & (1u << 13u);
        GPIO_EMC1_SELECT_NASRC = curr & (1u << 12u);
        GPIO_EMC1_RASRCN = (curr >> 8u) & 0b1111u;
        GPIO_EMC1_RASRCP = (curr >> 4u) & 0b1111u;
        GPIO_EMC1_FASTFRZ_EN = curr & (1u << 3u);
        GPIO_EMC1_COMPEN = curr & (1u << 2u);
        GPIO_EMC1_COMPTQ = curr & (1u << 1u);
        GPIO_EMC1_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR65's bit fields.
     *
     * (read-write) GPR65 General Purpose Register
     */
    inline void set_GPR65(IOMUXC_GPR_GPR65_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR65_DWP DWP,
                          bool GPIO_EMC1_SUPLYDET_LATCH,
                          bool GPIO_EMC1_REFGEN_SLEEP,
                          bool GPIO_EMC1_SELECT_NASRC,
                          uint8_t GPIO_EMC1_RASRCN, uint8_t GPIO_EMC1_RASRCP,
                          bool GPIO_EMC1_FASTFRZ_EN, bool GPIO_EMC1_COMPEN,
                          bool GPIO_EMC1_COMPTQ,
                          bool GPIO_EMC1_FREEZE) volatile
    {
        uint32_t curr = GPR65;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 14u);
        curr |= (GPIO_EMC1_SUPLYDET_LATCH & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (GPIO_EMC1_REFGEN_SLEEP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (GPIO_EMC1_SELECT_NASRC & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (GPIO_EMC1_RASRCN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (GPIO_EMC1_RASRCP & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GPIO_EMC1_FASTFRZ_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GPIO_EMC1_COMPEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPIO_EMC1_COMPTQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GPIO_EMC1_FREEZE & 0b1u) << 0u;

        GPR65 = curr;
    }

    /**
     * Get GPR66's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR66_DWP_LOCK get_GPR66_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR66_DWP_LOCK((GPR66 >> 30u) & 0b11u);
    }

    /**
     * Set GPR66's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR66_DWP_LOCK(IOMUXC_GPR_GPR66_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR66;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR66 = curr;
    }

    /**
     * Get GPR66's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR66_DWP get_GPR66_DWP() volatile
    {
        return IOMUXC_GPR_GPR66_DWP((GPR66 >> 28u) & 0b11u);
    }

    /**
     * Set GPR66's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR66_DWP(IOMUXC_GPR_GPR66_DWP value) volatile
    {
        uint32_t curr = GPR66;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR66 = curr;
    }

    /**
     * Get GPR66's GPIO_EMC2_NASRC field.
     *
     * GPIO_EMC_B2 IO bank compensation codes
     */
    inline uint8_t get_GPR66_GPIO_EMC2_NASRC() volatile
    {
        return (GPR66 >> 21u) & 0b1111u;
    }

    /**
     * Get GPR66's GPIO_EMC2_COMPOK bit.
     *
     * GPIO_EMC_B2 IO bank compensation OK flag
     */
    inline bool get_GPR66_GPIO_EMC2_COMPOK() volatile
    {
        return GPR66 & (1u << 20u);
    }

    /**
     * Get GPR66's GPIO_EMC2_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B2 IO bank power supply mode latch enable
     */
    inline bool get_GPR66_GPIO_EMC2_SUPLYDET_LATCH() volatile
    {
        return GPR66 & (1u << 14u);
    }

    /**
     * Set GPR66's GPIO_EMC2_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B2 IO bank power supply mode latch enable
     */
    inline void set_GPR66_GPIO_EMC2_SUPLYDET_LATCH() volatile
    {
        GPR66 |= 1u << 14u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B2 IO bank power supply mode latch enable
     */
    inline void clear_GPR66_GPIO_EMC2_SUPLYDET_LATCH() volatile
    {
        GPR66 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_SUPLYDET_LATCH bit.
     *
     * GPIO_EMC_B2 IO bank power supply mode latch enable
     */
    inline void toggle_GPR66_GPIO_EMC2_SUPLYDET_LATCH() volatile
    {
        GPR66 ^= 1u << 14u;
    }

    /**
     * Get GPR66's GPIO_EMC2_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank reference voltage generator cell sleep enable
     */
    inline bool get_GPR66_GPIO_EMC2_REFGEN_SLEEP() volatile
    {
        return GPR66 & (1u << 13u);
    }

    /**
     * Set GPR66's GPIO_EMC2_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank reference voltage generator cell sleep enable
     */
    inline void set_GPR66_GPIO_EMC2_REFGEN_SLEEP() volatile
    {
        GPR66 |= 1u << 13u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank reference voltage generator cell sleep enable
     */
    inline void clear_GPR66_GPIO_EMC2_REFGEN_SLEEP() volatile
    {
        GPR66 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_REFGEN_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank reference voltage generator cell sleep enable
     */
    inline void toggle_GPR66_GPIO_EMC2_REFGEN_SLEEP() volatile
    {
        GPR66 ^= 1u << 13u;
    }

    /**
     * Get GPR66's GPIO_EMC2_SELECT_NASRC bit.
     *
     * GPIO_EMC2_NASRC selection
     */
    inline bool get_GPR66_GPIO_EMC2_SELECT_NASRC() volatile
    {
        return GPR66 & (1u << 12u);
    }

    /**
     * Set GPR66's GPIO_EMC2_SELECT_NASRC bit.
     *
     * GPIO_EMC2_NASRC selection
     */
    inline void set_GPR66_GPIO_EMC2_SELECT_NASRC() volatile
    {
        GPR66 |= 1u << 12u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_SELECT_NASRC bit.
     *
     * GPIO_EMC2_NASRC selection
     */
    inline void clear_GPR66_GPIO_EMC2_SELECT_NASRC() volatile
    {
        GPR66 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_SELECT_NASRC bit.
     *
     * GPIO_EMC2_NASRC selection
     */
    inline void toggle_GPR66_GPIO_EMC2_SELECT_NASRC() volatile
    {
        GPR66 ^= 1u << 12u;
    }

    /**
     * Get GPR66's GPIO_EMC2_RASRCN field.
     *
     * GPIO_EMC_B2 IO bank's 4-bit NMOS compensation codes from core
     */
    inline uint8_t get_GPR66_GPIO_EMC2_RASRCN() volatile
    {
        return (GPR66 >> 8u) & 0b1111u;
    }

    /**
     * Set GPR66's GPIO_EMC2_RASRCN field.
     *
     * GPIO_EMC_B2 IO bank's 4-bit NMOS compensation codes from core
     */
    inline void set_GPR66_GPIO_EMC2_RASRCN(uint8_t value) volatile
    {
        uint32_t curr = GPR66;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        GPR66 = curr;
    }

    /**
     * Get GPR66's GPIO_EMC2_RASRCP field.
     *
     * GPIO_EMC_B2 IO bank's 4-bit PMOS compensation codes from core
     */
    inline uint8_t get_GPR66_GPIO_EMC2_RASRCP() volatile
    {
        return (GPR66 >> 4u) & 0b1111u;
    }

    /**
     * Set GPR66's GPIO_EMC2_RASRCP field.
     *
     * GPIO_EMC_B2 IO bank's 4-bit PMOS compensation codes from core
     */
    inline void set_GPR66_GPIO_EMC2_RASRCP(uint8_t value) volatile
    {
        uint32_t curr = GPR66;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        GPR66 = curr;
    }

    /**
     * Get GPR66's GPIO_EMC2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline bool get_GPR66_GPIO_EMC2_FASTFRZ_EN() volatile
    {
        return GPR66 & (1u << 3u);
    }

    /**
     * Set GPR66's GPIO_EMC2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void set_GPR66_GPIO_EMC2_FASTFRZ_EN() volatile
    {
        GPR66 |= 1u << 3u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void clear_GPR66_GPIO_EMC2_FASTFRZ_EN() volatile
    {
        GPR66 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void toggle_GPR66_GPIO_EMC2_FASTFRZ_EN() volatile
    {
        GPR66 ^= 1u << 3u;
    }

    /**
     * Get GPR66's GPIO_EMC2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR66_GPIO_EMC2_COMPEN() volatile
    {
        return GPR66 & (1u << 2u);
    }

    /**
     * Set GPR66's GPIO_EMC2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR66_GPIO_EMC2_COMPEN() volatile
    {
        GPR66 |= 1u << 2u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR66_GPIO_EMC2_COMPEN() volatile
    {
        GPR66 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR66_GPIO_EMC2_COMPEN() volatile
    {
        GPR66 ^= 1u << 2u;
    }

    /**
     * Get GPR66's GPIO_EMC2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR66_GPIO_EMC2_COMPTQ() volatile
    {
        return GPR66 & (1u << 1u);
    }

    /**
     * Set GPR66's GPIO_EMC2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR66_GPIO_EMC2_COMPTQ() volatile
    {
        GPR66 |= 1u << 1u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR66_GPIO_EMC2_COMPTQ() volatile
    {
        GPR66 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR66_GPIO_EMC2_COMPTQ() volatile
    {
        GPR66 ^= 1u << 1u;
    }

    /**
     * Get GPR66's GPIO_EMC2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline bool get_GPR66_GPIO_EMC2_FREEZE() volatile
    {
        return GPR66 & (1u << 0u);
    }

    /**
     * Set GPR66's GPIO_EMC2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void set_GPR66_GPIO_EMC2_FREEZE() volatile
    {
        GPR66 |= 1u << 0u;
    }

    /**
     * Clear GPR66's GPIO_EMC2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void clear_GPR66_GPIO_EMC2_FREEZE() volatile
    {
        GPR66 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR66's GPIO_EMC2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void toggle_GPR66_GPIO_EMC2_FREEZE() volatile
    {
        GPR66 ^= 1u << 0u;
    }

    /**
     * Get all of GPR66's bit fields.
     *
     * (read-write) GPR66 General Purpose Register
     */
    inline void get_GPR66(IOMUXC_GPR_GPR66_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR66_DWP &DWP, uint8_t &GPIO_EMC2_NASRC,
                          bool &GPIO_EMC2_COMPOK,
                          bool &GPIO_EMC2_SUPLYDET_LATCH,
                          bool &GPIO_EMC2_REFGEN_SLEEP,
                          bool &GPIO_EMC2_SELECT_NASRC,
                          uint8_t &GPIO_EMC2_RASRCN, uint8_t &GPIO_EMC2_RASRCP,
                          bool &GPIO_EMC2_FASTFRZ_EN, bool &GPIO_EMC2_COMPEN,
                          bool &GPIO_EMC2_COMPTQ,
                          bool &GPIO_EMC2_FREEZE) volatile
    {
        uint32_t curr = GPR66;

        DWP_LOCK = IOMUXC_GPR_GPR66_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR66_DWP((curr >> 28u) & 0b11u);
        GPIO_EMC2_NASRC = (curr >> 21u) & 0b1111u;
        GPIO_EMC2_COMPOK = curr & (1u << 20u);
        GPIO_EMC2_SUPLYDET_LATCH = curr & (1u << 14u);
        GPIO_EMC2_REFGEN_SLEEP = curr & (1u << 13u);
        GPIO_EMC2_SELECT_NASRC = curr & (1u << 12u);
        GPIO_EMC2_RASRCN = (curr >> 8u) & 0b1111u;
        GPIO_EMC2_RASRCP = (curr >> 4u) & 0b1111u;
        GPIO_EMC2_FASTFRZ_EN = curr & (1u << 3u);
        GPIO_EMC2_COMPEN = curr & (1u << 2u);
        GPIO_EMC2_COMPTQ = curr & (1u << 1u);
        GPIO_EMC2_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR66's bit fields.
     *
     * (read-write) GPR66 General Purpose Register
     */
    inline void set_GPR66(IOMUXC_GPR_GPR66_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR66_DWP DWP,
                          bool GPIO_EMC2_SUPLYDET_LATCH,
                          bool GPIO_EMC2_REFGEN_SLEEP,
                          bool GPIO_EMC2_SELECT_NASRC,
                          uint8_t GPIO_EMC2_RASRCN, uint8_t GPIO_EMC2_RASRCP,
                          bool GPIO_EMC2_FASTFRZ_EN, bool GPIO_EMC2_COMPEN,
                          bool GPIO_EMC2_COMPTQ,
                          bool GPIO_EMC2_FREEZE) volatile
    {
        uint32_t curr = GPR66;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 14u);
        curr |= (GPIO_EMC2_SUPLYDET_LATCH & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (GPIO_EMC2_REFGEN_SLEEP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (GPIO_EMC2_SELECT_NASRC & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (GPIO_EMC2_RASRCN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (GPIO_EMC2_RASRCP & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GPIO_EMC2_FASTFRZ_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GPIO_EMC2_COMPEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPIO_EMC2_COMPTQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GPIO_EMC2_FREEZE & 0b1u) << 0u;

        GPR66 = curr;
    }

    /**
     * Get GPR67's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR67_DWP_LOCK get_GPR67_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR67_DWP_LOCK((GPR67 >> 30u) & 0b11u);
    }

    /**
     * Set GPR67's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR67_DWP_LOCK(IOMUXC_GPR_GPR67_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR67;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR67 = curr;
    }

    /**
     * Get GPR67's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR67_DWP get_GPR67_DWP() volatile
    {
        return IOMUXC_GPR_GPR67_DWP((GPR67 >> 28u) & 0b11u);
    }

    /**
     * Set GPR67's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR67_DWP(IOMUXC_GPR_GPR67_DWP value) volatile
    {
        uint32_t curr = GPR67;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR67 = curr;
    }

    /**
     * Get GPR67's GPIO_SD1_NASRC field.
     *
     * GPIO_SD_B1 IO bank compensation codes
     */
    inline uint8_t get_GPR67_GPIO_SD1_NASRC() volatile
    {
        return (GPR67 >> 21u) & 0b1111u;
    }

    /**
     * Get GPR67's GPIO_SD1_COMPOK bit.
     *
     * GPIO_SD_B1 IO bank compensation OK flag
     */
    inline bool get_GPR67_GPIO_SD1_COMPOK() volatile
    {
        return GPR67 & (1u << 20u);
    }

    /**
     * Get GPR67's GPIO_SD1_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B1 IO bank power supply mode latch enable
     */
    inline bool get_GPR67_GPIO_SD1_SUPLYDET_LATCH() volatile
    {
        return GPR67 & (1u << 14u);
    }

    /**
     * Set GPR67's GPIO_SD1_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B1 IO bank power supply mode latch enable
     */
    inline void set_GPR67_GPIO_SD1_SUPLYDET_LATCH() volatile
    {
        GPR67 |= 1u << 14u;
    }

    /**
     * Clear GPR67's GPIO_SD1_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B1 IO bank power supply mode latch enable
     */
    inline void clear_GPR67_GPIO_SD1_SUPLYDET_LATCH() volatile
    {
        GPR67 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B1 IO bank power supply mode latch enable
     */
    inline void toggle_GPR67_GPIO_SD1_SUPLYDET_LATCH() volatile
    {
        GPR67 ^= 1u << 14u;
    }

    /**
     * Get GPR67's GPIO_SD1_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank reference voltage generator cell sleep enable
     */
    inline bool get_GPR67_GPIO_SD1_REFGEN_SLEEP() volatile
    {
        return GPR67 & (1u << 13u);
    }

    /**
     * Set GPR67's GPIO_SD1_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void set_GPR67_GPIO_SD1_REFGEN_SLEEP() volatile
    {
        GPR67 |= 1u << 13u;
    }

    /**
     * Clear GPR67's GPIO_SD1_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void clear_GPR67_GPIO_SD1_REFGEN_SLEEP() volatile
    {
        GPR67 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank reference voltage generator cell sleep enable
     */
    inline void toggle_GPR67_GPIO_SD1_REFGEN_SLEEP() volatile
    {
        GPR67 ^= 1u << 13u;
    }

    /**
     * Get GPR67's GPIO_SD1_SELECT_NASRC bit.
     *
     * GPIO_SD1_NASRC selection
     */
    inline bool get_GPR67_GPIO_SD1_SELECT_NASRC() volatile
    {
        return GPR67 & (1u << 12u);
    }

    /**
     * Set GPR67's GPIO_SD1_SELECT_NASRC bit.
     *
     * GPIO_SD1_NASRC selection
     */
    inline void set_GPR67_GPIO_SD1_SELECT_NASRC() volatile
    {
        GPR67 |= 1u << 12u;
    }

    /**
     * Clear GPR67's GPIO_SD1_SELECT_NASRC bit.
     *
     * GPIO_SD1_NASRC selection
     */
    inline void clear_GPR67_GPIO_SD1_SELECT_NASRC() volatile
    {
        GPR67 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_SELECT_NASRC bit.
     *
     * GPIO_SD1_NASRC selection
     */
    inline void toggle_GPR67_GPIO_SD1_SELECT_NASRC() volatile
    {
        GPR67 ^= 1u << 12u;
    }

    /**
     * Get GPR67's GPIO_SD1_RASRCN field.
     *
     * GPIO_SD_B1 IO bank's 4-bit NMOS compensation codes from core
     */
    inline uint8_t get_GPR67_GPIO_SD1_RASRCN() volatile
    {
        return (GPR67 >> 8u) & 0b1111u;
    }

    /**
     * Set GPR67's GPIO_SD1_RASRCN field.
     *
     * GPIO_SD_B1 IO bank's 4-bit NMOS compensation codes from core
     */
    inline void set_GPR67_GPIO_SD1_RASRCN(uint8_t value) volatile
    {
        uint32_t curr = GPR67;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        GPR67 = curr;
    }

    /**
     * Get GPR67's GPIO_SD1_RASRCP field.
     *
     * GPIO_SD_B1 IO bank's 4-bit PMOS compensation codes from core
     */
    inline uint8_t get_GPR67_GPIO_SD1_RASRCP() volatile
    {
        return (GPR67 >> 4u) & 0b1111u;
    }

    /**
     * Set GPR67's GPIO_SD1_RASRCP field.
     *
     * GPIO_SD_B1 IO bank's 4-bit PMOS compensation codes from core
     */
    inline void set_GPR67_GPIO_SD1_RASRCP(uint8_t value) volatile
    {
        uint32_t curr = GPR67;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        GPR67 = curr;
    }

    /**
     * Get GPR67's GPIO_SD1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline bool get_GPR67_GPIO_SD1_FASTFRZ_EN() volatile
    {
        return GPR67 & (1u << 3u);
    }

    /**
     * Set GPR67's GPIO_SD1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void set_GPR67_GPIO_SD1_FASTFRZ_EN() volatile
    {
        GPR67 |= 1u << 3u;
    }

    /**
     * Clear GPR67's GPIO_SD1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void clear_GPR67_GPIO_SD1_FASTFRZ_EN() volatile
    {
        GPR67 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void toggle_GPR67_GPIO_SD1_FASTFRZ_EN() volatile
    {
        GPR67 ^= 1u << 3u;
    }

    /**
     * Get GPR67's GPIO_SD1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR67_GPIO_SD1_COMPEN() volatile
    {
        return GPR67 & (1u << 2u);
    }

    /**
     * Set GPR67's GPIO_SD1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR67_GPIO_SD1_COMPEN() volatile
    {
        GPR67 |= 1u << 2u;
    }

    /**
     * Clear GPR67's GPIO_SD1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR67_GPIO_SD1_COMPEN() volatile
    {
        GPR67 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR67_GPIO_SD1_COMPEN() volatile
    {
        GPR67 ^= 1u << 2u;
    }

    /**
     * Get GPR67's GPIO_SD1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR67_GPIO_SD1_COMPTQ() volatile
    {
        return GPR67 & (1u << 1u);
    }

    /**
     * Set GPR67's GPIO_SD1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR67_GPIO_SD1_COMPTQ() volatile
    {
        GPR67 |= 1u << 1u;
    }

    /**
     * Clear GPR67's GPIO_SD1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR67_GPIO_SD1_COMPTQ() volatile
    {
        GPR67 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR67_GPIO_SD1_COMPTQ() volatile
    {
        GPR67 ^= 1u << 1u;
    }

    /**
     * Get GPR67's GPIO_SD1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline bool get_GPR67_GPIO_SD1_FREEZE() volatile
    {
        return GPR67 & (1u << 0u);
    }

    /**
     * Set GPR67's GPIO_SD1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void set_GPR67_GPIO_SD1_FREEZE() volatile
    {
        GPR67 |= 1u << 0u;
    }

    /**
     * Clear GPR67's GPIO_SD1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void clear_GPR67_GPIO_SD1_FREEZE() volatile
    {
        GPR67 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR67's GPIO_SD1_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void toggle_GPR67_GPIO_SD1_FREEZE() volatile
    {
        GPR67 ^= 1u << 0u;
    }

    /**
     * Get all of GPR67's bit fields.
     *
     * (read-write) GPR67 General Purpose Register
     */
    inline void get_GPR67(IOMUXC_GPR_GPR67_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR67_DWP &DWP, uint8_t &GPIO_SD1_NASRC,
                          bool &GPIO_SD1_COMPOK, bool &GPIO_SD1_SUPLYDET_LATCH,
                          bool &GPIO_SD1_REFGEN_SLEEP,
                          bool &GPIO_SD1_SELECT_NASRC,
                          uint8_t &GPIO_SD1_RASRCN, uint8_t &GPIO_SD1_RASRCP,
                          bool &GPIO_SD1_FASTFRZ_EN, bool &GPIO_SD1_COMPEN,
                          bool &GPIO_SD1_COMPTQ,
                          bool &GPIO_SD1_FREEZE) volatile
    {
        uint32_t curr = GPR67;

        DWP_LOCK = IOMUXC_GPR_GPR67_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR67_DWP((curr >> 28u) & 0b11u);
        GPIO_SD1_NASRC = (curr >> 21u) & 0b1111u;
        GPIO_SD1_COMPOK = curr & (1u << 20u);
        GPIO_SD1_SUPLYDET_LATCH = curr & (1u << 14u);
        GPIO_SD1_REFGEN_SLEEP = curr & (1u << 13u);
        GPIO_SD1_SELECT_NASRC = curr & (1u << 12u);
        GPIO_SD1_RASRCN = (curr >> 8u) & 0b1111u;
        GPIO_SD1_RASRCP = (curr >> 4u) & 0b1111u;
        GPIO_SD1_FASTFRZ_EN = curr & (1u << 3u);
        GPIO_SD1_COMPEN = curr & (1u << 2u);
        GPIO_SD1_COMPTQ = curr & (1u << 1u);
        GPIO_SD1_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR67's bit fields.
     *
     * (read-write) GPR67 General Purpose Register
     */
    inline void set_GPR67(IOMUXC_GPR_GPR67_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR67_DWP DWP,
                          bool GPIO_SD1_SUPLYDET_LATCH,
                          bool GPIO_SD1_REFGEN_SLEEP,
                          bool GPIO_SD1_SELECT_NASRC, uint8_t GPIO_SD1_RASRCN,
                          uint8_t GPIO_SD1_RASRCP, bool GPIO_SD1_FASTFRZ_EN,
                          bool GPIO_SD1_COMPEN, bool GPIO_SD1_COMPTQ,
                          bool GPIO_SD1_FREEZE) volatile
    {
        uint32_t curr = GPR67;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 14u);
        curr |= (GPIO_SD1_SUPLYDET_LATCH & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (GPIO_SD1_REFGEN_SLEEP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (GPIO_SD1_SELECT_NASRC & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (GPIO_SD1_RASRCN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (GPIO_SD1_RASRCP & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GPIO_SD1_FASTFRZ_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GPIO_SD1_COMPEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPIO_SD1_COMPTQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GPIO_SD1_FREEZE & 0b1u) << 0u;

        GPR67 = curr;
    }

    /**
     * Get GPR68's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR68_DWP_LOCK get_GPR68_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR68_DWP_LOCK((GPR68 >> 30u) & 0b11u);
    }

    /**
     * Set GPR68's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR68_DWP_LOCK(IOMUXC_GPR_GPR68_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR68;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR68 = curr;
    }

    /**
     * Get GPR68's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR68_DWP get_GPR68_DWP() volatile
    {
        return IOMUXC_GPR_GPR68_DWP((GPR68 >> 28u) & 0b11u);
    }

    /**
     * Set GPR68's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR68_DWP(IOMUXC_GPR_GPR68_DWP value) volatile
    {
        uint32_t curr = GPR68;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR68 = curr;
    }

    /**
     * Get GPR68's GPIO_SD2_NASRC field.
     *
     * GPIO_SD_B2 IO bank compensation codes
     */
    inline uint8_t get_GPR68_GPIO_SD2_NASRC() volatile
    {
        return (GPR68 >> 21u) & 0b1111u;
    }

    /**
     * Get GPR68's GPIO_SD2_COMPOK bit.
     *
     * GPIO_SD_B2 IO bank compensation OK flag
     */
    inline bool get_GPR68_GPIO_SD2_COMPOK() volatile
    {
        return GPR68 & (1u << 20u);
    }

    /**
     * Get GPR68's GPIO_SD2_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B2 IO bank power supply mode latch enable
     */
    inline bool get_GPR68_GPIO_SD2_SUPLYDET_LATCH() volatile
    {
        return GPR68 & (1u << 14u);
    }

    /**
     * Set GPR68's GPIO_SD2_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B2 IO bank power supply mode latch enable
     */
    inline void set_GPR68_GPIO_SD2_SUPLYDET_LATCH() volatile
    {
        GPR68 |= 1u << 14u;
    }

    /**
     * Clear GPR68's GPIO_SD2_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B2 IO bank power supply mode latch enable
     */
    inline void clear_GPR68_GPIO_SD2_SUPLYDET_LATCH() volatile
    {
        GPR68 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_SUPLYDET_LATCH bit.
     *
     * GPIO_SD_B2 IO bank power supply mode latch enable
     */
    inline void toggle_GPR68_GPIO_SD2_SUPLYDET_LATCH() volatile
    {
        GPR68 ^= 1u << 14u;
    }

    /**
     * Get GPR68's GPIO_SD2_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank reference voltage generator cell sleep enable
     */
    inline bool get_GPR68_GPIO_SD2_REFGEN_SLEEP() volatile
    {
        return GPR68 & (1u << 13u);
    }

    /**
     * Set GPR68's GPIO_SD2_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank reference voltage generator cell sleep enable
     */
    inline void set_GPR68_GPIO_SD2_REFGEN_SLEEP() volatile
    {
        GPR68 |= 1u << 13u;
    }

    /**
     * Clear GPR68's GPIO_SD2_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank reference voltage generator cell sleep enable
     */
    inline void clear_GPR68_GPIO_SD2_REFGEN_SLEEP() volatile
    {
        GPR68 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_REFGEN_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank reference voltage generator cell sleep enable
     */
    inline void toggle_GPR68_GPIO_SD2_REFGEN_SLEEP() volatile
    {
        GPR68 ^= 1u << 13u;
    }

    /**
     * Get GPR68's GPIO_SD2_SELECT_NASRC bit.
     *
     * GPIO_SD2_NASRC selection
     */
    inline bool get_GPR68_GPIO_SD2_SELECT_NASRC() volatile
    {
        return GPR68 & (1u << 12u);
    }

    /**
     * Set GPR68's GPIO_SD2_SELECT_NASRC bit.
     *
     * GPIO_SD2_NASRC selection
     */
    inline void set_GPR68_GPIO_SD2_SELECT_NASRC() volatile
    {
        GPR68 |= 1u << 12u;
    }

    /**
     * Clear GPR68's GPIO_SD2_SELECT_NASRC bit.
     *
     * GPIO_SD2_NASRC selection
     */
    inline void clear_GPR68_GPIO_SD2_SELECT_NASRC() volatile
    {
        GPR68 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_SELECT_NASRC bit.
     *
     * GPIO_SD2_NASRC selection
     */
    inline void toggle_GPR68_GPIO_SD2_SELECT_NASRC() volatile
    {
        GPR68 ^= 1u << 12u;
    }

    /**
     * Get GPR68's GPIO_SD2_RASRCN field.
     *
     * GPIO_SD_B2 IO bank's 4-bit NMOS compensation codes from core
     */
    inline uint8_t get_GPR68_GPIO_SD2_RASRCN() volatile
    {
        return (GPR68 >> 8u) & 0b1111u;
    }

    /**
     * Set GPR68's GPIO_SD2_RASRCN field.
     *
     * GPIO_SD_B2 IO bank's 4-bit NMOS compensation codes from core
     */
    inline void set_GPR68_GPIO_SD2_RASRCN(uint8_t value) volatile
    {
        uint32_t curr = GPR68;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        GPR68 = curr;
    }

    /**
     * Get GPR68's GPIO_SD2_RASRCP field.
     *
     * GPIO_SD_B2 IO bank's 4-bit PMOS compensation codes from core
     */
    inline uint8_t get_GPR68_GPIO_SD2_RASRCP() volatile
    {
        return (GPR68 >> 4u) & 0b1111u;
    }

    /**
     * Set GPR68's GPIO_SD2_RASRCP field.
     *
     * GPIO_SD_B2 IO bank's 4-bit PMOS compensation codes from core
     */
    inline void set_GPR68_GPIO_SD2_RASRCP(uint8_t value) volatile
    {
        uint32_t curr = GPR68;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        GPR68 = curr;
    }

    /**
     * Get GPR68's GPIO_SD2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline bool get_GPR68_GPIO_SD2_FASTFRZ_EN() volatile
    {
        return GPR68 & (1u << 3u);
    }

    /**
     * Set GPR68's GPIO_SD2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void set_GPR68_GPIO_SD2_FASTFRZ_EN() volatile
    {
        GPR68 |= 1u << 3u;
    }

    /**
     * Clear GPR68's GPIO_SD2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void clear_GPR68_GPIO_SD2_FASTFRZ_EN() volatile
    {
        GPR68 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_FASTFRZ_EN bit.
     *
     * Compensation code fast freeze
     */
    inline void toggle_GPR68_GPIO_SD2_FASTFRZ_EN() volatile
    {
        GPR68 ^= 1u << 3u;
    }

    /**
     * Get GPR68's GPIO_SD2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR68_GPIO_SD2_COMPEN() volatile
    {
        return GPR68 & (1u << 2u);
    }

    /**
     * Set GPR68's GPIO_SD2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR68_GPIO_SD2_COMPEN() volatile
    {
        GPR68 |= 1u << 2u;
    }

    /**
     * Clear GPR68's GPIO_SD2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR68_GPIO_SD2_COMPEN() volatile
    {
        GPR68 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_COMPEN bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR68_GPIO_SD2_COMPEN() volatile
    {
        GPR68 ^= 1u << 2u;
    }

    /**
     * Get GPR68's GPIO_SD2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline bool get_GPR68_GPIO_SD2_COMPTQ() volatile
    {
        return GPR68 & (1u << 1u);
    }

    /**
     * Set GPR68's GPIO_SD2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void set_GPR68_GPIO_SD2_COMPTQ() volatile
    {
        GPR68 |= 1u << 1u;
    }

    /**
     * Clear GPR68's GPIO_SD2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void clear_GPR68_GPIO_SD2_COMPTQ() volatile
    {
        GPR68 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_COMPTQ bit.
     *
     * COMPEN and COMPTQ control the operating modes of the compensation cell
     */
    inline void toggle_GPR68_GPIO_SD2_COMPTQ() volatile
    {
        GPR68 ^= 1u << 1u;
    }

    /**
     * Get GPR68's GPIO_SD2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline bool get_GPR68_GPIO_SD2_FREEZE() volatile
    {
        return GPR68 & (1u << 0u);
    }

    /**
     * Set GPR68's GPIO_SD2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void set_GPR68_GPIO_SD2_FREEZE() volatile
    {
        GPR68 |= 1u << 0u;
    }

    /**
     * Clear GPR68's GPIO_SD2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void clear_GPR68_GPIO_SD2_FREEZE() volatile
    {
        GPR68 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR68's GPIO_SD2_FREEZE bit.
     *
     * Compensation code freeze
     */
    inline void toggle_GPR68_GPIO_SD2_FREEZE() volatile
    {
        GPR68 ^= 1u << 0u;
    }

    /**
     * Get all of GPR68's bit fields.
     *
     * (read-write) GPR68 General Purpose Register
     */
    inline void get_GPR68(IOMUXC_GPR_GPR68_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR68_DWP &DWP, uint8_t &GPIO_SD2_NASRC,
                          bool &GPIO_SD2_COMPOK, bool &GPIO_SD2_SUPLYDET_LATCH,
                          bool &GPIO_SD2_REFGEN_SLEEP,
                          bool &GPIO_SD2_SELECT_NASRC,
                          uint8_t &GPIO_SD2_RASRCN, uint8_t &GPIO_SD2_RASRCP,
                          bool &GPIO_SD2_FASTFRZ_EN, bool &GPIO_SD2_COMPEN,
                          bool &GPIO_SD2_COMPTQ,
                          bool &GPIO_SD2_FREEZE) volatile
    {
        uint32_t curr = GPR68;

        DWP_LOCK = IOMUXC_GPR_GPR68_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR68_DWP((curr >> 28u) & 0b11u);
        GPIO_SD2_NASRC = (curr >> 21u) & 0b1111u;
        GPIO_SD2_COMPOK = curr & (1u << 20u);
        GPIO_SD2_SUPLYDET_LATCH = curr & (1u << 14u);
        GPIO_SD2_REFGEN_SLEEP = curr & (1u << 13u);
        GPIO_SD2_SELECT_NASRC = curr & (1u << 12u);
        GPIO_SD2_RASRCN = (curr >> 8u) & 0b1111u;
        GPIO_SD2_RASRCP = (curr >> 4u) & 0b1111u;
        GPIO_SD2_FASTFRZ_EN = curr & (1u << 3u);
        GPIO_SD2_COMPEN = curr & (1u << 2u);
        GPIO_SD2_COMPTQ = curr & (1u << 1u);
        GPIO_SD2_FREEZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR68's bit fields.
     *
     * (read-write) GPR68 General Purpose Register
     */
    inline void set_GPR68(IOMUXC_GPR_GPR68_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR68_DWP DWP,
                          bool GPIO_SD2_SUPLYDET_LATCH,
                          bool GPIO_SD2_REFGEN_SLEEP,
                          bool GPIO_SD2_SELECT_NASRC, uint8_t GPIO_SD2_RASRCN,
                          uint8_t GPIO_SD2_RASRCP, bool GPIO_SD2_FASTFRZ_EN,
                          bool GPIO_SD2_COMPEN, bool GPIO_SD2_COMPTQ,
                          bool GPIO_SD2_FREEZE) volatile
    {
        uint32_t curr = GPR68;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 14u);
        curr |= (GPIO_SD2_SUPLYDET_LATCH & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (GPIO_SD2_REFGEN_SLEEP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (GPIO_SD2_SELECT_NASRC & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (GPIO_SD2_RASRCN & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (GPIO_SD2_RASRCP & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GPIO_SD2_FASTFRZ_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GPIO_SD2_COMPEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPIO_SD2_COMPTQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GPIO_SD2_FREEZE & 0b1u) << 0u;

        GPR68 = curr;
    }

    /**
     * Get GPR69's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR69_DWP_LOCK get_GPR69_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR69_DWP_LOCK((GPR69 >> 30u) & 0b11u);
    }

    /**
     * Set GPR69's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR69_DWP_LOCK(IOMUXC_GPR_GPR69_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR69;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR69 = curr;
    }

    /**
     * Get GPR69's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR69_DWP get_GPR69_DWP() volatile
    {
        return IOMUXC_GPR_GPR69_DWP((GPR69 >> 28u) & 0b11u);
    }

    /**
     * Set GPR69's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR69_DWP(IOMUXC_GPR_GPR69_DWP value) volatile
    {
        uint32_t curr = GPR69;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR69 = curr;
    }

    /**
     * Get GPR69's SUPLYDET_SD2_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank supply voltage detector sleep mode enable
     */
    inline bool get_GPR69_SUPLYDET_SD2_SLEEP() volatile
    {
        return GPR69 & (1u << 13u);
    }

    /**
     * Set GPR69's SUPLYDET_SD2_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank supply voltage detector sleep mode enable
     */
    inline void set_GPR69_SUPLYDET_SD2_SLEEP() volatile
    {
        GPR69 |= 1u << 13u;
    }

    /**
     * Clear GPR69's SUPLYDET_SD2_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank supply voltage detector sleep mode enable
     */
    inline void clear_GPR69_SUPLYDET_SD2_SLEEP() volatile
    {
        GPR69 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR69's SUPLYDET_SD2_SLEEP bit.
     *
     * GPIO_SD_B2 IO bank supply voltage detector sleep mode enable
     */
    inline void toggle_GPR69_SUPLYDET_SD2_SLEEP() volatile
    {
        GPR69 ^= 1u << 13u;
    }

    /**
     * Get GPR69's SUPLYDET_SD1_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank supply voltage detector sleep mode enable
     */
    inline bool get_GPR69_SUPLYDET_SD1_SLEEP() volatile
    {
        return GPR69 & (1u << 12u);
    }

    /**
     * Set GPR69's SUPLYDET_SD1_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void set_GPR69_SUPLYDET_SD1_SLEEP() volatile
    {
        GPR69 |= 1u << 12u;
    }

    /**
     * Clear GPR69's SUPLYDET_SD1_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void clear_GPR69_SUPLYDET_SD1_SLEEP() volatile
    {
        GPR69 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR69's SUPLYDET_SD1_SLEEP bit.
     *
     * GPIO_SD_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void toggle_GPR69_SUPLYDET_SD1_SLEEP() volatile
    {
        GPR69 ^= 1u << 12u;
    }

    /**
     * Get GPR69's SUPLYDET_EMC2_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank supply voltage detector sleep mode enable
     */
    inline bool get_GPR69_SUPLYDET_EMC2_SLEEP() volatile
    {
        return GPR69 & (1u << 11u);
    }

    /**
     * Set GPR69's SUPLYDET_EMC2_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank supply voltage detector sleep mode enable
     */
    inline void set_GPR69_SUPLYDET_EMC2_SLEEP() volatile
    {
        GPR69 |= 1u << 11u;
    }

    /**
     * Clear GPR69's SUPLYDET_EMC2_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank supply voltage detector sleep mode enable
     */
    inline void clear_GPR69_SUPLYDET_EMC2_SLEEP() volatile
    {
        GPR69 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR69's SUPLYDET_EMC2_SLEEP bit.
     *
     * GPIO_EMC_B2 IO bank supply voltage detector sleep mode enable
     */
    inline void toggle_GPR69_SUPLYDET_EMC2_SLEEP() volatile
    {
        GPR69 ^= 1u << 11u;
    }

    /**
     * Get GPR69's SUPLYDET_EMC1_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank supply voltage detector sleep mode enable
     */
    inline bool get_GPR69_SUPLYDET_EMC1_SLEEP() volatile
    {
        return GPR69 & (1u << 10u);
    }

    /**
     * Set GPR69's SUPLYDET_EMC1_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void set_GPR69_SUPLYDET_EMC1_SLEEP() volatile
    {
        GPR69 |= 1u << 10u;
    }

    /**
     * Clear GPR69's SUPLYDET_EMC1_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void clear_GPR69_SUPLYDET_EMC1_SLEEP() volatile
    {
        GPR69 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR69's SUPLYDET_EMC1_SLEEP bit.
     *
     * GPIO_EMC_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void toggle_GPR69_SUPLYDET_EMC1_SLEEP() volatile
    {
        GPR69 ^= 1u << 10u;
    }

    /**
     * Get GPR69's SUPLYDET_DISP1_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank supply voltage detector sleep mode enable
     */
    inline bool get_GPR69_SUPLYDET_DISP1_SLEEP() volatile
    {
        return GPR69 & (1u << 9u);
    }

    /**
     * Set GPR69's SUPLYDET_DISP1_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void set_GPR69_SUPLYDET_DISP1_SLEEP() volatile
    {
        GPR69 |= 1u << 9u;
    }

    /**
     * Clear GPR69's SUPLYDET_DISP1_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void clear_GPR69_SUPLYDET_DISP1_SLEEP() volatile
    {
        GPR69 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR69's SUPLYDET_DISP1_SLEEP bit.
     *
     * GPIO_DISP_B1 IO bank supply voltage detector sleep mode enable
     */
    inline void toggle_GPR69_SUPLYDET_DISP1_SLEEP() volatile
    {
        GPR69 ^= 1u << 9u;
    }

    /**
     * Get GPR69's GPIO_AD1_LOW_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline bool get_GPR69_GPIO_AD1_LOW_RANGE() volatile
    {
        return GPR69 & (1u << 8u);
    }

    /**
     * Set GPR69's GPIO_AD1_LOW_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline void set_GPR69_GPIO_AD1_LOW_RANGE() volatile
    {
        GPR69 |= 1u << 8u;
    }

    /**
     * Clear GPR69's GPIO_AD1_LOW_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline void clear_GPR69_GPIO_AD1_LOW_RANGE() volatile
    {
        GPR69 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR69's GPIO_AD1_LOW_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline void toggle_GPR69_GPIO_AD1_LOW_RANGE() volatile
    {
        GPR69 ^= 1u << 8u;
    }

    /**
     * Get GPR69's GPIO_AD1_HIGH_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline bool get_GPR69_GPIO_AD1_HIGH_RANGE() volatile
    {
        return GPR69 & (1u << 7u);
    }

    /**
     * Set GPR69's GPIO_AD1_HIGH_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline void set_GPR69_GPIO_AD1_HIGH_RANGE() volatile
    {
        GPR69 |= 1u << 7u;
    }

    /**
     * Clear GPR69's GPIO_AD1_HIGH_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline void clear_GPR69_GPIO_AD1_HIGH_RANGE() volatile
    {
        GPR69 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR69's GPIO_AD1_HIGH_RANGE bit.
     *
     * GPIO_LPSR IO bank supply voltage range selection for GPIO_AD_18 to
     * GPIO_AD_35
     */
    inline void toggle_GPR69_GPIO_AD1_HIGH_RANGE() volatile
    {
        GPR69 ^= 1u << 7u;
    }

    /**
     * Get GPR69's GPIO_AD0_LOW_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline bool get_GPR69_GPIO_AD0_LOW_RANGE() volatile
    {
        return GPR69 & (1u << 5u);
    }

    /**
     * Set GPR69's GPIO_AD0_LOW_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline void set_GPR69_GPIO_AD0_LOW_RANGE() volatile
    {
        GPR69 |= 1u << 5u;
    }

    /**
     * Clear GPR69's GPIO_AD0_LOW_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline void clear_GPR69_GPIO_AD0_LOW_RANGE() volatile
    {
        GPR69 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR69's GPIO_AD0_LOW_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline void toggle_GPR69_GPIO_AD0_LOW_RANGE() volatile
    {
        GPR69 ^= 1u << 5u;
    }

    /**
     * Get GPR69's GPIO_AD0_HIGH_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline bool get_GPR69_GPIO_AD0_HIGH_RANGE() volatile
    {
        return GPR69 & (1u << 4u);
    }

    /**
     * Set GPR69's GPIO_AD0_HIGH_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline void set_GPR69_GPIO_AD0_HIGH_RANGE() volatile
    {
        GPR69 |= 1u << 4u;
    }

    /**
     * Clear GPR69's GPIO_AD0_HIGH_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline void clear_GPR69_GPIO_AD0_HIGH_RANGE() volatile
    {
        GPR69 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR69's GPIO_AD0_HIGH_RANGE bit.
     *
     * GPIO_AD IO bank supply voltage range selection for GPIO_AD_00 to
     * GPIO_AD_17
     */
    inline void toggle_GPR69_GPIO_AD0_HIGH_RANGE() volatile
    {
        GPR69 ^= 1u << 4u;
    }

    /**
     * Get GPR69's GPIO_DISP2_LOW_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline bool get_GPR69_GPIO_DISP2_LOW_RANGE() volatile
    {
        return GPR69 & (1u << 2u);
    }

    /**
     * Set GPR69's GPIO_DISP2_LOW_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline void set_GPR69_GPIO_DISP2_LOW_RANGE() volatile
    {
        GPR69 |= 1u << 2u;
    }

    /**
     * Clear GPR69's GPIO_DISP2_LOW_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline void clear_GPR69_GPIO_DISP2_LOW_RANGE() volatile
    {
        GPR69 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR69's GPIO_DISP2_LOW_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline void toggle_GPR69_GPIO_DISP2_LOW_RANGE() volatile
    {
        GPR69 ^= 1u << 2u;
    }

    /**
     * Get GPR69's GPIO_DISP2_HIGH_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline bool get_GPR69_GPIO_DISP2_HIGH_RANGE() volatile
    {
        return GPR69 & (1u << 1u);
    }

    /**
     * Set GPR69's GPIO_DISP2_HIGH_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline void set_GPR69_GPIO_DISP2_HIGH_RANGE() volatile
    {
        GPR69 |= 1u << 1u;
    }

    /**
     * Clear GPR69's GPIO_DISP2_HIGH_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline void clear_GPR69_GPIO_DISP2_HIGH_RANGE() volatile
    {
        GPR69 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR69's GPIO_DISP2_HIGH_RANGE bit.
     *
     * GPIO_DISP_B2 IO bank supply voltage range selection
     */
    inline void toggle_GPR69_GPIO_DISP2_HIGH_RANGE() volatile
    {
        GPR69 ^= 1u << 1u;
    }

    /**
     * Get all of GPR69's bit fields.
     *
     * (read-write) GPR69 General Purpose Register
     */
    inline void get_GPR69(IOMUXC_GPR_GPR69_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR69_DWP &DWP, bool &SUPLYDET_SD2_SLEEP,
                          bool &SUPLYDET_SD1_SLEEP, bool &SUPLYDET_EMC2_SLEEP,
                          bool &SUPLYDET_EMC1_SLEEP,
                          bool &SUPLYDET_DISP1_SLEEP, bool &GPIO_AD1_LOW_RANGE,
                          bool &GPIO_AD1_HIGH_RANGE, bool &GPIO_AD0_LOW_RANGE,
                          bool &GPIO_AD0_HIGH_RANGE,
                          bool &GPIO_DISP2_LOW_RANGE,
                          bool &GPIO_DISP2_HIGH_RANGE) volatile
    {
        uint32_t curr = GPR69;

        DWP_LOCK = IOMUXC_GPR_GPR69_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR69_DWP((curr >> 28u) & 0b11u);
        SUPLYDET_SD2_SLEEP = curr & (1u << 13u);
        SUPLYDET_SD1_SLEEP = curr & (1u << 12u);
        SUPLYDET_EMC2_SLEEP = curr & (1u << 11u);
        SUPLYDET_EMC1_SLEEP = curr & (1u << 10u);
        SUPLYDET_DISP1_SLEEP = curr & (1u << 9u);
        GPIO_AD1_LOW_RANGE = curr & (1u << 8u);
        GPIO_AD1_HIGH_RANGE = curr & (1u << 7u);
        GPIO_AD0_LOW_RANGE = curr & (1u << 5u);
        GPIO_AD0_HIGH_RANGE = curr & (1u << 4u);
        GPIO_DISP2_LOW_RANGE = curr & (1u << 2u);
        GPIO_DISP2_HIGH_RANGE = curr & (1u << 1u);
    }

    /**
     * Set all of GPR69's bit fields.
     *
     * (read-write) GPR69 General Purpose Register
     */
    inline void set_GPR69(IOMUXC_GPR_GPR69_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR69_DWP DWP, bool SUPLYDET_SD2_SLEEP,
                          bool SUPLYDET_SD1_SLEEP, bool SUPLYDET_EMC2_SLEEP,
                          bool SUPLYDET_EMC1_SLEEP, bool SUPLYDET_DISP1_SLEEP,
                          bool GPIO_AD1_LOW_RANGE, bool GPIO_AD1_HIGH_RANGE,
                          bool GPIO_AD0_LOW_RANGE, bool GPIO_AD0_HIGH_RANGE,
                          bool GPIO_DISP2_LOW_RANGE,
                          bool GPIO_DISP2_HIGH_RANGE) volatile
    {
        uint32_t curr = GPR69;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 13u);
        curr |= (SUPLYDET_SD2_SLEEP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (SUPLYDET_SD1_SLEEP & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SUPLYDET_EMC2_SLEEP & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SUPLYDET_EMC1_SLEEP & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SUPLYDET_DISP1_SLEEP & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (GPIO_AD1_LOW_RANGE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (GPIO_AD1_HIGH_RANGE & 0b1u) << 7u;
        curr &= ~(0b1u << 5u);
        curr |= (GPIO_AD0_LOW_RANGE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (GPIO_AD0_HIGH_RANGE & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (GPIO_DISP2_LOW_RANGE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPIO_DISP2_HIGH_RANGE & 0b1u) << 1u;

        GPR69 = curr;
    }

    /**
     * Get GPR70's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR70_DWP_LOCK get_GPR70_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR70_DWP_LOCK((GPR70 >> 30u) & 0b11u);
    }

    /**
     * Set GPR70's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR70_DWP_LOCK(IOMUXC_GPR_GPR70_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR70;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR70 = curr;
    }

    /**
     * Get GPR70's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR70_DWP get_GPR70_DWP() volatile
    {
        return IOMUXC_GPR_GPR70_DWP((GPR70 >> 28u) & 0b11u);
    }

    /**
     * Set GPR70's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR70_DWP(IOMUXC_GPR_GPR70_DWP value) volatile
    {
        uint32_t curr = GPR70;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR70 = curr;
    }

    /**
     * Get GPR70's FLEXSPI2_STOP_REQ bit.
     *
     * FLEXSPI2 stop request
     */
    inline bool get_GPR70_FLEXSPI2_STOP_REQ() volatile
    {
        return GPR70 & (1u << 26u);
    }

    /**
     * Set GPR70's FLEXSPI2_STOP_REQ bit.
     *
     * FLEXSPI2 stop request
     */
    inline void set_GPR70_FLEXSPI2_STOP_REQ() volatile
    {
        GPR70 |= 1u << 26u;
    }

    /**
     * Clear GPR70's FLEXSPI2_STOP_REQ bit.
     *
     * FLEXSPI2 stop request
     */
    inline void clear_GPR70_FLEXSPI2_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 26u);
    }

    /**
     * Toggle GPR70's FLEXSPI2_STOP_REQ bit.
     *
     * FLEXSPI2 stop request
     */
    inline void toggle_GPR70_FLEXSPI2_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 26u;
    }

    /**
     * Get GPR70's FLEXSPI2_IPG_DOZE bit.
     *
     * FLEXSPI2 doze mode
     */
    inline bool get_GPR70_FLEXSPI2_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 25u);
    }

    /**
     * Set GPR70's FLEXSPI2_IPG_DOZE bit.
     *
     * FLEXSPI2 doze mode
     */
    inline void set_GPR70_FLEXSPI2_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 25u;
    }

    /**
     * Clear GPR70's FLEXSPI2_IPG_DOZE bit.
     *
     * FLEXSPI2 doze mode
     */
    inline void clear_GPR70_FLEXSPI2_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 25u);
    }

    /**
     * Toggle GPR70's FLEXSPI2_IPG_DOZE bit.
     *
     * FLEXSPI2 doze mode
     */
    inline void toggle_GPR70_FLEXSPI2_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 25u;
    }

    /**
     * Get GPR70's FLEXSPI1_STOP_REQ bit.
     *
     * FLEXSPI1 stop request
     */
    inline bool get_GPR70_FLEXSPI1_STOP_REQ() volatile
    {
        return GPR70 & (1u << 24u);
    }

    /**
     * Set GPR70's FLEXSPI1_STOP_REQ bit.
     *
     * FLEXSPI1 stop request
     */
    inline void set_GPR70_FLEXSPI1_STOP_REQ() volatile
    {
        GPR70 |= 1u << 24u;
    }

    /**
     * Clear GPR70's FLEXSPI1_STOP_REQ bit.
     *
     * FLEXSPI1 stop request
     */
    inline void clear_GPR70_FLEXSPI1_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 24u);
    }

    /**
     * Toggle GPR70's FLEXSPI1_STOP_REQ bit.
     *
     * FLEXSPI1 stop request
     */
    inline void toggle_GPR70_FLEXSPI1_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 24u;
    }

    /**
     * Get GPR70's FLEXSPI1_IPG_DOZE bit.
     *
     * FLEXSPI1 doze mode
     */
    inline bool get_GPR70_FLEXSPI1_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 23u);
    }

    /**
     * Set GPR70's FLEXSPI1_IPG_DOZE bit.
     *
     * FLEXSPI1 doze mode
     */
    inline void set_GPR70_FLEXSPI1_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 23u;
    }

    /**
     * Clear GPR70's FLEXSPI1_IPG_DOZE bit.
     *
     * FLEXSPI1 doze mode
     */
    inline void clear_GPR70_FLEXSPI1_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 23u);
    }

    /**
     * Toggle GPR70's FLEXSPI1_IPG_DOZE bit.
     *
     * FLEXSPI1 doze mode
     */
    inline void toggle_GPR70_FLEXSPI1_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 23u;
    }

    /**
     * Get GPR70's FLEXIO2_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline bool get_GPR70_FLEXIO2_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 22u);
    }

    /**
     * Set GPR70's FLEXIO2_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline void set_GPR70_FLEXIO2_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 22u;
    }

    /**
     * Clear GPR70's FLEXIO2_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline void clear_GPR70_FLEXIO2_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 22u);
    }

    /**
     * Toggle GPR70's FLEXIO2_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline void toggle_GPR70_FLEXIO2_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 22u;
    }

    /**
     * Get GPR70's FLEXIO1_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline bool get_GPR70_FLEXIO1_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 21u);
    }

    /**
     * Set GPR70's FLEXIO1_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline void set_GPR70_FLEXIO1_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 21u;
    }

    /**
     * Clear GPR70's FLEXIO1_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline void clear_GPR70_FLEXIO1_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 21u);
    }

    /**
     * Toggle GPR70's FLEXIO1_IPG_DOZE bit.
     *
     * FLEXIO2 doze mode
     */
    inline void toggle_GPR70_FLEXIO1_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 21u;
    }

    /**
     * Get GPR70's ENET1G_STOP_REQ bit.
     *
     * ENET1G stop request
     */
    inline bool get_GPR70_ENET1G_STOP_REQ() volatile
    {
        return GPR70 & (1u << 20u);
    }

    /**
     * Set GPR70's ENET1G_STOP_REQ bit.
     *
     * ENET1G stop request
     */
    inline void set_GPR70_ENET1G_STOP_REQ() volatile
    {
        GPR70 |= 1u << 20u;
    }

    /**
     * Clear GPR70's ENET1G_STOP_REQ bit.
     *
     * ENET1G stop request
     */
    inline void clear_GPR70_ENET1G_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 20u);
    }

    /**
     * Toggle GPR70's ENET1G_STOP_REQ bit.
     *
     * ENET1G stop request
     */
    inline void toggle_GPR70_ENET1G_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 20u;
    }

    /**
     * Get GPR70's ENET1G_IPG_DOZE bit.
     *
     * ENET1G doze mode
     */
    inline bool get_GPR70_ENET1G_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 19u);
    }

    /**
     * Set GPR70's ENET1G_IPG_DOZE bit.
     *
     * ENET1G doze mode
     */
    inline void set_GPR70_ENET1G_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 19u;
    }

    /**
     * Clear GPR70's ENET1G_IPG_DOZE bit.
     *
     * ENET1G doze mode
     */
    inline void clear_GPR70_ENET1G_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 19u);
    }

    /**
     * Toggle GPR70's ENET1G_IPG_DOZE bit.
     *
     * ENET1G doze mode
     */
    inline void toggle_GPR70_ENET1G_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 19u;
    }

    /**
     * Get GPR70's ENET_STOP_REQ bit.
     *
     * ENET stop request
     */
    inline bool get_GPR70_ENET_STOP_REQ() volatile
    {
        return GPR70 & (1u << 18u);
    }

    /**
     * Set GPR70's ENET_STOP_REQ bit.
     *
     * ENET stop request
     */
    inline void set_GPR70_ENET_STOP_REQ() volatile
    {
        GPR70 |= 1u << 18u;
    }

    /**
     * Clear GPR70's ENET_STOP_REQ bit.
     *
     * ENET stop request
     */
    inline void clear_GPR70_ENET_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 18u);
    }

    /**
     * Toggle GPR70's ENET_STOP_REQ bit.
     *
     * ENET stop request
     */
    inline void toggle_GPR70_ENET_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 18u;
    }

    /**
     * Get GPR70's ENET_IPG_DOZE bit.
     *
     * ENET doze mode
     */
    inline bool get_GPR70_ENET_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 17u);
    }

    /**
     * Set GPR70's ENET_IPG_DOZE bit.
     *
     * ENET doze mode
     */
    inline void set_GPR70_ENET_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 17u;
    }

    /**
     * Clear GPR70's ENET_IPG_DOZE bit.
     *
     * ENET doze mode
     */
    inline void clear_GPR70_ENET_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR70's ENET_IPG_DOZE bit.
     *
     * ENET doze mode
     */
    inline void toggle_GPR70_ENET_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 17u;
    }

    /**
     * Get GPR70's EDMA_LPSR_STOP_REQ bit.
     *
     * EDMA_LPSR stop request
     */
    inline bool get_GPR70_EDMA_LPSR_STOP_REQ() volatile
    {
        return GPR70 & (1u << 16u);
    }

    /**
     * Set GPR70's EDMA_LPSR_STOP_REQ bit.
     *
     * EDMA_LPSR stop request
     */
    inline void set_GPR70_EDMA_LPSR_STOP_REQ() volatile
    {
        GPR70 |= 1u << 16u;
    }

    /**
     * Clear GPR70's EDMA_LPSR_STOP_REQ bit.
     *
     * EDMA_LPSR stop request
     */
    inline void clear_GPR70_EDMA_LPSR_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR70's EDMA_LPSR_STOP_REQ bit.
     *
     * EDMA_LPSR stop request
     */
    inline void toggle_GPR70_EDMA_LPSR_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 16u;
    }

    /**
     * Get GPR70's EDMA_STOP_REQ bit.
     *
     * EDMA stop request
     */
    inline bool get_GPR70_EDMA_STOP_REQ() volatile
    {
        return GPR70 & (1u << 15u);
    }

    /**
     * Set GPR70's EDMA_STOP_REQ bit.
     *
     * EDMA stop request
     */
    inline void set_GPR70_EDMA_STOP_REQ() volatile
    {
        GPR70 |= 1u << 15u;
    }

    /**
     * Clear GPR70's EDMA_STOP_REQ bit.
     *
     * EDMA stop request
     */
    inline void clear_GPR70_EDMA_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 15u);
    }

    /**
     * Toggle GPR70's EDMA_STOP_REQ bit.
     *
     * EDMA stop request
     */
    inline void toggle_GPR70_EDMA_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 15u;
    }

    /**
     * Get GPR70's CAN3_STOP_REQ bit.
     *
     * CAN3 stop request
     */
    inline bool get_GPR70_CAN3_STOP_REQ() volatile
    {
        return GPR70 & (1u << 13u);
    }

    /**
     * Set GPR70's CAN3_STOP_REQ bit.
     *
     * CAN3 stop request
     */
    inline void set_GPR70_CAN3_STOP_REQ() volatile
    {
        GPR70 |= 1u << 13u;
    }

    /**
     * Clear GPR70's CAN3_STOP_REQ bit.
     *
     * CAN3 stop request
     */
    inline void clear_GPR70_CAN3_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR70's CAN3_STOP_REQ bit.
     *
     * CAN3 stop request
     */
    inline void toggle_GPR70_CAN3_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 13u;
    }

    /**
     * Get GPR70's CAN3_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline bool get_GPR70_CAN3_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 12u);
    }

    /**
     * Set GPR70's CAN3_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline void set_GPR70_CAN3_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 12u;
    }

    /**
     * Clear GPR70's CAN3_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline void clear_GPR70_CAN3_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR70's CAN3_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline void toggle_GPR70_CAN3_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 12u;
    }

    /**
     * Get GPR70's CAN2_STOP_REQ bit.
     *
     * CAN2 stop request
     */
    inline bool get_GPR70_CAN2_STOP_REQ() volatile
    {
        return GPR70 & (1u << 11u);
    }

    /**
     * Set GPR70's CAN2_STOP_REQ bit.
     *
     * CAN2 stop request
     */
    inline void set_GPR70_CAN2_STOP_REQ() volatile
    {
        GPR70 |= 1u << 11u;
    }

    /**
     * Clear GPR70's CAN2_STOP_REQ bit.
     *
     * CAN2 stop request
     */
    inline void clear_GPR70_CAN2_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR70's CAN2_STOP_REQ bit.
     *
     * CAN2 stop request
     */
    inline void toggle_GPR70_CAN2_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 11u;
    }

    /**
     * Get GPR70's CAN2_IPG_DOZE bit.
     *
     * CAN2 doze mode
     */
    inline bool get_GPR70_CAN2_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 10u);
    }

    /**
     * Set GPR70's CAN2_IPG_DOZE bit.
     *
     * CAN2 doze mode
     */
    inline void set_GPR70_CAN2_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 10u;
    }

    /**
     * Clear GPR70's CAN2_IPG_DOZE bit.
     *
     * CAN2 doze mode
     */
    inline void clear_GPR70_CAN2_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR70's CAN2_IPG_DOZE bit.
     *
     * CAN2 doze mode
     */
    inline void toggle_GPR70_CAN2_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 10u;
    }

    /**
     * Get GPR70's CAN1_STOP_REQ bit.
     *
     * CAN1 stop request
     */
    inline bool get_GPR70_CAN1_STOP_REQ() volatile
    {
        return GPR70 & (1u << 9u);
    }

    /**
     * Set GPR70's CAN1_STOP_REQ bit.
     *
     * CAN1 stop request
     */
    inline void set_GPR70_CAN1_STOP_REQ() volatile
    {
        GPR70 |= 1u << 9u;
    }

    /**
     * Clear GPR70's CAN1_STOP_REQ bit.
     *
     * CAN1 stop request
     */
    inline void clear_GPR70_CAN1_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR70's CAN1_STOP_REQ bit.
     *
     * CAN1 stop request
     */
    inline void toggle_GPR70_CAN1_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 9u;
    }

    /**
     * Get GPR70's CAN1_IPG_DOZE bit.
     *
     * CAN1 doze mode
     */
    inline bool get_GPR70_CAN1_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 8u);
    }

    /**
     * Set GPR70's CAN1_IPG_DOZE bit.
     *
     * CAN1 doze mode
     */
    inline void set_GPR70_CAN1_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 8u;
    }

    /**
     * Clear GPR70's CAN1_IPG_DOZE bit.
     *
     * CAN1 doze mode
     */
    inline void clear_GPR70_CAN1_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR70's CAN1_IPG_DOZE bit.
     *
     * CAN1 doze mode
     */
    inline void toggle_GPR70_CAN1_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 8u;
    }

    /**
     * Get GPR70's CAAM_STOP_REQ bit.
     *
     * CAAM stop request
     */
    inline bool get_GPR70_CAAM_STOP_REQ() volatile
    {
        return GPR70 & (1u << 7u);
    }

    /**
     * Set GPR70's CAAM_STOP_REQ bit.
     *
     * CAAM stop request
     */
    inline void set_GPR70_CAAM_STOP_REQ() volatile
    {
        GPR70 |= 1u << 7u;
    }

    /**
     * Clear GPR70's CAAM_STOP_REQ bit.
     *
     * CAAM stop request
     */
    inline void clear_GPR70_CAAM_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR70's CAAM_STOP_REQ bit.
     *
     * CAAM stop request
     */
    inline void toggle_GPR70_CAAM_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 7u;
    }

    /**
     * Get GPR70's CAAM_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline bool get_GPR70_CAAM_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 6u);
    }

    /**
     * Set GPR70's CAAM_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline void set_GPR70_CAAM_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 6u;
    }

    /**
     * Clear GPR70's CAAM_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline void clear_GPR70_CAAM_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR70's CAAM_IPG_DOZE bit.
     *
     * CAN3 doze mode
     */
    inline void toggle_GPR70_CAAM_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 6u;
    }

    /**
     * Get GPR70's ADC2_IPG_STOP_MODE bit.
     *
     * ADC2 stop mode selection, cannot change when ADC2_STOP_REQ is asserted.
     */
    inline bool get_GPR70_ADC2_IPG_STOP_MODE() volatile
    {
        return GPR70 & (1u << 5u);
    }

    /**
     * Set GPR70's ADC2_IPG_STOP_MODE bit.
     *
     * ADC2 stop mode selection, cannot change when ADC2_STOP_REQ is asserted.
     */
    inline void set_GPR70_ADC2_IPG_STOP_MODE() volatile
    {
        GPR70 |= 1u << 5u;
    }

    /**
     * Clear GPR70's ADC2_IPG_STOP_MODE bit.
     *
     * ADC2 stop mode selection, cannot change when ADC2_STOP_REQ is asserted.
     */
    inline void clear_GPR70_ADC2_IPG_STOP_MODE() volatile
    {
        GPR70 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR70's ADC2_IPG_STOP_MODE bit.
     *
     * ADC2 stop mode selection, cannot change when ADC2_STOP_REQ is asserted.
     */
    inline void toggle_GPR70_ADC2_IPG_STOP_MODE() volatile
    {
        GPR70 ^= 1u << 5u;
    }

    /**
     * Get GPR70's ADC2_STOP_REQ bit.
     *
     * ADC2 stop request
     */
    inline bool get_GPR70_ADC2_STOP_REQ() volatile
    {
        return GPR70 & (1u << 4u);
    }

    /**
     * Set GPR70's ADC2_STOP_REQ bit.
     *
     * ADC2 stop request
     */
    inline void set_GPR70_ADC2_STOP_REQ() volatile
    {
        GPR70 |= 1u << 4u;
    }

    /**
     * Clear GPR70's ADC2_STOP_REQ bit.
     *
     * ADC2 stop request
     */
    inline void clear_GPR70_ADC2_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR70's ADC2_STOP_REQ bit.
     *
     * ADC2 stop request
     */
    inline void toggle_GPR70_ADC2_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 4u;
    }

    /**
     * Get GPR70's ADC2_IPG_DOZE bit.
     *
     * ADC2 doze mode
     */
    inline bool get_GPR70_ADC2_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 3u);
    }

    /**
     * Set GPR70's ADC2_IPG_DOZE bit.
     *
     * ADC2 doze mode
     */
    inline void set_GPR70_ADC2_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 3u;
    }

    /**
     * Clear GPR70's ADC2_IPG_DOZE bit.
     *
     * ADC2 doze mode
     */
    inline void clear_GPR70_ADC2_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR70's ADC2_IPG_DOZE bit.
     *
     * ADC2 doze mode
     */
    inline void toggle_GPR70_ADC2_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 3u;
    }

    /**
     * Get GPR70's ADC1_IPG_STOP_MODE bit.
     *
     * ADC1 stop mode selection, cannot change when ADC1_STOP_REQ is asserted.
     */
    inline bool get_GPR70_ADC1_IPG_STOP_MODE() volatile
    {
        return GPR70 & (1u << 2u);
    }

    /**
     * Set GPR70's ADC1_IPG_STOP_MODE bit.
     *
     * ADC1 stop mode selection, cannot change when ADC1_STOP_REQ is asserted.
     */
    inline void set_GPR70_ADC1_IPG_STOP_MODE() volatile
    {
        GPR70 |= 1u << 2u;
    }

    /**
     * Clear GPR70's ADC1_IPG_STOP_MODE bit.
     *
     * ADC1 stop mode selection, cannot change when ADC1_STOP_REQ is asserted.
     */
    inline void clear_GPR70_ADC1_IPG_STOP_MODE() volatile
    {
        GPR70 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR70's ADC1_IPG_STOP_MODE bit.
     *
     * ADC1 stop mode selection, cannot change when ADC1_STOP_REQ is asserted.
     */
    inline void toggle_GPR70_ADC1_IPG_STOP_MODE() volatile
    {
        GPR70 ^= 1u << 2u;
    }

    /**
     * Get GPR70's ADC1_STOP_REQ bit.
     *
     * ADC1 stop request
     */
    inline bool get_GPR70_ADC1_STOP_REQ() volatile
    {
        return GPR70 & (1u << 1u);
    }

    /**
     * Set GPR70's ADC1_STOP_REQ bit.
     *
     * ADC1 stop request
     */
    inline void set_GPR70_ADC1_STOP_REQ() volatile
    {
        GPR70 |= 1u << 1u;
    }

    /**
     * Clear GPR70's ADC1_STOP_REQ bit.
     *
     * ADC1 stop request
     */
    inline void clear_GPR70_ADC1_STOP_REQ() volatile
    {
        GPR70 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR70's ADC1_STOP_REQ bit.
     *
     * ADC1 stop request
     */
    inline void toggle_GPR70_ADC1_STOP_REQ() volatile
    {
        GPR70 ^= 1u << 1u;
    }

    /**
     * Get GPR70's ADC1_IPG_DOZE bit.
     *
     * ADC1 doze mode
     */
    inline bool get_GPR70_ADC1_IPG_DOZE() volatile
    {
        return GPR70 & (1u << 0u);
    }

    /**
     * Set GPR70's ADC1_IPG_DOZE bit.
     *
     * ADC1 doze mode
     */
    inline void set_GPR70_ADC1_IPG_DOZE() volatile
    {
        GPR70 |= 1u << 0u;
    }

    /**
     * Clear GPR70's ADC1_IPG_DOZE bit.
     *
     * ADC1 doze mode
     */
    inline void clear_GPR70_ADC1_IPG_DOZE() volatile
    {
        GPR70 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR70's ADC1_IPG_DOZE bit.
     *
     * ADC1 doze mode
     */
    inline void toggle_GPR70_ADC1_IPG_DOZE() volatile
    {
        GPR70 ^= 1u << 0u;
    }

    /**
     * Get all of GPR70's bit fields.
     *
     * (read-write) GPR70 General Purpose Register
     */
    inline void get_GPR70(
        IOMUXC_GPR_GPR70_DWP_LOCK &DWP_LOCK, IOMUXC_GPR_GPR70_DWP &DWP,
        bool &FLEXSPI2_STOP_REQ, bool &FLEXSPI2_IPG_DOZE,
        bool &FLEXSPI1_STOP_REQ, bool &FLEXSPI1_IPG_DOZE,
        bool &FLEXIO2_IPG_DOZE, bool &FLEXIO1_IPG_DOZE, bool &ENET1G_STOP_REQ,
        bool &ENET1G_IPG_DOZE, bool &ENET_STOP_REQ, bool &ENET_IPG_DOZE,
        bool &EDMA_LPSR_STOP_REQ, bool &EDMA_STOP_REQ, bool &CAN3_STOP_REQ,
        bool &CAN3_IPG_DOZE, bool &CAN2_STOP_REQ, bool &CAN2_IPG_DOZE,
        bool &CAN1_STOP_REQ, bool &CAN1_IPG_DOZE, bool &CAAM_STOP_REQ,
        bool &CAAM_IPG_DOZE, bool &ADC2_IPG_STOP_MODE, bool &ADC2_STOP_REQ,
        bool &ADC2_IPG_DOZE, bool &ADC1_IPG_STOP_MODE, bool &ADC1_STOP_REQ,
        bool &ADC1_IPG_DOZE) volatile
    {
        uint32_t curr = GPR70;

        DWP_LOCK = IOMUXC_GPR_GPR70_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR70_DWP((curr >> 28u) & 0b11u);
        FLEXSPI2_STOP_REQ = curr & (1u << 26u);
        FLEXSPI2_IPG_DOZE = curr & (1u << 25u);
        FLEXSPI1_STOP_REQ = curr & (1u << 24u);
        FLEXSPI1_IPG_DOZE = curr & (1u << 23u);
        FLEXIO2_IPG_DOZE = curr & (1u << 22u);
        FLEXIO1_IPG_DOZE = curr & (1u << 21u);
        ENET1G_STOP_REQ = curr & (1u << 20u);
        ENET1G_IPG_DOZE = curr & (1u << 19u);
        ENET_STOP_REQ = curr & (1u << 18u);
        ENET_IPG_DOZE = curr & (1u << 17u);
        EDMA_LPSR_STOP_REQ = curr & (1u << 16u);
        EDMA_STOP_REQ = curr & (1u << 15u);
        CAN3_STOP_REQ = curr & (1u << 13u);
        CAN3_IPG_DOZE = curr & (1u << 12u);
        CAN2_STOP_REQ = curr & (1u << 11u);
        CAN2_IPG_DOZE = curr & (1u << 10u);
        CAN1_STOP_REQ = curr & (1u << 9u);
        CAN1_IPG_DOZE = curr & (1u << 8u);
        CAAM_STOP_REQ = curr & (1u << 7u);
        CAAM_IPG_DOZE = curr & (1u << 6u);
        ADC2_IPG_STOP_MODE = curr & (1u << 5u);
        ADC2_STOP_REQ = curr & (1u << 4u);
        ADC2_IPG_DOZE = curr & (1u << 3u);
        ADC1_IPG_STOP_MODE = curr & (1u << 2u);
        ADC1_STOP_REQ = curr & (1u << 1u);
        ADC1_IPG_DOZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR70's bit fields.
     *
     * (read-write) GPR70 General Purpose Register
     */
    inline void set_GPR70(
        IOMUXC_GPR_GPR70_DWP_LOCK DWP_LOCK, IOMUXC_GPR_GPR70_DWP DWP,
        bool FLEXSPI2_STOP_REQ, bool FLEXSPI2_IPG_DOZE, bool FLEXSPI1_STOP_REQ,
        bool FLEXSPI1_IPG_DOZE, bool FLEXIO2_IPG_DOZE, bool FLEXIO1_IPG_DOZE,
        bool ENET1G_STOP_REQ, bool ENET1G_IPG_DOZE, bool ENET_STOP_REQ,
        bool ENET_IPG_DOZE, bool EDMA_LPSR_STOP_REQ, bool EDMA_STOP_REQ,
        bool CAN3_STOP_REQ, bool CAN3_IPG_DOZE, bool CAN2_STOP_REQ,
        bool CAN2_IPG_DOZE, bool CAN1_STOP_REQ, bool CAN1_IPG_DOZE,
        bool CAAM_STOP_REQ, bool CAAM_IPG_DOZE, bool ADC2_IPG_STOP_MODE,
        bool ADC2_STOP_REQ, bool ADC2_IPG_DOZE, bool ADC1_IPG_STOP_MODE,
        bool ADC1_STOP_REQ, bool ADC1_IPG_DOZE) volatile
    {
        uint32_t curr = GPR70;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (FLEXSPI2_STOP_REQ & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (FLEXSPI2_IPG_DOZE & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (FLEXSPI1_STOP_REQ & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (FLEXSPI1_IPG_DOZE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (FLEXIO2_IPG_DOZE & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (FLEXIO1_IPG_DOZE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ENET1G_STOP_REQ & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ENET1G_IPG_DOZE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ENET_STOP_REQ & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (ENET_IPG_DOZE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (EDMA_LPSR_STOP_REQ & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (EDMA_STOP_REQ & 0b1u) << 15u;
        curr &= ~(0b1u << 13u);
        curr |= (CAN3_STOP_REQ & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (CAN3_IPG_DOZE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (CAN2_STOP_REQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (CAN2_IPG_DOZE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (CAN1_STOP_REQ & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (CAN1_IPG_DOZE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (CAAM_STOP_REQ & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CAAM_IPG_DOZE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ADC2_IPG_STOP_MODE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ADC2_STOP_REQ & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ADC2_IPG_DOZE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ADC1_IPG_STOP_MODE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ADC1_STOP_REQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ADC1_IPG_DOZE & 0b1u) << 0u;

        GPR70 = curr;
    }

    /**
     * Get GPR71's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR71_DWP_LOCK get_GPR71_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR71_DWP_LOCK((GPR71 >> 30u) & 0b11u);
    }

    /**
     * Set GPR71's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR71_DWP_LOCK(IOMUXC_GPR_GPR71_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR71;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR71 = curr;
    }

    /**
     * Get GPR71's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR71_DWP get_GPR71_DWP() volatile
    {
        return IOMUXC_GPR_GPR71_DWP((GPR71 >> 28u) & 0b11u);
    }

    /**
     * Set GPR71's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR71_DWP(IOMUXC_GPR_GPR71_DWP value) volatile
    {
        uint32_t curr = GPR71;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR71 = curr;
    }

    /**
     * Get GPR71's LPSPI1_IPG_STOP_MODE bit.
     *
     * LPSPI1 stop mode selection, cannot change when LPSPI1_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPSPI1_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 26u);
    }

    /**
     * Set GPR71's LPSPI1_IPG_STOP_MODE bit.
     *
     * LPSPI1 stop mode selection, cannot change when LPSPI1_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPSPI1_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 26u;
    }

    /**
     * Clear GPR71's LPSPI1_IPG_STOP_MODE bit.
     *
     * LPSPI1 stop mode selection, cannot change when LPSPI1_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPSPI1_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 26u);
    }

    /**
     * Toggle GPR71's LPSPI1_IPG_STOP_MODE bit.
     *
     * LPSPI1 stop mode selection, cannot change when LPSPI1_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPSPI1_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 26u;
    }

    /**
     * Get GPR71's LPSPI1_STOP_REQ bit.
     *
     * LPSPI1 stop request
     */
    inline bool get_GPR71_LPSPI1_STOP_REQ() volatile
    {
        return GPR71 & (1u << 25u);
    }

    /**
     * Set GPR71's LPSPI1_STOP_REQ bit.
     *
     * LPSPI1 stop request
     */
    inline void set_GPR71_LPSPI1_STOP_REQ() volatile
    {
        GPR71 |= 1u << 25u;
    }

    /**
     * Clear GPR71's LPSPI1_STOP_REQ bit.
     *
     * LPSPI1 stop request
     */
    inline void clear_GPR71_LPSPI1_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 25u);
    }

    /**
     * Toggle GPR71's LPSPI1_STOP_REQ bit.
     *
     * LPSPI1 stop request
     */
    inline void toggle_GPR71_LPSPI1_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 25u;
    }

    /**
     * Get GPR71's LPSPI1_IPG_DOZE bit.
     *
     * LPSPI1 doze mode
     */
    inline bool get_GPR71_LPSPI1_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 24u);
    }

    /**
     * Set GPR71's LPSPI1_IPG_DOZE bit.
     *
     * LPSPI1 doze mode
     */
    inline void set_GPR71_LPSPI1_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 24u;
    }

    /**
     * Clear GPR71's LPSPI1_IPG_DOZE bit.
     *
     * LPSPI1 doze mode
     */
    inline void clear_GPR71_LPSPI1_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 24u);
    }

    /**
     * Toggle GPR71's LPSPI1_IPG_DOZE bit.
     *
     * LPSPI1 doze mode
     */
    inline void toggle_GPR71_LPSPI1_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 24u;
    }

    /**
     * Get GPR71's LPI2C6_IPG_STOP_MODE bit.
     *
     * LPI2C6 stop mode selection, cannot change when LPI2C6_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPI2C6_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 23u);
    }

    /**
     * Set GPR71's LPI2C6_IPG_STOP_MODE bit.
     *
     * LPI2C6 stop mode selection, cannot change when LPI2C6_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPI2C6_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 23u;
    }

    /**
     * Clear GPR71's LPI2C6_IPG_STOP_MODE bit.
     *
     * LPI2C6 stop mode selection, cannot change when LPI2C6_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPI2C6_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 23u);
    }

    /**
     * Toggle GPR71's LPI2C6_IPG_STOP_MODE bit.
     *
     * LPI2C6 stop mode selection, cannot change when LPI2C6_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPI2C6_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 23u;
    }

    /**
     * Get GPR71's LPI2C6_STOP_REQ bit.
     *
     * LPI2C6 stop request
     */
    inline bool get_GPR71_LPI2C6_STOP_REQ() volatile
    {
        return GPR71 & (1u << 22u);
    }

    /**
     * Set GPR71's LPI2C6_STOP_REQ bit.
     *
     * LPI2C6 stop request
     */
    inline void set_GPR71_LPI2C6_STOP_REQ() volatile
    {
        GPR71 |= 1u << 22u;
    }

    /**
     * Clear GPR71's LPI2C6_STOP_REQ bit.
     *
     * LPI2C6 stop request
     */
    inline void clear_GPR71_LPI2C6_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 22u);
    }

    /**
     * Toggle GPR71's LPI2C6_STOP_REQ bit.
     *
     * LPI2C6 stop request
     */
    inline void toggle_GPR71_LPI2C6_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 22u;
    }

    /**
     * Get GPR71's LPI2C6_IPG_DOZE bit.
     *
     * LPI2C6 doze mode
     */
    inline bool get_GPR71_LPI2C6_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 21u);
    }

    /**
     * Set GPR71's LPI2C6_IPG_DOZE bit.
     *
     * LPI2C6 doze mode
     */
    inline void set_GPR71_LPI2C6_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 21u;
    }

    /**
     * Clear GPR71's LPI2C6_IPG_DOZE bit.
     *
     * LPI2C6 doze mode
     */
    inline void clear_GPR71_LPI2C6_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 21u);
    }

    /**
     * Toggle GPR71's LPI2C6_IPG_DOZE bit.
     *
     * LPI2C6 doze mode
     */
    inline void toggle_GPR71_LPI2C6_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 21u;
    }

    /**
     * Get GPR71's LPI2C5_IPG_STOP_MODE bit.
     *
     * LPI2C5 stop mode selection, cannot change when LPI2C5_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPI2C5_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 20u);
    }

    /**
     * Set GPR71's LPI2C5_IPG_STOP_MODE bit.
     *
     * LPI2C5 stop mode selection, cannot change when LPI2C5_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPI2C5_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 20u;
    }

    /**
     * Clear GPR71's LPI2C5_IPG_STOP_MODE bit.
     *
     * LPI2C5 stop mode selection, cannot change when LPI2C5_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPI2C5_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 20u);
    }

    /**
     * Toggle GPR71's LPI2C5_IPG_STOP_MODE bit.
     *
     * LPI2C5 stop mode selection, cannot change when LPI2C5_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPI2C5_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 20u;
    }

    /**
     * Get GPR71's LPI2C5_STOP_REQ bit.
     *
     * LPI2C5 stop request
     */
    inline bool get_GPR71_LPI2C5_STOP_REQ() volatile
    {
        return GPR71 & (1u << 19u);
    }

    /**
     * Set GPR71's LPI2C5_STOP_REQ bit.
     *
     * LPI2C5 stop request
     */
    inline void set_GPR71_LPI2C5_STOP_REQ() volatile
    {
        GPR71 |= 1u << 19u;
    }

    /**
     * Clear GPR71's LPI2C5_STOP_REQ bit.
     *
     * LPI2C5 stop request
     */
    inline void clear_GPR71_LPI2C5_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 19u);
    }

    /**
     * Toggle GPR71's LPI2C5_STOP_REQ bit.
     *
     * LPI2C5 stop request
     */
    inline void toggle_GPR71_LPI2C5_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 19u;
    }

    /**
     * Get GPR71's LPI2C5_IPG_DOZE bit.
     *
     * LPI2C5 doze mode
     */
    inline bool get_GPR71_LPI2C5_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 18u);
    }

    /**
     * Set GPR71's LPI2C5_IPG_DOZE bit.
     *
     * LPI2C5 doze mode
     */
    inline void set_GPR71_LPI2C5_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 18u;
    }

    /**
     * Clear GPR71's LPI2C5_IPG_DOZE bit.
     *
     * LPI2C5 doze mode
     */
    inline void clear_GPR71_LPI2C5_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 18u);
    }

    /**
     * Toggle GPR71's LPI2C5_IPG_DOZE bit.
     *
     * LPI2C5 doze mode
     */
    inline void toggle_GPR71_LPI2C5_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 18u;
    }

    /**
     * Get GPR71's LPI2C4_IPG_STOP_MODE bit.
     *
     * LPI2C4 stop mode selection, cannot change when LPI2C4_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPI2C4_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 17u);
    }

    /**
     * Set GPR71's LPI2C4_IPG_STOP_MODE bit.
     *
     * LPI2C4 stop mode selection, cannot change when LPI2C4_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPI2C4_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 17u;
    }

    /**
     * Clear GPR71's LPI2C4_IPG_STOP_MODE bit.
     *
     * LPI2C4 stop mode selection, cannot change when LPI2C4_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPI2C4_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR71's LPI2C4_IPG_STOP_MODE bit.
     *
     * LPI2C4 stop mode selection, cannot change when LPI2C4_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPI2C4_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 17u;
    }

    /**
     * Get GPR71's LPI2C4_STOP_REQ bit.
     *
     * LPI2C4 stop request
     */
    inline bool get_GPR71_LPI2C4_STOP_REQ() volatile
    {
        return GPR71 & (1u << 16u);
    }

    /**
     * Set GPR71's LPI2C4_STOP_REQ bit.
     *
     * LPI2C4 stop request
     */
    inline void set_GPR71_LPI2C4_STOP_REQ() volatile
    {
        GPR71 |= 1u << 16u;
    }

    /**
     * Clear GPR71's LPI2C4_STOP_REQ bit.
     *
     * LPI2C4 stop request
     */
    inline void clear_GPR71_LPI2C4_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR71's LPI2C4_STOP_REQ bit.
     *
     * LPI2C4 stop request
     */
    inline void toggle_GPR71_LPI2C4_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 16u;
    }

    /**
     * Get GPR71's LPI2C4_IPG_DOZE bit.
     *
     * LPI2C4 doze mode
     */
    inline bool get_GPR71_LPI2C4_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 15u);
    }

    /**
     * Set GPR71's LPI2C4_IPG_DOZE bit.
     *
     * LPI2C4 doze mode
     */
    inline void set_GPR71_LPI2C4_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 15u;
    }

    /**
     * Clear GPR71's LPI2C4_IPG_DOZE bit.
     *
     * LPI2C4 doze mode
     */
    inline void clear_GPR71_LPI2C4_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 15u);
    }

    /**
     * Toggle GPR71's LPI2C4_IPG_DOZE bit.
     *
     * LPI2C4 doze mode
     */
    inline void toggle_GPR71_LPI2C4_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 15u;
    }

    /**
     * Get GPR71's LPI2C3_IPG_STOP_MODE bit.
     *
     * LPI2C3 stop mode selection, cannot change when LPI2C3_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPI2C3_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 14u);
    }

    /**
     * Set GPR71's LPI2C3_IPG_STOP_MODE bit.
     *
     * LPI2C3 stop mode selection, cannot change when LPI2C3_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPI2C3_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 14u;
    }

    /**
     * Clear GPR71's LPI2C3_IPG_STOP_MODE bit.
     *
     * LPI2C3 stop mode selection, cannot change when LPI2C3_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPI2C3_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR71's LPI2C3_IPG_STOP_MODE bit.
     *
     * LPI2C3 stop mode selection, cannot change when LPI2C3_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPI2C3_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 14u;
    }

    /**
     * Get GPR71's LPI2C3_STOP_REQ bit.
     *
     * LPI2C3 stop request
     */
    inline bool get_GPR71_LPI2C3_STOP_REQ() volatile
    {
        return GPR71 & (1u << 13u);
    }

    /**
     * Set GPR71's LPI2C3_STOP_REQ bit.
     *
     * LPI2C3 stop request
     */
    inline void set_GPR71_LPI2C3_STOP_REQ() volatile
    {
        GPR71 |= 1u << 13u;
    }

    /**
     * Clear GPR71's LPI2C3_STOP_REQ bit.
     *
     * LPI2C3 stop request
     */
    inline void clear_GPR71_LPI2C3_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR71's LPI2C3_STOP_REQ bit.
     *
     * LPI2C3 stop request
     */
    inline void toggle_GPR71_LPI2C3_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 13u;
    }

    /**
     * Get GPR71's LPI2C3_IPG_DOZE bit.
     *
     * LPI2C3 doze mode
     */
    inline bool get_GPR71_LPI2C3_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 12u);
    }

    /**
     * Set GPR71's LPI2C3_IPG_DOZE bit.
     *
     * LPI2C3 doze mode
     */
    inline void set_GPR71_LPI2C3_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 12u;
    }

    /**
     * Clear GPR71's LPI2C3_IPG_DOZE bit.
     *
     * LPI2C3 doze mode
     */
    inline void clear_GPR71_LPI2C3_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR71's LPI2C3_IPG_DOZE bit.
     *
     * LPI2C3 doze mode
     */
    inline void toggle_GPR71_LPI2C3_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 12u;
    }

    /**
     * Get GPR71's LPI2C2_IPG_STOP_MODE bit.
     *
     * LPI2C2 stop mode selection, cannot change when LPI2C2_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPI2C2_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 11u);
    }

    /**
     * Set GPR71's LPI2C2_IPG_STOP_MODE bit.
     *
     * LPI2C2 stop mode selection, cannot change when LPI2C2_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPI2C2_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 11u;
    }

    /**
     * Clear GPR71's LPI2C2_IPG_STOP_MODE bit.
     *
     * LPI2C2 stop mode selection, cannot change when LPI2C2_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPI2C2_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR71's LPI2C2_IPG_STOP_MODE bit.
     *
     * LPI2C2 stop mode selection, cannot change when LPI2C2_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPI2C2_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 11u;
    }

    /**
     * Get GPR71's LPI2C2_STOP_REQ bit.
     *
     * LPI2C2 stop request
     */
    inline bool get_GPR71_LPI2C2_STOP_REQ() volatile
    {
        return GPR71 & (1u << 10u);
    }

    /**
     * Set GPR71's LPI2C2_STOP_REQ bit.
     *
     * LPI2C2 stop request
     */
    inline void set_GPR71_LPI2C2_STOP_REQ() volatile
    {
        GPR71 |= 1u << 10u;
    }

    /**
     * Clear GPR71's LPI2C2_STOP_REQ bit.
     *
     * LPI2C2 stop request
     */
    inline void clear_GPR71_LPI2C2_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR71's LPI2C2_STOP_REQ bit.
     *
     * LPI2C2 stop request
     */
    inline void toggle_GPR71_LPI2C2_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 10u;
    }

    /**
     * Get GPR71's LPI2C2_IPG_DOZE bit.
     *
     * LPI2C2 doze mode
     */
    inline bool get_GPR71_LPI2C2_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 9u);
    }

    /**
     * Set GPR71's LPI2C2_IPG_DOZE bit.
     *
     * LPI2C2 doze mode
     */
    inline void set_GPR71_LPI2C2_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 9u;
    }

    /**
     * Clear GPR71's LPI2C2_IPG_DOZE bit.
     *
     * LPI2C2 doze mode
     */
    inline void clear_GPR71_LPI2C2_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR71's LPI2C2_IPG_DOZE bit.
     *
     * LPI2C2 doze mode
     */
    inline void toggle_GPR71_LPI2C2_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 9u;
    }

    /**
     * Get GPR71's LPI2C1_IPG_STOP_MODE bit.
     *
     * LPI2C1 stop mode selection, cannot change when LPI2C1_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR71_LPI2C1_IPG_STOP_MODE() volatile
    {
        return GPR71 & (1u << 8u);
    }

    /**
     * Set GPR71's LPI2C1_IPG_STOP_MODE bit.
     *
     * LPI2C1 stop mode selection, cannot change when LPI2C1_STOP_REQ is
     * asserted.
     */
    inline void set_GPR71_LPI2C1_IPG_STOP_MODE() volatile
    {
        GPR71 |= 1u << 8u;
    }

    /**
     * Clear GPR71's LPI2C1_IPG_STOP_MODE bit.
     *
     * LPI2C1 stop mode selection, cannot change when LPI2C1_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR71_LPI2C1_IPG_STOP_MODE() volatile
    {
        GPR71 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR71's LPI2C1_IPG_STOP_MODE bit.
     *
     * LPI2C1 stop mode selection, cannot change when LPI2C1_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR71_LPI2C1_IPG_STOP_MODE() volatile
    {
        GPR71 ^= 1u << 8u;
    }

    /**
     * Get GPR71's LPI2C1_STOP_REQ bit.
     *
     * LPI2C1 stop request
     */
    inline bool get_GPR71_LPI2C1_STOP_REQ() volatile
    {
        return GPR71 & (1u << 7u);
    }

    /**
     * Set GPR71's LPI2C1_STOP_REQ bit.
     *
     * LPI2C1 stop request
     */
    inline void set_GPR71_LPI2C1_STOP_REQ() volatile
    {
        GPR71 |= 1u << 7u;
    }

    /**
     * Clear GPR71's LPI2C1_STOP_REQ bit.
     *
     * LPI2C1 stop request
     */
    inline void clear_GPR71_LPI2C1_STOP_REQ() volatile
    {
        GPR71 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR71's LPI2C1_STOP_REQ bit.
     *
     * LPI2C1 stop request
     */
    inline void toggle_GPR71_LPI2C1_STOP_REQ() volatile
    {
        GPR71 ^= 1u << 7u;
    }

    /**
     * Get GPR71's LPI2C1_IPG_DOZE bit.
     *
     * LPI2C1 doze mode
     */
    inline bool get_GPR71_LPI2C1_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 6u);
    }

    /**
     * Set GPR71's LPI2C1_IPG_DOZE bit.
     *
     * LPI2C1 doze mode
     */
    inline void set_GPR71_LPI2C1_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 6u;
    }

    /**
     * Clear GPR71's LPI2C1_IPG_DOZE bit.
     *
     * LPI2C1 doze mode
     */
    inline void clear_GPR71_LPI2C1_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR71's LPI2C1_IPG_DOZE bit.
     *
     * LPI2C1 doze mode
     */
    inline void toggle_GPR71_LPI2C1_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 6u;
    }

    /**
     * Get GPR71's GPT6_IPG_DOZE bit.
     *
     * GPT6 doze mode
     */
    inline bool get_GPR71_GPT6_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 5u);
    }

    /**
     * Set GPR71's GPT6_IPG_DOZE bit.
     *
     * GPT6 doze mode
     */
    inline void set_GPR71_GPT6_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 5u;
    }

    /**
     * Clear GPR71's GPT6_IPG_DOZE bit.
     *
     * GPT6 doze mode
     */
    inline void clear_GPR71_GPT6_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR71's GPT6_IPG_DOZE bit.
     *
     * GPT6 doze mode
     */
    inline void toggle_GPR71_GPT6_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 5u;
    }

    /**
     * Get GPR71's GPT5_IPG_DOZE bit.
     *
     * GPT5 doze mode
     */
    inline bool get_GPR71_GPT5_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 4u);
    }

    /**
     * Set GPR71's GPT5_IPG_DOZE bit.
     *
     * GPT5 doze mode
     */
    inline void set_GPR71_GPT5_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 4u;
    }

    /**
     * Clear GPR71's GPT5_IPG_DOZE bit.
     *
     * GPT5 doze mode
     */
    inline void clear_GPR71_GPT5_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR71's GPT5_IPG_DOZE bit.
     *
     * GPT5 doze mode
     */
    inline void toggle_GPR71_GPT5_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 4u;
    }

    /**
     * Get GPR71's GPT4_IPG_DOZE bit.
     *
     * GPT4 doze mode
     */
    inline bool get_GPR71_GPT4_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 3u);
    }

    /**
     * Set GPR71's GPT4_IPG_DOZE bit.
     *
     * GPT4 doze mode
     */
    inline void set_GPR71_GPT4_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 3u;
    }

    /**
     * Clear GPR71's GPT4_IPG_DOZE bit.
     *
     * GPT4 doze mode
     */
    inline void clear_GPR71_GPT4_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR71's GPT4_IPG_DOZE bit.
     *
     * GPT4 doze mode
     */
    inline void toggle_GPR71_GPT4_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 3u;
    }

    /**
     * Get GPR71's GPT3_IPG_DOZE bit.
     *
     * GPT3 doze mode
     */
    inline bool get_GPR71_GPT3_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 2u);
    }

    /**
     * Set GPR71's GPT3_IPG_DOZE bit.
     *
     * GPT3 doze mode
     */
    inline void set_GPR71_GPT3_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 2u;
    }

    /**
     * Clear GPR71's GPT3_IPG_DOZE bit.
     *
     * GPT3 doze mode
     */
    inline void clear_GPR71_GPT3_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR71's GPT3_IPG_DOZE bit.
     *
     * GPT3 doze mode
     */
    inline void toggle_GPR71_GPT3_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 2u;
    }

    /**
     * Get GPR71's GPT2_IPG_DOZE bit.
     *
     * GPT2 doze mode
     */
    inline bool get_GPR71_GPT2_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 1u);
    }

    /**
     * Set GPR71's GPT2_IPG_DOZE bit.
     *
     * GPT2 doze mode
     */
    inline void set_GPR71_GPT2_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 1u;
    }

    /**
     * Clear GPR71's GPT2_IPG_DOZE bit.
     *
     * GPT2 doze mode
     */
    inline void clear_GPR71_GPT2_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR71's GPT2_IPG_DOZE bit.
     *
     * GPT2 doze mode
     */
    inline void toggle_GPR71_GPT2_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 1u;
    }

    /**
     * Get GPR71's GPT1_IPG_DOZE bit.
     *
     * GPT1 doze mode
     */
    inline bool get_GPR71_GPT1_IPG_DOZE() volatile
    {
        return GPR71 & (1u << 0u);
    }

    /**
     * Set GPR71's GPT1_IPG_DOZE bit.
     *
     * GPT1 doze mode
     */
    inline void set_GPR71_GPT1_IPG_DOZE() volatile
    {
        GPR71 |= 1u << 0u;
    }

    /**
     * Clear GPR71's GPT1_IPG_DOZE bit.
     *
     * GPT1 doze mode
     */
    inline void clear_GPR71_GPT1_IPG_DOZE() volatile
    {
        GPR71 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR71's GPT1_IPG_DOZE bit.
     *
     * GPT1 doze mode
     */
    inline void toggle_GPR71_GPT1_IPG_DOZE() volatile
    {
        GPR71 ^= 1u << 0u;
    }

    /**
     * Get all of GPR71's bit fields.
     *
     * (read-write) GPR71 General Purpose Register
     */
    inline void get_GPR71(IOMUXC_GPR_GPR71_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR71_DWP &DWP,
                          bool &LPSPI1_IPG_STOP_MODE, bool &LPSPI1_STOP_REQ,
                          bool &LPSPI1_IPG_DOZE, bool &LPI2C6_IPG_STOP_MODE,
                          bool &LPI2C6_STOP_REQ, bool &LPI2C6_IPG_DOZE,
                          bool &LPI2C5_IPG_STOP_MODE, bool &LPI2C5_STOP_REQ,
                          bool &LPI2C5_IPG_DOZE, bool &LPI2C4_IPG_STOP_MODE,
                          bool &LPI2C4_STOP_REQ, bool &LPI2C4_IPG_DOZE,
                          bool &LPI2C3_IPG_STOP_MODE, bool &LPI2C3_STOP_REQ,
                          bool &LPI2C3_IPG_DOZE, bool &LPI2C2_IPG_STOP_MODE,
                          bool &LPI2C2_STOP_REQ, bool &LPI2C2_IPG_DOZE,
                          bool &LPI2C1_IPG_STOP_MODE, bool &LPI2C1_STOP_REQ,
                          bool &LPI2C1_IPG_DOZE, bool &GPT6_IPG_DOZE,
                          bool &GPT5_IPG_DOZE, bool &GPT4_IPG_DOZE,
                          bool &GPT3_IPG_DOZE, bool &GPT2_IPG_DOZE,
                          bool &GPT1_IPG_DOZE) volatile
    {
        uint32_t curr = GPR71;

        DWP_LOCK = IOMUXC_GPR_GPR71_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR71_DWP((curr >> 28u) & 0b11u);
        LPSPI1_IPG_STOP_MODE = curr & (1u << 26u);
        LPSPI1_STOP_REQ = curr & (1u << 25u);
        LPSPI1_IPG_DOZE = curr & (1u << 24u);
        LPI2C6_IPG_STOP_MODE = curr & (1u << 23u);
        LPI2C6_STOP_REQ = curr & (1u << 22u);
        LPI2C6_IPG_DOZE = curr & (1u << 21u);
        LPI2C5_IPG_STOP_MODE = curr & (1u << 20u);
        LPI2C5_STOP_REQ = curr & (1u << 19u);
        LPI2C5_IPG_DOZE = curr & (1u << 18u);
        LPI2C4_IPG_STOP_MODE = curr & (1u << 17u);
        LPI2C4_STOP_REQ = curr & (1u << 16u);
        LPI2C4_IPG_DOZE = curr & (1u << 15u);
        LPI2C3_IPG_STOP_MODE = curr & (1u << 14u);
        LPI2C3_STOP_REQ = curr & (1u << 13u);
        LPI2C3_IPG_DOZE = curr & (1u << 12u);
        LPI2C2_IPG_STOP_MODE = curr & (1u << 11u);
        LPI2C2_STOP_REQ = curr & (1u << 10u);
        LPI2C2_IPG_DOZE = curr & (1u << 9u);
        LPI2C1_IPG_STOP_MODE = curr & (1u << 8u);
        LPI2C1_STOP_REQ = curr & (1u << 7u);
        LPI2C1_IPG_DOZE = curr & (1u << 6u);
        GPT6_IPG_DOZE = curr & (1u << 5u);
        GPT5_IPG_DOZE = curr & (1u << 4u);
        GPT4_IPG_DOZE = curr & (1u << 3u);
        GPT3_IPG_DOZE = curr & (1u << 2u);
        GPT2_IPG_DOZE = curr & (1u << 1u);
        GPT1_IPG_DOZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR71's bit fields.
     *
     * (read-write) GPR71 General Purpose Register
     */
    inline void set_GPR71(
        IOMUXC_GPR_GPR71_DWP_LOCK DWP_LOCK, IOMUXC_GPR_GPR71_DWP DWP,
        bool LPSPI1_IPG_STOP_MODE, bool LPSPI1_STOP_REQ, bool LPSPI1_IPG_DOZE,
        bool LPI2C6_IPG_STOP_MODE, bool LPI2C6_STOP_REQ, bool LPI2C6_IPG_DOZE,
        bool LPI2C5_IPG_STOP_MODE, bool LPI2C5_STOP_REQ, bool LPI2C5_IPG_DOZE,
        bool LPI2C4_IPG_STOP_MODE, bool LPI2C4_STOP_REQ, bool LPI2C4_IPG_DOZE,
        bool LPI2C3_IPG_STOP_MODE, bool LPI2C3_STOP_REQ, bool LPI2C3_IPG_DOZE,
        bool LPI2C2_IPG_STOP_MODE, bool LPI2C2_STOP_REQ, bool LPI2C2_IPG_DOZE,
        bool LPI2C1_IPG_STOP_MODE, bool LPI2C1_STOP_REQ, bool LPI2C1_IPG_DOZE,
        bool GPT6_IPG_DOZE, bool GPT5_IPG_DOZE, bool GPT4_IPG_DOZE,
        bool GPT3_IPG_DOZE, bool GPT2_IPG_DOZE, bool GPT1_IPG_DOZE) volatile
    {
        uint32_t curr = GPR71;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (LPSPI1_IPG_STOP_MODE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (LPSPI1_STOP_REQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (LPSPI1_IPG_DOZE & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (LPI2C6_IPG_STOP_MODE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (LPI2C6_STOP_REQ & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (LPI2C6_IPG_DOZE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (LPI2C5_IPG_STOP_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (LPI2C5_STOP_REQ & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (LPI2C5_IPG_DOZE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (LPI2C4_IPG_STOP_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (LPI2C4_STOP_REQ & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (LPI2C4_IPG_DOZE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (LPI2C3_IPG_STOP_MODE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (LPI2C3_STOP_REQ & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (LPI2C3_IPG_DOZE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LPI2C2_IPG_STOP_MODE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (LPI2C2_STOP_REQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (LPI2C2_IPG_DOZE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (LPI2C1_IPG_STOP_MODE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LPI2C1_STOP_REQ & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (LPI2C1_IPG_DOZE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (GPT6_IPG_DOZE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (GPT5_IPG_DOZE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (GPT4_IPG_DOZE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (GPT3_IPG_DOZE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (GPT2_IPG_DOZE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (GPT1_IPG_DOZE & 0b1u) << 0u;

        GPR71 = curr;
    }

    /**
     * Get GPR72's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR72_DWP_LOCK get_GPR72_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR72_DWP_LOCK((GPR72 >> 30u) & 0b11u);
    }

    /**
     * Set GPR72's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR72_DWP_LOCK(IOMUXC_GPR_GPR72_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR72;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR72 = curr;
    }

    /**
     * Get GPR72's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR72_DWP get_GPR72_DWP() volatile
    {
        return IOMUXC_GPR_GPR72_DWP((GPR72 >> 28u) & 0b11u);
    }

    /**
     * Set GPR72's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR72_DWP(IOMUXC_GPR_GPR72_DWP value) volatile
    {
        uint32_t curr = GPR72;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR72 = curr;
    }

    /**
     * Get GPR72's LPUART4_IPG_STOP_MODE bit.
     *
     * LPUART4 stop mode selection, cannot change when LPUART4_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPUART4_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 26u);
    }

    /**
     * Set GPR72's LPUART4_IPG_STOP_MODE bit.
     *
     * LPUART4 stop mode selection, cannot change when LPUART4_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPUART4_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 26u;
    }

    /**
     * Clear GPR72's LPUART4_IPG_STOP_MODE bit.
     *
     * LPUART4 stop mode selection, cannot change when LPUART4_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPUART4_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 26u);
    }

    /**
     * Toggle GPR72's LPUART4_IPG_STOP_MODE bit.
     *
     * LPUART4 stop mode selection, cannot change when LPUART4_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPUART4_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 26u;
    }

    /**
     * Get GPR72's LPUART4_STOP_REQ bit.
     *
     * LPUART4 stop request
     */
    inline bool get_GPR72_LPUART4_STOP_REQ() volatile
    {
        return GPR72 & (1u << 25u);
    }

    /**
     * Set GPR72's LPUART4_STOP_REQ bit.
     *
     * LPUART4 stop request
     */
    inline void set_GPR72_LPUART4_STOP_REQ() volatile
    {
        GPR72 |= 1u << 25u;
    }

    /**
     * Clear GPR72's LPUART4_STOP_REQ bit.
     *
     * LPUART4 stop request
     */
    inline void clear_GPR72_LPUART4_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 25u);
    }

    /**
     * Toggle GPR72's LPUART4_STOP_REQ bit.
     *
     * LPUART4 stop request
     */
    inline void toggle_GPR72_LPUART4_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 25u;
    }

    /**
     * Get GPR72's LPUART4_IPG_DOZE bit.
     *
     * LPUART4 doze mode
     */
    inline bool get_GPR72_LPUART4_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 24u);
    }

    /**
     * Set GPR72's LPUART4_IPG_DOZE bit.
     *
     * LPUART4 doze mode
     */
    inline void set_GPR72_LPUART4_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 24u;
    }

    /**
     * Clear GPR72's LPUART4_IPG_DOZE bit.
     *
     * LPUART4 doze mode
     */
    inline void clear_GPR72_LPUART4_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 24u);
    }

    /**
     * Toggle GPR72's LPUART4_IPG_DOZE bit.
     *
     * LPUART4 doze mode
     */
    inline void toggle_GPR72_LPUART4_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 24u;
    }

    /**
     * Get GPR72's LPUART3_IPG_STOP_MODE bit.
     *
     * LPUART3 stop mode selection, cannot change when LPUART3_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPUART3_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 23u);
    }

    /**
     * Set GPR72's LPUART3_IPG_STOP_MODE bit.
     *
     * LPUART3 stop mode selection, cannot change when LPUART3_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPUART3_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 23u;
    }

    /**
     * Clear GPR72's LPUART3_IPG_STOP_MODE bit.
     *
     * LPUART3 stop mode selection, cannot change when LPUART3_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPUART3_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 23u);
    }

    /**
     * Toggle GPR72's LPUART3_IPG_STOP_MODE bit.
     *
     * LPUART3 stop mode selection, cannot change when LPUART3_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPUART3_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 23u;
    }

    /**
     * Get GPR72's LPUART3_STOP_REQ bit.
     *
     * LPUART3 stop request
     */
    inline bool get_GPR72_LPUART3_STOP_REQ() volatile
    {
        return GPR72 & (1u << 22u);
    }

    /**
     * Set GPR72's LPUART3_STOP_REQ bit.
     *
     * LPUART3 stop request
     */
    inline void set_GPR72_LPUART3_STOP_REQ() volatile
    {
        GPR72 |= 1u << 22u;
    }

    /**
     * Clear GPR72's LPUART3_STOP_REQ bit.
     *
     * LPUART3 stop request
     */
    inline void clear_GPR72_LPUART3_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 22u);
    }

    /**
     * Toggle GPR72's LPUART3_STOP_REQ bit.
     *
     * LPUART3 stop request
     */
    inline void toggle_GPR72_LPUART3_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 22u;
    }

    /**
     * Get GPR72's LPUART3_IPG_DOZE bit.
     *
     * LPUART3 doze mode
     */
    inline bool get_GPR72_LPUART3_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 21u);
    }

    /**
     * Set GPR72's LPUART3_IPG_DOZE bit.
     *
     * LPUART3 doze mode
     */
    inline void set_GPR72_LPUART3_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 21u;
    }

    /**
     * Clear GPR72's LPUART3_IPG_DOZE bit.
     *
     * LPUART3 doze mode
     */
    inline void clear_GPR72_LPUART3_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 21u);
    }

    /**
     * Toggle GPR72's LPUART3_IPG_DOZE bit.
     *
     * LPUART3 doze mode
     */
    inline void toggle_GPR72_LPUART3_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 21u;
    }

    /**
     * Get GPR72's LPUART2_IPG_STOP_MODE bit.
     *
     * LPUART2 stop mode selection, cannot change when LPUART2_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPUART2_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 20u);
    }

    /**
     * Set GPR72's LPUART2_IPG_STOP_MODE bit.
     *
     * LPUART2 stop mode selection, cannot change when LPUART2_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPUART2_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 20u;
    }

    /**
     * Clear GPR72's LPUART2_IPG_STOP_MODE bit.
     *
     * LPUART2 stop mode selection, cannot change when LPUART2_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPUART2_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 20u);
    }

    /**
     * Toggle GPR72's LPUART2_IPG_STOP_MODE bit.
     *
     * LPUART2 stop mode selection, cannot change when LPUART2_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPUART2_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 20u;
    }

    /**
     * Get GPR72's LPUART2_STOP_REQ bit.
     *
     * LPUART2 stop request
     */
    inline bool get_GPR72_LPUART2_STOP_REQ() volatile
    {
        return GPR72 & (1u << 19u);
    }

    /**
     * Set GPR72's LPUART2_STOP_REQ bit.
     *
     * LPUART2 stop request
     */
    inline void set_GPR72_LPUART2_STOP_REQ() volatile
    {
        GPR72 |= 1u << 19u;
    }

    /**
     * Clear GPR72's LPUART2_STOP_REQ bit.
     *
     * LPUART2 stop request
     */
    inline void clear_GPR72_LPUART2_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 19u);
    }

    /**
     * Toggle GPR72's LPUART2_STOP_REQ bit.
     *
     * LPUART2 stop request
     */
    inline void toggle_GPR72_LPUART2_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 19u;
    }

    /**
     * Get GPR72's LPUART2_IPG_DOZE bit.
     *
     * LPUART2 doze mode
     */
    inline bool get_GPR72_LPUART2_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 18u);
    }

    /**
     * Set GPR72's LPUART2_IPG_DOZE bit.
     *
     * LPUART2 doze mode
     */
    inline void set_GPR72_LPUART2_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 18u;
    }

    /**
     * Clear GPR72's LPUART2_IPG_DOZE bit.
     *
     * LPUART2 doze mode
     */
    inline void clear_GPR72_LPUART2_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 18u);
    }

    /**
     * Toggle GPR72's LPUART2_IPG_DOZE bit.
     *
     * LPUART2 doze mode
     */
    inline void toggle_GPR72_LPUART2_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 18u;
    }

    /**
     * Get GPR72's LPUART1_IPG_STOP_MODE bit.
     *
     * LPUART1 stop mode selection, cannot change when LPUART1_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPUART1_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 17u);
    }

    /**
     * Set GPR72's LPUART1_IPG_STOP_MODE bit.
     *
     * LPUART1 stop mode selection, cannot change when LPUART1_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPUART1_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 17u;
    }

    /**
     * Clear GPR72's LPUART1_IPG_STOP_MODE bit.
     *
     * LPUART1 stop mode selection, cannot change when LPUART1_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPUART1_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR72's LPUART1_IPG_STOP_MODE bit.
     *
     * LPUART1 stop mode selection, cannot change when LPUART1_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPUART1_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 17u;
    }

    /**
     * Get GPR72's LPUART1_STOP_REQ bit.
     *
     * LPUART1 stop request
     */
    inline bool get_GPR72_LPUART1_STOP_REQ() volatile
    {
        return GPR72 & (1u << 16u);
    }

    /**
     * Set GPR72's LPUART1_STOP_REQ bit.
     *
     * LPUART1 stop request
     */
    inline void set_GPR72_LPUART1_STOP_REQ() volatile
    {
        GPR72 |= 1u << 16u;
    }

    /**
     * Clear GPR72's LPUART1_STOP_REQ bit.
     *
     * LPUART1 stop request
     */
    inline void clear_GPR72_LPUART1_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR72's LPUART1_STOP_REQ bit.
     *
     * LPUART1 stop request
     */
    inline void toggle_GPR72_LPUART1_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 16u;
    }

    /**
     * Get GPR72's LPUART1_IPG_DOZE bit.
     *
     * LPUART1 doze mode
     */
    inline bool get_GPR72_LPUART1_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 15u);
    }

    /**
     * Set GPR72's LPUART1_IPG_DOZE bit.
     *
     * LPUART1 doze mode
     */
    inline void set_GPR72_LPUART1_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 15u;
    }

    /**
     * Clear GPR72's LPUART1_IPG_DOZE bit.
     *
     * LPUART1 doze mode
     */
    inline void clear_GPR72_LPUART1_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 15u);
    }

    /**
     * Toggle GPR72's LPUART1_IPG_DOZE bit.
     *
     * LPUART1 doze mode
     */
    inline void toggle_GPR72_LPUART1_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 15u;
    }

    /**
     * Get GPR72's LPSPI6_IPG_STOP_MODE bit.
     *
     * LPSPI6 stop mode selection, cannot change when LPSPI6_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPSPI6_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 14u);
    }

    /**
     * Set GPR72's LPSPI6_IPG_STOP_MODE bit.
     *
     * LPSPI6 stop mode selection, cannot change when LPSPI6_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPSPI6_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 14u;
    }

    /**
     * Clear GPR72's LPSPI6_IPG_STOP_MODE bit.
     *
     * LPSPI6 stop mode selection, cannot change when LPSPI6_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPSPI6_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR72's LPSPI6_IPG_STOP_MODE bit.
     *
     * LPSPI6 stop mode selection, cannot change when LPSPI6_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPSPI6_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 14u;
    }

    /**
     * Get GPR72's LPSPI6_STOP_REQ bit.
     *
     * LPSPI6 stop request
     */
    inline bool get_GPR72_LPSPI6_STOP_REQ() volatile
    {
        return GPR72 & (1u << 13u);
    }

    /**
     * Set GPR72's LPSPI6_STOP_REQ bit.
     *
     * LPSPI6 stop request
     */
    inline void set_GPR72_LPSPI6_STOP_REQ() volatile
    {
        GPR72 |= 1u << 13u;
    }

    /**
     * Clear GPR72's LPSPI6_STOP_REQ bit.
     *
     * LPSPI6 stop request
     */
    inline void clear_GPR72_LPSPI6_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR72's LPSPI6_STOP_REQ bit.
     *
     * LPSPI6 stop request
     */
    inline void toggle_GPR72_LPSPI6_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 13u;
    }

    /**
     * Get GPR72's LPSPI6_IPG_DOZE bit.
     *
     * LPSPI6 doze mode
     */
    inline bool get_GPR72_LPSPI6_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 12u);
    }

    /**
     * Set GPR72's LPSPI6_IPG_DOZE bit.
     *
     * LPSPI6 doze mode
     */
    inline void set_GPR72_LPSPI6_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 12u;
    }

    /**
     * Clear GPR72's LPSPI6_IPG_DOZE bit.
     *
     * LPSPI6 doze mode
     */
    inline void clear_GPR72_LPSPI6_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR72's LPSPI6_IPG_DOZE bit.
     *
     * LPSPI6 doze mode
     */
    inline void toggle_GPR72_LPSPI6_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 12u;
    }

    /**
     * Get GPR72's LPSPI5_IPG_STOP_MODE bit.
     *
     * LPSPI5 stop mode selection, cannot change when LPSPI5_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPSPI5_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 11u);
    }

    /**
     * Set GPR72's LPSPI5_IPG_STOP_MODE bit.
     *
     * LPSPI5 stop mode selection, cannot change when LPSPI5_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPSPI5_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 11u;
    }

    /**
     * Clear GPR72's LPSPI5_IPG_STOP_MODE bit.
     *
     * LPSPI5 stop mode selection, cannot change when LPSPI5_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPSPI5_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR72's LPSPI5_IPG_STOP_MODE bit.
     *
     * LPSPI5 stop mode selection, cannot change when LPSPI5_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPSPI5_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 11u;
    }

    /**
     * Get GPR72's LPSPI5_STOP_REQ bit.
     *
     * LPSPI5 stop request
     */
    inline bool get_GPR72_LPSPI5_STOP_REQ() volatile
    {
        return GPR72 & (1u << 10u);
    }

    /**
     * Set GPR72's LPSPI5_STOP_REQ bit.
     *
     * LPSPI5 stop request
     */
    inline void set_GPR72_LPSPI5_STOP_REQ() volatile
    {
        GPR72 |= 1u << 10u;
    }

    /**
     * Clear GPR72's LPSPI5_STOP_REQ bit.
     *
     * LPSPI5 stop request
     */
    inline void clear_GPR72_LPSPI5_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR72's LPSPI5_STOP_REQ bit.
     *
     * LPSPI5 stop request
     */
    inline void toggle_GPR72_LPSPI5_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 10u;
    }

    /**
     * Get GPR72's LPSPI5_IPG_DOZE bit.
     *
     * LPSPI5 doze mode
     */
    inline bool get_GPR72_LPSPI5_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 9u);
    }

    /**
     * Set GPR72's LPSPI5_IPG_DOZE bit.
     *
     * LPSPI5 doze mode
     */
    inline void set_GPR72_LPSPI5_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 9u;
    }

    /**
     * Clear GPR72's LPSPI5_IPG_DOZE bit.
     *
     * LPSPI5 doze mode
     */
    inline void clear_GPR72_LPSPI5_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR72's LPSPI5_IPG_DOZE bit.
     *
     * LPSPI5 doze mode
     */
    inline void toggle_GPR72_LPSPI5_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 9u;
    }

    /**
     * Get GPR72's LPSPI4_IPG_STOP_MODE bit.
     *
     * LPSPI4 stop mode selection, cannot change when LPSPI4_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPSPI4_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 8u);
    }

    /**
     * Set GPR72's LPSPI4_IPG_STOP_MODE bit.
     *
     * LPSPI4 stop mode selection, cannot change when LPSPI4_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPSPI4_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 8u;
    }

    /**
     * Clear GPR72's LPSPI4_IPG_STOP_MODE bit.
     *
     * LPSPI4 stop mode selection, cannot change when LPSPI4_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPSPI4_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR72's LPSPI4_IPG_STOP_MODE bit.
     *
     * LPSPI4 stop mode selection, cannot change when LPSPI4_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPSPI4_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 8u;
    }

    /**
     * Get GPR72's LPSPI4_STOP_REQ bit.
     *
     * LPSPI4 stop request
     */
    inline bool get_GPR72_LPSPI4_STOP_REQ() volatile
    {
        return GPR72 & (1u << 7u);
    }

    /**
     * Set GPR72's LPSPI4_STOP_REQ bit.
     *
     * LPSPI4 stop request
     */
    inline void set_GPR72_LPSPI4_STOP_REQ() volatile
    {
        GPR72 |= 1u << 7u;
    }

    /**
     * Clear GPR72's LPSPI4_STOP_REQ bit.
     *
     * LPSPI4 stop request
     */
    inline void clear_GPR72_LPSPI4_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR72's LPSPI4_STOP_REQ bit.
     *
     * LPSPI4 stop request
     */
    inline void toggle_GPR72_LPSPI4_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 7u;
    }

    /**
     * Get GPR72's LPSPI4_IPG_DOZE bit.
     *
     * LPSPI4 doze mode
     */
    inline bool get_GPR72_LPSPI4_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 6u);
    }

    /**
     * Set GPR72's LPSPI4_IPG_DOZE bit.
     *
     * LPSPI4 doze mode
     */
    inline void set_GPR72_LPSPI4_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 6u;
    }

    /**
     * Clear GPR72's LPSPI4_IPG_DOZE bit.
     *
     * LPSPI4 doze mode
     */
    inline void clear_GPR72_LPSPI4_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR72's LPSPI4_IPG_DOZE bit.
     *
     * LPSPI4 doze mode
     */
    inline void toggle_GPR72_LPSPI4_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 6u;
    }

    /**
     * Get GPR72's LPSPI3_IPG_STOP_MODE bit.
     *
     * LPSPI3 stop mode selection, cannot change when LPSPI3_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPSPI3_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 5u);
    }

    /**
     * Set GPR72's LPSPI3_IPG_STOP_MODE bit.
     *
     * LPSPI3 stop mode selection, cannot change when LPSPI3_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPSPI3_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 5u;
    }

    /**
     * Clear GPR72's LPSPI3_IPG_STOP_MODE bit.
     *
     * LPSPI3 stop mode selection, cannot change when LPSPI3_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPSPI3_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR72's LPSPI3_IPG_STOP_MODE bit.
     *
     * LPSPI3 stop mode selection, cannot change when LPSPI3_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPSPI3_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 5u;
    }

    /**
     * Get GPR72's LPSPI3_STOP_REQ bit.
     *
     * LPSPI3 stop request
     */
    inline bool get_GPR72_LPSPI3_STOP_REQ() volatile
    {
        return GPR72 & (1u << 4u);
    }

    /**
     * Set GPR72's LPSPI3_STOP_REQ bit.
     *
     * LPSPI3 stop request
     */
    inline void set_GPR72_LPSPI3_STOP_REQ() volatile
    {
        GPR72 |= 1u << 4u;
    }

    /**
     * Clear GPR72's LPSPI3_STOP_REQ bit.
     *
     * LPSPI3 stop request
     */
    inline void clear_GPR72_LPSPI3_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR72's LPSPI3_STOP_REQ bit.
     *
     * LPSPI3 stop request
     */
    inline void toggle_GPR72_LPSPI3_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 4u;
    }

    /**
     * Get GPR72's LPSPI3_IPG_DOZE bit.
     *
     * LPSPI3 doze mode
     */
    inline bool get_GPR72_LPSPI3_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 3u);
    }

    /**
     * Set GPR72's LPSPI3_IPG_DOZE bit.
     *
     * LPSPI3 doze mode
     */
    inline void set_GPR72_LPSPI3_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 3u;
    }

    /**
     * Clear GPR72's LPSPI3_IPG_DOZE bit.
     *
     * LPSPI3 doze mode
     */
    inline void clear_GPR72_LPSPI3_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR72's LPSPI3_IPG_DOZE bit.
     *
     * LPSPI3 doze mode
     */
    inline void toggle_GPR72_LPSPI3_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 3u;
    }

    /**
     * Get GPR72's LPSPI2_IPG_STOP_MODE bit.
     *
     * LPSPI2 stop mode selection, cannot change when LPSPI2_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR72_LPSPI2_IPG_STOP_MODE() volatile
    {
        return GPR72 & (1u << 2u);
    }

    /**
     * Set GPR72's LPSPI2_IPG_STOP_MODE bit.
     *
     * LPSPI2 stop mode selection, cannot change when LPSPI2_STOP_REQ is
     * asserted.
     */
    inline void set_GPR72_LPSPI2_IPG_STOP_MODE() volatile
    {
        GPR72 |= 1u << 2u;
    }

    /**
     * Clear GPR72's LPSPI2_IPG_STOP_MODE bit.
     *
     * LPSPI2 stop mode selection, cannot change when LPSPI2_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR72_LPSPI2_IPG_STOP_MODE() volatile
    {
        GPR72 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR72's LPSPI2_IPG_STOP_MODE bit.
     *
     * LPSPI2 stop mode selection, cannot change when LPSPI2_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR72_LPSPI2_IPG_STOP_MODE() volatile
    {
        GPR72 ^= 1u << 2u;
    }

    /**
     * Get GPR72's LPSPI2_STOP_REQ bit.
     *
     * LPSPI2 stop request
     */
    inline bool get_GPR72_LPSPI2_STOP_REQ() volatile
    {
        return GPR72 & (1u << 1u);
    }

    /**
     * Set GPR72's LPSPI2_STOP_REQ bit.
     *
     * LPSPI2 stop request
     */
    inline void set_GPR72_LPSPI2_STOP_REQ() volatile
    {
        GPR72 |= 1u << 1u;
    }

    /**
     * Clear GPR72's LPSPI2_STOP_REQ bit.
     *
     * LPSPI2 stop request
     */
    inline void clear_GPR72_LPSPI2_STOP_REQ() volatile
    {
        GPR72 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR72's LPSPI2_STOP_REQ bit.
     *
     * LPSPI2 stop request
     */
    inline void toggle_GPR72_LPSPI2_STOP_REQ() volatile
    {
        GPR72 ^= 1u << 1u;
    }

    /**
     * Get GPR72's LPSPI2_IPG_DOZE bit.
     *
     * LPSPI2 doze mode
     */
    inline bool get_GPR72_LPSPI2_IPG_DOZE() volatile
    {
        return GPR72 & (1u << 0u);
    }

    /**
     * Set GPR72's LPSPI2_IPG_DOZE bit.
     *
     * LPSPI2 doze mode
     */
    inline void set_GPR72_LPSPI2_IPG_DOZE() volatile
    {
        GPR72 |= 1u << 0u;
    }

    /**
     * Clear GPR72's LPSPI2_IPG_DOZE bit.
     *
     * LPSPI2 doze mode
     */
    inline void clear_GPR72_LPSPI2_IPG_DOZE() volatile
    {
        GPR72 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR72's LPSPI2_IPG_DOZE bit.
     *
     * LPSPI2 doze mode
     */
    inline void toggle_GPR72_LPSPI2_IPG_DOZE() volatile
    {
        GPR72 ^= 1u << 0u;
    }

    /**
     * Get all of GPR72's bit fields.
     *
     * (read-write) GPR72 General Purpose Register
     */
    inline void get_GPR72(IOMUXC_GPR_GPR72_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR72_DWP &DWP,
                          bool &LPUART4_IPG_STOP_MODE, bool &LPUART4_STOP_REQ,
                          bool &LPUART4_IPG_DOZE, bool &LPUART3_IPG_STOP_MODE,
                          bool &LPUART3_STOP_REQ, bool &LPUART3_IPG_DOZE,
                          bool &LPUART2_IPG_STOP_MODE, bool &LPUART2_STOP_REQ,
                          bool &LPUART2_IPG_DOZE, bool &LPUART1_IPG_STOP_MODE,
                          bool &LPUART1_STOP_REQ, bool &LPUART1_IPG_DOZE,
                          bool &LPSPI6_IPG_STOP_MODE, bool &LPSPI6_STOP_REQ,
                          bool &LPSPI6_IPG_DOZE, bool &LPSPI5_IPG_STOP_MODE,
                          bool &LPSPI5_STOP_REQ, bool &LPSPI5_IPG_DOZE,
                          bool &LPSPI4_IPG_STOP_MODE, bool &LPSPI4_STOP_REQ,
                          bool &LPSPI4_IPG_DOZE, bool &LPSPI3_IPG_STOP_MODE,
                          bool &LPSPI3_STOP_REQ, bool &LPSPI3_IPG_DOZE,
                          bool &LPSPI2_IPG_STOP_MODE, bool &LPSPI2_STOP_REQ,
                          bool &LPSPI2_IPG_DOZE) volatile
    {
        uint32_t curr = GPR72;

        DWP_LOCK = IOMUXC_GPR_GPR72_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR72_DWP((curr >> 28u) & 0b11u);
        LPUART4_IPG_STOP_MODE = curr & (1u << 26u);
        LPUART4_STOP_REQ = curr & (1u << 25u);
        LPUART4_IPG_DOZE = curr & (1u << 24u);
        LPUART3_IPG_STOP_MODE = curr & (1u << 23u);
        LPUART3_STOP_REQ = curr & (1u << 22u);
        LPUART3_IPG_DOZE = curr & (1u << 21u);
        LPUART2_IPG_STOP_MODE = curr & (1u << 20u);
        LPUART2_STOP_REQ = curr & (1u << 19u);
        LPUART2_IPG_DOZE = curr & (1u << 18u);
        LPUART1_IPG_STOP_MODE = curr & (1u << 17u);
        LPUART1_STOP_REQ = curr & (1u << 16u);
        LPUART1_IPG_DOZE = curr & (1u << 15u);
        LPSPI6_IPG_STOP_MODE = curr & (1u << 14u);
        LPSPI6_STOP_REQ = curr & (1u << 13u);
        LPSPI6_IPG_DOZE = curr & (1u << 12u);
        LPSPI5_IPG_STOP_MODE = curr & (1u << 11u);
        LPSPI5_STOP_REQ = curr & (1u << 10u);
        LPSPI5_IPG_DOZE = curr & (1u << 9u);
        LPSPI4_IPG_STOP_MODE = curr & (1u << 8u);
        LPSPI4_STOP_REQ = curr & (1u << 7u);
        LPSPI4_IPG_DOZE = curr & (1u << 6u);
        LPSPI3_IPG_STOP_MODE = curr & (1u << 5u);
        LPSPI3_STOP_REQ = curr & (1u << 4u);
        LPSPI3_IPG_DOZE = curr & (1u << 3u);
        LPSPI2_IPG_STOP_MODE = curr & (1u << 2u);
        LPSPI2_STOP_REQ = curr & (1u << 1u);
        LPSPI2_IPG_DOZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR72's bit fields.
     *
     * (read-write) GPR72 General Purpose Register
     */
    inline void set_GPR72(IOMUXC_GPR_GPR72_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR72_DWP DWP, bool LPUART4_IPG_STOP_MODE,
                          bool LPUART4_STOP_REQ, bool LPUART4_IPG_DOZE,
                          bool LPUART3_IPG_STOP_MODE, bool LPUART3_STOP_REQ,
                          bool LPUART3_IPG_DOZE, bool LPUART2_IPG_STOP_MODE,
                          bool LPUART2_STOP_REQ, bool LPUART2_IPG_DOZE,
                          bool LPUART1_IPG_STOP_MODE, bool LPUART1_STOP_REQ,
                          bool LPUART1_IPG_DOZE, bool LPSPI6_IPG_STOP_MODE,
                          bool LPSPI6_STOP_REQ, bool LPSPI6_IPG_DOZE,
                          bool LPSPI5_IPG_STOP_MODE, bool LPSPI5_STOP_REQ,
                          bool LPSPI5_IPG_DOZE, bool LPSPI4_IPG_STOP_MODE,
                          bool LPSPI4_STOP_REQ, bool LPSPI4_IPG_DOZE,
                          bool LPSPI3_IPG_STOP_MODE, bool LPSPI3_STOP_REQ,
                          bool LPSPI3_IPG_DOZE, bool LPSPI2_IPG_STOP_MODE,
                          bool LPSPI2_STOP_REQ, bool LPSPI2_IPG_DOZE) volatile
    {
        uint32_t curr = GPR72;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (LPUART4_IPG_STOP_MODE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (LPUART4_STOP_REQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (LPUART4_IPG_DOZE & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (LPUART3_IPG_STOP_MODE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (LPUART3_STOP_REQ & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (LPUART3_IPG_DOZE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (LPUART2_IPG_STOP_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (LPUART2_STOP_REQ & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (LPUART2_IPG_DOZE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (LPUART1_IPG_STOP_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (LPUART1_STOP_REQ & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (LPUART1_IPG_DOZE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (LPSPI6_IPG_STOP_MODE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (LPSPI6_STOP_REQ & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (LPSPI6_IPG_DOZE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LPSPI5_IPG_STOP_MODE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (LPSPI5_STOP_REQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (LPSPI5_IPG_DOZE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (LPSPI4_IPG_STOP_MODE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LPSPI4_STOP_REQ & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (LPSPI4_IPG_DOZE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LPSPI3_IPG_STOP_MODE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (LPSPI3_STOP_REQ & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LPSPI3_IPG_DOZE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (LPSPI2_IPG_STOP_MODE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (LPSPI2_STOP_REQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (LPSPI2_IPG_DOZE & 0b1u) << 0u;

        GPR72 = curr;
    }

    /**
     * Get GPR73's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR73_DWP_LOCK get_GPR73_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR73_DWP_LOCK((GPR73 >> 30u) & 0b11u);
    }

    /**
     * Set GPR73's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR73_DWP_LOCK(IOMUXC_GPR_GPR73_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR73;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR73 = curr;
    }

    /**
     * Get GPR73's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR73_DWP get_GPR73_DWP() volatile
    {
        return IOMUXC_GPR_GPR73_DWP((GPR73 >> 28u) & 0b11u);
    }

    /**
     * Set GPR73's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR73_DWP(IOMUXC_GPR_GPR73_DWP value) volatile
    {
        uint32_t curr = GPR73;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR73 = curr;
    }

    /**
     * Get GPR73's MIC_IPG_STOP_MODE bit.
     *
     * MIC stop mode selection, cannot change when MIC_STOP_REQ is asserted.
     */
    inline bool get_GPR73_MIC_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 26u);
    }

    /**
     * Set GPR73's MIC_IPG_STOP_MODE bit.
     *
     * MIC stop mode selection, cannot change when MIC_STOP_REQ is asserted.
     */
    inline void set_GPR73_MIC_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 26u;
    }

    /**
     * Clear GPR73's MIC_IPG_STOP_MODE bit.
     *
     * MIC stop mode selection, cannot change when MIC_STOP_REQ is asserted.
     */
    inline void clear_GPR73_MIC_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 26u);
    }

    /**
     * Toggle GPR73's MIC_IPG_STOP_MODE bit.
     *
     * MIC stop mode selection, cannot change when MIC_STOP_REQ is asserted.
     */
    inline void toggle_GPR73_MIC_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 26u;
    }

    /**
     * Get GPR73's MIC_STOP_REQ bit.
     *
     * MIC stop request
     */
    inline bool get_GPR73_MIC_STOP_REQ() volatile
    {
        return GPR73 & (1u << 25u);
    }

    /**
     * Set GPR73's MIC_STOP_REQ bit.
     *
     * MIC stop request
     */
    inline void set_GPR73_MIC_STOP_REQ() volatile
    {
        GPR73 |= 1u << 25u;
    }

    /**
     * Clear GPR73's MIC_STOP_REQ bit.
     *
     * MIC stop request
     */
    inline void clear_GPR73_MIC_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 25u);
    }

    /**
     * Toggle GPR73's MIC_STOP_REQ bit.
     *
     * MIC stop request
     */
    inline void toggle_GPR73_MIC_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 25u;
    }

    /**
     * Get GPR73's MIC_IPG_DOZE bit.
     *
     * MIC doze mode
     */
    inline bool get_GPR73_MIC_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 24u);
    }

    /**
     * Set GPR73's MIC_IPG_DOZE bit.
     *
     * MIC doze mode
     */
    inline void set_GPR73_MIC_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 24u;
    }

    /**
     * Clear GPR73's MIC_IPG_DOZE bit.
     *
     * MIC doze mode
     */
    inline void clear_GPR73_MIC_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 24u);
    }

    /**
     * Toggle GPR73's MIC_IPG_DOZE bit.
     *
     * MIC doze mode
     */
    inline void toggle_GPR73_MIC_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 24u;
    }

    /**
     * Get GPR73's LPUART12_IPG_STOP_MODE bit.
     *
     * LPUART12 stop mode selection, cannot change when LPUART12_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART12_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 23u);
    }

    /**
     * Set GPR73's LPUART12_IPG_STOP_MODE bit.
     *
     * LPUART12 stop mode selection, cannot change when LPUART12_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART12_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 23u;
    }

    /**
     * Clear GPR73's LPUART12_IPG_STOP_MODE bit.
     *
     * LPUART12 stop mode selection, cannot change when LPUART12_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART12_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 23u);
    }

    /**
     * Toggle GPR73's LPUART12_IPG_STOP_MODE bit.
     *
     * LPUART12 stop mode selection, cannot change when LPUART12_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART12_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 23u;
    }

    /**
     * Get GPR73's LPUART12_STOP_REQ bit.
     *
     * LPUART12 stop request
     */
    inline bool get_GPR73_LPUART12_STOP_REQ() volatile
    {
        return GPR73 & (1u << 22u);
    }

    /**
     * Set GPR73's LPUART12_STOP_REQ bit.
     *
     * LPUART12 stop request
     */
    inline void set_GPR73_LPUART12_STOP_REQ() volatile
    {
        GPR73 |= 1u << 22u;
    }

    /**
     * Clear GPR73's LPUART12_STOP_REQ bit.
     *
     * LPUART12 stop request
     */
    inline void clear_GPR73_LPUART12_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 22u);
    }

    /**
     * Toggle GPR73's LPUART12_STOP_REQ bit.
     *
     * LPUART12 stop request
     */
    inline void toggle_GPR73_LPUART12_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 22u;
    }

    /**
     * Get GPR73's LPUART12_IPG_DOZE bit.
     *
     * LPUART12 doze mode
     */
    inline bool get_GPR73_LPUART12_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 21u);
    }

    /**
     * Set GPR73's LPUART12_IPG_DOZE bit.
     *
     * LPUART12 doze mode
     */
    inline void set_GPR73_LPUART12_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 21u;
    }

    /**
     * Clear GPR73's LPUART12_IPG_DOZE bit.
     *
     * LPUART12 doze mode
     */
    inline void clear_GPR73_LPUART12_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 21u);
    }

    /**
     * Toggle GPR73's LPUART12_IPG_DOZE bit.
     *
     * LPUART12 doze mode
     */
    inline void toggle_GPR73_LPUART12_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 21u;
    }

    /**
     * Get GPR73's LPUART11_IPG_STOP_MODE bit.
     *
     * LPUART11 stop mode selection, cannot change when LPUART11_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART11_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 20u);
    }

    /**
     * Set GPR73's LPUART11_IPG_STOP_MODE bit.
     *
     * LPUART11 stop mode selection, cannot change when LPUART11_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART11_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 20u;
    }

    /**
     * Clear GPR73's LPUART11_IPG_STOP_MODE bit.
     *
     * LPUART11 stop mode selection, cannot change when LPUART11_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART11_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 20u);
    }

    /**
     * Toggle GPR73's LPUART11_IPG_STOP_MODE bit.
     *
     * LPUART11 stop mode selection, cannot change when LPUART11_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART11_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 20u;
    }

    /**
     * Get GPR73's LPUART11_STOP_REQ bit.
     *
     * LPUART11 stop request
     */
    inline bool get_GPR73_LPUART11_STOP_REQ() volatile
    {
        return GPR73 & (1u << 19u);
    }

    /**
     * Set GPR73's LPUART11_STOP_REQ bit.
     *
     * LPUART11 stop request
     */
    inline void set_GPR73_LPUART11_STOP_REQ() volatile
    {
        GPR73 |= 1u << 19u;
    }

    /**
     * Clear GPR73's LPUART11_STOP_REQ bit.
     *
     * LPUART11 stop request
     */
    inline void clear_GPR73_LPUART11_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 19u);
    }

    /**
     * Toggle GPR73's LPUART11_STOP_REQ bit.
     *
     * LPUART11 stop request
     */
    inline void toggle_GPR73_LPUART11_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 19u;
    }

    /**
     * Get GPR73's LPUART11_IPG_DOZE bit.
     *
     * LPUART11 doze mode
     */
    inline bool get_GPR73_LPUART11_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 18u);
    }

    /**
     * Set GPR73's LPUART11_IPG_DOZE bit.
     *
     * LPUART11 doze mode
     */
    inline void set_GPR73_LPUART11_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 18u;
    }

    /**
     * Clear GPR73's LPUART11_IPG_DOZE bit.
     *
     * LPUART11 doze mode
     */
    inline void clear_GPR73_LPUART11_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 18u);
    }

    /**
     * Toggle GPR73's LPUART11_IPG_DOZE bit.
     *
     * LPUART11 doze mode
     */
    inline void toggle_GPR73_LPUART11_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 18u;
    }

    /**
     * Get GPR73's LPUART10_IPG_STOP_MODE bit.
     *
     * LPUART10 stop mode selection, cannot change when LPUART10_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART10_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 17u);
    }

    /**
     * Set GPR73's LPUART10_IPG_STOP_MODE bit.
     *
     * LPUART10 stop mode selection, cannot change when LPUART10_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART10_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 17u;
    }

    /**
     * Clear GPR73's LPUART10_IPG_STOP_MODE bit.
     *
     * LPUART10 stop mode selection, cannot change when LPUART10_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART10_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR73's LPUART10_IPG_STOP_MODE bit.
     *
     * LPUART10 stop mode selection, cannot change when LPUART10_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART10_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 17u;
    }

    /**
     * Get GPR73's LPUART10_STOP_REQ bit.
     *
     * LPUART10 stop request
     */
    inline bool get_GPR73_LPUART10_STOP_REQ() volatile
    {
        return GPR73 & (1u << 16u);
    }

    /**
     * Set GPR73's LPUART10_STOP_REQ bit.
     *
     * LPUART10 stop request
     */
    inline void set_GPR73_LPUART10_STOP_REQ() volatile
    {
        GPR73 |= 1u << 16u;
    }

    /**
     * Clear GPR73's LPUART10_STOP_REQ bit.
     *
     * LPUART10 stop request
     */
    inline void clear_GPR73_LPUART10_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR73's LPUART10_STOP_REQ bit.
     *
     * LPUART10 stop request
     */
    inline void toggle_GPR73_LPUART10_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 16u;
    }

    /**
     * Get GPR73's LPUART10_IPG_DOZE bit.
     *
     * LPUART10 doze mode
     */
    inline bool get_GPR73_LPUART10_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 15u);
    }

    /**
     * Set GPR73's LPUART10_IPG_DOZE bit.
     *
     * LPUART10 doze mode
     */
    inline void set_GPR73_LPUART10_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 15u;
    }

    /**
     * Clear GPR73's LPUART10_IPG_DOZE bit.
     *
     * LPUART10 doze mode
     */
    inline void clear_GPR73_LPUART10_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 15u);
    }

    /**
     * Toggle GPR73's LPUART10_IPG_DOZE bit.
     *
     * LPUART10 doze mode
     */
    inline void toggle_GPR73_LPUART10_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 15u;
    }

    /**
     * Get GPR73's LPUART9_IPG_STOP_MODE bit.
     *
     * LPUART9 stop mode selection, cannot change when LPUART9_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART9_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 14u);
    }

    /**
     * Set GPR73's LPUART9_IPG_STOP_MODE bit.
     *
     * LPUART9 stop mode selection, cannot change when LPUART9_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART9_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 14u;
    }

    /**
     * Clear GPR73's LPUART9_IPG_STOP_MODE bit.
     *
     * LPUART9 stop mode selection, cannot change when LPUART9_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART9_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR73's LPUART9_IPG_STOP_MODE bit.
     *
     * LPUART9 stop mode selection, cannot change when LPUART9_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART9_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 14u;
    }

    /**
     * Get GPR73's LPUART9_STOP_REQ bit.
     *
     * LPUART9 stop request
     */
    inline bool get_GPR73_LPUART9_STOP_REQ() volatile
    {
        return GPR73 & (1u << 13u);
    }

    /**
     * Set GPR73's LPUART9_STOP_REQ bit.
     *
     * LPUART9 stop request
     */
    inline void set_GPR73_LPUART9_STOP_REQ() volatile
    {
        GPR73 |= 1u << 13u;
    }

    /**
     * Clear GPR73's LPUART9_STOP_REQ bit.
     *
     * LPUART9 stop request
     */
    inline void clear_GPR73_LPUART9_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR73's LPUART9_STOP_REQ bit.
     *
     * LPUART9 stop request
     */
    inline void toggle_GPR73_LPUART9_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 13u;
    }

    /**
     * Get GPR73's LPUART9_IPG_DOZE bit.
     *
     * LPUART9 doze mode
     */
    inline bool get_GPR73_LPUART9_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 12u);
    }

    /**
     * Set GPR73's LPUART9_IPG_DOZE bit.
     *
     * LPUART9 doze mode
     */
    inline void set_GPR73_LPUART9_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 12u;
    }

    /**
     * Clear GPR73's LPUART9_IPG_DOZE bit.
     *
     * LPUART9 doze mode
     */
    inline void clear_GPR73_LPUART9_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR73's LPUART9_IPG_DOZE bit.
     *
     * LPUART9 doze mode
     */
    inline void toggle_GPR73_LPUART9_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 12u;
    }

    /**
     * Get GPR73's LPUART8_IPG_STOP_MODE bit.
     *
     * LPUART8 stop mode selection, cannot change when LPUART8_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART8_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 11u);
    }

    /**
     * Set GPR73's LPUART8_IPG_STOP_MODE bit.
     *
     * LPUART8 stop mode selection, cannot change when LPUART8_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART8_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 11u;
    }

    /**
     * Clear GPR73's LPUART8_IPG_STOP_MODE bit.
     *
     * LPUART8 stop mode selection, cannot change when LPUART8_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART8_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR73's LPUART8_IPG_STOP_MODE bit.
     *
     * LPUART8 stop mode selection, cannot change when LPUART8_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART8_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 11u;
    }

    /**
     * Get GPR73's LPUART8_STOP_REQ bit.
     *
     * LPUART8 stop request
     */
    inline bool get_GPR73_LPUART8_STOP_REQ() volatile
    {
        return GPR73 & (1u << 10u);
    }

    /**
     * Set GPR73's LPUART8_STOP_REQ bit.
     *
     * LPUART8 stop request
     */
    inline void set_GPR73_LPUART8_STOP_REQ() volatile
    {
        GPR73 |= 1u << 10u;
    }

    /**
     * Clear GPR73's LPUART8_STOP_REQ bit.
     *
     * LPUART8 stop request
     */
    inline void clear_GPR73_LPUART8_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR73's LPUART8_STOP_REQ bit.
     *
     * LPUART8 stop request
     */
    inline void toggle_GPR73_LPUART8_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 10u;
    }

    /**
     * Get GPR73's LPUART8_IPG_DOZE bit.
     *
     * LPUART8 doze mode
     */
    inline bool get_GPR73_LPUART8_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 9u);
    }

    /**
     * Set GPR73's LPUART8_IPG_DOZE bit.
     *
     * LPUART8 doze mode
     */
    inline void set_GPR73_LPUART8_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 9u;
    }

    /**
     * Clear GPR73's LPUART8_IPG_DOZE bit.
     *
     * LPUART8 doze mode
     */
    inline void clear_GPR73_LPUART8_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR73's LPUART8_IPG_DOZE bit.
     *
     * LPUART8 doze mode
     */
    inline void toggle_GPR73_LPUART8_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 9u;
    }

    /**
     * Get GPR73's LPUART7_IPG_STOP_MODE bit.
     *
     * LPUART7 stop mode selection, cannot change when LPUART7_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART7_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 8u);
    }

    /**
     * Set GPR73's LPUART7_IPG_STOP_MODE bit.
     *
     * LPUART7 stop mode selection, cannot change when LPUART7_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART7_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 8u;
    }

    /**
     * Clear GPR73's LPUART7_IPG_STOP_MODE bit.
     *
     * LPUART7 stop mode selection, cannot change when LPUART7_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART7_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR73's LPUART7_IPG_STOP_MODE bit.
     *
     * LPUART7 stop mode selection, cannot change when LPUART7_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART7_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 8u;
    }

    /**
     * Get GPR73's LPUART7_STOP_REQ bit.
     *
     * LPUART7 stop request
     */
    inline bool get_GPR73_LPUART7_STOP_REQ() volatile
    {
        return GPR73 & (1u << 7u);
    }

    /**
     * Set GPR73's LPUART7_STOP_REQ bit.
     *
     * LPUART7 stop request
     */
    inline void set_GPR73_LPUART7_STOP_REQ() volatile
    {
        GPR73 |= 1u << 7u;
    }

    /**
     * Clear GPR73's LPUART7_STOP_REQ bit.
     *
     * LPUART7 stop request
     */
    inline void clear_GPR73_LPUART7_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR73's LPUART7_STOP_REQ bit.
     *
     * LPUART7 stop request
     */
    inline void toggle_GPR73_LPUART7_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 7u;
    }

    /**
     * Get GPR73's LPUART7_IPG_DOZE bit.
     *
     * LPUART7 doze mode
     */
    inline bool get_GPR73_LPUART7_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 6u);
    }

    /**
     * Set GPR73's LPUART7_IPG_DOZE bit.
     *
     * LPUART7 doze mode
     */
    inline void set_GPR73_LPUART7_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 6u;
    }

    /**
     * Clear GPR73's LPUART7_IPG_DOZE bit.
     *
     * LPUART7 doze mode
     */
    inline void clear_GPR73_LPUART7_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR73's LPUART7_IPG_DOZE bit.
     *
     * LPUART7 doze mode
     */
    inline void toggle_GPR73_LPUART7_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 6u;
    }

    /**
     * Get GPR73's LPUART6_IPG_STOP_MODE bit.
     *
     * LPUART6 stop mode selection, cannot change when LPUART6_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART6_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 5u);
    }

    /**
     * Set GPR73's LPUART6_IPG_STOP_MODE bit.
     *
     * LPUART6 stop mode selection, cannot change when LPUART6_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART6_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 5u;
    }

    /**
     * Clear GPR73's LPUART6_IPG_STOP_MODE bit.
     *
     * LPUART6 stop mode selection, cannot change when LPUART6_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART6_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR73's LPUART6_IPG_STOP_MODE bit.
     *
     * LPUART6 stop mode selection, cannot change when LPUART6_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART6_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 5u;
    }

    /**
     * Get GPR73's LPUART6_STOP_REQ bit.
     *
     * LPUART6 stop request
     */
    inline bool get_GPR73_LPUART6_STOP_REQ() volatile
    {
        return GPR73 & (1u << 4u);
    }

    /**
     * Set GPR73's LPUART6_STOP_REQ bit.
     *
     * LPUART6 stop request
     */
    inline void set_GPR73_LPUART6_STOP_REQ() volatile
    {
        GPR73 |= 1u << 4u;
    }

    /**
     * Clear GPR73's LPUART6_STOP_REQ bit.
     *
     * LPUART6 stop request
     */
    inline void clear_GPR73_LPUART6_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR73's LPUART6_STOP_REQ bit.
     *
     * LPUART6 stop request
     */
    inline void toggle_GPR73_LPUART6_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 4u;
    }

    /**
     * Get GPR73's LPUART6_IPG_DOZE bit.
     *
     * LPUART6 doze mode
     */
    inline bool get_GPR73_LPUART6_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 3u);
    }

    /**
     * Set GPR73's LPUART6_IPG_DOZE bit.
     *
     * LPUART6 doze mode
     */
    inline void set_GPR73_LPUART6_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 3u;
    }

    /**
     * Clear GPR73's LPUART6_IPG_DOZE bit.
     *
     * LPUART6 doze mode
     */
    inline void clear_GPR73_LPUART6_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR73's LPUART6_IPG_DOZE bit.
     *
     * LPUART6 doze mode
     */
    inline void toggle_GPR73_LPUART6_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 3u;
    }

    /**
     * Get GPR73's LPUART5_IPG_STOP_MODE bit.
     *
     * LPUART5 stop mode selection, cannot change when LPUART5_STOP_REQ is
     * asserted.
     */
    inline bool get_GPR73_LPUART5_IPG_STOP_MODE() volatile
    {
        return GPR73 & (1u << 2u);
    }

    /**
     * Set GPR73's LPUART5_IPG_STOP_MODE bit.
     *
     * LPUART5 stop mode selection, cannot change when LPUART5_STOP_REQ is
     * asserted.
     */
    inline void set_GPR73_LPUART5_IPG_STOP_MODE() volatile
    {
        GPR73 |= 1u << 2u;
    }

    /**
     * Clear GPR73's LPUART5_IPG_STOP_MODE bit.
     *
     * LPUART5 stop mode selection, cannot change when LPUART5_STOP_REQ is
     * asserted.
     */
    inline void clear_GPR73_LPUART5_IPG_STOP_MODE() volatile
    {
        GPR73 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR73's LPUART5_IPG_STOP_MODE bit.
     *
     * LPUART5 stop mode selection, cannot change when LPUART5_STOP_REQ is
     * asserted.
     */
    inline void toggle_GPR73_LPUART5_IPG_STOP_MODE() volatile
    {
        GPR73 ^= 1u << 2u;
    }

    /**
     * Get GPR73's LPUART5_STOP_REQ bit.
     *
     * LPUART5 stop request
     */
    inline bool get_GPR73_LPUART5_STOP_REQ() volatile
    {
        return GPR73 & (1u << 1u);
    }

    /**
     * Set GPR73's LPUART5_STOP_REQ bit.
     *
     * LPUART5 stop request
     */
    inline void set_GPR73_LPUART5_STOP_REQ() volatile
    {
        GPR73 |= 1u << 1u;
    }

    /**
     * Clear GPR73's LPUART5_STOP_REQ bit.
     *
     * LPUART5 stop request
     */
    inline void clear_GPR73_LPUART5_STOP_REQ() volatile
    {
        GPR73 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR73's LPUART5_STOP_REQ bit.
     *
     * LPUART5 stop request
     */
    inline void toggle_GPR73_LPUART5_STOP_REQ() volatile
    {
        GPR73 ^= 1u << 1u;
    }

    /**
     * Get GPR73's LPUART5_IPG_DOZE bit.
     *
     * LPUART5 doze mode
     */
    inline bool get_GPR73_LPUART5_IPG_DOZE() volatile
    {
        return GPR73 & (1u << 0u);
    }

    /**
     * Set GPR73's LPUART5_IPG_DOZE bit.
     *
     * LPUART5 doze mode
     */
    inline void set_GPR73_LPUART5_IPG_DOZE() volatile
    {
        GPR73 |= 1u << 0u;
    }

    /**
     * Clear GPR73's LPUART5_IPG_DOZE bit.
     *
     * LPUART5 doze mode
     */
    inline void clear_GPR73_LPUART5_IPG_DOZE() volatile
    {
        GPR73 &= ~(1u << 0u);
    }

    /**
     * Toggle GPR73's LPUART5_IPG_DOZE bit.
     *
     * LPUART5 doze mode
     */
    inline void toggle_GPR73_LPUART5_IPG_DOZE() volatile
    {
        GPR73 ^= 1u << 0u;
    }

    /**
     * Get all of GPR73's bit fields.
     *
     * (read-write) GPR73 General Purpose Register
     */
    inline void get_GPR73(IOMUXC_GPR_GPR73_DWP_LOCK &DWP_LOCK,
                          IOMUXC_GPR_GPR73_DWP &DWP, bool &MIC_IPG_STOP_MODE,
                          bool &MIC_STOP_REQ, bool &MIC_IPG_DOZE,
                          bool &LPUART12_IPG_STOP_MODE,
                          bool &LPUART12_STOP_REQ, bool &LPUART12_IPG_DOZE,
                          bool &LPUART11_IPG_STOP_MODE,
                          bool &LPUART11_STOP_REQ, bool &LPUART11_IPG_DOZE,
                          bool &LPUART10_IPG_STOP_MODE,
                          bool &LPUART10_STOP_REQ, bool &LPUART10_IPG_DOZE,
                          bool &LPUART9_IPG_STOP_MODE, bool &LPUART9_STOP_REQ,
                          bool &LPUART9_IPG_DOZE, bool &LPUART8_IPG_STOP_MODE,
                          bool &LPUART8_STOP_REQ, bool &LPUART8_IPG_DOZE,
                          bool &LPUART7_IPG_STOP_MODE, bool &LPUART7_STOP_REQ,
                          bool &LPUART7_IPG_DOZE, bool &LPUART6_IPG_STOP_MODE,
                          bool &LPUART6_STOP_REQ, bool &LPUART6_IPG_DOZE,
                          bool &LPUART5_IPG_STOP_MODE, bool &LPUART5_STOP_REQ,
                          bool &LPUART5_IPG_DOZE) volatile
    {
        uint32_t curr = GPR73;

        DWP_LOCK = IOMUXC_GPR_GPR73_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR73_DWP((curr >> 28u) & 0b11u);
        MIC_IPG_STOP_MODE = curr & (1u << 26u);
        MIC_STOP_REQ = curr & (1u << 25u);
        MIC_IPG_DOZE = curr & (1u << 24u);
        LPUART12_IPG_STOP_MODE = curr & (1u << 23u);
        LPUART12_STOP_REQ = curr & (1u << 22u);
        LPUART12_IPG_DOZE = curr & (1u << 21u);
        LPUART11_IPG_STOP_MODE = curr & (1u << 20u);
        LPUART11_STOP_REQ = curr & (1u << 19u);
        LPUART11_IPG_DOZE = curr & (1u << 18u);
        LPUART10_IPG_STOP_MODE = curr & (1u << 17u);
        LPUART10_STOP_REQ = curr & (1u << 16u);
        LPUART10_IPG_DOZE = curr & (1u << 15u);
        LPUART9_IPG_STOP_MODE = curr & (1u << 14u);
        LPUART9_STOP_REQ = curr & (1u << 13u);
        LPUART9_IPG_DOZE = curr & (1u << 12u);
        LPUART8_IPG_STOP_MODE = curr & (1u << 11u);
        LPUART8_STOP_REQ = curr & (1u << 10u);
        LPUART8_IPG_DOZE = curr & (1u << 9u);
        LPUART7_IPG_STOP_MODE = curr & (1u << 8u);
        LPUART7_STOP_REQ = curr & (1u << 7u);
        LPUART7_IPG_DOZE = curr & (1u << 6u);
        LPUART6_IPG_STOP_MODE = curr & (1u << 5u);
        LPUART6_STOP_REQ = curr & (1u << 4u);
        LPUART6_IPG_DOZE = curr & (1u << 3u);
        LPUART5_IPG_STOP_MODE = curr & (1u << 2u);
        LPUART5_STOP_REQ = curr & (1u << 1u);
        LPUART5_IPG_DOZE = curr & (1u << 0u);
    }

    /**
     * Set all of GPR73's bit fields.
     *
     * (read-write) GPR73 General Purpose Register
     */
    inline void set_GPR73(IOMUXC_GPR_GPR73_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR73_DWP DWP, bool MIC_IPG_STOP_MODE,
                          bool MIC_STOP_REQ, bool MIC_IPG_DOZE,
                          bool LPUART12_IPG_STOP_MODE, bool LPUART12_STOP_REQ,
                          bool LPUART12_IPG_DOZE, bool LPUART11_IPG_STOP_MODE,
                          bool LPUART11_STOP_REQ, bool LPUART11_IPG_DOZE,
                          bool LPUART10_IPG_STOP_MODE, bool LPUART10_STOP_REQ,
                          bool LPUART10_IPG_DOZE, bool LPUART9_IPG_STOP_MODE,
                          bool LPUART9_STOP_REQ, bool LPUART9_IPG_DOZE,
                          bool LPUART8_IPG_STOP_MODE, bool LPUART8_STOP_REQ,
                          bool LPUART8_IPG_DOZE, bool LPUART7_IPG_STOP_MODE,
                          bool LPUART7_STOP_REQ, bool LPUART7_IPG_DOZE,
                          bool LPUART6_IPG_STOP_MODE, bool LPUART6_STOP_REQ,
                          bool LPUART6_IPG_DOZE, bool LPUART5_IPG_STOP_MODE,
                          bool LPUART5_STOP_REQ,
                          bool LPUART5_IPG_DOZE) volatile
    {
        uint32_t curr = GPR73;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (MIC_IPG_STOP_MODE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (MIC_STOP_REQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (MIC_IPG_DOZE & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (LPUART12_IPG_STOP_MODE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (LPUART12_STOP_REQ & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (LPUART12_IPG_DOZE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (LPUART11_IPG_STOP_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (LPUART11_STOP_REQ & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (LPUART11_IPG_DOZE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (LPUART10_IPG_STOP_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (LPUART10_STOP_REQ & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (LPUART10_IPG_DOZE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (LPUART9_IPG_STOP_MODE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (LPUART9_STOP_REQ & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (LPUART9_IPG_DOZE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (LPUART8_IPG_STOP_MODE & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (LPUART8_STOP_REQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (LPUART8_IPG_DOZE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (LPUART7_IPG_STOP_MODE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LPUART7_STOP_REQ & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (LPUART7_IPG_DOZE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LPUART6_IPG_STOP_MODE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (LPUART6_STOP_REQ & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LPUART6_IPG_DOZE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (LPUART5_IPG_STOP_MODE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (LPUART5_STOP_REQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (LPUART5_IPG_DOZE & 0b1u) << 0u;

        GPR73 = curr;
    }

    /**
     * Get GPR74's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_GPR_GPR74_DWP_LOCK get_GPR74_DWP_LOCK() volatile
    {
        return IOMUXC_GPR_GPR74_DWP_LOCK((GPR74 >> 30u) & 0b11u);
    }

    /**
     * Set GPR74's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_GPR74_DWP_LOCK(IOMUXC_GPR_GPR74_DWP_LOCK value) volatile
    {
        uint32_t curr = GPR74;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        GPR74 = curr;
    }

    /**
     * Get GPR74's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_GPR_GPR74_DWP get_GPR74_DWP() volatile
    {
        return IOMUXC_GPR_GPR74_DWP((GPR74 >> 28u) & 0b11u);
    }

    /**
     * Set GPR74's DWP field.
     *
     * Domain write protection
     */
    inline void set_GPR74_DWP(IOMUXC_GPR_GPR74_DWP value) volatile
    {
        uint32_t curr = GPR74;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        GPR74 = curr;
    }

    /**
     * Get GPR74's FLEXIO2_STOP_REQ_PER bit.
     *
     * FLEXIO2 peripheral clock domain stop request
     */
    inline bool get_GPR74_FLEXIO2_STOP_REQ_PER() volatile
    {
        return GPR74 & (1u << 17u);
    }

    /**
     * Set GPR74's FLEXIO2_STOP_REQ_PER bit.
     *
     * FLEXIO2 peripheral clock domain stop request
     */
    inline void set_GPR74_FLEXIO2_STOP_REQ_PER() volatile
    {
        GPR74 |= 1u << 17u;
    }

    /**
     * Clear GPR74's FLEXIO2_STOP_REQ_PER bit.
     *
     * FLEXIO2 peripheral clock domain stop request
     */
    inline void clear_GPR74_FLEXIO2_STOP_REQ_PER() volatile
    {
        GPR74 &= ~(1u << 17u);
    }

    /**
     * Toggle GPR74's FLEXIO2_STOP_REQ_PER bit.
     *
     * FLEXIO2 peripheral clock domain stop request
     */
    inline void toggle_GPR74_FLEXIO2_STOP_REQ_PER() volatile
    {
        GPR74 ^= 1u << 17u;
    }

    /**
     * Get GPR74's FLEXIO2_STOP_REQ_BUS bit.
     *
     * FLEXIO2 bus clock domain stop request
     */
    inline bool get_GPR74_FLEXIO2_STOP_REQ_BUS() volatile
    {
        return GPR74 & (1u << 16u);
    }

    /**
     * Set GPR74's FLEXIO2_STOP_REQ_BUS bit.
     *
     * FLEXIO2 bus clock domain stop request
     */
    inline void set_GPR74_FLEXIO2_STOP_REQ_BUS() volatile
    {
        GPR74 |= 1u << 16u;
    }

    /**
     * Clear GPR74's FLEXIO2_STOP_REQ_BUS bit.
     *
     * FLEXIO2 bus clock domain stop request
     */
    inline void clear_GPR74_FLEXIO2_STOP_REQ_BUS() volatile
    {
        GPR74 &= ~(1u << 16u);
    }

    /**
     * Toggle GPR74's FLEXIO2_STOP_REQ_BUS bit.
     *
     * FLEXIO2 bus clock domain stop request
     */
    inline void toggle_GPR74_FLEXIO2_STOP_REQ_BUS() volatile
    {
        GPR74 ^= 1u << 16u;
    }

    /**
     * Get GPR74's FLEXIO1_STOP_REQ_PER bit.
     *
     * FLEXIO1 peripheral clock domain stop request
     */
    inline bool get_GPR74_FLEXIO1_STOP_REQ_PER() volatile
    {
        return GPR74 & (1u << 15u);
    }

    /**
     * Set GPR74's FLEXIO1_STOP_REQ_PER bit.
     *
     * FLEXIO1 peripheral clock domain stop request
     */
    inline void set_GPR74_FLEXIO1_STOP_REQ_PER() volatile
    {
        GPR74 |= 1u << 15u;
    }

    /**
     * Clear GPR74's FLEXIO1_STOP_REQ_PER bit.
     *
     * FLEXIO1 peripheral clock domain stop request
     */
    inline void clear_GPR74_FLEXIO1_STOP_REQ_PER() volatile
    {
        GPR74 &= ~(1u << 15u);
    }

    /**
     * Toggle GPR74's FLEXIO1_STOP_REQ_PER bit.
     *
     * FLEXIO1 peripheral clock domain stop request
     */
    inline void toggle_GPR74_FLEXIO1_STOP_REQ_PER() volatile
    {
        GPR74 ^= 1u << 15u;
    }

    /**
     * Get GPR74's FLEXIO1_STOP_REQ_BUS bit.
     *
     * FLEXIO1 bus clock domain stop request
     */
    inline bool get_GPR74_FLEXIO1_STOP_REQ_BUS() volatile
    {
        return GPR74 & (1u << 14u);
    }

    /**
     * Set GPR74's FLEXIO1_STOP_REQ_BUS bit.
     *
     * FLEXIO1 bus clock domain stop request
     */
    inline void set_GPR74_FLEXIO1_STOP_REQ_BUS() volatile
    {
        GPR74 |= 1u << 14u;
    }

    /**
     * Clear GPR74's FLEXIO1_STOP_REQ_BUS bit.
     *
     * FLEXIO1 bus clock domain stop request
     */
    inline void clear_GPR74_FLEXIO1_STOP_REQ_BUS() volatile
    {
        GPR74 &= ~(1u << 14u);
    }

    /**
     * Toggle GPR74's FLEXIO1_STOP_REQ_BUS bit.
     *
     * FLEXIO1 bus clock domain stop request
     */
    inline void toggle_GPR74_FLEXIO1_STOP_REQ_BUS() volatile
    {
        GPR74 ^= 1u << 14u;
    }

    /**
     * Get GPR74's SAI4_STOP_REQ bit.
     *
     * SAI4 stop request
     */
    inline bool get_GPR74_SAI4_STOP_REQ() volatile
    {
        return GPR74 & (1u << 13u);
    }

    /**
     * Set GPR74's SAI4_STOP_REQ bit.
     *
     * SAI4 stop request
     */
    inline void set_GPR74_SAI4_STOP_REQ() volatile
    {
        GPR74 |= 1u << 13u;
    }

    /**
     * Clear GPR74's SAI4_STOP_REQ bit.
     *
     * SAI4 stop request
     */
    inline void clear_GPR74_SAI4_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 13u);
    }

    /**
     * Toggle GPR74's SAI4_STOP_REQ bit.
     *
     * SAI4 stop request
     */
    inline void toggle_GPR74_SAI4_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 13u;
    }

    /**
     * Get GPR74's SAI3_STOP_REQ bit.
     *
     * SAI3 stop request
     */
    inline bool get_GPR74_SAI3_STOP_REQ() volatile
    {
        return GPR74 & (1u << 12u);
    }

    /**
     * Set GPR74's SAI3_STOP_REQ bit.
     *
     * SAI3 stop request
     */
    inline void set_GPR74_SAI3_STOP_REQ() volatile
    {
        GPR74 |= 1u << 12u;
    }

    /**
     * Clear GPR74's SAI3_STOP_REQ bit.
     *
     * SAI3 stop request
     */
    inline void clear_GPR74_SAI3_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 12u);
    }

    /**
     * Toggle GPR74's SAI3_STOP_REQ bit.
     *
     * SAI3 stop request
     */
    inline void toggle_GPR74_SAI3_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 12u;
    }

    /**
     * Get GPR74's SAI2_STOP_REQ bit.
     *
     * SAI2 stop request
     */
    inline bool get_GPR74_SAI2_STOP_REQ() volatile
    {
        return GPR74 & (1u << 11u);
    }

    /**
     * Set GPR74's SAI2_STOP_REQ bit.
     *
     * SAI2 stop request
     */
    inline void set_GPR74_SAI2_STOP_REQ() volatile
    {
        GPR74 |= 1u << 11u;
    }

    /**
     * Clear GPR74's SAI2_STOP_REQ bit.
     *
     * SAI2 stop request
     */
    inline void clear_GPR74_SAI2_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 11u);
    }

    /**
     * Toggle GPR74's SAI2_STOP_REQ bit.
     *
     * SAI2 stop request
     */
    inline void toggle_GPR74_SAI2_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 11u;
    }

    /**
     * Get GPR74's SAI1_STOP_REQ bit.
     *
     * SAI1 stop request
     */
    inline bool get_GPR74_SAI1_STOP_REQ() volatile
    {
        return GPR74 & (1u << 10u);
    }

    /**
     * Set GPR74's SAI1_STOP_REQ bit.
     *
     * SAI1 stop request
     */
    inline void set_GPR74_SAI1_STOP_REQ() volatile
    {
        GPR74 |= 1u << 10u;
    }

    /**
     * Clear GPR74's SAI1_STOP_REQ bit.
     *
     * SAI1 stop request
     */
    inline void clear_GPR74_SAI1_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 10u);
    }

    /**
     * Toggle GPR74's SAI1_STOP_REQ bit.
     *
     * SAI1 stop request
     */
    inline void toggle_GPR74_SAI1_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 10u;
    }

    /**
     * Get GPR74's WDOG2_IPG_DOZE bit.
     *
     * WDOG2 doze mode
     */
    inline bool get_GPR74_WDOG2_IPG_DOZE() volatile
    {
        return GPR74 & (1u << 9u);
    }

    /**
     * Set GPR74's WDOG2_IPG_DOZE bit.
     *
     * WDOG2 doze mode
     */
    inline void set_GPR74_WDOG2_IPG_DOZE() volatile
    {
        GPR74 |= 1u << 9u;
    }

    /**
     * Clear GPR74's WDOG2_IPG_DOZE bit.
     *
     * WDOG2 doze mode
     */
    inline void clear_GPR74_WDOG2_IPG_DOZE() volatile
    {
        GPR74 &= ~(1u << 9u);
    }

    /**
     * Toggle GPR74's WDOG2_IPG_DOZE bit.
     *
     * WDOG2 doze mode
     */
    inline void toggle_GPR74_WDOG2_IPG_DOZE() volatile
    {
        GPR74 ^= 1u << 9u;
    }

    /**
     * Get GPR74's WDOG1_IPG_DOZE bit.
     *
     * WDOG1 doze mode
     */
    inline bool get_GPR74_WDOG1_IPG_DOZE() volatile
    {
        return GPR74 & (1u << 8u);
    }

    /**
     * Set GPR74's WDOG1_IPG_DOZE bit.
     *
     * WDOG1 doze mode
     */
    inline void set_GPR74_WDOG1_IPG_DOZE() volatile
    {
        GPR74 |= 1u << 8u;
    }

    /**
     * Clear GPR74's WDOG1_IPG_DOZE bit.
     *
     * WDOG1 doze mode
     */
    inline void clear_GPR74_WDOG1_IPG_DOZE() volatile
    {
        GPR74 &= ~(1u << 8u);
    }

    /**
     * Toggle GPR74's WDOG1_IPG_DOZE bit.
     *
     * WDOG1 doze mode
     */
    inline void toggle_GPR74_WDOG1_IPG_DOZE() volatile
    {
        GPR74 ^= 1u << 8u;
    }

    /**
     * Get GPR74's SNVS_HP_STOP_REQ bit.
     *
     * SNVS_HP stop request
     */
    inline bool get_GPR74_SNVS_HP_STOP_REQ() volatile
    {
        return GPR74 & (1u << 7u);
    }

    /**
     * Set GPR74's SNVS_HP_STOP_REQ bit.
     *
     * SNVS_HP stop request
     */
    inline void set_GPR74_SNVS_HP_STOP_REQ() volatile
    {
        GPR74 |= 1u << 7u;
    }

    /**
     * Clear GPR74's SNVS_HP_STOP_REQ bit.
     *
     * SNVS_HP stop request
     */
    inline void clear_GPR74_SNVS_HP_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 7u);
    }

    /**
     * Toggle GPR74's SNVS_HP_STOP_REQ bit.
     *
     * SNVS_HP stop request
     */
    inline void toggle_GPR74_SNVS_HP_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 7u;
    }

    /**
     * Get GPR74's SNVS_HP_IPG_DOZE bit.
     *
     * SNVS_HP doze mode
     */
    inline bool get_GPR74_SNVS_HP_IPG_DOZE() volatile
    {
        return GPR74 & (1u << 6u);
    }

    /**
     * Set GPR74's SNVS_HP_IPG_DOZE bit.
     *
     * SNVS_HP doze mode
     */
    inline void set_GPR74_SNVS_HP_IPG_DOZE() volatile
    {
        GPR74 |= 1u << 6u;
    }

    /**
     * Clear GPR74's SNVS_HP_IPG_DOZE bit.
     *
     * SNVS_HP doze mode
     */
    inline void clear_GPR74_SNVS_HP_IPG_DOZE() volatile
    {
        GPR74 &= ~(1u << 6u);
    }

    /**
     * Toggle GPR74's SNVS_HP_IPG_DOZE bit.
     *
     * SNVS_HP doze mode
     */
    inline void toggle_GPR74_SNVS_HP_IPG_DOZE() volatile
    {
        GPR74 ^= 1u << 6u;
    }

    /**
     * Get GPR74's SIM2_IPG_DOZE bit.
     *
     * SIM2 doze mode
     */
    inline bool get_GPR74_SIM2_IPG_DOZE() volatile
    {
        return GPR74 & (1u << 5u);
    }

    /**
     * Set GPR74's SIM2_IPG_DOZE bit.
     *
     * SIM2 doze mode
     */
    inline void set_GPR74_SIM2_IPG_DOZE() volatile
    {
        GPR74 |= 1u << 5u;
    }

    /**
     * Clear GPR74's SIM2_IPG_DOZE bit.
     *
     * SIM2 doze mode
     */
    inline void clear_GPR74_SIM2_IPG_DOZE() volatile
    {
        GPR74 &= ~(1u << 5u);
    }

    /**
     * Toggle GPR74's SIM2_IPG_DOZE bit.
     *
     * SIM2 doze mode
     */
    inline void toggle_GPR74_SIM2_IPG_DOZE() volatile
    {
        GPR74 ^= 1u << 5u;
    }

    /**
     * Get GPR74's SIM1_IPG_DOZE bit.
     *
     * SIM1 doze mode
     */
    inline bool get_GPR74_SIM1_IPG_DOZE() volatile
    {
        return GPR74 & (1u << 4u);
    }

    /**
     * Set GPR74's SIM1_IPG_DOZE bit.
     *
     * SIM1 doze mode
     */
    inline void set_GPR74_SIM1_IPG_DOZE() volatile
    {
        GPR74 |= 1u << 4u;
    }

    /**
     * Clear GPR74's SIM1_IPG_DOZE bit.
     *
     * SIM1 doze mode
     */
    inline void clear_GPR74_SIM1_IPG_DOZE() volatile
    {
        GPR74 &= ~(1u << 4u);
    }

    /**
     * Toggle GPR74's SIM1_IPG_DOZE bit.
     *
     * SIM1 doze mode
     */
    inline void toggle_GPR74_SIM1_IPG_DOZE() volatile
    {
        GPR74 ^= 1u << 4u;
    }

    /**
     * Get GPR74's SEMC_STOP_REQ bit.
     *
     * SEMC stop request
     */
    inline bool get_GPR74_SEMC_STOP_REQ() volatile
    {
        return GPR74 & (1u << 3u);
    }

    /**
     * Set GPR74's SEMC_STOP_REQ bit.
     *
     * SEMC stop request
     */
    inline void set_GPR74_SEMC_STOP_REQ() volatile
    {
        GPR74 |= 1u << 3u;
    }

    /**
     * Clear GPR74's SEMC_STOP_REQ bit.
     *
     * SEMC stop request
     */
    inline void clear_GPR74_SEMC_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 3u);
    }

    /**
     * Toggle GPR74's SEMC_STOP_REQ bit.
     *
     * SEMC stop request
     */
    inline void toggle_GPR74_SEMC_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 3u;
    }

    /**
     * Get GPR74's PIT2_STOP_REQ bit.
     *
     * PIT2 stop request
     */
    inline bool get_GPR74_PIT2_STOP_REQ() volatile
    {
        return GPR74 & (1u << 2u);
    }

    /**
     * Set GPR74's PIT2_STOP_REQ bit.
     *
     * PIT2 stop request
     */
    inline void set_GPR74_PIT2_STOP_REQ() volatile
    {
        GPR74 |= 1u << 2u;
    }

    /**
     * Clear GPR74's PIT2_STOP_REQ bit.
     *
     * PIT2 stop request
     */
    inline void clear_GPR74_PIT2_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 2u);
    }

    /**
     * Toggle GPR74's PIT2_STOP_REQ bit.
     *
     * PIT2 stop request
     */
    inline void toggle_GPR74_PIT2_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 2u;
    }

    /**
     * Get GPR74's PIT1_STOP_REQ bit.
     *
     * PIT1 stop request
     */
    inline bool get_GPR74_PIT1_STOP_REQ() volatile
    {
        return GPR74 & (1u << 1u);
    }

    /**
     * Set GPR74's PIT1_STOP_REQ bit.
     *
     * PIT1 stop request
     */
    inline void set_GPR74_PIT1_STOP_REQ() volatile
    {
        GPR74 |= 1u << 1u;
    }

    /**
     * Clear GPR74's PIT1_STOP_REQ bit.
     *
     * PIT1 stop request
     */
    inline void clear_GPR74_PIT1_STOP_REQ() volatile
    {
        GPR74 &= ~(1u << 1u);
    }

    /**
     * Toggle GPR74's PIT1_STOP_REQ bit.
     *
     * PIT1 stop request
     */
    inline void toggle_GPR74_PIT1_STOP_REQ() volatile
    {
        GPR74 ^= 1u << 1u;
    }

    /**
     * Get all of GPR74's bit fields.
     *
     * (read-write) GPR74 General Purpose Register
     */
    inline void get_GPR74(
        IOMUXC_GPR_GPR74_DWP_LOCK &DWP_LOCK, IOMUXC_GPR_GPR74_DWP &DWP,
        bool &FLEXIO2_STOP_REQ_PER, bool &FLEXIO2_STOP_REQ_BUS,
        bool &FLEXIO1_STOP_REQ_PER, bool &FLEXIO1_STOP_REQ_BUS,
        bool &SAI4_STOP_REQ, bool &SAI3_STOP_REQ, bool &SAI2_STOP_REQ,
        bool &SAI1_STOP_REQ, bool &WDOG2_IPG_DOZE, bool &WDOG1_IPG_DOZE,
        bool &SNVS_HP_STOP_REQ, bool &SNVS_HP_IPG_DOZE, bool &SIM2_IPG_DOZE,
        bool &SIM1_IPG_DOZE, bool &SEMC_STOP_REQ, bool &PIT2_STOP_REQ,
        bool &PIT1_STOP_REQ) volatile
    {
        uint32_t curr = GPR74;

        DWP_LOCK = IOMUXC_GPR_GPR74_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_GPR_GPR74_DWP((curr >> 28u) & 0b11u);
        FLEXIO2_STOP_REQ_PER = curr & (1u << 17u);
        FLEXIO2_STOP_REQ_BUS = curr & (1u << 16u);
        FLEXIO1_STOP_REQ_PER = curr & (1u << 15u);
        FLEXIO1_STOP_REQ_BUS = curr & (1u << 14u);
        SAI4_STOP_REQ = curr & (1u << 13u);
        SAI3_STOP_REQ = curr & (1u << 12u);
        SAI2_STOP_REQ = curr & (1u << 11u);
        SAI1_STOP_REQ = curr & (1u << 10u);
        WDOG2_IPG_DOZE = curr & (1u << 9u);
        WDOG1_IPG_DOZE = curr & (1u << 8u);
        SNVS_HP_STOP_REQ = curr & (1u << 7u);
        SNVS_HP_IPG_DOZE = curr & (1u << 6u);
        SIM2_IPG_DOZE = curr & (1u << 5u);
        SIM1_IPG_DOZE = curr & (1u << 4u);
        SEMC_STOP_REQ = curr & (1u << 3u);
        PIT2_STOP_REQ = curr & (1u << 2u);
        PIT1_STOP_REQ = curr & (1u << 1u);
    }

    /**
     * Set all of GPR74's bit fields.
     *
     * (read-write) GPR74 General Purpose Register
     */
    inline void set_GPR74(IOMUXC_GPR_GPR74_DWP_LOCK DWP_LOCK,
                          IOMUXC_GPR_GPR74_DWP DWP, bool FLEXIO2_STOP_REQ_PER,
                          bool FLEXIO2_STOP_REQ_BUS, bool FLEXIO1_STOP_REQ_PER,
                          bool FLEXIO1_STOP_REQ_BUS, bool SAI4_STOP_REQ,
                          bool SAI3_STOP_REQ, bool SAI2_STOP_REQ,
                          bool SAI1_STOP_REQ, bool WDOG2_IPG_DOZE,
                          bool WDOG1_IPG_DOZE, bool SNVS_HP_STOP_REQ,
                          bool SNVS_HP_IPG_DOZE, bool SIM2_IPG_DOZE,
                          bool SIM1_IPG_DOZE, bool SEMC_STOP_REQ,
                          bool PIT2_STOP_REQ, bool PIT1_STOP_REQ) volatile
    {
        uint32_t curr = GPR74;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 17u);
        curr |= (FLEXIO2_STOP_REQ_PER & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (FLEXIO2_STOP_REQ_BUS & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (FLEXIO1_STOP_REQ_PER & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (FLEXIO1_STOP_REQ_BUS & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (SAI4_STOP_REQ & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (SAI3_STOP_REQ & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SAI2_STOP_REQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SAI1_STOP_REQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (WDOG2_IPG_DOZE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (WDOG1_IPG_DOZE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (SNVS_HP_STOP_REQ & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (SNVS_HP_IPG_DOZE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (SIM2_IPG_DOZE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SIM1_IPG_DOZE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SEMC_STOP_REQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PIT2_STOP_REQ & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PIT1_STOP_REQ & 0b1u) << 1u;

        GPR74 = curr;
    }

    /**
     * Get GPR75's LPUART8_STOP_ACK bit.
     *
     * LPUART8 stop acknowledge
     */
    inline bool get_GPR75_LPUART8_STOP_ACK() volatile
    {
        return GPR75 & (1u << 31u);
    }

    /**
     * Get GPR75's LPUART7_STOP_ACK bit.
     *
     * LPUART7 stop acknowledge
     */
    inline bool get_GPR75_LPUART7_STOP_ACK() volatile
    {
        return GPR75 & (1u << 30u);
    }

    /**
     * Get GPR75's LPUART6_STOP_ACK bit.
     *
     * LPUART6 stop acknowledge
     */
    inline bool get_GPR75_LPUART6_STOP_ACK() volatile
    {
        return GPR75 & (1u << 29u);
    }

    /**
     * Get GPR75's LPUART5_STOP_ACK bit.
     *
     * LPUART5 stop acknowledge
     */
    inline bool get_GPR75_LPUART5_STOP_ACK() volatile
    {
        return GPR75 & (1u << 28u);
    }

    /**
     * Get GPR75's LPUART4_STOP_ACK bit.
     *
     * LPUART4 stop acknowledge
     */
    inline bool get_GPR75_LPUART4_STOP_ACK() volatile
    {
        return GPR75 & (1u << 27u);
    }

    /**
     * Get GPR75's LPUART3_STOP_ACK bit.
     *
     * LPUART3 stop acknowledge
     */
    inline bool get_GPR75_LPUART3_STOP_ACK() volatile
    {
        return GPR75 & (1u << 26u);
    }

    /**
     * Get GPR75's LPUART2_STOP_ACK bit.
     *
     * LPUART2 stop acknowledge
     */
    inline bool get_GPR75_LPUART2_STOP_ACK() volatile
    {
        return GPR75 & (1u << 25u);
    }

    /**
     * Get GPR75's LPUART1_STOP_ACK bit.
     *
     * LPUART1 stop acknowledge
     */
    inline bool get_GPR75_LPUART1_STOP_ACK() volatile
    {
        return GPR75 & (1u << 24u);
    }

    /**
     * Get GPR75's LPSPI6_STOP_ACK bit.
     *
     * LPSPI6 stop acknowledge
     */
    inline bool get_GPR75_LPSPI6_STOP_ACK() volatile
    {
        return GPR75 & (1u << 23u);
    }

    /**
     * Get GPR75's LPSPI5_STOP_ACK bit.
     *
     * LPSPI5 stop acknowledge
     */
    inline bool get_GPR75_LPSPI5_STOP_ACK() volatile
    {
        return GPR75 & (1u << 22u);
    }

    /**
     * Get GPR75's LPSPI4_STOP_ACK bit.
     *
     * LPSPI4 stop acknowledge
     */
    inline bool get_GPR75_LPSPI4_STOP_ACK() volatile
    {
        return GPR75 & (1u << 21u);
    }

    /**
     * Get GPR75's LPSPI3_STOP_ACK bit.
     *
     * LPSPI3 stop acknowledge
     */
    inline bool get_GPR75_LPSPI3_STOP_ACK() volatile
    {
        return GPR75 & (1u << 20u);
    }

    /**
     * Get GPR75's LPSPI2_STOP_ACK bit.
     *
     * LPSPI2 stop acknowledge
     */
    inline bool get_GPR75_LPSPI2_STOP_ACK() volatile
    {
        return GPR75 & (1u << 19u);
    }

    /**
     * Get GPR75's LPSPI1_STOP_ACK bit.
     *
     * LPSPI1 stop acknowledge
     */
    inline bool get_GPR75_LPSPI1_STOP_ACK() volatile
    {
        return GPR75 & (1u << 18u);
    }

    /**
     * Get GPR75's LPI2C6_STOP_ACK bit.
     *
     * LPI2C6 stop acknowledge
     */
    inline bool get_GPR75_LPI2C6_STOP_ACK() volatile
    {
        return GPR75 & (1u << 17u);
    }

    /**
     * Get GPR75's LPI2C5_STOP_ACK bit.
     *
     * LPI2C5 stop acknowledge
     */
    inline bool get_GPR75_LPI2C5_STOP_ACK() volatile
    {
        return GPR75 & (1u << 16u);
    }

    /**
     * Get GPR75's LPI2C4_STOP_ACK bit.
     *
     * LPI2C4 stop acknowledge
     */
    inline bool get_GPR75_LPI2C4_STOP_ACK() volatile
    {
        return GPR75 & (1u << 15u);
    }

    /**
     * Get GPR75's LPI2C3_STOP_ACK bit.
     *
     * LPI2C3 stop acknowledge
     */
    inline bool get_GPR75_LPI2C3_STOP_ACK() volatile
    {
        return GPR75 & (1u << 14u);
    }

    /**
     * Get GPR75's LPI2C2_STOP_ACK bit.
     *
     * LPI2C2 stop acknowledge
     */
    inline bool get_GPR75_LPI2C2_STOP_ACK() volatile
    {
        return GPR75 & (1u << 13u);
    }

    /**
     * Get GPR75's LPI2C1_STOP_ACK bit.
     *
     * LPI2C1 stop acknowledge
     */
    inline bool get_GPR75_LPI2C1_STOP_ACK() volatile
    {
        return GPR75 & (1u << 12u);
    }

    /**
     * Get GPR75's FLEXSPI2_STOP_ACK bit.
     *
     * FLEXSPI2 stop acknowledge
     */
    inline bool get_GPR75_FLEXSPI2_STOP_ACK() volatile
    {
        return GPR75 & (1u << 11u);
    }

    /**
     * Get GPR75's FLEXSPI1_STOP_ACK bit.
     *
     * FLEXSPI1 stop acknowledge
     */
    inline bool get_GPR75_FLEXSPI1_STOP_ACK() volatile
    {
        return GPR75 & (1u << 10u);
    }

    /**
     * Get GPR75's ENET1G_STOP_ACK bit.
     *
     * ENET1G stop acknowledge
     */
    inline bool get_GPR75_ENET1G_STOP_ACK() volatile
    {
        return GPR75 & (1u << 9u);
    }

    /**
     * Get GPR75's ENET_STOP_ACK bit.
     *
     * ENET stop acknowledge
     */
    inline bool get_GPR75_ENET_STOP_ACK() volatile
    {
        return GPR75 & (1u << 8u);
    }

    /**
     * Get GPR75's EDMA_LPSR_STOP_ACK bit.
     *
     * EDMA_LPSR stop acknowledge
     */
    inline bool get_GPR75_EDMA_LPSR_STOP_ACK() volatile
    {
        return GPR75 & (1u << 7u);
    }

    /**
     * Get GPR75's EDMA_STOP_ACK bit.
     *
     * EDMA stop acknowledge
     */
    inline bool get_GPR75_EDMA_STOP_ACK() volatile
    {
        return GPR75 & (1u << 6u);
    }

    /**
     * Get GPR75's CAN3_STOP_ACK bit.
     *
     * CAN3 stop acknowledge
     */
    inline bool get_GPR75_CAN3_STOP_ACK() volatile
    {
        return GPR75 & (1u << 5u);
    }

    /**
     * Get GPR75's CAN2_STOP_ACK bit.
     *
     * CAN2 stop acknowledge
     */
    inline bool get_GPR75_CAN2_STOP_ACK() volatile
    {
        return GPR75 & (1u << 4u);
    }

    /**
     * Get GPR75's CAN1_STOP_ACK bit.
     *
     * CAN1 stop acknowledge
     */
    inline bool get_GPR75_CAN1_STOP_ACK() volatile
    {
        return GPR75 & (1u << 3u);
    }

    /**
     * Get GPR75's CAAM_STOP_ACK bit.
     *
     * CAAM stop acknowledge
     */
    inline bool get_GPR75_CAAM_STOP_ACK() volatile
    {
        return GPR75 & (1u << 2u);
    }

    /**
     * Get GPR75's ADC2_STOP_ACK bit.
     *
     * ADC2 stop acknowledge
     */
    inline bool get_GPR75_ADC2_STOP_ACK() volatile
    {
        return GPR75 & (1u << 1u);
    }

    /**
     * Get GPR75's ADC1_STOP_ACK bit.
     *
     * ADC1 stop acknowledge
     */
    inline bool get_GPR75_ADC1_STOP_ACK() volatile
    {
        return GPR75 & (1u << 0u);
    }

    /**
     * Get all of GPR75's bit fields.
     *
     * (read-write) GPR75 General Purpose Register
     */
    inline void get_GPR75(
        bool &LPUART8_STOP_ACK, bool &LPUART7_STOP_ACK, bool &LPUART6_STOP_ACK,
        bool &LPUART5_STOP_ACK, bool &LPUART4_STOP_ACK, bool &LPUART3_STOP_ACK,
        bool &LPUART2_STOP_ACK, bool &LPUART1_STOP_ACK, bool &LPSPI6_STOP_ACK,
        bool &LPSPI5_STOP_ACK, bool &LPSPI4_STOP_ACK, bool &LPSPI3_STOP_ACK,
        bool &LPSPI2_STOP_ACK, bool &LPSPI1_STOP_ACK, bool &LPI2C6_STOP_ACK,
        bool &LPI2C5_STOP_ACK, bool &LPI2C4_STOP_ACK, bool &LPI2C3_STOP_ACK,
        bool &LPI2C2_STOP_ACK, bool &LPI2C1_STOP_ACK, bool &FLEXSPI2_STOP_ACK,
        bool &FLEXSPI1_STOP_ACK, bool &ENET1G_STOP_ACK, bool &ENET_STOP_ACK,
        bool &EDMA_LPSR_STOP_ACK, bool &EDMA_STOP_ACK, bool &CAN3_STOP_ACK,
        bool &CAN2_STOP_ACK, bool &CAN1_STOP_ACK, bool &CAAM_STOP_ACK,
        bool &ADC2_STOP_ACK, bool &ADC1_STOP_ACK) volatile
    {
        uint32_t curr = GPR75;

        LPUART8_STOP_ACK = curr & (1u << 31u);
        LPUART7_STOP_ACK = curr & (1u << 30u);
        LPUART6_STOP_ACK = curr & (1u << 29u);
        LPUART5_STOP_ACK = curr & (1u << 28u);
        LPUART4_STOP_ACK = curr & (1u << 27u);
        LPUART3_STOP_ACK = curr & (1u << 26u);
        LPUART2_STOP_ACK = curr & (1u << 25u);
        LPUART1_STOP_ACK = curr & (1u << 24u);
        LPSPI6_STOP_ACK = curr & (1u << 23u);
        LPSPI5_STOP_ACK = curr & (1u << 22u);
        LPSPI4_STOP_ACK = curr & (1u << 21u);
        LPSPI3_STOP_ACK = curr & (1u << 20u);
        LPSPI2_STOP_ACK = curr & (1u << 19u);
        LPSPI1_STOP_ACK = curr & (1u << 18u);
        LPI2C6_STOP_ACK = curr & (1u << 17u);
        LPI2C5_STOP_ACK = curr & (1u << 16u);
        LPI2C4_STOP_ACK = curr & (1u << 15u);
        LPI2C3_STOP_ACK = curr & (1u << 14u);
        LPI2C2_STOP_ACK = curr & (1u << 13u);
        LPI2C1_STOP_ACK = curr & (1u << 12u);
        FLEXSPI2_STOP_ACK = curr & (1u << 11u);
        FLEXSPI1_STOP_ACK = curr & (1u << 10u);
        ENET1G_STOP_ACK = curr & (1u << 9u);
        ENET_STOP_ACK = curr & (1u << 8u);
        EDMA_LPSR_STOP_ACK = curr & (1u << 7u);
        EDMA_STOP_ACK = curr & (1u << 6u);
        CAN3_STOP_ACK = curr & (1u << 5u);
        CAN2_STOP_ACK = curr & (1u << 4u);
        CAN1_STOP_ACK = curr & (1u << 3u);
        CAAM_STOP_ACK = curr & (1u << 2u);
        ADC2_STOP_ACK = curr & (1u << 1u);
        ADC1_STOP_ACK = curr & (1u << 0u);
    }

    /**
     * Get GPR76's FLEXIO2_STOP_ACK_PER bit.
     *
     * FLEXIO2 stop acknowledge of peripheral clock domain
     */
    inline bool get_GPR76_FLEXIO2_STOP_ACK_PER() volatile
    {
        return GPR76 & (1u << 16u);
    }

    /**
     * Get GPR76's FLEXIO2_STOP_ACK_BUS bit.
     *
     * FLEXIO2 stop acknowledge of bus clock domain
     */
    inline bool get_GPR76_FLEXIO2_STOP_ACK_BUS() volatile
    {
        return GPR76 & (1u << 15u);
    }

    /**
     * Get GPR76's FLEXIO1_STOP_ACK_PER bit.
     *
     * FLEXIO1 stop acknowledge of peripheral clock domain
     */
    inline bool get_GPR76_FLEXIO1_STOP_ACK_PER() volatile
    {
        return GPR76 & (1u << 14u);
    }

    /**
     * Get GPR76's FLEXIO1_STOP_ACK_BUS bit.
     *
     * FLEXIO1 stop acknowledge of bus clock domain
     */
    inline bool get_GPR76_FLEXIO1_STOP_ACK_BUS() volatile
    {
        return GPR76 & (1u << 13u);
    }

    /**
     * Get GPR76's SAI4_STOP_ACK bit.
     *
     * SAI4 stop acknowledge
     */
    inline bool get_GPR76_SAI4_STOP_ACK() volatile
    {
        return GPR76 & (1u << 12u);
    }

    /**
     * Get GPR76's SAI3_STOP_ACK bit.
     *
     * SAI3 stop acknowledge
     */
    inline bool get_GPR76_SAI3_STOP_ACK() volatile
    {
        return GPR76 & (1u << 11u);
    }

    /**
     * Get GPR76's SAI2_STOP_ACK bit.
     *
     * SAI2 stop acknowledge
     */
    inline bool get_GPR76_SAI2_STOP_ACK() volatile
    {
        return GPR76 & (1u << 10u);
    }

    /**
     * Get GPR76's SAI1_STOP_ACK bit.
     *
     * SAI1 stop acknowledge
     */
    inline bool get_GPR76_SAI1_STOP_ACK() volatile
    {
        return GPR76 & (1u << 9u);
    }

    /**
     * Get GPR76's SNVS_HP_STOP_ACK bit.
     *
     * SNVS_HP stop acknowledge
     */
    inline bool get_GPR76_SNVS_HP_STOP_ACK() volatile
    {
        return GPR76 & (1u << 8u);
    }

    /**
     * Get GPR76's SEMC_STOP_ACK bit.
     *
     * SEMC stop acknowledge
     */
    inline bool get_GPR76_SEMC_STOP_ACK() volatile
    {
        return GPR76 & (1u << 7u);
    }

    /**
     * Get GPR76's PIT2_STOP_ACK bit.
     *
     * PIT2 stop acknowledge
     */
    inline bool get_GPR76_PIT2_STOP_ACK() volatile
    {
        return GPR76 & (1u << 6u);
    }

    /**
     * Get GPR76's PIT1_STOP_ACK bit.
     *
     * PIT1 stop acknowledge
     */
    inline bool get_GPR76_PIT1_STOP_ACK() volatile
    {
        return GPR76 & (1u << 5u);
    }

    /**
     * Get GPR76's MIC_STOP_ACK bit.
     *
     * MIC stop acknowledge
     */
    inline bool get_GPR76_MIC_STOP_ACK() volatile
    {
        return GPR76 & (1u << 4u);
    }

    /**
     * Get GPR76's LPUART12_STOP_ACK bit.
     *
     * LPUART12 stop acknowledge
     */
    inline bool get_GPR76_LPUART12_STOP_ACK() volatile
    {
        return GPR76 & (1u << 3u);
    }

    /**
     * Get GPR76's LPUART11_STOP_ACK bit.
     *
     * LPUART11 stop acknowledge
     */
    inline bool get_GPR76_LPUART11_STOP_ACK() volatile
    {
        return GPR76 & (1u << 2u);
    }

    /**
     * Get GPR76's LPUART10_STOP_ACK bit.
     *
     * LPUART10 stop acknowledge
     */
    inline bool get_GPR76_LPUART10_STOP_ACK() volatile
    {
        return GPR76 & (1u << 1u);
    }

    /**
     * Get GPR76's LPUART9_STOP_ACK bit.
     *
     * LPUART9 stop acknowledge
     */
    inline bool get_GPR76_LPUART9_STOP_ACK() volatile
    {
        return GPR76 & (1u << 0u);
    }

    /**
     * Get all of GPR76's bit fields.
     *
     * (read-write) GPR76 General Purpose Register
     */
    inline void get_GPR76(
        bool &FLEXIO2_STOP_ACK_PER, bool &FLEXIO2_STOP_ACK_BUS,
        bool &FLEXIO1_STOP_ACK_PER, bool &FLEXIO1_STOP_ACK_BUS,
        bool &SAI4_STOP_ACK, bool &SAI3_STOP_ACK, bool &SAI2_STOP_ACK,
        bool &SAI1_STOP_ACK, bool &SNVS_HP_STOP_ACK, bool &SEMC_STOP_ACK,
        bool &PIT2_STOP_ACK, bool &PIT1_STOP_ACK, bool &MIC_STOP_ACK,
        bool &LPUART12_STOP_ACK, bool &LPUART11_STOP_ACK,
        bool &LPUART10_STOP_ACK, bool &LPUART9_STOP_ACK) volatile
    {
        uint32_t curr = GPR76;

        FLEXIO2_STOP_ACK_PER = curr & (1u << 16u);
        FLEXIO2_STOP_ACK_BUS = curr & (1u << 15u);
        FLEXIO1_STOP_ACK_PER = curr & (1u << 14u);
        FLEXIO1_STOP_ACK_BUS = curr & (1u << 13u);
        SAI4_STOP_ACK = curr & (1u << 12u);
        SAI3_STOP_ACK = curr & (1u << 11u);
        SAI2_STOP_ACK = curr & (1u << 10u);
        SAI1_STOP_ACK = curr & (1u << 9u);
        SNVS_HP_STOP_ACK = curr & (1u << 8u);
        SEMC_STOP_ACK = curr & (1u << 7u);
        PIT2_STOP_ACK = curr & (1u << 6u);
        PIT1_STOP_ACK = curr & (1u << 5u);
        MIC_STOP_ACK = curr & (1u << 4u);
        LPUART12_STOP_ACK = curr & (1u << 3u);
        LPUART11_STOP_ACK = curr & (1u << 2u);
        LPUART10_STOP_ACK = curr & (1u << 1u);
        LPUART9_STOP_ACK = curr & (1u << 0u);
    }
};

static_assert(sizeof(iomuxc_gpr) == iomuxc_gpr::size);

static volatile iomuxc_gpr *const IOMUXC_GPR =
    reinterpret_cast<iomuxc_gpr *>(0x400E4000);

}; // namespace MIMXRT1176::CM7
