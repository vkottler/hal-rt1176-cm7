/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * Clock root select Registers
 */
struct [[gnu::packed]] CLOCK_ROOT_instance
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        128; /*!< CLOCK_ROOT_instance's size in bytes. */

    /* Fields. */
    uint32_t CLOCK_ROOT_CONTROL;     /*!< (read-write) Clock root control */
    uint32_t CLOCK_ROOT_CONTROL_SET; /*!< (read-write) Clock root control */
    uint32_t CLOCK_ROOT_CONTROL_CLR; /*!< (read-write) Clock root control */
    uint32_t CLOCK_ROOT_CONTROL_TOG; /*!< (read-write) Clock root control */
    static constexpr std::size_t reserved_padding0_length = 4;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t CLOCK_ROOT_STATUS0; /*!< (read-write) Clock root working status */
    uint32_t
        CLOCK_ROOT_STATUS1; /*!< (read-write) Clock root low power status */
    const uint32_t reserved_padding1 = {};
    uint32_t CLOCK_ROOT_CONFIG; /*!< (read-write) Clock root configuration */
    uint32_t CLOCK_ROOT_AUTHEN; /*!< (read-write) Clock root access control */
    uint32_t
        CLOCK_ROOT_AUTHEN_SET; /*!< (read-write) Clock root access control */
    uint32_t
        CLOCK_ROOT_AUTHEN_CLR; /*!< (read-write) Clock root access control */
    uint32_t
        CLOCK_ROOT_AUTHEN_TOG; /*!< (read-write) Clock root access control */
    static constexpr std::size_t CLOCK_ROOT_SETPOINT_length = 16;
    uint32_t
        CLOCK_ROOT_SETPOINT[CLOCK_ROOT_SETPOINT_length]; /*!< (read-write)
                                                            Setpoint setting */

    /* Methods. */

    /**
     * Get CLOCK_ROOT_CONTROL's OFF bit.
     *
     * OFF
     */
    inline bool get_CLOCK_ROOT_CONTROL_OFF()
    {
        return CLOCK_ROOT_CONTROL & (1u << 24u);
    }

    /**
     * Set CLOCK_ROOT_CONTROL's OFF bit.
     *
     * OFF
     */
    inline void set_CLOCK_ROOT_CONTROL_OFF()
    {
        CLOCK_ROOT_CONTROL |= 1u << 24u;
    }

    /**
     * Clear CLOCK_ROOT_CONTROL's OFF bit.
     *
     * OFF
     */
    inline void clear_CLOCK_ROOT_CONTROL_OFF()
    {
        CLOCK_ROOT_CONTROL &= ~(1u << 24u);
    }

    /**
     * Toggle CLOCK_ROOT_CONTROL's OFF bit.
     *
     * OFF
     */
    inline void toggle_CLOCK_ROOT_CONTROL_OFF()
    {
        CLOCK_ROOT_CONTROL ^= 1u << 24u;
    }

    /**
     * Get CLOCK_ROOT_CONTROL's MUX field.
     *
     * Clock multiplexer
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_MUX()
    {
        return (CLOCK_ROOT_CONTROL >> 8u) & 0b111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL's MUX field.
     *
     * Clock multiplexer
     */
    inline void set_CLOCK_ROOT_CONTROL_MUX(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        CLOCK_ROOT_CONTROL = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL's DIV field.
     *
     * Clock divider
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_DIV()
    {
        return (CLOCK_ROOT_CONTROL >> 0u) & 0b11111111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL's DIV field.
     *
     * Clock divider
     */
    inline void set_CLOCK_ROOT_CONTROL_DIV(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL = curr;
    }

    /**
     * Get all of CLOCK_ROOT_CONTROL's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void get_CLOCK_ROOT_CONTROL(bool &OFF, uint8_t &MUX, uint8_t &DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL;

        OFF = curr & (1u << 24u);
        MUX = (curr >> 8u) & 0b111u;
        DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CLOCK_ROOT_CONTROL's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void set_CLOCK_ROOT_CONTROL(bool OFF, uint8_t MUX, uint8_t DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL;

        curr &= ~(0b1u << 24u);
        curr |= (OFF & 0b1u) << 24u;
        curr &= ~(0b111u << 8u);
        curr |= (MUX & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DIV & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_SET's OFF bit.
     *
     * OFF
     */
    inline bool get_CLOCK_ROOT_CONTROL_SET_OFF()
    {
        return CLOCK_ROOT_CONTROL_SET & (1u << 24u);
    }

    /**
     * Set CLOCK_ROOT_CONTROL_SET's OFF bit.
     *
     * OFF
     */
    inline void set_CLOCK_ROOT_CONTROL_SET_OFF()
    {
        CLOCK_ROOT_CONTROL_SET |= 1u << 24u;
    }

    /**
     * Clear CLOCK_ROOT_CONTROL_SET's OFF bit.
     *
     * OFF
     */
    inline void clear_CLOCK_ROOT_CONTROL_SET_OFF()
    {
        CLOCK_ROOT_CONTROL_SET &= ~(1u << 24u);
    }

    /**
     * Toggle CLOCK_ROOT_CONTROL_SET's OFF bit.
     *
     * OFF
     */
    inline void toggle_CLOCK_ROOT_CONTROL_SET_OFF()
    {
        CLOCK_ROOT_CONTROL_SET ^= 1u << 24u;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_SET's MUX field.
     *
     * Clock multiplexer
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_SET_MUX()
    {
        return (CLOCK_ROOT_CONTROL_SET >> 8u) & 0b111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL_SET's MUX field.
     *
     * Clock multiplexer
     */
    inline void set_CLOCK_ROOT_CONTROL_SET_MUX(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_SET;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        CLOCK_ROOT_CONTROL_SET = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_SET's DIV field.
     *
     * Clock divider
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_SET_DIV()
    {
        return (CLOCK_ROOT_CONTROL_SET >> 0u) & 0b11111111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL_SET's DIV field.
     *
     * Clock divider
     */
    inline void set_CLOCK_ROOT_CONTROL_SET_DIV(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_SET;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL_SET = curr;
    }

    /**
     * Get all of CLOCK_ROOT_CONTROL_SET's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void get_CLOCK_ROOT_CONTROL_SET(bool &OFF, uint8_t &MUX,
                                           uint8_t &DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_SET;

        OFF = curr & (1u << 24u);
        MUX = (curr >> 8u) & 0b111u;
        DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CLOCK_ROOT_CONTROL_SET's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void set_CLOCK_ROOT_CONTROL_SET(bool OFF, uint8_t MUX, uint8_t DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_SET;

        curr &= ~(0b1u << 24u);
        curr |= (OFF & 0b1u) << 24u;
        curr &= ~(0b111u << 8u);
        curr |= (MUX & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DIV & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL_SET = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_CLR's OFF bit.
     *
     * OFF
     */
    inline bool get_CLOCK_ROOT_CONTROL_CLR_OFF()
    {
        return CLOCK_ROOT_CONTROL_CLR & (1u << 24u);
    }

    /**
     * Set CLOCK_ROOT_CONTROL_CLR's OFF bit.
     *
     * OFF
     */
    inline void set_CLOCK_ROOT_CONTROL_CLR_OFF()
    {
        CLOCK_ROOT_CONTROL_CLR |= 1u << 24u;
    }

    /**
     * Clear CLOCK_ROOT_CONTROL_CLR's OFF bit.
     *
     * OFF
     */
    inline void clear_CLOCK_ROOT_CONTROL_CLR_OFF()
    {
        CLOCK_ROOT_CONTROL_CLR &= ~(1u << 24u);
    }

    /**
     * Toggle CLOCK_ROOT_CONTROL_CLR's OFF bit.
     *
     * OFF
     */
    inline void toggle_CLOCK_ROOT_CONTROL_CLR_OFF()
    {
        CLOCK_ROOT_CONTROL_CLR ^= 1u << 24u;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_CLR's MUX field.
     *
     * Clock multiplexer
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_CLR_MUX()
    {
        return (CLOCK_ROOT_CONTROL_CLR >> 8u) & 0b111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL_CLR's MUX field.
     *
     * Clock multiplexer
     */
    inline void set_CLOCK_ROOT_CONTROL_CLR_MUX(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_CLR;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        CLOCK_ROOT_CONTROL_CLR = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_CLR's DIV field.
     *
     * Clock divider
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_CLR_DIV()
    {
        return (CLOCK_ROOT_CONTROL_CLR >> 0u) & 0b11111111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL_CLR's DIV field.
     *
     * Clock divider
     */
    inline void set_CLOCK_ROOT_CONTROL_CLR_DIV(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_CLR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL_CLR = curr;
    }

    /**
     * Get all of CLOCK_ROOT_CONTROL_CLR's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void get_CLOCK_ROOT_CONTROL_CLR(bool &OFF, uint8_t &MUX,
                                           uint8_t &DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_CLR;

        OFF = curr & (1u << 24u);
        MUX = (curr >> 8u) & 0b111u;
        DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CLOCK_ROOT_CONTROL_CLR's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void set_CLOCK_ROOT_CONTROL_CLR(bool OFF, uint8_t MUX, uint8_t DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_CLR;

        curr &= ~(0b1u << 24u);
        curr |= (OFF & 0b1u) << 24u;
        curr &= ~(0b111u << 8u);
        curr |= (MUX & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DIV & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL_CLR = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_TOG's OFF bit.
     *
     * OFF
     */
    inline bool get_CLOCK_ROOT_CONTROL_TOG_OFF()
    {
        return CLOCK_ROOT_CONTROL_TOG & (1u << 24u);
    }

    /**
     * Set CLOCK_ROOT_CONTROL_TOG's OFF bit.
     *
     * OFF
     */
    inline void set_CLOCK_ROOT_CONTROL_TOG_OFF()
    {
        CLOCK_ROOT_CONTROL_TOG |= 1u << 24u;
    }

    /**
     * Clear CLOCK_ROOT_CONTROL_TOG's OFF bit.
     *
     * OFF
     */
    inline void clear_CLOCK_ROOT_CONTROL_TOG_OFF()
    {
        CLOCK_ROOT_CONTROL_TOG &= ~(1u << 24u);
    }

    /**
     * Toggle CLOCK_ROOT_CONTROL_TOG's OFF bit.
     *
     * OFF
     */
    inline void toggle_CLOCK_ROOT_CONTROL_TOG_OFF()
    {
        CLOCK_ROOT_CONTROL_TOG ^= 1u << 24u;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_TOG's MUX field.
     *
     * Clock multiplexer
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_TOG_MUX()
    {
        return (CLOCK_ROOT_CONTROL_TOG >> 8u) & 0b111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL_TOG's MUX field.
     *
     * Clock multiplexer
     */
    inline void set_CLOCK_ROOT_CONTROL_TOG_MUX(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_TOG;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        CLOCK_ROOT_CONTROL_TOG = curr;
    }

    /**
     * Get CLOCK_ROOT_CONTROL_TOG's DIV field.
     *
     * Clock divider
     */
    inline uint8_t get_CLOCK_ROOT_CONTROL_TOG_DIV()
    {
        return (CLOCK_ROOT_CONTROL_TOG >> 0u) & 0b11111111u;
    }

    /**
     * Set CLOCK_ROOT_CONTROL_TOG's DIV field.
     *
     * Clock divider
     */
    inline void set_CLOCK_ROOT_CONTROL_TOG_DIV(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_TOG;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL_TOG = curr;
    }

    /**
     * Get all of CLOCK_ROOT_CONTROL_TOG's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void get_CLOCK_ROOT_CONTROL_TOG(bool &OFF, uint8_t &MUX,
                                           uint8_t &DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_TOG;

        OFF = curr & (1u << 24u);
        MUX = (curr >> 8u) & 0b111u;
        DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CLOCK_ROOT_CONTROL_TOG's bit fields.
     *
     * (read-write) Clock root control
     */
    inline void set_CLOCK_ROOT_CONTROL_TOG(bool OFF, uint8_t MUX, uint8_t DIV)
    {
        uint32_t curr = CLOCK_ROOT_CONTROL_TOG;

        curr &= ~(0b1u << 24u);
        curr |= (OFF & 0b1u) << 24u;
        curr &= ~(0b111u << 8u);
        curr |= (MUX & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DIV & 0b11111111u) << 0u;

        CLOCK_ROOT_CONTROL_TOG = curr;
    }

    /**
     * Get CLOCK_ROOT_STATUS0's CHANGING bit.
     *
     * Internal updating in clock root
     */
    inline bool get_CLOCK_ROOT_STATUS0_CHANGING()
    {
        return CLOCK_ROOT_STATUS0 & (1u << 31u);
    }

    /**
     * Get CLOCK_ROOT_STATUS0's UPDATE_REVERSE bit.
     *
     * Internal status synchronization from clock generation logic
     */
    inline bool get_CLOCK_ROOT_STATUS0_UPDATE_REVERSE()
    {
        return CLOCK_ROOT_STATUS0 & (1u << 30u);
    }

    /**
     * Get CLOCK_ROOT_STATUS0's UPDATE_FORWARD bit.
     *
     * Internal status synchronization to clock generation logic
     */
    inline bool get_CLOCK_ROOT_STATUS0_UPDATE_FORWARD()
    {
        return CLOCK_ROOT_STATUS0 & (1u << 29u);
    }

    /**
     * Get CLOCK_ROOT_STATUS0's SLICE_BUSY bit.
     *
     * Internal updating in generation logic
     */
    inline bool get_CLOCK_ROOT_STATUS0_SLICE_BUSY()
    {
        return CLOCK_ROOT_STATUS0 & (1u << 28u);
    }

    /**
     * Get CLOCK_ROOT_STATUS0's POWERDOWN bit.
     *
     * Current clock root POWERDOWN setting
     */
    inline bool get_CLOCK_ROOT_STATUS0_POWERDOWN()
    {
        return CLOCK_ROOT_STATUS0 & (1u << 27u);
    }

    /**
     * Get CLOCK_ROOT_STATUS0's OFF bit.
     *
     * Current clock root OFF setting
     */
    inline bool get_CLOCK_ROOT_STATUS0_OFF()
    {
        return CLOCK_ROOT_STATUS0 & (1u << 24u);
    }

    /**
     * Get CLOCK_ROOT_STATUS0's MUX field.
     *
     * Current clock root MUX setting
     */
    inline uint8_t get_CLOCK_ROOT_STATUS0_MUX()
    {
        return (CLOCK_ROOT_STATUS0 >> 8u) & 0b111u;
    }

    /**
     * Get CLOCK_ROOT_STATUS0's DIV field.
     *
     * Current clock root DIV setting
     */
    inline uint8_t get_CLOCK_ROOT_STATUS0_DIV()
    {
        return (CLOCK_ROOT_STATUS0 >> 0u) & 0b11111111u;
    }

    /**
     * Get all of CLOCK_ROOT_STATUS0's bit fields.
     *
     * (read-write) Clock root working status
     */
    inline void get_CLOCK_ROOT_STATUS0(bool &CHANGING, bool &UPDATE_REVERSE,
                                       bool &UPDATE_FORWARD, bool &SLICE_BUSY,
                                       bool &POWERDOWN, bool &OFF,
                                       uint8_t &MUX, uint8_t &DIV)
    {
        uint32_t curr = CLOCK_ROOT_STATUS0;

        CHANGING = curr & (1u << 31u);
        UPDATE_REVERSE = curr & (1u << 30u);
        UPDATE_FORWARD = curr & (1u << 29u);
        SLICE_BUSY = curr & (1u << 28u);
        POWERDOWN = curr & (1u << 27u);
        OFF = curr & (1u << 24u);
        MUX = (curr >> 8u) & 0b111u;
        DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get CLOCK_ROOT_STATUS1's UP_DONE bit.
     *
     * Clock frequency increase finish
     */
    inline bool get_CLOCK_ROOT_STATUS1_UP_DONE()
    {
        return CLOCK_ROOT_STATUS1 & (1u << 27u);
    }

    /**
     * Get CLOCK_ROOT_STATUS1's UP_REQUEST bit.
     *
     * Clock frequency increase request
     */
    inline bool get_CLOCK_ROOT_STATUS1_UP_REQUEST()
    {
        return CLOCK_ROOT_STATUS1 & (1u << 26u);
    }

    /**
     * Get CLOCK_ROOT_STATUS1's DOWN_DONE bit.
     *
     * Clock frequency decrease finish
     */
    inline bool get_CLOCK_ROOT_STATUS1_DOWN_DONE()
    {
        return CLOCK_ROOT_STATUS1 & (1u << 25u);
    }

    /**
     * Get CLOCK_ROOT_STATUS1's DOWN_REQUEST bit.
     *
     * Clock frequency decrease request
     */
    inline bool get_CLOCK_ROOT_STATUS1_DOWN_REQUEST()
    {
        return CLOCK_ROOT_STATUS1 & (1u << 24u);
    }

    /**
     * Get CLOCK_ROOT_STATUS1's CURRENT_SETPOINT field.
     *
     * Current Setpoint
     */
    inline uint8_t get_CLOCK_ROOT_STATUS1_CURRENT_SETPOINT()
    {
        return (CLOCK_ROOT_STATUS1 >> 20u) & 0b1111u;
    }

    /**
     * Get CLOCK_ROOT_STATUS1's TARGET_SETPOINT field.
     *
     * Target Setpoint
     */
    inline uint8_t get_CLOCK_ROOT_STATUS1_TARGET_SETPOINT()
    {
        return (CLOCK_ROOT_STATUS1 >> 16u) & 0b1111u;
    }

    /**
     * Get all of CLOCK_ROOT_STATUS1's bit fields.
     *
     * (read-write) Clock root low power status
     */
    inline void get_CLOCK_ROOT_STATUS1(bool &UP_DONE, bool &UP_REQUEST,
                                       bool &DOWN_DONE, bool &DOWN_REQUEST,
                                       uint8_t &CURRENT_SETPOINT,
                                       uint8_t &TARGET_SETPOINT)
    {
        uint32_t curr = CLOCK_ROOT_STATUS1;

        UP_DONE = curr & (1u << 27u);
        UP_REQUEST = curr & (1u << 26u);
        DOWN_DONE = curr & (1u << 25u);
        DOWN_REQUEST = curr & (1u << 24u);
        CURRENT_SETPOINT = (curr >> 20u) & 0b1111u;
        TARGET_SETPOINT = (curr >> 16u) & 0b1111u;
    }

    /**
     * Get CLOCK_ROOT_CONFIG's SETPOINT_PRESENT bit.
     *
     * Setpoint present
     */
    inline bool get_CLOCK_ROOT_CONFIG_SETPOINT_PRESENT()
    {
        return CLOCK_ROOT_CONFIG & (1u << 4u);
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline bool get_CLOCK_ROOT_AUTHEN_LOCK_MODE()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 20u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void set_CLOCK_ROOT_AUTHEN_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 20u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void clear_CLOCK_ROOT_AUTHEN_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 20u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 20u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SETPOINT_MODE()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 17u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void set_CLOCK_ROOT_AUTHEN_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 17u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 17u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 17u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline bool get_CLOCK_ROOT_AUTHEN_DOMAIN_MODE()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 16u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void set_CLOCK_ROOT_AUTHEN_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 16u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void clear_CLOCK_ROOT_AUTHEN_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 16u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 16u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline bool get_CLOCK_ROOT_AUTHEN_LOCK_LIST()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 12u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 12u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void clear_CLOCK_ROOT_AUTHEN_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 12u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 12u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's WHITE_LIST field.
     *
     * Whitelist
     */
    inline CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST get_CLOCK_ROOT_AUTHEN_WHITE_LIST()
    {
        return CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST((CLOCK_ROOT_AUTHEN >> 8u) &
                                                0b1111u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's WHITE_LIST field.
     *
     * Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_WHITE_LIST(
        CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST value)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        CLOCK_ROOT_AUTHEN = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline bool get_CLOCK_ROOT_AUTHEN_LOCK_TZ()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 4u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void set_CLOCK_ROOT_AUTHEN_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 4u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void clear_CLOCK_ROOT_AUTHEN_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 4u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 4u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's TZ_NS bit.
     *
     * Non-secure access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TZ_NS()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 1u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void set_CLOCK_ROOT_AUTHEN_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 1u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 1u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 1u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN's TZ_USER bit.
     *
     * User access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TZ_USER()
    {
        return CLOCK_ROOT_AUTHEN & (1u << 0u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN's TZ_USER bit.
     *
     * User access
     */
    inline void set_CLOCK_ROOT_AUTHEN_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN |= 1u << 0u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN's TZ_USER bit.
     *
     * User access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN &= ~(1u << 0u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN's TZ_USER bit.
     *
     * User access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN ^= 1u << 0u;
    }

    /**
     * Get all of CLOCK_ROOT_AUTHEN's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void get_CLOCK_ROOT_AUTHEN(
        bool &LOCK_MODE, bool &SETPOINT_MODE, bool &DOMAIN_MODE,
        bool &LOCK_LIST, CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST &WHITE_LIST,
        bool &LOCK_TZ, bool &TZ_NS, bool &TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN;

        LOCK_MODE = curr & (1u << 20u);
        SETPOINT_MODE = curr & (1u << 17u);
        DOMAIN_MODE = curr & (1u << 16u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST((curr >> 8u) & 0b1111u);
        LOCK_TZ = curr & (1u << 4u);
        TZ_NS = curr & (1u << 1u);
        TZ_USER = curr & (1u << 0u);
    }

    /**
     * Set all of CLOCK_ROOT_AUTHEN's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void set_CLOCK_ROOT_AUTHEN(
        bool LOCK_MODE, bool SETPOINT_MODE, bool DOMAIN_MODE, bool LOCK_LIST,
        CCM_CLOCK_ROOT_AUTHEN_WHITE_LIST WHITE_LIST, bool LOCK_TZ, bool TZ_NS,
        bool TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 17u);
        curr |= (SETPOINT_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DOMAIN_MODE & 0b1u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(WHITE_LIST) & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_TZ & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TZ_NS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TZ_USER & 0b1u) << 0u;

        CLOCK_ROOT_AUTHEN = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_LOCK_MODE()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 20u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 20u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 20u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 20u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_SETPOINT_MODE()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 17u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 17u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 17u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 17u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_DOMAIN_MODE()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 16u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 16u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 16u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 16u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_LOCK_LIST()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 12u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 12u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 12u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 12u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's WHITE_LIST field.
     *
     * Whitelist
     */
    inline uint8_t get_CLOCK_ROOT_AUTHEN_SET_WHITE_LIST()
    {
        return (CLOCK_ROOT_AUTHEN_SET >> 8u) & 0b1111u;
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's WHITE_LIST field.
     *
     * Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_WHITE_LIST(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_SET;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CLOCK_ROOT_AUTHEN_SET = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_LOCK_TZ()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 4u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 4u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 4u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 4u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's TZ_NS bit.
     *
     * Non-secure access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_TZ_NS()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 1u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 1u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 1u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 1u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_SET's TZ_USER bit.
     *
     * User access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_SET_TZ_USER()
    {
        return CLOCK_ROOT_AUTHEN_SET & (1u << 0u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_SET's TZ_USER bit.
     *
     * User access
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_SET |= 1u << 0u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_SET's TZ_USER bit.
     *
     * User access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_SET_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_SET &= ~(1u << 0u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_SET's TZ_USER bit.
     *
     * User access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_SET_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_SET ^= 1u << 0u;
    }

    /**
     * Get all of CLOCK_ROOT_AUTHEN_SET's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void get_CLOCK_ROOT_AUTHEN_SET(bool &LOCK_MODE, bool &SETPOINT_MODE,
                                          bool &DOMAIN_MODE, bool &LOCK_LIST,
                                          uint8_t &WHITE_LIST, bool &LOCK_TZ,
                                          bool &TZ_NS, bool &TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_SET;

        LOCK_MODE = curr & (1u << 20u);
        SETPOINT_MODE = curr & (1u << 17u);
        DOMAIN_MODE = curr & (1u << 16u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_TZ = curr & (1u << 4u);
        TZ_NS = curr & (1u << 1u);
        TZ_USER = curr & (1u << 0u);
    }

    /**
     * Set all of CLOCK_ROOT_AUTHEN_SET's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void set_CLOCK_ROOT_AUTHEN_SET(bool LOCK_MODE, bool SETPOINT_MODE,
                                          bool DOMAIN_MODE, bool LOCK_LIST,
                                          uint8_t WHITE_LIST, bool LOCK_TZ,
                                          bool TZ_NS, bool TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_SET;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 17u);
        curr |= (SETPOINT_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DOMAIN_MODE & 0b1u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_TZ & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TZ_NS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TZ_USER & 0b1u) << 0u;

        CLOCK_ROOT_AUTHEN_SET = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_LOCK_MODE()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 20u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 20u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 20u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_SETPOINT_MODE()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 17u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 17u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 17u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 17u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_DOMAIN_MODE()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 16u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 16u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 16u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 16u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_LOCK_LIST()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 12u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 12u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 12u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's WHITE_LIST field.
     *
     * Whitelist
     */
    inline uint8_t get_CLOCK_ROOT_AUTHEN_CLR_WHITE_LIST()
    {
        return (CLOCK_ROOT_AUTHEN_CLR >> 8u) & 0b1111u;
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's WHITE_LIST field.
     *
     * Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_WHITE_LIST(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_CLR;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CLOCK_ROOT_AUTHEN_CLR = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_LOCK_TZ()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 4u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 4u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 4u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's TZ_NS bit.
     *
     * Non-secure access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_TZ_NS()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 1u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 1u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 1u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_CLR's TZ_USER bit.
     *
     * User access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_CLR_TZ_USER()
    {
        return CLOCK_ROOT_AUTHEN_CLR & (1u << 0u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_CLR's TZ_USER bit.
     *
     * User access
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_CLR |= 1u << 0u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_CLR's TZ_USER bit.
     *
     * User access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_CLR_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_CLR's TZ_USER bit.
     *
     * User access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_CLR_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_CLR ^= 1u << 0u;
    }

    /**
     * Get all of CLOCK_ROOT_AUTHEN_CLR's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void get_CLOCK_ROOT_AUTHEN_CLR(bool &LOCK_MODE, bool &SETPOINT_MODE,
                                          bool &DOMAIN_MODE, bool &LOCK_LIST,
                                          uint8_t &WHITE_LIST, bool &LOCK_TZ,
                                          bool &TZ_NS, bool &TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_CLR;

        LOCK_MODE = curr & (1u << 20u);
        SETPOINT_MODE = curr & (1u << 17u);
        DOMAIN_MODE = curr & (1u << 16u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_TZ = curr & (1u << 4u);
        TZ_NS = curr & (1u << 1u);
        TZ_USER = curr & (1u << 0u);
    }

    /**
     * Set all of CLOCK_ROOT_AUTHEN_CLR's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void set_CLOCK_ROOT_AUTHEN_CLR(bool LOCK_MODE, bool SETPOINT_MODE,
                                          bool DOMAIN_MODE, bool LOCK_LIST,
                                          uint8_t WHITE_LIST, bool LOCK_TZ,
                                          bool TZ_NS, bool TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_CLR;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 17u);
        curr |= (SETPOINT_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DOMAIN_MODE & 0b1u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_TZ & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TZ_NS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TZ_USER & 0b1u) << 0u;

        CLOCK_ROOT_AUTHEN_CLR = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_LOCK_MODE()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 20u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 20u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's LOCK_MODE bit.
     *
     * Lock low power and access mode
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_LOCK_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 20u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_SETPOINT_MODE()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 17u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 17u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 17u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's SETPOINT_MODE bit.
     *
     * Low power and access control by Setpoint
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_SETPOINT_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 17u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_DOMAIN_MODE()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 16u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 16u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 16u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's DOMAIN_MODE bit.
     *
     * Low power and access control by domain
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_DOMAIN_MODE()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 16u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_LOCK_LIST()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 12u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 12u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's LOCK_LIST bit.
     *
     * Lock Whitelist
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_LOCK_LIST()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 12u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's WHITE_LIST field.
     *
     * Whitelist
     */
    inline uint8_t get_CLOCK_ROOT_AUTHEN_TOG_WHITE_LIST()
    {
        return (CLOCK_ROOT_AUTHEN_TOG >> 8u) & 0b1111u;
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's WHITE_LIST field.
     *
     * Whitelist
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_WHITE_LIST(uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_TOG;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CLOCK_ROOT_AUTHEN_TOG = curr;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_LOCK_TZ()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 4u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 4u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's LOCK_TZ bit.
     *
     * Lock truszone setting
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_LOCK_TZ()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 4u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's TZ_NS bit.
     *
     * Non-secure access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_TZ_NS()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 1u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 1u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's TZ_NS bit.
     *
     * Non-secure access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_TZ_NS()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 1u;
    }

    /**
     * Get CLOCK_ROOT_AUTHEN_TOG's TZ_USER bit.
     *
     * User access
     */
    inline bool get_CLOCK_ROOT_AUTHEN_TOG_TZ_USER()
    {
        return CLOCK_ROOT_AUTHEN_TOG & (1u << 0u);
    }

    /**
     * Set CLOCK_ROOT_AUTHEN_TOG's TZ_USER bit.
     *
     * User access
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_TOG |= 1u << 0u;
    }

    /**
     * Clear CLOCK_ROOT_AUTHEN_TOG's TZ_USER bit.
     *
     * User access
     */
    inline void clear_CLOCK_ROOT_AUTHEN_TOG_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle CLOCK_ROOT_AUTHEN_TOG's TZ_USER bit.
     *
     * User access
     */
    inline void toggle_CLOCK_ROOT_AUTHEN_TOG_TZ_USER()
    {
        CLOCK_ROOT_AUTHEN_TOG ^= 1u << 0u;
    }

    /**
     * Get all of CLOCK_ROOT_AUTHEN_TOG's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void get_CLOCK_ROOT_AUTHEN_TOG(bool &LOCK_MODE, bool &SETPOINT_MODE,
                                          bool &DOMAIN_MODE, bool &LOCK_LIST,
                                          uint8_t &WHITE_LIST, bool &LOCK_TZ,
                                          bool &TZ_NS, bool &TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_TOG;

        LOCK_MODE = curr & (1u << 20u);
        SETPOINT_MODE = curr & (1u << 17u);
        DOMAIN_MODE = curr & (1u << 16u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_TZ = curr & (1u << 4u);
        TZ_NS = curr & (1u << 1u);
        TZ_USER = curr & (1u << 0u);
    }

    /**
     * Set all of CLOCK_ROOT_AUTHEN_TOG's bit fields.
     *
     * (read-write) Clock root access control
     */
    inline void set_CLOCK_ROOT_AUTHEN_TOG(bool LOCK_MODE, bool SETPOINT_MODE,
                                          bool DOMAIN_MODE, bool LOCK_LIST,
                                          uint8_t WHITE_LIST, bool LOCK_TZ,
                                          bool TZ_NS, bool TZ_USER)
    {
        uint32_t curr = CLOCK_ROOT_AUTHEN_TOG;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_MODE & 0b1u) << 20u;
        curr &= ~(0b1u << 17u);
        curr |= (SETPOINT_MODE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (DOMAIN_MODE & 0b1u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_TZ & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (TZ_NS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TZ_USER & 0b1u) << 0u;

        CLOCK_ROOT_AUTHEN_TOG = curr;
    }

    /**
     * Get CLOCK_ROOT_SETPOINT's GRADE field.
     *
     * Grade
     */
    inline uint8_t get_CLOCK_ROOT_SETPOINT_GRADE(std::size_t index)
    {
        return (CLOCK_ROOT_SETPOINT[index] >> 28u) & 0b1111u;
    }

    /**
     * Set CLOCK_ROOT_SETPOINT's GRADE field.
     *
     * Grade
     */
    inline void set_CLOCK_ROOT_SETPOINT_GRADE(std::size_t index, uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_SETPOINT[index];

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        CLOCK_ROOT_SETPOINT[index] = curr;
    }

    /**
     * Get CLOCK_ROOT_SETPOINT's OFF bit.
     *
     * OFF
     */
    inline bool get_CLOCK_ROOT_SETPOINT_OFF(std::size_t index)
    {
        return CLOCK_ROOT_SETPOINT[index] & (1u << 24u);
    }

    /**
     * Set CLOCK_ROOT_SETPOINT's OFF bit.
     *
     * OFF
     */
    inline void set_CLOCK_ROOT_SETPOINT_OFF()
    {
        CLOCK_ROOT_SETPOINT |= 1u << 24u;
    }

    /**
     * Clear CLOCK_ROOT_SETPOINT's OFF bit.
     *
     * OFF
     */
    inline void clear_CLOCK_ROOT_SETPOINT_OFF()
    {
        CLOCK_ROOT_SETPOINT &= ~(1u << 24u);
    }

    /**
     * Toggle CLOCK_ROOT_SETPOINT's OFF bit.
     *
     * OFF
     */
    inline void toggle_CLOCK_ROOT_SETPOINT_OFF()
    {
        CLOCK_ROOT_SETPOINT ^= 1u << 24u;
    }

    /**
     * Get CLOCK_ROOT_SETPOINT's MUX field.
     *
     * Clock multiplexer
     */
    inline uint8_t get_CLOCK_ROOT_SETPOINT_MUX(std::size_t index)
    {
        return (CLOCK_ROOT_SETPOINT[index] >> 8u) & 0b111u;
    }

    /**
     * Set CLOCK_ROOT_SETPOINT's MUX field.
     *
     * Clock multiplexer
     */
    inline void set_CLOCK_ROOT_SETPOINT_MUX(std::size_t index, uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_SETPOINT[index];

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        CLOCK_ROOT_SETPOINT[index] = curr;
    }

    /**
     * Get CLOCK_ROOT_SETPOINT's DIV field.
     *
     * Clock divider
     */
    inline uint8_t get_CLOCK_ROOT_SETPOINT_DIV(std::size_t index)
    {
        return (CLOCK_ROOT_SETPOINT[index] >> 0u) & 0b11111111u;
    }

    /**
     * Set CLOCK_ROOT_SETPOINT's DIV field.
     *
     * Clock divider
     */
    inline void set_CLOCK_ROOT_SETPOINT_DIV(std::size_t index, uint8_t value)
    {
        uint32_t curr = CLOCK_ROOT_SETPOINT[index];

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLOCK_ROOT_SETPOINT[index] = curr;
    }

    /**
     * Get all of CLOCK_ROOT_SETPOINT's bit fields.
     *
     * (read-write) Setpoint setting
     */
    inline void get_CLOCK_ROOT_SETPOINT(std::size_t index, uint8_t &GRADE,
                                        bool &OFF, uint8_t &MUX, uint8_t &DIV)
    {
        uint32_t curr = CLOCK_ROOT_SETPOINT[index];

        GRADE = (curr >> 28u) & 0b1111u;
        OFF = curr & (1u << 24u);
        MUX = (curr >> 8u) & 0b111u;
        DIV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CLOCK_ROOT_SETPOINT's bit fields.
     *
     * (read-write) Setpoint setting
     */
    inline void set_CLOCK_ROOT_SETPOINT(std::size_t index, uint8_t GRADE,
                                        bool OFF, uint8_t MUX, uint8_t DIV)
    {
        uint32_t curr = CLOCK_ROOT_SETPOINT[index];

        curr &= ~(0b1111u << 28u);
        curr |= (GRADE & 0b1111u) << 28u;
        curr &= ~(0b1u << 24u);
        curr |= (OFF & 0b1u) << 24u;
        curr &= ~(0b111u << 8u);
        curr |= (MUX & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (DIV & 0b11111111u) << 0u;

        CLOCK_ROOT_SETPOINT[index] = curr;
    }
};

static_assert(sizeof(CLOCK_ROOT_instance) == CLOCK_ROOT_instance::size);

}; // namespace MIMXRT1176::CM7
