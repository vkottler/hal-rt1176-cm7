/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/CSI_CR18_MASK_OPTION.h"
#include "../enums/CSI_CR20_QR_DATA_FORMAT.h"
#include "../enums/CSI_CR2_AFS.h"
#include "../enums/CSI_CR2_BTS.h"
#include "../enums/CSI_CR2_DMA_BURST_TYPE_RFF.h"
#include "../enums/CSI_CR2_DMA_BURST_TYPE_SFF.h"
#include "../enums/CSI_CR2_HSC.h"
#include "../enums/CSI_CR2_LVRM.h"
#include "../enums/CSI_CR2_VSC.h"
#include "../enums/CSI_CR3_RxFF_LEVEL.h"
#include "../enums/CSI_CR3_STATFF_LEVEL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * CSI
 */
struct [[gnu::packed]] csi
{
    /* Constant attributes. */
    static constexpr std::size_t size = 1108; /*!< csi's size in bytes. */

    /* Fields. */
    uint32_t CR1;      /*!< (read-write) CSI Control Register 1 */
    uint32_t CR2;      /*!< (read-write) CSI Control Register 2 */
    uint32_t CR3;      /*!< (read-write) CSI Control Register 3 */
    uint32_t STATFIFO; /*!< (read-write) CSI Statistic FIFO Register */
    uint32_t RFIFO;    /*!< (read-write) CSI RX FIFO Register */
    uint32_t RXCNT;    /*!< (read-write) CSI RX Count Register */
    uint32_t SR;       /*!< (read-write) CSI Status Register */
    const uint32_t reserved_padding0 = {};
    uint32_t DMASA_STATFIFO; /*!< (read-write) CSI DMA Start Address Register -
                                for STATFIFO */
    uint32_t DMATS_STATFIFO; /*!< (read-write) CSI DMA Transfer Size Register -
                                for STATFIFO */
    uint32_t DMASA_FB1; /*!< (read-write) CSI DMA Start Address Register - for
                           Frame Buffer1 */
    uint32_t DMASA_FB2; /*!< (read-write) CSI DMA Transfer Size Register - for
                           Frame Buffer2 */
    uint32_t
        FBUF_PARA; /*!< (read-write) CSI Frame Buffer Parameter Register */
    uint32_t IMAG_PARA; /*!< (read-write) CSI Image Parameter Register */
    static constexpr std::size_t reserved_padding1_length = 4;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CR18; /*!< (read-write) CSI Control Register 18 */
    uint32_t CR19; /*!< (read-write) CSI Control Register 19 */
    uint32_t CR20; /*!< (read-write) CSI Control Register 20 */
    static constexpr std::size_t CR_length = 256;
    uint32_t CR[CR_length]; /*!< (read-write) CSI Control Register */

    /* Methods. */

    /**
     * Get CR1's SWAP16_EN bit.
     *
     * SWAP 16-Bit Enable
     */
    inline bool get_CR1_SWAP16_EN() volatile
    {
        return CR1 & (1u << 31u);
    }

    /**
     * Set CR1's SWAP16_EN bit.
     *
     * SWAP 16-Bit Enable
     */
    inline void set_CR1_SWAP16_EN() volatile
    {
        CR1 |= 1u << 31u;
    }

    /**
     * Clear CR1's SWAP16_EN bit.
     *
     * SWAP 16-Bit Enable
     */
    inline void clear_CR1_SWAP16_EN() volatile
    {
        CR1 &= ~(1u << 31u);
    }

    /**
     * Toggle CR1's SWAP16_EN bit.
     *
     * SWAP 16-Bit Enable
     */
    inline void toggle_CR1_SWAP16_EN() volatile
    {
        CR1 ^= 1u << 31u;
    }

    /**
     * Get CR1's EXT_VSYNC bit.
     *
     * External VSYNC Enable
     */
    inline bool get_CR1_EXT_VSYNC() volatile
    {
        return CR1 & (1u << 30u);
    }

    /**
     * Set CR1's EXT_VSYNC bit.
     *
     * External VSYNC Enable
     */
    inline void set_CR1_EXT_VSYNC() volatile
    {
        CR1 |= 1u << 30u;
    }

    /**
     * Clear CR1's EXT_VSYNC bit.
     *
     * External VSYNC Enable
     */
    inline void clear_CR1_EXT_VSYNC() volatile
    {
        CR1 &= ~(1u << 30u);
    }

    /**
     * Toggle CR1's EXT_VSYNC bit.
     *
     * External VSYNC Enable
     */
    inline void toggle_CR1_EXT_VSYNC() volatile
    {
        CR1 ^= 1u << 30u;
    }

    /**
     * Get CR1's EOF_INT_EN bit.
     *
     * End-of-Frame Interrupt Enable. This bit enables and disables the EOF
     * interrupt.
     */
    inline bool get_CR1_EOF_INT_EN() volatile
    {
        return CR1 & (1u << 29u);
    }

    /**
     * Set CR1's EOF_INT_EN bit.
     *
     * End-of-Frame Interrupt Enable. This bit enables and disables the EOF
     * interrupt.
     */
    inline void set_CR1_EOF_INT_EN() volatile
    {
        CR1 |= 1u << 29u;
    }

    /**
     * Clear CR1's EOF_INT_EN bit.
     *
     * End-of-Frame Interrupt Enable. This bit enables and disables the EOF
     * interrupt.
     */
    inline void clear_CR1_EOF_INT_EN() volatile
    {
        CR1 &= ~(1u << 29u);
    }

    /**
     * Toggle CR1's EOF_INT_EN bit.
     *
     * End-of-Frame Interrupt Enable. This bit enables and disables the EOF
     * interrupt.
     */
    inline void toggle_CR1_EOF_INT_EN() volatile
    {
        CR1 ^= 1u << 29u;
    }

    /**
     * Get CR1's VIDEO_MODE bit.
     *
     * Video mode select. This bit controls the video mode in BT.656 mode and
     * TV decoder input.
     */
    inline bool get_CR1_VIDEO_MODE() volatile
    {
        return CR1 & (1u << 27u);
    }

    /**
     * Set CR1's VIDEO_MODE bit.
     *
     * Video mode select. This bit controls the video mode in BT.656 mode and
     * TV decoder input.
     */
    inline void set_CR1_VIDEO_MODE() volatile
    {
        CR1 |= 1u << 27u;
    }

    /**
     * Clear CR1's VIDEO_MODE bit.
     *
     * Video mode select. This bit controls the video mode in BT.656 mode and
     * TV decoder input.
     */
    inline void clear_CR1_VIDEO_MODE() volatile
    {
        CR1 &= ~(1u << 27u);
    }

    /**
     * Toggle CR1's VIDEO_MODE bit.
     *
     * Video mode select. This bit controls the video mode in BT.656 mode and
     * TV decoder input.
     */
    inline void toggle_CR1_VIDEO_MODE() volatile
    {
        CR1 ^= 1u << 27u;
    }

    /**
     * Get CR1's COF_INT_EN bit.
     *
     * Change Of Image Field (COF) Interrupt Enable
     */
    inline bool get_CR1_COF_INT_EN() volatile
    {
        return CR1 & (1u << 26u);
    }

    /**
     * Set CR1's COF_INT_EN bit.
     *
     * Change Of Image Field (COF) Interrupt Enable
     */
    inline void set_CR1_COF_INT_EN() volatile
    {
        CR1 |= 1u << 26u;
    }

    /**
     * Clear CR1's COF_INT_EN bit.
     *
     * Change Of Image Field (COF) Interrupt Enable
     */
    inline void clear_CR1_COF_INT_EN() volatile
    {
        CR1 &= ~(1u << 26u);
    }

    /**
     * Toggle CR1's COF_INT_EN bit.
     *
     * Change Of Image Field (COF) Interrupt Enable
     */
    inline void toggle_CR1_COF_INT_EN() volatile
    {
        CR1 ^= 1u << 26u;
    }

    /**
     * Get CR1's SF_OR_INTEN bit.
     *
     * STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO
     * overrun interrupt.
     */
    inline bool get_CR1_SF_OR_INTEN() volatile
    {
        return CR1 & (1u << 25u);
    }

    /**
     * Set CR1's SF_OR_INTEN bit.
     *
     * STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO
     * overrun interrupt.
     */
    inline void set_CR1_SF_OR_INTEN() volatile
    {
        CR1 |= 1u << 25u;
    }

    /**
     * Clear CR1's SF_OR_INTEN bit.
     *
     * STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO
     * overrun interrupt.
     */
    inline void clear_CR1_SF_OR_INTEN() volatile
    {
        CR1 &= ~(1u << 25u);
    }

    /**
     * Toggle CR1's SF_OR_INTEN bit.
     *
     * STAT FIFO Overrun Interrupt Enable. This bit enables the STATFIFO
     * overrun interrupt.
     */
    inline void toggle_CR1_SF_OR_INTEN() volatile
    {
        CR1 ^= 1u << 25u;
    }

    /**
     * Get CR1's RF_OR_INTEN bit.
     *
     * RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun
     * interrupt.
     */
    inline bool get_CR1_RF_OR_INTEN() volatile
    {
        return CR1 & (1u << 24u);
    }

    /**
     * Set CR1's RF_OR_INTEN bit.
     *
     * RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun
     * interrupt.
     */
    inline void set_CR1_RF_OR_INTEN() volatile
    {
        CR1 |= 1u << 24u;
    }

    /**
     * Clear CR1's RF_OR_INTEN bit.
     *
     * RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun
     * interrupt.
     */
    inline void clear_CR1_RF_OR_INTEN() volatile
    {
        CR1 &= ~(1u << 24u);
    }

    /**
     * Toggle CR1's RF_OR_INTEN bit.
     *
     * RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun
     * interrupt.
     */
    inline void toggle_CR1_RF_OR_INTEN() volatile
    {
        CR1 ^= 1u << 24u;
    }

    /**
     * Get CR1's SFF_DMA_DONE_INTEN bit.
     *
     * STATFIFO DMA Transfer Done Interrupt Enable
     */
    inline bool get_CR1_SFF_DMA_DONE_INTEN() volatile
    {
        return CR1 & (1u << 22u);
    }

    /**
     * Set CR1's SFF_DMA_DONE_INTEN bit.
     *
     * STATFIFO DMA Transfer Done Interrupt Enable
     */
    inline void set_CR1_SFF_DMA_DONE_INTEN() volatile
    {
        CR1 |= 1u << 22u;
    }

    /**
     * Clear CR1's SFF_DMA_DONE_INTEN bit.
     *
     * STATFIFO DMA Transfer Done Interrupt Enable
     */
    inline void clear_CR1_SFF_DMA_DONE_INTEN() volatile
    {
        CR1 &= ~(1u << 22u);
    }

    /**
     * Toggle CR1's SFF_DMA_DONE_INTEN bit.
     *
     * STATFIFO DMA Transfer Done Interrupt Enable
     */
    inline void toggle_CR1_SFF_DMA_DONE_INTEN() volatile
    {
        CR1 ^= 1u << 22u;
    }

    /**
     * Get CR1's STATFF_INTEN bit.
     *
     * STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO
     * interrupt.
     */
    inline bool get_CR1_STATFF_INTEN() volatile
    {
        return CR1 & (1u << 21u);
    }

    /**
     * Set CR1's STATFF_INTEN bit.
     *
     * STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO
     * interrupt.
     */
    inline void set_CR1_STATFF_INTEN() volatile
    {
        CR1 |= 1u << 21u;
    }

    /**
     * Clear CR1's STATFF_INTEN bit.
     *
     * STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO
     * interrupt.
     */
    inline void clear_CR1_STATFF_INTEN() volatile
    {
        CR1 &= ~(1u << 21u);
    }

    /**
     * Toggle CR1's STATFF_INTEN bit.
     *
     * STATFIFO Full Interrupt Enable. This bit enables the STAT FIFO
     * interrupt.
     */
    inline void toggle_CR1_STATFF_INTEN() volatile
    {
        CR1 ^= 1u << 21u;
    }

    /**
     * Get CR1's FB2_DMA_DONE_INTEN bit.
     *
     * Frame Buffer2 DMA Transfer Done Interrupt Enable
     */
    inline bool get_CR1_FB2_DMA_DONE_INTEN() volatile
    {
        return CR1 & (1u << 20u);
    }

    /**
     * Set CR1's FB2_DMA_DONE_INTEN bit.
     *
     * Frame Buffer2 DMA Transfer Done Interrupt Enable
     */
    inline void set_CR1_FB2_DMA_DONE_INTEN() volatile
    {
        CR1 |= 1u << 20u;
    }

    /**
     * Clear CR1's FB2_DMA_DONE_INTEN bit.
     *
     * Frame Buffer2 DMA Transfer Done Interrupt Enable
     */
    inline void clear_CR1_FB2_DMA_DONE_INTEN() volatile
    {
        CR1 &= ~(1u << 20u);
    }

    /**
     * Toggle CR1's FB2_DMA_DONE_INTEN bit.
     *
     * Frame Buffer2 DMA Transfer Done Interrupt Enable
     */
    inline void toggle_CR1_FB2_DMA_DONE_INTEN() volatile
    {
        CR1 ^= 1u << 20u;
    }

    /**
     * Get CR1's FB1_DMA_DONE_INTEN bit.
     *
     * Frame Buffer1 DMA Transfer Done Interrupt Enable
     */
    inline bool get_CR1_FB1_DMA_DONE_INTEN() volatile
    {
        return CR1 & (1u << 19u);
    }

    /**
     * Set CR1's FB1_DMA_DONE_INTEN bit.
     *
     * Frame Buffer1 DMA Transfer Done Interrupt Enable
     */
    inline void set_CR1_FB1_DMA_DONE_INTEN() volatile
    {
        CR1 |= 1u << 19u;
    }

    /**
     * Clear CR1's FB1_DMA_DONE_INTEN bit.
     *
     * Frame Buffer1 DMA Transfer Done Interrupt Enable
     */
    inline void clear_CR1_FB1_DMA_DONE_INTEN() volatile
    {
        CR1 &= ~(1u << 19u);
    }

    /**
     * Toggle CR1's FB1_DMA_DONE_INTEN bit.
     *
     * Frame Buffer1 DMA Transfer Done Interrupt Enable
     */
    inline void toggle_CR1_FB1_DMA_DONE_INTEN() volatile
    {
        CR1 ^= 1u << 19u;
    }

    /**
     * Get CR1's RXFF_INTEN bit.
     *
     * RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full
     * interrupt.
     */
    inline bool get_CR1_RXFF_INTEN() volatile
    {
        return CR1 & (1u << 18u);
    }

    /**
     * Set CR1's RXFF_INTEN bit.
     *
     * RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full
     * interrupt.
     */
    inline void set_CR1_RXFF_INTEN() volatile
    {
        CR1 |= 1u << 18u;
    }

    /**
     * Clear CR1's RXFF_INTEN bit.
     *
     * RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full
     * interrupt.
     */
    inline void clear_CR1_RXFF_INTEN() volatile
    {
        CR1 &= ~(1u << 18u);
    }

    /**
     * Toggle CR1's RXFF_INTEN bit.
     *
     * RxFIFO Full Interrupt Enable. This bit enables the RxFIFO full
     * interrupt.
     */
    inline void toggle_CR1_RXFF_INTEN() volatile
    {
        CR1 ^= 1u << 18u;
    }

    /**
     * Get CR1's SOF_POL bit.
     *
     * SOF Interrupt Polarity. This bit controls the condition that generates
     * an SOF interrupt.
     */
    inline bool get_CR1_SOF_POL() volatile
    {
        return CR1 & (1u << 17u);
    }

    /**
     * Set CR1's SOF_POL bit.
     *
     * SOF Interrupt Polarity. This bit controls the condition that generates
     * an SOF interrupt.
     */
    inline void set_CR1_SOF_POL() volatile
    {
        CR1 |= 1u << 17u;
    }

    /**
     * Clear CR1's SOF_POL bit.
     *
     * SOF Interrupt Polarity. This bit controls the condition that generates
     * an SOF interrupt.
     */
    inline void clear_CR1_SOF_POL() volatile
    {
        CR1 &= ~(1u << 17u);
    }

    /**
     * Toggle CR1's SOF_POL bit.
     *
     * SOF Interrupt Polarity. This bit controls the condition that generates
     * an SOF interrupt.
     */
    inline void toggle_CR1_SOF_POL() volatile
    {
        CR1 ^= 1u << 17u;
    }

    /**
     * Get CR1's SOF_INTEN bit.
     *
     * Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF
     * interrupt.
     */
    inline bool get_CR1_SOF_INTEN() volatile
    {
        return CR1 & (1u << 16u);
    }

    /**
     * Set CR1's SOF_INTEN bit.
     *
     * Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF
     * interrupt.
     */
    inline void set_CR1_SOF_INTEN() volatile
    {
        CR1 |= 1u << 16u;
    }

    /**
     * Clear CR1's SOF_INTEN bit.
     *
     * Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF
     * interrupt.
     */
    inline void clear_CR1_SOF_INTEN() volatile
    {
        CR1 &= ~(1u << 16u);
    }

    /**
     * Toggle CR1's SOF_INTEN bit.
     *
     * Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF
     * interrupt.
     */
    inline void toggle_CR1_SOF_INTEN() volatile
    {
        CR1 ^= 1u << 16u;
    }

    /**
     * Get CR1's HISTOGRAM_CALC_DONE_IE bit.
     *
     * Histogram Interrupt Enable
     */
    inline bool get_CR1_HISTOGRAM_CALC_DONE_IE() volatile
    {
        return CR1 & (1u << 12u);
    }

    /**
     * Set CR1's HISTOGRAM_CALC_DONE_IE bit.
     *
     * Histogram Interrupt Enable
     */
    inline void set_CR1_HISTOGRAM_CALC_DONE_IE() volatile
    {
        CR1 |= 1u << 12u;
    }

    /**
     * Clear CR1's HISTOGRAM_CALC_DONE_IE bit.
     *
     * Histogram Interrupt Enable
     */
    inline void clear_CR1_HISTOGRAM_CALC_DONE_IE() volatile
    {
        CR1 &= ~(1u << 12u);
    }

    /**
     * Toggle CR1's HISTOGRAM_CALC_DONE_IE bit.
     *
     * Histogram Interrupt Enable
     */
    inline void toggle_CR1_HISTOGRAM_CALC_DONE_IE() volatile
    {
        CR1 ^= 1u << 12u;
    }

    /**
     * Get CR1's HSYNC_POL bit.
     *
     * HSYNC Polarity Select
     */
    inline bool get_CR1_HSYNC_POL() volatile
    {
        return CR1 & (1u << 11u);
    }

    /**
     * Set CR1's HSYNC_POL bit.
     *
     * HSYNC Polarity Select
     */
    inline void set_CR1_HSYNC_POL() volatile
    {
        CR1 |= 1u << 11u;
    }

    /**
     * Clear CR1's HSYNC_POL bit.
     *
     * HSYNC Polarity Select
     */
    inline void clear_CR1_HSYNC_POL() volatile
    {
        CR1 &= ~(1u << 11u);
    }

    /**
     * Toggle CR1's HSYNC_POL bit.
     *
     * HSYNC Polarity Select
     */
    inline void toggle_CR1_HSYNC_POL() volatile
    {
        CR1 ^= 1u << 11u;
    }

    /**
     * Get CR1's CCIR_EN bit.
     *
     * BT.656 Interface Enable. This bit selects the type of interface used.
     */
    inline bool get_CR1_CCIR_EN() volatile
    {
        return CR1 & (1u << 10u);
    }

    /**
     * Set CR1's CCIR_EN bit.
     *
     * BT.656 Interface Enable. This bit selects the type of interface used.
     */
    inline void set_CR1_CCIR_EN() volatile
    {
        CR1 |= 1u << 10u;
    }

    /**
     * Clear CR1's CCIR_EN bit.
     *
     * BT.656 Interface Enable. This bit selects the type of interface used.
     */
    inline void clear_CR1_CCIR_EN() volatile
    {
        CR1 &= ~(1u << 10u);
    }

    /**
     * Toggle CR1's CCIR_EN bit.
     *
     * BT.656 Interface Enable. This bit selects the type of interface used.
     */
    inline void toggle_CR1_CCIR_EN() volatile
    {
        CR1 ^= 1u << 10u;
    }

    /**
     * Get CR1's FCC bit.
     *
     * FIFO Clear Control
     */
    inline bool get_CR1_FCC() volatile
    {
        return CR1 & (1u << 8u);
    }

    /**
     * Set CR1's FCC bit.
     *
     * FIFO Clear Control
     */
    inline void set_CR1_FCC() volatile
    {
        CR1 |= 1u << 8u;
    }

    /**
     * Clear CR1's FCC bit.
     *
     * FIFO Clear Control
     */
    inline void clear_CR1_FCC() volatile
    {
        CR1 &= ~(1u << 8u);
    }

    /**
     * Toggle CR1's FCC bit.
     *
     * FIFO Clear Control
     */
    inline void toggle_CR1_FCC() volatile
    {
        CR1 ^= 1u << 8u;
    }

    /**
     * Get CR1's PACK_DIR bit.
     *
     * Data Packing Direction
     */
    inline bool get_CR1_PACK_DIR() volatile
    {
        return CR1 & (1u << 7u);
    }

    /**
     * Set CR1's PACK_DIR bit.
     *
     * Data Packing Direction
     */
    inline void set_CR1_PACK_DIR() volatile
    {
        CR1 |= 1u << 7u;
    }

    /**
     * Clear CR1's PACK_DIR bit.
     *
     * Data Packing Direction
     */
    inline void clear_CR1_PACK_DIR() volatile
    {
        CR1 &= ~(1u << 7u);
    }

    /**
     * Toggle CR1's PACK_DIR bit.
     *
     * Data Packing Direction
     */
    inline void toggle_CR1_PACK_DIR() volatile
    {
        CR1 ^= 1u << 7u;
    }

    /**
     * Get CR1's CLR_STATFIFO bit.
     *
     * Asynchronous STATFIFO Clear
     */
    inline bool get_CR1_CLR_STATFIFO() volatile
    {
        return CR1 & (1u << 6u);
    }

    /**
     * Set CR1's CLR_STATFIFO bit.
     *
     * Asynchronous STATFIFO Clear
     */
    inline void set_CR1_CLR_STATFIFO() volatile
    {
        CR1 |= 1u << 6u;
    }

    /**
     * Clear CR1's CLR_STATFIFO bit.
     *
     * Asynchronous STATFIFO Clear
     */
    inline void clear_CR1_CLR_STATFIFO() volatile
    {
        CR1 &= ~(1u << 6u);
    }

    /**
     * Toggle CR1's CLR_STATFIFO bit.
     *
     * Asynchronous STATFIFO Clear
     */
    inline void toggle_CR1_CLR_STATFIFO() volatile
    {
        CR1 ^= 1u << 6u;
    }

    /**
     * Get CR1's CLR_RXFIFO bit.
     *
     * Asynchronous RXFIFO Clear
     */
    inline bool get_CR1_CLR_RXFIFO() volatile
    {
        return CR1 & (1u << 5u);
    }

    /**
     * Set CR1's CLR_RXFIFO bit.
     *
     * Asynchronous RXFIFO Clear
     */
    inline void set_CR1_CLR_RXFIFO() volatile
    {
        CR1 |= 1u << 5u;
    }

    /**
     * Clear CR1's CLR_RXFIFO bit.
     *
     * Asynchronous RXFIFO Clear
     */
    inline void clear_CR1_CLR_RXFIFO() volatile
    {
        CR1 &= ~(1u << 5u);
    }

    /**
     * Toggle CR1's CLR_RXFIFO bit.
     *
     * Asynchronous RXFIFO Clear
     */
    inline void toggle_CR1_CLR_RXFIFO() volatile
    {
        CR1 ^= 1u << 5u;
    }

    /**
     * Get CR1's GCLK_MODE bit.
     *
     * Gated Clock Mode Enable
     */
    inline bool get_CR1_GCLK_MODE() volatile
    {
        return CR1 & (1u << 4u);
    }

    /**
     * Set CR1's GCLK_MODE bit.
     *
     * Gated Clock Mode Enable
     */
    inline void set_CR1_GCLK_MODE() volatile
    {
        CR1 |= 1u << 4u;
    }

    /**
     * Clear CR1's GCLK_MODE bit.
     *
     * Gated Clock Mode Enable
     */
    inline void clear_CR1_GCLK_MODE() volatile
    {
        CR1 &= ~(1u << 4u);
    }

    /**
     * Toggle CR1's GCLK_MODE bit.
     *
     * Gated Clock Mode Enable
     */
    inline void toggle_CR1_GCLK_MODE() volatile
    {
        CR1 ^= 1u << 4u;
    }

    /**
     * Get CR1's INV_DATA bit.
     *
     * Invert Data Input. This bit enables or disables internal inverters on
     * the data lines.
     */
    inline bool get_CR1_INV_DATA() volatile
    {
        return CR1 & (1u << 3u);
    }

    /**
     * Set CR1's INV_DATA bit.
     *
     * Invert Data Input. This bit enables or disables internal inverters on
     * the data lines.
     */
    inline void set_CR1_INV_DATA() volatile
    {
        CR1 |= 1u << 3u;
    }

    /**
     * Clear CR1's INV_DATA bit.
     *
     * Invert Data Input. This bit enables or disables internal inverters on
     * the data lines.
     */
    inline void clear_CR1_INV_DATA() volatile
    {
        CR1 &= ~(1u << 3u);
    }

    /**
     * Toggle CR1's INV_DATA bit.
     *
     * Invert Data Input. This bit enables or disables internal inverters on
     * the data lines.
     */
    inline void toggle_CR1_INV_DATA() volatile
    {
        CR1 ^= 1u << 3u;
    }

    /**
     * Get CR1's INV_PCLK bit.
     *
     * Invert Pixel Clock Input
     */
    inline bool get_CR1_INV_PCLK() volatile
    {
        return CR1 & (1u << 2u);
    }

    /**
     * Set CR1's INV_PCLK bit.
     *
     * Invert Pixel Clock Input
     */
    inline void set_CR1_INV_PCLK() volatile
    {
        CR1 |= 1u << 2u;
    }

    /**
     * Clear CR1's INV_PCLK bit.
     *
     * Invert Pixel Clock Input
     */
    inline void clear_CR1_INV_PCLK() volatile
    {
        CR1 &= ~(1u << 2u);
    }

    /**
     * Toggle CR1's INV_PCLK bit.
     *
     * Invert Pixel Clock Input
     */
    inline void toggle_CR1_INV_PCLK() volatile
    {
        CR1 ^= 1u << 2u;
    }

    /**
     * Get CR1's REDGE bit.
     *
     * Valid Pixel Clock Edge Select
     */
    inline bool get_CR1_REDGE() volatile
    {
        return CR1 & (1u << 1u);
    }

    /**
     * Set CR1's REDGE bit.
     *
     * Valid Pixel Clock Edge Select
     */
    inline void set_CR1_REDGE() volatile
    {
        CR1 |= 1u << 1u;
    }

    /**
     * Clear CR1's REDGE bit.
     *
     * Valid Pixel Clock Edge Select
     */
    inline void clear_CR1_REDGE() volatile
    {
        CR1 &= ~(1u << 1u);
    }

    /**
     * Toggle CR1's REDGE bit.
     *
     * Valid Pixel Clock Edge Select
     */
    inline void toggle_CR1_REDGE() volatile
    {
        CR1 ^= 1u << 1u;
    }

    /**
     * Get CR1's PIXEL_BIT bit.
     *
     * Pixel Bit
     */
    inline bool get_CR1_PIXEL_BIT() volatile
    {
        return CR1 & (1u << 0u);
    }

    /**
     * Set CR1's PIXEL_BIT bit.
     *
     * Pixel Bit
     */
    inline void set_CR1_PIXEL_BIT() volatile
    {
        CR1 |= 1u << 0u;
    }

    /**
     * Clear CR1's PIXEL_BIT bit.
     *
     * Pixel Bit
     */
    inline void clear_CR1_PIXEL_BIT() volatile
    {
        CR1 &= ~(1u << 0u);
    }

    /**
     * Toggle CR1's PIXEL_BIT bit.
     *
     * Pixel Bit
     */
    inline void toggle_CR1_PIXEL_BIT() volatile
    {
        CR1 ^= 1u << 0u;
    }

    /**
     * Get all of CR1's bit fields.
     *
     * (read-write) CSI Control Register 1
     */
    inline void get_CR1(bool &SWAP16_EN, bool &EXT_VSYNC, bool &EOF_INT_EN,
                        bool &VIDEO_MODE, bool &COF_INT_EN, bool &SF_OR_INTEN,
                        bool &RF_OR_INTEN, bool &SFF_DMA_DONE_INTEN,
                        bool &STATFF_INTEN, bool &FB2_DMA_DONE_INTEN,
                        bool &FB1_DMA_DONE_INTEN, bool &RXFF_INTEN,
                        bool &SOF_POL, bool &SOF_INTEN,
                        bool &HISTOGRAM_CALC_DONE_IE, bool &HSYNC_POL,
                        bool &CCIR_EN, bool &FCC, bool &PACK_DIR,
                        bool &CLR_STATFIFO, bool &CLR_RXFIFO, bool &GCLK_MODE,
                        bool &INV_DATA, bool &INV_PCLK, bool &REDGE,
                        bool &PIXEL_BIT) volatile
    {
        uint32_t curr = CR1;

        SWAP16_EN = curr & (1u << 31u);
        EXT_VSYNC = curr & (1u << 30u);
        EOF_INT_EN = curr & (1u << 29u);
        VIDEO_MODE = curr & (1u << 27u);
        COF_INT_EN = curr & (1u << 26u);
        SF_OR_INTEN = curr & (1u << 25u);
        RF_OR_INTEN = curr & (1u << 24u);
        SFF_DMA_DONE_INTEN = curr & (1u << 22u);
        STATFF_INTEN = curr & (1u << 21u);
        FB2_DMA_DONE_INTEN = curr & (1u << 20u);
        FB1_DMA_DONE_INTEN = curr & (1u << 19u);
        RXFF_INTEN = curr & (1u << 18u);
        SOF_POL = curr & (1u << 17u);
        SOF_INTEN = curr & (1u << 16u);
        HISTOGRAM_CALC_DONE_IE = curr & (1u << 12u);
        HSYNC_POL = curr & (1u << 11u);
        CCIR_EN = curr & (1u << 10u);
        FCC = curr & (1u << 8u);
        PACK_DIR = curr & (1u << 7u);
        CLR_STATFIFO = curr & (1u << 6u);
        CLR_RXFIFO = curr & (1u << 5u);
        GCLK_MODE = curr & (1u << 4u);
        INV_DATA = curr & (1u << 3u);
        INV_PCLK = curr & (1u << 2u);
        REDGE = curr & (1u << 1u);
        PIXEL_BIT = curr & (1u << 0u);
    }

    /**
     * Set all of CR1's bit fields.
     *
     * (read-write) CSI Control Register 1
     */
    inline void set_CR1(bool SWAP16_EN, bool EXT_VSYNC, bool EOF_INT_EN,
                        bool VIDEO_MODE, bool COF_INT_EN, bool SF_OR_INTEN,
                        bool RF_OR_INTEN, bool SFF_DMA_DONE_INTEN,
                        bool STATFF_INTEN, bool FB2_DMA_DONE_INTEN,
                        bool FB1_DMA_DONE_INTEN, bool RXFF_INTEN, bool SOF_POL,
                        bool SOF_INTEN, bool HISTOGRAM_CALC_DONE_IE,
                        bool HSYNC_POL, bool CCIR_EN, bool FCC, bool PACK_DIR,
                        bool CLR_STATFIFO, bool CLR_RXFIFO, bool GCLK_MODE,
                        bool INV_DATA, bool INV_PCLK, bool REDGE,
                        bool PIXEL_BIT) volatile
    {
        uint32_t curr = CR1;

        curr &= ~(0b1u << 31u);
        curr |= (SWAP16_EN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (EXT_VSYNC & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (EOF_INT_EN & 0b1u) << 29u;
        curr &= ~(0b1u << 27u);
        curr |= (VIDEO_MODE & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (COF_INT_EN & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (SF_OR_INTEN & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RF_OR_INTEN & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (SFF_DMA_DONE_INTEN & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (STATFF_INTEN & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (FB2_DMA_DONE_INTEN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (FB1_DMA_DONE_INTEN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RXFF_INTEN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (SOF_POL & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SOF_INTEN & 0b1u) << 16u;
        curr &= ~(0b1u << 12u);
        curr |= (HISTOGRAM_CALC_DONE_IE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (HSYNC_POL & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (CCIR_EN & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (FCC & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (PACK_DIR & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (CLR_STATFIFO & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CLR_RXFIFO & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (GCLK_MODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (INV_DATA & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (INV_PCLK & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (REDGE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PIXEL_BIT & 0b1u) << 0u;

        CR1 = curr;
    }

    /**
     * Get CR2's DMA_BURST_TYPE_RFF field.
     *
     * Burst Type of DMA Transfer from RxFIFO. Selects the burst type of DMA
     * transfer from RxFIFO.
     */
    inline CSI_CR2_DMA_BURST_TYPE_RFF get_CR2_DMA_BURST_TYPE_RFF() volatile
    {
        return CSI_CR2_DMA_BURST_TYPE_RFF((CR2 >> 30u) & 0b11u);
    }

    /**
     * Set CR2's DMA_BURST_TYPE_RFF field.
     *
     * Burst Type of DMA Transfer from RxFIFO. Selects the burst type of DMA
     * transfer from RxFIFO.
     */
    inline void set_CR2_DMA_BURST_TYPE_RFF(
        CSI_CR2_DMA_BURST_TYPE_RFF value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        CR2 = curr;
    }

    /**
     * Get CR2's DMA_BURST_TYPE_SFF field.
     *
     * Burst Type of DMA Transfer from STATFIFO. Selects the burst type of DMA
     * transfer from STATFIFO.
     */
    inline CSI_CR2_DMA_BURST_TYPE_SFF get_CR2_DMA_BURST_TYPE_SFF() volatile
    {
        return CSI_CR2_DMA_BURST_TYPE_SFF((CR2 >> 28u) & 0b11u);
    }

    /**
     * Set CR2's DMA_BURST_TYPE_SFF field.
     *
     * Burst Type of DMA Transfer from STATFIFO. Selects the burst type of DMA
     * transfer from STATFIFO.
     */
    inline void set_CR2_DMA_BURST_TYPE_SFF(
        CSI_CR2_DMA_BURST_TYPE_SFF value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CR2 = curr;
    }

    /**
     * Get CR2's DRM bit.
     *
     * Double Resolution Mode. Controls size of statistics grid.
     */
    inline bool get_CR2_DRM() volatile
    {
        return CR2 & (1u << 26u);
    }

    /**
     * Set CR2's DRM bit.
     *
     * Double Resolution Mode. Controls size of statistics grid.
     */
    inline void set_CR2_DRM() volatile
    {
        CR2 |= 1u << 26u;
    }

    /**
     * Clear CR2's DRM bit.
     *
     * Double Resolution Mode. Controls size of statistics grid.
     */
    inline void clear_CR2_DRM() volatile
    {
        CR2 &= ~(1u << 26u);
    }

    /**
     * Toggle CR2's DRM bit.
     *
     * Double Resolution Mode. Controls size of statistics grid.
     */
    inline void toggle_CR2_DRM() volatile
    {
        CR2 ^= 1u << 26u;
    }

    /**
     * Get CR2's AFS field.
     *
     * Auto Focus Spread. Selects which green pixels are used for auto-focus.
     */
    inline CSI_CR2_AFS get_CR2_AFS() volatile
    {
        return CSI_CR2_AFS((CR2 >> 24u) & 0b11u);
    }

    /**
     * Set CR2's AFS field.
     *
     * Auto Focus Spread. Selects which green pixels are used for auto-focus.
     */
    inline void set_CR2_AFS(CSI_CR2_AFS value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(value) & 0b11u) << 24u;

        CR2 = curr;
    }

    /**
     * Get CR2's SCE bit.
     *
     * Skip Count Enable
     */
    inline bool get_CR2_SCE() volatile
    {
        return CR2 & (1u << 23u);
    }

    /**
     * Set CR2's SCE bit.
     *
     * Skip Count Enable
     */
    inline void set_CR2_SCE() volatile
    {
        CR2 |= 1u << 23u;
    }

    /**
     * Clear CR2's SCE bit.
     *
     * Skip Count Enable
     */
    inline void clear_CR2_SCE() volatile
    {
        CR2 &= ~(1u << 23u);
    }

    /**
     * Toggle CR2's SCE bit.
     *
     * Skip Count Enable
     */
    inline void toggle_CR2_SCE() volatile
    {
        CR2 ^= 1u << 23u;
    }

    /**
     * Get CR2's BTS field.
     *
     * Bayer Tile Start. Controls the Bayer pattern starting point.
     */
    inline CSI_CR2_BTS get_CR2_BTS() volatile
    {
        return CSI_CR2_BTS((CR2 >> 19u) & 0b11u);
    }

    /**
     * Set CR2's BTS field.
     *
     * Bayer Tile Start. Controls the Bayer pattern starting point.
     */
    inline void set_CR2_BTS(CSI_CR2_BTS value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11u << 19u);
        curr |= (std::to_underlying(value) & 0b11u) << 19u;

        CR2 = curr;
    }

    /**
     * Get CR2's LVRM field.
     *
     * Live View Resolution Mode. Selects the grid size used for live view
     * resolution.
     */
    inline CSI_CR2_LVRM get_CR2_LVRM() volatile
    {
        return CSI_CR2_LVRM((CR2 >> 16u) & 0b111u);
    }

    /**
     * Set CR2's LVRM field.
     *
     * Live View Resolution Mode. Selects the grid size used for live view
     * resolution.
     */
    inline void set_CR2_LVRM(CSI_CR2_LVRM value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        CR2 = curr;
    }

    /**
     * Get CR2's VSC field.
     *
     * Vertical Skip Count. Contains the number of rows to skip. SCE must be 1,
     * otherwise VSC is ignored.
     */
    inline CSI_CR2_VSC get_CR2_VSC() volatile
    {
        return CSI_CR2_VSC((CR2 >> 8u) & 0b11111111u);
    }

    /**
     * Set CR2's VSC field.
     *
     * Vertical Skip Count. Contains the number of rows to skip. SCE must be 1,
     * otherwise VSC is ignored.
     */
    inline void set_CR2_VSC(CSI_CR2_VSC value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        CR2 = curr;
    }

    /**
     * Get CR2's HSC field.
     *
     * Horizontal Skip Count
     */
    inline CSI_CR2_HSC get_CR2_HSC() volatile
    {
        return CSI_CR2_HSC((CR2 >> 0u) & 0b11111111u);
    }

    /**
     * Set CR2's HSC field.
     *
     * Horizontal Skip Count
     */
    inline void set_CR2_HSC(CSI_CR2_HSC value) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11111111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 0u;

        CR2 = curr;
    }

    /**
     * Get all of CR2's bit fields.
     *
     * (read-write) CSI Control Register 2
     */
    inline void get_CR2(CSI_CR2_DMA_BURST_TYPE_RFF &DMA_BURST_TYPE_RFF,
                        CSI_CR2_DMA_BURST_TYPE_SFF &DMA_BURST_TYPE_SFF,
                        bool &DRM, CSI_CR2_AFS &AFS, bool &SCE,
                        CSI_CR2_BTS &BTS, CSI_CR2_LVRM &LVRM, CSI_CR2_VSC &VSC,
                        CSI_CR2_HSC &HSC) volatile
    {
        uint32_t curr = CR2;

        DMA_BURST_TYPE_RFF = CSI_CR2_DMA_BURST_TYPE_RFF((curr >> 30u) & 0b11u);
        DMA_BURST_TYPE_SFF = CSI_CR2_DMA_BURST_TYPE_SFF((curr >> 28u) & 0b11u);
        DRM = curr & (1u << 26u);
        AFS = CSI_CR2_AFS((curr >> 24u) & 0b11u);
        SCE = curr & (1u << 23u);
        BTS = CSI_CR2_BTS((curr >> 19u) & 0b11u);
        LVRM = CSI_CR2_LVRM((curr >> 16u) & 0b111u);
        VSC = CSI_CR2_VSC((curr >> 8u) & 0b11111111u);
        HSC = CSI_CR2_HSC((curr >> 0u) & 0b11111111u);
    }

    /**
     * Set all of CR2's bit fields.
     *
     * (read-write) CSI Control Register 2
     */
    inline void set_CR2(CSI_CR2_DMA_BURST_TYPE_RFF DMA_BURST_TYPE_RFF,
                        CSI_CR2_DMA_BURST_TYPE_SFF DMA_BURST_TYPE_SFF,
                        bool DRM, CSI_CR2_AFS AFS, bool SCE, CSI_CR2_BTS BTS,
                        CSI_CR2_LVRM LVRM, CSI_CR2_VSC VSC,
                        CSI_CR2_HSC HSC) volatile
    {
        uint32_t curr = CR2;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DMA_BURST_TYPE_RFF) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DMA_BURST_TYPE_SFF) & 0b11u) << 28u;
        curr &= ~(0b1u << 26u);
        curr |= (DRM & 0b1u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(AFS) & 0b11u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (SCE & 0b1u) << 23u;
        curr &= ~(0b11u << 19u);
        curr |= (std::to_underlying(BTS) & 0b11u) << 19u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(LVRM) & 0b111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(VSC) & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (std::to_underlying(HSC) & 0b11111111u) << 0u;

        CR2 = curr;
    }

    /**
     * Get CR3's FRMCNT field.
     *
     * Frame Counter
     */
    inline uint16_t get_CR3_FRMCNT() volatile
    {
        return (CR3 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CR3's FRMCNT field.
     *
     * Frame Counter
     */
    inline void set_CR3_FRMCNT(uint16_t value) volatile
    {
        uint32_t curr = CR3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CR3 = curr;
    }

    /**
     * Get CR3's FRMCNT_RST bit.
     *
     * Frame Count Reset. Resets the Frame Counter. (Cleared automatically
     * after reset is done)
     */
    inline bool get_CR3_FRMCNT_RST() volatile
    {
        return CR3 & (1u << 15u);
    }

    /**
     * Set CR3's FRMCNT_RST bit.
     *
     * Frame Count Reset. Resets the Frame Counter. (Cleared automatically
     * after reset is done)
     */
    inline void set_CR3_FRMCNT_RST() volatile
    {
        CR3 |= 1u << 15u;
    }

    /**
     * Clear CR3's FRMCNT_RST bit.
     *
     * Frame Count Reset. Resets the Frame Counter. (Cleared automatically
     * after reset is done)
     */
    inline void clear_CR3_FRMCNT_RST() volatile
    {
        CR3 &= ~(1u << 15u);
    }

    /**
     * Toggle CR3's FRMCNT_RST bit.
     *
     * Frame Count Reset. Resets the Frame Counter. (Cleared automatically
     * after reset is done)
     */
    inline void toggle_CR3_FRMCNT_RST() volatile
    {
        CR3 ^= 1u << 15u;
    }

    /**
     * Get CR3's DMA_REFLASH_RFF bit.
     *
     * Reflash DMA Controller for RxFIFO
     */
    inline bool get_CR3_DMA_REFLASH_RFF() volatile
    {
        return CR3 & (1u << 14u);
    }

    /**
     * Set CR3's DMA_REFLASH_RFF bit.
     *
     * Reflash DMA Controller for RxFIFO
     */
    inline void set_CR3_DMA_REFLASH_RFF() volatile
    {
        CR3 |= 1u << 14u;
    }

    /**
     * Clear CR3's DMA_REFLASH_RFF bit.
     *
     * Reflash DMA Controller for RxFIFO
     */
    inline void clear_CR3_DMA_REFLASH_RFF() volatile
    {
        CR3 &= ~(1u << 14u);
    }

    /**
     * Toggle CR3's DMA_REFLASH_RFF bit.
     *
     * Reflash DMA Controller for RxFIFO
     */
    inline void toggle_CR3_DMA_REFLASH_RFF() volatile
    {
        CR3 ^= 1u << 14u;
    }

    /**
     * Get CR3's DMA_REFLASH_SFF bit.
     *
     * Reflash DMA Controller for STATFIFO
     */
    inline bool get_CR3_DMA_REFLASH_SFF() volatile
    {
        return CR3 & (1u << 13u);
    }

    /**
     * Set CR3's DMA_REFLASH_SFF bit.
     *
     * Reflash DMA Controller for STATFIFO
     */
    inline void set_CR3_DMA_REFLASH_SFF() volatile
    {
        CR3 |= 1u << 13u;
    }

    /**
     * Clear CR3's DMA_REFLASH_SFF bit.
     *
     * Reflash DMA Controller for STATFIFO
     */
    inline void clear_CR3_DMA_REFLASH_SFF() volatile
    {
        CR3 &= ~(1u << 13u);
    }

    /**
     * Toggle CR3's DMA_REFLASH_SFF bit.
     *
     * Reflash DMA Controller for STATFIFO
     */
    inline void toggle_CR3_DMA_REFLASH_SFF() volatile
    {
        CR3 ^= 1u << 13u;
    }

    /**
     * Get CR3's DMA_REQ_EN_RFF bit.
     *
     * DMA Request Enable for RxFIFO
     */
    inline bool get_CR3_DMA_REQ_EN_RFF() volatile
    {
        return CR3 & (1u << 12u);
    }

    /**
     * Set CR3's DMA_REQ_EN_RFF bit.
     *
     * DMA Request Enable for RxFIFO
     */
    inline void set_CR3_DMA_REQ_EN_RFF() volatile
    {
        CR3 |= 1u << 12u;
    }

    /**
     * Clear CR3's DMA_REQ_EN_RFF bit.
     *
     * DMA Request Enable for RxFIFO
     */
    inline void clear_CR3_DMA_REQ_EN_RFF() volatile
    {
        CR3 &= ~(1u << 12u);
    }

    /**
     * Toggle CR3's DMA_REQ_EN_RFF bit.
     *
     * DMA Request Enable for RxFIFO
     */
    inline void toggle_CR3_DMA_REQ_EN_RFF() volatile
    {
        CR3 ^= 1u << 12u;
    }

    /**
     * Get CR3's DMA_REQ_EN_SFF bit.
     *
     * DMA Request Enable for STATFIFO
     */
    inline bool get_CR3_DMA_REQ_EN_SFF() volatile
    {
        return CR3 & (1u << 11u);
    }

    /**
     * Set CR3's DMA_REQ_EN_SFF bit.
     *
     * DMA Request Enable for STATFIFO
     */
    inline void set_CR3_DMA_REQ_EN_SFF() volatile
    {
        CR3 |= 1u << 11u;
    }

    /**
     * Clear CR3's DMA_REQ_EN_SFF bit.
     *
     * DMA Request Enable for STATFIFO
     */
    inline void clear_CR3_DMA_REQ_EN_SFF() volatile
    {
        CR3 &= ~(1u << 11u);
    }

    /**
     * Toggle CR3's DMA_REQ_EN_SFF bit.
     *
     * DMA Request Enable for STATFIFO
     */
    inline void toggle_CR3_DMA_REQ_EN_SFF() volatile
    {
        CR3 ^= 1u << 11u;
    }

    /**
     * Get CR3's STATFF_LEVEL field.
     *
     * STATFIFO Full Level
     */
    inline CSI_CR3_STATFF_LEVEL get_CR3_STATFF_LEVEL() volatile
    {
        return CSI_CR3_STATFF_LEVEL((CR3 >> 8u) & 0b111u);
    }

    /**
     * Set CR3's STATFF_LEVEL field.
     *
     * STATFIFO Full Level
     */
    inline void set_CR3_STATFF_LEVEL(CSI_CR3_STATFF_LEVEL value) volatile
    {
        uint32_t curr = CR3;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CR3 = curr;
    }

    /**
     * Get CR3's HRESP_ERR_EN bit.
     *
     * Hresponse Error Enable. This bit enables the hresponse (AHB protocol
     * standard) error interrupt.
     */
    inline bool get_CR3_HRESP_ERR_EN() volatile
    {
        return CR3 & (1u << 7u);
    }

    /**
     * Set CR3's HRESP_ERR_EN bit.
     *
     * Hresponse Error Enable. This bit enables the hresponse (AHB protocol
     * standard) error interrupt.
     */
    inline void set_CR3_HRESP_ERR_EN() volatile
    {
        CR3 |= 1u << 7u;
    }

    /**
     * Clear CR3's HRESP_ERR_EN bit.
     *
     * Hresponse Error Enable. This bit enables the hresponse (AHB protocol
     * standard) error interrupt.
     */
    inline void clear_CR3_HRESP_ERR_EN() volatile
    {
        CR3 &= ~(1u << 7u);
    }

    /**
     * Toggle CR3's HRESP_ERR_EN bit.
     *
     * Hresponse Error Enable. This bit enables the hresponse (AHB protocol
     * standard) error interrupt.
     */
    inline void toggle_CR3_HRESP_ERR_EN() volatile
    {
        CR3 ^= 1u << 7u;
    }

    /**
     * Get CR3's RxFF_LEVEL field.
     *
     * RxFIFO Full Level
     */
    inline CSI_CR3_RxFF_LEVEL get_CR3_RxFF_LEVEL() volatile
    {
        return CSI_CR3_RxFF_LEVEL((CR3 >> 4u) & 0b111u);
    }

    /**
     * Set CR3's RxFF_LEVEL field.
     *
     * RxFIFO Full Level
     */
    inline void set_CR3_RxFF_LEVEL(CSI_CR3_RxFF_LEVEL value) volatile
    {
        uint32_t curr = CR3;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        CR3 = curr;
    }

    /**
     * Get CR3's SENSOR_16BITS bit.
     *
     * 16-bit Sensor Mode
     */
    inline bool get_CR3_SENSOR_16BITS() volatile
    {
        return CR3 & (1u << 3u);
    }

    /**
     * Set CR3's SENSOR_16BITS bit.
     *
     * 16-bit Sensor Mode
     */
    inline void set_CR3_SENSOR_16BITS() volatile
    {
        CR3 |= 1u << 3u;
    }

    /**
     * Clear CR3's SENSOR_16BITS bit.
     *
     * 16-bit Sensor Mode
     */
    inline void clear_CR3_SENSOR_16BITS() volatile
    {
        CR3 &= ~(1u << 3u);
    }

    /**
     * Toggle CR3's SENSOR_16BITS bit.
     *
     * 16-bit Sensor Mode
     */
    inline void toggle_CR3_SENSOR_16BITS() volatile
    {
        CR3 ^= 1u << 3u;
    }

    /**
     * Get CR3's ZERO_PACK_EN bit.
     *
     * Dummy Zero Packing Enable
     */
    inline bool get_CR3_ZERO_PACK_EN() volatile
    {
        return CR3 & (1u << 2u);
    }

    /**
     * Set CR3's ZERO_PACK_EN bit.
     *
     * Dummy Zero Packing Enable
     */
    inline void set_CR3_ZERO_PACK_EN() volatile
    {
        CR3 |= 1u << 2u;
    }

    /**
     * Clear CR3's ZERO_PACK_EN bit.
     *
     * Dummy Zero Packing Enable
     */
    inline void clear_CR3_ZERO_PACK_EN() volatile
    {
        CR3 &= ~(1u << 2u);
    }

    /**
     * Toggle CR3's ZERO_PACK_EN bit.
     *
     * Dummy Zero Packing Enable
     */
    inline void toggle_CR3_ZERO_PACK_EN() volatile
    {
        CR3 ^= 1u << 2u;
    }

    /**
     * Get CR3's ECC_INT_EN bit.
     *
     * Error Detection Interrupt Enable
     */
    inline bool get_CR3_ECC_INT_EN() volatile
    {
        return CR3 & (1u << 1u);
    }

    /**
     * Set CR3's ECC_INT_EN bit.
     *
     * Error Detection Interrupt Enable
     */
    inline void set_CR3_ECC_INT_EN() volatile
    {
        CR3 |= 1u << 1u;
    }

    /**
     * Clear CR3's ECC_INT_EN bit.
     *
     * Error Detection Interrupt Enable
     */
    inline void clear_CR3_ECC_INT_EN() volatile
    {
        CR3 &= ~(1u << 1u);
    }

    /**
     * Toggle CR3's ECC_INT_EN bit.
     *
     * Error Detection Interrupt Enable
     */
    inline void toggle_CR3_ECC_INT_EN() volatile
    {
        CR3 ^= 1u << 1u;
    }

    /**
     * Get CR3's ECC_AUTO_EN bit.
     *
     * Automatic Error Correction Enable
     */
    inline bool get_CR3_ECC_AUTO_EN() volatile
    {
        return CR3 & (1u << 0u);
    }

    /**
     * Set CR3's ECC_AUTO_EN bit.
     *
     * Automatic Error Correction Enable
     */
    inline void set_CR3_ECC_AUTO_EN() volatile
    {
        CR3 |= 1u << 0u;
    }

    /**
     * Clear CR3's ECC_AUTO_EN bit.
     *
     * Automatic Error Correction Enable
     */
    inline void clear_CR3_ECC_AUTO_EN() volatile
    {
        CR3 &= ~(1u << 0u);
    }

    /**
     * Toggle CR3's ECC_AUTO_EN bit.
     *
     * Automatic Error Correction Enable
     */
    inline void toggle_CR3_ECC_AUTO_EN() volatile
    {
        CR3 ^= 1u << 0u;
    }

    /**
     * Get all of CR3's bit fields.
     *
     * (read-write) CSI Control Register 3
     */
    inline void get_CR3(uint16_t &FRMCNT, bool &FRMCNT_RST,
                        bool &DMA_REFLASH_RFF, bool &DMA_REFLASH_SFF,
                        bool &DMA_REQ_EN_RFF, bool &DMA_REQ_EN_SFF,
                        CSI_CR3_STATFF_LEVEL &STATFF_LEVEL, bool &HRESP_ERR_EN,
                        CSI_CR3_RxFF_LEVEL &RxFF_LEVEL, bool &SENSOR_16BITS,
                        bool &ZERO_PACK_EN, bool &ECC_INT_EN,
                        bool &ECC_AUTO_EN) volatile
    {
        uint32_t curr = CR3;

        FRMCNT = (curr >> 16u) & 0b1111111111111111u;
        FRMCNT_RST = curr & (1u << 15u);
        DMA_REFLASH_RFF = curr & (1u << 14u);
        DMA_REFLASH_SFF = curr & (1u << 13u);
        DMA_REQ_EN_RFF = curr & (1u << 12u);
        DMA_REQ_EN_SFF = curr & (1u << 11u);
        STATFF_LEVEL = CSI_CR3_STATFF_LEVEL((curr >> 8u) & 0b111u);
        HRESP_ERR_EN = curr & (1u << 7u);
        RxFF_LEVEL = CSI_CR3_RxFF_LEVEL((curr >> 4u) & 0b111u);
        SENSOR_16BITS = curr & (1u << 3u);
        ZERO_PACK_EN = curr & (1u << 2u);
        ECC_INT_EN = curr & (1u << 1u);
        ECC_AUTO_EN = curr & (1u << 0u);
    }

    /**
     * Set all of CR3's bit fields.
     *
     * (read-write) CSI Control Register 3
     */
    inline void set_CR3(uint16_t FRMCNT, bool FRMCNT_RST, bool DMA_REFLASH_RFF,
                        bool DMA_REFLASH_SFF, bool DMA_REQ_EN_RFF,
                        bool DMA_REQ_EN_SFF, CSI_CR3_STATFF_LEVEL STATFF_LEVEL,
                        bool HRESP_ERR_EN, CSI_CR3_RxFF_LEVEL RxFF_LEVEL,
                        bool SENSOR_16BITS, bool ZERO_PACK_EN, bool ECC_INT_EN,
                        bool ECC_AUTO_EN) volatile
    {
        uint32_t curr = CR3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (FRMCNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (FRMCNT_RST & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (DMA_REFLASH_RFF & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (DMA_REFLASH_SFF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (DMA_REQ_EN_RFF & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (DMA_REQ_EN_SFF & 0b1u) << 11u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(STATFF_LEVEL) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (HRESP_ERR_EN & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(RxFF_LEVEL) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (SENSOR_16BITS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ZERO_PACK_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ECC_INT_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ECC_AUTO_EN & 0b1u) << 0u;

        CR3 = curr;
    }

    /**
     * Get STATFIFO's STAT field.
     *
     * Static data from sensor
     */
    inline uint32_t get_STATFIFO_STAT() volatile
    {
        return (STATFIFO >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get RFIFO's IMAGE field.
     *
     * Received image data
     */
    inline uint32_t get_RFIFO_IMAGE() volatile
    {
        return (RFIFO >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get RXCNT's RXCNT field.
     *
     * RxFIFO Count
     */
    inline uint32_t get_RXCNT_RXCNT() volatile
    {
        return (RXCNT >> 0u) & 0b1111111111111111111111u;
    }

    /**
     * Set RXCNT's RXCNT field.
     *
     * RxFIFO Count
     */
    inline void set_RXCNT_RXCNT(uint32_t value) volatile
    {
        uint32_t curr = RXCNT;

        curr &= ~(0b1111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111u) << 0u;

        RXCNT = curr;
    }

    /**
     * Get SR's BASEADDR_CHHANGE_ERROR bit.
     *
     * When using base address switching enable, this bit will be 1 when
     * switching occur before DMA complete
     */
    inline bool get_SR_BASEADDR_CHHANGE_ERROR() volatile
    {
        return SR & (1u << 28u);
    }

    /**
     * Set SR's BASEADDR_CHHANGE_ERROR bit.
     *
     * When using base address switching enable, this bit will be 1 when
     * switching occur before DMA complete
     */
    inline void set_SR_BASEADDR_CHHANGE_ERROR() volatile
    {
        SR |= 1u << 28u;
    }

    /**
     * Clear SR's BASEADDR_CHHANGE_ERROR bit.
     *
     * When using base address switching enable, this bit will be 1 when
     * switching occur before DMA complete
     */
    inline void clear_SR_BASEADDR_CHHANGE_ERROR() volatile
    {
        SR &= ~(1u << 28u);
    }

    /**
     * Toggle SR's BASEADDR_CHHANGE_ERROR bit.
     *
     * When using base address switching enable, this bit will be 1 when
     * switching occur before DMA complete
     */
    inline void toggle_SR_BASEADDR_CHHANGE_ERROR() volatile
    {
        SR ^= 1u << 28u;
    }

    /**
     * Get SR's DMA_FIELD0_DONE bit.
     *
     * When DMA field 0 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline bool get_SR_DMA_FIELD0_DONE() volatile
    {
        return SR & (1u << 27u);
    }

    /**
     * Set SR's DMA_FIELD0_DONE bit.
     *
     * When DMA field 0 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline void set_SR_DMA_FIELD0_DONE() volatile
    {
        SR |= 1u << 27u;
    }

    /**
     * Clear SR's DMA_FIELD0_DONE bit.
     *
     * When DMA field 0 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline void clear_SR_DMA_FIELD0_DONE() volatile
    {
        SR &= ~(1u << 27u);
    }

    /**
     * Toggle SR's DMA_FIELD0_DONE bit.
     *
     * When DMA field 0 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline void toggle_SR_DMA_FIELD0_DONE() volatile
    {
        SR ^= 1u << 27u;
    }

    /**
     * Get SR's DMA_FIELD1_DONE bit.
     *
     * When DMA field 1 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline bool get_SR_DMA_FIELD1_DONE() volatile
    {
        return SR & (1u << 26u);
    }

    /**
     * Set SR's DMA_FIELD1_DONE bit.
     *
     * When DMA field 1 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline void set_SR_DMA_FIELD1_DONE() volatile
    {
        SR |= 1u << 26u;
    }

    /**
     * Clear SR's DMA_FIELD1_DONE bit.
     *
     * When DMA field 1 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline void clear_SR_DMA_FIELD1_DONE() volatile
    {
        SR &= ~(1u << 26u);
    }

    /**
     * Toggle SR's DMA_FIELD1_DONE bit.
     *
     * When DMA field 1 is complete, this bit will be set to 1(clear by writing
     * 1).
     */
    inline void toggle_SR_DMA_FIELD1_DONE() volatile
    {
        SR ^= 1u << 26u;
    }

    /**
     * Get SR's SF_OR_INT bit.
     *
     * STATFIFO Overrun Interrupt Status
     */
    inline bool get_SR_SF_OR_INT() volatile
    {
        return SR & (1u << 25u);
    }

    /**
     * Set SR's SF_OR_INT bit.
     *
     * STATFIFO Overrun Interrupt Status
     */
    inline void set_SR_SF_OR_INT() volatile
    {
        SR |= 1u << 25u;
    }

    /**
     * Clear SR's SF_OR_INT bit.
     *
     * STATFIFO Overrun Interrupt Status
     */
    inline void clear_SR_SF_OR_INT() volatile
    {
        SR &= ~(1u << 25u);
    }

    /**
     * Toggle SR's SF_OR_INT bit.
     *
     * STATFIFO Overrun Interrupt Status
     */
    inline void toggle_SR_SF_OR_INT() volatile
    {
        SR ^= 1u << 25u;
    }

    /**
     * Get SR's RF_OR_INT bit.
     *
     * RxFIFO Overrun Interrupt Status
     */
    inline bool get_SR_RF_OR_INT() volatile
    {
        return SR & (1u << 24u);
    }

    /**
     * Set SR's RF_OR_INT bit.
     *
     * RxFIFO Overrun Interrupt Status
     */
    inline void set_SR_RF_OR_INT() volatile
    {
        SR |= 1u << 24u;
    }

    /**
     * Clear SR's RF_OR_INT bit.
     *
     * RxFIFO Overrun Interrupt Status
     */
    inline void clear_SR_RF_OR_INT() volatile
    {
        SR &= ~(1u << 24u);
    }

    /**
     * Toggle SR's RF_OR_INT bit.
     *
     * RxFIFO Overrun Interrupt Status
     */
    inline void toggle_SR_RF_OR_INT() volatile
    {
        SR ^= 1u << 24u;
    }

    /**
     * Get SR's DMA_TSF_DONE_SFF bit.
     *
     * DMA Transfer Done from StatFIFO
     */
    inline bool get_SR_DMA_TSF_DONE_SFF() volatile
    {
        return SR & (1u << 22u);
    }

    /**
     * Set SR's DMA_TSF_DONE_SFF bit.
     *
     * DMA Transfer Done from StatFIFO
     */
    inline void set_SR_DMA_TSF_DONE_SFF() volatile
    {
        SR |= 1u << 22u;
    }

    /**
     * Clear SR's DMA_TSF_DONE_SFF bit.
     *
     * DMA Transfer Done from StatFIFO
     */
    inline void clear_SR_DMA_TSF_DONE_SFF() volatile
    {
        SR &= ~(1u << 22u);
    }

    /**
     * Toggle SR's DMA_TSF_DONE_SFF bit.
     *
     * DMA Transfer Done from StatFIFO
     */
    inline void toggle_SR_DMA_TSF_DONE_SFF() volatile
    {
        SR ^= 1u << 22u;
    }

    /**
     * Get SR's STATFF_INT bit.
     *
     * STATFIFO Full Interrupt Status
     */
    inline bool get_SR_STATFF_INT() volatile
    {
        return SR & (1u << 21u);
    }

    /**
     * Set SR's STATFF_INT bit.
     *
     * STATFIFO Full Interrupt Status
     */
    inline void set_SR_STATFF_INT() volatile
    {
        SR |= 1u << 21u;
    }

    /**
     * Clear SR's STATFF_INT bit.
     *
     * STATFIFO Full Interrupt Status
     */
    inline void clear_SR_STATFF_INT() volatile
    {
        SR &= ~(1u << 21u);
    }

    /**
     * Toggle SR's STATFF_INT bit.
     *
     * STATFIFO Full Interrupt Status
     */
    inline void toggle_SR_STATFF_INT() volatile
    {
        SR ^= 1u << 21u;
    }

    /**
     * Get SR's DMA_TSF_DONE_FB2 bit.
     *
     * DMA Transfer Done in Frame Buffer2
     */
    inline bool get_SR_DMA_TSF_DONE_FB2() volatile
    {
        return SR & (1u << 20u);
    }

    /**
     * Set SR's DMA_TSF_DONE_FB2 bit.
     *
     * DMA Transfer Done in Frame Buffer2
     */
    inline void set_SR_DMA_TSF_DONE_FB2() volatile
    {
        SR |= 1u << 20u;
    }

    /**
     * Clear SR's DMA_TSF_DONE_FB2 bit.
     *
     * DMA Transfer Done in Frame Buffer2
     */
    inline void clear_SR_DMA_TSF_DONE_FB2() volatile
    {
        SR &= ~(1u << 20u);
    }

    /**
     * Toggle SR's DMA_TSF_DONE_FB2 bit.
     *
     * DMA Transfer Done in Frame Buffer2
     */
    inline void toggle_SR_DMA_TSF_DONE_FB2() volatile
    {
        SR ^= 1u << 20u;
    }

    /**
     * Get SR's DMA_TSF_DONE_FB1 bit.
     *
     * DMA Transfer Done in Frame Buffer1
     */
    inline bool get_SR_DMA_TSF_DONE_FB1() volatile
    {
        return SR & (1u << 19u);
    }

    /**
     * Set SR's DMA_TSF_DONE_FB1 bit.
     *
     * DMA Transfer Done in Frame Buffer1
     */
    inline void set_SR_DMA_TSF_DONE_FB1() volatile
    {
        SR |= 1u << 19u;
    }

    /**
     * Clear SR's DMA_TSF_DONE_FB1 bit.
     *
     * DMA Transfer Done in Frame Buffer1
     */
    inline void clear_SR_DMA_TSF_DONE_FB1() volatile
    {
        SR &= ~(1u << 19u);
    }

    /**
     * Toggle SR's DMA_TSF_DONE_FB1 bit.
     *
     * DMA Transfer Done in Frame Buffer1
     */
    inline void toggle_SR_DMA_TSF_DONE_FB1() volatile
    {
        SR ^= 1u << 19u;
    }

    /**
     * Get SR's RxFF_INT bit.
     *
     * RXFIFO Full Interrupt Status
     */
    inline bool get_SR_RxFF_INT() volatile
    {
        return SR & (1u << 18u);
    }

    /**
     * Set SR's RxFF_INT bit.
     *
     * RXFIFO Full Interrupt Status
     */
    inline void set_SR_RxFF_INT() volatile
    {
        SR |= 1u << 18u;
    }

    /**
     * Clear SR's RxFF_INT bit.
     *
     * RXFIFO Full Interrupt Status
     */
    inline void clear_SR_RxFF_INT() volatile
    {
        SR &= ~(1u << 18u);
    }

    /**
     * Toggle SR's RxFF_INT bit.
     *
     * RXFIFO Full Interrupt Status
     */
    inline void toggle_SR_RxFF_INT() volatile
    {
        SR ^= 1u << 18u;
    }

    /**
     * Get SR's EOF_INT bit.
     *
     * End of Frame (EOF) Interrupt Status. Indicates when EOF is detected.
     * (Cleared by writing 1)
     */
    inline bool get_SR_EOF_INT() volatile
    {
        return SR & (1u << 17u);
    }

    /**
     * Set SR's EOF_INT bit.
     *
     * End of Frame (EOF) Interrupt Status. Indicates when EOF is detected.
     * (Cleared by writing 1)
     */
    inline void set_SR_EOF_INT() volatile
    {
        SR |= 1u << 17u;
    }

    /**
     * Clear SR's EOF_INT bit.
     *
     * End of Frame (EOF) Interrupt Status. Indicates when EOF is detected.
     * (Cleared by writing 1)
     */
    inline void clear_SR_EOF_INT() volatile
    {
        SR &= ~(1u << 17u);
    }

    /**
     * Toggle SR's EOF_INT bit.
     *
     * End of Frame (EOF) Interrupt Status. Indicates when EOF is detected.
     * (Cleared by writing 1)
     */
    inline void toggle_SR_EOF_INT() volatile
    {
        SR ^= 1u << 17u;
    }

    /**
     * Get SR's SOF_INT bit.
     *
     * Start of Frame Interrupt Status. Indicates when SOF is detected.
     * (Cleared by writing 1)
     */
    inline bool get_SR_SOF_INT() volatile
    {
        return SR & (1u << 16u);
    }

    /**
     * Set SR's SOF_INT bit.
     *
     * Start of Frame Interrupt Status. Indicates when SOF is detected.
     * (Cleared by writing 1)
     */
    inline void set_SR_SOF_INT() volatile
    {
        SR |= 1u << 16u;
    }

    /**
     * Clear SR's SOF_INT bit.
     *
     * Start of Frame Interrupt Status. Indicates when SOF is detected.
     * (Cleared by writing 1)
     */
    inline void clear_SR_SOF_INT() volatile
    {
        SR &= ~(1u << 16u);
    }

    /**
     * Toggle SR's SOF_INT bit.
     *
     * Start of Frame Interrupt Status. Indicates when SOF is detected.
     * (Cleared by writing 1)
     */
    inline void toggle_SR_SOF_INT() volatile
    {
        SR ^= 1u << 16u;
    }

    /**
     * Get SR's F2_INT bit.
     *
     * BT
     */
    inline bool get_SR_F2_INT() volatile
    {
        return SR & (1u << 15u);
    }

    /**
     * Set SR's F2_INT bit.
     *
     * BT
     */
    inline void set_SR_F2_INT() volatile
    {
        SR |= 1u << 15u;
    }

    /**
     * Clear SR's F2_INT bit.
     *
     * BT
     */
    inline void clear_SR_F2_INT() volatile
    {
        SR &= ~(1u << 15u);
    }

    /**
     * Toggle SR's F2_INT bit.
     *
     * BT
     */
    inline void toggle_SR_F2_INT() volatile
    {
        SR ^= 1u << 15u;
    }

    /**
     * Get SR's F1_INT bit.
     *
     * BT
     */
    inline bool get_SR_F1_INT() volatile
    {
        return SR & (1u << 14u);
    }

    /**
     * Set SR's F1_INT bit.
     *
     * BT
     */
    inline void set_SR_F1_INT() volatile
    {
        SR |= 1u << 14u;
    }

    /**
     * Clear SR's F1_INT bit.
     *
     * BT
     */
    inline void clear_SR_F1_INT() volatile
    {
        SR &= ~(1u << 14u);
    }

    /**
     * Toggle SR's F1_INT bit.
     *
     * BT
     */
    inline void toggle_SR_F1_INT() volatile
    {
        SR ^= 1u << 14u;
    }

    /**
     * Get SR's COF_INT bit.
     *
     * Change Of Field Interrupt Status
     */
    inline bool get_SR_COF_INT() volatile
    {
        return SR & (1u << 13u);
    }

    /**
     * Set SR's COF_INT bit.
     *
     * Change Of Field Interrupt Status
     */
    inline void set_SR_COF_INT() volatile
    {
        SR |= 1u << 13u;
    }

    /**
     * Clear SR's COF_INT bit.
     *
     * Change Of Field Interrupt Status
     */
    inline void clear_SR_COF_INT() volatile
    {
        SR &= ~(1u << 13u);
    }

    /**
     * Toggle SR's COF_INT bit.
     *
     * Change Of Field Interrupt Status
     */
    inline void toggle_SR_COF_INT() volatile
    {
        SR ^= 1u << 13u;
    }

    /**
     * Get SR's HRESP_ERR_INT bit.
     *
     * Hresponse Error Interrupt Status
     */
    inline bool get_SR_HRESP_ERR_INT() volatile
    {
        return SR & (1u << 7u);
    }

    /**
     * Set SR's HRESP_ERR_INT bit.
     *
     * Hresponse Error Interrupt Status
     */
    inline void set_SR_HRESP_ERR_INT() volatile
    {
        SR |= 1u << 7u;
    }

    /**
     * Clear SR's HRESP_ERR_INT bit.
     *
     * Hresponse Error Interrupt Status
     */
    inline void clear_SR_HRESP_ERR_INT() volatile
    {
        SR &= ~(1u << 7u);
    }

    /**
     * Toggle SR's HRESP_ERR_INT bit.
     *
     * Hresponse Error Interrupt Status
     */
    inline void toggle_SR_HRESP_ERR_INT() volatile
    {
        SR ^= 1u << 7u;
    }

    /**
     * Get SR's HISTOGRAM_CALC_DONE_INT bit.
     *
     * no description available
     */
    inline bool get_SR_HISTOGRAM_CALC_DONE_INT() volatile
    {
        return SR & (1u << 2u);
    }

    /**
     * Set SR's HISTOGRAM_CALC_DONE_INT bit.
     *
     * no description available
     */
    inline void set_SR_HISTOGRAM_CALC_DONE_INT() volatile
    {
        SR |= 1u << 2u;
    }

    /**
     * Clear SR's HISTOGRAM_CALC_DONE_INT bit.
     *
     * no description available
     */
    inline void clear_SR_HISTOGRAM_CALC_DONE_INT() volatile
    {
        SR &= ~(1u << 2u);
    }

    /**
     * Toggle SR's HISTOGRAM_CALC_DONE_INT bit.
     *
     * no description available
     */
    inline void toggle_SR_HISTOGRAM_CALC_DONE_INT() volatile
    {
        SR ^= 1u << 2u;
    }

    /**
     * Get SR's ECC_INT bit.
     *
     * BT
     */
    inline bool get_SR_ECC_INT() volatile
    {
        return SR & (1u << 1u);
    }

    /**
     * Set SR's ECC_INT bit.
     *
     * BT
     */
    inline void set_SR_ECC_INT() volatile
    {
        SR |= 1u << 1u;
    }

    /**
     * Clear SR's ECC_INT bit.
     *
     * BT
     */
    inline void clear_SR_ECC_INT() volatile
    {
        SR &= ~(1u << 1u);
    }

    /**
     * Toggle SR's ECC_INT bit.
     *
     * BT
     */
    inline void toggle_SR_ECC_INT() volatile
    {
        SR ^= 1u << 1u;
    }

    /**
     * Get SR's DRDY bit.
     *
     * RXFIFO Data Ready
     */
    inline bool get_SR_DRDY() volatile
    {
        return SR & (1u << 0u);
    }

    /**
     * Set SR's DRDY bit.
     *
     * RXFIFO Data Ready
     */
    inline void set_SR_DRDY() volatile
    {
        SR |= 1u << 0u;
    }

    /**
     * Clear SR's DRDY bit.
     *
     * RXFIFO Data Ready
     */
    inline void clear_SR_DRDY() volatile
    {
        SR &= ~(1u << 0u);
    }

    /**
     * Toggle SR's DRDY bit.
     *
     * RXFIFO Data Ready
     */
    inline void toggle_SR_DRDY() volatile
    {
        SR ^= 1u << 0u;
    }

    /**
     * Get all of SR's bit fields.
     *
     * (read-write) CSI Status Register
     */
    inline void get_SR(bool &BASEADDR_CHHANGE_ERROR, bool &DMA_FIELD0_DONE,
                       bool &DMA_FIELD1_DONE, bool &SF_OR_INT, bool &RF_OR_INT,
                       bool &DMA_TSF_DONE_SFF, bool &STATFF_INT,
                       bool &DMA_TSF_DONE_FB2, bool &DMA_TSF_DONE_FB1,
                       bool &RxFF_INT, bool &EOF_INT, bool &SOF_INT,
                       bool &F2_INT, bool &F1_INT, bool &COF_INT,
                       bool &HRESP_ERR_INT, bool &HISTOGRAM_CALC_DONE_INT,
                       bool &ECC_INT, bool &DRDY) volatile
    {
        uint32_t curr = SR;

        BASEADDR_CHHANGE_ERROR = curr & (1u << 28u);
        DMA_FIELD0_DONE = curr & (1u << 27u);
        DMA_FIELD1_DONE = curr & (1u << 26u);
        SF_OR_INT = curr & (1u << 25u);
        RF_OR_INT = curr & (1u << 24u);
        DMA_TSF_DONE_SFF = curr & (1u << 22u);
        STATFF_INT = curr & (1u << 21u);
        DMA_TSF_DONE_FB2 = curr & (1u << 20u);
        DMA_TSF_DONE_FB1 = curr & (1u << 19u);
        RxFF_INT = curr & (1u << 18u);
        EOF_INT = curr & (1u << 17u);
        SOF_INT = curr & (1u << 16u);
        F2_INT = curr & (1u << 15u);
        F1_INT = curr & (1u << 14u);
        COF_INT = curr & (1u << 13u);
        HRESP_ERR_INT = curr & (1u << 7u);
        HISTOGRAM_CALC_DONE_INT = curr & (1u << 2u);
        ECC_INT = curr & (1u << 1u);
        DRDY = curr & (1u << 0u);
    }

    /**
     * Set all of SR's bit fields.
     *
     * (read-write) CSI Status Register
     */
    inline void set_SR(bool BASEADDR_CHHANGE_ERROR, bool DMA_FIELD0_DONE,
                       bool DMA_FIELD1_DONE, bool SF_OR_INT, bool RF_OR_INT,
                       bool DMA_TSF_DONE_SFF, bool STATFF_INT,
                       bool DMA_TSF_DONE_FB2, bool DMA_TSF_DONE_FB1,
                       bool RxFF_INT, bool EOF_INT, bool SOF_INT, bool F2_INT,
                       bool F1_INT, bool COF_INT, bool HRESP_ERR_INT,
                       bool HISTOGRAM_CALC_DONE_INT, bool ECC_INT,
                       bool DRDY) volatile
    {
        uint32_t curr = SR;

        curr &= ~(0b1u << 28u);
        curr |= (BASEADDR_CHHANGE_ERROR & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (DMA_FIELD0_DONE & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (DMA_FIELD1_DONE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (SF_OR_INT & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RF_OR_INT & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (DMA_TSF_DONE_SFF & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (STATFF_INT & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (DMA_TSF_DONE_FB2 & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (DMA_TSF_DONE_FB1 & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RxFF_INT & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (EOF_INT & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SOF_INT & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (F2_INT & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (F1_INT & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (COF_INT & 0b1u) << 13u;
        curr &= ~(0b1u << 7u);
        curr |= (HRESP_ERR_INT & 0b1u) << 7u;
        curr &= ~(0b1u << 2u);
        curr |= (HISTOGRAM_CALC_DONE_INT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ECC_INT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DRDY & 0b1u) << 0u;

        SR = curr;
    }

    /**
     * Get DMASA_STATFIFO's DMA_START_ADDR_SFF field.
     *
     * DMA Start Address for STATFIFO
     */
    inline uint32_t get_DMASA_STATFIFO_DMA_START_ADDR_SFF() volatile
    {
        return (DMASA_STATFIFO >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DMASA_STATFIFO's DMA_START_ADDR_SFF field.
     *
     * DMA Start Address for STATFIFO
     */
    inline void set_DMASA_STATFIFO_DMA_START_ADDR_SFF(uint32_t value) volatile
    {
        uint32_t curr = DMASA_STATFIFO;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        DMASA_STATFIFO = curr;
    }

    /**
     * Get DMATS_STATFIFO's DMA_TSF_SIZE_SFF field.
     *
     * DMA Transfer Size for STATFIFO
     */
    inline uint32_t get_DMATS_STATFIFO_DMA_TSF_SIZE_SFF() volatile
    {
        return (DMATS_STATFIFO >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set DMATS_STATFIFO's DMA_TSF_SIZE_SFF field.
     *
     * DMA Transfer Size for STATFIFO
     */
    inline void set_DMATS_STATFIFO_DMA_TSF_SIZE_SFF(uint32_t value) volatile
    {
        uint32_t curr = DMATS_STATFIFO;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DMATS_STATFIFO = curr;
    }

    /**
     * Get DMASA_FB1's DMA_START_ADDR_FB1 field.
     *
     * DMA Start Address in Frame Buffer1
     */
    inline uint32_t get_DMASA_FB1_DMA_START_ADDR_FB1() volatile
    {
        return (DMASA_FB1 >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DMASA_FB1's DMA_START_ADDR_FB1 field.
     *
     * DMA Start Address in Frame Buffer1
     */
    inline void set_DMASA_FB1_DMA_START_ADDR_FB1(uint32_t value) volatile
    {
        uint32_t curr = DMASA_FB1;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        DMASA_FB1 = curr;
    }

    /**
     * Get DMASA_FB2's DMA_START_ADDR_FB2 field.
     *
     * DMA Start Address in Frame Buffer2
     */
    inline uint32_t get_DMASA_FB2_DMA_START_ADDR_FB2() volatile
    {
        return (DMASA_FB2 >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set DMASA_FB2's DMA_START_ADDR_FB2 field.
     *
     * DMA Start Address in Frame Buffer2
     */
    inline void set_DMASA_FB2_DMA_START_ADDR_FB2(uint32_t value) volatile
    {
        uint32_t curr = DMASA_FB2;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        DMASA_FB2 = curr;
    }

    /**
     * Get FBUF_PARA's DEINTERLACE_STRIDE field.
     *
     * DEINTERLACE_STRIDE is only used in the deinterlace mode
     */
    inline uint16_t get_FBUF_PARA_DEINTERLACE_STRIDE() volatile
    {
        return (FBUF_PARA >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set FBUF_PARA's DEINTERLACE_STRIDE field.
     *
     * DEINTERLACE_STRIDE is only used in the deinterlace mode
     */
    inline void set_FBUF_PARA_DEINTERLACE_STRIDE(uint16_t value) volatile
    {
        uint32_t curr = FBUF_PARA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        FBUF_PARA = curr;
    }

    /**
     * Get FBUF_PARA's FBUF_STRIDE field.
     *
     * Frame Buffer Parameter
     */
    inline uint16_t get_FBUF_PARA_FBUF_STRIDE() volatile
    {
        return (FBUF_PARA >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set FBUF_PARA's FBUF_STRIDE field.
     *
     * Frame Buffer Parameter
     */
    inline void set_FBUF_PARA_FBUF_STRIDE(uint16_t value) volatile
    {
        uint32_t curr = FBUF_PARA;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        FBUF_PARA = curr;
    }

    /**
     * Get all of FBUF_PARA's bit fields.
     *
     * (read-write) CSI Frame Buffer Parameter Register
     */
    inline void get_FBUF_PARA(uint16_t &DEINTERLACE_STRIDE,
                              uint16_t &FBUF_STRIDE) volatile
    {
        uint32_t curr = FBUF_PARA;

        DEINTERLACE_STRIDE = (curr >> 16u) & 0b1111111111111111u;
        FBUF_STRIDE = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of FBUF_PARA's bit fields.
     *
     * (read-write) CSI Frame Buffer Parameter Register
     */
    inline void set_FBUF_PARA(uint16_t DEINTERLACE_STRIDE,
                              uint16_t FBUF_STRIDE) volatile
    {
        uint32_t curr = FBUF_PARA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (DEINTERLACE_STRIDE & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (FBUF_STRIDE & 0b1111111111111111u) << 0u;

        FBUF_PARA = curr;
    }

    /**
     * Get IMAG_PARA's IMAGE_WIDTH field.
     *
     * This field indicates the number of active pixel cycles per line
     */
    inline uint16_t get_IMAG_PARA_IMAGE_WIDTH() volatile
    {
        return (IMAG_PARA >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set IMAG_PARA's IMAGE_WIDTH field.
     *
     * This field indicates the number of active pixel cycles per line
     */
    inline void set_IMAG_PARA_IMAGE_WIDTH(uint16_t value) volatile
    {
        uint32_t curr = IMAG_PARA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        IMAG_PARA = curr;
    }

    /**
     * Get IMAG_PARA's IMAGE_HEIGHT field.
     *
     * Image Height. Indicates how many pixels in a column of the image from
     * the sensor.
     */
    inline uint16_t get_IMAG_PARA_IMAGE_HEIGHT() volatile
    {
        return (IMAG_PARA >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IMAG_PARA's IMAGE_HEIGHT field.
     *
     * Image Height. Indicates how many pixels in a column of the image from
     * the sensor.
     */
    inline void set_IMAG_PARA_IMAGE_HEIGHT(uint16_t value) volatile
    {
        uint32_t curr = IMAG_PARA;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IMAG_PARA = curr;
    }

    /**
     * Get all of IMAG_PARA's bit fields.
     *
     * (read-write) CSI Image Parameter Register
     */
    inline void get_IMAG_PARA(uint16_t &IMAGE_WIDTH,
                              uint16_t &IMAGE_HEIGHT) volatile
    {
        uint32_t curr = IMAG_PARA;

        IMAGE_WIDTH = (curr >> 16u) & 0b1111111111111111u;
        IMAGE_HEIGHT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of IMAG_PARA's bit fields.
     *
     * (read-write) CSI Image Parameter Register
     */
    inline void set_IMAG_PARA(uint16_t IMAGE_WIDTH,
                              uint16_t IMAGE_HEIGHT) volatile
    {
        uint32_t curr = IMAG_PARA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (IMAGE_WIDTH & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (IMAGE_HEIGHT & 0b1111111111111111u) << 0u;

        IMAG_PARA = curr;
    }

    /**
     * Get CR18's CSI_ENABLE bit.
     *
     * CSI global enable signal
     */
    inline bool get_CR18_CSI_ENABLE() volatile
    {
        return CR18 & (1u << 31u);
    }

    /**
     * Set CR18's CSI_ENABLE bit.
     *
     * CSI global enable signal
     */
    inline void set_CR18_CSI_ENABLE() volatile
    {
        CR18 |= 1u << 31u;
    }

    /**
     * Clear CR18's CSI_ENABLE bit.
     *
     * CSI global enable signal
     */
    inline void clear_CR18_CSI_ENABLE() volatile
    {
        CR18 &= ~(1u << 31u);
    }

    /**
     * Toggle CR18's CSI_ENABLE bit.
     *
     * CSI global enable signal
     */
    inline void toggle_CR18_CSI_ENABLE() volatile
    {
        CR18 ^= 1u << 31u;
    }

    /**
     * Get CR18's MIPI_DATA_FORMAT field.
     *
     * Image Data Format
     */
    inline uint8_t get_CR18_MIPI_DATA_FORMAT() volatile
    {
        return (CR18 >> 25u) & 0b111111u;
    }

    /**
     * Get CR18's LINE_STRIDE_EN bit.
     *
     * When the line width are not the multiple of the burst length, assert
     * this bit.
     */
    inline bool get_CR18_LINE_STRIDE_EN() volatile
    {
        return CR18 & (1u << 24u);
    }

    /**
     * Set CR18's LINE_STRIDE_EN bit.
     *
     * When the line width are not the multiple of the burst length, assert
     * this bit.
     */
    inline void set_CR18_LINE_STRIDE_EN() volatile
    {
        CR18 |= 1u << 24u;
    }

    /**
     * Clear CR18's LINE_STRIDE_EN bit.
     *
     * When the line width are not the multiple of the burst length, assert
     * this bit.
     */
    inline void clear_CR18_LINE_STRIDE_EN() volatile
    {
        CR18 &= ~(1u << 24u);
    }

    /**
     * Toggle CR18's LINE_STRIDE_EN bit.
     *
     * When the line width are not the multiple of the burst length, assert
     * this bit.
     */
    inline void toggle_CR18_LINE_STRIDE_EN() volatile
    {
        CR18 ^= 1u << 24u;
    }

    /**
     * Get CR18's DATA_FROM_MIPI bit.
     *
     * no description available
     */
    inline bool get_CR18_DATA_FROM_MIPI() volatile
    {
        return CR18 & (1u << 22u);
    }

    /**
     * Set CR18's DATA_FROM_MIPI bit.
     *
     * no description available
     */
    inline void set_CR18_DATA_FROM_MIPI() volatile
    {
        CR18 |= 1u << 22u;
    }

    /**
     * Clear CR18's DATA_FROM_MIPI bit.
     *
     * no description available
     */
    inline void clear_CR18_DATA_FROM_MIPI() volatile
    {
        CR18 &= ~(1u << 22u);
    }

    /**
     * Toggle CR18's DATA_FROM_MIPI bit.
     *
     * no description available
     */
    inline void toggle_CR18_DATA_FROM_MIPI() volatile
    {
        CR18 ^= 1u << 22u;
    }

    /**
     * Get CR18's MIPI_YU_SWAP bit.
     *
     * It only works in MIPI CSI YUV422 double component mode.
     */
    inline bool get_CR18_MIPI_YU_SWAP() volatile
    {
        return CR18 & (1u << 21u);
    }

    /**
     * Set CR18's MIPI_YU_SWAP bit.
     *
     * It only works in MIPI CSI YUV422 double component mode.
     */
    inline void set_CR18_MIPI_YU_SWAP() volatile
    {
        CR18 |= 1u << 21u;
    }

    /**
     * Clear CR18's MIPI_YU_SWAP bit.
     *
     * It only works in MIPI CSI YUV422 double component mode.
     */
    inline void clear_CR18_MIPI_YU_SWAP() volatile
    {
        CR18 &= ~(1u << 21u);
    }

    /**
     * Toggle CR18's MIPI_YU_SWAP bit.
     *
     * It only works in MIPI CSI YUV422 double component mode.
     */
    inline void toggle_CR18_MIPI_YU_SWAP() volatile
    {
        CR18 ^= 1u << 21u;
    }

    /**
     * Get CR18's MIPI_DOUBLE_CMPNT bit.
     *
     * Double component per clock cycle in YUV422 formats.
     */
    inline bool get_CR18_MIPI_DOUBLE_CMPNT() volatile
    {
        return CR18 & (1u << 20u);
    }

    /**
     * Set CR18's MIPI_DOUBLE_CMPNT bit.
     *
     * Double component per clock cycle in YUV422 formats.
     */
    inline void set_CR18_MIPI_DOUBLE_CMPNT() volatile
    {
        CR18 |= 1u << 20u;
    }

    /**
     * Clear CR18's MIPI_DOUBLE_CMPNT bit.
     *
     * Double component per clock cycle in YUV422 formats.
     */
    inline void clear_CR18_MIPI_DOUBLE_CMPNT() volatile
    {
        CR18 &= ~(1u << 20u);
    }

    /**
     * Toggle CR18's MIPI_DOUBLE_CMPNT bit.
     *
     * Double component per clock cycle in YUV422 formats.
     */
    inline void toggle_CR18_MIPI_DOUBLE_CMPNT() volatile
    {
        CR18 ^= 1u << 20u;
    }

    /**
     * Get CR18's MASK_OPTION field.
     *
     * These bits used to choose the method to mask the CSI input.
     */
    inline CSI_CR18_MASK_OPTION get_CR18_MASK_OPTION() volatile
    {
        return CSI_CR18_MASK_OPTION((CR18 >> 18u) & 0b11u);
    }

    /**
     * Set CR18's MASK_OPTION field.
     *
     * These bits used to choose the method to mask the CSI input.
     */
    inline void set_CR18_MASK_OPTION(CSI_CR18_MASK_OPTION value) volatile
    {
        uint32_t curr = CR18;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        CR18 = curr;
    }

    /**
     * Get CR18's AHB_HPROT field.
     *
     * Hprot value in AHB bus protocol.
     */
    inline uint8_t get_CR18_AHB_HPROT() volatile
    {
        return (CR18 >> 12u) & 0b1111u;
    }

    /**
     * Set CR18's AHB_HPROT field.
     *
     * Hprot value in AHB bus protocol.
     */
    inline void set_CR18_AHB_HPROT(uint8_t value) volatile
    {
        uint32_t curr = CR18;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        CR18 = curr;
    }

    /**
     * Get CR18's RGB888A_FORMAT_SEL bit.
     *
     * Output is 32-bit format.
     */
    inline bool get_CR18_RGB888A_FORMAT_SEL() volatile
    {
        return CR18 & (1u << 10u);
    }

    /**
     * Set CR18's RGB888A_FORMAT_SEL bit.
     *
     * Output is 32-bit format.
     */
    inline void set_CR18_RGB888A_FORMAT_SEL() volatile
    {
        CR18 |= 1u << 10u;
    }

    /**
     * Clear CR18's RGB888A_FORMAT_SEL bit.
     *
     * Output is 32-bit format.
     */
    inline void clear_CR18_RGB888A_FORMAT_SEL() volatile
    {
        CR18 &= ~(1u << 10u);
    }

    /**
     * Toggle CR18's RGB888A_FORMAT_SEL bit.
     *
     * Output is 32-bit format.
     */
    inline void toggle_CR18_RGB888A_FORMAT_SEL() volatile
    {
        CR18 ^= 1u << 10u;
    }

    /**
     * Get CR18's BASEADDR_CHANGE_ERROR_IE bit.
     *
     * Base address change error interrupt enable signal.
     */
    inline bool get_CR18_BASEADDR_CHANGE_ERROR_IE() volatile
    {
        return CR18 & (1u << 9u);
    }

    /**
     * Set CR18's BASEADDR_CHANGE_ERROR_IE bit.
     *
     * Base address change error interrupt enable signal.
     */
    inline void set_CR18_BASEADDR_CHANGE_ERROR_IE() volatile
    {
        CR18 |= 1u << 9u;
    }

    /**
     * Clear CR18's BASEADDR_CHANGE_ERROR_IE bit.
     *
     * Base address change error interrupt enable signal.
     */
    inline void clear_CR18_BASEADDR_CHANGE_ERROR_IE() volatile
    {
        CR18 &= ~(1u << 9u);
    }

    /**
     * Toggle CR18's BASEADDR_CHANGE_ERROR_IE bit.
     *
     * Base address change error interrupt enable signal.
     */
    inline void toggle_CR18_BASEADDR_CHANGE_ERROR_IE() volatile
    {
        CR18 ^= 1u << 9u;
    }

    /**
     * Get CR18's LAST_DMA_REQ_SEL bit.
     *
     * Choosing the last DMA request condition
     */
    inline bool get_CR18_LAST_DMA_REQ_SEL() volatile
    {
        return CR18 & (1u << 8u);
    }

    /**
     * Set CR18's LAST_DMA_REQ_SEL bit.
     *
     * Choosing the last DMA request condition
     */
    inline void set_CR18_LAST_DMA_REQ_SEL() volatile
    {
        CR18 |= 1u << 8u;
    }

    /**
     * Clear CR18's LAST_DMA_REQ_SEL bit.
     *
     * Choosing the last DMA request condition
     */
    inline void clear_CR18_LAST_DMA_REQ_SEL() volatile
    {
        CR18 &= ~(1u << 8u);
    }

    /**
     * Toggle CR18's LAST_DMA_REQ_SEL bit.
     *
     * Choosing the last DMA request condition
     */
    inline void toggle_CR18_LAST_DMA_REQ_SEL() volatile
    {
        CR18 ^= 1u << 8u;
    }

    /**
     * Get CR18's DMA_FIELD1_DONE_IE bit.
     *
     * When in interlace mode, field 1 done interrupt enable.
     */
    inline bool get_CR18_DMA_FIELD1_DONE_IE() volatile
    {
        return CR18 & (1u << 7u);
    }

    /**
     * Set CR18's DMA_FIELD1_DONE_IE bit.
     *
     * When in interlace mode, field 1 done interrupt enable.
     */
    inline void set_CR18_DMA_FIELD1_DONE_IE() volatile
    {
        CR18 |= 1u << 7u;
    }

    /**
     * Clear CR18's DMA_FIELD1_DONE_IE bit.
     *
     * When in interlace mode, field 1 done interrupt enable.
     */
    inline void clear_CR18_DMA_FIELD1_DONE_IE() volatile
    {
        CR18 &= ~(1u << 7u);
    }

    /**
     * Toggle CR18's DMA_FIELD1_DONE_IE bit.
     *
     * When in interlace mode, field 1 done interrupt enable.
     */
    inline void toggle_CR18_DMA_FIELD1_DONE_IE() volatile
    {
        CR18 ^= 1u << 7u;
    }

    /**
     * Get CR18's FIELD0_DONE_IE bit.
     *
     * In interlace mode, field 0 means interrupt enabled.
     */
    inline bool get_CR18_FIELD0_DONE_IE() volatile
    {
        return CR18 & (1u << 6u);
    }

    /**
     * Set CR18's FIELD0_DONE_IE bit.
     *
     * In interlace mode, field 0 means interrupt enabled.
     */
    inline void set_CR18_FIELD0_DONE_IE() volatile
    {
        CR18 |= 1u << 6u;
    }

    /**
     * Clear CR18's FIELD0_DONE_IE bit.
     *
     * In interlace mode, field 0 means interrupt enabled.
     */
    inline void clear_CR18_FIELD0_DONE_IE() volatile
    {
        CR18 &= ~(1u << 6u);
    }

    /**
     * Toggle CR18's FIELD0_DONE_IE bit.
     *
     * In interlace mode, field 0 means interrupt enabled.
     */
    inline void toggle_CR18_FIELD0_DONE_IE() volatile
    {
        CR18 ^= 1u << 6u;
    }

    /**
     * Get CR18's BASEADDR_SWITCH_SEL bit.
     *
     * CSI 2 base addresses switching method. When using this bit,
     * BASEADDR_SWITCH_EN is 1.
     */
    inline bool get_CR18_BASEADDR_SWITCH_SEL() volatile
    {
        return CR18 & (1u << 5u);
    }

    /**
     * Set CR18's BASEADDR_SWITCH_SEL bit.
     *
     * CSI 2 base addresses switching method. When using this bit,
     * BASEADDR_SWITCH_EN is 1.
     */
    inline void set_CR18_BASEADDR_SWITCH_SEL() volatile
    {
        CR18 |= 1u << 5u;
    }

    /**
     * Clear CR18's BASEADDR_SWITCH_SEL bit.
     *
     * CSI 2 base addresses switching method. When using this bit,
     * BASEADDR_SWITCH_EN is 1.
     */
    inline void clear_CR18_BASEADDR_SWITCH_SEL() volatile
    {
        CR18 &= ~(1u << 5u);
    }

    /**
     * Toggle CR18's BASEADDR_SWITCH_SEL bit.
     *
     * CSI 2 base addresses switching method. When using this bit,
     * BASEADDR_SWITCH_EN is 1.
     */
    inline void toggle_CR18_BASEADDR_SWITCH_SEL() volatile
    {
        CR18 ^= 1u << 5u;
    }

    /**
     * Get CR18's BASEADDR_SWITCH_EN bit.
     *
     * When this bit is enabled, CSI DMA will switch the base address according
     * to BASEADDR_SWITCH_SEL rather than automatically by DMA completed
     */
    inline bool get_CR18_BASEADDR_SWITCH_EN() volatile
    {
        return CR18 & (1u << 4u);
    }

    /**
     * Set CR18's BASEADDR_SWITCH_EN bit.
     *
     * When this bit is enabled, CSI DMA will switch the base address according
     * to BASEADDR_SWITCH_SEL rather than automatically by DMA completed
     */
    inline void set_CR18_BASEADDR_SWITCH_EN() volatile
    {
        CR18 |= 1u << 4u;
    }

    /**
     * Clear CR18's BASEADDR_SWITCH_EN bit.
     *
     * When this bit is enabled, CSI DMA will switch the base address according
     * to BASEADDR_SWITCH_SEL rather than automatically by DMA completed
     */
    inline void clear_CR18_BASEADDR_SWITCH_EN() volatile
    {
        CR18 &= ~(1u << 4u);
    }

    /**
     * Toggle CR18's BASEADDR_SWITCH_EN bit.
     *
     * When this bit is enabled, CSI DMA will switch the base address according
     * to BASEADDR_SWITCH_SEL rather than automatically by DMA completed
     */
    inline void toggle_CR18_BASEADDR_SWITCH_EN() volatile
    {
        CR18 ^= 1u << 4u;
    }

    /**
     * Get CR18's PARALLEL24_EN bit.
     *
     * Enable bit for Parallel RGB888/YUV444 24bit input
     */
    inline bool get_CR18_PARALLEL24_EN() volatile
    {
        return CR18 & (1u << 3u);
    }

    /**
     * Set CR18's PARALLEL24_EN bit.
     *
     * Enable bit for Parallel RGB888/YUV444 24bit input
     */
    inline void set_CR18_PARALLEL24_EN() volatile
    {
        CR18 |= 1u << 3u;
    }

    /**
     * Clear CR18's PARALLEL24_EN bit.
     *
     * Enable bit for Parallel RGB888/YUV444 24bit input
     */
    inline void clear_CR18_PARALLEL24_EN() volatile
    {
        CR18 &= ~(1u << 3u);
    }

    /**
     * Toggle CR18's PARALLEL24_EN bit.
     *
     * Enable bit for Parallel RGB888/YUV444 24bit input
     */
    inline void toggle_CR18_PARALLEL24_EN() volatile
    {
        CR18 ^= 1u << 3u;
    }

    /**
     * Get CR18's DEINTERLACE_EN bit.
     *
     * This bit is used to select the output method When input is TVDECODER or
     * standard BT.656 video.
     */
    inline bool get_CR18_DEINTERLACE_EN() volatile
    {
        return CR18 & (1u << 2u);
    }

    /**
     * Set CR18's DEINTERLACE_EN bit.
     *
     * This bit is used to select the output method When input is TVDECODER or
     * standard BT.656 video.
     */
    inline void set_CR18_DEINTERLACE_EN() volatile
    {
        CR18 |= 1u << 2u;
    }

    /**
     * Clear CR18's DEINTERLACE_EN bit.
     *
     * This bit is used to select the output method When input is TVDECODER or
     * standard BT.656 video.
     */
    inline void clear_CR18_DEINTERLACE_EN() volatile
    {
        CR18 &= ~(1u << 2u);
    }

    /**
     * Toggle CR18's DEINTERLACE_EN bit.
     *
     * This bit is used to select the output method When input is TVDECODER or
     * standard BT.656 video.
     */
    inline void toggle_CR18_DEINTERLACE_EN() volatile
    {
        CR18 ^= 1u << 2u;
    }

    /**
     * Get CR18's TVDECODER_IN_EN bit.
     *
     * When input is from TV decoder, this bit is enabled.
     */
    inline bool get_CR18_TVDECODER_IN_EN() volatile
    {
        return CR18 & (1u << 1u);
    }

    /**
     * Set CR18's TVDECODER_IN_EN bit.
     *
     * When input is from TV decoder, this bit is enabled.
     */
    inline void set_CR18_TVDECODER_IN_EN() volatile
    {
        CR18 |= 1u << 1u;
    }

    /**
     * Clear CR18's TVDECODER_IN_EN bit.
     *
     * When input is from TV decoder, this bit is enabled.
     */
    inline void clear_CR18_TVDECODER_IN_EN() volatile
    {
        CR18 &= ~(1u << 1u);
    }

    /**
     * Toggle CR18's TVDECODER_IN_EN bit.
     *
     * When input is from TV decoder, this bit is enabled.
     */
    inline void toggle_CR18_TVDECODER_IN_EN() volatile
    {
        CR18 ^= 1u << 1u;
    }

    /**
     * Get CR18's NTSC_EN bit.
     *
     * This bit is used to select NTSC/PAL mode When input is TVDECODER or
     * standard BT.656 video.
     */
    inline bool get_CR18_NTSC_EN() volatile
    {
        return CR18 & (1u << 0u);
    }

    /**
     * Set CR18's NTSC_EN bit.
     *
     * This bit is used to select NTSC/PAL mode When input is TVDECODER or
     * standard BT.656 video.
     */
    inline void set_CR18_NTSC_EN() volatile
    {
        CR18 |= 1u << 0u;
    }

    /**
     * Clear CR18's NTSC_EN bit.
     *
     * This bit is used to select NTSC/PAL mode When input is TVDECODER or
     * standard BT.656 video.
     */
    inline void clear_CR18_NTSC_EN() volatile
    {
        CR18 &= ~(1u << 0u);
    }

    /**
     * Toggle CR18's NTSC_EN bit.
     *
     * This bit is used to select NTSC/PAL mode When input is TVDECODER or
     * standard BT.656 video.
     */
    inline void toggle_CR18_NTSC_EN() volatile
    {
        CR18 ^= 1u << 0u;
    }

    /**
     * Get all of CR18's bit fields.
     *
     * (read-write) CSI Control Register 18
     */
    inline void get_CR18(bool &CSI_ENABLE, uint8_t &MIPI_DATA_FORMAT,
                         bool &LINE_STRIDE_EN, bool &DATA_FROM_MIPI,
                         bool &MIPI_YU_SWAP, bool &MIPI_DOUBLE_CMPNT,
                         CSI_CR18_MASK_OPTION &MASK_OPTION, uint8_t &AHB_HPROT,
                         bool &RGB888A_FORMAT_SEL,
                         bool &BASEADDR_CHANGE_ERROR_IE,
                         bool &LAST_DMA_REQ_SEL, bool &DMA_FIELD1_DONE_IE,
                         bool &FIELD0_DONE_IE, bool &BASEADDR_SWITCH_SEL,
                         bool &BASEADDR_SWITCH_EN, bool &PARALLEL24_EN,
                         bool &DEINTERLACE_EN, bool &TVDECODER_IN_EN,
                         bool &NTSC_EN) volatile
    {
        uint32_t curr = CR18;

        CSI_ENABLE = curr & (1u << 31u);
        MIPI_DATA_FORMAT = (curr >> 25u) & 0b111111u;
        LINE_STRIDE_EN = curr & (1u << 24u);
        DATA_FROM_MIPI = curr & (1u << 22u);
        MIPI_YU_SWAP = curr & (1u << 21u);
        MIPI_DOUBLE_CMPNT = curr & (1u << 20u);
        MASK_OPTION = CSI_CR18_MASK_OPTION((curr >> 18u) & 0b11u);
        AHB_HPROT = (curr >> 12u) & 0b1111u;
        RGB888A_FORMAT_SEL = curr & (1u << 10u);
        BASEADDR_CHANGE_ERROR_IE = curr & (1u << 9u);
        LAST_DMA_REQ_SEL = curr & (1u << 8u);
        DMA_FIELD1_DONE_IE = curr & (1u << 7u);
        FIELD0_DONE_IE = curr & (1u << 6u);
        BASEADDR_SWITCH_SEL = curr & (1u << 5u);
        BASEADDR_SWITCH_EN = curr & (1u << 4u);
        PARALLEL24_EN = curr & (1u << 3u);
        DEINTERLACE_EN = curr & (1u << 2u);
        TVDECODER_IN_EN = curr & (1u << 1u);
        NTSC_EN = curr & (1u << 0u);
    }

    /**
     * Set all of CR18's bit fields.
     *
     * (read-write) CSI Control Register 18
     */
    inline void set_CR18(bool CSI_ENABLE, bool LINE_STRIDE_EN,
                         bool DATA_FROM_MIPI, bool MIPI_YU_SWAP,
                         bool MIPI_DOUBLE_CMPNT,
                         CSI_CR18_MASK_OPTION MASK_OPTION, uint8_t AHB_HPROT,
                         bool RGB888A_FORMAT_SEL,
                         bool BASEADDR_CHANGE_ERROR_IE, bool LAST_DMA_REQ_SEL,
                         bool DMA_FIELD1_DONE_IE, bool FIELD0_DONE_IE,
                         bool BASEADDR_SWITCH_SEL, bool BASEADDR_SWITCH_EN,
                         bool PARALLEL24_EN, bool DEINTERLACE_EN,
                         bool TVDECODER_IN_EN, bool NTSC_EN) volatile
    {
        uint32_t curr = CR18;

        curr &= ~(0b1u << 31u);
        curr |= (CSI_ENABLE & 0b1u) << 31u;
        curr &= ~(0b1u << 24u);
        curr |= (LINE_STRIDE_EN & 0b1u) << 24u;
        curr &= ~(0b1u << 22u);
        curr |= (DATA_FROM_MIPI & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (MIPI_YU_SWAP & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (MIPI_DOUBLE_CMPNT & 0b1u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(MASK_OPTION) & 0b11u) << 18u;
        curr &= ~(0b1111u << 12u);
        curr |= (AHB_HPROT & 0b1111u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (RGB888A_FORMAT_SEL & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (BASEADDR_CHANGE_ERROR_IE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (LAST_DMA_REQ_SEL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (DMA_FIELD1_DONE_IE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (FIELD0_DONE_IE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (BASEADDR_SWITCH_SEL & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BASEADDR_SWITCH_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PARALLEL24_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DEINTERLACE_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TVDECODER_IN_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (NTSC_EN & 0b1u) << 0u;

        CR18 = curr;
    }

    /**
     * Get CR19's DMA_RFIFO_HIGHEST_FIFO_LEVEL field.
     *
     * This byte stores the highest FIFO level achieved by CSI FIFO timely and
     * will be clear by writing 8'ff to it
     */
    inline uint8_t get_CR19_DMA_RFIFO_HIGHEST_FIFO_LEVEL() volatile
    {
        return (CR19 >> 0u) & 0b11111111u;
    }

    /**
     * Set CR19's DMA_RFIFO_HIGHEST_FIFO_LEVEL field.
     *
     * This byte stores the highest FIFO level achieved by CSI FIFO timely and
     * will be clear by writing 8'ff to it
     */
    inline void set_CR19_DMA_RFIFO_HIGHEST_FIFO_LEVEL(uint8_t value) volatile
    {
        uint32_t curr = CR19;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CR19 = curr;
    }

    /**
     * Get CR20's QRCODE_EN bit.
     *
     * Gray scale mode enable
     */
    inline bool get_CR20_QRCODE_EN() volatile
    {
        return CR20 & (1u << 31u);
    }

    /**
     * Set CR20's QRCODE_EN bit.
     *
     * Gray scale mode enable
     */
    inline void set_CR20_QRCODE_EN() volatile
    {
        CR20 |= 1u << 31u;
    }

    /**
     * Clear CR20's QRCODE_EN bit.
     *
     * Gray scale mode enable
     */
    inline void clear_CR20_QRCODE_EN() volatile
    {
        CR20 &= ~(1u << 31u);
    }

    /**
     * Toggle CR20's QRCODE_EN bit.
     *
     * Gray scale mode enable
     */
    inline void toggle_CR20_QRCODE_EN() volatile
    {
        CR20 ^= 1u << 31u;
    }

    /**
     * Get CR20's HISTOGRAM_EN bit.
     *
     * Histogram enable
     */
    inline bool get_CR20_HISTOGRAM_EN() volatile
    {
        return CR20 & (1u << 30u);
    }

    /**
     * Set CR20's HISTOGRAM_EN bit.
     *
     * Histogram enable
     */
    inline void set_CR20_HISTOGRAM_EN() volatile
    {
        CR20 |= 1u << 30u;
    }

    /**
     * Clear CR20's HISTOGRAM_EN bit.
     *
     * Histogram enable
     */
    inline void clear_CR20_HISTOGRAM_EN() volatile
    {
        CR20 &= ~(1u << 30u);
    }

    /**
     * Toggle CR20's HISTOGRAM_EN bit.
     *
     * Histogram enable
     */
    inline void toggle_CR20_HISTOGRAM_EN() volatile
    {
        CR20 ^= 1u << 30u;
    }

    /**
     * Get CR20's _10BIT_NEW_EN bit.
     *
     * no description available
     */
    inline bool get_CR20__10BIT_NEW_EN() volatile
    {
        return CR20 & (1u << 29u);
    }

    /**
     * Set CR20's _10BIT_NEW_EN bit.
     *
     * no description available
     */
    inline void set_CR20__10BIT_NEW_EN() volatile
    {
        CR20 |= 1u << 29u;
    }

    /**
     * Clear CR20's _10BIT_NEW_EN bit.
     *
     * no description available
     */
    inline void clear_CR20__10BIT_NEW_EN() volatile
    {
        CR20 &= ~(1u << 29u);
    }

    /**
     * Toggle CR20's _10BIT_NEW_EN bit.
     *
     * no description available
     */
    inline void toggle_CR20__10BIT_NEW_EN() volatile
    {
        CR20 ^= 1u << 29u;
    }

    /**
     * Get CR20's BIG_END bit.
     *
     * no description available
     */
    inline bool get_CR20_BIG_END() volatile
    {
        return CR20 & (1u << 12u);
    }

    /**
     * Set CR20's BIG_END bit.
     *
     * no description available
     */
    inline void set_CR20_BIG_END() volatile
    {
        CR20 |= 1u << 12u;
    }

    /**
     * Clear CR20's BIG_END bit.
     *
     * no description available
     */
    inline void clear_CR20_BIG_END() volatile
    {
        CR20 &= ~(1u << 12u);
    }

    /**
     * Toggle CR20's BIG_END bit.
     *
     * no description available
     */
    inline void toggle_CR20_BIG_END() volatile
    {
        CR20 ^= 1u << 12u;
    }

    /**
     * Get CR20's QR_DATA_FORMAT field.
     *
     * no description available
     */
    inline CSI_CR20_QR_DATA_FORMAT get_CR20_QR_DATA_FORMAT() volatile
    {
        return CSI_CR20_QR_DATA_FORMAT((CR20 >> 9u) & 0b111u);
    }

    /**
     * Set CR20's QR_DATA_FORMAT field.
     *
     * no description available
     */
    inline void set_CR20_QR_DATA_FORMAT(CSI_CR20_QR_DATA_FORMAT value) volatile
    {
        uint32_t curr = CR20;

        curr &= ~(0b111u << 9u);
        curr |= (std::to_underlying(value) & 0b111u) << 9u;

        CR20 = curr;
    }

    /**
     * Get CR20's BINARY_EN bit.
     *
     * no description available
     */
    inline bool get_CR20_BINARY_EN() volatile
    {
        return CR20 & (1u << 8u);
    }

    /**
     * Set CR20's BINARY_EN bit.
     *
     * no description available
     */
    inline void set_CR20_BINARY_EN() volatile
    {
        CR20 |= 1u << 8u;
    }

    /**
     * Clear CR20's BINARY_EN bit.
     *
     * no description available
     */
    inline void clear_CR20_BINARY_EN() volatile
    {
        CR20 &= ~(1u << 8u);
    }

    /**
     * Toggle CR20's BINARY_EN bit.
     *
     * no description available
     */
    inline void toggle_CR20_BINARY_EN() volatile
    {
        CR20 ^= 1u << 8u;
    }

    /**
     * Get CR20's THRESHOLD field.
     *
     * THRESHOLD used for binary function. When data value > THRESHOLD, output
     * will be 1 Else will be 0.
     */
    inline uint8_t get_CR20_THRESHOLD() volatile
    {
        return (CR20 >> 0u) & 0b11111111u;
    }

    /**
     * Set CR20's THRESHOLD field.
     *
     * THRESHOLD used for binary function. When data value > THRESHOLD, output
     * will be 1 Else will be 0.
     */
    inline void set_CR20_THRESHOLD(uint8_t value) volatile
    {
        uint32_t curr = CR20;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CR20 = curr;
    }

    /**
     * Get all of CR20's bit fields.
     *
     * (read-write) CSI Control Register 20
     */
    inline void get_CR20(bool &QRCODE_EN, bool &HISTOGRAM_EN,
                         bool &_10BIT_NEW_EN, bool &BIG_END,
                         CSI_CR20_QR_DATA_FORMAT &QR_DATA_FORMAT,
                         bool &BINARY_EN, uint8_t &THRESHOLD) volatile
    {
        uint32_t curr = CR20;

        QRCODE_EN = curr & (1u << 31u);
        HISTOGRAM_EN = curr & (1u << 30u);
        _10BIT_NEW_EN = curr & (1u << 29u);
        BIG_END = curr & (1u << 12u);
        QR_DATA_FORMAT = CSI_CR20_QR_DATA_FORMAT((curr >> 9u) & 0b111u);
        BINARY_EN = curr & (1u << 8u);
        THRESHOLD = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of CR20's bit fields.
     *
     * (read-write) CSI Control Register 20
     */
    inline void set_CR20(bool QRCODE_EN, bool HISTOGRAM_EN, bool _10BIT_NEW_EN,
                         bool BIG_END, CSI_CR20_QR_DATA_FORMAT QR_DATA_FORMAT,
                         bool BINARY_EN, uint8_t THRESHOLD) volatile
    {
        uint32_t curr = CR20;

        curr &= ~(0b1u << 31u);
        curr |= (QRCODE_EN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (HISTOGRAM_EN & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (_10BIT_NEW_EN & 0b1u) << 29u;
        curr &= ~(0b1u << 12u);
        curr |= (BIG_END & 0b1u) << 12u;
        curr &= ~(0b111u << 9u);
        curr |= (std::to_underlying(QR_DATA_FORMAT) & 0b111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (BINARY_EN & 0b1u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (THRESHOLD & 0b11111111u) << 0u;

        CR20 = curr;
    }

    /**
     * Get CR's PIXEL_COUNTERS field.
     *
     * Number of pixels (Y component of the input pixel) equals: 0 (CSICR21) 1
     * (CSICR22)
     */
    inline uint32_t get_CR_PIXEL_COUNTERS(std::size_t index) volatile
    {
        return (CR[index] >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set CR's PIXEL_COUNTERS field.
     *
     * Number of pixels (Y component of the input pixel) equals: 0 (CSICR21) 1
     * (CSICR22)
     */
    inline void set_CR_PIXEL_COUNTERS(std::size_t index,
                                      uint32_t value) volatile
    {
        uint32_t curr = CR[index];

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        CR[index] = curr;
    }
};

static_assert(sizeof(csi) == csi::size);

static volatile csi *const CSI = reinterpret_cast<csi *>(0x40800000);

}; // namespace MIMXRT1176::CM7
