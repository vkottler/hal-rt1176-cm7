/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/PGMC_BPC0_BPC_MODE_CTRL_MODE.h"
#include "../enums/PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * PGMC_BPC
 */
struct [[gnu::packed]] pgmc_bpc0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 72; /*!< pgmc_bpc0's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint32_t BPC_AUTHEN_CTRL; /*!< (read-write) BPC Authentication Control */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t BPC_MODE;       /*!< (read-write) BPC Mode */
    uint32_t BPC_POWER_CTRL; /*!< (read-write) BPC power control */
    static constexpr std::size_t reserved_padding2_length = 5;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t BPC_FLAG; /*!< (read-write) BPC flag */
    static constexpr std::size_t reserved_padding3_length = 4;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t BPC_SSAR_SAVE_CTRL; /*!< (read-write) BPC SSAR save control */
    uint32_t
        BPC_SSAR_RESTORE_CTRL; /*!< (read-write) BPC SSAR restore control */

    /* Methods. */

    /**
     * Get BPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline bool get_BPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        return BPC_AUTHEN_CTRL & (1u << 20u);
    }

    /**
     * Set BPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void set_BPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        BPC_AUTHEN_CTRL |= 1u << 20u;
    }

    /**
     * Clear BPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void clear_BPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        BPC_AUTHEN_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle BPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void toggle_BPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        BPC_AUTHEN_CTRL ^= 1u << 20u;
    }

    /**
     * Get BPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline bool get_BPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        return BPC_AUTHEN_CTRL & (1u << 12u);
    }

    /**
     * Set BPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void set_BPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        BPC_AUTHEN_CTRL |= 1u << 12u;
    }

    /**
     * Clear BPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void clear_BPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        BPC_AUTHEN_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle BPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void toggle_BPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        BPC_AUTHEN_CTRL ^= 1u << 12u;
    }

    /**
     * Get BPC_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline uint8_t get_BPC_AUTHEN_CTRL_WHITE_LIST() volatile
    {
        return (BPC_AUTHEN_CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set BPC_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline void set_BPC_AUTHEN_CTRL_WHITE_LIST(uint8_t value) volatile
    {
        uint32_t curr = BPC_AUTHEN_CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        BPC_AUTHEN_CTRL = curr;
    }

    /**
     * Get BPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline bool get_BPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        return BPC_AUTHEN_CTRL & (1u << 4u);
    }

    /**
     * Set BPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void set_BPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        BPC_AUTHEN_CTRL |= 1u << 4u;
    }

    /**
     * Clear BPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void clear_BPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        BPC_AUTHEN_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle BPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void toggle_BPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        BPC_AUTHEN_CTRL ^= 1u << 4u;
    }

    /**
     * Get BPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline bool get_BPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        return BPC_AUTHEN_CTRL & (1u << 1u);
    }

    /**
     * Set BPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void set_BPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        BPC_AUTHEN_CTRL |= 1u << 1u;
    }

    /**
     * Clear BPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void clear_BPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        BPC_AUTHEN_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle BPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void toggle_BPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        BPC_AUTHEN_CTRL ^= 1u << 1u;
    }

    /**
     * Get BPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline bool get_BPC_AUTHEN_CTRL_USER() volatile
    {
        return BPC_AUTHEN_CTRL & (1u << 0u);
    }

    /**
     * Set BPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void set_BPC_AUTHEN_CTRL_USER() volatile
    {
        BPC_AUTHEN_CTRL |= 1u << 0u;
    }

    /**
     * Clear BPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void clear_BPC_AUTHEN_CTRL_USER() volatile
    {
        BPC_AUTHEN_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle BPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void toggle_BPC_AUTHEN_CTRL_USER() volatile
    {
        BPC_AUTHEN_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of BPC_AUTHEN_CTRL's bit fields.
     *
     * (read-write) BPC Authentication Control
     */
    inline void get_BPC_AUTHEN_CTRL(bool &LOCK_CFG, bool &LOCK_LIST,
                                    uint8_t &WHITE_LIST, bool &LOCK_SETTING,
                                    bool &NONSECURE, bool &USER) volatile
    {
        uint32_t curr = BPC_AUTHEN_CTRL;

        LOCK_CFG = curr & (1u << 20u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_SETTING = curr & (1u << 4u);
        NONSECURE = curr & (1u << 1u);
        USER = curr & (1u << 0u);
    }

    /**
     * Set all of BPC_AUTHEN_CTRL's bit fields.
     *
     * (read-write) BPC Authentication Control
     */
    inline void set_BPC_AUTHEN_CTRL(bool LOCK_CFG, bool LOCK_LIST,
                                    uint8_t WHITE_LIST, bool LOCK_SETTING,
                                    bool NONSECURE, bool USER) volatile
    {
        uint32_t curr = BPC_AUTHEN_CTRL;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_CFG & 0b1u) << 20u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_SETTING & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (NONSECURE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (USER & 0b1u) << 0u;

        BPC_AUTHEN_CTRL = curr;
    }

    /**
     * Get BPC_MODE's DOMAIN_ASSIGN field.
     *
     * Domain assignment of the BPC
     */
    inline PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN
    get_BPC_MODE_DOMAIN_ASSIGN() volatile
    {
        return PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN((BPC_MODE >> 4u) & 0b11u);
    }

    /**
     * Set BPC_MODE's DOMAIN_ASSIGN field.
     *
     * Domain assignment of the BPC
     */
    inline void set_BPC_MODE_DOMAIN_ASSIGN(
        PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN value) volatile
    {
        uint32_t curr = BPC_MODE;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        BPC_MODE = curr;
    }

    /**
     * Get BPC_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline PGMC_BPC0_BPC_MODE_CTRL_MODE get_BPC_MODE_CTRL_MODE() volatile
    {
        return PGMC_BPC0_BPC_MODE_CTRL_MODE((BPC_MODE >> 0u) & 0b11u);
    }

    /**
     * Set BPC_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_BPC_MODE_CTRL_MODE(
        PGMC_BPC0_BPC_MODE_CTRL_MODE value) volatile
    {
        uint32_t curr = BPC_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        BPC_MODE = curr;
    }

    /**
     * Get all of BPC_MODE's bit fields.
     *
     * (read-write) BPC Mode
     */
    inline void get_BPC_MODE(PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN &DOMAIN_ASSIGN,
                             PGMC_BPC0_BPC_MODE_CTRL_MODE &CTRL_MODE) volatile
    {
        uint32_t curr = BPC_MODE;

        DOMAIN_ASSIGN = PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN((curr >> 4u) & 0b11u);
        CTRL_MODE = PGMC_BPC0_BPC_MODE_CTRL_MODE((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of BPC_MODE's bit fields.
     *
     * (read-write) BPC Mode
     */
    inline void set_BPC_MODE(PGMC_BPC0_BPC_MODE_DOMAIN_ASSIGN DOMAIN_ASSIGN,
                             PGMC_BPC0_BPC_MODE_CTRL_MODE CTRL_MODE) volatile
    {
        uint32_t curr = BPC_MODE;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DOMAIN_ASSIGN) & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CTRL_MODE) & 0b11u) << 0u;

        BPC_MODE = curr;
    }

    /**
     * Get BPC_POWER_CTRL's PWR_OFF_AT_SP field.
     *
     * Power off when system enters Setpoint number
     */
    inline uint16_t get_BPC_POWER_CTRL_PWR_OFF_AT_SP() volatile
    {
        return (BPC_POWER_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set BPC_POWER_CTRL's PWR_OFF_AT_SP field.
     *
     * Power off when system enters Setpoint number
     */
    inline void set_BPC_POWER_CTRL_PWR_OFF_AT_SP(uint16_t value) volatile
    {
        uint32_t curr = BPC_POWER_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        BPC_POWER_CTRL = curr;
    }

    /**
     * Get BPC_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline bool get_BPC_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        return BPC_POWER_CTRL & (1u << 11u);
    }

    /**
     * Set BPC_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline void set_BPC_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        BPC_POWER_CTRL |= 1u << 11u;
    }

    /**
     * Clear BPC_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline void clear_BPC_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle BPC_POWER_CTRL's ISO_OFF_SOFT bit.
     *
     * Software isolation off trigger
     */
    inline void toggle_BPC_POWER_CTRL_ISO_OFF_SOFT() volatile
    {
        BPC_POWER_CTRL ^= 1u << 11u;
    }

    /**
     * Get BPC_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline bool get_BPC_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        return BPC_POWER_CTRL & (1u << 10u);
    }

    /**
     * Set BPC_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline void set_BPC_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        BPC_POWER_CTRL |= 1u << 10u;
    }

    /**
     * Clear BPC_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline void clear_BPC_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle BPC_POWER_CTRL's PSW_ON_SOFT bit.
     *
     * Software power on trigger
     */
    inline void toggle_BPC_POWER_CTRL_PSW_ON_SOFT() volatile
    {
        BPC_POWER_CTRL ^= 1u << 10u;
    }

    /**
     * Get BPC_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline bool get_BPC_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        return BPC_POWER_CTRL & (1u << 9u);
    }

    /**
     * Set BPC_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline void set_BPC_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        BPC_POWER_CTRL |= 1u << 9u;
    }

    /**
     * Clear BPC_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline void clear_BPC_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle BPC_POWER_CTRL's PSW_OFF_SOFT bit.
     *
     * Software power off trigger
     */
    inline void toggle_BPC_POWER_CTRL_PSW_OFF_SOFT() volatile
    {
        BPC_POWER_CTRL ^= 1u << 9u;
    }

    /**
     * Get BPC_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline bool get_BPC_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        return BPC_POWER_CTRL & (1u << 8u);
    }

    /**
     * Set BPC_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline void set_BPC_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        BPC_POWER_CTRL |= 1u << 8u;
    }

    /**
     * Clear BPC_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline void clear_BPC_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle BPC_POWER_CTRL's ISO_ON_SOFT bit.
     *
     * Software isolation on trigger
     */
    inline void toggle_BPC_POWER_CTRL_ISO_ON_SOFT() volatile
    {
        BPC_POWER_CTRL ^= 1u << 8u;
    }

    /**
     * Get BPC_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * 0x1: Power off when domain enters SUSPEND mode
     */
    inline bool get_BPC_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        return BPC_POWER_CTRL & (1u << 3u);
    }

    /**
     * Set BPC_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * 0x1: Power off when domain enters SUSPEND mode
     */
    inline void set_BPC_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        BPC_POWER_CTRL |= 1u << 3u;
    }

    /**
     * Clear BPC_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * 0x1: Power off when domain enters SUSPEND mode
     */
    inline void clear_BPC_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle BPC_POWER_CTRL's PWR_OFF_AT_SUSPEND bit.
     *
     * 0x1: Power off when domain enters SUSPEND mode
     */
    inline void toggle_BPC_POWER_CTRL_PWR_OFF_AT_SUSPEND() volatile
    {
        BPC_POWER_CTRL ^= 1u << 3u;
    }

    /**
     * Get BPC_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * 0x1: Power off when domain enters STOP mode
     */
    inline bool get_BPC_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        return BPC_POWER_CTRL & (1u << 2u);
    }

    /**
     * Set BPC_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * 0x1: Power off when domain enters STOP mode
     */
    inline void set_BPC_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        BPC_POWER_CTRL |= 1u << 2u;
    }

    /**
     * Clear BPC_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * 0x1: Power off when domain enters STOP mode
     */
    inline void clear_BPC_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle BPC_POWER_CTRL's PWR_OFF_AT_STOP bit.
     *
     * 0x1: Power off when domain enters STOP mode
     */
    inline void toggle_BPC_POWER_CTRL_PWR_OFF_AT_STOP() volatile
    {
        BPC_POWER_CTRL ^= 1u << 2u;
    }

    /**
     * Get BPC_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * 0x1: Power off when domain enters WAIT mode
     */
    inline bool get_BPC_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        return BPC_POWER_CTRL & (1u << 1u);
    }

    /**
     * Set BPC_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * 0x1: Power off when domain enters WAIT mode
     */
    inline void set_BPC_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        BPC_POWER_CTRL |= 1u << 1u;
    }

    /**
     * Clear BPC_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * 0x1: Power off when domain enters WAIT mode
     */
    inline void clear_BPC_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        BPC_POWER_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle BPC_POWER_CTRL's PWR_OFF_AT_WAIT bit.
     *
     * 0x1: Power off when domain enters WAIT mode
     */
    inline void toggle_BPC_POWER_CTRL_PWR_OFF_AT_WAIT() volatile
    {
        BPC_POWER_CTRL ^= 1u << 1u;
    }

    /**
     * Get all of BPC_POWER_CTRL's bit fields.
     *
     * (read-write) BPC power control
     */
    inline void get_BPC_POWER_CTRL(uint16_t &PWR_OFF_AT_SP, bool &ISO_OFF_SOFT,
                                   bool &PSW_ON_SOFT, bool &PSW_OFF_SOFT,
                                   bool &ISO_ON_SOFT, bool &PWR_OFF_AT_SUSPEND,
                                   bool &PWR_OFF_AT_STOP,
                                   bool &PWR_OFF_AT_WAIT) volatile
    {
        uint32_t curr = BPC_POWER_CTRL;

        PWR_OFF_AT_SP = (curr >> 16u) & 0b1111111111111111u;
        ISO_OFF_SOFT = curr & (1u << 11u);
        PSW_ON_SOFT = curr & (1u << 10u);
        PSW_OFF_SOFT = curr & (1u << 9u);
        ISO_ON_SOFT = curr & (1u << 8u);
        PWR_OFF_AT_SUSPEND = curr & (1u << 3u);
        PWR_OFF_AT_STOP = curr & (1u << 2u);
        PWR_OFF_AT_WAIT = curr & (1u << 1u);
    }

    /**
     * Set all of BPC_POWER_CTRL's bit fields.
     *
     * (read-write) BPC power control
     */
    inline void set_BPC_POWER_CTRL(uint16_t PWR_OFF_AT_SP, bool ISO_OFF_SOFT,
                                   bool PSW_ON_SOFT, bool PSW_OFF_SOFT,
                                   bool ISO_ON_SOFT, bool PWR_OFF_AT_SUSPEND,
                                   bool PWR_OFF_AT_STOP,
                                   bool PWR_OFF_AT_WAIT) volatile
    {
        uint32_t curr = BPC_POWER_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (PWR_OFF_AT_SP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (ISO_OFF_SOFT & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (PSW_ON_SOFT & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (PSW_OFF_SOFT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (ISO_ON_SOFT & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (PWR_OFF_AT_SUSPEND & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PWR_OFF_AT_STOP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PWR_OFF_AT_WAIT & 0b1u) << 1u;

        BPC_POWER_CTRL = curr;
    }

    /**
     * Get BPC_FLAG's PDN_FLAG bit.
     *
     * set to 1 after power switch off, cleared by writing 1
     */
    inline bool get_BPC_FLAG_PDN_FLAG() volatile
    {
        return BPC_FLAG & (1u << 0u);
    }

    /**
     * Set BPC_FLAG's PDN_FLAG bit.
     *
     * set to 1 after power switch off, cleared by writing 1
     */
    inline void set_BPC_FLAG_PDN_FLAG() volatile
    {
        BPC_FLAG |= 1u << 0u;
    }

    /**
     * Clear BPC_FLAG's PDN_FLAG bit.
     *
     * set to 1 after power switch off, cleared by writing 1
     */
    inline void clear_BPC_FLAG_PDN_FLAG() volatile
    {
        BPC_FLAG &= ~(1u << 0u);
    }

    /**
     * Toggle BPC_FLAG's PDN_FLAG bit.
     *
     * set to 1 after power switch off, cleared by writing 1
     */
    inline void toggle_BPC_FLAG_PDN_FLAG() volatile
    {
        BPC_FLAG ^= 1u << 0u;
    }

    /**
     * Get BPC_SSAR_SAVE_CTRL's SAVE_AT_SP field.
     *
     * Save data when system enters a Setpoint.
     */
    inline uint16_t get_BPC_SSAR_SAVE_CTRL_SAVE_AT_SP() volatile
    {
        return (BPC_SSAR_SAVE_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set BPC_SSAR_SAVE_CTRL's SAVE_AT_SP field.
     *
     * Save data when system enters a Setpoint.
     */
    inline void set_BPC_SSAR_SAVE_CTRL_SAVE_AT_SP(uint16_t value) volatile
    {
        uint32_t curr = BPC_SSAR_SAVE_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        BPC_SSAR_SAVE_CTRL = curr;
    }

    /**
     * Get BPC_SSAR_SAVE_CTRL's SAVE_AT_SUSPEND bit.
     *
     * Save data when domain enters SUSPEND mode
     */
    inline bool get_BPC_SSAR_SAVE_CTRL_SAVE_AT_SUSPEND() volatile
    {
        return BPC_SSAR_SAVE_CTRL & (1u << 3u);
    }

    /**
     * Set BPC_SSAR_SAVE_CTRL's SAVE_AT_SUSPEND bit.
     *
     * Save data when domain enters SUSPEND mode
     */
    inline void set_BPC_SSAR_SAVE_CTRL_SAVE_AT_SUSPEND() volatile
    {
        BPC_SSAR_SAVE_CTRL |= 1u << 3u;
    }

    /**
     * Clear BPC_SSAR_SAVE_CTRL's SAVE_AT_SUSPEND bit.
     *
     * Save data when domain enters SUSPEND mode
     */
    inline void clear_BPC_SSAR_SAVE_CTRL_SAVE_AT_SUSPEND() volatile
    {
        BPC_SSAR_SAVE_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle BPC_SSAR_SAVE_CTRL's SAVE_AT_SUSPEND bit.
     *
     * Save data when domain enters SUSPEND mode
     */
    inline void toggle_BPC_SSAR_SAVE_CTRL_SAVE_AT_SUSPEND() volatile
    {
        BPC_SSAR_SAVE_CTRL ^= 1u << 3u;
    }

    /**
     * Get BPC_SSAR_SAVE_CTRL's SAVE_AT_STOP bit.
     *
     * Save data when domain enters STOP mode
     */
    inline bool get_BPC_SSAR_SAVE_CTRL_SAVE_AT_STOP() volatile
    {
        return BPC_SSAR_SAVE_CTRL & (1u << 2u);
    }

    /**
     * Set BPC_SSAR_SAVE_CTRL's SAVE_AT_STOP bit.
     *
     * Save data when domain enters STOP mode
     */
    inline void set_BPC_SSAR_SAVE_CTRL_SAVE_AT_STOP() volatile
    {
        BPC_SSAR_SAVE_CTRL |= 1u << 2u;
    }

    /**
     * Clear BPC_SSAR_SAVE_CTRL's SAVE_AT_STOP bit.
     *
     * Save data when domain enters STOP mode
     */
    inline void clear_BPC_SSAR_SAVE_CTRL_SAVE_AT_STOP() volatile
    {
        BPC_SSAR_SAVE_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle BPC_SSAR_SAVE_CTRL's SAVE_AT_STOP bit.
     *
     * Save data when domain enters STOP mode
     */
    inline void toggle_BPC_SSAR_SAVE_CTRL_SAVE_AT_STOP() volatile
    {
        BPC_SSAR_SAVE_CTRL ^= 1u << 2u;
    }

    /**
     * Get BPC_SSAR_SAVE_CTRL's SAVE_AT_WAIT bit.
     *
     * Save data when domain enters WAIT mode
     */
    inline bool get_BPC_SSAR_SAVE_CTRL_SAVE_AT_WAIT() volatile
    {
        return BPC_SSAR_SAVE_CTRL & (1u << 1u);
    }

    /**
     * Set BPC_SSAR_SAVE_CTRL's SAVE_AT_WAIT bit.
     *
     * Save data when domain enters WAIT mode
     */
    inline void set_BPC_SSAR_SAVE_CTRL_SAVE_AT_WAIT() volatile
    {
        BPC_SSAR_SAVE_CTRL |= 1u << 1u;
    }

    /**
     * Clear BPC_SSAR_SAVE_CTRL's SAVE_AT_WAIT bit.
     *
     * Save data when domain enters WAIT mode
     */
    inline void clear_BPC_SSAR_SAVE_CTRL_SAVE_AT_WAIT() volatile
    {
        BPC_SSAR_SAVE_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle BPC_SSAR_SAVE_CTRL's SAVE_AT_WAIT bit.
     *
     * Save data when domain enters WAIT mode
     */
    inline void toggle_BPC_SSAR_SAVE_CTRL_SAVE_AT_WAIT() volatile
    {
        BPC_SSAR_SAVE_CTRL ^= 1u << 1u;
    }

    /**
     * Get BPC_SSAR_SAVE_CTRL's SAVE_AT_RUN bit.
     *
     * Save data at RUN mode, software writting 0x1 to trigger SSARC to execute
     * save process
     */
    inline bool get_BPC_SSAR_SAVE_CTRL_SAVE_AT_RUN() volatile
    {
        return BPC_SSAR_SAVE_CTRL & (1u << 0u);
    }

    /**
     * Set BPC_SSAR_SAVE_CTRL's SAVE_AT_RUN bit.
     *
     * Save data at RUN mode, software writting 0x1 to trigger SSARC to execute
     * save process
     */
    inline void set_BPC_SSAR_SAVE_CTRL_SAVE_AT_RUN() volatile
    {
        BPC_SSAR_SAVE_CTRL |= 1u << 0u;
    }

    /**
     * Clear BPC_SSAR_SAVE_CTRL's SAVE_AT_RUN bit.
     *
     * Save data at RUN mode, software writting 0x1 to trigger SSARC to execute
     * save process
     */
    inline void clear_BPC_SSAR_SAVE_CTRL_SAVE_AT_RUN() volatile
    {
        BPC_SSAR_SAVE_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle BPC_SSAR_SAVE_CTRL's SAVE_AT_RUN bit.
     *
     * Save data at RUN mode, software writting 0x1 to trigger SSARC to execute
     * save process
     */
    inline void toggle_BPC_SSAR_SAVE_CTRL_SAVE_AT_RUN() volatile
    {
        BPC_SSAR_SAVE_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of BPC_SSAR_SAVE_CTRL's bit fields.
     *
     * (read-write) BPC SSAR save control
     */
    inline void get_BPC_SSAR_SAVE_CTRL(uint16_t &SAVE_AT_SP,
                                       bool &SAVE_AT_SUSPEND,
                                       bool &SAVE_AT_STOP, bool &SAVE_AT_WAIT,
                                       bool &SAVE_AT_RUN) volatile
    {
        uint32_t curr = BPC_SSAR_SAVE_CTRL;

        SAVE_AT_SP = (curr >> 16u) & 0b1111111111111111u;
        SAVE_AT_SUSPEND = curr & (1u << 3u);
        SAVE_AT_STOP = curr & (1u << 2u);
        SAVE_AT_WAIT = curr & (1u << 1u);
        SAVE_AT_RUN = curr & (1u << 0u);
    }

    /**
     * Set all of BPC_SSAR_SAVE_CTRL's bit fields.
     *
     * (read-write) BPC SSAR save control
     */
    inline void set_BPC_SSAR_SAVE_CTRL(uint16_t SAVE_AT_SP,
                                       bool SAVE_AT_SUSPEND, bool SAVE_AT_STOP,
                                       bool SAVE_AT_WAIT,
                                       bool SAVE_AT_RUN) volatile
    {
        uint32_t curr = BPC_SSAR_SAVE_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (SAVE_AT_SP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (SAVE_AT_SUSPEND & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SAVE_AT_STOP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SAVE_AT_WAIT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SAVE_AT_RUN & 0b1u) << 0u;

        BPC_SSAR_SAVE_CTRL = curr;
    }

    /**
     * Get BPC_SSAR_RESTORE_CTRL's RESTORE_AT_SP field.
     *
     * Restore data when system enters a Setpoint.
     */
    inline uint16_t get_BPC_SSAR_RESTORE_CTRL_RESTORE_AT_SP() volatile
    {
        return (BPC_SSAR_RESTORE_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set BPC_SSAR_RESTORE_CTRL's RESTORE_AT_SP field.
     *
     * Restore data when system enters a Setpoint.
     */
    inline void set_BPC_SSAR_RESTORE_CTRL_RESTORE_AT_SP(
        uint16_t value) volatile
    {
        uint32_t curr = BPC_SSAR_RESTORE_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        BPC_SSAR_RESTORE_CTRL = curr;
    }

    /**
     * Get BPC_SSAR_RESTORE_CTRL's RESTORE_AT_RUN bit.
     *
     * Restore data at RUN mode
     */
    inline bool get_BPC_SSAR_RESTORE_CTRL_RESTORE_AT_RUN() volatile
    {
        return BPC_SSAR_RESTORE_CTRL & (1u << 0u);
    }

    /**
     * Set BPC_SSAR_RESTORE_CTRL's RESTORE_AT_RUN bit.
     *
     * Restore data at RUN mode
     */
    inline void set_BPC_SSAR_RESTORE_CTRL_RESTORE_AT_RUN() volatile
    {
        BPC_SSAR_RESTORE_CTRL |= 1u << 0u;
    }

    /**
     * Clear BPC_SSAR_RESTORE_CTRL's RESTORE_AT_RUN bit.
     *
     * Restore data at RUN mode
     */
    inline void clear_BPC_SSAR_RESTORE_CTRL_RESTORE_AT_RUN() volatile
    {
        BPC_SSAR_RESTORE_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle BPC_SSAR_RESTORE_CTRL's RESTORE_AT_RUN bit.
     *
     * Restore data at RUN mode
     */
    inline void toggle_BPC_SSAR_RESTORE_CTRL_RESTORE_AT_RUN() volatile
    {
        BPC_SSAR_RESTORE_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of BPC_SSAR_RESTORE_CTRL's bit fields.
     *
     * (read-write) BPC SSAR restore control
     */
    inline void get_BPC_SSAR_RESTORE_CTRL(uint16_t &RESTORE_AT_SP,
                                          bool &RESTORE_AT_RUN) volatile
    {
        uint32_t curr = BPC_SSAR_RESTORE_CTRL;

        RESTORE_AT_SP = (curr >> 16u) & 0b1111111111111111u;
        RESTORE_AT_RUN = curr & (1u << 0u);
    }

    /**
     * Set all of BPC_SSAR_RESTORE_CTRL's bit fields.
     *
     * (read-write) BPC SSAR restore control
     */
    inline void set_BPC_SSAR_RESTORE_CTRL(uint16_t RESTORE_AT_SP,
                                          bool RESTORE_AT_RUN) volatile
    {
        uint32_t curr = BPC_SSAR_RESTORE_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (RESTORE_AT_SP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 0u);
        curr |= (RESTORE_AT_RUN & 0b1u) << 0u;

        BPC_SSAR_RESTORE_CTRL = curr;
    }
};

static_assert(sizeof(pgmc_bpc0) == pgmc_bpc0::size);

static volatile pgmc_bpc0 *const PGMC_BPC0 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88000);

static volatile pgmc_bpc0 *const PGMC_BPC1 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88200);

static volatile pgmc_bpc0 *const PGMC_BPC2 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88400);

static volatile pgmc_bpc0 *const PGMC_BPC3 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88600);

static volatile pgmc_bpc0 *const PGMC_BPC4 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88800);

static volatile pgmc_bpc0 *const PGMC_BPC5 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88A00);

static volatile pgmc_bpc0 *const PGMC_BPC6 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88C00);

static volatile pgmc_bpc0 *const PGMC_BPC7 =
    reinterpret_cast<pgmc_bpc0 *>(0x40C88E00);

}; // namespace MIMXRT1176::CM7
