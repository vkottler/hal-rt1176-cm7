/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/FLEXSPI1_AHBCR_ALIGNMENT.h"
#include "../enums/FLEXSPI1_AHBCR_SPLIT_LIMIT.h"
#include "../enums/FLEXSPI1_FLSHCR2_AWRWAITUNIT.h"
#include "../enums/FLEXSPI1_HMSTR0CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR1CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR2CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR3CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR4CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR5CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR6CR_MASK.h"
#include "../enums/FLEXSPI1_HMSTR7CR_MASK.h"
#include "../enums/FLEXSPI1_MCR0_RXCLKSRC.h"
#include "../enums/FLEXSPI1_MCR0_SERCLKDIV.h"
#include "../enums/FLEXSPI1_STS0_ARBCMDSRC.h"
#include "../enums/FLEXSPI1_STS1_AHBCMDERRCODE.h"
#include "../enums/FLEXSPI1_STS1_IPCMDERRCODE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * FlexSPI
 */
struct [[gnu::packed]] flexspi1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 1120; /*!< flexspi1's size in bytes. */

    /* Fields. */
    uint32_t MCR0;   /*!< (read-write) Module Control Register 0 */
    uint32_t MCR1;   /*!< (read-write) Module Control Register 1 */
    uint32_t MCR2;   /*!< (read-write) Module Control Register 2 */
    uint32_t AHBCR;  /*!< (read-write) AHB Bus Control Register */
    uint32_t INTEN;  /*!< (read-write) Interrupt Enable Register */
    uint32_t INTR;   /*!< (read-write) Interrupt Register */
    uint32_t LUTKEY; /*!< (read-write) LUT Key Register */
    uint32_t LUTCR;  /*!< (read-write) LUT Control Register */
    uint32_t
        AHBRXBUF0CR0; /*!< (read-write) AHB RX Buffer 0 Control Register 0 */
    uint32_t
        AHBRXBUF1CR0; /*!< (read-write) AHB RX Buffer 1 Control Register 0 */
    uint32_t
        AHBRXBUF2CR0; /*!< (read-write) AHB RX Buffer 2 Control Register 0 */
    uint32_t
        AHBRXBUF3CR0; /*!< (read-write) AHB RX Buffer 3 Control Register 0 */
    uint32_t
        AHBRXBUF4CR0; /*!< (read-write) AHB RX Buffer 4 Control Register 0 */
    uint32_t
        AHBRXBUF5CR0; /*!< (read-write) AHB RX Buffer 5 Control Register 0 */
    uint32_t
        AHBRXBUF6CR0; /*!< (read-write) AHB RX Buffer 6 Control Register 0 */
    uint32_t
        AHBRXBUF7CR0; /*!< (read-write) AHB RX Buffer 7 Control Register 0 */
    static constexpr std::size_t reserved_padding0_length = 8;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t FLSHA1CR0; /*!< (read-write) Flash Control Register 0 */
    uint32_t FLSHA2CR0; /*!< (read-write) Flash Control Register 0 */
    uint32_t FLSHB1CR0; /*!< (read-write) Flash Control Register 0 */
    uint32_t FLSHB2CR0; /*!< (read-write) Flash Control Register 0 */
    static constexpr std::size_t FLSHCR1_length = 4;
    uint32_t
        FLSHCR1[FLSHCR1_length]; /*!< (read-write) Flash Control Register 1 */
    static constexpr std::size_t FLSHCR2_length = 4;
    uint32_t
        FLSHCR2[FLSHCR2_length]; /*!< (read-write) Flash Control Register 2 */
    const uint32_t reserved_padding1 = {};
    uint32_t FLSHCR4; /*!< (read-write) Flash Control Register 4 */
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t IPCR0; /*!< (read-write) IP Control Register 0 */
    uint32_t IPCR1; /*!< (read-write) IP Control Register 1 */
    static constexpr std::size_t reserved_padding3_length = 2;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t IPCMD; /*!< (read-write) IP Command Register */
    const uint32_t reserved_padding4 = {};
    uint32_t IPRXFCR; /*!< (read-write) IP RX FIFO Control Register */
    uint32_t IPTXFCR; /*!< (read-write) IP TX FIFO Control Register */
    static constexpr std::size_t DLLCR_length = 2;
    uint32_t DLLCR[DLLCR_length]; /*!< (read-write) DLL Control Register 0 */
    static constexpr std::size_t reserved_padding5_length = 2;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t MISCCR4;    /*!< (read-write) Misc Control Register 4 */
    uint32_t MISCCR5;    /*!< (read-write) Misc Control Register 5 */
    uint32_t MISCCR6;    /*!< (read-write) Misc Control Register 6 */
    uint32_t MISCCR7;    /*!< (read-write) Misc Control Register 7 */
    uint32_t STS0;       /*!< (read-write) Status Register 0 */
    uint32_t STS1;       /*!< (read-write) Status Register 1 */
    uint32_t STS2;       /*!< (read-write) Status Register 2 */
    uint32_t AHBSPNDSTS; /*!< (read-write) AHB Suspend Status Register */
    uint32_t IPRXFSTS;   /*!< (read-write) IP RX FIFO Status Register */
    uint32_t IPTXFSTS;   /*!< (read-write) IP TX FIFO Status Register */
    static constexpr std::size_t reserved_padding6_length = 2;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    static constexpr std::size_t RFDR_length = 32;
    uint32_t RFDR[RFDR_length]; /*!< (read-write) IP RX FIFO Data Register x */
    static constexpr std::size_t TFDR_length = 32;
    uint32_t TFDR[TFDR_length]; /*!< (read-write) IP TX FIFO Data Register x */
    static constexpr std::size_t LUT_length = 64;
    uint32_t LUT[LUT_length]; /*!< (read-write) LUT x */
    static constexpr std::size_t reserved_padding7_length = 64;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t HMSTR0CR;    /*!< (read-write) AHB Master ID 0 Control Register */
    uint32_t HMSTR1CR;    /*!< (read-write) AHB Master ID 1 Control Register */
    uint32_t HMSTR2CR;    /*!< (read-write) AHB Master ID 2 Control Register */
    uint32_t HMSTR3CR;    /*!< (read-write) AHB Master ID 3 Control Register */
    uint32_t HMSTR4CR;    /*!< (read-write) AHB Master ID 4 Control Register */
    uint32_t HMSTR5CR;    /*!< (read-write) AHB Master ID 5 Control Register */
    uint32_t HMSTR6CR;    /*!< (read-write) AHB Master ID 6 Control Register */
    uint32_t HMSTR7CR;    /*!< (read-write) AHB Master ID 7 Control Register */
    uint32_t HADDRSTART;  /*!< (read-write) HADDR REMAP START ADDR */
    uint32_t HADDREND;    /*!< (read-write) HADDR REMAP END ADDR */
    uint32_t HADDROFFSET; /*!< (read-write) HADDR REMAP OFFSET */
    const uint32_t reserved_padding8 = {};
    uint32_t IPSNSZSTART0; /*!< (read-write) IPS nonsecure region Start address
                              of region 0 */
    uint32_t IPSNSZEND0; /*!< (read-write) IPS nonsecure region End address of
                            region 0 */
    uint32_t IPSNSZSTART1; /*!< (read-write) IPS nonsecure region Start address
                              of region 1 */
    uint32_t IPSNSZEND1; /*!< (read-write) IPS nonsecure region End address of
                            region 1 */
    uint32_t AHBBUFREGIONSTART0; /*!< (read-write) RX BUF Start address of
                                    region 0 */
    uint32_t AHBBUFREGIONEND0;   /*!< (read-write) RX BUF region End address of
                                    region 0 */
    uint32_t AHBBUFREGIONSTART1; /*!< (read-write) RX BUF Start address of
                                    region 1 */
    uint32_t AHBBUFREGIONEND1;   /*!< (read-write) RX BUF region End address of
                                    region 1 */
    uint32_t AHBBUFREGIONSTART2; /*!< (read-write) RX BUF Start address of
                                    region 2 */
    uint32_t AHBBUFREGIONEND2;   /*!< (read-write) RX BUF region End address of
                                    region 2 */
    uint32_t AHBBUFREGIONSTART3; /*!< (read-write) RX BUF Start address of
                                    region 3 */
    uint32_t AHBBUFREGIONEND3;   /*!< (read-write) RX BUF region End address of
                                    region 3 */

    /* Methods. */

    /**
     * Get MCR0's AHBGRANTWAIT field.
     *
     * Timeout wait cycle for AHB command grant.
     */
    inline uint8_t get_MCR0_AHBGRANTWAIT() volatile
    {
        return (MCR0 >> 24u) & 0b11111111u;
    }

    /**
     * Set MCR0's AHBGRANTWAIT field.
     *
     * Timeout wait cycle for AHB command grant.
     */
    inline void set_MCR0_AHBGRANTWAIT(uint8_t value) volatile
    {
        uint32_t curr = MCR0;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        MCR0 = curr;
    }

    /**
     * Get MCR0's IPGRANTWAIT field.
     *
     * Time out wait cycle for IP command grant.
     */
    inline uint8_t get_MCR0_IPGRANTWAIT() volatile
    {
        return (MCR0 >> 16u) & 0b11111111u;
    }

    /**
     * Set MCR0's IPGRANTWAIT field.
     *
     * Time out wait cycle for IP command grant.
     */
    inline void set_MCR0_IPGRANTWAIT(uint8_t value) volatile
    {
        uint32_t curr = MCR0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MCR0 = curr;
    }

    /**
     * Get MCR0's SCKFREERUNEN bit.
     *
     * This bit is used to force SCLK output free-running. For FPGA
     * applications, external device may use SCLK as reference clock to its
     * internal PLL. If SCLK free-running is enabled, data sampling with
     * loopback clock from SCLK pad is not supported (MCR0[RXCLKSRC]=2).
     */
    inline bool get_MCR0_SCKFREERUNEN() volatile
    {
        return MCR0 & (1u << 14u);
    }

    /**
     * Set MCR0's SCKFREERUNEN bit.
     *
     * This bit is used to force SCLK output free-running. For FPGA
     * applications, external device may use SCLK as reference clock to its
     * internal PLL. If SCLK free-running is enabled, data sampling with
     * loopback clock from SCLK pad is not supported (MCR0[RXCLKSRC]=2).
     */
    inline void set_MCR0_SCKFREERUNEN() volatile
    {
        MCR0 |= 1u << 14u;
    }

    /**
     * Clear MCR0's SCKFREERUNEN bit.
     *
     * This bit is used to force SCLK output free-running. For FPGA
     * applications, external device may use SCLK as reference clock to its
     * internal PLL. If SCLK free-running is enabled, data sampling with
     * loopback clock from SCLK pad is not supported (MCR0[RXCLKSRC]=2).
     */
    inline void clear_MCR0_SCKFREERUNEN() volatile
    {
        MCR0 &= ~(1u << 14u);
    }

    /**
     * Toggle MCR0's SCKFREERUNEN bit.
     *
     * This bit is used to force SCLK output free-running. For FPGA
     * applications, external device may use SCLK as reference clock to its
     * internal PLL. If SCLK free-running is enabled, data sampling with
     * loopback clock from SCLK pad is not supported (MCR0[RXCLKSRC]=2).
     */
    inline void toggle_MCR0_SCKFREERUNEN() volatile
    {
        MCR0 ^= 1u << 14u;
    }

    /**
     * Get MCR0's COMBINATIONEN bit.
     *
     * This bit is to support Flash Octal mode access by combining Port A and B
     * Data pins (A_DATA[3:0] and B_DATA[3:0]), when Port A and Port B are of 4
     * bit data width.
     */
    inline bool get_MCR0_COMBINATIONEN() volatile
    {
        return MCR0 & (1u << 13u);
    }

    /**
     * Set MCR0's COMBINATIONEN bit.
     *
     * This bit is to support Flash Octal mode access by combining Port A and B
     * Data pins (A_DATA[3:0] and B_DATA[3:0]), when Port A and Port B are of 4
     * bit data width.
     */
    inline void set_MCR0_COMBINATIONEN() volatile
    {
        MCR0 |= 1u << 13u;
    }

    /**
     * Clear MCR0's COMBINATIONEN bit.
     *
     * This bit is to support Flash Octal mode access by combining Port A and B
     * Data pins (A_DATA[3:0] and B_DATA[3:0]), when Port A and Port B are of 4
     * bit data width.
     */
    inline void clear_MCR0_COMBINATIONEN() volatile
    {
        MCR0 &= ~(1u << 13u);
    }

    /**
     * Toggle MCR0's COMBINATIONEN bit.
     *
     * This bit is to support Flash Octal mode access by combining Port A and B
     * Data pins (A_DATA[3:0] and B_DATA[3:0]), when Port A and Port B are of 4
     * bit data width.
     */
    inline void toggle_MCR0_COMBINATIONEN() volatile
    {
        MCR0 ^= 1u << 13u;
    }

    /**
     * Get MCR0's DOZEEN bit.
     *
     * Doze mode enable bit
     */
    inline bool get_MCR0_DOZEEN() volatile
    {
        return MCR0 & (1u << 12u);
    }

    /**
     * Set MCR0's DOZEEN bit.
     *
     * Doze mode enable bit
     */
    inline void set_MCR0_DOZEEN() volatile
    {
        MCR0 |= 1u << 12u;
    }

    /**
     * Clear MCR0's DOZEEN bit.
     *
     * Doze mode enable bit
     */
    inline void clear_MCR0_DOZEEN() volatile
    {
        MCR0 &= ~(1u << 12u);
    }

    /**
     * Toggle MCR0's DOZEEN bit.
     *
     * Doze mode enable bit
     */
    inline void toggle_MCR0_DOZEEN() volatile
    {
        MCR0 ^= 1u << 12u;
    }

    /**
     * Get MCR0's HSEN bit.
     *
     * Half Speed Serial Flash access Enable.
     */
    inline bool get_MCR0_HSEN() volatile
    {
        return MCR0 & (1u << 11u);
    }

    /**
     * Set MCR0's HSEN bit.
     *
     * Half Speed Serial Flash access Enable.
     */
    inline void set_MCR0_HSEN() volatile
    {
        MCR0 |= 1u << 11u;
    }

    /**
     * Clear MCR0's HSEN bit.
     *
     * Half Speed Serial Flash access Enable.
     */
    inline void clear_MCR0_HSEN() volatile
    {
        MCR0 &= ~(1u << 11u);
    }

    /**
     * Toggle MCR0's HSEN bit.
     *
     * Half Speed Serial Flash access Enable.
     */
    inline void toggle_MCR0_HSEN() volatile
    {
        MCR0 ^= 1u << 11u;
    }

    /**
     * Get MCR0's SERCLKDIV field.
     *
     * The serial root clock could be divided inside FlexSPI . Refer Clocks
     * chapter for more details on clocking.
     */
    inline FLEXSPI1_MCR0_SERCLKDIV get_MCR0_SERCLKDIV() volatile
    {
        return FLEXSPI1_MCR0_SERCLKDIV((MCR0 >> 8u) & 0b111u);
    }

    /**
     * Set MCR0's SERCLKDIV field.
     *
     * The serial root clock could be divided inside FlexSPI . Refer Clocks
     * chapter for more details on clocking.
     */
    inline void set_MCR0_SERCLKDIV(FLEXSPI1_MCR0_SERCLKDIV value) volatile
    {
        uint32_t curr = MCR0;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        MCR0 = curr;
    }

    /**
     * Get MCR0's ATDFEN bit.
     *
     * Enable AHB bus Write Access to IP TX FIFO.
     */
    inline bool get_MCR0_ATDFEN() volatile
    {
        return MCR0 & (1u << 7u);
    }

    /**
     * Set MCR0's ATDFEN bit.
     *
     * Enable AHB bus Write Access to IP TX FIFO.
     */
    inline void set_MCR0_ATDFEN() volatile
    {
        MCR0 |= 1u << 7u;
    }

    /**
     * Clear MCR0's ATDFEN bit.
     *
     * Enable AHB bus Write Access to IP TX FIFO.
     */
    inline void clear_MCR0_ATDFEN() volatile
    {
        MCR0 &= ~(1u << 7u);
    }

    /**
     * Toggle MCR0's ATDFEN bit.
     *
     * Enable AHB bus Write Access to IP TX FIFO.
     */
    inline void toggle_MCR0_ATDFEN() volatile
    {
        MCR0 ^= 1u << 7u;
    }

    /**
     * Get MCR0's ARDFEN bit.
     *
     * Enable AHB bus Read Access to IP RX FIFO.
     */
    inline bool get_MCR0_ARDFEN() volatile
    {
        return MCR0 & (1u << 6u);
    }

    /**
     * Set MCR0's ARDFEN bit.
     *
     * Enable AHB bus Read Access to IP RX FIFO.
     */
    inline void set_MCR0_ARDFEN() volatile
    {
        MCR0 |= 1u << 6u;
    }

    /**
     * Clear MCR0's ARDFEN bit.
     *
     * Enable AHB bus Read Access to IP RX FIFO.
     */
    inline void clear_MCR0_ARDFEN() volatile
    {
        MCR0 &= ~(1u << 6u);
    }

    /**
     * Toggle MCR0's ARDFEN bit.
     *
     * Enable AHB bus Read Access to IP RX FIFO.
     */
    inline void toggle_MCR0_ARDFEN() volatile
    {
        MCR0 ^= 1u << 6u;
    }

    /**
     * Get MCR0's RXCLKSRC field.
     *
     * Sample Clock source selection for Flash Reading
     */
    inline FLEXSPI1_MCR0_RXCLKSRC get_MCR0_RXCLKSRC() volatile
    {
        return FLEXSPI1_MCR0_RXCLKSRC((MCR0 >> 4u) & 0b11u);
    }

    /**
     * Set MCR0's RXCLKSRC field.
     *
     * Sample Clock source selection for Flash Reading
     */
    inline void set_MCR0_RXCLKSRC(FLEXSPI1_MCR0_RXCLKSRC value) volatile
    {
        uint32_t curr = MCR0;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        MCR0 = curr;
    }

    /**
     * Get MCR0's MDIS bit.
     *
     * Module Disable
     */
    inline bool get_MCR0_MDIS() volatile
    {
        return MCR0 & (1u << 1u);
    }

    /**
     * Set MCR0's MDIS bit.
     *
     * Module Disable
     */
    inline void set_MCR0_MDIS() volatile
    {
        MCR0 |= 1u << 1u;
    }

    /**
     * Clear MCR0's MDIS bit.
     *
     * Module Disable
     */
    inline void clear_MCR0_MDIS() volatile
    {
        MCR0 &= ~(1u << 1u);
    }

    /**
     * Toggle MCR0's MDIS bit.
     *
     * Module Disable
     */
    inline void toggle_MCR0_MDIS() volatile
    {
        MCR0 ^= 1u << 1u;
    }

    /**
     * Get MCR0's SWRESET bit.
     *
     * Software Reset
     */
    inline bool get_MCR0_SWRESET() volatile
    {
        return MCR0 & (1u << 0u);
    }

    /**
     * Set MCR0's SWRESET bit.
     *
     * Software Reset
     */
    inline void set_MCR0_SWRESET() volatile
    {
        MCR0 |= 1u << 0u;
    }

    /**
     * Clear MCR0's SWRESET bit.
     *
     * Software Reset
     */
    inline void clear_MCR0_SWRESET() volatile
    {
        MCR0 &= ~(1u << 0u);
    }

    /**
     * Toggle MCR0's SWRESET bit.
     *
     * Software Reset
     */
    inline void toggle_MCR0_SWRESET() volatile
    {
        MCR0 ^= 1u << 0u;
    }

    /**
     * Get all of MCR0's bit fields.
     *
     * (read-write) Module Control Register 0
     */
    inline void get_MCR0(uint8_t &AHBGRANTWAIT, uint8_t &IPGRANTWAIT,
                         bool &SCKFREERUNEN, bool &COMBINATIONEN, bool &DOZEEN,
                         bool &HSEN, FLEXSPI1_MCR0_SERCLKDIV &SERCLKDIV,
                         bool &ATDFEN, bool &ARDFEN,
                         FLEXSPI1_MCR0_RXCLKSRC &RXCLKSRC, bool &MDIS,
                         bool &SWRESET) volatile
    {
        uint32_t curr = MCR0;

        AHBGRANTWAIT = (curr >> 24u) & 0b11111111u;
        IPGRANTWAIT = (curr >> 16u) & 0b11111111u;
        SCKFREERUNEN = curr & (1u << 14u);
        COMBINATIONEN = curr & (1u << 13u);
        DOZEEN = curr & (1u << 12u);
        HSEN = curr & (1u << 11u);
        SERCLKDIV = FLEXSPI1_MCR0_SERCLKDIV((curr >> 8u) & 0b111u);
        ATDFEN = curr & (1u << 7u);
        ARDFEN = curr & (1u << 6u);
        RXCLKSRC = FLEXSPI1_MCR0_RXCLKSRC((curr >> 4u) & 0b11u);
        MDIS = curr & (1u << 1u);
        SWRESET = curr & (1u << 0u);
    }

    /**
     * Set all of MCR0's bit fields.
     *
     * (read-write) Module Control Register 0
     */
    inline void set_MCR0(uint8_t AHBGRANTWAIT, uint8_t IPGRANTWAIT,
                         bool SCKFREERUNEN, bool COMBINATIONEN, bool DOZEEN,
                         bool HSEN, FLEXSPI1_MCR0_SERCLKDIV SERCLKDIV,
                         bool ATDFEN, bool ARDFEN,
                         FLEXSPI1_MCR0_RXCLKSRC RXCLKSRC, bool MDIS,
                         bool SWRESET) volatile
    {
        uint32_t curr = MCR0;

        curr &= ~(0b11111111u << 24u);
        curr |= (AHBGRANTWAIT & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (IPGRANTWAIT & 0b11111111u) << 16u;
        curr &= ~(0b1u << 14u);
        curr |= (SCKFREERUNEN & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (COMBINATIONEN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (DOZEEN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (HSEN & 0b1u) << 11u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(SERCLKDIV) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ATDFEN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ARDFEN & 0b1u) << 6u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(RXCLKSRC) & 0b11u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (MDIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SWRESET & 0b1u) << 0u;

        MCR0 = curr;
    }

    /**
     * Get MCR1's SEQWAIT field.
     *
     * Command Sequence Execution will timeout and abort after SEQWAIT * 1024
     * Serial Root Clock cycles
     */
    inline uint16_t get_MCR1_SEQWAIT() volatile
    {
        return (MCR1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MCR1's SEQWAIT field.
     *
     * Command Sequence Execution will timeout and abort after SEQWAIT * 1024
     * Serial Root Clock cycles
     */
    inline void set_MCR1_SEQWAIT(uint16_t value) volatile
    {
        uint32_t curr = MCR1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MCR1 = curr;
    }

    /**
     * Get MCR1's AHBBUSWAIT field.
     *
     * AHB Read/Write access to Serial Flash Memory space will timeout if not
     * data received from Flash or data not transmitted after AHBBUSWAIT * 1024
     * ahb clock cycles, AHB Bus will get an error response
     */
    inline uint16_t get_MCR1_AHBBUSWAIT() volatile
    {
        return (MCR1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MCR1's AHBBUSWAIT field.
     *
     * AHB Read/Write access to Serial Flash Memory space will timeout if not
     * data received from Flash or data not transmitted after AHBBUSWAIT * 1024
     * ahb clock cycles, AHB Bus will get an error response
     */
    inline void set_MCR1_AHBBUSWAIT(uint16_t value) volatile
    {
        uint32_t curr = MCR1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MCR1 = curr;
    }

    /**
     * Get all of MCR1's bit fields.
     *
     * (read-write) Module Control Register 1
     */
    inline void get_MCR1(uint16_t &SEQWAIT, uint16_t &AHBBUSWAIT) volatile
    {
        uint32_t curr = MCR1;

        SEQWAIT = (curr >> 16u) & 0b1111111111111111u;
        AHBBUSWAIT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MCR1's bit fields.
     *
     * (read-write) Module Control Register 1
     */
    inline void set_MCR1(uint16_t SEQWAIT, uint16_t AHBBUSWAIT) volatile
    {
        uint32_t curr = MCR1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (SEQWAIT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (AHBBUSWAIT & 0b1111111111111111u) << 0u;

        MCR1 = curr;
    }

    /**
     * Get MCR2's RESUMEWAIT field.
     *
     * Wait cycle (in AHB clock cycle) for idle state before suspended command
     * sequence resumed.
     */
    inline uint8_t get_MCR2_RESUMEWAIT() volatile
    {
        return (MCR2 >> 24u) & 0b11111111u;
    }

    /**
     * Set MCR2's RESUMEWAIT field.
     *
     * Wait cycle (in AHB clock cycle) for idle state before suspended command
     * sequence resumed.
     */
    inline void set_MCR2_RESUMEWAIT(uint8_t value) volatile
    {
        uint32_t curr = MCR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        MCR2 = curr;
    }

    /**
     * Get MCR2's SCKBDIFFOPT bit.
     *
     * B_SCLK pad can be used as A_SCLK differential clock output (inverted
     * clock to A_SCLK). In this case, port B flash access is not available.
     * After changing the value of this field, MCR0[SWRESET] should be set.
     */
    inline bool get_MCR2_SCKBDIFFOPT() volatile
    {
        return MCR2 & (1u << 19u);
    }

    /**
     * Set MCR2's SCKBDIFFOPT bit.
     *
     * B_SCLK pad can be used as A_SCLK differential clock output (inverted
     * clock to A_SCLK). In this case, port B flash access is not available.
     * After changing the value of this field, MCR0[SWRESET] should be set.
     */
    inline void set_MCR2_SCKBDIFFOPT() volatile
    {
        MCR2 |= 1u << 19u;
    }

    /**
     * Clear MCR2's SCKBDIFFOPT bit.
     *
     * B_SCLK pad can be used as A_SCLK differential clock output (inverted
     * clock to A_SCLK). In this case, port B flash access is not available.
     * After changing the value of this field, MCR0[SWRESET] should be set.
     */
    inline void clear_MCR2_SCKBDIFFOPT() volatile
    {
        MCR2 &= ~(1u << 19u);
    }

    /**
     * Toggle MCR2's SCKBDIFFOPT bit.
     *
     * B_SCLK pad can be used as A_SCLK differential clock output (inverted
     * clock to A_SCLK). In this case, port B flash access is not available.
     * After changing the value of this field, MCR0[SWRESET] should be set.
     */
    inline void toggle_MCR2_SCKBDIFFOPT() volatile
    {
        MCR2 ^= 1u << 19u;
    }

    /**
     * Get MCR2's SAMEDEVICEEN bit.
     *
     * All external devices are same devices (both in types and size) for
     * A1/A2/B1/B2.
     */
    inline bool get_MCR2_SAMEDEVICEEN() volatile
    {
        return MCR2 & (1u << 15u);
    }

    /**
     * Set MCR2's SAMEDEVICEEN bit.
     *
     * All external devices are same devices (both in types and size) for
     * A1/A2/B1/B2.
     */
    inline void set_MCR2_SAMEDEVICEEN() volatile
    {
        MCR2 |= 1u << 15u;
    }

    /**
     * Clear MCR2's SAMEDEVICEEN bit.
     *
     * All external devices are same devices (both in types and size) for
     * A1/A2/B1/B2.
     */
    inline void clear_MCR2_SAMEDEVICEEN() volatile
    {
        MCR2 &= ~(1u << 15u);
    }

    /**
     * Toggle MCR2's SAMEDEVICEEN bit.
     *
     * All external devices are same devices (both in types and size) for
     * A1/A2/B1/B2.
     */
    inline void toggle_MCR2_SAMEDEVICEEN() volatile
    {
        MCR2 ^= 1u << 15u;
    }

    /**
     * Get MCR2's CLRAHBBUFOPT bit.
     *
     * This bit determines whether AHB RX Buffer and AHB TX Buffer will be
     * cleaned automatically when FlexSPI returns STOP mode ACK. Software
     * should set this bit if AHB RX Buffer or AHB TX Buffer will be powered
     * off in STOP mode. Otherwise AHB read access after exiting STOP mode may
     * hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
     */
    inline bool get_MCR2_CLRAHBBUFOPT() volatile
    {
        return MCR2 & (1u << 11u);
    }

    /**
     * Set MCR2's CLRAHBBUFOPT bit.
     *
     * This bit determines whether AHB RX Buffer and AHB TX Buffer will be
     * cleaned automatically when FlexSPI returns STOP mode ACK. Software
     * should set this bit if AHB RX Buffer or AHB TX Buffer will be powered
     * off in STOP mode. Otherwise AHB read access after exiting STOP mode may
     * hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
     */
    inline void set_MCR2_CLRAHBBUFOPT() volatile
    {
        MCR2 |= 1u << 11u;
    }

    /**
     * Clear MCR2's CLRAHBBUFOPT bit.
     *
     * This bit determines whether AHB RX Buffer and AHB TX Buffer will be
     * cleaned automatically when FlexSPI returns STOP mode ACK. Software
     * should set this bit if AHB RX Buffer or AHB TX Buffer will be powered
     * off in STOP mode. Otherwise AHB read access after exiting STOP mode may
     * hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
     */
    inline void clear_MCR2_CLRAHBBUFOPT() volatile
    {
        MCR2 &= ~(1u << 11u);
    }

    /**
     * Toggle MCR2's CLRAHBBUFOPT bit.
     *
     * This bit determines whether AHB RX Buffer and AHB TX Buffer will be
     * cleaned automatically when FlexSPI returns STOP mode ACK. Software
     * should set this bit if AHB RX Buffer or AHB TX Buffer will be powered
     * off in STOP mode. Otherwise AHB read access after exiting STOP mode may
     * hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
     */
    inline void toggle_MCR2_CLRAHBBUFOPT() volatile
    {
        MCR2 ^= 1u << 11u;
    }

    /**
     * Get all of MCR2's bit fields.
     *
     * (read-write) Module Control Register 2
     */
    inline void get_MCR2(uint8_t &RESUMEWAIT, bool &SCKBDIFFOPT,
                         bool &SAMEDEVICEEN, bool &CLRAHBBUFOPT) volatile
    {
        uint32_t curr = MCR2;

        RESUMEWAIT = (curr >> 24u) & 0b11111111u;
        SCKBDIFFOPT = curr & (1u << 19u);
        SAMEDEVICEEN = curr & (1u << 15u);
        CLRAHBBUFOPT = curr & (1u << 11u);
    }

    /**
     * Set all of MCR2's bit fields.
     *
     * (read-write) Module Control Register 2
     */
    inline void set_MCR2(uint8_t RESUMEWAIT, bool SCKBDIFFOPT,
                         bool SAMEDEVICEEN, bool CLRAHBBUFOPT) volatile
    {
        uint32_t curr = MCR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (RESUMEWAIT & 0b11111111u) << 24u;
        curr &= ~(0b1u << 19u);
        curr |= (SCKBDIFFOPT & 0b1u) << 19u;
        curr &= ~(0b1u << 15u);
        curr |= (SAMEDEVICEEN & 0b1u) << 15u;
        curr &= ~(0b1u << 11u);
        curr |= (CLRAHBBUFOPT & 0b1u) << 11u;

        MCR2 = curr;
    }

    /**
     * Get AHBCR's ALIGNMENT field.
     *
     * Decides all AHB read/write boundary. All access cross the boundary will
     * be divided into smaller sub accesses.
     */
    inline FLEXSPI1_AHBCR_ALIGNMENT get_AHBCR_ALIGNMENT() volatile
    {
        return FLEXSPI1_AHBCR_ALIGNMENT((AHBCR >> 20u) & 0b11u);
    }

    /**
     * Set AHBCR's ALIGNMENT field.
     *
     * Decides all AHB read/write boundary. All access cross the boundary will
     * be divided into smaller sub accesses.
     */
    inline void set_AHBCR_ALIGNMENT(FLEXSPI1_AHBCR_ALIGNMENT value) volatile
    {
        uint32_t curr = AHBCR;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(value) & 0b11u) << 20u;

        AHBCR = curr;
    }

    /**
     * Get AHBCR's ECCSWAPEN bit.
     *
     * ECC Read data swap function
     */
    inline bool get_AHBCR_ECCSWAPEN() volatile
    {
        return AHBCR & (1u << 19u);
    }

    /**
     * Set AHBCR's ECCSWAPEN bit.
     *
     * ECC Read data swap function
     */
    inline void set_AHBCR_ECCSWAPEN() volatile
    {
        AHBCR |= 1u << 19u;
    }

    /**
     * Clear AHBCR's ECCSWAPEN bit.
     *
     * ECC Read data swap function
     */
    inline void clear_AHBCR_ECCSWAPEN() volatile
    {
        AHBCR &= ~(1u << 19u);
    }

    /**
     * Toggle AHBCR's ECCSWAPEN bit.
     *
     * ECC Read data swap function
     */
    inline void toggle_AHBCR_ECCSWAPEN() volatile
    {
        AHBCR ^= 1u << 19u;
    }

    /**
     * Get AHBCR's HMSTRIDREMAP bit.
     *
     * AHB Master ID Remapping enable
     */
    inline bool get_AHBCR_HMSTRIDREMAP() volatile
    {
        return AHBCR & (1u << 18u);
    }

    /**
     * Set AHBCR's HMSTRIDREMAP bit.
     *
     * AHB Master ID Remapping enable
     */
    inline void set_AHBCR_HMSTRIDREMAP() volatile
    {
        AHBCR |= 1u << 18u;
    }

    /**
     * Clear AHBCR's HMSTRIDREMAP bit.
     *
     * AHB Master ID Remapping enable
     */
    inline void clear_AHBCR_HMSTRIDREMAP() volatile
    {
        AHBCR &= ~(1u << 18u);
    }

    /**
     * Toggle AHBCR's HMSTRIDREMAP bit.
     *
     * AHB Master ID Remapping enable
     */
    inline void toggle_AHBCR_HMSTRIDREMAP() volatile
    {
        AHBCR ^= 1u << 18u;
    }

    /**
     * Get AHBCR's ECCMULTIERRCLR bit.
     *
     * AHB ECC Multi bits ERR CLR
     */
    inline bool get_AHBCR_ECCMULTIERRCLR() volatile
    {
        return AHBCR & (1u << 17u);
    }

    /**
     * Set AHBCR's ECCMULTIERRCLR bit.
     *
     * AHB ECC Multi bits ERR CLR
     */
    inline void set_AHBCR_ECCMULTIERRCLR() volatile
    {
        AHBCR |= 1u << 17u;
    }

    /**
     * Clear AHBCR's ECCMULTIERRCLR bit.
     *
     * AHB ECC Multi bits ERR CLR
     */
    inline void clear_AHBCR_ECCMULTIERRCLR() volatile
    {
        AHBCR &= ~(1u << 17u);
    }

    /**
     * Toggle AHBCR's ECCMULTIERRCLR bit.
     *
     * AHB ECC Multi bits ERR CLR
     */
    inline void toggle_AHBCR_ECCMULTIERRCLR() volatile
    {
        AHBCR ^= 1u << 17u;
    }

    /**
     * Get AHBCR's ECCSINGLEERRCLR bit.
     *
     * AHB ECC Single bit ERR CLR
     */
    inline bool get_AHBCR_ECCSINGLEERRCLR() volatile
    {
        return AHBCR & (1u << 16u);
    }

    /**
     * Set AHBCR's ECCSINGLEERRCLR bit.
     *
     * AHB ECC Single bit ERR CLR
     */
    inline void set_AHBCR_ECCSINGLEERRCLR() volatile
    {
        AHBCR |= 1u << 16u;
    }

    /**
     * Clear AHBCR's ECCSINGLEERRCLR bit.
     *
     * AHB ECC Single bit ERR CLR
     */
    inline void clear_AHBCR_ECCSINGLEERRCLR() volatile
    {
        AHBCR &= ~(1u << 16u);
    }

    /**
     * Toggle AHBCR's ECCSINGLEERRCLR bit.
     *
     * AHB ECC Single bit ERR CLR
     */
    inline void toggle_AHBCR_ECCSINGLEERRCLR() volatile
    {
        AHBCR ^= 1u << 16u;
    }

    /**
     * Get AHBCR's KEYECCEN bit.
     *
     * OTFAD KEY BLOC ECC Enable
     */
    inline bool get_AHBCR_KEYECCEN() volatile
    {
        return AHBCR & (1u << 15u);
    }

    /**
     * Set AHBCR's KEYECCEN bit.
     *
     * OTFAD KEY BLOC ECC Enable
     */
    inline void set_AHBCR_KEYECCEN() volatile
    {
        AHBCR |= 1u << 15u;
    }

    /**
     * Clear AHBCR's KEYECCEN bit.
     *
     * OTFAD KEY BLOC ECC Enable
     */
    inline void clear_AHBCR_KEYECCEN() volatile
    {
        AHBCR &= ~(1u << 15u);
    }

    /**
     * Toggle AHBCR's KEYECCEN bit.
     *
     * OTFAD KEY BLOC ECC Enable
     */
    inline void toggle_AHBCR_KEYECCEN() volatile
    {
        AHBCR ^= 1u << 15u;
    }

    /**
     * Get AHBCR's SPLIT_LIMIT field.
     *
     * AHB SPLIT SIZE
     */
    inline FLEXSPI1_AHBCR_SPLIT_LIMIT get_AHBCR_SPLIT_LIMIT() volatile
    {
        return FLEXSPI1_AHBCR_SPLIT_LIMIT((AHBCR >> 13u) & 0b11u);
    }

    /**
     * Set AHBCR's SPLIT_LIMIT field.
     *
     * AHB SPLIT SIZE
     */
    inline void set_AHBCR_SPLIT_LIMIT(
        FLEXSPI1_AHBCR_SPLIT_LIMIT value) volatile
    {
        uint32_t curr = AHBCR;

        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(value) & 0b11u) << 13u;

        AHBCR = curr;
    }

    /**
     * Get AHBCR's SPLITEN bit.
     *
     * AHB transaction SPLIT
     */
    inline bool get_AHBCR_SPLITEN() volatile
    {
        return AHBCR & (1u << 12u);
    }

    /**
     * Set AHBCR's SPLITEN bit.
     *
     * AHB transaction SPLIT
     */
    inline void set_AHBCR_SPLITEN() volatile
    {
        AHBCR |= 1u << 12u;
    }

    /**
     * Clear AHBCR's SPLITEN bit.
     *
     * AHB transaction SPLIT
     */
    inline void clear_AHBCR_SPLITEN() volatile
    {
        AHBCR &= ~(1u << 12u);
    }

    /**
     * Toggle AHBCR's SPLITEN bit.
     *
     * AHB transaction SPLIT
     */
    inline void toggle_AHBCR_SPLITEN() volatile
    {
        AHBCR ^= 1u << 12u;
    }

    /**
     * Get AHBCR's ECCEN bit.
     *
     * AHB Read ECC Enable
     */
    inline bool get_AHBCR_ECCEN() volatile
    {
        return AHBCR & (1u << 11u);
    }

    /**
     * Set AHBCR's ECCEN bit.
     *
     * AHB Read ECC Enable
     */
    inline void set_AHBCR_ECCEN() volatile
    {
        AHBCR |= 1u << 11u;
    }

    /**
     * Clear AHBCR's ECCEN bit.
     *
     * AHB Read ECC Enable
     */
    inline void clear_AHBCR_ECCEN() volatile
    {
        AHBCR &= ~(1u << 11u);
    }

    /**
     * Toggle AHBCR's ECCEN bit.
     *
     * AHB Read ECC Enable
     */
    inline void toggle_AHBCR_ECCEN() volatile
    {
        AHBCR ^= 1u << 11u;
    }

    /**
     * Get AHBCR's READSZALIGN bit.
     *
     * AHB Read Size Alignment
     */
    inline bool get_AHBCR_READSZALIGN() volatile
    {
        return AHBCR & (1u << 10u);
    }

    /**
     * Set AHBCR's READSZALIGN bit.
     *
     * AHB Read Size Alignment
     */
    inline void set_AHBCR_READSZALIGN() volatile
    {
        AHBCR |= 1u << 10u;
    }

    /**
     * Clear AHBCR's READSZALIGN bit.
     *
     * AHB Read Size Alignment
     */
    inline void clear_AHBCR_READSZALIGN() volatile
    {
        AHBCR &= ~(1u << 10u);
    }

    /**
     * Toggle AHBCR's READSZALIGN bit.
     *
     * AHB Read Size Alignment
     */
    inline void toggle_AHBCR_READSZALIGN() volatile
    {
        AHBCR ^= 1u << 10u;
    }

    /**
     * Get AHBCR's READADDROPT bit.
     *
     * AHB Read Address option bit. This option bit is intend to remove AHB
     * burst start address alignment limitation.
     */
    inline bool get_AHBCR_READADDROPT() volatile
    {
        return AHBCR & (1u << 6u);
    }

    /**
     * Set AHBCR's READADDROPT bit.
     *
     * AHB Read Address option bit. This option bit is intend to remove AHB
     * burst start address alignment limitation.
     */
    inline void set_AHBCR_READADDROPT() volatile
    {
        AHBCR |= 1u << 6u;
    }

    /**
     * Clear AHBCR's READADDROPT bit.
     *
     * AHB Read Address option bit. This option bit is intend to remove AHB
     * burst start address alignment limitation.
     */
    inline void clear_AHBCR_READADDROPT() volatile
    {
        AHBCR &= ~(1u << 6u);
    }

    /**
     * Toggle AHBCR's READADDROPT bit.
     *
     * AHB Read Address option bit. This option bit is intend to remove AHB
     * burst start address alignment limitation.
     */
    inline void toggle_AHBCR_READADDROPT() volatile
    {
        AHBCR ^= 1u << 6u;
    }

    /**
     * Get AHBCR's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable.
     */
    inline bool get_AHBCR_PREFETCHEN() volatile
    {
        return AHBCR & (1u << 5u);
    }

    /**
     * Set AHBCR's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable.
     */
    inline void set_AHBCR_PREFETCHEN() volatile
    {
        AHBCR |= 1u << 5u;
    }

    /**
     * Clear AHBCR's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable.
     */
    inline void clear_AHBCR_PREFETCHEN() volatile
    {
        AHBCR &= ~(1u << 5u);
    }

    /**
     * Toggle AHBCR's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable.
     */
    inline void toggle_AHBCR_PREFETCHEN() volatile
    {
        AHBCR ^= 1u << 5u;
    }

    /**
     * Get AHBCR's BUFFERABLEEN bit.
     *
     * Enable AHB bus bufferable write access support. This field affects the
     * last beat of AHB write access, refer for more details about AHB
     * bufferable write.
     */
    inline bool get_AHBCR_BUFFERABLEEN() volatile
    {
        return AHBCR & (1u << 4u);
    }

    /**
     * Set AHBCR's BUFFERABLEEN bit.
     *
     * Enable AHB bus bufferable write access support. This field affects the
     * last beat of AHB write access, refer for more details about AHB
     * bufferable write.
     */
    inline void set_AHBCR_BUFFERABLEEN() volatile
    {
        AHBCR |= 1u << 4u;
    }

    /**
     * Clear AHBCR's BUFFERABLEEN bit.
     *
     * Enable AHB bus bufferable write access support. This field affects the
     * last beat of AHB write access, refer for more details about AHB
     * bufferable write.
     */
    inline void clear_AHBCR_BUFFERABLEEN() volatile
    {
        AHBCR &= ~(1u << 4u);
    }

    /**
     * Toggle AHBCR's BUFFERABLEEN bit.
     *
     * Enable AHB bus bufferable write access support. This field affects the
     * last beat of AHB write access, refer for more details about AHB
     * bufferable write.
     */
    inline void toggle_AHBCR_BUFFERABLEEN() volatile
    {
        AHBCR ^= 1u << 4u;
    }

    /**
     * Get AHBCR's CACHABLEEN bit.
     *
     * Enable AHB bus cachable read access support.
     */
    inline bool get_AHBCR_CACHABLEEN() volatile
    {
        return AHBCR & (1u << 3u);
    }

    /**
     * Set AHBCR's CACHABLEEN bit.
     *
     * Enable AHB bus cachable read access support.
     */
    inline void set_AHBCR_CACHABLEEN() volatile
    {
        AHBCR |= 1u << 3u;
    }

    /**
     * Clear AHBCR's CACHABLEEN bit.
     *
     * Enable AHB bus cachable read access support.
     */
    inline void clear_AHBCR_CACHABLEEN() volatile
    {
        AHBCR &= ~(1u << 3u);
    }

    /**
     * Toggle AHBCR's CACHABLEEN bit.
     *
     * Enable AHB bus cachable read access support.
     */
    inline void toggle_AHBCR_CACHABLEEN() volatile
    {
        AHBCR ^= 1u << 3u;
    }

    /**
     * Get AHBCR's CLRAHBRXBUF bit.
     *
     * Clear the status/pointers of AHB RX Buffer. Auto-cleared.
     */
    inline bool get_AHBCR_CLRAHBRXBUF() volatile
    {
        return AHBCR & (1u << 1u);
    }

    /**
     * Set AHBCR's CLRAHBRXBUF bit.
     *
     * Clear the status/pointers of AHB RX Buffer. Auto-cleared.
     */
    inline void set_AHBCR_CLRAHBRXBUF() volatile
    {
        AHBCR |= 1u << 1u;
    }

    /**
     * Clear AHBCR's CLRAHBRXBUF bit.
     *
     * Clear the status/pointers of AHB RX Buffer. Auto-cleared.
     */
    inline void clear_AHBCR_CLRAHBRXBUF() volatile
    {
        AHBCR &= ~(1u << 1u);
    }

    /**
     * Toggle AHBCR's CLRAHBRXBUF bit.
     *
     * Clear the status/pointers of AHB RX Buffer. Auto-cleared.
     */
    inline void toggle_AHBCR_CLRAHBRXBUF() volatile
    {
        AHBCR ^= 1u << 1u;
    }

    /**
     * Get AHBCR's APAREN bit.
     *
     * Parallel mode enabled for AHB triggered Command (both read and write) .
     */
    inline bool get_AHBCR_APAREN() volatile
    {
        return AHBCR & (1u << 0u);
    }

    /**
     * Set AHBCR's APAREN bit.
     *
     * Parallel mode enabled for AHB triggered Command (both read and write) .
     */
    inline void set_AHBCR_APAREN() volatile
    {
        AHBCR |= 1u << 0u;
    }

    /**
     * Clear AHBCR's APAREN bit.
     *
     * Parallel mode enabled for AHB triggered Command (both read and write) .
     */
    inline void clear_AHBCR_APAREN() volatile
    {
        AHBCR &= ~(1u << 0u);
    }

    /**
     * Toggle AHBCR's APAREN bit.
     *
     * Parallel mode enabled for AHB triggered Command (both read and write) .
     */
    inline void toggle_AHBCR_APAREN() volatile
    {
        AHBCR ^= 1u << 0u;
    }

    /**
     * Get all of AHBCR's bit fields.
     *
     * (read-write) AHB Bus Control Register
     */
    inline void get_AHBCR(FLEXSPI1_AHBCR_ALIGNMENT &ALIGNMENT, bool &ECCSWAPEN,
                          bool &HMSTRIDREMAP, bool &ECCMULTIERRCLR,
                          bool &ECCSINGLEERRCLR, bool &KEYECCEN,
                          FLEXSPI1_AHBCR_SPLIT_LIMIT &SPLIT_LIMIT,
                          bool &SPLITEN, bool &ECCEN, bool &READSZALIGN,
                          bool &READADDROPT, bool &PREFETCHEN,
                          bool &BUFFERABLEEN, bool &CACHABLEEN,
                          bool &CLRAHBRXBUF, bool &APAREN) volatile
    {
        uint32_t curr = AHBCR;

        ALIGNMENT = FLEXSPI1_AHBCR_ALIGNMENT((curr >> 20u) & 0b11u);
        ECCSWAPEN = curr & (1u << 19u);
        HMSTRIDREMAP = curr & (1u << 18u);
        ECCMULTIERRCLR = curr & (1u << 17u);
        ECCSINGLEERRCLR = curr & (1u << 16u);
        KEYECCEN = curr & (1u << 15u);
        SPLIT_LIMIT = FLEXSPI1_AHBCR_SPLIT_LIMIT((curr >> 13u) & 0b11u);
        SPLITEN = curr & (1u << 12u);
        ECCEN = curr & (1u << 11u);
        READSZALIGN = curr & (1u << 10u);
        READADDROPT = curr & (1u << 6u);
        PREFETCHEN = curr & (1u << 5u);
        BUFFERABLEEN = curr & (1u << 4u);
        CACHABLEEN = curr & (1u << 3u);
        CLRAHBRXBUF = curr & (1u << 1u);
        APAREN = curr & (1u << 0u);
    }

    /**
     * Set all of AHBCR's bit fields.
     *
     * (read-write) AHB Bus Control Register
     */
    inline void set_AHBCR(FLEXSPI1_AHBCR_ALIGNMENT ALIGNMENT, bool ECCSWAPEN,
                          bool HMSTRIDREMAP, bool ECCMULTIERRCLR,
                          bool ECCSINGLEERRCLR, bool KEYECCEN,
                          FLEXSPI1_AHBCR_SPLIT_LIMIT SPLIT_LIMIT, bool SPLITEN,
                          bool ECCEN, bool READSZALIGN, bool READADDROPT,
                          bool PREFETCHEN, bool BUFFERABLEEN, bool CACHABLEEN,
                          bool CLRAHBRXBUF, bool APAREN) volatile
    {
        uint32_t curr = AHBCR;

        curr &= ~(0b11u << 20u);
        curr |= (std::to_underlying(ALIGNMENT) & 0b11u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ECCSWAPEN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (HMSTRIDREMAP & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (ECCMULTIERRCLR & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ECCSINGLEERRCLR & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (KEYECCEN & 0b1u) << 15u;
        curr &= ~(0b11u << 13u);
        curr |= (std::to_underlying(SPLIT_LIMIT) & 0b11u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (SPLITEN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ECCEN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (READSZALIGN & 0b1u) << 10u;
        curr &= ~(0b1u << 6u);
        curr |= (READADDROPT & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (PREFETCHEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (BUFFERABLEEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (CACHABLEEN & 0b1u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (CLRAHBRXBUF & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (APAREN & 0b1u) << 0u;

        AHBCR = curr;
    }

    /**
     * Get INTEN's IPCMDSECUREVIOEN bit.
     *
     * IP command security violation interrupt enable.
     */
    inline bool get_INTEN_IPCMDSECUREVIOEN() volatile
    {
        return INTEN & (1u << 16u);
    }

    /**
     * Set INTEN's IPCMDSECUREVIOEN bit.
     *
     * IP command security violation interrupt enable.
     */
    inline void set_INTEN_IPCMDSECUREVIOEN() volatile
    {
        INTEN |= 1u << 16u;
    }

    /**
     * Clear INTEN's IPCMDSECUREVIOEN bit.
     *
     * IP command security violation interrupt enable.
     */
    inline void clear_INTEN_IPCMDSECUREVIOEN() volatile
    {
        INTEN &= ~(1u << 16u);
    }

    /**
     * Toggle INTEN's IPCMDSECUREVIOEN bit.
     *
     * IP command security violation interrupt enable.
     */
    inline void toggle_INTEN_IPCMDSECUREVIOEN() volatile
    {
        INTEN ^= 1u << 16u;
    }

    /**
     * Get INTEN's ECCSINGLEERREN bit.
     *
     * ECC single bit error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline bool get_INTEN_ECCSINGLEERREN() volatile
    {
        return INTEN & (1u << 15u);
    }

    /**
     * Set INTEN's ECCSINGLEERREN bit.
     *
     * ECC single bit error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void set_INTEN_ECCSINGLEERREN() volatile
    {
        INTEN |= 1u << 15u;
    }

    /**
     * Clear INTEN's ECCSINGLEERREN bit.
     *
     * ECC single bit error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void clear_INTEN_ECCSINGLEERREN() volatile
    {
        INTEN &= ~(1u << 15u);
    }

    /**
     * Toggle INTEN's ECCSINGLEERREN bit.
     *
     * ECC single bit error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void toggle_INTEN_ECCSINGLEERREN() volatile
    {
        INTEN ^= 1u << 15u;
    }

    /**
     * Get INTEN's ECCMULTIERREN bit.
     *
     * ECC multi bits error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline bool get_INTEN_ECCMULTIERREN() volatile
    {
        return INTEN & (1u << 14u);
    }

    /**
     * Set INTEN's ECCMULTIERREN bit.
     *
     * ECC multi bits error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void set_INTEN_ECCMULTIERREN() volatile
    {
        INTEN |= 1u << 14u;
    }

    /**
     * Clear INTEN's ECCMULTIERREN bit.
     *
     * ECC multi bits error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void clear_INTEN_ECCMULTIERREN() volatile
    {
        INTEN &= ~(1u << 14u);
    }

    /**
     * Toggle INTEN's ECCMULTIERREN bit.
     *
     * ECC multi bits error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void toggle_INTEN_ECCMULTIERREN() volatile
    {
        INTEN ^= 1u << 14u;
    }

    /**
     * Get INTEN's KEYERROREN bit.
     *
     * OTFAD key blob processing error interrupt enable.Refer Interrupts
     * chapter for more details.
     */
    inline bool get_INTEN_KEYERROREN() volatile
    {
        return INTEN & (1u << 13u);
    }

    /**
     * Set INTEN's KEYERROREN bit.
     *
     * OTFAD key blob processing error interrupt enable.Refer Interrupts
     * chapter for more details.
     */
    inline void set_INTEN_KEYERROREN() volatile
    {
        INTEN |= 1u << 13u;
    }

    /**
     * Clear INTEN's KEYERROREN bit.
     *
     * OTFAD key blob processing error interrupt enable.Refer Interrupts
     * chapter for more details.
     */
    inline void clear_INTEN_KEYERROREN() volatile
    {
        INTEN &= ~(1u << 13u);
    }

    /**
     * Toggle INTEN's KEYERROREN bit.
     *
     * OTFAD key blob processing error interrupt enable.Refer Interrupts
     * chapter for more details.
     */
    inline void toggle_INTEN_KEYERROREN() volatile
    {
        INTEN ^= 1u << 13u;
    }

    /**
     * Get INTEN's KEYDONEEN bit.
     *
     * OTFAD key blob processing done interrupt enable.Refer Interrupts chapter
     * for more details.
     */
    inline bool get_INTEN_KEYDONEEN() volatile
    {
        return INTEN & (1u << 12u);
    }

    /**
     * Set INTEN's KEYDONEEN bit.
     *
     * OTFAD key blob processing done interrupt enable.Refer Interrupts chapter
     * for more details.
     */
    inline void set_INTEN_KEYDONEEN() volatile
    {
        INTEN |= 1u << 12u;
    }

    /**
     * Clear INTEN's KEYDONEEN bit.
     *
     * OTFAD key blob processing done interrupt enable.Refer Interrupts chapter
     * for more details.
     */
    inline void clear_INTEN_KEYDONEEN() volatile
    {
        INTEN &= ~(1u << 12u);
    }

    /**
     * Toggle INTEN's KEYDONEEN bit.
     *
     * OTFAD key blob processing done interrupt enable.Refer Interrupts chapter
     * for more details.
     */
    inline void toggle_INTEN_KEYDONEEN() volatile
    {
        INTEN ^= 1u << 12u;
    }

    /**
     * Get INTEN's SEQTIMEOUTEN bit.
     *
     * Sequence execution timeout interrupt enable.Refer Interrupts chapter for
     * more details.
     */
    inline bool get_INTEN_SEQTIMEOUTEN() volatile
    {
        return INTEN & (1u << 11u);
    }

    /**
     * Set INTEN's SEQTIMEOUTEN bit.
     *
     * Sequence execution timeout interrupt enable.Refer Interrupts chapter for
     * more details.
     */
    inline void set_INTEN_SEQTIMEOUTEN() volatile
    {
        INTEN |= 1u << 11u;
    }

    /**
     * Clear INTEN's SEQTIMEOUTEN bit.
     *
     * Sequence execution timeout interrupt enable.Refer Interrupts chapter for
     * more details.
     */
    inline void clear_INTEN_SEQTIMEOUTEN() volatile
    {
        INTEN &= ~(1u << 11u);
    }

    /**
     * Toggle INTEN's SEQTIMEOUTEN bit.
     *
     * Sequence execution timeout interrupt enable.Refer Interrupts chapter for
     * more details.
     */
    inline void toggle_INTEN_SEQTIMEOUTEN() volatile
    {
        INTEN ^= 1u << 11u;
    }

    /**
     * Get INTEN's AHBBUSERROREN bit.
     *
     * AHB Bus error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline bool get_INTEN_AHBBUSERROREN() volatile
    {
        return INTEN & (1u << 10u);
    }

    /**
     * Set INTEN's AHBBUSERROREN bit.
     *
     * AHB Bus error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void set_INTEN_AHBBUSERROREN() volatile
    {
        INTEN |= 1u << 10u;
    }

    /**
     * Clear INTEN's AHBBUSERROREN bit.
     *
     * AHB Bus error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void clear_INTEN_AHBBUSERROREN() volatile
    {
        INTEN &= ~(1u << 10u);
    }

    /**
     * Toggle INTEN's AHBBUSERROREN bit.
     *
     * AHB Bus error interrupt enable.Refer Interrupts chapter for more
     * details.
     */
    inline void toggle_INTEN_AHBBUSERROREN() volatile
    {
        INTEN ^= 1u << 10u;
    }

    /**
     * Get INTEN's SCKSTOPBYWREN bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt enable.
     */
    inline bool get_INTEN_SCKSTOPBYWREN() volatile
    {
        return INTEN & (1u << 9u);
    }

    /**
     * Set INTEN's SCKSTOPBYWREN bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt enable.
     */
    inline void set_INTEN_SCKSTOPBYWREN() volatile
    {
        INTEN |= 1u << 9u;
    }

    /**
     * Clear INTEN's SCKSTOPBYWREN bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt enable.
     */
    inline void clear_INTEN_SCKSTOPBYWREN() volatile
    {
        INTEN &= ~(1u << 9u);
    }

    /**
     * Toggle INTEN's SCKSTOPBYWREN bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt enable.
     */
    inline void toggle_INTEN_SCKSTOPBYWREN() volatile
    {
        INTEN ^= 1u << 9u;
    }

    /**
     * Get INTEN's SCKSTOPBYRDEN bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt enable.
     */
    inline bool get_INTEN_SCKSTOPBYRDEN() volatile
    {
        return INTEN & (1u << 8u);
    }

    /**
     * Set INTEN's SCKSTOPBYRDEN bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt enable.
     */
    inline void set_INTEN_SCKSTOPBYRDEN() volatile
    {
        INTEN |= 1u << 8u;
    }

    /**
     * Clear INTEN's SCKSTOPBYRDEN bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt enable.
     */
    inline void clear_INTEN_SCKSTOPBYRDEN() volatile
    {
        INTEN &= ~(1u << 8u);
    }

    /**
     * Toggle INTEN's SCKSTOPBYRDEN bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt enable.
     */
    inline void toggle_INTEN_SCKSTOPBYRDEN() volatile
    {
        INTEN ^= 1u << 8u;
    }

    /**
     * Get INTEN's IPTXWEEN bit.
     *
     * IP TX FIFO WaterMark empty interrupt enable.
     */
    inline bool get_INTEN_IPTXWEEN() volatile
    {
        return INTEN & (1u << 6u);
    }

    /**
     * Set INTEN's IPTXWEEN bit.
     *
     * IP TX FIFO WaterMark empty interrupt enable.
     */
    inline void set_INTEN_IPTXWEEN() volatile
    {
        INTEN |= 1u << 6u;
    }

    /**
     * Clear INTEN's IPTXWEEN bit.
     *
     * IP TX FIFO WaterMark empty interrupt enable.
     */
    inline void clear_INTEN_IPTXWEEN() volatile
    {
        INTEN &= ~(1u << 6u);
    }

    /**
     * Toggle INTEN's IPTXWEEN bit.
     *
     * IP TX FIFO WaterMark empty interrupt enable.
     */
    inline void toggle_INTEN_IPTXWEEN() volatile
    {
        INTEN ^= 1u << 6u;
    }

    /**
     * Get INTEN's IPRXWAEN bit.
     *
     * IP RX FIFO WaterMark available interrupt enable.
     */
    inline bool get_INTEN_IPRXWAEN() volatile
    {
        return INTEN & (1u << 5u);
    }

    /**
     * Set INTEN's IPRXWAEN bit.
     *
     * IP RX FIFO WaterMark available interrupt enable.
     */
    inline void set_INTEN_IPRXWAEN() volatile
    {
        INTEN |= 1u << 5u;
    }

    /**
     * Clear INTEN's IPRXWAEN bit.
     *
     * IP RX FIFO WaterMark available interrupt enable.
     */
    inline void clear_INTEN_IPRXWAEN() volatile
    {
        INTEN &= ~(1u << 5u);
    }

    /**
     * Toggle INTEN's IPRXWAEN bit.
     *
     * IP RX FIFO WaterMark available interrupt enable.
     */
    inline void toggle_INTEN_IPRXWAEN() volatile
    {
        INTEN ^= 1u << 5u;
    }

    /**
     * Get INTEN's AHBCMDERREN bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt enable.
     */
    inline bool get_INTEN_AHBCMDERREN() volatile
    {
        return INTEN & (1u << 4u);
    }

    /**
     * Set INTEN's AHBCMDERREN bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt enable.
     */
    inline void set_INTEN_AHBCMDERREN() volatile
    {
        INTEN |= 1u << 4u;
    }

    /**
     * Clear INTEN's AHBCMDERREN bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt enable.
     */
    inline void clear_INTEN_AHBCMDERREN() volatile
    {
        INTEN &= ~(1u << 4u);
    }

    /**
     * Toggle INTEN's AHBCMDERREN bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt enable.
     */
    inline void toggle_INTEN_AHBCMDERREN() volatile
    {
        INTEN ^= 1u << 4u;
    }

    /**
     * Get INTEN's IPCMDERREN bit.
     *
     * IP triggered Command Sequences Error Detected interrupt enable.
     */
    inline bool get_INTEN_IPCMDERREN() volatile
    {
        return INTEN & (1u << 3u);
    }

    /**
     * Set INTEN's IPCMDERREN bit.
     *
     * IP triggered Command Sequences Error Detected interrupt enable.
     */
    inline void set_INTEN_IPCMDERREN() volatile
    {
        INTEN |= 1u << 3u;
    }

    /**
     * Clear INTEN's IPCMDERREN bit.
     *
     * IP triggered Command Sequences Error Detected interrupt enable.
     */
    inline void clear_INTEN_IPCMDERREN() volatile
    {
        INTEN &= ~(1u << 3u);
    }

    /**
     * Toggle INTEN's IPCMDERREN bit.
     *
     * IP triggered Command Sequences Error Detected interrupt enable.
     */
    inline void toggle_INTEN_IPCMDERREN() volatile
    {
        INTEN ^= 1u << 3u;
    }

    /**
     * Get INTEN's AHBCMDGEEN bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline bool get_INTEN_AHBCMDGEEN() volatile
    {
        return INTEN & (1u << 2u);
    }

    /**
     * Set INTEN's AHBCMDGEEN bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline void set_INTEN_AHBCMDGEEN() volatile
    {
        INTEN |= 1u << 2u;
    }

    /**
     * Clear INTEN's AHBCMDGEEN bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline void clear_INTEN_AHBCMDGEEN() volatile
    {
        INTEN &= ~(1u << 2u);
    }

    /**
     * Toggle INTEN's AHBCMDGEEN bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline void toggle_INTEN_AHBCMDGEEN() volatile
    {
        INTEN ^= 1u << 2u;
    }

    /**
     * Get INTEN's IPCMDGEEN bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline bool get_INTEN_IPCMDGEEN() volatile
    {
        return INTEN & (1u << 1u);
    }

    /**
     * Set INTEN's IPCMDGEEN bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline void set_INTEN_IPCMDGEEN() volatile
    {
        INTEN |= 1u << 1u;
    }

    /**
     * Clear INTEN's IPCMDGEEN bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline void clear_INTEN_IPCMDGEEN() volatile
    {
        INTEN &= ~(1u << 1u);
    }

    /**
     * Toggle INTEN's IPCMDGEEN bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt enable.
     */
    inline void toggle_INTEN_IPCMDGEEN() volatile
    {
        INTEN ^= 1u << 1u;
    }

    /**
     * Get INTEN's IPCMDDONEEN bit.
     *
     * IP triggered Command Sequences Execution finished interrupt enable.
     */
    inline bool get_INTEN_IPCMDDONEEN() volatile
    {
        return INTEN & (1u << 0u);
    }

    /**
     * Set INTEN's IPCMDDONEEN bit.
     *
     * IP triggered Command Sequences Execution finished interrupt enable.
     */
    inline void set_INTEN_IPCMDDONEEN() volatile
    {
        INTEN |= 1u << 0u;
    }

    /**
     * Clear INTEN's IPCMDDONEEN bit.
     *
     * IP triggered Command Sequences Execution finished interrupt enable.
     */
    inline void clear_INTEN_IPCMDDONEEN() volatile
    {
        INTEN &= ~(1u << 0u);
    }

    /**
     * Toggle INTEN's IPCMDDONEEN bit.
     *
     * IP triggered Command Sequences Execution finished interrupt enable.
     */
    inline void toggle_INTEN_IPCMDDONEEN() volatile
    {
        INTEN ^= 1u << 0u;
    }

    /**
     * Get all of INTEN's bit fields.
     *
     * (read-write) Interrupt Enable Register
     */
    inline void get_INTEN(bool &IPCMDSECUREVIOEN, bool &ECCSINGLEERREN,
                          bool &ECCMULTIERREN, bool &KEYERROREN,
                          bool &KEYDONEEN, bool &SEQTIMEOUTEN,
                          bool &AHBBUSERROREN, bool &SCKSTOPBYWREN,
                          bool &SCKSTOPBYRDEN, bool &IPTXWEEN, bool &IPRXWAEN,
                          bool &AHBCMDERREN, bool &IPCMDERREN,
                          bool &AHBCMDGEEN, bool &IPCMDGEEN,
                          bool &IPCMDDONEEN) volatile
    {
        uint32_t curr = INTEN;

        IPCMDSECUREVIOEN = curr & (1u << 16u);
        ECCSINGLEERREN = curr & (1u << 15u);
        ECCMULTIERREN = curr & (1u << 14u);
        KEYERROREN = curr & (1u << 13u);
        KEYDONEEN = curr & (1u << 12u);
        SEQTIMEOUTEN = curr & (1u << 11u);
        AHBBUSERROREN = curr & (1u << 10u);
        SCKSTOPBYWREN = curr & (1u << 9u);
        SCKSTOPBYRDEN = curr & (1u << 8u);
        IPTXWEEN = curr & (1u << 6u);
        IPRXWAEN = curr & (1u << 5u);
        AHBCMDERREN = curr & (1u << 4u);
        IPCMDERREN = curr & (1u << 3u);
        AHBCMDGEEN = curr & (1u << 2u);
        IPCMDGEEN = curr & (1u << 1u);
        IPCMDDONEEN = curr & (1u << 0u);
    }

    /**
     * Set all of INTEN's bit fields.
     *
     * (read-write) Interrupt Enable Register
     */
    inline void set_INTEN(bool IPCMDSECUREVIOEN, bool ECCSINGLEERREN,
                          bool ECCMULTIERREN, bool KEYERROREN, bool KEYDONEEN,
                          bool SEQTIMEOUTEN, bool AHBBUSERROREN,
                          bool SCKSTOPBYWREN, bool SCKSTOPBYRDEN,
                          bool IPTXWEEN, bool IPRXWAEN, bool AHBCMDERREN,
                          bool IPCMDERREN, bool AHBCMDGEEN, bool IPCMDGEEN,
                          bool IPCMDDONEEN) volatile
    {
        uint32_t curr = INTEN;

        curr &= ~(0b1u << 16u);
        curr |= (IPCMDSECUREVIOEN & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ECCSINGLEERREN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ECCMULTIERREN & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (KEYERROREN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (KEYDONEEN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SEQTIMEOUTEN & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (AHBBUSERROREN & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SCKSTOPBYWREN & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SCKSTOPBYRDEN & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (IPTXWEEN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (IPRXWAEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (AHBCMDERREN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IPCMDERREN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AHBCMDGEEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IPCMDGEEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IPCMDDONEEN & 0b1u) << 0u;

        INTEN = curr;
    }

    /**
     * Get INTR's IPCMDSECUREVIO bit.
     *
     * IP command security violation interrupt.
     */
    inline bool get_INTR_IPCMDSECUREVIO() volatile
    {
        return INTR & (1u << 16u);
    }

    /**
     * Set INTR's IPCMDSECUREVIO bit.
     *
     * IP command security violation interrupt.
     */
    inline void set_INTR_IPCMDSECUREVIO() volatile
    {
        INTR |= 1u << 16u;
    }

    /**
     * Clear INTR's IPCMDSECUREVIO bit.
     *
     * IP command security violation interrupt.
     */
    inline void clear_INTR_IPCMDSECUREVIO() volatile
    {
        INTR &= ~(1u << 16u);
    }

    /**
     * Toggle INTR's IPCMDSECUREVIO bit.
     *
     * IP command security violation interrupt.
     */
    inline void toggle_INTR_IPCMDSECUREVIO() volatile
    {
        INTR ^= 1u << 16u;
    }

    /**
     * Get INTR's ECCSINGLEERR bit.
     *
     * ECC single bit error interrupt.
     */
    inline bool get_INTR_ECCSINGLEERR() volatile
    {
        return INTR & (1u << 15u);
    }

    /**
     * Set INTR's ECCSINGLEERR bit.
     *
     * ECC single bit error interrupt.
     */
    inline void set_INTR_ECCSINGLEERR() volatile
    {
        INTR |= 1u << 15u;
    }

    /**
     * Clear INTR's ECCSINGLEERR bit.
     *
     * ECC single bit error interrupt.
     */
    inline void clear_INTR_ECCSINGLEERR() volatile
    {
        INTR &= ~(1u << 15u);
    }

    /**
     * Toggle INTR's ECCSINGLEERR bit.
     *
     * ECC single bit error interrupt.
     */
    inline void toggle_INTR_ECCSINGLEERR() volatile
    {
        INTR ^= 1u << 15u;
    }

    /**
     * Get INTR's ECCMULTIERR bit.
     *
     * ECC multi bits error interrupt.
     */
    inline bool get_INTR_ECCMULTIERR() volatile
    {
        return INTR & (1u << 14u);
    }

    /**
     * Set INTR's ECCMULTIERR bit.
     *
     * ECC multi bits error interrupt.
     */
    inline void set_INTR_ECCMULTIERR() volatile
    {
        INTR |= 1u << 14u;
    }

    /**
     * Clear INTR's ECCMULTIERR bit.
     *
     * ECC multi bits error interrupt.
     */
    inline void clear_INTR_ECCMULTIERR() volatile
    {
        INTR &= ~(1u << 14u);
    }

    /**
     * Toggle INTR's ECCMULTIERR bit.
     *
     * ECC multi bits error interrupt.
     */
    inline void toggle_INTR_ECCMULTIERR() volatile
    {
        INTR ^= 1u << 14u;
    }

    /**
     * Get INTR's KEYERROR bit.
     *
     * OTFAD key blob processing error interrupt.
     */
    inline bool get_INTR_KEYERROR() volatile
    {
        return INTR & (1u << 13u);
    }

    /**
     * Get INTR's KEYDONE bit.
     *
     * OTFAD key blob processing done interrupt.
     */
    inline bool get_INTR_KEYDONE() volatile
    {
        return INTR & (1u << 12u);
    }

    /**
     * Set INTR's KEYDONE bit.
     *
     * OTFAD key blob processing done interrupt.
     */
    inline void set_INTR_KEYDONE() volatile
    {
        INTR |= 1u << 12u;
    }

    /**
     * Clear INTR's KEYDONE bit.
     *
     * OTFAD key blob processing done interrupt.
     */
    inline void clear_INTR_KEYDONE() volatile
    {
        INTR &= ~(1u << 12u);
    }

    /**
     * Toggle INTR's KEYDONE bit.
     *
     * OTFAD key blob processing done interrupt.
     */
    inline void toggle_INTR_KEYDONE() volatile
    {
        INTR ^= 1u << 12u;
    }

    /**
     * Get INTR's SEQTIMEOUT bit.
     *
     * Sequence execution timeout interrupt.
     */
    inline bool get_INTR_SEQTIMEOUT() volatile
    {
        return INTR & (1u << 11u);
    }

    /**
     * Set INTR's SEQTIMEOUT bit.
     *
     * Sequence execution timeout interrupt.
     */
    inline void set_INTR_SEQTIMEOUT() volatile
    {
        INTR |= 1u << 11u;
    }

    /**
     * Clear INTR's SEQTIMEOUT bit.
     *
     * Sequence execution timeout interrupt.
     */
    inline void clear_INTR_SEQTIMEOUT() volatile
    {
        INTR &= ~(1u << 11u);
    }

    /**
     * Toggle INTR's SEQTIMEOUT bit.
     *
     * Sequence execution timeout interrupt.
     */
    inline void toggle_INTR_SEQTIMEOUT() volatile
    {
        INTR ^= 1u << 11u;
    }

    /**
     * Get INTR's AHBBUSERROR bit.
     *
     * AHB Bus timeout or AHB bus illegal access Flash during OTFAD key blob
     * processing interrupt.
     */
    inline bool get_INTR_AHBBUSERROR() volatile
    {
        return INTR & (1u << 10u);
    }

    /**
     * Set INTR's AHBBUSERROR bit.
     *
     * AHB Bus timeout or AHB bus illegal access Flash during OTFAD key blob
     * processing interrupt.
     */
    inline void set_INTR_AHBBUSERROR() volatile
    {
        INTR |= 1u << 10u;
    }

    /**
     * Clear INTR's AHBBUSERROR bit.
     *
     * AHB Bus timeout or AHB bus illegal access Flash during OTFAD key blob
     * processing interrupt.
     */
    inline void clear_INTR_AHBBUSERROR() volatile
    {
        INTR &= ~(1u << 10u);
    }

    /**
     * Toggle INTR's AHBBUSERROR bit.
     *
     * AHB Bus timeout or AHB bus illegal access Flash during OTFAD key blob
     * processing interrupt.
     */
    inline void toggle_INTR_AHBBUSERROR() volatile
    {
        INTR ^= 1u << 10u;
    }

    /**
     * Get INTR's SCKSTOPBYWR bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt.
     */
    inline bool get_INTR_SCKSTOPBYWR() volatile
    {
        return INTR & (1u << 9u);
    }

    /**
     * Set INTR's SCKSTOPBYWR bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt.
     */
    inline void set_INTR_SCKSTOPBYWR() volatile
    {
        INTR |= 1u << 9u;
    }

    /**
     * Clear INTR's SCKSTOPBYWR bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt.
     */
    inline void clear_INTR_SCKSTOPBYWR() volatile
    {
        INTR &= ~(1u << 9u);
    }

    /**
     * Toggle INTR's SCKSTOPBYWR bit.
     *
     * SCLK is stopped during command sequence because Async TX FIFO empty
     * interrupt.
     */
    inline void toggle_INTR_SCKSTOPBYWR() volatile
    {
        INTR ^= 1u << 9u;
    }

    /**
     * Get INTR's SCKSTOPBYRD bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt.
     */
    inline bool get_INTR_SCKSTOPBYRD() volatile
    {
        return INTR & (1u << 8u);
    }

    /**
     * Set INTR's SCKSTOPBYRD bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt.
     */
    inline void set_INTR_SCKSTOPBYRD() volatile
    {
        INTR |= 1u << 8u;
    }

    /**
     * Clear INTR's SCKSTOPBYRD bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt.
     */
    inline void clear_INTR_SCKSTOPBYRD() volatile
    {
        INTR &= ~(1u << 8u);
    }

    /**
     * Toggle INTR's SCKSTOPBYRD bit.
     *
     * SCLK is stopped during command sequence because Async RX FIFO full
     * interrupt.
     */
    inline void toggle_INTR_SCKSTOPBYRD() volatile
    {
        INTR ^= 1u << 8u;
    }

    /**
     * Get INTR's IPTXWE bit.
     *
     * IP TX FIFO watermark empty interrupt.
     */
    inline bool get_INTR_IPTXWE() volatile
    {
        return INTR & (1u << 6u);
    }

    /**
     * Set INTR's IPTXWE bit.
     *
     * IP TX FIFO watermark empty interrupt.
     */
    inline void set_INTR_IPTXWE() volatile
    {
        INTR |= 1u << 6u;
    }

    /**
     * Clear INTR's IPTXWE bit.
     *
     * IP TX FIFO watermark empty interrupt.
     */
    inline void clear_INTR_IPTXWE() volatile
    {
        INTR &= ~(1u << 6u);
    }

    /**
     * Toggle INTR's IPTXWE bit.
     *
     * IP TX FIFO watermark empty interrupt.
     */
    inline void toggle_INTR_IPTXWE() volatile
    {
        INTR ^= 1u << 6u;
    }

    /**
     * Get INTR's IPRXWA bit.
     *
     * IP RX FIFO watermark available interrupt.
     */
    inline bool get_INTR_IPRXWA() volatile
    {
        return INTR & (1u << 5u);
    }

    /**
     * Set INTR's IPRXWA bit.
     *
     * IP RX FIFO watermark available interrupt.
     */
    inline void set_INTR_IPRXWA() volatile
    {
        INTR |= 1u << 5u;
    }

    /**
     * Clear INTR's IPRXWA bit.
     *
     * IP RX FIFO watermark available interrupt.
     */
    inline void clear_INTR_IPRXWA() volatile
    {
        INTR &= ~(1u << 5u);
    }

    /**
     * Toggle INTR's IPRXWA bit.
     *
     * IP RX FIFO watermark available interrupt.
     */
    inline void toggle_INTR_IPRXWA() volatile
    {
        INTR ^= 1u << 5u;
    }

    /**
     * Get INTR's AHBCMDERR bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt. When an error
     * detected for AHB command, this command will be ignored and not executed
     * at all.
     */
    inline bool get_INTR_AHBCMDERR() volatile
    {
        return INTR & (1u << 4u);
    }

    /**
     * Set INTR's AHBCMDERR bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt. When an error
     * detected for AHB command, this command will be ignored and not executed
     * at all.
     */
    inline void set_INTR_AHBCMDERR() volatile
    {
        INTR |= 1u << 4u;
    }

    /**
     * Clear INTR's AHBCMDERR bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt. When an error
     * detected for AHB command, this command will be ignored and not executed
     * at all.
     */
    inline void clear_INTR_AHBCMDERR() volatile
    {
        INTR &= ~(1u << 4u);
    }

    /**
     * Toggle INTR's AHBCMDERR bit.
     *
     * AHB triggered Command Sequences Error Detected interrupt. When an error
     * detected for AHB command, this command will be ignored and not executed
     * at all.
     */
    inline void toggle_INTR_AHBCMDERR() volatile
    {
        INTR ^= 1u << 4u;
    }

    /**
     * Get INTR's IPCMDERR bit.
     *
     * IP triggered Command Sequences Error Detected interrupt. When an error
     * detected for IP command, this command will be ignored and not executed
     * at all.
     */
    inline bool get_INTR_IPCMDERR() volatile
    {
        return INTR & (1u << 3u);
    }

    /**
     * Set INTR's IPCMDERR bit.
     *
     * IP triggered Command Sequences Error Detected interrupt. When an error
     * detected for IP command, this command will be ignored and not executed
     * at all.
     */
    inline void set_INTR_IPCMDERR() volatile
    {
        INTR |= 1u << 3u;
    }

    /**
     * Clear INTR's IPCMDERR bit.
     *
     * IP triggered Command Sequences Error Detected interrupt. When an error
     * detected for IP command, this command will be ignored and not executed
     * at all.
     */
    inline void clear_INTR_IPCMDERR() volatile
    {
        INTR &= ~(1u << 3u);
    }

    /**
     * Toggle INTR's IPCMDERR bit.
     *
     * IP triggered Command Sequences Error Detected interrupt. When an error
     * detected for IP command, this command will be ignored and not executed
     * at all.
     */
    inline void toggle_INTR_IPCMDERR() volatile
    {
        INTR ^= 1u << 3u;
    }

    /**
     * Get INTR's AHBCMDGE bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt.
     */
    inline bool get_INTR_AHBCMDGE() volatile
    {
        return INTR & (1u << 2u);
    }

    /**
     * Set INTR's AHBCMDGE bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt.
     */
    inline void set_INTR_AHBCMDGE() volatile
    {
        INTR |= 1u << 2u;
    }

    /**
     * Clear INTR's AHBCMDGE bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt.
     */
    inline void clear_INTR_AHBCMDGE() volatile
    {
        INTR &= ~(1u << 2u);
    }

    /**
     * Toggle INTR's AHBCMDGE bit.
     *
     * AHB triggered Command Sequences Grant Timeout interrupt.
     */
    inline void toggle_INTR_AHBCMDGE() volatile
    {
        INTR ^= 1u << 2u;
    }

    /**
     * Get INTR's IPCMDGE bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt.
     */
    inline bool get_INTR_IPCMDGE() volatile
    {
        return INTR & (1u << 1u);
    }

    /**
     * Set INTR's IPCMDGE bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt.
     */
    inline void set_INTR_IPCMDGE() volatile
    {
        INTR |= 1u << 1u;
    }

    /**
     * Clear INTR's IPCMDGE bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt.
     */
    inline void clear_INTR_IPCMDGE() volatile
    {
        INTR &= ~(1u << 1u);
    }

    /**
     * Toggle INTR's IPCMDGE bit.
     *
     * IP triggered Command Sequences Grant Timeout interrupt.
     */
    inline void toggle_INTR_IPCMDGE() volatile
    {
        INTR ^= 1u << 1u;
    }

    /**
     * Get INTR's IPCMDDONE bit.
     *
     * IP triggered Command Sequences Execution finished interrupt. This
     * interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt
     * generated.
     */
    inline bool get_INTR_IPCMDDONE() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Set INTR's IPCMDDONE bit.
     *
     * IP triggered Command Sequences Execution finished interrupt. This
     * interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt
     * generated.
     */
    inline void set_INTR_IPCMDDONE() volatile
    {
        INTR |= 1u << 0u;
    }

    /**
     * Clear INTR's IPCMDDONE bit.
     *
     * IP triggered Command Sequences Execution finished interrupt. This
     * interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt
     * generated.
     */
    inline void clear_INTR_IPCMDDONE() volatile
    {
        INTR &= ~(1u << 0u);
    }

    /**
     * Toggle INTR's IPCMDDONE bit.
     *
     * IP triggered Command Sequences Execution finished interrupt. This
     * interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt
     * generated.
     */
    inline void toggle_INTR_IPCMDDONE() volatile
    {
        INTR ^= 1u << 0u;
    }

    /**
     * Get all of INTR's bit fields.
     *
     * (read-write) Interrupt Register
     */
    inline void get_INTR(bool &IPCMDSECUREVIO, bool &ECCSINGLEERR,
                         bool &ECCMULTIERR, bool &KEYERROR, bool &KEYDONE,
                         bool &SEQTIMEOUT, bool &AHBBUSERROR,
                         bool &SCKSTOPBYWR, bool &SCKSTOPBYRD, bool &IPTXWE,
                         bool &IPRXWA, bool &AHBCMDERR, bool &IPCMDERR,
                         bool &AHBCMDGE, bool &IPCMDGE,
                         bool &IPCMDDONE) volatile
    {
        uint32_t curr = INTR;

        IPCMDSECUREVIO = curr & (1u << 16u);
        ECCSINGLEERR = curr & (1u << 15u);
        ECCMULTIERR = curr & (1u << 14u);
        KEYERROR = curr & (1u << 13u);
        KEYDONE = curr & (1u << 12u);
        SEQTIMEOUT = curr & (1u << 11u);
        AHBBUSERROR = curr & (1u << 10u);
        SCKSTOPBYWR = curr & (1u << 9u);
        SCKSTOPBYRD = curr & (1u << 8u);
        IPTXWE = curr & (1u << 6u);
        IPRXWA = curr & (1u << 5u);
        AHBCMDERR = curr & (1u << 4u);
        IPCMDERR = curr & (1u << 3u);
        AHBCMDGE = curr & (1u << 2u);
        IPCMDGE = curr & (1u << 1u);
        IPCMDDONE = curr & (1u << 0u);
    }

    /**
     * Set all of INTR's bit fields.
     *
     * (read-write) Interrupt Register
     */
    inline void set_INTR(bool IPCMDSECUREVIO, bool ECCSINGLEERR,
                         bool ECCMULTIERR, bool KEYDONE, bool SEQTIMEOUT,
                         bool AHBBUSERROR, bool SCKSTOPBYWR, bool SCKSTOPBYRD,
                         bool IPTXWE, bool IPRXWA, bool AHBCMDERR,
                         bool IPCMDERR, bool AHBCMDGE, bool IPCMDGE,
                         bool IPCMDDONE) volatile
    {
        uint32_t curr = INTR;

        curr &= ~(0b1u << 16u);
        curr |= (IPCMDSECUREVIO & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ECCSINGLEERR & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (ECCMULTIERR & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (KEYDONE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SEQTIMEOUT & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (AHBBUSERROR & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SCKSTOPBYWR & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SCKSTOPBYRD & 0b1u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (IPTXWE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (IPRXWA & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (AHBCMDERR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IPCMDERR & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AHBCMDGE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IPCMDGE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IPCMDDONE & 0b1u) << 0u;

        INTR = curr;
    }

    /**
     * Get LUTKEY's KEY field.
     *
     * The Key to lock or unlock LUT.
     */
    inline uint32_t get_LUTKEY_KEY() volatile
    {
        return (LUTKEY >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LUTKEY's KEY field.
     *
     * The Key to lock or unlock LUT.
     */
    inline void set_LUTKEY_KEY(uint32_t value) volatile
    {
        uint32_t curr = LUTKEY;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LUTKEY = curr;
    }

    /**
     * Get LUTCR's PROTECT bit.
     *
     * LUT protection
     */
    inline bool get_LUTCR_PROTECT() volatile
    {
        return LUTCR & (1u << 2u);
    }

    /**
     * Set LUTCR's PROTECT bit.
     *
     * LUT protection
     */
    inline void set_LUTCR_PROTECT() volatile
    {
        LUTCR |= 1u << 2u;
    }

    /**
     * Clear LUTCR's PROTECT bit.
     *
     * LUT protection
     */
    inline void clear_LUTCR_PROTECT() volatile
    {
        LUTCR &= ~(1u << 2u);
    }

    /**
     * Toggle LUTCR's PROTECT bit.
     *
     * LUT protection
     */
    inline void toggle_LUTCR_PROTECT() volatile
    {
        LUTCR ^= 1u << 2u;
    }

    /**
     * Get LUTCR's UNLOCK bit.
     *
     * Unlock LUT
     */
    inline bool get_LUTCR_UNLOCK() volatile
    {
        return LUTCR & (1u << 1u);
    }

    /**
     * Set LUTCR's UNLOCK bit.
     *
     * Unlock LUT
     */
    inline void set_LUTCR_UNLOCK() volatile
    {
        LUTCR |= 1u << 1u;
    }

    /**
     * Clear LUTCR's UNLOCK bit.
     *
     * Unlock LUT
     */
    inline void clear_LUTCR_UNLOCK() volatile
    {
        LUTCR &= ~(1u << 1u);
    }

    /**
     * Toggle LUTCR's UNLOCK bit.
     *
     * Unlock LUT
     */
    inline void toggle_LUTCR_UNLOCK() volatile
    {
        LUTCR ^= 1u << 1u;
    }

    /**
     * Get LUTCR's LOCK bit.
     *
     * Lock LUT
     */
    inline bool get_LUTCR_LOCK() volatile
    {
        return LUTCR & (1u << 0u);
    }

    /**
     * Set LUTCR's LOCK bit.
     *
     * Lock LUT
     */
    inline void set_LUTCR_LOCK() volatile
    {
        LUTCR |= 1u << 0u;
    }

    /**
     * Clear LUTCR's LOCK bit.
     *
     * Lock LUT
     */
    inline void clear_LUTCR_LOCK() volatile
    {
        LUTCR &= ~(1u << 0u);
    }

    /**
     * Toggle LUTCR's LOCK bit.
     *
     * Lock LUT
     */
    inline void toggle_LUTCR_LOCK() volatile
    {
        LUTCR ^= 1u << 0u;
    }

    /**
     * Get all of LUTCR's bit fields.
     *
     * (read-write) LUT Control Register
     */
    inline void get_LUTCR(bool &PROTECT, bool &UNLOCK, bool &LOCK) volatile
    {
        uint32_t curr = LUTCR;

        PROTECT = curr & (1u << 2u);
        UNLOCK = curr & (1u << 1u);
        LOCK = curr & (1u << 0u);
    }

    /**
     * Set all of LUTCR's bit fields.
     *
     * (read-write) LUT Control Register
     */
    inline void set_LUTCR(bool PROTECT, bool UNLOCK, bool LOCK) volatile
    {
        uint32_t curr = LUTCR;

        curr &= ~(0b1u << 2u);
        curr |= (PROTECT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (UNLOCK & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (LOCK & 0b1u) << 0u;

        LUTCR = curr;
    }

    /**
     * Get AHBRXBUF0CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF0CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF0CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF0CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF0CR0_PREFETCHEN() volatile
    {
        AHBRXBUF0CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF0CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF0CR0_PREFETCHEN() volatile
    {
        AHBRXBUF0CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF0CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF0CR0_PREFETCHEN() volatile
    {
        AHBRXBUF0CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF0CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF0CR0_REGIONEN() volatile
    {
        return AHBRXBUF0CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF0CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF0CR0_REGIONEN() volatile
    {
        AHBRXBUF0CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF0CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF0CR0_REGIONEN() volatile
    {
        AHBRXBUF0CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF0CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF0CR0_REGIONEN() volatile
    {
        AHBRXBUF0CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF0CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF0CR0_PRIORITY() volatile
    {
        return (AHBRXBUF0CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF0CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF0CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF0CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF0CR0 = curr;
    }

    /**
     * Get AHBRXBUF0CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF0CR0_MSTRID() volatile
    {
        return (AHBRXBUF0CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF0CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF0CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF0CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF0CR0 = curr;
    }

    /**
     * Get AHBRXBUF0CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF0CR0_BUFSZ() volatile
    {
        return (AHBRXBUF0CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF0CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF0CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF0CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF0CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF0CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 0 Control Register 0
     */
    inline void get_AHBRXBUF0CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF0CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF0CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 0 Control Register 0
     */
    inline void set_AHBRXBUF0CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF0CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF0CR0 = curr;
    }

    /**
     * Get AHBRXBUF1CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF1CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF1CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF1CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF1CR0_PREFETCHEN() volatile
    {
        AHBRXBUF1CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF1CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF1CR0_PREFETCHEN() volatile
    {
        AHBRXBUF1CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF1CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF1CR0_PREFETCHEN() volatile
    {
        AHBRXBUF1CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF1CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF1CR0_REGIONEN() volatile
    {
        return AHBRXBUF1CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF1CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF1CR0_REGIONEN() volatile
    {
        AHBRXBUF1CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF1CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF1CR0_REGIONEN() volatile
    {
        AHBRXBUF1CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF1CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF1CR0_REGIONEN() volatile
    {
        AHBRXBUF1CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF1CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF1CR0_PRIORITY() volatile
    {
        return (AHBRXBUF1CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF1CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF1CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF1CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF1CR0 = curr;
    }

    /**
     * Get AHBRXBUF1CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF1CR0_MSTRID() volatile
    {
        return (AHBRXBUF1CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF1CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF1CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF1CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF1CR0 = curr;
    }

    /**
     * Get AHBRXBUF1CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF1CR0_BUFSZ() volatile
    {
        return (AHBRXBUF1CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF1CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF1CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF1CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF1CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF1CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 1 Control Register 0
     */
    inline void get_AHBRXBUF1CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF1CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF1CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 1 Control Register 0
     */
    inline void set_AHBRXBUF1CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF1CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF1CR0 = curr;
    }

    /**
     * Get AHBRXBUF2CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF2CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF2CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF2CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF2CR0_PREFETCHEN() volatile
    {
        AHBRXBUF2CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF2CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF2CR0_PREFETCHEN() volatile
    {
        AHBRXBUF2CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF2CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF2CR0_PREFETCHEN() volatile
    {
        AHBRXBUF2CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF2CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF2CR0_REGIONEN() volatile
    {
        return AHBRXBUF2CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF2CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF2CR0_REGIONEN() volatile
    {
        AHBRXBUF2CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF2CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF2CR0_REGIONEN() volatile
    {
        AHBRXBUF2CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF2CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF2CR0_REGIONEN() volatile
    {
        AHBRXBUF2CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF2CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF2CR0_PRIORITY() volatile
    {
        return (AHBRXBUF2CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF2CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF2CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF2CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF2CR0 = curr;
    }

    /**
     * Get AHBRXBUF2CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF2CR0_MSTRID() volatile
    {
        return (AHBRXBUF2CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF2CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF2CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF2CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF2CR0 = curr;
    }

    /**
     * Get AHBRXBUF2CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF2CR0_BUFSZ() volatile
    {
        return (AHBRXBUF2CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF2CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF2CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF2CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF2CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF2CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 2 Control Register 0
     */
    inline void get_AHBRXBUF2CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF2CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF2CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 2 Control Register 0
     */
    inline void set_AHBRXBUF2CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF2CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF2CR0 = curr;
    }

    /**
     * Get AHBRXBUF3CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF3CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF3CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF3CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF3CR0_PREFETCHEN() volatile
    {
        AHBRXBUF3CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF3CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF3CR0_PREFETCHEN() volatile
    {
        AHBRXBUF3CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF3CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF3CR0_PREFETCHEN() volatile
    {
        AHBRXBUF3CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF3CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF3CR0_REGIONEN() volatile
    {
        return AHBRXBUF3CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF3CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF3CR0_REGIONEN() volatile
    {
        AHBRXBUF3CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF3CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF3CR0_REGIONEN() volatile
    {
        AHBRXBUF3CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF3CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF3CR0_REGIONEN() volatile
    {
        AHBRXBUF3CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF3CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF3CR0_PRIORITY() volatile
    {
        return (AHBRXBUF3CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF3CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF3CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF3CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF3CR0 = curr;
    }

    /**
     * Get AHBRXBUF3CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF3CR0_MSTRID() volatile
    {
        return (AHBRXBUF3CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF3CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF3CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF3CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF3CR0 = curr;
    }

    /**
     * Get AHBRXBUF3CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF3CR0_BUFSZ() volatile
    {
        return (AHBRXBUF3CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF3CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF3CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF3CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF3CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF3CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 3 Control Register 0
     */
    inline void get_AHBRXBUF3CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF3CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF3CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 3 Control Register 0
     */
    inline void set_AHBRXBUF3CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF3CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF3CR0 = curr;
    }

    /**
     * Get AHBRXBUF4CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF4CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF4CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF4CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF4CR0_PREFETCHEN() volatile
    {
        AHBRXBUF4CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF4CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF4CR0_PREFETCHEN() volatile
    {
        AHBRXBUF4CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF4CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF4CR0_PREFETCHEN() volatile
    {
        AHBRXBUF4CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF4CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF4CR0_REGIONEN() volatile
    {
        return AHBRXBUF4CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF4CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF4CR0_REGIONEN() volatile
    {
        AHBRXBUF4CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF4CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF4CR0_REGIONEN() volatile
    {
        AHBRXBUF4CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF4CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF4CR0_REGIONEN() volatile
    {
        AHBRXBUF4CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF4CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF4CR0_PRIORITY() volatile
    {
        return (AHBRXBUF4CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF4CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF4CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF4CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF4CR0 = curr;
    }

    /**
     * Get AHBRXBUF4CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF4CR0_MSTRID() volatile
    {
        return (AHBRXBUF4CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF4CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF4CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF4CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF4CR0 = curr;
    }

    /**
     * Get AHBRXBUF4CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF4CR0_BUFSZ() volatile
    {
        return (AHBRXBUF4CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF4CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF4CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF4CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF4CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF4CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 4 Control Register 0
     */
    inline void get_AHBRXBUF4CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF4CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF4CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 4 Control Register 0
     */
    inline void set_AHBRXBUF4CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF4CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF4CR0 = curr;
    }

    /**
     * Get AHBRXBUF5CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF5CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF5CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF5CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF5CR0_PREFETCHEN() volatile
    {
        AHBRXBUF5CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF5CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF5CR0_PREFETCHEN() volatile
    {
        AHBRXBUF5CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF5CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF5CR0_PREFETCHEN() volatile
    {
        AHBRXBUF5CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF5CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF5CR0_REGIONEN() volatile
    {
        return AHBRXBUF5CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF5CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF5CR0_REGIONEN() volatile
    {
        AHBRXBUF5CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF5CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF5CR0_REGIONEN() volatile
    {
        AHBRXBUF5CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF5CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF5CR0_REGIONEN() volatile
    {
        AHBRXBUF5CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF5CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF5CR0_PRIORITY() volatile
    {
        return (AHBRXBUF5CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF5CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF5CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF5CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF5CR0 = curr;
    }

    /**
     * Get AHBRXBUF5CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF5CR0_MSTRID() volatile
    {
        return (AHBRXBUF5CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF5CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF5CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF5CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF5CR0 = curr;
    }

    /**
     * Get AHBRXBUF5CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF5CR0_BUFSZ() volatile
    {
        return (AHBRXBUF5CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF5CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF5CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF5CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF5CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF5CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 5 Control Register 0
     */
    inline void get_AHBRXBUF5CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF5CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF5CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 5 Control Register 0
     */
    inline void set_AHBRXBUF5CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF5CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF5CR0 = curr;
    }

    /**
     * Get AHBRXBUF6CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF6CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF6CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF6CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF6CR0_PREFETCHEN() volatile
    {
        AHBRXBUF6CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF6CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF6CR0_PREFETCHEN() volatile
    {
        AHBRXBUF6CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF6CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF6CR0_PREFETCHEN() volatile
    {
        AHBRXBUF6CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF6CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF6CR0_REGIONEN() volatile
    {
        return AHBRXBUF6CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF6CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF6CR0_REGIONEN() volatile
    {
        AHBRXBUF6CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF6CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF6CR0_REGIONEN() volatile
    {
        AHBRXBUF6CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF6CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF6CR0_REGIONEN() volatile
    {
        AHBRXBUF6CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF6CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF6CR0_PRIORITY() volatile
    {
        return (AHBRXBUF6CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF6CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF6CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF6CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF6CR0 = curr;
    }

    /**
     * Get AHBRXBUF6CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF6CR0_MSTRID() volatile
    {
        return (AHBRXBUF6CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF6CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF6CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF6CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF6CR0 = curr;
    }

    /**
     * Get AHBRXBUF6CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF6CR0_BUFSZ() volatile
    {
        return (AHBRXBUF6CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF6CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF6CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF6CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF6CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF6CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 6 Control Register 0
     */
    inline void get_AHBRXBUF6CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF6CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF6CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 6 Control Register 0
     */
    inline void set_AHBRXBUF6CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF6CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF6CR0 = curr;
    }

    /**
     * Get AHBRXBUF7CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline bool get_AHBRXBUF7CR0_PREFETCHEN() volatile
    {
        return AHBRXBUF7CR0 & (1u << 31u);
    }

    /**
     * Set AHBRXBUF7CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void set_AHBRXBUF7CR0_PREFETCHEN() volatile
    {
        AHBRXBUF7CR0 |= 1u << 31u;
    }

    /**
     * Clear AHBRXBUF7CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void clear_AHBRXBUF7CR0_PREFETCHEN() volatile
    {
        AHBRXBUF7CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle AHBRXBUF7CR0's PREFETCHEN bit.
     *
     * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
     */
    inline void toggle_AHBRXBUF7CR0_PREFETCHEN() volatile
    {
        AHBRXBUF7CR0 ^= 1u << 31u;
    }

    /**
     * Get AHBRXBUF7CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline bool get_AHBRXBUF7CR0_REGIONEN() volatile
    {
        return AHBRXBUF7CR0 & (1u << 30u);
    }

    /**
     * Set AHBRXBUF7CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void set_AHBRXBUF7CR0_REGIONEN() volatile
    {
        AHBRXBUF7CR0 |= 1u << 30u;
    }

    /**
     * Clear AHBRXBUF7CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void clear_AHBRXBUF7CR0_REGIONEN() volatile
    {
        AHBRXBUF7CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle AHBRXBUF7CR0's REGIONEN bit.
     *
     * AHB RX Buffer address region funciton enable
     */
    inline void toggle_AHBRXBUF7CR0_REGIONEN() volatile
    {
        AHBRXBUF7CR0 ^= 1u << 30u;
    }

    /**
     * Get AHBRXBUF7CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline uint8_t get_AHBRXBUF7CR0_PRIORITY() volatile
    {
        return (AHBRXBUF7CR0 >> 24u) & 0b111u;
    }

    /**
     * Set AHBRXBUF7CR0's PRIORITY field.
     *
     * This priority for AHB Master Read which this AHB RX Buffer is assigned.
     * 7 is the highest priority, 0 the lowest.
     */
    inline void set_AHBRXBUF7CR0_PRIORITY(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF7CR0;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        AHBRXBUF7CR0 = curr;
    }

    /**
     * Get AHBRXBUF7CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline uint8_t get_AHBRXBUF7CR0_MSTRID() volatile
    {
        return (AHBRXBUF7CR0 >> 16u) & 0b1111u;
    }

    /**
     * Set AHBRXBUF7CR0's MSTRID field.
     *
     * This AHB RX Buffer is assigned according to AHB Master with ID
     * (MSTR_ID).
     */
    inline void set_AHBRXBUF7CR0_MSTRID(uint8_t value) volatile
    {
        uint32_t curr = AHBRXBUF7CR0;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        AHBRXBUF7CR0 = curr;
    }

    /**
     * Get AHBRXBUF7CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline uint16_t get_AHBRXBUF7CR0_BUFSZ() volatile
    {
        return (AHBRXBUF7CR0 >> 0u) & 0b1111111111u;
    }

    /**
     * Set AHBRXBUF7CR0's BUFSZ field.
     *
     * AHB RX Buffer Size in 64 bits.
     */
    inline void set_AHBRXBUF7CR0_BUFSZ(uint16_t value) volatile
    {
        uint32_t curr = AHBRXBUF7CR0;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        AHBRXBUF7CR0 = curr;
    }

    /**
     * Get all of AHBRXBUF7CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 7 Control Register 0
     */
    inline void get_AHBRXBUF7CR0(bool &PREFETCHEN, bool &REGIONEN,
                                 uint8_t &PRIORITY, uint8_t &MSTRID,
                                 uint16_t &BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF7CR0;

        PREFETCHEN = curr & (1u << 31u);
        REGIONEN = curr & (1u << 30u);
        PRIORITY = (curr >> 24u) & 0b111u;
        MSTRID = (curr >> 16u) & 0b1111u;
        BUFSZ = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of AHBRXBUF7CR0's bit fields.
     *
     * (read-write) AHB RX Buffer 7 Control Register 0
     */
    inline void set_AHBRXBUF7CR0(bool PREFETCHEN, bool REGIONEN,
                                 uint8_t PRIORITY, uint8_t MSTRID,
                                 uint16_t BUFSZ) volatile
    {
        uint32_t curr = AHBRXBUF7CR0;

        curr &= ~(0b1u << 31u);
        curr |= (PREFETCHEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (REGIONEN & 0b1u) << 30u;
        curr &= ~(0b111u << 24u);
        curr |= (PRIORITY & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (MSTRID & 0b1111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (BUFSZ & 0b1111111111u) << 0u;

        AHBRXBUF7CR0 = curr;
    }

    /**
     * Get FLSHA1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline bool get_FLSHA1CR0_SPLITRDEN() volatile
    {
        return FLSHA1CR0 & (1u << 31u);
    }

    /**
     * Set FLSHA1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void set_FLSHA1CR0_SPLITRDEN() volatile
    {
        FLSHA1CR0 |= 1u << 31u;
    }

    /**
     * Clear FLSHA1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void clear_FLSHA1CR0_SPLITRDEN() volatile
    {
        FLSHA1CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle FLSHA1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void toggle_FLSHA1CR0_SPLITRDEN() volatile
    {
        FLSHA1CR0 ^= 1u << 31u;
    }

    /**
     * Get FLSHA1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline bool get_FLSHA1CR0_SPLITWREN() volatile
    {
        return FLSHA1CR0 & (1u << 30u);
    }

    /**
     * Set FLSHA1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void set_FLSHA1CR0_SPLITWREN() volatile
    {
        FLSHA1CR0 |= 1u << 30u;
    }

    /**
     * Clear FLSHA1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void clear_FLSHA1CR0_SPLITWREN() volatile
    {
        FLSHA1CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle FLSHA1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void toggle_FLSHA1CR0_SPLITWREN() volatile
    {
        FLSHA1CR0 ^= 1u << 30u;
    }

    /**
     * Get FLSHA1CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline uint32_t get_FLSHA1CR0_FLSHSZ() volatile
    {
        return (FLSHA1CR0 >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set FLSHA1CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline void set_FLSHA1CR0_FLSHSZ(uint32_t value) volatile
    {
        uint32_t curr = FLSHA1CR0;

        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111u) << 0u;

        FLSHA1CR0 = curr;
    }

    /**
     * Get all of FLSHA1CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void get_FLSHA1CR0(bool &SPLITRDEN, bool &SPLITWREN,
                              uint32_t &FLSHSZ) volatile
    {
        uint32_t curr = FLSHA1CR0;

        SPLITRDEN = curr & (1u << 31u);
        SPLITWREN = curr & (1u << 30u);
        FLSHSZ = (curr >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set all of FLSHA1CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void set_FLSHA1CR0(bool SPLITRDEN, bool SPLITWREN,
                              uint32_t FLSHSZ) volatile
    {
        uint32_t curr = FLSHA1CR0;

        curr &= ~(0b1u << 31u);
        curr |= (SPLITRDEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SPLITWREN & 0b1u) << 30u;
        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (FLSHSZ & 0b11111111111111111111111u) << 0u;

        FLSHA1CR0 = curr;
    }

    /**
     * Get FLSHA2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline bool get_FLSHA2CR0_SPLITRDEN() volatile
    {
        return FLSHA2CR0 & (1u << 31u);
    }

    /**
     * Set FLSHA2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void set_FLSHA2CR0_SPLITRDEN() volatile
    {
        FLSHA2CR0 |= 1u << 31u;
    }

    /**
     * Clear FLSHA2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void clear_FLSHA2CR0_SPLITRDEN() volatile
    {
        FLSHA2CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle FLSHA2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void toggle_FLSHA2CR0_SPLITRDEN() volatile
    {
        FLSHA2CR0 ^= 1u << 31u;
    }

    /**
     * Get FLSHA2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline bool get_FLSHA2CR0_SPLITWREN() volatile
    {
        return FLSHA2CR0 & (1u << 30u);
    }

    /**
     * Set FLSHA2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void set_FLSHA2CR0_SPLITWREN() volatile
    {
        FLSHA2CR0 |= 1u << 30u;
    }

    /**
     * Clear FLSHA2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void clear_FLSHA2CR0_SPLITWREN() volatile
    {
        FLSHA2CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle FLSHA2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void toggle_FLSHA2CR0_SPLITWREN() volatile
    {
        FLSHA2CR0 ^= 1u << 30u;
    }

    /**
     * Get FLSHA2CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline uint32_t get_FLSHA2CR0_FLSHSZ() volatile
    {
        return (FLSHA2CR0 >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set FLSHA2CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline void set_FLSHA2CR0_FLSHSZ(uint32_t value) volatile
    {
        uint32_t curr = FLSHA2CR0;

        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111u) << 0u;

        FLSHA2CR0 = curr;
    }

    /**
     * Get all of FLSHA2CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void get_FLSHA2CR0(bool &SPLITRDEN, bool &SPLITWREN,
                              uint32_t &FLSHSZ) volatile
    {
        uint32_t curr = FLSHA2CR0;

        SPLITRDEN = curr & (1u << 31u);
        SPLITWREN = curr & (1u << 30u);
        FLSHSZ = (curr >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set all of FLSHA2CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void set_FLSHA2CR0(bool SPLITRDEN, bool SPLITWREN,
                              uint32_t FLSHSZ) volatile
    {
        uint32_t curr = FLSHA2CR0;

        curr &= ~(0b1u << 31u);
        curr |= (SPLITRDEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SPLITWREN & 0b1u) << 30u;
        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (FLSHSZ & 0b11111111111111111111111u) << 0u;

        FLSHA2CR0 = curr;
    }

    /**
     * Get FLSHB1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline bool get_FLSHB1CR0_SPLITRDEN() volatile
    {
        return FLSHB1CR0 & (1u << 31u);
    }

    /**
     * Set FLSHB1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void set_FLSHB1CR0_SPLITRDEN() volatile
    {
        FLSHB1CR0 |= 1u << 31u;
    }

    /**
     * Clear FLSHB1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void clear_FLSHB1CR0_SPLITRDEN() volatile
    {
        FLSHB1CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle FLSHB1CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void toggle_FLSHB1CR0_SPLITRDEN() volatile
    {
        FLSHB1CR0 ^= 1u << 31u;
    }

    /**
     * Get FLSHB1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline bool get_FLSHB1CR0_SPLITWREN() volatile
    {
        return FLSHB1CR0 & (1u << 30u);
    }

    /**
     * Set FLSHB1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void set_FLSHB1CR0_SPLITWREN() volatile
    {
        FLSHB1CR0 |= 1u << 30u;
    }

    /**
     * Clear FLSHB1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void clear_FLSHB1CR0_SPLITWREN() volatile
    {
        FLSHB1CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle FLSHB1CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void toggle_FLSHB1CR0_SPLITWREN() volatile
    {
        FLSHB1CR0 ^= 1u << 30u;
    }

    /**
     * Get FLSHB1CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline uint32_t get_FLSHB1CR0_FLSHSZ() volatile
    {
        return (FLSHB1CR0 >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set FLSHB1CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline void set_FLSHB1CR0_FLSHSZ(uint32_t value) volatile
    {
        uint32_t curr = FLSHB1CR0;

        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111u) << 0u;

        FLSHB1CR0 = curr;
    }

    /**
     * Get all of FLSHB1CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void get_FLSHB1CR0(bool &SPLITRDEN, bool &SPLITWREN,
                              uint32_t &FLSHSZ) volatile
    {
        uint32_t curr = FLSHB1CR0;

        SPLITRDEN = curr & (1u << 31u);
        SPLITWREN = curr & (1u << 30u);
        FLSHSZ = (curr >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set all of FLSHB1CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void set_FLSHB1CR0(bool SPLITRDEN, bool SPLITWREN,
                              uint32_t FLSHSZ) volatile
    {
        uint32_t curr = FLSHB1CR0;

        curr &= ~(0b1u << 31u);
        curr |= (SPLITRDEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SPLITWREN & 0b1u) << 30u;
        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (FLSHSZ & 0b11111111111111111111111u) << 0u;

        FLSHB1CR0 = curr;
    }

    /**
     * Get FLSHB2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline bool get_FLSHB2CR0_SPLITRDEN() volatile
    {
        return FLSHB2CR0 & (1u << 31u);
    }

    /**
     * Set FLSHB2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void set_FLSHB2CR0_SPLITRDEN() volatile
    {
        FLSHB2CR0 |= 1u << 31u;
    }

    /**
     * Clear FLSHB2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void clear_FLSHB2CR0_SPLITRDEN() volatile
    {
        FLSHB2CR0 &= ~(1u << 31u);
    }

    /**
     * Toggle FLSHB2CR0's SPLITRDEN bit.
     *
     * AHB read access split function control.
     */
    inline void toggle_FLSHB2CR0_SPLITRDEN() volatile
    {
        FLSHB2CR0 ^= 1u << 31u;
    }

    /**
     * Get FLSHB2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline bool get_FLSHB2CR0_SPLITWREN() volatile
    {
        return FLSHB2CR0 & (1u << 30u);
    }

    /**
     * Set FLSHB2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void set_FLSHB2CR0_SPLITWREN() volatile
    {
        FLSHB2CR0 |= 1u << 30u;
    }

    /**
     * Clear FLSHB2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void clear_FLSHB2CR0_SPLITWREN() volatile
    {
        FLSHB2CR0 &= ~(1u << 30u);
    }

    /**
     * Toggle FLSHB2CR0's SPLITWREN bit.
     *
     * AHB write access split function control.
     */
    inline void toggle_FLSHB2CR0_SPLITWREN() volatile
    {
        FLSHB2CR0 ^= 1u << 30u;
    }

    /**
     * Get FLSHB2CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline uint32_t get_FLSHB2CR0_FLSHSZ() volatile
    {
        return (FLSHB2CR0 >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set FLSHB2CR0's FLSHSZ field.
     *
     * Flash Size in KByte.
     */
    inline void set_FLSHB2CR0_FLSHSZ(uint32_t value) volatile
    {
        uint32_t curr = FLSHB2CR0;

        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111u) << 0u;

        FLSHB2CR0 = curr;
    }

    /**
     * Get all of FLSHB2CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void get_FLSHB2CR0(bool &SPLITRDEN, bool &SPLITWREN,
                              uint32_t &FLSHSZ) volatile
    {
        uint32_t curr = FLSHB2CR0;

        SPLITRDEN = curr & (1u << 31u);
        SPLITWREN = curr & (1u << 30u);
        FLSHSZ = (curr >> 0u) & 0b11111111111111111111111u;
    }

    /**
     * Set all of FLSHB2CR0's bit fields.
     *
     * (read-write) Flash Control Register 0
     */
    inline void set_FLSHB2CR0(bool SPLITRDEN, bool SPLITWREN,
                              uint32_t FLSHSZ) volatile
    {
        uint32_t curr = FLSHB2CR0;

        curr &= ~(0b1u << 31u);
        curr |= (SPLITRDEN & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (SPLITWREN & 0b1u) << 30u;
        curr &= ~(0b11111111111111111111111u << 0u);
        curr |= (FLSHSZ & 0b11111111111111111111111u) << 0u;

        FLSHB2CR0 = curr;
    }

    /**
     * Get FLSHCR1's CSINTERVAL field.
     *
     * This field is used to set the minimum interval between flash device Chip
     * selection deassertion and flash device Chip selection assertion. If
     * external flash has a limitation on the interval between command
     * sequences, this field should be set accordingly. If there is no
     * limitation, set this field with value 0x0.
     */
    inline uint16_t get_FLSHCR1_CSINTERVAL(std::size_t index) volatile
    {
        return (FLSHCR1[index] >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set FLSHCR1's CSINTERVAL field.
     *
     * This field is used to set the minimum interval between flash device Chip
     * selection deassertion and flash device Chip selection assertion. If
     * external flash has a limitation on the interval between command
     * sequences, this field should be set accordingly. If there is no
     * limitation, set this field with value 0x0.
     */
    inline void set_FLSHCR1_CSINTERVAL(std::size_t index,
                                       uint16_t value) volatile
    {
        uint32_t curr = FLSHCR1[index];

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        FLSHCR1[index] = curr;
    }

    /**
     * Get FLSHCR1's CSINTERVALUNIT bit.
     *
     * CS interval unit
     */
    inline bool get_FLSHCR1_CSINTERVALUNIT(std::size_t index) volatile
    {
        return FLSHCR1[index] & (1u << 15u);
    }

    /**
     * Set FLSHCR1's CSINTERVALUNIT bit.
     *
     * CS interval unit
     */
    inline void set_FLSHCR1_CSINTERVALUNIT() volatile
    {
        FLSHCR1 |= 1u << 15u;
    }

    /**
     * Clear FLSHCR1's CSINTERVALUNIT bit.
     *
     * CS interval unit
     */
    inline void clear_FLSHCR1_CSINTERVALUNIT() volatile
    {
        FLSHCR1 &= ~(1u << 15u);
    }

    /**
     * Toggle FLSHCR1's CSINTERVALUNIT bit.
     *
     * CS interval unit
     */
    inline void toggle_FLSHCR1_CSINTERVALUNIT() volatile
    {
        FLSHCR1 ^= 1u << 15u;
    }

    /**
     * Get FLSHCR1's CAS field.
     *
     * Column Address Size.
     */
    inline uint8_t get_FLSHCR1_CAS(std::size_t index) volatile
    {
        return (FLSHCR1[index] >> 11u) & 0b1111u;
    }

    /**
     * Set FLSHCR1's CAS field.
     *
     * Column Address Size.
     */
    inline void set_FLSHCR1_CAS(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = FLSHCR1[index];

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        FLSHCR1[index] = curr;
    }

    /**
     * Get FLSHCR1's WA bit.
     *
     * Word Addressable.
     */
    inline bool get_FLSHCR1_WA(std::size_t index) volatile
    {
        return FLSHCR1[index] & (1u << 10u);
    }

    /**
     * Set FLSHCR1's WA bit.
     *
     * Word Addressable.
     */
    inline void set_FLSHCR1_WA() volatile
    {
        FLSHCR1 |= 1u << 10u;
    }

    /**
     * Clear FLSHCR1's WA bit.
     *
     * Word Addressable.
     */
    inline void clear_FLSHCR1_WA() volatile
    {
        FLSHCR1 &= ~(1u << 10u);
    }

    /**
     * Toggle FLSHCR1's WA bit.
     *
     * Word Addressable.
     */
    inline void toggle_FLSHCR1_WA() volatile
    {
        FLSHCR1 ^= 1u << 10u;
    }

    /**
     * Get FLSHCR1's TCSH field.
     *
     * Serial Flash CS Hold time.
     */
    inline uint8_t get_FLSHCR1_TCSH(std::size_t index) volatile
    {
        return (FLSHCR1[index] >> 5u) & 0b11111u;
    }

    /**
     * Set FLSHCR1's TCSH field.
     *
     * Serial Flash CS Hold time.
     */
    inline void set_FLSHCR1_TCSH(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = FLSHCR1[index];

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        FLSHCR1[index] = curr;
    }

    /**
     * Get FLSHCR1's TCSS field.
     *
     * Serial Flash CS setup time.
     */
    inline uint8_t get_FLSHCR1_TCSS(std::size_t index) volatile
    {
        return (FLSHCR1[index] >> 0u) & 0b11111u;
    }

    /**
     * Set FLSHCR1's TCSS field.
     *
     * Serial Flash CS setup time.
     */
    inline void set_FLSHCR1_TCSS(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = FLSHCR1[index];

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        FLSHCR1[index] = curr;
    }

    /**
     * Get all of FLSHCR1's bit fields.
     *
     * (read-write) Flash Control Register 1
     */
    inline void get_FLSHCR1(std::size_t index, uint16_t &CSINTERVAL,
                            bool &CSINTERVALUNIT, uint8_t &CAS, bool &WA,
                            uint8_t &TCSH, uint8_t &TCSS) volatile
    {
        uint32_t curr = FLSHCR1[index];

        CSINTERVAL = (curr >> 16u) & 0b1111111111111111u;
        CSINTERVALUNIT = curr & (1u << 15u);
        CAS = (curr >> 11u) & 0b1111u;
        WA = curr & (1u << 10u);
        TCSH = (curr >> 5u) & 0b11111u;
        TCSS = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of FLSHCR1's bit fields.
     *
     * (read-write) Flash Control Register 1
     */
    inline void set_FLSHCR1(std::size_t index, uint16_t CSINTERVAL,
                            bool CSINTERVALUNIT, uint8_t CAS, bool WA,
                            uint8_t TCSH, uint8_t TCSS) volatile
    {
        uint32_t curr = FLSHCR1[index];

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (CSINTERVAL & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (CSINTERVALUNIT & 0b1u) << 15u;
        curr &= ~(0b1111u << 11u);
        curr |= (CAS & 0b1111u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (WA & 0b1u) << 10u;
        curr &= ~(0b11111u << 5u);
        curr |= (TCSH & 0b11111u) << 5u;
        curr &= ~(0b11111u << 0u);
        curr |= (TCSS & 0b11111u) << 0u;

        FLSHCR1[index] = curr;
    }

    /**
     * Get FLSHCR2's CLRINSTRPTR bit.
     *
     * Clear the instruction pointer which is internally saved pointer by
     * JMP_ON_CS. Refer Programmable Sequence Engine for details.
     */
    inline bool get_FLSHCR2_CLRINSTRPTR(std::size_t index) volatile
    {
        return FLSHCR2[index] & (1u << 31u);
    }

    /**
     * Set FLSHCR2's CLRINSTRPTR bit.
     *
     * Clear the instruction pointer which is internally saved pointer by
     * JMP_ON_CS. Refer Programmable Sequence Engine for details.
     */
    inline void set_FLSHCR2_CLRINSTRPTR() volatile
    {
        FLSHCR2 |= 1u << 31u;
    }

    /**
     * Clear FLSHCR2's CLRINSTRPTR bit.
     *
     * Clear the instruction pointer which is internally saved pointer by
     * JMP_ON_CS. Refer Programmable Sequence Engine for details.
     */
    inline void clear_FLSHCR2_CLRINSTRPTR() volatile
    {
        FLSHCR2 &= ~(1u << 31u);
    }

    /**
     * Toggle FLSHCR2's CLRINSTRPTR bit.
     *
     * Clear the instruction pointer which is internally saved pointer by
     * JMP_ON_CS. Refer Programmable Sequence Engine for details.
     */
    inline void toggle_FLSHCR2_CLRINSTRPTR() volatile
    {
        FLSHCR2 ^= 1u << 31u;
    }

    /**
     * Get FLSHCR2's AWRWAITUNIT field.
     *
     * AWRWAIT unit
     */
    inline FLEXSPI1_FLSHCR2_AWRWAITUNIT get_FLSHCR2_AWRWAITUNIT(
        std::size_t index) volatile
    {
        return FLEXSPI1_FLSHCR2_AWRWAITUNIT((FLSHCR2[index] >> 28u) & 0b111u);
    }

    /**
     * Set FLSHCR2's AWRWAITUNIT field.
     *
     * AWRWAIT unit
     */
    inline void set_FLSHCR2_AWRWAITUNIT(
        std::size_t index, FLEXSPI1_FLSHCR2_AWRWAITUNIT value) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b111u << 28u);
        curr |= (std::to_underlying(value) & 0b111u) << 28u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get FLSHCR2's AWRWAIT field.
     *
     * For certain devices (such as FPGA), it need some time to write data into
     * internal memory after the command sequences finished on FlexSPI
     * interface
     */
    inline uint16_t get_FLSHCR2_AWRWAIT(std::size_t index) volatile
    {
        return (FLSHCR2[index] >> 16u) & 0b111111111111u;
    }

    /**
     * Set FLSHCR2's AWRWAIT field.
     *
     * For certain devices (such as FPGA), it need some time to write data into
     * internal memory after the command sequences finished on FlexSPI
     * interface
     */
    inline void set_FLSHCR2_AWRWAIT(std::size_t index, uint16_t value) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get FLSHCR2's AWRSEQNUM field.
     *
     * Sequence Number for AHB Write triggered Command.
     */
    inline uint8_t get_FLSHCR2_AWRSEQNUM(std::size_t index) volatile
    {
        return (FLSHCR2[index] >> 13u) & 0b111u;
    }

    /**
     * Set FLSHCR2's AWRSEQNUM field.
     *
     * Sequence Number for AHB Write triggered Command.
     */
    inline void set_FLSHCR2_AWRSEQNUM(std::size_t index,
                                      uint8_t value) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b111u << 13u);
        curr |= (value & 0b111u) << 13u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get FLSHCR2's AWRSEQID field.
     *
     * Sequence Index for AHB Write triggered Command.
     */
    inline uint8_t get_FLSHCR2_AWRSEQID(std::size_t index) volatile
    {
        return (FLSHCR2[index] >> 8u) & 0b1111u;
    }

    /**
     * Set FLSHCR2's AWRSEQID field.
     *
     * Sequence Index for AHB Write triggered Command.
     */
    inline void set_FLSHCR2_AWRSEQID(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get FLSHCR2's ARDSEQNUM field.
     *
     * Sequence Number for AHB Read triggered Command in LUT.
     */
    inline uint8_t get_FLSHCR2_ARDSEQNUM(std::size_t index) volatile
    {
        return (FLSHCR2[index] >> 5u) & 0b111u;
    }

    /**
     * Set FLSHCR2's ARDSEQNUM field.
     *
     * Sequence Number for AHB Read triggered Command in LUT.
     */
    inline void set_FLSHCR2_ARDSEQNUM(std::size_t index,
                                      uint8_t value) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b111u << 5u);
        curr |= (value & 0b111u) << 5u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get FLSHCR2's ARDSEQID field.
     *
     * Sequence Index for AHB Read triggered Command in LUT.
     */
    inline uint8_t get_FLSHCR2_ARDSEQID(std::size_t index) volatile
    {
        return (FLSHCR2[index] >> 0u) & 0b1111u;
    }

    /**
     * Set FLSHCR2's ARDSEQID field.
     *
     * Sequence Index for AHB Read triggered Command in LUT.
     */
    inline void set_FLSHCR2_ARDSEQID(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get all of FLSHCR2's bit fields.
     *
     * (read-write) Flash Control Register 2
     */
    inline void get_FLSHCR2(std::size_t index, bool &CLRINSTRPTR,
                            FLEXSPI1_FLSHCR2_AWRWAITUNIT &AWRWAITUNIT,
                            uint16_t &AWRWAIT, uint8_t &AWRSEQNUM,
                            uint8_t &AWRSEQID, uint8_t &ARDSEQNUM,
                            uint8_t &ARDSEQID) volatile
    {
        uint32_t curr = FLSHCR2[index];

        CLRINSTRPTR = curr & (1u << 31u);
        AWRWAITUNIT = FLEXSPI1_FLSHCR2_AWRWAITUNIT((curr >> 28u) & 0b111u);
        AWRWAIT = (curr >> 16u) & 0b111111111111u;
        AWRSEQNUM = (curr >> 13u) & 0b111u;
        AWRSEQID = (curr >> 8u) & 0b1111u;
        ARDSEQNUM = (curr >> 5u) & 0b111u;
        ARDSEQID = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of FLSHCR2's bit fields.
     *
     * (read-write) Flash Control Register 2
     */
    inline void set_FLSHCR2(std::size_t index, bool CLRINSTRPTR,
                            FLEXSPI1_FLSHCR2_AWRWAITUNIT AWRWAITUNIT,
                            uint16_t AWRWAIT, uint8_t AWRSEQNUM,
                            uint8_t AWRSEQID, uint8_t ARDSEQNUM,
                            uint8_t ARDSEQID) volatile
    {
        uint32_t curr = FLSHCR2[index];

        curr &= ~(0b1u << 31u);
        curr |= (CLRINSTRPTR & 0b1u) << 31u;
        curr &= ~(0b111u << 28u);
        curr |= (std::to_underlying(AWRWAITUNIT) & 0b111u) << 28u;
        curr &= ~(0b111111111111u << 16u);
        curr |= (AWRWAIT & 0b111111111111u) << 16u;
        curr &= ~(0b111u << 13u);
        curr |= (AWRSEQNUM & 0b111u) << 13u;
        curr &= ~(0b1111u << 8u);
        curr |= (AWRSEQID & 0b1111u) << 8u;
        curr &= ~(0b111u << 5u);
        curr |= (ARDSEQNUM & 0b111u) << 5u;
        curr &= ~(0b1111u << 0u);
        curr |= (ARDSEQID & 0b1111u) << 0u;

        FLSHCR2[index] = curr;
    }

    /**
     * Get FLSHCR4's PAR_ADDR_ADJ_DIS bit.
     *
     * Disable the address shift logic for lower density of 16 bit PSRAM.
     */
    inline bool get_FLSHCR4_PAR_ADDR_ADJ_DIS() volatile
    {
        return FLSHCR4 & (1u << 11u);
    }

    /**
     * Set FLSHCR4's PAR_ADDR_ADJ_DIS bit.
     *
     * Disable the address shift logic for lower density of 16 bit PSRAM.
     */
    inline void set_FLSHCR4_PAR_ADDR_ADJ_DIS() volatile
    {
        FLSHCR4 |= 1u << 11u;
    }

    /**
     * Clear FLSHCR4's PAR_ADDR_ADJ_DIS bit.
     *
     * Disable the address shift logic for lower density of 16 bit PSRAM.
     */
    inline void clear_FLSHCR4_PAR_ADDR_ADJ_DIS() volatile
    {
        FLSHCR4 &= ~(1u << 11u);
    }

    /**
     * Toggle FLSHCR4's PAR_ADDR_ADJ_DIS bit.
     *
     * Disable the address shift logic for lower density of 16 bit PSRAM.
     */
    inline void toggle_FLSHCR4_PAR_ADDR_ADJ_DIS() volatile
    {
        FLSHCR4 ^= 1u << 11u;
    }

    /**
     * Get FLSHCR4's PAR_WM field.
     *
     * Enable APMEM 16 bit write mask function, bit 9 for A1-B1 pair, bit 10
     * for A2-B2 pair.
     */
    inline uint8_t get_FLSHCR4_PAR_WM() volatile
    {
        return (FLSHCR4 >> 9u) & 0b11u;
    }

    /**
     * Set FLSHCR4's PAR_WM field.
     *
     * Enable APMEM 16 bit write mask function, bit 9 for A1-B1 pair, bit 10
     * for A2-B2 pair.
     */
    inline void set_FLSHCR4_PAR_WM(uint8_t value) volatile
    {
        uint32_t curr = FLSHCR4;

        curr &= ~(0b11u << 9u);
        curr |= (value & 0b11u) << 9u;

        FLSHCR4 = curr;
    }

    /**
     * Get FLSHCR4's WMENB bit.
     *
     * Write mask enable bit for flash device on port B. When write mask
     * function is needed for memory device on port B, this bit must be set.
     */
    inline bool get_FLSHCR4_WMENB() volatile
    {
        return FLSHCR4 & (1u << 3u);
    }

    /**
     * Set FLSHCR4's WMENB bit.
     *
     * Write mask enable bit for flash device on port B. When write mask
     * function is needed for memory device on port B, this bit must be set.
     */
    inline void set_FLSHCR4_WMENB() volatile
    {
        FLSHCR4 |= 1u << 3u;
    }

    /**
     * Clear FLSHCR4's WMENB bit.
     *
     * Write mask enable bit for flash device on port B. When write mask
     * function is needed for memory device on port B, this bit must be set.
     */
    inline void clear_FLSHCR4_WMENB() volatile
    {
        FLSHCR4 &= ~(1u << 3u);
    }

    /**
     * Toggle FLSHCR4's WMENB bit.
     *
     * Write mask enable bit for flash device on port B. When write mask
     * function is needed for memory device on port B, this bit must be set.
     */
    inline void toggle_FLSHCR4_WMENB() volatile
    {
        FLSHCR4 ^= 1u << 3u;
    }

    /**
     * Get FLSHCR4's WMENA bit.
     *
     * Write mask enable bit for flash device on port A. When write mask
     * function is needed for memory device on port A, this bit must be set.
     */
    inline bool get_FLSHCR4_WMENA() volatile
    {
        return FLSHCR4 & (1u << 2u);
    }

    /**
     * Set FLSHCR4's WMENA bit.
     *
     * Write mask enable bit for flash device on port A. When write mask
     * function is needed for memory device on port A, this bit must be set.
     */
    inline void set_FLSHCR4_WMENA() volatile
    {
        FLSHCR4 |= 1u << 2u;
    }

    /**
     * Clear FLSHCR4's WMENA bit.
     *
     * Write mask enable bit for flash device on port A. When write mask
     * function is needed for memory device on port A, this bit must be set.
     */
    inline void clear_FLSHCR4_WMENA() volatile
    {
        FLSHCR4 &= ~(1u << 2u);
    }

    /**
     * Toggle FLSHCR4's WMENA bit.
     *
     * Write mask enable bit for flash device on port A. When write mask
     * function is needed for memory device on port A, this bit must be set.
     */
    inline void toggle_FLSHCR4_WMENA() volatile
    {
        FLSHCR4 ^= 1u << 2u;
    }

    /**
     * Get FLSHCR4's WMOPT2 bit.
     *
     * Write mask option bit 2. When using AP memory, This option bit could be
     * used to remove AHB write burst minimal length limitation. When using
     * this bit, WMOPT1 should also be set.
     */
    inline bool get_FLSHCR4_WMOPT2() volatile
    {
        return FLSHCR4 & (1u << 1u);
    }

    /**
     * Set FLSHCR4's WMOPT2 bit.
     *
     * Write mask option bit 2. When using AP memory, This option bit could be
     * used to remove AHB write burst minimal length limitation. When using
     * this bit, WMOPT1 should also be set.
     */
    inline void set_FLSHCR4_WMOPT2() volatile
    {
        FLSHCR4 |= 1u << 1u;
    }

    /**
     * Clear FLSHCR4's WMOPT2 bit.
     *
     * Write mask option bit 2. When using AP memory, This option bit could be
     * used to remove AHB write burst minimal length limitation. When using
     * this bit, WMOPT1 should also be set.
     */
    inline void clear_FLSHCR4_WMOPT2() volatile
    {
        FLSHCR4 &= ~(1u << 1u);
    }

    /**
     * Toggle FLSHCR4's WMOPT2 bit.
     *
     * Write mask option bit 2. When using AP memory, This option bit could be
     * used to remove AHB write burst minimal length limitation. When using
     * this bit, WMOPT1 should also be set.
     */
    inline void toggle_FLSHCR4_WMOPT2() volatile
    {
        FLSHCR4 ^= 1u << 1u;
    }

    /**
     * Get FLSHCR4's WMOPT1 bit.
     *
     * Write mask option bit 1. This option bit could be used to remove AHB
     * write burst start address alignment limitation.
     */
    inline bool get_FLSHCR4_WMOPT1() volatile
    {
        return FLSHCR4 & (1u << 0u);
    }

    /**
     * Set FLSHCR4's WMOPT1 bit.
     *
     * Write mask option bit 1. This option bit could be used to remove AHB
     * write burst start address alignment limitation.
     */
    inline void set_FLSHCR4_WMOPT1() volatile
    {
        FLSHCR4 |= 1u << 0u;
    }

    /**
     * Clear FLSHCR4's WMOPT1 bit.
     *
     * Write mask option bit 1. This option bit could be used to remove AHB
     * write burst start address alignment limitation.
     */
    inline void clear_FLSHCR4_WMOPT1() volatile
    {
        FLSHCR4 &= ~(1u << 0u);
    }

    /**
     * Toggle FLSHCR4's WMOPT1 bit.
     *
     * Write mask option bit 1. This option bit could be used to remove AHB
     * write burst start address alignment limitation.
     */
    inline void toggle_FLSHCR4_WMOPT1() volatile
    {
        FLSHCR4 ^= 1u << 0u;
    }

    /**
     * Get all of FLSHCR4's bit fields.
     *
     * (read-write) Flash Control Register 4
     */
    inline void get_FLSHCR4(bool &PAR_ADDR_ADJ_DIS, uint8_t &PAR_WM,
                            bool &WMENB, bool &WMENA, bool &WMOPT2,
                            bool &WMOPT1) volatile
    {
        uint32_t curr = FLSHCR4;

        PAR_ADDR_ADJ_DIS = curr & (1u << 11u);
        PAR_WM = (curr >> 9u) & 0b11u;
        WMENB = curr & (1u << 3u);
        WMENA = curr & (1u << 2u);
        WMOPT2 = curr & (1u << 1u);
        WMOPT1 = curr & (1u << 0u);
    }

    /**
     * Set all of FLSHCR4's bit fields.
     *
     * (read-write) Flash Control Register 4
     */
    inline void set_FLSHCR4(bool PAR_ADDR_ADJ_DIS, uint8_t PAR_WM, bool WMENB,
                            bool WMENA, bool WMOPT2, bool WMOPT1) volatile
    {
        uint32_t curr = FLSHCR4;

        curr &= ~(0b1u << 11u);
        curr |= (PAR_ADDR_ADJ_DIS & 0b1u) << 11u;
        curr &= ~(0b11u << 9u);
        curr |= (PAR_WM & 0b11u) << 9u;
        curr &= ~(0b1u << 3u);
        curr |= (WMENB & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (WMENA & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (WMOPT2 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (WMOPT1 & 0b1u) << 0u;

        FLSHCR4 = curr;
    }

    /**
     * Get IPCR0's SFAR field.
     *
     * Serial Flash Address for IP command.
     */
    inline uint32_t get_IPCR0_SFAR() volatile
    {
        return (IPCR0 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IPCR0's SFAR field.
     *
     * Serial Flash Address for IP command.
     */
    inline void set_IPCR0_SFAR(uint32_t value) volatile
    {
        uint32_t curr = IPCR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IPCR0 = curr;
    }

    /**
     * Get IPCR1's IPAREN bit.
     *
     * Parallel mode Enabled for IP command.
     */
    inline bool get_IPCR1_IPAREN() volatile
    {
        return IPCR1 & (1u << 31u);
    }

    /**
     * Set IPCR1's IPAREN bit.
     *
     * Parallel mode Enabled for IP command.
     */
    inline void set_IPCR1_IPAREN() volatile
    {
        IPCR1 |= 1u << 31u;
    }

    /**
     * Clear IPCR1's IPAREN bit.
     *
     * Parallel mode Enabled for IP command.
     */
    inline void clear_IPCR1_IPAREN() volatile
    {
        IPCR1 &= ~(1u << 31u);
    }

    /**
     * Toggle IPCR1's IPAREN bit.
     *
     * Parallel mode Enabled for IP command.
     */
    inline void toggle_IPCR1_IPAREN() volatile
    {
        IPCR1 ^= 1u << 31u;
    }

    /**
     * Get IPCR1's ISEQNUM field.
     *
     * Sequence Number for IP command: ISEQNUM+1.
     */
    inline uint8_t get_IPCR1_ISEQNUM() volatile
    {
        return (IPCR1 >> 24u) & 0b111u;
    }

    /**
     * Set IPCR1's ISEQNUM field.
     *
     * Sequence Number for IP command: ISEQNUM+1.
     */
    inline void set_IPCR1_ISEQNUM(uint8_t value) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        IPCR1 = curr;
    }

    /**
     * Get IPCR1's ISEQID field.
     *
     * Sequence Index in LUT for IP command.
     */
    inline uint8_t get_IPCR1_ISEQID() volatile
    {
        return (IPCR1 >> 16u) & 0b1111u;
    }

    /**
     * Set IPCR1's ISEQID field.
     *
     * Sequence Index in LUT for IP command.
     */
    inline void set_IPCR1_ISEQID(uint8_t value) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        IPCR1 = curr;
    }

    /**
     * Get IPCR1's IDATSZ field.
     *
     * Flash Read/Program Data Size (in Bytes) for IP command.
     */
    inline uint16_t get_IPCR1_IDATSZ() volatile
    {
        return (IPCR1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IPCR1's IDATSZ field.
     *
     * Flash Read/Program Data Size (in Bytes) for IP command.
     */
    inline void set_IPCR1_IDATSZ(uint16_t value) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IPCR1 = curr;
    }

    /**
     * Get all of IPCR1's bit fields.
     *
     * (read-write) IP Control Register 1
     */
    inline void get_IPCR1(bool &IPAREN, uint8_t &ISEQNUM, uint8_t &ISEQID,
                          uint16_t &IDATSZ) volatile
    {
        uint32_t curr = IPCR1;

        IPAREN = curr & (1u << 31u);
        ISEQNUM = (curr >> 24u) & 0b111u;
        ISEQID = (curr >> 16u) & 0b1111u;
        IDATSZ = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of IPCR1's bit fields.
     *
     * (read-write) IP Control Register 1
     */
    inline void set_IPCR1(bool IPAREN, uint8_t ISEQNUM, uint8_t ISEQID,
                          uint16_t IDATSZ) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b1u << 31u);
        curr |= (IPAREN & 0b1u) << 31u;
        curr &= ~(0b111u << 24u);
        curr |= (ISEQNUM & 0b111u) << 24u;
        curr &= ~(0b1111u << 16u);
        curr |= (ISEQID & 0b1111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (IDATSZ & 0b1111111111111111u) << 0u;

        IPCR1 = curr;
    }

    /**
     * Get IPCMD's TRG bit.
     *
     * Setting this bit will trigger an IP Command.
     */
    inline bool get_IPCMD_TRG() volatile
    {
        return IPCMD & (1u << 0u);
    }

    /**
     * Set IPCMD's TRG bit.
     *
     * Setting this bit will trigger an IP Command.
     */
    inline void set_IPCMD_TRG() volatile
    {
        IPCMD |= 1u << 0u;
    }

    /**
     * Clear IPCMD's TRG bit.
     *
     * Setting this bit will trigger an IP Command.
     */
    inline void clear_IPCMD_TRG() volatile
    {
        IPCMD &= ~(1u << 0u);
    }

    /**
     * Toggle IPCMD's TRG bit.
     *
     * Setting this bit will trigger an IP Command.
     */
    inline void toggle_IPCMD_TRG() volatile
    {
        IPCMD ^= 1u << 0u;
    }

    /**
     * Get IPRXFCR's RXWMRK field.
     *
     * Watermark level is (RXWMRK+1)*64 Bits.
     */
    inline uint8_t get_IPRXFCR_RXWMRK() volatile
    {
        return (IPRXFCR >> 2u) & 0b11111u;
    }

    /**
     * Set IPRXFCR's RXWMRK field.
     *
     * Watermark level is (RXWMRK+1)*64 Bits.
     */
    inline void set_IPRXFCR_RXWMRK(uint8_t value) volatile
    {
        uint32_t curr = IPRXFCR;

        curr &= ~(0b11111u << 2u);
        curr |= (value & 0b11111u) << 2u;

        IPRXFCR = curr;
    }

    /**
     * Get IPRXFCR's RXDMAEN bit.
     *
     * IP RX FIFO reading by DMA enabled.
     */
    inline bool get_IPRXFCR_RXDMAEN() volatile
    {
        return IPRXFCR & (1u << 1u);
    }

    /**
     * Set IPRXFCR's RXDMAEN bit.
     *
     * IP RX FIFO reading by DMA enabled.
     */
    inline void set_IPRXFCR_RXDMAEN() volatile
    {
        IPRXFCR |= 1u << 1u;
    }

    /**
     * Clear IPRXFCR's RXDMAEN bit.
     *
     * IP RX FIFO reading by DMA enabled.
     */
    inline void clear_IPRXFCR_RXDMAEN() volatile
    {
        IPRXFCR &= ~(1u << 1u);
    }

    /**
     * Toggle IPRXFCR's RXDMAEN bit.
     *
     * IP RX FIFO reading by DMA enabled.
     */
    inline void toggle_IPRXFCR_RXDMAEN() volatile
    {
        IPRXFCR ^= 1u << 1u;
    }

    /**
     * Get IPRXFCR's CLRIPRXF bit.
     *
     * Clear all valid data entries in IP RX FIFO.
     */
    inline bool get_IPRXFCR_CLRIPRXF() volatile
    {
        return IPRXFCR & (1u << 0u);
    }

    /**
     * Set IPRXFCR's CLRIPRXF bit.
     *
     * Clear all valid data entries in IP RX FIFO.
     */
    inline void set_IPRXFCR_CLRIPRXF() volatile
    {
        IPRXFCR |= 1u << 0u;
    }

    /**
     * Clear IPRXFCR's CLRIPRXF bit.
     *
     * Clear all valid data entries in IP RX FIFO.
     */
    inline void clear_IPRXFCR_CLRIPRXF() volatile
    {
        IPRXFCR &= ~(1u << 0u);
    }

    /**
     * Toggle IPRXFCR's CLRIPRXF bit.
     *
     * Clear all valid data entries in IP RX FIFO.
     */
    inline void toggle_IPRXFCR_CLRIPRXF() volatile
    {
        IPRXFCR ^= 1u << 0u;
    }

    /**
     * Get all of IPRXFCR's bit fields.
     *
     * (read-write) IP RX FIFO Control Register
     */
    inline void get_IPRXFCR(uint8_t &RXWMRK, bool &RXDMAEN,
                            bool &CLRIPRXF) volatile
    {
        uint32_t curr = IPRXFCR;

        RXWMRK = (curr >> 2u) & 0b11111u;
        RXDMAEN = curr & (1u << 1u);
        CLRIPRXF = curr & (1u << 0u);
    }

    /**
     * Set all of IPRXFCR's bit fields.
     *
     * (read-write) IP RX FIFO Control Register
     */
    inline void set_IPRXFCR(uint8_t RXWMRK, bool RXDMAEN,
                            bool CLRIPRXF) volatile
    {
        uint32_t curr = IPRXFCR;

        curr &= ~(0b11111u << 2u);
        curr |= (RXWMRK & 0b11111u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RXDMAEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CLRIPRXF & 0b1u) << 0u;

        IPRXFCR = curr;
    }

    /**
     * Get IPTXFCR's TXWMRK field.
     *
     * Watermark level is (TXWMRK+1)*64 Bits.
     */
    inline uint8_t get_IPTXFCR_TXWMRK() volatile
    {
        return (IPTXFCR >> 2u) & 0b11111u;
    }

    /**
     * Set IPTXFCR's TXWMRK field.
     *
     * Watermark level is (TXWMRK+1)*64 Bits.
     */
    inline void set_IPTXFCR_TXWMRK(uint8_t value) volatile
    {
        uint32_t curr = IPTXFCR;

        curr &= ~(0b11111u << 2u);
        curr |= (value & 0b11111u) << 2u;

        IPTXFCR = curr;
    }

    /**
     * Get IPTXFCR's TXDMAEN bit.
     *
     * IP TX FIFO filling by DMA enabled.
     */
    inline bool get_IPTXFCR_TXDMAEN() volatile
    {
        return IPTXFCR & (1u << 1u);
    }

    /**
     * Set IPTXFCR's TXDMAEN bit.
     *
     * IP TX FIFO filling by DMA enabled.
     */
    inline void set_IPTXFCR_TXDMAEN() volatile
    {
        IPTXFCR |= 1u << 1u;
    }

    /**
     * Clear IPTXFCR's TXDMAEN bit.
     *
     * IP TX FIFO filling by DMA enabled.
     */
    inline void clear_IPTXFCR_TXDMAEN() volatile
    {
        IPTXFCR &= ~(1u << 1u);
    }

    /**
     * Toggle IPTXFCR's TXDMAEN bit.
     *
     * IP TX FIFO filling by DMA enabled.
     */
    inline void toggle_IPTXFCR_TXDMAEN() volatile
    {
        IPTXFCR ^= 1u << 1u;
    }

    /**
     * Get IPTXFCR's CLRIPTXF bit.
     *
     * Clear all valid data entries in IP TX FIFO.
     */
    inline bool get_IPTXFCR_CLRIPTXF() volatile
    {
        return IPTXFCR & (1u << 0u);
    }

    /**
     * Set IPTXFCR's CLRIPTXF bit.
     *
     * Clear all valid data entries in IP TX FIFO.
     */
    inline void set_IPTXFCR_CLRIPTXF() volatile
    {
        IPTXFCR |= 1u << 0u;
    }

    /**
     * Clear IPTXFCR's CLRIPTXF bit.
     *
     * Clear all valid data entries in IP TX FIFO.
     */
    inline void clear_IPTXFCR_CLRIPTXF() volatile
    {
        IPTXFCR &= ~(1u << 0u);
    }

    /**
     * Toggle IPTXFCR's CLRIPTXF bit.
     *
     * Clear all valid data entries in IP TX FIFO.
     */
    inline void toggle_IPTXFCR_CLRIPTXF() volatile
    {
        IPTXFCR ^= 1u << 0u;
    }

    /**
     * Get all of IPTXFCR's bit fields.
     *
     * (read-write) IP TX FIFO Control Register
     */
    inline void get_IPTXFCR(uint8_t &TXWMRK, bool &TXDMAEN,
                            bool &CLRIPTXF) volatile
    {
        uint32_t curr = IPTXFCR;

        TXWMRK = (curr >> 2u) & 0b11111u;
        TXDMAEN = curr & (1u << 1u);
        CLRIPTXF = curr & (1u << 0u);
    }

    /**
     * Set all of IPTXFCR's bit fields.
     *
     * (read-write) IP TX FIFO Control Register
     */
    inline void set_IPTXFCR(uint8_t TXWMRK, bool TXDMAEN,
                            bool CLRIPTXF) volatile
    {
        uint32_t curr = IPTXFCR;

        curr &= ~(0b11111u << 2u);
        curr |= (TXWMRK & 0b11111u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXDMAEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CLRIPTXF & 0b1u) << 0u;

        IPTXFCR = curr;
    }

    /**
     * Get DLLCR's OVRDVAL field.
     *
     * Slave clock delay line delay cell number selection override value.
     */
    inline uint8_t get_DLLCR_OVRDVAL(std::size_t index) volatile
    {
        return (DLLCR[index] >> 9u) & 0b111111u;
    }

    /**
     * Set DLLCR's OVRDVAL field.
     *
     * Slave clock delay line delay cell number selection override value.
     */
    inline void set_DLLCR_OVRDVAL(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = DLLCR[index];

        curr &= ~(0b111111u << 9u);
        curr |= (value & 0b111111u) << 9u;

        DLLCR[index] = curr;
    }

    /**
     * Get DLLCR's OVRDEN bit.
     *
     * Slave clock delay line delay cell number selection override enable.
     */
    inline bool get_DLLCR_OVRDEN(std::size_t index) volatile
    {
        return DLLCR[index] & (1u << 8u);
    }

    /**
     * Set DLLCR's OVRDEN bit.
     *
     * Slave clock delay line delay cell number selection override enable.
     */
    inline void set_DLLCR_OVRDEN() volatile
    {
        DLLCR |= 1u << 8u;
    }

    /**
     * Clear DLLCR's OVRDEN bit.
     *
     * Slave clock delay line delay cell number selection override enable.
     */
    inline void clear_DLLCR_OVRDEN() volatile
    {
        DLLCR &= ~(1u << 8u);
    }

    /**
     * Toggle DLLCR's OVRDEN bit.
     *
     * Slave clock delay line delay cell number selection override enable.
     */
    inline void toggle_DLLCR_OVRDEN() volatile
    {
        DLLCR ^= 1u << 8u;
    }

    /**
     * Get DLLCR's SLVDLYTARGET field.
     *
     * The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 *
     * clock cycle of reference clock (serial root clock). If serial root clock
     * is >= 100 MHz, DLLEN set to 0x1, OVRDEN set to =0x0, then SLVDLYTARGET
     * setting of 0xF is recommended.
     */
    inline uint8_t get_DLLCR_SLVDLYTARGET(std::size_t index) volatile
    {
        return (DLLCR[index] >> 3u) & 0b1111u;
    }

    /**
     * Set DLLCR's SLVDLYTARGET field.
     *
     * The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 *
     * clock cycle of reference clock (serial root clock). If serial root clock
     * is >= 100 MHz, DLLEN set to 0x1, OVRDEN set to =0x0, then SLVDLYTARGET
     * setting of 0xF is recommended.
     */
    inline void set_DLLCR_SLVDLYTARGET(std::size_t index,
                                       uint8_t value) volatile
    {
        uint32_t curr = DLLCR[index];

        curr &= ~(0b1111u << 3u);
        curr |= (value & 0b1111u) << 3u;

        DLLCR[index] = curr;
    }

    /**
     * Get DLLCR's DLLRESET bit.
     *
     * Software could force a reset on DLL by setting this field to 0x1. This
     * will cause the DLL to lose lock and re-calibrate to detect an ref_clock
     * half period phase shift. The reset action is edge triggered, so software
     * need to clear this bit after set this bit (no delay limitation).
     */
    inline bool get_DLLCR_DLLRESET(std::size_t index) volatile
    {
        return DLLCR[index] & (1u << 1u);
    }

    /**
     * Set DLLCR's DLLRESET bit.
     *
     * Software could force a reset on DLL by setting this field to 0x1. This
     * will cause the DLL to lose lock and re-calibrate to detect an ref_clock
     * half period phase shift. The reset action is edge triggered, so software
     * need to clear this bit after set this bit (no delay limitation).
     */
    inline void set_DLLCR_DLLRESET() volatile
    {
        DLLCR |= 1u << 1u;
    }

    /**
     * Clear DLLCR's DLLRESET bit.
     *
     * Software could force a reset on DLL by setting this field to 0x1. This
     * will cause the DLL to lose lock and re-calibrate to detect an ref_clock
     * half period phase shift. The reset action is edge triggered, so software
     * need to clear this bit after set this bit (no delay limitation).
     */
    inline void clear_DLLCR_DLLRESET() volatile
    {
        DLLCR &= ~(1u << 1u);
    }

    /**
     * Toggle DLLCR's DLLRESET bit.
     *
     * Software could force a reset on DLL by setting this field to 0x1. This
     * will cause the DLL to lose lock and re-calibrate to detect an ref_clock
     * half period phase shift. The reset action is edge triggered, so software
     * need to clear this bit after set this bit (no delay limitation).
     */
    inline void toggle_DLLCR_DLLRESET() volatile
    {
        DLLCR ^= 1u << 1u;
    }

    /**
     * Get DLLCR's DLLEN bit.
     *
     * DLL calibration enable.
     */
    inline bool get_DLLCR_DLLEN(std::size_t index) volatile
    {
        return DLLCR[index] & (1u << 0u);
    }

    /**
     * Set DLLCR's DLLEN bit.
     *
     * DLL calibration enable.
     */
    inline void set_DLLCR_DLLEN() volatile
    {
        DLLCR |= 1u << 0u;
    }

    /**
     * Clear DLLCR's DLLEN bit.
     *
     * DLL calibration enable.
     */
    inline void clear_DLLCR_DLLEN() volatile
    {
        DLLCR &= ~(1u << 0u);
    }

    /**
     * Toggle DLLCR's DLLEN bit.
     *
     * DLL calibration enable.
     */
    inline void toggle_DLLCR_DLLEN() volatile
    {
        DLLCR ^= 1u << 0u;
    }

    /**
     * Get all of DLLCR's bit fields.
     *
     * (read-write) DLL Control Register 0
     */
    inline void get_DLLCR(std::size_t index, uint8_t &OVRDVAL, bool &OVRDEN,
                          uint8_t &SLVDLYTARGET, bool &DLLRESET,
                          bool &DLLEN) volatile
    {
        uint32_t curr = DLLCR[index];

        OVRDVAL = (curr >> 9u) & 0b111111u;
        OVRDEN = curr & (1u << 8u);
        SLVDLYTARGET = (curr >> 3u) & 0b1111u;
        DLLRESET = curr & (1u << 1u);
        DLLEN = curr & (1u << 0u);
    }

    /**
     * Set all of DLLCR's bit fields.
     *
     * (read-write) DLL Control Register 0
     */
    inline void set_DLLCR(std::size_t index, uint8_t OVRDVAL, bool OVRDEN,
                          uint8_t SLVDLYTARGET, bool DLLRESET,
                          bool DLLEN) volatile
    {
        uint32_t curr = DLLCR[index];

        curr &= ~(0b111111u << 9u);
        curr |= (OVRDVAL & 0b111111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (OVRDEN & 0b1u) << 8u;
        curr &= ~(0b1111u << 3u);
        curr |= (SLVDLYTARGET & 0b1111u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (DLLRESET & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DLLEN & 0b1u) << 0u;

        DLLCR[index] = curr;
    }

    /**
     * Get MISCCR4's AHBADDRESS field.
     *
     * AHB bus address that trigger the current ECC multi bits error interrupt.
     */
    inline uint32_t get_MISCCR4_AHBADDRESS() volatile
    {
        return (MISCCR4 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get MISCCR5's ECCSINGLEERRORCORR field.
     *
     * ECC single bit error correction indication.
     */
    inline uint32_t get_MISCCR5_ECCSINGLEERRORCORR() volatile
    {
        return (MISCCR5 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get MISCCR6's ADDRESS field.
     *
     * ECC single error address
     */
    inline uint32_t get_MISCCR6_ADDRESS() volatile
    {
        return (MISCCR6 >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Get MISCCR6's HIT bit.
     *
     * ECC single error information Hit
     */
    inline bool get_MISCCR6_HIT() volatile
    {
        return MISCCR6 & (1u << 1u);
    }

    /**
     * Get MISCCR6's VALID bit.
     *
     * ECC single error information Valid
     */
    inline bool get_MISCCR6_VALID() volatile
    {
        return MISCCR6 & (1u << 0u);
    }

    /**
     * Get all of MISCCR6's bit fields.
     *
     * (read-write) Misc Control Register 6
     */
    inline void get_MISCCR6(uint32_t &ADDRESS, bool &HIT, bool &VALID) volatile
    {
        uint32_t curr = MISCCR6;

        ADDRESS = (curr >> 2u) & 0b111111111111111111111111111111u;
        HIT = curr & (1u << 1u);
        VALID = curr & (1u << 0u);
    }

    /**
     * Get MISCCR7's ADDRESS field.
     *
     * ECC multi error address
     */
    inline uint32_t get_MISCCR7_ADDRESS() volatile
    {
        return (MISCCR7 >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Get MISCCR7's HIT bit.
     *
     * ECC multi error information Hit
     */
    inline bool get_MISCCR7_HIT() volatile
    {
        return MISCCR7 & (1u << 1u);
    }

    /**
     * Get MISCCR7's VALID bit.
     *
     * ECC multi error information Valid
     */
    inline bool get_MISCCR7_VALID() volatile
    {
        return MISCCR7 & (1u << 0u);
    }

    /**
     * Get all of MISCCR7's bit fields.
     *
     * (read-write) Misc Control Register 7
     */
    inline void get_MISCCR7(uint32_t &ADDRESS, bool &HIT, bool &VALID) volatile
    {
        uint32_t curr = MISCCR7;

        ADDRESS = (curr >> 2u) & 0b111111111111111111111111111111u;
        HIT = curr & (1u << 1u);
        VALID = curr & (1u << 0u);
    }

    /**
     * Get STS0's ARBCMDSRC field.
     *
     * This status field indicates the trigger source of current command
     * sequence granted by arbitrator. This field value is meaningless when
     * ARB_CTL is not busy (STS0[ARBIDLE]=0x1).
     */
    inline FLEXSPI1_STS0_ARBCMDSRC get_STS0_ARBCMDSRC() volatile
    {
        return FLEXSPI1_STS0_ARBCMDSRC((STS0 >> 2u) & 0b11u);
    }

    /**
     * Get STS0's ARBIDLE bit.
     *
     * This status bit indicates the state machine in ARB_CTL is busy and there
     * is command sequence granted by arbitrator and not finished yet on
     * FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will
     * be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit
     * should be polled to wait for FlexSPI controller become idle instead of
     * SEQIDLE.
     */
    inline bool get_STS0_ARBIDLE() volatile
    {
        return STS0 & (1u << 1u);
    }

    /**
     * Get STS0's SEQIDLE bit.
     *
     * This status bit indicates the state machine in SEQ_CTL is idle and there
     * is command sequence executing on FlexSPI interface.
     */
    inline bool get_STS0_SEQIDLE() volatile
    {
        return STS0 & (1u << 0u);
    }

    /**
     * Get all of STS0's bit fields.
     *
     * (read-write) Status Register 0
     */
    inline void get_STS0(FLEXSPI1_STS0_ARBCMDSRC &ARBCMDSRC, bool &ARBIDLE,
                         bool &SEQIDLE) volatile
    {
        uint32_t curr = STS0;

        ARBCMDSRC = FLEXSPI1_STS0_ARBCMDSRC((curr >> 2u) & 0b11u);
        ARBIDLE = curr & (1u << 1u);
        SEQIDLE = curr & (1u << 0u);
    }

    /**
     * Get STS1's IPCMDERRCODE field.
     *
     * Indicates the Error Code when IP command Error detected. This field will
     * be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
     */
    inline FLEXSPI1_STS1_IPCMDERRCODE get_STS1_IPCMDERRCODE() volatile
    {
        return FLEXSPI1_STS1_IPCMDERRCODE((STS1 >> 24u) & 0b1111u);
    }

    /**
     * Get STS1's IPCMDERRID field.
     *
     * Indicates the sequence Index when IP command error detected. This field
     * will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).
     */
    inline uint8_t get_STS1_IPCMDERRID() volatile
    {
        return (STS1 >> 16u) & 0b1111u;
    }

    /**
     * Get STS1's AHBCMDERRCODE field.
     *
     * Indicates the Error Code when AHB command Error detected. This field
     * will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
     */
    inline FLEXSPI1_STS1_AHBCMDERRCODE get_STS1_AHBCMDERRCODE() volatile
    {
        return FLEXSPI1_STS1_AHBCMDERRCODE((STS1 >> 8u) & 0b1111u);
    }

    /**
     * Get STS1's AHBCMDERRID field.
     *
     * Indicates the sequence index when an AHB command error is detected. This
     * field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
     */
    inline uint8_t get_STS1_AHBCMDERRID() volatile
    {
        return (STS1 >> 0u) & 0b1111u;
    }

    /**
     * Get all of STS1's bit fields.
     *
     * (read-write) Status Register 1
     */
    inline void get_STS1(FLEXSPI1_STS1_IPCMDERRCODE &IPCMDERRCODE,
                         uint8_t &IPCMDERRID,
                         FLEXSPI1_STS1_AHBCMDERRCODE &AHBCMDERRCODE,
                         uint8_t &AHBCMDERRID) volatile
    {
        uint32_t curr = STS1;

        IPCMDERRCODE = FLEXSPI1_STS1_IPCMDERRCODE((curr >> 24u) & 0b1111u);
        IPCMDERRID = (curr >> 16u) & 0b1111u;
        AHBCMDERRCODE = FLEXSPI1_STS1_AHBCMDERRCODE((curr >> 8u) & 0b1111u);
        AHBCMDERRID = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get STS2's BREFSEL field.
     *
     * Flash B sample clock reference delay line delay cell number selection.
     */
    inline uint8_t get_STS2_BREFSEL() volatile
    {
        return (STS2 >> 24u) & 0b111111u;
    }

    /**
     * Get STS2's BSLVSEL field.
     *
     * Flash B sample clock slave delay line delay cell number selection.
     */
    inline uint8_t get_STS2_BSLVSEL() volatile
    {
        return (STS2 >> 18u) & 0b111111u;
    }

    /**
     * Get STS2's BREFLOCK bit.
     *
     * Flash B sample clock reference delay line locked.
     */
    inline bool get_STS2_BREFLOCK() volatile
    {
        return STS2 & (1u << 17u);
    }

    /**
     * Get STS2's BSLVLOCK bit.
     *
     * Flash B sample clock slave delay line locked.
     */
    inline bool get_STS2_BSLVLOCK() volatile
    {
        return STS2 & (1u << 16u);
    }

    /**
     * Get STS2's AREFSEL field.
     *
     * Flash A sample clock reference delay line delay cell number selection.
     */
    inline uint8_t get_STS2_AREFSEL() volatile
    {
        return (STS2 >> 8u) & 0b111111u;
    }

    /**
     * Get STS2's ASLVSEL field.
     *
     * Flash A sample clock slave delay line delay cell number selection .
     */
    inline uint8_t get_STS2_ASLVSEL() volatile
    {
        return (STS2 >> 2u) & 0b111111u;
    }

    /**
     * Get STS2's AREFLOCK bit.
     *
     * Flash A sample clock reference delay line locked.
     */
    inline bool get_STS2_AREFLOCK() volatile
    {
        return STS2 & (1u << 1u);
    }

    /**
     * Get STS2's ASLVLOCK bit.
     *
     * Flash A sample clock slave delay line locked.
     */
    inline bool get_STS2_ASLVLOCK() volatile
    {
        return STS2 & (1u << 0u);
    }

    /**
     * Get all of STS2's bit fields.
     *
     * (read-write) Status Register 2
     */
    inline void get_STS2(uint8_t &BREFSEL, uint8_t &BSLVSEL, bool &BREFLOCK,
                         bool &BSLVLOCK, uint8_t &AREFSEL, uint8_t &ASLVSEL,
                         bool &AREFLOCK, bool &ASLVLOCK) volatile
    {
        uint32_t curr = STS2;

        BREFSEL = (curr >> 24u) & 0b111111u;
        BSLVSEL = (curr >> 18u) & 0b111111u;
        BREFLOCK = curr & (1u << 17u);
        BSLVLOCK = curr & (1u << 16u);
        AREFSEL = (curr >> 8u) & 0b111111u;
        ASLVSEL = (curr >> 2u) & 0b111111u;
        AREFLOCK = curr & (1u << 1u);
        ASLVLOCK = curr & (1u << 0u);
    }

    /**
     * Get AHBSPNDSTS's DATLFT field.
     *
     * Left Data size for suspended command sequence (in byte).
     */
    inline uint16_t get_AHBSPNDSTS_DATLFT() volatile
    {
        return (AHBSPNDSTS >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get AHBSPNDSTS's BUFID field.
     *
     * AHB RX BUF ID for suspended command sequence.
     */
    inline uint8_t get_AHBSPNDSTS_BUFID() volatile
    {
        return (AHBSPNDSTS >> 1u) & 0b111u;
    }

    /**
     * Get AHBSPNDSTS's ACTIVE bit.
     *
     * Indicates if an AHB read prefetch command sequence has been suspended.
     */
    inline bool get_AHBSPNDSTS_ACTIVE() volatile
    {
        return AHBSPNDSTS & (1u << 0u);
    }

    /**
     * Get all of AHBSPNDSTS's bit fields.
     *
     * (read-write) AHB Suspend Status Register
     */
    inline void get_AHBSPNDSTS(uint16_t &DATLFT, uint8_t &BUFID,
                               bool &ACTIVE) volatile
    {
        uint32_t curr = AHBSPNDSTS;

        DATLFT = (curr >> 16u) & 0b1111111111111111u;
        BUFID = (curr >> 1u) & 0b111u;
        ACTIVE = curr & (1u << 0u);
    }

    /**
     * Get IPRXFSTS's RDCNTR field.
     *
     * Total Read Data Counter: RDCNTR * 64 Bits.
     */
    inline uint16_t get_IPRXFSTS_RDCNTR() volatile
    {
        return (IPRXFSTS >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get IPRXFSTS's FILL field.
     *
     * Fill level of IP RX FIFO.
     */
    inline uint8_t get_IPRXFSTS_FILL() volatile
    {
        return (IPRXFSTS >> 0u) & 0b11111111u;
    }

    /**
     * Get all of IPRXFSTS's bit fields.
     *
     * (read-write) IP RX FIFO Status Register
     */
    inline void get_IPRXFSTS(uint16_t &RDCNTR, uint8_t &FILL) volatile
    {
        uint32_t curr = IPRXFSTS;

        RDCNTR = (curr >> 16u) & 0b1111111111111111u;
        FILL = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get IPTXFSTS's WRCNTR field.
     *
     * Total Write Data Counter: WRCNTR * 64 Bits.
     */
    inline uint16_t get_IPTXFSTS_WRCNTR() volatile
    {
        return (IPTXFSTS >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get IPTXFSTS's FILL field.
     *
     * Fill level of IP TX FIFO.
     */
    inline uint8_t get_IPTXFSTS_FILL() volatile
    {
        return (IPTXFSTS >> 0u) & 0b11111111u;
    }

    /**
     * Get all of IPTXFSTS's bit fields.
     *
     * (read-write) IP TX FIFO Status Register
     */
    inline void get_IPTXFSTS(uint16_t &WRCNTR, uint8_t &FILL) volatile
    {
        uint32_t curr = IPTXFSTS;

        WRCNTR = (curr >> 16u) & 0b1111111111111111u;
        FILL = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get RFDR's RXDATA field.
     *
     * RX Data
     */
    inline uint32_t get_RFDR_RXDATA(std::size_t index) volatile
    {
        return (RFDR[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set TFDR's TXDATA field.
     *
     * TX Data
     */
    inline void set_TFDR_TXDATA(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = TFDR[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        TFDR[index] = curr;
    }

    /**
     * Get LUT's OPCODE1 field.
     *
     * OPCODE1
     */
    inline uint8_t get_LUT_OPCODE1(std::size_t index) volatile
    {
        return (LUT[index] >> 26u) & 0b111111u;
    }

    /**
     * Set LUT's OPCODE1 field.
     *
     * OPCODE1
     */
    inline void set_LUT_OPCODE1(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b111111u << 26u);
        curr |= (value & 0b111111u) << 26u;

        LUT[index] = curr;
    }

    /**
     * Get LUT's NUM_PADS1 field.
     *
     * NUM_PADS1
     */
    inline uint8_t get_LUT_NUM_PADS1(std::size_t index) volatile
    {
        return (LUT[index] >> 24u) & 0b11u;
    }

    /**
     * Set LUT's NUM_PADS1 field.
     *
     * NUM_PADS1
     */
    inline void set_LUT_NUM_PADS1(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b11u << 24u);
        curr |= (value & 0b11u) << 24u;

        LUT[index] = curr;
    }

    /**
     * Get LUT's OPERAND1 field.
     *
     * OPERAND1
     */
    inline uint8_t get_LUT_OPERAND1(std::size_t index) volatile
    {
        return (LUT[index] >> 16u) & 0b11111111u;
    }

    /**
     * Set LUT's OPERAND1 field.
     *
     * OPERAND1
     */
    inline void set_LUT_OPERAND1(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        LUT[index] = curr;
    }

    /**
     * Get LUT's OPCODE0 field.
     *
     * OPCODE
     */
    inline uint8_t get_LUT_OPCODE0(std::size_t index) volatile
    {
        return (LUT[index] >> 10u) & 0b111111u;
    }

    /**
     * Set LUT's OPCODE0 field.
     *
     * OPCODE
     */
    inline void set_LUT_OPCODE0(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b111111u << 10u);
        curr |= (value & 0b111111u) << 10u;

        LUT[index] = curr;
    }

    /**
     * Get LUT's NUM_PADS0 field.
     *
     * NUM_PADS0
     */
    inline uint8_t get_LUT_NUM_PADS0(std::size_t index) volatile
    {
        return (LUT[index] >> 8u) & 0b11u;
    }

    /**
     * Set LUT's NUM_PADS0 field.
     *
     * NUM_PADS0
     */
    inline void set_LUT_NUM_PADS0(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        LUT[index] = curr;
    }

    /**
     * Get LUT's OPERAND0 field.
     *
     * OPERAND0
     */
    inline uint8_t get_LUT_OPERAND0(std::size_t index) volatile
    {
        return (LUT[index] >> 0u) & 0b11111111u;
    }

    /**
     * Set LUT's OPERAND0 field.
     *
     * OPERAND0
     */
    inline void set_LUT_OPERAND0(std::size_t index, uint8_t value) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LUT[index] = curr;
    }

    /**
     * Get all of LUT's bit fields.
     *
     * (read-write) LUT x
     */
    inline void get_LUT(std::size_t index, uint8_t &OPCODE1,
                        uint8_t &NUM_PADS1, uint8_t &OPERAND1,
                        uint8_t &OPCODE0, uint8_t &NUM_PADS0,
                        uint8_t &OPERAND0) volatile
    {
        uint32_t curr = LUT[index];

        OPCODE1 = (curr >> 26u) & 0b111111u;
        NUM_PADS1 = (curr >> 24u) & 0b11u;
        OPERAND1 = (curr >> 16u) & 0b11111111u;
        OPCODE0 = (curr >> 10u) & 0b111111u;
        NUM_PADS0 = (curr >> 8u) & 0b11u;
        OPERAND0 = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of LUT's bit fields.
     *
     * (read-write) LUT x
     */
    inline void set_LUT(std::size_t index, uint8_t OPCODE1, uint8_t NUM_PADS1,
                        uint8_t OPERAND1, uint8_t OPCODE0, uint8_t NUM_PADS0,
                        uint8_t OPERAND0) volatile
    {
        uint32_t curr = LUT[index];

        curr &= ~(0b111111u << 26u);
        curr |= (OPCODE1 & 0b111111u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (NUM_PADS1 & 0b11u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (OPERAND1 & 0b11111111u) << 16u;
        curr &= ~(0b111111u << 10u);
        curr |= (OPCODE0 & 0b111111u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (NUM_PADS0 & 0b11u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (OPERAND0 & 0b11111111u) << 0u;

        LUT[index] = curr;
    }

    /**
     * Get HMSTR0CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR0CR_MSTRID() volatile
    {
        return (HMSTR0CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR0CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR0CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR0CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR0CR = curr;
    }

    /**
     * Get HMSTR0CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR0CR_MASK get_HMSTR0CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR0CR_MASK((HMSTR0CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR0CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR0CR_MASK(FLEXSPI1_HMSTR0CR_MASK value) volatile
    {
        uint32_t curr = HMSTR0CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR0CR = curr;
    }

    /**
     * Get all of HMSTR0CR's bit fields.
     *
     * (read-write) AHB Master ID 0 Control Register
     */
    inline void get_HMSTR0CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR0CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR0CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR0CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR0CR's bit fields.
     *
     * (read-write) AHB Master ID 0 Control Register
     */
    inline void set_HMSTR0CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR0CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR0CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR0CR = curr;
    }

    /**
     * Get HMSTR1CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR1CR_MSTRID() volatile
    {
        return (HMSTR1CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR1CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR1CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR1CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR1CR = curr;
    }

    /**
     * Get HMSTR1CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR1CR_MASK get_HMSTR1CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR1CR_MASK((HMSTR1CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR1CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR1CR_MASK(FLEXSPI1_HMSTR1CR_MASK value) volatile
    {
        uint32_t curr = HMSTR1CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR1CR = curr;
    }

    /**
     * Get all of HMSTR1CR's bit fields.
     *
     * (read-write) AHB Master ID 1 Control Register
     */
    inline void get_HMSTR1CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR1CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR1CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR1CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR1CR's bit fields.
     *
     * (read-write) AHB Master ID 1 Control Register
     */
    inline void set_HMSTR1CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR1CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR1CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR1CR = curr;
    }

    /**
     * Get HMSTR2CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR2CR_MSTRID() volatile
    {
        return (HMSTR2CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR2CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR2CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR2CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR2CR = curr;
    }

    /**
     * Get HMSTR2CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR2CR_MASK get_HMSTR2CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR2CR_MASK((HMSTR2CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR2CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR2CR_MASK(FLEXSPI1_HMSTR2CR_MASK value) volatile
    {
        uint32_t curr = HMSTR2CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR2CR = curr;
    }

    /**
     * Get all of HMSTR2CR's bit fields.
     *
     * (read-write) AHB Master ID 2 Control Register
     */
    inline void get_HMSTR2CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR2CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR2CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR2CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR2CR's bit fields.
     *
     * (read-write) AHB Master ID 2 Control Register
     */
    inline void set_HMSTR2CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR2CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR2CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR2CR = curr;
    }

    /**
     * Get HMSTR3CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR3CR_MSTRID() volatile
    {
        return (HMSTR3CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR3CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR3CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR3CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR3CR = curr;
    }

    /**
     * Get HMSTR3CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR3CR_MASK get_HMSTR3CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR3CR_MASK((HMSTR3CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR3CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR3CR_MASK(FLEXSPI1_HMSTR3CR_MASK value) volatile
    {
        uint32_t curr = HMSTR3CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR3CR = curr;
    }

    /**
     * Get all of HMSTR3CR's bit fields.
     *
     * (read-write) AHB Master ID 3 Control Register
     */
    inline void get_HMSTR3CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR3CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR3CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR3CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR3CR's bit fields.
     *
     * (read-write) AHB Master ID 3 Control Register
     */
    inline void set_HMSTR3CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR3CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR3CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR3CR = curr;
    }

    /**
     * Get HMSTR4CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR4CR_MSTRID() volatile
    {
        return (HMSTR4CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR4CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR4CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR4CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR4CR = curr;
    }

    /**
     * Get HMSTR4CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR4CR_MASK get_HMSTR4CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR4CR_MASK((HMSTR4CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR4CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR4CR_MASK(FLEXSPI1_HMSTR4CR_MASK value) volatile
    {
        uint32_t curr = HMSTR4CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR4CR = curr;
    }

    /**
     * Get all of HMSTR4CR's bit fields.
     *
     * (read-write) AHB Master ID 4 Control Register
     */
    inline void get_HMSTR4CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR4CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR4CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR4CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR4CR's bit fields.
     *
     * (read-write) AHB Master ID 4 Control Register
     */
    inline void set_HMSTR4CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR4CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR4CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR4CR = curr;
    }

    /**
     * Get HMSTR5CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR5CR_MSTRID() volatile
    {
        return (HMSTR5CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR5CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR5CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR5CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR5CR = curr;
    }

    /**
     * Get HMSTR5CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR5CR_MASK get_HMSTR5CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR5CR_MASK((HMSTR5CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR5CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR5CR_MASK(FLEXSPI1_HMSTR5CR_MASK value) volatile
    {
        uint32_t curr = HMSTR5CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR5CR = curr;
    }

    /**
     * Get all of HMSTR5CR's bit fields.
     *
     * (read-write) AHB Master ID 5 Control Register
     */
    inline void get_HMSTR5CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR5CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR5CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR5CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR5CR's bit fields.
     *
     * (read-write) AHB Master ID 5 Control Register
     */
    inline void set_HMSTR5CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR5CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR5CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR5CR = curr;
    }

    /**
     * Get HMSTR6CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR6CR_MSTRID() volatile
    {
        return (HMSTR6CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR6CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR6CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR6CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR6CR = curr;
    }

    /**
     * Get HMSTR6CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR6CR_MASK get_HMSTR6CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR6CR_MASK((HMSTR6CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR6CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR6CR_MASK(FLEXSPI1_HMSTR6CR_MASK value) volatile
    {
        uint32_t curr = HMSTR6CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR6CR = curr;
    }

    /**
     * Get all of HMSTR6CR's bit fields.
     *
     * (read-write) AHB Master ID 6 Control Register
     */
    inline void get_HMSTR6CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR6CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR6CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR6CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR6CR's bit fields.
     *
     * (read-write) AHB Master ID 6 Control Register
     */
    inline void set_HMSTR6CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR6CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR6CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR6CR = curr;
    }

    /**
     * Get HMSTR7CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline uint16_t get_HMSTR7CR_MSTRID() volatile
    {
        return (HMSTR7CR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set HMSTR7CR's MSTRID field.
     *
     * This is expected Master ID.
     */
    inline void set_HMSTR7CR_MSTRID(uint16_t value) volatile
    {
        uint32_t curr = HMSTR7CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        HMSTR7CR = curr;
    }

    /**
     * Get HMSTR7CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline FLEXSPI1_HMSTR7CR_MASK get_HMSTR7CR_MASK() volatile
    {
        return FLEXSPI1_HMSTR7CR_MASK((HMSTR7CR >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set HMSTR7CR's MASK field.
     *
     * Mask bits for AHB master ID.
     */
    inline void set_HMSTR7CR_MASK(FLEXSPI1_HMSTR7CR_MASK value) volatile
    {
        uint32_t curr = HMSTR7CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        HMSTR7CR = curr;
    }

    /**
     * Get all of HMSTR7CR's bit fields.
     *
     * (read-write) AHB Master ID 7 Control Register
     */
    inline void get_HMSTR7CR(uint16_t &MSTRID,
                             FLEXSPI1_HMSTR7CR_MASK &MASK) volatile
    {
        uint32_t curr = HMSTR7CR;

        MSTRID = (curr >> 16u) & 0b1111111111111111u;
        MASK = FLEXSPI1_HMSTR7CR_MASK((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of HMSTR7CR's bit fields.
     *
     * (read-write) AHB Master ID 7 Control Register
     */
    inline void set_HMSTR7CR(uint16_t MSTRID,
                             FLEXSPI1_HMSTR7CR_MASK MASK) volatile
    {
        uint32_t curr = HMSTR7CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (MSTRID & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(MASK) & 0b1111111111111111u) << 0u;

        HMSTR7CR = curr;
    }

    /**
     * Get HADDRSTART's ADDRSTART field.
     *
     * HADDR remap range's start addr, 4K aligned When ADDRSTART setting is
     * same as ASFM_BASE, and OTFAD keyblob function is enabled, keyblob will
     * also be remapped
     */
    inline uint32_t get_HADDRSTART_ADDRSTART() volatile
    {
        return (HADDRSTART >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set HADDRSTART's ADDRSTART field.
     *
     * HADDR remap range's start addr, 4K aligned When ADDRSTART setting is
     * same as ASFM_BASE, and OTFAD keyblob function is enabled, keyblob will
     * also be remapped
     */
    inline void set_HADDRSTART_ADDRSTART(uint32_t value) volatile
    {
        uint32_t curr = HADDRSTART;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        HADDRSTART = curr;
    }

    /**
     * Get HADDRSTART's KBINECC bit.
     *
     * OTFAD Keyblob is in ECC region and need to be remapped
     */
    inline bool get_HADDRSTART_KBINECC() volatile
    {
        return HADDRSTART & (1u << 1u);
    }

    /**
     * Set HADDRSTART's KBINECC bit.
     *
     * OTFAD Keyblob is in ECC region and need to be remapped
     */
    inline void set_HADDRSTART_KBINECC() volatile
    {
        HADDRSTART |= 1u << 1u;
    }

    /**
     * Clear HADDRSTART's KBINECC bit.
     *
     * OTFAD Keyblob is in ECC region and need to be remapped
     */
    inline void clear_HADDRSTART_KBINECC() volatile
    {
        HADDRSTART &= ~(1u << 1u);
    }

    /**
     * Toggle HADDRSTART's KBINECC bit.
     *
     * OTFAD Keyblob is in ECC region and need to be remapped
     */
    inline void toggle_HADDRSTART_KBINECC() volatile
    {
        HADDRSTART ^= 1u << 1u;
    }

    /**
     * Get HADDRSTART's REMAPEN bit.
     *
     * AHB Bus address remap function enable
     */
    inline bool get_HADDRSTART_REMAPEN() volatile
    {
        return HADDRSTART & (1u << 0u);
    }

    /**
     * Set HADDRSTART's REMAPEN bit.
     *
     * AHB Bus address remap function enable
     */
    inline void set_HADDRSTART_REMAPEN() volatile
    {
        HADDRSTART |= 1u << 0u;
    }

    /**
     * Clear HADDRSTART's REMAPEN bit.
     *
     * AHB Bus address remap function enable
     */
    inline void clear_HADDRSTART_REMAPEN() volatile
    {
        HADDRSTART &= ~(1u << 0u);
    }

    /**
     * Toggle HADDRSTART's REMAPEN bit.
     *
     * AHB Bus address remap function enable
     */
    inline void toggle_HADDRSTART_REMAPEN() volatile
    {
        HADDRSTART ^= 1u << 0u;
    }

    /**
     * Get all of HADDRSTART's bit fields.
     *
     * (read-write) HADDR REMAP START ADDR
     */
    inline void get_HADDRSTART(uint32_t &ADDRSTART, bool &KBINECC,
                               bool &REMAPEN) volatile
    {
        uint32_t curr = HADDRSTART;

        ADDRSTART = (curr >> 12u) & 0b11111111111111111111u;
        KBINECC = curr & (1u << 1u);
        REMAPEN = curr & (1u << 0u);
    }

    /**
     * Set all of HADDRSTART's bit fields.
     *
     * (read-write) HADDR REMAP START ADDR
     */
    inline void set_HADDRSTART(uint32_t ADDRSTART, bool KBINECC,
                               bool REMAPEN) volatile
    {
        uint32_t curr = HADDRSTART;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (ADDRSTART & 0b11111111111111111111u) << 12u;
        curr &= ~(0b1u << 1u);
        curr |= (KBINECC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REMAPEN & 0b1u) << 0u;

        HADDRSTART = curr;
    }

    /**
     * Get HADDREND's ENDSTART field.
     *
     * HADDR remap range's end addr, 4K aligned
     */
    inline uint32_t get_HADDREND_ENDSTART() volatile
    {
        return (HADDREND >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set HADDREND's ENDSTART field.
     *
     * HADDR remap range's end addr, 4K aligned
     */
    inline void set_HADDREND_ENDSTART(uint32_t value) volatile
    {
        uint32_t curr = HADDREND;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        HADDREND = curr;
    }

    /**
     * Get HADDROFFSET's ADDROFFSET field.
     *
     * HADDR offset field, remapped address will be
     * ADDR[31:12]=ADDR_original[31:12]+ADDROFFSET
     */
    inline uint32_t get_HADDROFFSET_ADDROFFSET() volatile
    {
        return (HADDROFFSET >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set HADDROFFSET's ADDROFFSET field.
     *
     * HADDR offset field, remapped address will be
     * ADDR[31:12]=ADDR_original[31:12]+ADDROFFSET
     */
    inline void set_HADDROFFSET_ADDROFFSET(uint32_t value) volatile
    {
        uint32_t curr = HADDROFFSET;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        HADDROFFSET = curr;
    }

    /**
     * Get IPSNSZSTART0's start_address field.
     *
     * Start address of region 0. Minimal 4K Bytes aligned. It is flash
     * address.
     */
    inline uint32_t get_IPSNSZSTART0_start_address() volatile
    {
        return (IPSNSZSTART0 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set IPSNSZSTART0's start_address field.
     *
     * Start address of region 0. Minimal 4K Bytes aligned. It is flash
     * address.
     */
    inline void set_IPSNSZSTART0_start_address(uint32_t value) volatile
    {
        uint32_t curr = IPSNSZSTART0;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        IPSNSZSTART0 = curr;
    }

    /**
     * Get IPSNSZEND0's end_address field.
     *
     * End address of region 0. Minimal 4K Bytes aligned. It is flash address.
     */
    inline uint32_t get_IPSNSZEND0_end_address() volatile
    {
        return (IPSNSZEND0 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set IPSNSZEND0's end_address field.
     *
     * End address of region 0. Minimal 4K Bytes aligned. It is flash address.
     */
    inline void set_IPSNSZEND0_end_address(uint32_t value) volatile
    {
        uint32_t curr = IPSNSZEND0;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        IPSNSZEND0 = curr;
    }

    /**
     * Get IPSNSZSTART1's start_address field.
     *
     * Start address of region 1. Minimal 4K Bytes aligned. It is flash
     * address.
     */
    inline uint32_t get_IPSNSZSTART1_start_address() volatile
    {
        return (IPSNSZSTART1 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set IPSNSZSTART1's start_address field.
     *
     * Start address of region 1. Minimal 4K Bytes aligned. It is flash
     * address.
     */
    inline void set_IPSNSZSTART1_start_address(uint32_t value) volatile
    {
        uint32_t curr = IPSNSZSTART1;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        IPSNSZSTART1 = curr;
    }

    /**
     * Get IPSNSZEND1's end_address field.
     *
     * End address of region 1. Minimal 4K Bytes aligned. It is flash address.
     */
    inline uint32_t get_IPSNSZEND1_end_address() volatile
    {
        return (IPSNSZEND1 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set IPSNSZEND1's end_address field.
     *
     * End address of region 1. Minimal 4K Bytes aligned. It is flash address.
     */
    inline void set_IPSNSZEND1_end_address(uint32_t value) volatile
    {
        uint32_t curr = IPSNSZEND1;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        IPSNSZEND1 = curr;
    }

    /**
     * Get AHBBUFREGIONSTART0's start_address field.
     *
     * Start address of region 0. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline uint32_t get_AHBBUFREGIONSTART0_start_address() volatile
    {
        return (AHBBUFREGIONSTART0 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONSTART0's start_address field.
     *
     * Start address of region 0. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline void set_AHBBUFREGIONSTART0_start_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONSTART0;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONSTART0 = curr;
    }

    /**
     * Get AHBBUFREGIONEND0's end_address field.
     *
     * End address of region 0. Minimal 4K Bytes aligned. It is system address.
     */
    inline uint32_t get_AHBBUFREGIONEND0_end_address() volatile
    {
        return (AHBBUFREGIONEND0 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONEND0's end_address field.
     *
     * End address of region 0. Minimal 4K Bytes aligned. It is system address.
     */
    inline void set_AHBBUFREGIONEND0_end_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONEND0;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONEND0 = curr;
    }

    /**
     * Get AHBBUFREGIONSTART1's start_address field.
     *
     * Start address of region 1. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline uint32_t get_AHBBUFREGIONSTART1_start_address() volatile
    {
        return (AHBBUFREGIONSTART1 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONSTART1's start_address field.
     *
     * Start address of region 1. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline void set_AHBBUFREGIONSTART1_start_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONSTART1;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONSTART1 = curr;
    }

    /**
     * Get AHBBUFREGIONEND1's end_address field.
     *
     * End address of region 1. Minimal 4K Bytes aligned. It is system address.
     */
    inline uint32_t get_AHBBUFREGIONEND1_end_address() volatile
    {
        return (AHBBUFREGIONEND1 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONEND1's end_address field.
     *
     * End address of region 1. Minimal 4K Bytes aligned. It is system address.
     */
    inline void set_AHBBUFREGIONEND1_end_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONEND1;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONEND1 = curr;
    }

    /**
     * Get AHBBUFREGIONSTART2's start_address field.
     *
     * Start address of region 2. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline uint32_t get_AHBBUFREGIONSTART2_start_address() volatile
    {
        return (AHBBUFREGIONSTART2 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONSTART2's start_address field.
     *
     * Start address of region 2. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline void set_AHBBUFREGIONSTART2_start_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONSTART2;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONSTART2 = curr;
    }

    /**
     * Get AHBBUFREGIONEND2's end_address field.
     *
     * End address of region 2. Minimal 4K Bytes aligned. It is system address.
     */
    inline uint32_t get_AHBBUFREGIONEND2_end_address() volatile
    {
        return (AHBBUFREGIONEND2 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONEND2's end_address field.
     *
     * End address of region 2. Minimal 4K Bytes aligned. It is system address.
     */
    inline void set_AHBBUFREGIONEND2_end_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONEND2;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONEND2 = curr;
    }

    /**
     * Get AHBBUFREGIONSTART3's start_address field.
     *
     * Start address of region 3. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline uint32_t get_AHBBUFREGIONSTART3_start_address() volatile
    {
        return (AHBBUFREGIONSTART3 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONSTART3's start_address field.
     *
     * Start address of region 3. Minimal 4K Bytes aligned. It is system
     * address.
     */
    inline void set_AHBBUFREGIONSTART3_start_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONSTART3;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONSTART3 = curr;
    }

    /**
     * Get AHBBUFREGIONEND3's end_address field.
     *
     * End address of region 3. Minimal 4K Bytes aligned. It is system address.
     */
    inline uint32_t get_AHBBUFREGIONEND3_end_address() volatile
    {
        return (AHBBUFREGIONEND3 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set AHBBUFREGIONEND3's end_address field.
     *
     * End address of region 3. Minimal 4K Bytes aligned. It is system address.
     */
    inline void set_AHBBUFREGIONEND3_end_address(uint32_t value) volatile
    {
        uint32_t curr = AHBBUFREGIONEND3;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        AHBBUFREGIONEND3 = curr;
    }
};

static_assert(sizeof(flexspi1) == flexspi1::size);

static volatile flexspi1 *const FLEXSPI1 =
    reinterpret_cast<flexspi1 *>(0x400CC000);

static volatile flexspi1 *const FLEXSPI2 =
    reinterpret_cast<flexspi1 *>(0x400D0000);

}; // namespace MIMXRT1176::CM7
