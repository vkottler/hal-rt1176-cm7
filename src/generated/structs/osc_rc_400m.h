/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * no description available
 */
struct [[gnu::packed]] osc_rc_400m
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        128; /*!< osc_rc_400m's size in bytes. */

    /* Fields. */
    uint32_t CTRL0;     /*!< (read-write) Control Register 0 */
    uint32_t CTRL0_SET; /*!< (read-write) Control Register 0 */
    uint32_t CTRL0_CLR; /*!< (read-write) Control Register 0 */
    uint32_t CTRL0_TOG; /*!< (read-write) Control Register 0 */
    uint32_t CTRL1;     /*!< (read-write) Control Register 1 */
    uint32_t CTRL1_SET; /*!< (read-write) Control Register 1 */
    uint32_t CTRL1_CLR; /*!< (read-write) Control Register 1 */
    uint32_t CTRL1_TOG; /*!< (read-write) Control Register 1 */
    uint32_t CTRL2;     /*!< (read-write) Control Register 2 */
    uint32_t CTRL2_SET; /*!< (read-write) Control Register 2 */
    uint32_t CTRL2_CLR; /*!< (read-write) Control Register 2 */
    uint32_t CTRL2_TOG; /*!< (read-write) Control Register 2 */
    uint32_t CTRL3;     /*!< (read-write) Control Register 3 */
    uint32_t CTRL3_SET; /*!< (read-write) Control Register 3 */
    uint32_t CTRL3_CLR; /*!< (read-write) Control Register 3 */
    uint32_t CTRL3_TOG; /*!< (read-write) Control Register 3 */
    static constexpr std::size_t reserved_padding0_length = 4;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t STAT0;     /*!< (read-write) Status Register 0 */
    uint32_t STAT0_SET; /*!< (read-write) Status Register 0 */
    uint32_t STAT0_CLR; /*!< (read-write) Status Register 0 */
    uint32_t STAT0_TOG; /*!< (read-write) Status Register 0 */
    uint32_t STAT1;     /*!< (read-write) Status Register 1 */
    uint32_t STAT1_SET; /*!< (read-write) Status Register 1 */
    uint32_t STAT1_CLR; /*!< (read-write) Status Register 1 */
    uint32_t STAT1_TOG; /*!< (read-write) Status Register 1 */
    uint32_t STAT2;     /*!< (read-write) Status Register 2 */
    uint32_t STAT2_SET; /*!< (read-write) Status Register 2 */
    uint32_t STAT2_CLR; /*!< (read-write) Status Register 2 */
    uint32_t STAT2_TOG; /*!< (read-write) Status Register 2 */

    /* Methods. */

    /**
     * Get CTRL0's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline uint8_t get_CTRL0_REF_CLK_DIV() volatile
    {
        return (CTRL0 >> 24u) & 0b111111u;
    }

    /**
     * Set CTRL0's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline void set_CTRL0_REF_CLK_DIV(uint8_t value) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0_SET's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline uint8_t get_CTRL0_SET_REF_CLK_DIV() volatile
    {
        return (CTRL0_SET >> 24u) & 0b111111u;
    }

    /**
     * Set CTRL0_SET's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline void set_CTRL0_SET_REF_CLK_DIV(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_SET;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        CTRL0_SET = curr;
    }

    /**
     * Get CTRL0_CLR's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline uint8_t get_CTRL0_CLR_REF_CLK_DIV() volatile
    {
        return (CTRL0_CLR >> 24u) & 0b111111u;
    }

    /**
     * Set CTRL0_CLR's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline void set_CTRL0_CLR_REF_CLK_DIV(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_CLR;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        CTRL0_CLR = curr;
    }

    /**
     * Get CTRL0_TOG's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline uint8_t get_CTRL0_TOG_REF_CLK_DIV() volatile
    {
        return (CTRL0_TOG >> 24u) & 0b111111u;
    }

    /**
     * Set CTRL0_TOG's REF_CLK_DIV field.
     *
     * Divide value for ref_clk to generate slow_clk (used inside this IP)
     */
    inline void set_CTRL0_TOG_REF_CLK_DIV(uint8_t value) volatile
    {
        uint32_t curr = CTRL0_TOG;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        CTRL0_TOG = curr;
    }

    /**
     * Get CTRL1's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline uint16_t get_CTRL1_TARGET_COUNT() volatile
    {
        return (CTRL1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL1's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline void set_CTRL1_TARGET_COUNT(uint16_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_HYST_PLUS() volatile
    {
        return (CTRL1 >> 8u) & 0b1111u;
    }

    /**
     * Set CTRL1's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline void set_CTRL1_HYST_PLUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_HYST_MINUS() volatile
    {
        return (CTRL1 >> 0u) & 0b1111u;
    }

    /**
     * Set CTRL1's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline void set_CTRL1_HYST_MINUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get all of CTRL1's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void get_CTRL1(uint16_t &TARGET_COUNT, uint8_t &HYST_PLUS,
                          uint8_t &HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1;

        TARGET_COUNT = (curr >> 16u) & 0b1111111111111111u;
        HYST_PLUS = (curr >> 8u) & 0b1111u;
        HYST_MINUS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CTRL1's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void set_CTRL1(uint16_t TARGET_COUNT, uint8_t HYST_PLUS,
                          uint8_t HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TARGET_COUNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (HYST_PLUS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (HYST_MINUS & 0b1111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1_SET's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline uint16_t get_CTRL1_SET_TARGET_COUNT() volatile
    {
        return (CTRL1_SET >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL1_SET's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline void set_CTRL1_SET_TARGET_COUNT(uint16_t value) volatile
    {
        uint32_t curr = CTRL1_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL1_SET = curr;
    }

    /**
     * Get CTRL1_SET's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_SET_HYST_PLUS() volatile
    {
        return (CTRL1_SET >> 8u) & 0b1111u;
    }

    /**
     * Set CTRL1_SET's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline void set_CTRL1_SET_HYST_PLUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_SET;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CTRL1_SET = curr;
    }

    /**
     * Get CTRL1_SET's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_SET_HYST_MINUS() volatile
    {
        return (CTRL1_SET >> 0u) & 0b1111u;
    }

    /**
     * Set CTRL1_SET's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline void set_CTRL1_SET_HYST_MINUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_SET;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CTRL1_SET = curr;
    }

    /**
     * Get all of CTRL1_SET's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void get_CTRL1_SET(uint16_t &TARGET_COUNT, uint8_t &HYST_PLUS,
                              uint8_t &HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1_SET;

        TARGET_COUNT = (curr >> 16u) & 0b1111111111111111u;
        HYST_PLUS = (curr >> 8u) & 0b1111u;
        HYST_MINUS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CTRL1_SET's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void set_CTRL1_SET(uint16_t TARGET_COUNT, uint8_t HYST_PLUS,
                              uint8_t HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TARGET_COUNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (HYST_PLUS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (HYST_MINUS & 0b1111u) << 0u;

        CTRL1_SET = curr;
    }

    /**
     * Get CTRL1_CLR's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline uint16_t get_CTRL1_CLR_TARGET_COUNT() volatile
    {
        return (CTRL1_CLR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL1_CLR's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline void set_CTRL1_CLR_TARGET_COUNT(uint16_t value) volatile
    {
        uint32_t curr = CTRL1_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL1_CLR = curr;
    }

    /**
     * Get CTRL1_CLR's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_CLR_HYST_PLUS() volatile
    {
        return (CTRL1_CLR >> 8u) & 0b1111u;
    }

    /**
     * Set CTRL1_CLR's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline void set_CTRL1_CLR_HYST_PLUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_CLR;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CTRL1_CLR = curr;
    }

    /**
     * Get CTRL1_CLR's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_CLR_HYST_MINUS() volatile
    {
        return (CTRL1_CLR >> 0u) & 0b1111u;
    }

    /**
     * Set CTRL1_CLR's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline void set_CTRL1_CLR_HYST_MINUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_CLR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CTRL1_CLR = curr;
    }

    /**
     * Get all of CTRL1_CLR's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void get_CTRL1_CLR(uint16_t &TARGET_COUNT, uint8_t &HYST_PLUS,
                              uint8_t &HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1_CLR;

        TARGET_COUNT = (curr >> 16u) & 0b1111111111111111u;
        HYST_PLUS = (curr >> 8u) & 0b1111u;
        HYST_MINUS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CTRL1_CLR's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void set_CTRL1_CLR(uint16_t TARGET_COUNT, uint8_t HYST_PLUS,
                              uint8_t HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TARGET_COUNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (HYST_PLUS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (HYST_MINUS & 0b1111u) << 0u;

        CTRL1_CLR = curr;
    }

    /**
     * Get CTRL1_TOG's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline uint16_t get_CTRL1_TOG_TARGET_COUNT() volatile
    {
        return (CTRL1_TOG >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL1_TOG's TARGET_COUNT field.
     *
     * Target count for the fast clock
     */
    inline void set_CTRL1_TOG_TARGET_COUNT(uint16_t value) volatile
    {
        uint32_t curr = CTRL1_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL1_TOG = curr;
    }

    /**
     * Get CTRL1_TOG's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_TOG_HYST_PLUS() volatile
    {
        return (CTRL1_TOG >> 8u) & 0b1111u;
    }

    /**
     * Set CTRL1_TOG's HYST_PLUS field.
     *
     * Positive hysteresis value for the tuned clock
     */
    inline void set_CTRL1_TOG_HYST_PLUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_TOG;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CTRL1_TOG = curr;
    }

    /**
     * Get CTRL1_TOG's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline uint8_t get_CTRL1_TOG_HYST_MINUS() volatile
    {
        return (CTRL1_TOG >> 0u) & 0b1111u;
    }

    /**
     * Set CTRL1_TOG's HYST_MINUS field.
     *
     * Negative hysteresis value for the tuned clock
     */
    inline void set_CTRL1_TOG_HYST_MINUS(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_TOG;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CTRL1_TOG = curr;
    }

    /**
     * Get all of CTRL1_TOG's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void get_CTRL1_TOG(uint16_t &TARGET_COUNT, uint8_t &HYST_PLUS,
                              uint8_t &HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1_TOG;

        TARGET_COUNT = (curr >> 16u) & 0b1111111111111111u;
        HYST_PLUS = (curr >> 8u) & 0b1111u;
        HYST_MINUS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of CTRL1_TOG's bit fields.
     *
     * (read-write) Control Register 1
     */
    inline void set_CTRL1_TOG(uint16_t TARGET_COUNT, uint8_t HYST_PLUS,
                              uint8_t HYST_MINUS) volatile
    {
        uint32_t curr = CTRL1_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (TARGET_COUNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111u << 8u);
        curr |= (HYST_PLUS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 0u);
        curr |= (HYST_MINUS & 0b1111u) << 0u;

        CTRL1_TOG = curr;
    }

    /**
     * Get CTRL2's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline uint8_t get_CTRL2_OSC_TUNE_VAL() volatile
    {
        return (CTRL2 >> 24u) & 0b11111111u;
    }

    /**
     * Set CTRL2's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline void set_CTRL2_OSC_TUNE_VAL(uint8_t value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline bool get_CTRL2_TUNE_START() volatile
    {
        return CTRL2 & (1u << 14u);
    }

    /**
     * Set CTRL2's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void set_CTRL2_TUNE_START() volatile
    {
        CTRL2 |= 1u << 14u;
    }

    /**
     * Clear CTRL2's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void clear_CTRL2_TUNE_START() volatile
    {
        CTRL2 &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL2's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void toggle_CTRL2_TUNE_START() volatile
    {
        CTRL2 ^= 1u << 14u;
    }

    /**
     * Get CTRL2's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline bool get_CTRL2_TUNE_EN() volatile
    {
        return CTRL2 & (1u << 12u);
    }

    /**
     * Set CTRL2's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void set_CTRL2_TUNE_EN() volatile
    {
        CTRL2 |= 1u << 12u;
    }

    /**
     * Clear CTRL2's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void clear_CTRL2_TUNE_EN() volatile
    {
        CTRL2 &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL2's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void toggle_CTRL2_TUNE_EN() volatile
    {
        CTRL2 ^= 1u << 12u;
    }

    /**
     * Get CTRL2's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline bool get_CTRL2_TUNE_BYP() volatile
    {
        return CTRL2 & (1u << 10u);
    }

    /**
     * Set CTRL2's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void set_CTRL2_TUNE_BYP() volatile
    {
        CTRL2 |= 1u << 10u;
    }

    /**
     * Clear CTRL2's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void clear_CTRL2_TUNE_BYP() volatile
    {
        CTRL2 &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL2's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void toggle_CTRL2_TUNE_BYP() volatile
    {
        CTRL2 ^= 1u << 10u;
    }

    /**
     * Get all of CTRL2's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void get_CTRL2(uint8_t &OSC_TUNE_VAL, bool &TUNE_START,
                          bool &TUNE_EN, bool &TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2;

        OSC_TUNE_VAL = (curr >> 24u) & 0b11111111u;
        TUNE_START = curr & (1u << 14u);
        TUNE_EN = curr & (1u << 12u);
        TUNE_BYP = curr & (1u << 10u);
    }

    /**
     * Set all of CTRL2's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void set_CTRL2(uint8_t OSC_TUNE_VAL, bool TUNE_START, bool TUNE_EN,
                          bool TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b11111111u << 24u);
        curr |= (OSC_TUNE_VAL & 0b11111111u) << 24u;
        curr &= ~(0b1u << 14u);
        curr |= (TUNE_START & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (TUNE_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (TUNE_BYP & 0b1u) << 10u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2_SET's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline uint8_t get_CTRL2_SET_OSC_TUNE_VAL() volatile
    {
        return (CTRL2_SET >> 24u) & 0b11111111u;
    }

    /**
     * Set CTRL2_SET's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline void set_CTRL2_SET_OSC_TUNE_VAL(uint8_t value) volatile
    {
        uint32_t curr = CTRL2_SET;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        CTRL2_SET = curr;
    }

    /**
     * Get CTRL2_SET's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline bool get_CTRL2_SET_TUNE_START() volatile
    {
        return CTRL2_SET & (1u << 14u);
    }

    /**
     * Set CTRL2_SET's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void set_CTRL2_SET_TUNE_START() volatile
    {
        CTRL2_SET |= 1u << 14u;
    }

    /**
     * Clear CTRL2_SET's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void clear_CTRL2_SET_TUNE_START() volatile
    {
        CTRL2_SET &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL2_SET's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void toggle_CTRL2_SET_TUNE_START() volatile
    {
        CTRL2_SET ^= 1u << 14u;
    }

    /**
     * Get CTRL2_SET's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline bool get_CTRL2_SET_TUNE_EN() volatile
    {
        return CTRL2_SET & (1u << 12u);
    }

    /**
     * Set CTRL2_SET's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void set_CTRL2_SET_TUNE_EN() volatile
    {
        CTRL2_SET |= 1u << 12u;
    }

    /**
     * Clear CTRL2_SET's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void clear_CTRL2_SET_TUNE_EN() volatile
    {
        CTRL2_SET &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL2_SET's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void toggle_CTRL2_SET_TUNE_EN() volatile
    {
        CTRL2_SET ^= 1u << 12u;
    }

    /**
     * Get CTRL2_SET's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline bool get_CTRL2_SET_TUNE_BYP() volatile
    {
        return CTRL2_SET & (1u << 10u);
    }

    /**
     * Set CTRL2_SET's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void set_CTRL2_SET_TUNE_BYP() volatile
    {
        CTRL2_SET |= 1u << 10u;
    }

    /**
     * Clear CTRL2_SET's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void clear_CTRL2_SET_TUNE_BYP() volatile
    {
        CTRL2_SET &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL2_SET's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void toggle_CTRL2_SET_TUNE_BYP() volatile
    {
        CTRL2_SET ^= 1u << 10u;
    }

    /**
     * Get all of CTRL2_SET's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void get_CTRL2_SET(uint8_t &OSC_TUNE_VAL, bool &TUNE_START,
                              bool &TUNE_EN, bool &TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2_SET;

        OSC_TUNE_VAL = (curr >> 24u) & 0b11111111u;
        TUNE_START = curr & (1u << 14u);
        TUNE_EN = curr & (1u << 12u);
        TUNE_BYP = curr & (1u << 10u);
    }

    /**
     * Set all of CTRL2_SET's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void set_CTRL2_SET(uint8_t OSC_TUNE_VAL, bool TUNE_START,
                              bool TUNE_EN, bool TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2_SET;

        curr &= ~(0b11111111u << 24u);
        curr |= (OSC_TUNE_VAL & 0b11111111u) << 24u;
        curr &= ~(0b1u << 14u);
        curr |= (TUNE_START & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (TUNE_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (TUNE_BYP & 0b1u) << 10u;

        CTRL2_SET = curr;
    }

    /**
     * Get CTRL2_CLR's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline uint8_t get_CTRL2_CLR_OSC_TUNE_VAL() volatile
    {
        return (CTRL2_CLR >> 24u) & 0b11111111u;
    }

    /**
     * Set CTRL2_CLR's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline void set_CTRL2_CLR_OSC_TUNE_VAL(uint8_t value) volatile
    {
        uint32_t curr = CTRL2_CLR;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        CTRL2_CLR = curr;
    }

    /**
     * Get CTRL2_CLR's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline bool get_CTRL2_CLR_TUNE_START() volatile
    {
        return CTRL2_CLR & (1u << 14u);
    }

    /**
     * Set CTRL2_CLR's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void set_CTRL2_CLR_TUNE_START() volatile
    {
        CTRL2_CLR |= 1u << 14u;
    }

    /**
     * Clear CTRL2_CLR's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void clear_CTRL2_CLR_TUNE_START() volatile
    {
        CTRL2_CLR &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL2_CLR's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void toggle_CTRL2_CLR_TUNE_START() volatile
    {
        CTRL2_CLR ^= 1u << 14u;
    }

    /**
     * Get CTRL2_CLR's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline bool get_CTRL2_CLR_TUNE_EN() volatile
    {
        return CTRL2_CLR & (1u << 12u);
    }

    /**
     * Set CTRL2_CLR's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void set_CTRL2_CLR_TUNE_EN() volatile
    {
        CTRL2_CLR |= 1u << 12u;
    }

    /**
     * Clear CTRL2_CLR's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void clear_CTRL2_CLR_TUNE_EN() volatile
    {
        CTRL2_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL2_CLR's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void toggle_CTRL2_CLR_TUNE_EN() volatile
    {
        CTRL2_CLR ^= 1u << 12u;
    }

    /**
     * Get CTRL2_CLR's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline bool get_CTRL2_CLR_TUNE_BYP() volatile
    {
        return CTRL2_CLR & (1u << 10u);
    }

    /**
     * Set CTRL2_CLR's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void set_CTRL2_CLR_TUNE_BYP() volatile
    {
        CTRL2_CLR |= 1u << 10u;
    }

    /**
     * Clear CTRL2_CLR's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void clear_CTRL2_CLR_TUNE_BYP() volatile
    {
        CTRL2_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL2_CLR's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void toggle_CTRL2_CLR_TUNE_BYP() volatile
    {
        CTRL2_CLR ^= 1u << 10u;
    }

    /**
     * Get all of CTRL2_CLR's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void get_CTRL2_CLR(uint8_t &OSC_TUNE_VAL, bool &TUNE_START,
                              bool &TUNE_EN, bool &TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2_CLR;

        OSC_TUNE_VAL = (curr >> 24u) & 0b11111111u;
        TUNE_START = curr & (1u << 14u);
        TUNE_EN = curr & (1u << 12u);
        TUNE_BYP = curr & (1u << 10u);
    }

    /**
     * Set all of CTRL2_CLR's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void set_CTRL2_CLR(uint8_t OSC_TUNE_VAL, bool TUNE_START,
                              bool TUNE_EN, bool TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2_CLR;

        curr &= ~(0b11111111u << 24u);
        curr |= (OSC_TUNE_VAL & 0b11111111u) << 24u;
        curr &= ~(0b1u << 14u);
        curr |= (TUNE_START & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (TUNE_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (TUNE_BYP & 0b1u) << 10u;

        CTRL2_CLR = curr;
    }

    /**
     * Get CTRL2_TOG's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline uint8_t get_CTRL2_TOG_OSC_TUNE_VAL() volatile
    {
        return (CTRL2_TOG >> 24u) & 0b11111111u;
    }

    /**
     * Set CTRL2_TOG's OSC_TUNE_VAL field.
     *
     * Program the oscillator frequency
     */
    inline void set_CTRL2_TOG_OSC_TUNE_VAL(uint8_t value) volatile
    {
        uint32_t curr = CTRL2_TOG;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        CTRL2_TOG = curr;
    }

    /**
     * Get CTRL2_TOG's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline bool get_CTRL2_TOG_TUNE_START() volatile
    {
        return CTRL2_TOG & (1u << 14u);
    }

    /**
     * Set CTRL2_TOG's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void set_CTRL2_TOG_TUNE_START() volatile
    {
        CTRL2_TOG |= 1u << 14u;
    }

    /**
     * Clear CTRL2_TOG's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void clear_CTRL2_TOG_TUNE_START() volatile
    {
        CTRL2_TOG &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL2_TOG's TUNE_START bit.
     *
     * Start/Stop tuning
     */
    inline void toggle_CTRL2_TOG_TUNE_START() volatile
    {
        CTRL2_TOG ^= 1u << 14u;
    }

    /**
     * Get CTRL2_TOG's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline bool get_CTRL2_TOG_TUNE_EN() volatile
    {
        return CTRL2_TOG & (1u << 12u);
    }

    /**
     * Set CTRL2_TOG's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void set_CTRL2_TOG_TUNE_EN() volatile
    {
        CTRL2_TOG |= 1u << 12u;
    }

    /**
     * Clear CTRL2_TOG's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void clear_CTRL2_TOG_TUNE_EN() volatile
    {
        CTRL2_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL2_TOG's TUNE_EN bit.
     *
     * Freeze/Unfreeze the tuning value
     */
    inline void toggle_CTRL2_TOG_TUNE_EN() volatile
    {
        CTRL2_TOG ^= 1u << 12u;
    }

    /**
     * Get CTRL2_TOG's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline bool get_CTRL2_TOG_TUNE_BYP() volatile
    {
        return CTRL2_TOG & (1u << 10u);
    }

    /**
     * Set CTRL2_TOG's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void set_CTRL2_TOG_TUNE_BYP() volatile
    {
        CTRL2_TOG |= 1u << 10u;
    }

    /**
     * Clear CTRL2_TOG's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void clear_CTRL2_TOG_TUNE_BYP() volatile
    {
        CTRL2_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL2_TOG's TUNE_BYP bit.
     *
     * Bypass the tuning logic
     */
    inline void toggle_CTRL2_TOG_TUNE_BYP() volatile
    {
        CTRL2_TOG ^= 1u << 10u;
    }

    /**
     * Get all of CTRL2_TOG's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void get_CTRL2_TOG(uint8_t &OSC_TUNE_VAL, bool &TUNE_START,
                              bool &TUNE_EN, bool &TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2_TOG;

        OSC_TUNE_VAL = (curr >> 24u) & 0b11111111u;
        TUNE_START = curr & (1u << 14u);
        TUNE_EN = curr & (1u << 12u);
        TUNE_BYP = curr & (1u << 10u);
    }

    /**
     * Set all of CTRL2_TOG's bit fields.
     *
     * (read-write) Control Register 2
     */
    inline void set_CTRL2_TOG(uint8_t OSC_TUNE_VAL, bool TUNE_START,
                              bool TUNE_EN, bool TUNE_BYP) volatile
    {
        uint32_t curr = CTRL2_TOG;

        curr &= ~(0b11111111u << 24u);
        curr |= (OSC_TUNE_VAL & 0b11111111u) << 24u;
        curr &= ~(0b1u << 14u);
        curr |= (TUNE_START & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (TUNE_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (TUNE_BYP & 0b1u) << 10u;

        CTRL2_TOG = curr;
    }

    /**
     * Get CTRL3's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline uint16_t get_CTRL3_COUNT_1M_CLK() volatile
    {
        return (CTRL3 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL3's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline void set_CTRL3_COUNT_1M_CLK(uint16_t value) volatile
    {
        uint32_t curr = CTRL3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL3 = curr;
    }

    /**
     * Get CTRL3's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline bool get_CTRL3_MUX_1M_CLK() volatile
    {
        return CTRL3 & (1u << 10u);
    }

    /**
     * Set CTRL3's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void set_CTRL3_MUX_1M_CLK() volatile
    {
        CTRL3 |= 1u << 10u;
    }

    /**
     * Clear CTRL3's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void clear_CTRL3_MUX_1M_CLK() volatile
    {
        CTRL3 &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL3's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void toggle_CTRL3_MUX_1M_CLK() volatile
    {
        CTRL3 ^= 1u << 10u;
    }

    /**
     * Get CTRL3's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline bool get_CTRL3_EN_1M_CLK() volatile
    {
        return CTRL3 & (1u << 8u);
    }

    /**
     * Set CTRL3's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void set_CTRL3_EN_1M_CLK() volatile
    {
        CTRL3 |= 1u << 8u;
    }

    /**
     * Clear CTRL3's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void clear_CTRL3_EN_1M_CLK() volatile
    {
        CTRL3 &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL3's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void toggle_CTRL3_EN_1M_CLK() volatile
    {
        CTRL3 ^= 1u << 8u;
    }

    /**
     * Get CTRL3's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline bool get_CTRL3_CLR_ERR() volatile
    {
        return CTRL3 & (1u << 0u);
    }

    /**
     * Set CTRL3's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void set_CTRL3_CLR_ERR() volatile
    {
        CTRL3 |= 1u << 0u;
    }

    /**
     * Clear CTRL3's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void clear_CTRL3_CLR_ERR() volatile
    {
        CTRL3 &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL3's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void toggle_CTRL3_CLR_ERR() volatile
    {
        CTRL3 ^= 1u << 0u;
    }

    /**
     * Get all of CTRL3's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void get_CTRL3(uint16_t &COUNT_1M_CLK, bool &MUX_1M_CLK,
                          bool &EN_1M_CLK, bool &CLR_ERR) volatile
    {
        uint32_t curr = CTRL3;

        COUNT_1M_CLK = (curr >> 16u) & 0b1111111111111111u;
        MUX_1M_CLK = curr & (1u << 10u);
        EN_1M_CLK = curr & (1u << 8u);
        CLR_ERR = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL3's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void set_CTRL3(uint16_t COUNT_1M_CLK, bool MUX_1M_CLK,
                          bool EN_1M_CLK, bool CLR_ERR) volatile
    {
        uint32_t curr = CTRL3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (COUNT_1M_CLK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (MUX_1M_CLK & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (EN_1M_CLK & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (CLR_ERR & 0b1u) << 0u;

        CTRL3 = curr;
    }

    /**
     * Get CTRL3_SET's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline uint16_t get_CTRL3_SET_COUNT_1M_CLK() volatile
    {
        return (CTRL3_SET >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL3_SET's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline void set_CTRL3_SET_COUNT_1M_CLK(uint16_t value) volatile
    {
        uint32_t curr = CTRL3_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL3_SET = curr;
    }

    /**
     * Get CTRL3_SET's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline bool get_CTRL3_SET_MUX_1M_CLK() volatile
    {
        return CTRL3_SET & (1u << 10u);
    }

    /**
     * Set CTRL3_SET's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void set_CTRL3_SET_MUX_1M_CLK() volatile
    {
        CTRL3_SET |= 1u << 10u;
    }

    /**
     * Clear CTRL3_SET's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void clear_CTRL3_SET_MUX_1M_CLK() volatile
    {
        CTRL3_SET &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL3_SET's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void toggle_CTRL3_SET_MUX_1M_CLK() volatile
    {
        CTRL3_SET ^= 1u << 10u;
    }

    /**
     * Get CTRL3_SET's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline bool get_CTRL3_SET_EN_1M_CLK() volatile
    {
        return CTRL3_SET & (1u << 8u);
    }

    /**
     * Set CTRL3_SET's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void set_CTRL3_SET_EN_1M_CLK() volatile
    {
        CTRL3_SET |= 1u << 8u;
    }

    /**
     * Clear CTRL3_SET's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void clear_CTRL3_SET_EN_1M_CLK() volatile
    {
        CTRL3_SET &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL3_SET's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void toggle_CTRL3_SET_EN_1M_CLK() volatile
    {
        CTRL3_SET ^= 1u << 8u;
    }

    /**
     * Get CTRL3_SET's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline bool get_CTRL3_SET_CLR_ERR() volatile
    {
        return CTRL3_SET & (1u << 0u);
    }

    /**
     * Set CTRL3_SET's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void set_CTRL3_SET_CLR_ERR() volatile
    {
        CTRL3_SET |= 1u << 0u;
    }

    /**
     * Clear CTRL3_SET's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void clear_CTRL3_SET_CLR_ERR() volatile
    {
        CTRL3_SET &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL3_SET's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void toggle_CTRL3_SET_CLR_ERR() volatile
    {
        CTRL3_SET ^= 1u << 0u;
    }

    /**
     * Get all of CTRL3_SET's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void get_CTRL3_SET(uint16_t &COUNT_1M_CLK, bool &MUX_1M_CLK,
                              bool &EN_1M_CLK, bool &CLR_ERR) volatile
    {
        uint32_t curr = CTRL3_SET;

        COUNT_1M_CLK = (curr >> 16u) & 0b1111111111111111u;
        MUX_1M_CLK = curr & (1u << 10u);
        EN_1M_CLK = curr & (1u << 8u);
        CLR_ERR = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL3_SET's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void set_CTRL3_SET(uint16_t COUNT_1M_CLK, bool MUX_1M_CLK,
                              bool EN_1M_CLK, bool CLR_ERR) volatile
    {
        uint32_t curr = CTRL3_SET;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (COUNT_1M_CLK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (MUX_1M_CLK & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (EN_1M_CLK & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (CLR_ERR & 0b1u) << 0u;

        CTRL3_SET = curr;
    }

    /**
     * Get CTRL3_CLR's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline uint16_t get_CTRL3_CLR_COUNT_1M_CLK() volatile
    {
        return (CTRL3_CLR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL3_CLR's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline void set_CTRL3_CLR_COUNT_1M_CLK(uint16_t value) volatile
    {
        uint32_t curr = CTRL3_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL3_CLR = curr;
    }

    /**
     * Get CTRL3_CLR's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline bool get_CTRL3_CLR_MUX_1M_CLK() volatile
    {
        return CTRL3_CLR & (1u << 10u);
    }

    /**
     * Set CTRL3_CLR's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void set_CTRL3_CLR_MUX_1M_CLK() volatile
    {
        CTRL3_CLR |= 1u << 10u;
    }

    /**
     * Clear CTRL3_CLR's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void clear_CTRL3_CLR_MUX_1M_CLK() volatile
    {
        CTRL3_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL3_CLR's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void toggle_CTRL3_CLR_MUX_1M_CLK() volatile
    {
        CTRL3_CLR ^= 1u << 10u;
    }

    /**
     * Get CTRL3_CLR's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline bool get_CTRL3_CLR_EN_1M_CLK() volatile
    {
        return CTRL3_CLR & (1u << 8u);
    }

    /**
     * Set CTRL3_CLR's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void set_CTRL3_CLR_EN_1M_CLK() volatile
    {
        CTRL3_CLR |= 1u << 8u;
    }

    /**
     * Clear CTRL3_CLR's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void clear_CTRL3_CLR_EN_1M_CLK() volatile
    {
        CTRL3_CLR &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL3_CLR's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void toggle_CTRL3_CLR_EN_1M_CLK() volatile
    {
        CTRL3_CLR ^= 1u << 8u;
    }

    /**
     * Get CTRL3_CLR's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline bool get_CTRL3_CLR_CLR_ERR() volatile
    {
        return CTRL3_CLR & (1u << 0u);
    }

    /**
     * Set CTRL3_CLR's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void set_CTRL3_CLR_CLR_ERR() volatile
    {
        CTRL3_CLR |= 1u << 0u;
    }

    /**
     * Clear CTRL3_CLR's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void clear_CTRL3_CLR_CLR_ERR() volatile
    {
        CTRL3_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL3_CLR's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void toggle_CTRL3_CLR_CLR_ERR() volatile
    {
        CTRL3_CLR ^= 1u << 0u;
    }

    /**
     * Get all of CTRL3_CLR's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void get_CTRL3_CLR(uint16_t &COUNT_1M_CLK, bool &MUX_1M_CLK,
                              bool &EN_1M_CLK, bool &CLR_ERR) volatile
    {
        uint32_t curr = CTRL3_CLR;

        COUNT_1M_CLK = (curr >> 16u) & 0b1111111111111111u;
        MUX_1M_CLK = curr & (1u << 10u);
        EN_1M_CLK = curr & (1u << 8u);
        CLR_ERR = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL3_CLR's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void set_CTRL3_CLR(uint16_t COUNT_1M_CLK, bool MUX_1M_CLK,
                              bool EN_1M_CLK, bool CLR_ERR) volatile
    {
        uint32_t curr = CTRL3_CLR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (COUNT_1M_CLK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (MUX_1M_CLK & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (EN_1M_CLK & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (CLR_ERR & 0b1u) << 0u;

        CTRL3_CLR = curr;
    }

    /**
     * Get CTRL3_TOG's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline uint16_t get_CTRL3_TOG_COUNT_1M_CLK() volatile
    {
        return (CTRL3_TOG >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CTRL3_TOG's COUNT_1M_CLK field.
     *
     * Count for the locked clk_1m_out
     */
    inline void set_CTRL3_TOG_COUNT_1M_CLK(uint16_t value) volatile
    {
        uint32_t curr = CTRL3_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CTRL3_TOG = curr;
    }

    /**
     * Get CTRL3_TOG's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline bool get_CTRL3_TOG_MUX_1M_CLK() volatile
    {
        return CTRL3_TOG & (1u << 10u);
    }

    /**
     * Set CTRL3_TOG's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void set_CTRL3_TOG_MUX_1M_CLK() volatile
    {
        CTRL3_TOG |= 1u << 10u;
    }

    /**
     * Clear CTRL3_TOG's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void clear_CTRL3_TOG_MUX_1M_CLK() volatile
    {
        CTRL3_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL3_TOG's MUX_1M_CLK bit.
     *
     * Select free/locked 1MHz output
     */
    inline void toggle_CTRL3_TOG_MUX_1M_CLK() volatile
    {
        CTRL3_TOG ^= 1u << 10u;
    }

    /**
     * Get CTRL3_TOG's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline bool get_CTRL3_TOG_EN_1M_CLK() volatile
    {
        return CTRL3_TOG & (1u << 8u);
    }

    /**
     * Set CTRL3_TOG's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void set_CTRL3_TOG_EN_1M_CLK() volatile
    {
        CTRL3_TOG |= 1u << 8u;
    }

    /**
     * Clear CTRL3_TOG's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void clear_CTRL3_TOG_EN_1M_CLK() volatile
    {
        CTRL3_TOG &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL3_TOG's EN_1M_CLK bit.
     *
     * Enable 1MHz output Clock
     */
    inline void toggle_CTRL3_TOG_EN_1M_CLK() volatile
    {
        CTRL3_TOG ^= 1u << 8u;
    }

    /**
     * Get CTRL3_TOG's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline bool get_CTRL3_TOG_CLR_ERR() volatile
    {
        return CTRL3_TOG & (1u << 0u);
    }

    /**
     * Set CTRL3_TOG's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void set_CTRL3_TOG_CLR_ERR() volatile
    {
        CTRL3_TOG |= 1u << 0u;
    }

    /**
     * Clear CTRL3_TOG's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void clear_CTRL3_TOG_CLR_ERR() volatile
    {
        CTRL3_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL3_TOG's CLR_ERR bit.
     *
     * Clear the error flag CLK1M_ERR
     */
    inline void toggle_CTRL3_TOG_CLR_ERR() volatile
    {
        CTRL3_TOG ^= 1u << 0u;
    }

    /**
     * Get all of CTRL3_TOG's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void get_CTRL3_TOG(uint16_t &COUNT_1M_CLK, bool &MUX_1M_CLK,
                              bool &EN_1M_CLK, bool &CLR_ERR) volatile
    {
        uint32_t curr = CTRL3_TOG;

        COUNT_1M_CLK = (curr >> 16u) & 0b1111111111111111u;
        MUX_1M_CLK = curr & (1u << 10u);
        EN_1M_CLK = curr & (1u << 8u);
        CLR_ERR = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL3_TOG's bit fields.
     *
     * (read-write) Control Register 3
     */
    inline void set_CTRL3_TOG(uint16_t COUNT_1M_CLK, bool MUX_1M_CLK,
                              bool EN_1M_CLK, bool CLR_ERR) volatile
    {
        uint32_t curr = CTRL3_TOG;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (COUNT_1M_CLK & 0b1111111111111111u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (MUX_1M_CLK & 0b1u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (EN_1M_CLK & 0b1u) << 8u;
        curr &= ~(0b1u << 0u);
        curr |= (CLR_ERR & 0b1u) << 0u;

        CTRL3_TOG = curr;
    }

    /**
     * Get STAT0's CLK1M_ERR bit.
     *
     * Error flag for clk_1m_locked
     */
    inline bool get_STAT0_CLK1M_ERR() volatile
    {
        return STAT0 & (1u << 0u);
    }

    /**
     * Get STAT0_SET's CLK1M_ERR bit.
     *
     * Error flag for clk_1m_locked
     */
    inline bool get_STAT0_SET_CLK1M_ERR() volatile
    {
        return STAT0_SET & (1u << 0u);
    }

    /**
     * Get STAT0_CLR's CLK1M_ERR bit.
     *
     * Error flag for clk_1m_locked
     */
    inline bool get_STAT0_CLR_CLK1M_ERR() volatile
    {
        return STAT0_CLR & (1u << 0u);
    }

    /**
     * Get STAT0_TOG's CLK1M_ERR bit.
     *
     * Error flag for clk_1m_locked
     */
    inline bool get_STAT0_TOG_CLK1M_ERR() volatile
    {
        return STAT0_TOG & (1u << 0u);
    }

    /**
     * Get STAT1's CURR_COUNT_VAL field.
     *
     * Current count for the fast clock
     */
    inline uint16_t get_STAT1_CURR_COUNT_VAL() volatile
    {
        return (STAT1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get STAT1_SET's CURR_COUNT_VAL field.
     *
     * Current count for the fast clock
     */
    inline uint16_t get_STAT1_SET_CURR_COUNT_VAL() volatile
    {
        return (STAT1_SET >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get STAT1_CLR's CURR_COUNT_VAL field.
     *
     * Current count for the fast clock
     */
    inline uint16_t get_STAT1_CLR_CURR_COUNT_VAL() volatile
    {
        return (STAT1_CLR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get STAT1_TOG's CURR_COUNT_VAL field.
     *
     * Current count for the fast clock
     */
    inline uint16_t get_STAT1_TOG_CURR_COUNT_VAL() volatile
    {
        return (STAT1_TOG >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get STAT2's CURR_OSC_TUNE_VAL field.
     *
     * Current tuning value used by oscillator
     */
    inline uint8_t get_STAT2_CURR_OSC_TUNE_VAL() volatile
    {
        return (STAT2 >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT2_SET's CURR_OSC_TUNE_VAL field.
     *
     * Current tuning value used by oscillator
     */
    inline uint8_t get_STAT2_SET_CURR_OSC_TUNE_VAL() volatile
    {
        return (STAT2_SET >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT2_CLR's CURR_OSC_TUNE_VAL field.
     *
     * Current tuning value used by oscillator
     */
    inline uint8_t get_STAT2_CLR_CURR_OSC_TUNE_VAL() volatile
    {
        return (STAT2_CLR >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT2_TOG's CURR_OSC_TUNE_VAL field.
     *
     * Current tuning value used by oscillator
     */
    inline uint8_t get_STAT2_TOG_CURR_OSC_TUNE_VAL() volatile
    {
        return (STAT2_TOG >> 24u) & 0b11111111u;
    }
};

static_assert(sizeof(osc_rc_400m) == osc_rc_400m::size);

static volatile osc_rc_400m *const OSC_RC_400M =
    reinterpret_cast<osc_rc_400m *>(0);

}; // namespace MIMXRT1176::CM7
