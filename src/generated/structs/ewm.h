/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * EWM
 */
struct [[gnu::packed]] ewm
{
    /* Constant attributes. */
    static constexpr std::size_t size = 6; /*!< ewm's size in bytes. */

    /* Fields. */
    uint8_t CTRL;         /*!< (read-write) Control Register */
    uint8_t SERV;         /*!< (read-write) Service Register */
    uint8_t CMPL;         /*!< (read-write) Compare Low Register */
    uint8_t CMPH;         /*!< (read-write) Compare High Register */
    uint8_t CLKCTRL;      /*!< (read-write) Clock Control Register */
    uint8_t CLKPRESCALER; /*!< (read-write) Clock Prescaler Register */

    /* Methods. */

    /**
     * Get CTRL's INTEN bit.
     *
     * Interrupt Enable.
     */
    inline bool get_CTRL_INTEN() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's INTEN bit.
     *
     * Interrupt Enable.
     */
    inline void set_CTRL_INTEN() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's INTEN bit.
     *
     * Interrupt Enable.
     */
    inline void clear_CTRL_INTEN() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's INTEN bit.
     *
     * Interrupt Enable.
     */
    inline void toggle_CTRL_INTEN() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get CTRL's INEN bit.
     *
     * Input Enable.
     */
    inline bool get_CTRL_INEN() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's INEN bit.
     *
     * Input Enable.
     */
    inline void set_CTRL_INEN() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's INEN bit.
     *
     * Input Enable.
     */
    inline void clear_CTRL_INEN() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's INEN bit.
     *
     * Input Enable.
     */
    inline void toggle_CTRL_INEN() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's ASSIN bit.
     *
     * EWM_in's Assertion State Select.
     */
    inline bool get_CTRL_ASSIN() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's ASSIN bit.
     *
     * EWM_in's Assertion State Select.
     */
    inline void set_CTRL_ASSIN() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's ASSIN bit.
     *
     * EWM_in's Assertion State Select.
     */
    inline void clear_CTRL_ASSIN() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's ASSIN bit.
     *
     * EWM_in's Assertion State Select.
     */
    inline void toggle_CTRL_ASSIN() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's EWMEN bit.
     *
     * EWM enable.
     */
    inline bool get_CTRL_EWMEN() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's EWMEN bit.
     *
     * EWM enable.
     */
    inline void set_CTRL_EWMEN() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's EWMEN bit.
     *
     * EWM enable.
     */
    inline void clear_CTRL_EWMEN() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's EWMEN bit.
     *
     * EWM enable.
     */
    inline void toggle_CTRL_EWMEN() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) Control Register
     */
    inline void get_CTRL(bool &INTEN, bool &INEN, bool &ASSIN,
                         bool &EWMEN) volatile
    {
        uint8_t curr = CTRL;

        INTEN = curr & (1u << 3u);
        INEN = curr & (1u << 2u);
        ASSIN = curr & (1u << 1u);
        EWMEN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) Control Register
     */
    inline void set_CTRL(bool INTEN, bool INEN, bool ASSIN,
                         bool EWMEN) volatile
    {
        uint8_t curr = CTRL;

        curr &= ~(0b1u << 3u);
        curr |= (INTEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (INEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ASSIN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EWMEN & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get SERV's SERVICE field.
     *
     * SERVICE
     */
    inline uint8_t get_SERV_SERVICE() volatile
    {
        return (SERV >> 0u) & 0b11111111u;
    }

    /**
     * Set SERV's SERVICE field.
     *
     * SERVICE
     */
    inline void set_SERV_SERVICE(uint8_t value) volatile
    {
        uint8_t curr = SERV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SERV = curr;
    }

    /**
     * Get CMPL's COMPAREL field.
     *
     * COMPAREL
     */
    inline uint8_t get_CMPL_COMPAREL() volatile
    {
        return (CMPL >> 0u) & 0b11111111u;
    }

    /**
     * Set CMPL's COMPAREL field.
     *
     * COMPAREL
     */
    inline void set_CMPL_COMPAREL(uint8_t value) volatile
    {
        uint8_t curr = CMPL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CMPL = curr;
    }

    /**
     * Get CMPH's COMPAREH field.
     *
     * COMPAREH
     */
    inline uint8_t get_CMPH_COMPAREH() volatile
    {
        return (CMPH >> 0u) & 0b11111111u;
    }

    /**
     * Set CMPH's COMPAREH field.
     *
     * COMPAREH
     */
    inline void set_CMPH_COMPAREH(uint8_t value) volatile
    {
        uint8_t curr = CMPH;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CMPH = curr;
    }

    /**
     * Get CLKCTRL's CLKSEL field.
     *
     * CLKSEL
     */
    inline uint8_t get_CLKCTRL_CLKSEL() volatile
    {
        return (CLKCTRL >> 0u) & 0b11u;
    }

    /**
     * Set CLKCTRL's CLKSEL field.
     *
     * CLKSEL
     */
    inline void set_CLKCTRL_CLKSEL(uint8_t value) volatile
    {
        uint8_t curr = CLKCTRL;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        CLKCTRL = curr;
    }

    /**
     * Get CLKPRESCALER's CLK_DIV field.
     *
     * CLK_DIV
     */
    inline uint8_t get_CLKPRESCALER_CLK_DIV() volatile
    {
        return (CLKPRESCALER >> 0u) & 0b11111111u;
    }

    /**
     * Set CLKPRESCALER's CLK_DIV field.
     *
     * CLK_DIV
     */
    inline void set_CLKPRESCALER_CLK_DIV(uint8_t value) volatile
    {
        uint8_t curr = CLKPRESCALER;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLKPRESCALER = curr;
    }
};

static_assert(sizeof(ewm) == ewm::size);

static volatile ewm *const EWM = reinterpret_cast<ewm *>(0x4002C000);

}; // namespace MIMXRT1176::CM7
