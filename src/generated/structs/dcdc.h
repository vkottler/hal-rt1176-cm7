/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/DCDC_CTRL1_VDD1P0CTRL_STBY_TRG.h"
#include "../enums/DCDC_CTRL1_VDD1P0CTRL_TRG.h"
#include "../enums/DCDC_CTRL1_VDD1P8CTRL_STBY_TRG.h"
#include "../enums/DCDC_CTRL1_VDD1P8CTRL_TRG.h"
#include "../enums/DCDC_REG1_LP_CMP_ISRC_SEL.h"
#include "../enums/DCDC_REG1_VBG_TRIM.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * DCDC
 */
struct [[gnu::packed]] dcdc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 112; /*!< dcdc's size in bytes. */

    /* Fields. */
    uint32_t CTRL0; /*!< (read-write) DCDC Control Register 0 */
    uint32_t CTRL1; /*!< (read-write) DCDC Control Register 1 */
    uint32_t REG0;  /*!< (read-write) DCDC Register 0 */
    uint32_t REG1;  /*!< (read-write) DCDC Register 1 */
    uint32_t REG2;  /*!< (read-write) DCDC Register 2 */
    uint32_t REG3;  /*!< (read-write) DCDC Register 3 */
    uint32_t REG4;  /*!< (read-write) DCDC Register 4 */
    uint32_t REG5;  /*!< (read-write) DCDC Register 5 */
    uint32_t REG6;  /*!< (read-write) DCDC Register 6 */
    uint32_t REG7;  /*!< (read-write) DCDC Register 7 */
    uint32_t REG7P; /*!< (read-write) DCDC Register 7 plus */
    uint32_t REG8;  /*!< (read-write) DCDC Register 8 */
    uint32_t REG9;  /*!< (read-write) DCDC Register 9 */
    uint32_t REG10; /*!< (read-write) DCDC Register 10 */
    uint32_t REG11; /*!< (read-write) DCDC Register 11 */
    uint32_t REG12; /*!< (read-write) DCDC Register 12 */
    uint32_t REG13; /*!< (read-write) DCDC Register 13 */
    uint32_t REG14; /*!< (read-write) DCDC Register 14 */
    uint32_t REG15; /*!< (read-write) DCDC Register 15 */
    uint32_t REG16; /*!< (read-write) DCDC Register 16 */
    uint32_t REG17; /*!< (read-write) DCDC Register 17 */
    uint32_t REG18; /*!< (read-write) DCDC Register 18 */
    uint32_t REG19; /*!< (read-write) DCDC Register 19 */
    uint32_t REG20; /*!< (read-write) DCDC Register 20 */
    uint32_t REG21; /*!< (read-write) DCDC Register 21 */
    uint32_t REG22; /*!< (read-write) DCDC Register 22 */
    uint32_t REG23; /*!< (read-write) DCDC Register 23 */
    uint32_t REG24; /*!< (read-write) DCDC Register 24 */

    /* Methods. */

    /**
     * Get CTRL0's CONTROL_MODE bit.
     *
     * Control mode
     */
    inline bool get_CTRL0_CONTROL_MODE() volatile
    {
        return CTRL0 & (1u << 31u);
    }

    /**
     * Set CTRL0's CONTROL_MODE bit.
     *
     * Control mode
     */
    inline void set_CTRL0_CONTROL_MODE() volatile
    {
        CTRL0 |= 1u << 31u;
    }

    /**
     * Clear CTRL0's CONTROL_MODE bit.
     *
     * Control mode
     */
    inline void clear_CTRL0_CONTROL_MODE() volatile
    {
        CTRL0 &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL0's CONTROL_MODE bit.
     *
     * Control mode
     */
    inline void toggle_CTRL0_CONTROL_MODE() volatile
    {
        CTRL0 ^= 1u << 31u;
    }

    /**
     * Get CTRL0's DEBUG_BITS field.
     *
     * DEBUG_BITS[11:0]
     */
    inline uint16_t get_CTRL0_DEBUG_BITS() volatile
    {
        return (CTRL0 >> 19u) & 0b111111111111u;
    }

    /**
     * Set CTRL0's DEBUG_BITS field.
     *
     * DEBUG_BITS[11:0]
     */
    inline void set_CTRL0_DEBUG_BITS(uint16_t value) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b111111111111u << 19u);
        curr |= (value & 0b111111111111u) << 19u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0's TRIM_HOLD bit.
     *
     * Hold trim input
     */
    inline bool get_CTRL0_TRIM_HOLD() volatile
    {
        return CTRL0 & (1u << 6u);
    }

    /**
     * Set CTRL0's TRIM_HOLD bit.
     *
     * Hold trim input
     */
    inline void set_CTRL0_TRIM_HOLD() volatile
    {
        CTRL0 |= 1u << 6u;
    }

    /**
     * Clear CTRL0's TRIM_HOLD bit.
     *
     * Hold trim input
     */
    inline void clear_CTRL0_TRIM_HOLD() volatile
    {
        CTRL0 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL0's TRIM_HOLD bit.
     *
     * Hold trim input
     */
    inline void toggle_CTRL0_TRIM_HOLD() volatile
    {
        CTRL0 ^= 1u << 6u;
    }

    /**
     * Get CTRL0's ENABLE_DCDC_CNT bit.
     *
     * Enable internal count for DCDC_OK timeout
     */
    inline bool get_CTRL0_ENABLE_DCDC_CNT() volatile
    {
        return CTRL0 & (1u << 5u);
    }

    /**
     * Set CTRL0's ENABLE_DCDC_CNT bit.
     *
     * Enable internal count for DCDC_OK timeout
     */
    inline void set_CTRL0_ENABLE_DCDC_CNT() volatile
    {
        CTRL0 |= 1u << 5u;
    }

    /**
     * Clear CTRL0's ENABLE_DCDC_CNT bit.
     *
     * Enable internal count for DCDC_OK timeout
     */
    inline void clear_CTRL0_ENABLE_DCDC_CNT() volatile
    {
        CTRL0 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL0's ENABLE_DCDC_CNT bit.
     *
     * Enable internal count for DCDC_OK timeout
     */
    inline void toggle_CTRL0_ENABLE_DCDC_CNT() volatile
    {
        CTRL0 ^= 1u << 5u;
    }

    /**
     * Get CTRL0's STBY_LP_MODE_EN bit.
     *
     * DCDC low-power mode enable by GPC standby request
     */
    inline bool get_CTRL0_STBY_LP_MODE_EN() volatile
    {
        return CTRL0 & (1u << 4u);
    }

    /**
     * Set CTRL0's STBY_LP_MODE_EN bit.
     *
     * DCDC low-power mode enable by GPC standby request
     */
    inline void set_CTRL0_STBY_LP_MODE_EN() volatile
    {
        CTRL0 |= 1u << 4u;
    }

    /**
     * Clear CTRL0's STBY_LP_MODE_EN bit.
     *
     * DCDC low-power mode enable by GPC standby request
     */
    inline void clear_CTRL0_STBY_LP_MODE_EN() volatile
    {
        CTRL0 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL0's STBY_LP_MODE_EN bit.
     *
     * DCDC low-power mode enable by GPC standby request
     */
    inline void toggle_CTRL0_STBY_LP_MODE_EN() volatile
    {
        CTRL0 ^= 1u << 4u;
    }

    /**
     * Get CTRL0's LP_MODE_EN bit.
     *
     * DCDC low-power (LP) mode enable DCDC can't start up directly into LP
     * mode
     */
    inline bool get_CTRL0_LP_MODE_EN() volatile
    {
        return CTRL0 & (1u << 3u);
    }

    /**
     * Set CTRL0's LP_MODE_EN bit.
     *
     * DCDC low-power (LP) mode enable DCDC can't start up directly into LP
     * mode
     */
    inline void set_CTRL0_LP_MODE_EN() volatile
    {
        CTRL0 |= 1u << 3u;
    }

    /**
     * Clear CTRL0's LP_MODE_EN bit.
     *
     * DCDC low-power (LP) mode enable DCDC can't start up directly into LP
     * mode
     */
    inline void clear_CTRL0_LP_MODE_EN() volatile
    {
        CTRL0 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL0's LP_MODE_EN bit.
     *
     * DCDC low-power (LP) mode enable DCDC can't start up directly into LP
     * mode
     */
    inline void toggle_CTRL0_LP_MODE_EN() volatile
    {
        CTRL0 ^= 1u << 3u;
    }

    /**
     * Get CTRL0's STBY_EN bit.
     *
     * DCDC standby mode enable
     */
    inline bool get_CTRL0_STBY_EN() volatile
    {
        return CTRL0 & (1u << 2u);
    }

    /**
     * Set CTRL0's STBY_EN bit.
     *
     * DCDC standby mode enable
     */
    inline void set_CTRL0_STBY_EN() volatile
    {
        CTRL0 |= 1u << 2u;
    }

    /**
     * Clear CTRL0's STBY_EN bit.
     *
     * DCDC standby mode enable
     */
    inline void clear_CTRL0_STBY_EN() volatile
    {
        CTRL0 &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL0's STBY_EN bit.
     *
     * DCDC standby mode enable
     */
    inline void toggle_CTRL0_STBY_EN() volatile
    {
        CTRL0 ^= 1u << 2u;
    }

    /**
     * Get CTRL0's DIG_EN bit.
     *
     * Enable the DCDC_DIG switching converter output
     */
    inline bool get_CTRL0_DIG_EN() volatile
    {
        return CTRL0 & (1u << 1u);
    }

    /**
     * Set CTRL0's DIG_EN bit.
     *
     * Enable the DCDC_DIG switching converter output
     */
    inline void set_CTRL0_DIG_EN() volatile
    {
        CTRL0 |= 1u << 1u;
    }

    /**
     * Clear CTRL0's DIG_EN bit.
     *
     * Enable the DCDC_DIG switching converter output
     */
    inline void clear_CTRL0_DIG_EN() volatile
    {
        CTRL0 &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL0's DIG_EN bit.
     *
     * Enable the DCDC_DIG switching converter output
     */
    inline void toggle_CTRL0_DIG_EN() volatile
    {
        CTRL0 ^= 1u << 1u;
    }

    /**
     * Get CTRL0's ENABLE bit.
     *
     * DCDC Enable
     */
    inline bool get_CTRL0_ENABLE() volatile
    {
        return CTRL0 & (1u << 0u);
    }

    /**
     * Set CTRL0's ENABLE bit.
     *
     * DCDC Enable
     */
    inline void set_CTRL0_ENABLE() volatile
    {
        CTRL0 |= 1u << 0u;
    }

    /**
     * Clear CTRL0's ENABLE bit.
     *
     * DCDC Enable
     */
    inline void clear_CTRL0_ENABLE() volatile
    {
        CTRL0 &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL0's ENABLE bit.
     *
     * DCDC Enable
     */
    inline void toggle_CTRL0_ENABLE() volatile
    {
        CTRL0 ^= 1u << 0u;
    }

    /**
     * Get all of CTRL0's bit fields.
     *
     * (read-write) DCDC Control Register 0
     */
    inline void get_CTRL0(bool &CONTROL_MODE, uint16_t &DEBUG_BITS,
                          bool &TRIM_HOLD, bool &ENABLE_DCDC_CNT,
                          bool &STBY_LP_MODE_EN, bool &LP_MODE_EN,
                          bool &STBY_EN, bool &DIG_EN, bool &ENABLE) volatile
    {
        uint32_t curr = CTRL0;

        CONTROL_MODE = curr & (1u << 31u);
        DEBUG_BITS = (curr >> 19u) & 0b111111111111u;
        TRIM_HOLD = curr & (1u << 6u);
        ENABLE_DCDC_CNT = curr & (1u << 5u);
        STBY_LP_MODE_EN = curr & (1u << 4u);
        LP_MODE_EN = curr & (1u << 3u);
        STBY_EN = curr & (1u << 2u);
        DIG_EN = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL0's bit fields.
     *
     * (read-write) DCDC Control Register 0
     */
    inline void set_CTRL0(bool CONTROL_MODE, uint16_t DEBUG_BITS,
                          bool TRIM_HOLD, bool ENABLE_DCDC_CNT,
                          bool STBY_LP_MODE_EN, bool LP_MODE_EN, bool STBY_EN,
                          bool DIG_EN, bool ENABLE) volatile
    {
        uint32_t curr = CTRL0;

        curr &= ~(0b1u << 31u);
        curr |= (CONTROL_MODE & 0b1u) << 31u;
        curr &= ~(0b111111111111u << 19u);
        curr |= (DEBUG_BITS & 0b111111111111u) << 19u;
        curr &= ~(0b1u << 6u);
        curr |= (TRIM_HOLD & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ENABLE_DCDC_CNT & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (STBY_LP_MODE_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LP_MODE_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (STBY_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DIG_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL1's VDD1P0CTRL_STBY_TRG field.
     *
     * Target value of VDD1P0 in standby mode, 25mV each step from 0x00 to
     * 0x1F:
     */
    inline DCDC_CTRL1_VDD1P0CTRL_STBY_TRG
    get_CTRL1_VDD1P0CTRL_STBY_TRG() volatile
    {
        return DCDC_CTRL1_VDD1P0CTRL_STBY_TRG((CTRL1 >> 24u) & 0b11111u);
    }

    /**
     * Set CTRL1's VDD1P0CTRL_STBY_TRG field.
     *
     * Target value of VDD1P0 in standby mode, 25mV each step from 0x00 to
     * 0x1F:
     */
    inline void set_CTRL1_VDD1P0CTRL_STBY_TRG(
        DCDC_CTRL1_VDD1P0CTRL_STBY_TRG value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111u) << 24u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's VDD1P8CTRL_STBY_TRG field.
     *
     * Target value of VDD1P8 in standby mode, 25mV each step from 0x00 to
     * 0x1F:
     */
    inline DCDC_CTRL1_VDD1P8CTRL_STBY_TRG
    get_CTRL1_VDD1P8CTRL_STBY_TRG() volatile
    {
        return DCDC_CTRL1_VDD1P8CTRL_STBY_TRG((CTRL1 >> 16u) & 0b11111u);
    }

    /**
     * Set CTRL1's VDD1P8CTRL_STBY_TRG field.
     *
     * Target value of VDD1P8 in standby mode, 25mV each step from 0x00 to
     * 0x1F:
     */
    inline void set_CTRL1_VDD1P8CTRL_STBY_TRG(
        DCDC_CTRL1_VDD1P8CTRL_STBY_TRG value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111u << 16u);
        curr |= (std::to_underlying(value) & 0b11111u) << 16u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's VDD1P0CTRL_TRG field.
     *
     * Target value of VDD1P0 in buck mode, 25mV each step from 0x00 to 0x1F:
     */
    inline DCDC_CTRL1_VDD1P0CTRL_TRG get_CTRL1_VDD1P0CTRL_TRG() volatile
    {
        return DCDC_CTRL1_VDD1P0CTRL_TRG((CTRL1 >> 8u) & 0b11111u);
    }

    /**
     * Set CTRL1's VDD1P0CTRL_TRG field.
     *
     * Target value of VDD1P0 in buck mode, 25mV each step from 0x00 to 0x1F:
     */
    inline void set_CTRL1_VDD1P0CTRL_TRG(
        DCDC_CTRL1_VDD1P0CTRL_TRG value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111u) << 8u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's VDD1P8CTRL_TRG field.
     *
     * Target value of VDD1P8 in buck mode, 25mV each step from 0x00 to 0x1F:
     */
    inline DCDC_CTRL1_VDD1P8CTRL_TRG get_CTRL1_VDD1P8CTRL_TRG() volatile
    {
        return DCDC_CTRL1_VDD1P8CTRL_TRG((CTRL1 >> 0u) & 0b11111u);
    }

    /**
     * Set CTRL1's VDD1P8CTRL_TRG field.
     *
     * Target value of VDD1P8 in buck mode, 25mV each step from 0x00 to 0x1F:
     */
    inline void set_CTRL1_VDD1P8CTRL_TRG(
        DCDC_CTRL1_VDD1P8CTRL_TRG value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get all of CTRL1's bit fields.
     *
     * (read-write) DCDC Control Register 1
     */
    inline void get_CTRL1(DCDC_CTRL1_VDD1P0CTRL_STBY_TRG &VDD1P0CTRL_STBY_TRG,
                          DCDC_CTRL1_VDD1P8CTRL_STBY_TRG &VDD1P8CTRL_STBY_TRG,
                          DCDC_CTRL1_VDD1P0CTRL_TRG &VDD1P0CTRL_TRG,
                          DCDC_CTRL1_VDD1P8CTRL_TRG &VDD1P8CTRL_TRG) volatile
    {
        uint32_t curr = CTRL1;

        VDD1P0CTRL_STBY_TRG =
            DCDC_CTRL1_VDD1P0CTRL_STBY_TRG((curr >> 24u) & 0b11111u);
        VDD1P8CTRL_STBY_TRG =
            DCDC_CTRL1_VDD1P8CTRL_STBY_TRG((curr >> 16u) & 0b11111u);
        VDD1P0CTRL_TRG = DCDC_CTRL1_VDD1P0CTRL_TRG((curr >> 8u) & 0b11111u);
        VDD1P8CTRL_TRG = DCDC_CTRL1_VDD1P8CTRL_TRG((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of CTRL1's bit fields.
     *
     * (read-write) DCDC Control Register 1
     */
    inline void set_CTRL1(DCDC_CTRL1_VDD1P0CTRL_STBY_TRG VDD1P0CTRL_STBY_TRG,
                          DCDC_CTRL1_VDD1P8CTRL_STBY_TRG VDD1P8CTRL_STBY_TRG,
                          DCDC_CTRL1_VDD1P0CTRL_TRG VDD1P0CTRL_TRG,
                          DCDC_CTRL1_VDD1P8CTRL_TRG VDD1P8CTRL_TRG) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b11111u << 24u);
        curr |= (std::to_underlying(VDD1P0CTRL_STBY_TRG) & 0b11111u) << 24u;
        curr &= ~(0b11111u << 16u);
        curr |= (std::to_underlying(VDD1P8CTRL_STBY_TRG) & 0b11111u) << 16u;
        curr &= ~(0b11111u << 8u);
        curr |= (std::to_underlying(VDD1P0CTRL_TRG) & 0b11111u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(VDD1P8CTRL_TRG) & 0b11111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get REG0's STS_DC_OK bit.
     *
     * DCDC Output OK
     */
    inline bool get_REG0_STS_DC_OK() volatile
    {
        return REG0 & (1u << 31u);
    }

    /**
     * Get REG0's XTAL_24M_OK bit.
     *
     * 24M XTAL OK
     */
    inline bool get_REG0_XTAL_24M_OK() volatile
    {
        return REG0 & (1u << 29u);
    }

    /**
     * Set REG0's XTAL_24M_OK bit.
     *
     * 24M XTAL OK
     */
    inline void set_REG0_XTAL_24M_OK() volatile
    {
        REG0 |= 1u << 29u;
    }

    /**
     * Clear REG0's XTAL_24M_OK bit.
     *
     * 24M XTAL OK
     */
    inline void clear_REG0_XTAL_24M_OK() volatile
    {
        REG0 &= ~(1u << 29u);
    }

    /**
     * Toggle REG0's XTAL_24M_OK bit.
     *
     * 24M XTAL OK
     */
    inline void toggle_REG0_XTAL_24M_OK() volatile
    {
        REG0 ^= 1u << 29u;
    }

    /**
     * Get REG0's XTALOK_DISABLE bit.
     *
     * Disable xtalok detection circuit
     */
    inline bool get_REG0_XTALOK_DISABLE() volatile
    {
        return REG0 & (1u << 27u);
    }

    /**
     * Set REG0's XTALOK_DISABLE bit.
     *
     * Disable xtalok detection circuit
     */
    inline void set_REG0_XTALOK_DISABLE() volatile
    {
        REG0 |= 1u << 27u;
    }

    /**
     * Clear REG0's XTALOK_DISABLE bit.
     *
     * Disable xtalok detection circuit
     */
    inline void clear_REG0_XTALOK_DISABLE() volatile
    {
        REG0 &= ~(1u << 27u);
    }

    /**
     * Toggle REG0's XTALOK_DISABLE bit.
     *
     * Disable xtalok detection circuit
     */
    inline void toggle_REG0_XTALOK_DISABLE() volatile
    {
        REG0 ^= 1u << 27u;
    }

    /**
     * Get REG0's PWD_CMP_OFFSET bit.
     *
     * power down the out-of-range detection comparator
     */
    inline bool get_REG0_PWD_CMP_OFFSET() volatile
    {
        return REG0 & (1u << 26u);
    }

    /**
     * Set REG0's PWD_CMP_OFFSET bit.
     *
     * power down the out-of-range detection comparator
     */
    inline void set_REG0_PWD_CMP_OFFSET() volatile
    {
        REG0 |= 1u << 26u;
    }

    /**
     * Clear REG0's PWD_CMP_OFFSET bit.
     *
     * power down the out-of-range detection comparator
     */
    inline void clear_REG0_PWD_CMP_OFFSET() volatile
    {
        REG0 &= ~(1u << 26u);
    }

    /**
     * Toggle REG0's PWD_CMP_OFFSET bit.
     *
     * power down the out-of-range detection comparator
     */
    inline void toggle_REG0_PWD_CMP_OFFSET() volatile
    {
        REG0 ^= 1u << 26u;
    }

    /**
     * Get REG0's LP_HIGH_HYS bit.
     *
     * Low Power High Hysteric Value
     */
    inline bool get_REG0_LP_HIGH_HYS() volatile
    {
        return REG0 & (1u << 21u);
    }

    /**
     * Set REG0's LP_HIGH_HYS bit.
     *
     * Low Power High Hysteric Value
     */
    inline void set_REG0_LP_HIGH_HYS() volatile
    {
        REG0 |= 1u << 21u;
    }

    /**
     * Clear REG0's LP_HIGH_HYS bit.
     *
     * Low Power High Hysteric Value
     */
    inline void clear_REG0_LP_HIGH_HYS() volatile
    {
        REG0 &= ~(1u << 21u);
    }

    /**
     * Toggle REG0's LP_HIGH_HYS bit.
     *
     * Low Power High Hysteric Value
     */
    inline void toggle_REG0_LP_HIGH_HYS() volatile
    {
        REG0 ^= 1u << 21u;
    }

    /**
     * Get REG0's PWD_HIGH_VDD1P0_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P0
     */
    inline bool get_REG0_PWD_HIGH_VDD1P0_DET() volatile
    {
        return REG0 & (1u << 17u);
    }

    /**
     * Set REG0's PWD_HIGH_VDD1P0_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P0
     */
    inline void set_REG0_PWD_HIGH_VDD1P0_DET() volatile
    {
        REG0 |= 1u << 17u;
    }

    /**
     * Clear REG0's PWD_HIGH_VDD1P0_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P0
     */
    inline void clear_REG0_PWD_HIGH_VDD1P0_DET() volatile
    {
        REG0 &= ~(1u << 17u);
    }

    /**
     * Toggle REG0's PWD_HIGH_VDD1P0_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P0
     */
    inline void toggle_REG0_PWD_HIGH_VDD1P0_DET() volatile
    {
        REG0 ^= 1u << 17u;
    }

    /**
     * Get REG0's PWD_HIGH_VDD1P8_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P8
     */
    inline bool get_REG0_PWD_HIGH_VDD1P8_DET() volatile
    {
        return REG0 & (1u << 16u);
    }

    /**
     * Set REG0's PWD_HIGH_VDD1P8_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P8
     */
    inline void set_REG0_PWD_HIGH_VDD1P8_DET() volatile
    {
        REG0 |= 1u << 16u;
    }

    /**
     * Clear REG0's PWD_HIGH_VDD1P8_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P8
     */
    inline void clear_REG0_PWD_HIGH_VDD1P8_DET() volatile
    {
        REG0 &= ~(1u << 16u);
    }

    /**
     * Toggle REG0's PWD_HIGH_VDD1P8_DET bit.
     *
     * Power Down High Voltage Detection for VDD1P8
     */
    inline void toggle_REG0_PWD_HIGH_VDD1P8_DET() volatile
    {
        REG0 ^= 1u << 16u;
    }

    /**
     * Get REG0's PWD_CMP_DCDC_IN_DET bit.
     *
     * Set to "1" to power down the low voltage detection comparator
     */
    inline bool get_REG0_PWD_CMP_DCDC_IN_DET() volatile
    {
        return REG0 & (1u << 11u);
    }

    /**
     * Set REG0's PWD_CMP_DCDC_IN_DET bit.
     *
     * Set to "1" to power down the low voltage detection comparator
     */
    inline void set_REG0_PWD_CMP_DCDC_IN_DET() volatile
    {
        REG0 |= 1u << 11u;
    }

    /**
     * Clear REG0's PWD_CMP_DCDC_IN_DET bit.
     *
     * Set to "1" to power down the low voltage detection comparator
     */
    inline void clear_REG0_PWD_CMP_DCDC_IN_DET() volatile
    {
        REG0 &= ~(1u << 11u);
    }

    /**
     * Toggle REG0's PWD_CMP_DCDC_IN_DET bit.
     *
     * Set to "1" to power down the low voltage detection comparator
     */
    inline void toggle_REG0_PWD_CMP_DCDC_IN_DET() volatile
    {
        REG0 ^= 1u << 11u;
    }

    /**
     * Get REG0's PWD_OVERCUR_DET bit.
     *
     * Power down overcurrent detection comparator
     */
    inline bool get_REG0_PWD_OVERCUR_DET() volatile
    {
        return REG0 & (1u << 8u);
    }

    /**
     * Set REG0's PWD_OVERCUR_DET bit.
     *
     * Power down overcurrent detection comparator
     */
    inline void set_REG0_PWD_OVERCUR_DET() volatile
    {
        REG0 |= 1u << 8u;
    }

    /**
     * Clear REG0's PWD_OVERCUR_DET bit.
     *
     * Power down overcurrent detection comparator
     */
    inline void clear_REG0_PWD_OVERCUR_DET() volatile
    {
        REG0 &= ~(1u << 8u);
    }

    /**
     * Toggle REG0's PWD_OVERCUR_DET bit.
     *
     * Power down overcurrent detection comparator
     */
    inline void toggle_REG0_PWD_OVERCUR_DET() volatile
    {
        REG0 ^= 1u << 8u;
    }

    /**
     * Get REG0's CUR_SNS_THRSH field.
     *
     * Current Sense (detector) Threshold
     */
    inline uint8_t get_REG0_CUR_SNS_THRSH() volatile
    {
        return (REG0 >> 5u) & 0b111u;
    }

    /**
     * Set REG0's CUR_SNS_THRSH field.
     *
     * Current Sense (detector) Threshold
     */
    inline void set_REG0_CUR_SNS_THRSH(uint8_t value) volatile
    {
        uint32_t curr = REG0;

        curr &= ~(0b111u << 5u);
        curr |= (value & 0b111u) << 5u;

        REG0 = curr;
    }

    /**
     * Get REG0's PWD_CUR_SNS_CMP bit.
     *
     * Power down signal of the current detector
     */
    inline bool get_REG0_PWD_CUR_SNS_CMP() volatile
    {
        return REG0 & (1u << 4u);
    }

    /**
     * Set REG0's PWD_CUR_SNS_CMP bit.
     *
     * Power down signal of the current detector
     */
    inline void set_REG0_PWD_CUR_SNS_CMP() volatile
    {
        REG0 |= 1u << 4u;
    }

    /**
     * Clear REG0's PWD_CUR_SNS_CMP bit.
     *
     * Power down signal of the current detector
     */
    inline void clear_REG0_PWD_CUR_SNS_CMP() volatile
    {
        REG0 &= ~(1u << 4u);
    }

    /**
     * Toggle REG0's PWD_CUR_SNS_CMP bit.
     *
     * Power down signal of the current detector
     */
    inline void toggle_REG0_PWD_CUR_SNS_CMP() volatile
    {
        REG0 ^= 1u << 4u;
    }

    /**
     * Get REG0's PWD_OSC_INT bit.
     *
     * Power down internal ring oscillator
     */
    inline bool get_REG0_PWD_OSC_INT() volatile
    {
        return REG0 & (1u << 3u);
    }

    /**
     * Set REG0's PWD_OSC_INT bit.
     *
     * Power down internal ring oscillator
     */
    inline void set_REG0_PWD_OSC_INT() volatile
    {
        REG0 |= 1u << 3u;
    }

    /**
     * Clear REG0's PWD_OSC_INT bit.
     *
     * Power down internal ring oscillator
     */
    inline void clear_REG0_PWD_OSC_INT() volatile
    {
        REG0 &= ~(1u << 3u);
    }

    /**
     * Toggle REG0's PWD_OSC_INT bit.
     *
     * Power down internal ring oscillator
     */
    inline void toggle_REG0_PWD_OSC_INT() volatile
    {
        REG0 ^= 1u << 3u;
    }

    /**
     * Get REG0's SEL_CLK bit.
     *
     * Select Clock
     */
    inline bool get_REG0_SEL_CLK() volatile
    {
        return REG0 & (1u << 2u);
    }

    /**
     * Set REG0's SEL_CLK bit.
     *
     * Select Clock
     */
    inline void set_REG0_SEL_CLK() volatile
    {
        REG0 |= 1u << 2u;
    }

    /**
     * Clear REG0's SEL_CLK bit.
     *
     * Select Clock
     */
    inline void clear_REG0_SEL_CLK() volatile
    {
        REG0 &= ~(1u << 2u);
    }

    /**
     * Toggle REG0's SEL_CLK bit.
     *
     * Select Clock
     */
    inline void toggle_REG0_SEL_CLK() volatile
    {
        REG0 ^= 1u << 2u;
    }

    /**
     * Get REG0's DISABLE_AUTO_CLK_SWITCH bit.
     *
     * Disable Auto Clock Switch
     */
    inline bool get_REG0_DISABLE_AUTO_CLK_SWITCH() volatile
    {
        return REG0 & (1u << 1u);
    }

    /**
     * Set REG0's DISABLE_AUTO_CLK_SWITCH bit.
     *
     * Disable Auto Clock Switch
     */
    inline void set_REG0_DISABLE_AUTO_CLK_SWITCH() volatile
    {
        REG0 |= 1u << 1u;
    }

    /**
     * Clear REG0's DISABLE_AUTO_CLK_SWITCH bit.
     *
     * Disable Auto Clock Switch
     */
    inline void clear_REG0_DISABLE_AUTO_CLK_SWITCH() volatile
    {
        REG0 &= ~(1u << 1u);
    }

    /**
     * Toggle REG0's DISABLE_AUTO_CLK_SWITCH bit.
     *
     * Disable Auto Clock Switch
     */
    inline void toggle_REG0_DISABLE_AUTO_CLK_SWITCH() volatile
    {
        REG0 ^= 1u << 1u;
    }

    /**
     * Get REG0's PWD_ZCD bit.
     *
     * Power Down Zero Cross Detection
     */
    inline bool get_REG0_PWD_ZCD() volatile
    {
        return REG0 & (1u << 0u);
    }

    /**
     * Set REG0's PWD_ZCD bit.
     *
     * Power Down Zero Cross Detection
     */
    inline void set_REG0_PWD_ZCD() volatile
    {
        REG0 |= 1u << 0u;
    }

    /**
     * Clear REG0's PWD_ZCD bit.
     *
     * Power Down Zero Cross Detection
     */
    inline void clear_REG0_PWD_ZCD() volatile
    {
        REG0 &= ~(1u << 0u);
    }

    /**
     * Toggle REG0's PWD_ZCD bit.
     *
     * Power Down Zero Cross Detection
     */
    inline void toggle_REG0_PWD_ZCD() volatile
    {
        REG0 ^= 1u << 0u;
    }

    /**
     * Get all of REG0's bit fields.
     *
     * (read-write) DCDC Register 0
     */
    inline void get_REG0(bool &STS_DC_OK, bool &XTAL_24M_OK,
                         bool &XTALOK_DISABLE, bool &PWD_CMP_OFFSET,
                         bool &LP_HIGH_HYS, bool &PWD_HIGH_VDD1P0_DET,
                         bool &PWD_HIGH_VDD1P8_DET, bool &PWD_CMP_DCDC_IN_DET,
                         bool &PWD_OVERCUR_DET, uint8_t &CUR_SNS_THRSH,
                         bool &PWD_CUR_SNS_CMP, bool &PWD_OSC_INT,
                         bool &SEL_CLK, bool &DISABLE_AUTO_CLK_SWITCH,
                         bool &PWD_ZCD) volatile
    {
        uint32_t curr = REG0;

        STS_DC_OK = curr & (1u << 31u);
        XTAL_24M_OK = curr & (1u << 29u);
        XTALOK_DISABLE = curr & (1u << 27u);
        PWD_CMP_OFFSET = curr & (1u << 26u);
        LP_HIGH_HYS = curr & (1u << 21u);
        PWD_HIGH_VDD1P0_DET = curr & (1u << 17u);
        PWD_HIGH_VDD1P8_DET = curr & (1u << 16u);
        PWD_CMP_DCDC_IN_DET = curr & (1u << 11u);
        PWD_OVERCUR_DET = curr & (1u << 8u);
        CUR_SNS_THRSH = (curr >> 5u) & 0b111u;
        PWD_CUR_SNS_CMP = curr & (1u << 4u);
        PWD_OSC_INT = curr & (1u << 3u);
        SEL_CLK = curr & (1u << 2u);
        DISABLE_AUTO_CLK_SWITCH = curr & (1u << 1u);
        PWD_ZCD = curr & (1u << 0u);
    }

    /**
     * Set all of REG0's bit fields.
     *
     * (read-write) DCDC Register 0
     */
    inline void set_REG0(bool XTAL_24M_OK, bool XTALOK_DISABLE,
                         bool PWD_CMP_OFFSET, bool LP_HIGH_HYS,
                         bool PWD_HIGH_VDD1P0_DET, bool PWD_HIGH_VDD1P8_DET,
                         bool PWD_CMP_DCDC_IN_DET, bool PWD_OVERCUR_DET,
                         uint8_t CUR_SNS_THRSH, bool PWD_CUR_SNS_CMP,
                         bool PWD_OSC_INT, bool SEL_CLK,
                         bool DISABLE_AUTO_CLK_SWITCH, bool PWD_ZCD) volatile
    {
        uint32_t curr = REG0;

        curr &= ~(0b1u << 29u);
        curr |= (XTAL_24M_OK & 0b1u) << 29u;
        curr &= ~(0b1u << 27u);
        curr |= (XTALOK_DISABLE & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (PWD_CMP_OFFSET & 0b1u) << 26u;
        curr &= ~(0b1u << 21u);
        curr |= (LP_HIGH_HYS & 0b1u) << 21u;
        curr &= ~(0b1u << 17u);
        curr |= (PWD_HIGH_VDD1P0_DET & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (PWD_HIGH_VDD1P8_DET & 0b1u) << 16u;
        curr &= ~(0b1u << 11u);
        curr |= (PWD_CMP_DCDC_IN_DET & 0b1u) << 11u;
        curr &= ~(0b1u << 8u);
        curr |= (PWD_OVERCUR_DET & 0b1u) << 8u;
        curr &= ~(0b111u << 5u);
        curr |= (CUR_SNS_THRSH & 0b111u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (PWD_CUR_SNS_CMP & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PWD_OSC_INT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SEL_CLK & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DISABLE_AUTO_CLK_SWITCH & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PWD_ZCD & 0b1u) << 0u;

        REG0 = curr;
    }

    /**
     * Get REG1's LOOPCTRL_EN_DF_HYST bit.
     *
     * Enable hysteresis in switching converter differential mode analog
     * comparators
     */
    inline bool get_REG1_LOOPCTRL_EN_DF_HYST() volatile
    {
        return REG1 & (1u << 30u);
    }

    /**
     * Set REG1's LOOPCTRL_EN_DF_HYST bit.
     *
     * Enable hysteresis in switching converter differential mode analog
     * comparators
     */
    inline void set_REG1_LOOPCTRL_EN_DF_HYST() volatile
    {
        REG1 |= 1u << 30u;
    }

    /**
     * Clear REG1's LOOPCTRL_EN_DF_HYST bit.
     *
     * Enable hysteresis in switching converter differential mode analog
     * comparators
     */
    inline void clear_REG1_LOOPCTRL_EN_DF_HYST() volatile
    {
        REG1 &= ~(1u << 30u);
    }

    /**
     * Toggle REG1's LOOPCTRL_EN_DF_HYST bit.
     *
     * Enable hysteresis in switching converter differential mode analog
     * comparators
     */
    inline void toggle_REG1_LOOPCTRL_EN_DF_HYST() volatile
    {
        REG1 ^= 1u << 30u;
    }

    /**
     * Get REG1's LOOPCTRL_EN_CM_HYST bit.
     *
     * Enable hysteresis in switching converter common mode analog comparators
     */
    inline bool get_REG1_LOOPCTRL_EN_CM_HYST() volatile
    {
        return REG1 & (1u << 29u);
    }

    /**
     * Set REG1's LOOPCTRL_EN_CM_HYST bit.
     *
     * Enable hysteresis in switching converter common mode analog comparators
     */
    inline void set_REG1_LOOPCTRL_EN_CM_HYST() volatile
    {
        REG1 |= 1u << 29u;
    }

    /**
     * Clear REG1's LOOPCTRL_EN_CM_HYST bit.
     *
     * Enable hysteresis in switching converter common mode analog comparators
     */
    inline void clear_REG1_LOOPCTRL_EN_CM_HYST() volatile
    {
        REG1 &= ~(1u << 29u);
    }

    /**
     * Toggle REG1's LOOPCTRL_EN_CM_HYST bit.
     *
     * Enable hysteresis in switching converter common mode analog comparators
     */
    inline void toggle_REG1_LOOPCTRL_EN_CM_HYST() volatile
    {
        REG1 ^= 1u << 29u;
    }

    /**
     * Get REG1's LOOPCTRL_DF_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline bool get_REG1_LOOPCTRL_DF_HST_THRESH() volatile
    {
        return REG1 & (1u << 28u);
    }

    /**
     * Set REG1's LOOPCTRL_DF_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline void set_REG1_LOOPCTRL_DF_HST_THRESH() volatile
    {
        REG1 |= 1u << 28u;
    }

    /**
     * Clear REG1's LOOPCTRL_DF_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline void clear_REG1_LOOPCTRL_DF_HST_THRESH() volatile
    {
        REG1 &= ~(1u << 28u);
    }

    /**
     * Toggle REG1's LOOPCTRL_DF_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline void toggle_REG1_LOOPCTRL_DF_HST_THRESH() volatile
    {
        REG1 ^= 1u << 28u;
    }

    /**
     * Get REG1's LOOPCTRL_CM_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline bool get_REG1_LOOPCTRL_CM_HST_THRESH() volatile
    {
        return REG1 & (1u << 27u);
    }

    /**
     * Set REG1's LOOPCTRL_CM_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline void set_REG1_LOOPCTRL_CM_HST_THRESH() volatile
    {
        REG1 |= 1u << 27u;
    }

    /**
     * Clear REG1's LOOPCTRL_CM_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline void clear_REG1_LOOPCTRL_CM_HST_THRESH() volatile
    {
        REG1 &= ~(1u << 27u);
    }

    /**
     * Toggle REG1's LOOPCTRL_CM_HST_THRESH bit.
     *
     * Increase Threshold Detection
     */
    inline void toggle_REG1_LOOPCTRL_CM_HST_THRESH() volatile
    {
        REG1 ^= 1u << 27u;
    }

    /**
     * Get REG1's LP_CMP_ISRC_SEL field.
     *
     * Low Power Comparator Current Bias
     */
    inline DCDC_REG1_LP_CMP_ISRC_SEL get_REG1_LP_CMP_ISRC_SEL() volatile
    {
        return DCDC_REG1_LP_CMP_ISRC_SEL((REG1 >> 11u) & 0b11u);
    }

    /**
     * Set REG1's LP_CMP_ISRC_SEL field.
     *
     * Low Power Comparator Current Bias
     */
    inline void set_REG1_LP_CMP_ISRC_SEL(
        DCDC_REG1_LP_CMP_ISRC_SEL value) volatile
    {
        uint32_t curr = REG1;

        curr &= ~(0b11u << 11u);
        curr |= (std::to_underlying(value) & 0b11u) << 11u;

        REG1 = curr;
    }

    /**
     * Get REG1's VBG_TRIM field.
     *
     * Trim Bandgap Voltage
     */
    inline DCDC_REG1_VBG_TRIM get_REG1_VBG_TRIM() volatile
    {
        return DCDC_REG1_VBG_TRIM((REG1 >> 6u) & 0b11111u);
    }

    /**
     * Set REG1's VBG_TRIM field.
     *
     * Trim Bandgap Voltage
     */
    inline void set_REG1_VBG_TRIM(DCDC_REG1_VBG_TRIM value) volatile
    {
        uint32_t curr = REG1;

        curr &= ~(0b11111u << 6u);
        curr |= (std::to_underlying(value) & 0b11111u) << 6u;

        REG1 = curr;
    }

    /**
     * Get REG1's RLOAD_REG_EN_LPSR bit.
     *
     * Load Resistor Enable
     */
    inline bool get_REG1_RLOAD_REG_EN_LPSR() volatile
    {
        return REG1 & (1u << 4u);
    }

    /**
     * Set REG1's RLOAD_REG_EN_LPSR bit.
     *
     * Load Resistor Enable
     */
    inline void set_REG1_RLOAD_REG_EN_LPSR() volatile
    {
        REG1 |= 1u << 4u;
    }

    /**
     * Clear REG1's RLOAD_REG_EN_LPSR bit.
     *
     * Load Resistor Enable
     */
    inline void clear_REG1_RLOAD_REG_EN_LPSR() volatile
    {
        REG1 &= ~(1u << 4u);
    }

    /**
     * Toggle REG1's RLOAD_REG_EN_LPSR bit.
     *
     * Load Resistor Enable
     */
    inline void toggle_REG1_RLOAD_REG_EN_LPSR() volatile
    {
        REG1 ^= 1u << 4u;
    }

    /**
     * Get REG1's DM_CTRL bit.
     *
     * DM Control
     */
    inline bool get_REG1_DM_CTRL() volatile
    {
        return REG1 & (1u << 3u);
    }

    /**
     * Set REG1's DM_CTRL bit.
     *
     * DM Control
     */
    inline void set_REG1_DM_CTRL() volatile
    {
        REG1 |= 1u << 3u;
    }

    /**
     * Clear REG1's DM_CTRL bit.
     *
     * DM Control
     */
    inline void clear_REG1_DM_CTRL() volatile
    {
        REG1 &= ~(1u << 3u);
    }

    /**
     * Toggle REG1's DM_CTRL bit.
     *
     * DM Control
     */
    inline void toggle_REG1_DM_CTRL() volatile
    {
        REG1 ^= 1u << 3u;
    }

    /**
     * Get all of REG1's bit fields.
     *
     * (read-write) DCDC Register 1
     */
    inline void get_REG1(bool &LOOPCTRL_EN_DF_HYST, bool &LOOPCTRL_EN_CM_HYST,
                         bool &LOOPCTRL_DF_HST_THRESH,
                         bool &LOOPCTRL_CM_HST_THRESH,
                         DCDC_REG1_LP_CMP_ISRC_SEL &LP_CMP_ISRC_SEL,
                         DCDC_REG1_VBG_TRIM &VBG_TRIM, bool &RLOAD_REG_EN_LPSR,
                         bool &DM_CTRL) volatile
    {
        uint32_t curr = REG1;

        LOOPCTRL_EN_DF_HYST = curr & (1u << 30u);
        LOOPCTRL_EN_CM_HYST = curr & (1u << 29u);
        LOOPCTRL_DF_HST_THRESH = curr & (1u << 28u);
        LOOPCTRL_CM_HST_THRESH = curr & (1u << 27u);
        LP_CMP_ISRC_SEL = DCDC_REG1_LP_CMP_ISRC_SEL((curr >> 11u) & 0b11u);
        VBG_TRIM = DCDC_REG1_VBG_TRIM((curr >> 6u) & 0b11111u);
        RLOAD_REG_EN_LPSR = curr & (1u << 4u);
        DM_CTRL = curr & (1u << 3u);
    }

    /**
     * Set all of REG1's bit fields.
     *
     * (read-write) DCDC Register 1
     */
    inline void set_REG1(bool LOOPCTRL_EN_DF_HYST, bool LOOPCTRL_EN_CM_HYST,
                         bool LOOPCTRL_DF_HST_THRESH,
                         bool LOOPCTRL_CM_HST_THRESH,
                         DCDC_REG1_LP_CMP_ISRC_SEL LP_CMP_ISRC_SEL,
                         DCDC_REG1_VBG_TRIM VBG_TRIM, bool RLOAD_REG_EN_LPSR,
                         bool DM_CTRL) volatile
    {
        uint32_t curr = REG1;

        curr &= ~(0b1u << 30u);
        curr |= (LOOPCTRL_EN_DF_HYST & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (LOOPCTRL_EN_CM_HYST & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (LOOPCTRL_DF_HST_THRESH & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (LOOPCTRL_CM_HST_THRESH & 0b1u) << 27u;
        curr &= ~(0b11u << 11u);
        curr |= (std::to_underlying(LP_CMP_ISRC_SEL) & 0b11u) << 11u;
        curr &= ~(0b11111u << 6u);
        curr |= (std::to_underlying(VBG_TRIM) & 0b11111u) << 6u;
        curr &= ~(0b1u << 4u);
        curr |= (RLOAD_REG_EN_LPSR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DM_CTRL & 0b1u) << 3u;

        REG1 = curr;
    }

    /**
     * Get REG2's LOOPCTRL_TOGGLE_DIF bit.
     *
     * Set high to enable supply stepping to change only after the differential
     * control loop has toggled as well
     */
    inline bool get_REG2_LOOPCTRL_TOGGLE_DIF() volatile
    {
        return REG2 & (1u << 30u);
    }

    /**
     * Set REG2's LOOPCTRL_TOGGLE_DIF bit.
     *
     * Set high to enable supply stepping to change only after the differential
     * control loop has toggled as well
     */
    inline void set_REG2_LOOPCTRL_TOGGLE_DIF() volatile
    {
        REG2 |= 1u << 30u;
    }

    /**
     * Clear REG2's LOOPCTRL_TOGGLE_DIF bit.
     *
     * Set high to enable supply stepping to change only after the differential
     * control loop has toggled as well
     */
    inline void clear_REG2_LOOPCTRL_TOGGLE_DIF() volatile
    {
        REG2 &= ~(1u << 30u);
    }

    /**
     * Toggle REG2's LOOPCTRL_TOGGLE_DIF bit.
     *
     * Set high to enable supply stepping to change only after the differential
     * control loop has toggled as well
     */
    inline void toggle_REG2_LOOPCTRL_TOGGLE_DIF() volatile
    {
        REG2 ^= 1u << 30u;
    }

    /**
     * Get REG2's DCM_SET_CTRL bit.
     *
     * DCM Set Control
     */
    inline bool get_REG2_DCM_SET_CTRL() volatile
    {
        return REG2 & (1u << 28u);
    }

    /**
     * Set REG2's DCM_SET_CTRL bit.
     *
     * DCM Set Control
     */
    inline void set_REG2_DCM_SET_CTRL() volatile
    {
        REG2 |= 1u << 28u;
    }

    /**
     * Clear REG2's DCM_SET_CTRL bit.
     *
     * DCM Set Control
     */
    inline void clear_REG2_DCM_SET_CTRL() volatile
    {
        REG2 &= ~(1u << 28u);
    }

    /**
     * Toggle REG2's DCM_SET_CTRL bit.
     *
     * DCM Set Control
     */
    inline void toggle_REG2_DCM_SET_CTRL() volatile
    {
        REG2 ^= 1u << 28u;
    }

    /**
     * Get REG2's BATTMONITOR_BATT_VAL field.
     *
     * Software should be configured to place the battery voltage in this
     * register measured with an 8-mV LSB resolution through the ADC
     */
    inline uint16_t get_REG2_BATTMONITOR_BATT_VAL() volatile
    {
        return (REG2 >> 16u) & 0b1111111111u;
    }

    /**
     * Set REG2's BATTMONITOR_BATT_VAL field.
     *
     * Software should be configured to place the battery voltage in this
     * register measured with an 8-mV LSB resolution through the ADC
     */
    inline void set_REG2_BATTMONITOR_BATT_VAL(uint16_t value) volatile
    {
        uint32_t curr = REG2;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        REG2 = curr;
    }

    /**
     * Get REG2's BATTMONITOR_EN_BATADJ bit.
     *
     * This bit enables the DCDC to improve efficiency and minimize ripple
     * using the information from the BATT_VAL field
     */
    inline bool get_REG2_BATTMONITOR_EN_BATADJ() volatile
    {
        return REG2 & (1u << 15u);
    }

    /**
     * Set REG2's BATTMONITOR_EN_BATADJ bit.
     *
     * This bit enables the DCDC to improve efficiency and minimize ripple
     * using the information from the BATT_VAL field
     */
    inline void set_REG2_BATTMONITOR_EN_BATADJ() volatile
    {
        REG2 |= 1u << 15u;
    }

    /**
     * Clear REG2's BATTMONITOR_EN_BATADJ bit.
     *
     * This bit enables the DCDC to improve efficiency and minimize ripple
     * using the information from the BATT_VAL field
     */
    inline void clear_REG2_BATTMONITOR_EN_BATADJ() volatile
    {
        REG2 &= ~(1u << 15u);
    }

    /**
     * Toggle REG2's BATTMONITOR_EN_BATADJ bit.
     *
     * This bit enables the DCDC to improve efficiency and minimize ripple
     * using the information from the BATT_VAL field
     */
    inline void toggle_REG2_BATTMONITOR_EN_BATADJ() volatile
    {
        REG2 ^= 1u << 15u;
    }

    /**
     * Get REG2's LOOPCTRL_HYST_SIGN bit.
     *
     * Invert the sign of the hysteresis in DCDC analog comparators.
     */
    inline bool get_REG2_LOOPCTRL_HYST_SIGN() volatile
    {
        return REG2 & (1u << 13u);
    }

    /**
     * Set REG2's LOOPCTRL_HYST_SIGN bit.
     *
     * Invert the sign of the hysteresis in DCDC analog comparators.
     */
    inline void set_REG2_LOOPCTRL_HYST_SIGN() volatile
    {
        REG2 |= 1u << 13u;
    }

    /**
     * Clear REG2's LOOPCTRL_HYST_SIGN bit.
     *
     * Invert the sign of the hysteresis in DCDC analog comparators.
     */
    inline void clear_REG2_LOOPCTRL_HYST_SIGN() volatile
    {
        REG2 &= ~(1u << 13u);
    }

    /**
     * Toggle REG2's LOOPCTRL_HYST_SIGN bit.
     *
     * Invert the sign of the hysteresis in DCDC analog comparators.
     */
    inline void toggle_REG2_LOOPCTRL_HYST_SIGN() volatile
    {
        REG2 ^= 1u << 13u;
    }

    /**
     * Get REG2's LOOPCTRL_RCSCALE_THRSH bit.
     *
     * Increase the threshold detection for RC scale circuit.
     */
    inline bool get_REG2_LOOPCTRL_RCSCALE_THRSH() volatile
    {
        return REG2 & (1u << 12u);
    }

    /**
     * Set REG2's LOOPCTRL_RCSCALE_THRSH bit.
     *
     * Increase the threshold detection for RC scale circuit.
     */
    inline void set_REG2_LOOPCTRL_RCSCALE_THRSH() volatile
    {
        REG2 |= 1u << 12u;
    }

    /**
     * Clear REG2's LOOPCTRL_RCSCALE_THRSH bit.
     *
     * Increase the threshold detection for RC scale circuit.
     */
    inline void clear_REG2_LOOPCTRL_RCSCALE_THRSH() volatile
    {
        REG2 &= ~(1u << 12u);
    }

    /**
     * Toggle REG2's LOOPCTRL_RCSCALE_THRSH bit.
     *
     * Increase the threshold detection for RC scale circuit.
     */
    inline void toggle_REG2_LOOPCTRL_RCSCALE_THRSH() volatile
    {
        REG2 ^= 1u << 12u;
    }

    /**
     * Get REG2's LOOPCTRL_EN_RCSCALE field.
     *
     * Enable RC Scale
     */
    inline uint8_t get_REG2_LOOPCTRL_EN_RCSCALE() volatile
    {
        return (REG2 >> 9u) & 0b111u;
    }

    /**
     * Set REG2's LOOPCTRL_EN_RCSCALE field.
     *
     * Enable RC Scale
     */
    inline void set_REG2_LOOPCTRL_EN_RCSCALE(uint8_t value) volatile
    {
        uint32_t curr = REG2;

        curr &= ~(0b111u << 9u);
        curr |= (value & 0b111u) << 9u;

        REG2 = curr;
    }

    /**
     * Get REG2's LOOPCTRL_DC_FF field.
     *
     * Two's complement feed forward step in duty cycle in the switching DCDC
     * converter
     */
    inline uint8_t get_REG2_LOOPCTRL_DC_FF() volatile
    {
        return (REG2 >> 6u) & 0b111u;
    }

    /**
     * Set REG2's LOOPCTRL_DC_FF field.
     *
     * Two's complement feed forward step in duty cycle in the switching DCDC
     * converter
     */
    inline void set_REG2_LOOPCTRL_DC_FF(uint8_t value) volatile
    {
        uint32_t curr = REG2;

        curr &= ~(0b111u << 6u);
        curr |= (value & 0b111u) << 6u;

        REG2 = curr;
    }

    /**
     * Get REG2's LOOPCTRL_DC_R field.
     *
     * Magnitude of proportional control parameter in the switching DCDC
     * converter control loop.
     */
    inline uint8_t get_REG2_LOOPCTRL_DC_R() volatile
    {
        return (REG2 >> 2u) & 0b1111u;
    }

    /**
     * Set REG2's LOOPCTRL_DC_R field.
     *
     * Magnitude of proportional control parameter in the switching DCDC
     * converter control loop.
     */
    inline void set_REG2_LOOPCTRL_DC_R(uint8_t value) volatile
    {
        uint32_t curr = REG2;

        curr &= ~(0b1111u << 2u);
        curr |= (value & 0b1111u) << 2u;

        REG2 = curr;
    }

    /**
     * Get REG2's LOOPCTRL_DC_C field.
     *
     * Ratio of integral control parameter to proportional control parameter in
     * the switching DCDC converter, and can be used to optimize efficiency and
     * loop response
     */
    inline uint8_t get_REG2_LOOPCTRL_DC_C() volatile
    {
        return (REG2 >> 0u) & 0b11u;
    }

    /**
     * Set REG2's LOOPCTRL_DC_C field.
     *
     * Ratio of integral control parameter to proportional control parameter in
     * the switching DCDC converter, and can be used to optimize efficiency and
     * loop response
     */
    inline void set_REG2_LOOPCTRL_DC_C(uint8_t value) volatile
    {
        uint32_t curr = REG2;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        REG2 = curr;
    }

    /**
     * Get all of REG2's bit fields.
     *
     * (read-write) DCDC Register 2
     */
    inline void get_REG2(bool &LOOPCTRL_TOGGLE_DIF, bool &DCM_SET_CTRL,
                         uint16_t &BATTMONITOR_BATT_VAL,
                         bool &BATTMONITOR_EN_BATADJ, bool &LOOPCTRL_HYST_SIGN,
                         bool &LOOPCTRL_RCSCALE_THRSH,
                         uint8_t &LOOPCTRL_EN_RCSCALE, uint8_t &LOOPCTRL_DC_FF,
                         uint8_t &LOOPCTRL_DC_R,
                         uint8_t &LOOPCTRL_DC_C) volatile
    {
        uint32_t curr = REG2;

        LOOPCTRL_TOGGLE_DIF = curr & (1u << 30u);
        DCM_SET_CTRL = curr & (1u << 28u);
        BATTMONITOR_BATT_VAL = (curr >> 16u) & 0b1111111111u;
        BATTMONITOR_EN_BATADJ = curr & (1u << 15u);
        LOOPCTRL_HYST_SIGN = curr & (1u << 13u);
        LOOPCTRL_RCSCALE_THRSH = curr & (1u << 12u);
        LOOPCTRL_EN_RCSCALE = (curr >> 9u) & 0b111u;
        LOOPCTRL_DC_FF = (curr >> 6u) & 0b111u;
        LOOPCTRL_DC_R = (curr >> 2u) & 0b1111u;
        LOOPCTRL_DC_C = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of REG2's bit fields.
     *
     * (read-write) DCDC Register 2
     */
    inline void set_REG2(bool LOOPCTRL_TOGGLE_DIF, bool DCM_SET_CTRL,
                         uint16_t BATTMONITOR_BATT_VAL,
                         bool BATTMONITOR_EN_BATADJ, bool LOOPCTRL_HYST_SIGN,
                         bool LOOPCTRL_RCSCALE_THRSH,
                         uint8_t LOOPCTRL_EN_RCSCALE, uint8_t LOOPCTRL_DC_FF,
                         uint8_t LOOPCTRL_DC_R, uint8_t LOOPCTRL_DC_C) volatile
    {
        uint32_t curr = REG2;

        curr &= ~(0b1u << 30u);
        curr |= (LOOPCTRL_TOGGLE_DIF & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (DCM_SET_CTRL & 0b1u) << 28u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (BATTMONITOR_BATT_VAL & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (BATTMONITOR_EN_BATADJ & 0b1u) << 15u;
        curr &= ~(0b1u << 13u);
        curr |= (LOOPCTRL_HYST_SIGN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (LOOPCTRL_RCSCALE_THRSH & 0b1u) << 12u;
        curr &= ~(0b111u << 9u);
        curr |= (LOOPCTRL_EN_RCSCALE & 0b111u) << 9u;
        curr &= ~(0b111u << 6u);
        curr |= (LOOPCTRL_DC_FF & 0b111u) << 6u;
        curr &= ~(0b1111u << 2u);
        curr |= (LOOPCTRL_DC_R & 0b1111u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (LOOPCTRL_DC_C & 0b11u) << 0u;

        REG2 = curr;
    }

    /**
     * Get REG3's VDD1P8CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P8
     */
    inline bool get_REG3_VDD1P8CTRL_DISABLE_STEP() volatile
    {
        return REG3 & (1u << 30u);
    }

    /**
     * Set REG3's VDD1P8CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P8
     */
    inline void set_REG3_VDD1P8CTRL_DISABLE_STEP() volatile
    {
        REG3 |= 1u << 30u;
    }

    /**
     * Clear REG3's VDD1P8CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P8
     */
    inline void clear_REG3_VDD1P8CTRL_DISABLE_STEP() volatile
    {
        REG3 &= ~(1u << 30u);
    }

    /**
     * Toggle REG3's VDD1P8CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P8
     */
    inline void toggle_REG3_VDD1P8CTRL_DISABLE_STEP() volatile
    {
        REG3 ^= 1u << 30u;
    }

    /**
     * Get REG3's VDD1P0CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P0
     */
    inline bool get_REG3_VDD1P0CTRL_DISABLE_STEP() volatile
    {
        return REG3 & (1u << 29u);
    }

    /**
     * Set REG3's VDD1P0CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P0
     */
    inline void set_REG3_VDD1P0CTRL_DISABLE_STEP() volatile
    {
        REG3 |= 1u << 29u;
    }

    /**
     * Clear REG3's VDD1P0CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P0
     */
    inline void clear_REG3_VDD1P0CTRL_DISABLE_STEP() volatile
    {
        REG3 &= ~(1u << 29u);
    }

    /**
     * Toggle REG3's VDD1P0CTRL_DISABLE_STEP bit.
     *
     * Disable Step for VDD1P0
     */
    inline void toggle_REG3_VDD1P0CTRL_DISABLE_STEP() volatile
    {
        REG3 ^= 1u << 29u;
    }

    /**
     * Get REG3's MISC_DELAY_TIMING bit.
     *
     * Miscellaneous Delay Timing
     */
    inline bool get_REG3_MISC_DELAY_TIMING() volatile
    {
        return REG3 & (1u << 27u);
    }

    /**
     * Set REG3's MISC_DELAY_TIMING bit.
     *
     * Miscellaneous Delay Timing
     */
    inline void set_REG3_MISC_DELAY_TIMING() volatile
    {
        REG3 |= 1u << 27u;
    }

    /**
     * Clear REG3's MISC_DELAY_TIMING bit.
     *
     * Miscellaneous Delay Timing
     */
    inline void clear_REG3_MISC_DELAY_TIMING() volatile
    {
        REG3 &= ~(1u << 27u);
    }

    /**
     * Toggle REG3's MISC_DELAY_TIMING bit.
     *
     * Miscellaneous Delay Timing
     */
    inline void toggle_REG3_MISC_DELAY_TIMING() volatile
    {
        REG3 ^= 1u << 27u;
    }

    /**
     * Get REG3's MINPWR_HALF_FETS bit.
     *
     * Use half switch FET
     */
    inline bool get_REG3_MINPWR_HALF_FETS() volatile
    {
        return REG3 & (1u << 26u);
    }

    /**
     * Set REG3's MINPWR_HALF_FETS bit.
     *
     * Use half switch FET
     */
    inline void set_REG3_MINPWR_HALF_FETS() volatile
    {
        REG3 |= 1u << 26u;
    }

    /**
     * Clear REG3's MINPWR_HALF_FETS bit.
     *
     * Use half switch FET
     */
    inline void clear_REG3_MINPWR_HALF_FETS() volatile
    {
        REG3 &= ~(1u << 26u);
    }

    /**
     * Toggle REG3's MINPWR_HALF_FETS bit.
     *
     * Use half switch FET
     */
    inline void toggle_REG3_MINPWR_HALF_FETS() volatile
    {
        REG3 ^= 1u << 26u;
    }

    /**
     * Get REG3's MINPWR_DC_HALFCLK bit.
     *
     * Set DCDC clock to half freqeuncy for continuous mode.
     */
    inline bool get_REG3_MINPWR_DC_HALFCLK() volatile
    {
        return REG3 & (1u << 24u);
    }

    /**
     * Set REG3's MINPWR_DC_HALFCLK bit.
     *
     * Set DCDC clock to half freqeuncy for continuous mode.
     */
    inline void set_REG3_MINPWR_DC_HALFCLK() volatile
    {
        REG3 |= 1u << 24u;
    }

    /**
     * Clear REG3's MINPWR_DC_HALFCLK bit.
     *
     * Set DCDC clock to half freqeuncy for continuous mode.
     */
    inline void clear_REG3_MINPWR_DC_HALFCLK() volatile
    {
        REG3 &= ~(1u << 24u);
    }

    /**
     * Toggle REG3's MINPWR_DC_HALFCLK bit.
     *
     * Set DCDC clock to half freqeuncy for continuous mode.
     */
    inline void toggle_REG3_MINPWR_DC_HALFCLK() volatile
    {
        REG3 ^= 1u << 24u;
    }

    /**
     * Get REG3's REG_FBK_SEL field.
     *
     * Select the feedback point of the internal regulator
     */
    inline uint8_t get_REG3_REG_FBK_SEL() volatile
    {
        return (REG3 >> 22u) & 0b11u;
    }

    /**
     * Set REG3's REG_FBK_SEL field.
     *
     * Select the feedback point of the internal regulator
     */
    inline void set_REG3_REG_FBK_SEL(uint8_t value) volatile
    {
        uint32_t curr = REG3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        REG3 = curr;
    }

    /**
     * Get REG3's DOUBLE_IBIAS_CMP_LP_LPSR bit.
     *
     * no description available
     */
    inline bool get_REG3_DOUBLE_IBIAS_CMP_LP_LPSR() volatile
    {
        return REG3 & (1u << 21u);
    }

    /**
     * Set REG3's DOUBLE_IBIAS_CMP_LP_LPSR bit.
     *
     * no description available
     */
    inline void set_REG3_DOUBLE_IBIAS_CMP_LP_LPSR() volatile
    {
        REG3 |= 1u << 21u;
    }

    /**
     * Clear REG3's DOUBLE_IBIAS_CMP_LP_LPSR bit.
     *
     * no description available
     */
    inline void clear_REG3_DOUBLE_IBIAS_CMP_LP_LPSR() volatile
    {
        REG3 &= ~(1u << 21u);
    }

    /**
     * Toggle REG3's DOUBLE_IBIAS_CMP_LP_LPSR bit.
     *
     * no description available
     */
    inline void toggle_REG3_DOUBLE_IBIAS_CMP_LP_LPSR() volatile
    {
        REG3 ^= 1u << 21u;
    }

    /**
     * Get REG3's DISABLE_IDLE_SKIP bit.
     *
     * no description available
     */
    inline bool get_REG3_DISABLE_IDLE_SKIP() volatile
    {
        return REG3 & (1u << 20u);
    }

    /**
     * Set REG3's DISABLE_IDLE_SKIP bit.
     *
     * no description available
     */
    inline void set_REG3_DISABLE_IDLE_SKIP() volatile
    {
        REG3 |= 1u << 20u;
    }

    /**
     * Clear REG3's DISABLE_IDLE_SKIP bit.
     *
     * no description available
     */
    inline void clear_REG3_DISABLE_IDLE_SKIP() volatile
    {
        REG3 &= ~(1u << 20u);
    }

    /**
     * Toggle REG3's DISABLE_IDLE_SKIP bit.
     *
     * no description available
     */
    inline void toggle_REG3_DISABLE_IDLE_SKIP() volatile
    {
        REG3 ^= 1u << 20u;
    }

    /**
     * Get REG3's DISABLE_PULSE_SKIP bit.
     *
     * Disable Pulse Skip
     */
    inline bool get_REG3_DISABLE_PULSE_SKIP() volatile
    {
        return REG3 & (1u << 19u);
    }

    /**
     * Set REG3's DISABLE_PULSE_SKIP bit.
     *
     * Disable Pulse Skip
     */
    inline void set_REG3_DISABLE_PULSE_SKIP() volatile
    {
        REG3 |= 1u << 19u;
    }

    /**
     * Clear REG3's DISABLE_PULSE_SKIP bit.
     *
     * Disable Pulse Skip
     */
    inline void clear_REG3_DISABLE_PULSE_SKIP() volatile
    {
        REG3 &= ~(1u << 19u);
    }

    /**
     * Toggle REG3's DISABLE_PULSE_SKIP bit.
     *
     * Disable Pulse Skip
     */
    inline void toggle_REG3_DISABLE_PULSE_SKIP() volatile
    {
        REG3 ^= 1u << 19u;
    }

    /**
     * Get REG3's ENABLE_FF bit.
     *
     * no description available
     */
    inline bool get_REG3_ENABLE_FF() volatile
    {
        return REG3 & (1u << 18u);
    }

    /**
     * Set REG3's ENABLE_FF bit.
     *
     * no description available
     */
    inline void set_REG3_ENABLE_FF() volatile
    {
        REG3 |= 1u << 18u;
    }

    /**
     * Clear REG3's ENABLE_FF bit.
     *
     * no description available
     */
    inline void clear_REG3_ENABLE_FF() volatile
    {
        REG3 &= ~(1u << 18u);
    }

    /**
     * Toggle REG3's ENABLE_FF bit.
     *
     * no description available
     */
    inline void toggle_REG3_ENABLE_FF() volatile
    {
        REG3 ^= 1u << 18u;
    }

    /**
     * Get REG3's OVERCUR_DETECT_OUT bit.
     *
     * signal "1" when overcurrent happens.
     */
    inline bool get_REG3_OVERCUR_DETECT_OUT() volatile
    {
        return REG3 & (1u << 17u);
    }

    /**
     * Get REG3's OVERVOLT_VDD1P0_DET_OUT bit.
     *
     * signal "1" when overvoltage on the VDD1P0 output happens
     */
    inline bool get_REG3_OVERVOLT_VDD1P0_DET_OUT() volatile
    {
        return REG3 & (1u << 16u);
    }

    /**
     * Get REG3's OVERVOLT_VDD1P8_DET_OUT bit.
     *
     * signal "1" when overvoltage on the VDD1P8 output happens
     */
    inline bool get_REG3_OVERVOLT_VDD1P8_DET_OUT() volatile
    {
        return REG3 & (1u << 15u);
    }

    /**
     * Get REG3's IN_BROWNOUT bit.
     *
     * signal "1" when the voltage on DCDC_IN is lower than 2.6V
     */
    inline bool get_REG3_IN_BROWNOUT() volatile
    {
        return REG3 & (1u << 14u);
    }

    /**
     * Get all of REG3's bit fields.
     *
     * (read-write) DCDC Register 3
     */
    inline void get_REG3(bool &VDD1P8CTRL_DISABLE_STEP,
                         bool &VDD1P0CTRL_DISABLE_STEP,
                         bool &MISC_DELAY_TIMING, bool &MINPWR_HALF_FETS,
                         bool &MINPWR_DC_HALFCLK, uint8_t &REG_FBK_SEL,
                         bool &DOUBLE_IBIAS_CMP_LP_LPSR,
                         bool &DISABLE_IDLE_SKIP, bool &DISABLE_PULSE_SKIP,
                         bool &ENABLE_FF, bool &OVERCUR_DETECT_OUT,
                         bool &OVERVOLT_VDD1P0_DET_OUT,
                         bool &OVERVOLT_VDD1P8_DET_OUT,
                         bool &IN_BROWNOUT) volatile
    {
        uint32_t curr = REG3;

        VDD1P8CTRL_DISABLE_STEP = curr & (1u << 30u);
        VDD1P0CTRL_DISABLE_STEP = curr & (1u << 29u);
        MISC_DELAY_TIMING = curr & (1u << 27u);
        MINPWR_HALF_FETS = curr & (1u << 26u);
        MINPWR_DC_HALFCLK = curr & (1u << 24u);
        REG_FBK_SEL = (curr >> 22u) & 0b11u;
        DOUBLE_IBIAS_CMP_LP_LPSR = curr & (1u << 21u);
        DISABLE_IDLE_SKIP = curr & (1u << 20u);
        DISABLE_PULSE_SKIP = curr & (1u << 19u);
        ENABLE_FF = curr & (1u << 18u);
        OVERCUR_DETECT_OUT = curr & (1u << 17u);
        OVERVOLT_VDD1P0_DET_OUT = curr & (1u << 16u);
        OVERVOLT_VDD1P8_DET_OUT = curr & (1u << 15u);
        IN_BROWNOUT = curr & (1u << 14u);
    }

    /**
     * Set all of REG3's bit fields.
     *
     * (read-write) DCDC Register 3
     */
    inline void set_REG3(bool VDD1P8CTRL_DISABLE_STEP,
                         bool VDD1P0CTRL_DISABLE_STEP, bool MISC_DELAY_TIMING,
                         bool MINPWR_HALF_FETS, bool MINPWR_DC_HALFCLK,
                         uint8_t REG_FBK_SEL, bool DOUBLE_IBIAS_CMP_LP_LPSR,
                         bool DISABLE_IDLE_SKIP, bool DISABLE_PULSE_SKIP,
                         bool ENABLE_FF) volatile
    {
        uint32_t curr = REG3;

        curr &= ~(0b1u << 30u);
        curr |= (VDD1P8CTRL_DISABLE_STEP & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (VDD1P0CTRL_DISABLE_STEP & 0b1u) << 29u;
        curr &= ~(0b1u << 27u);
        curr |= (MISC_DELAY_TIMING & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (MINPWR_HALF_FETS & 0b1u) << 26u;
        curr &= ~(0b1u << 24u);
        curr |= (MINPWR_DC_HALFCLK & 0b1u) << 24u;
        curr &= ~(0b11u << 22u);
        curr |= (REG_FBK_SEL & 0b11u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (DOUBLE_IBIAS_CMP_LP_LPSR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (DISABLE_IDLE_SKIP & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (DISABLE_PULSE_SKIP & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ENABLE_FF & 0b1u) << 18u;

        REG3 = curr;
    }

    /**
     * Get REG4's ENABLE_SP field.
     *
     * Configures CTRL0[ENABLE] (DCDC Enable) for Setpoints 0-15
     */
    inline uint16_t get_REG4_ENABLE_SP() volatile
    {
        return (REG4 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set REG4's ENABLE_SP field.
     *
     * Configures CTRL0[ENABLE] (DCDC Enable) for Setpoints 0-15
     */
    inline void set_REG4_ENABLE_SP(uint16_t value) volatile
    {
        uint32_t curr = REG4;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        REG4 = curr;
    }

    /**
     * Get REG5's DIG_EN_SP field.
     *
     * Configures CTRL0[DIG_EN] (DCDC_DIG Enable) for Setpoints 0-15. Always
     * set these bits to 1.
     */
    inline uint16_t get_REG5_DIG_EN_SP() volatile
    {
        return (REG5 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set REG5's DIG_EN_SP field.
     *
     * Configures CTRL0[DIG_EN] (DCDC_DIG Enable) for Setpoints 0-15. Always
     * set these bits to 1.
     */
    inline void set_REG5_DIG_EN_SP(uint16_t value) volatile
    {
        uint32_t curr = REG5;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        REG5 = curr;
    }

    /**
     * Get REG6's LP_MODE_SP field.
     *
     * Configures CTRL0[LP_MODE_EN] (LP Mode Enable) for Setpoints 0-15
     */
    inline uint16_t get_REG6_LP_MODE_SP() volatile
    {
        return (REG6 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set REG6's LP_MODE_SP field.
     *
     * Configures CTRL0[LP_MODE_EN] (LP Mode Enable) for Setpoints 0-15
     */
    inline void set_REG6_LP_MODE_SP(uint16_t value) volatile
    {
        uint32_t curr = REG6;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        REG6 = curr;
    }

    /**
     * Get REG7's STBY_EN_SP field.
     *
     * Configures CTRL0[STBY_EN] (Standby Enable) for Setpoints 0-15
     */
    inline uint16_t get_REG7_STBY_EN_SP() volatile
    {
        return (REG7 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set REG7's STBY_EN_SP field.
     *
     * Configures CTRL0[STBY_EN] (Standby Enable) for Setpoints 0-15
     */
    inline void set_REG7_STBY_EN_SP(uint16_t value) volatile
    {
        uint32_t curr = REG7;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        REG7 = curr;
    }

    /**
     * Get REG7P's STBY_LP_MODE_SP field.
     *
     * Configures CTRL0[STBY_LP_MODE_EN] (LP Mode via GPC Enable) for Setpoints
     * 0-15
     */
    inline uint16_t get_REG7P_STBY_LP_MODE_SP() volatile
    {
        return (REG7P >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set REG7P's STBY_LP_MODE_SP field.
     *
     * Configures CTRL0[STBY_LP_MODE_EN] (LP Mode via GPC Enable) for Setpoints
     * 0-15
     */
    inline void set_REG7P_STBY_LP_MODE_SP(uint16_t value) volatile
    {
        uint32_t curr = REG7P;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        REG7P = curr;
    }

    /**
     * Get REG8's ANA_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 0-3
     */
    inline uint32_t get_REG8_ANA_TRG_SP0() volatile
    {
        return (REG8 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG8's ANA_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 0-3
     */
    inline void set_REG8_ANA_TRG_SP0(uint32_t value) volatile
    {
        uint32_t curr = REG8;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG8 = curr;
    }

    /**
     * Get REG9's ANA_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 4-7
     */
    inline uint32_t get_REG9_ANA_TRG_SP1() volatile
    {
        return (REG9 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG9's ANA_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 4-7
     */
    inline void set_REG9_ANA_TRG_SP1(uint32_t value) volatile
    {
        uint32_t curr = REG9;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG9 = curr;
    }

    /**
     * Get REG10's ANA_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 8-11
     */
    inline uint32_t get_REG10_ANA_TRG_SP2() volatile
    {
        return (REG10 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG10's ANA_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 8-11
     */
    inline void set_REG10_ANA_TRG_SP2(uint32_t value) volatile
    {
        uint32_t curr = REG10;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG10 = curr;
    }

    /**
     * Get REG11's ANA_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 12-15
     */
    inline uint32_t get_REG11_ANA_TRG_SP3() volatile
    {
        return (REG11 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG11's ANA_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P8CTRL_TRG] FOR Setpoints 12-15
     */
    inline void set_REG11_ANA_TRG_SP3(uint32_t value) volatile
    {
        uint32_t curr = REG11;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG11 = curr;
    }

    /**
     * Get REG12's DIG_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 0-3
     */
    inline uint32_t get_REG12_DIG_TRG_SP0() volatile
    {
        return (REG12 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG12's DIG_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 0-3
     */
    inline void set_REG12_DIG_TRG_SP0(uint32_t value) volatile
    {
        uint32_t curr = REG12;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG12 = curr;
    }

    /**
     * Get REG13's DIG_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 4-7
     */
    inline uint32_t get_REG13_DIG_TRG_SP1() volatile
    {
        return (REG13 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG13's DIG_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 4-7
     */
    inline void set_REG13_DIG_TRG_SP1(uint32_t value) volatile
    {
        uint32_t curr = REG13;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG13 = curr;
    }

    /**
     * Get REG14's DIG_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 8-11
     */
    inline uint32_t get_REG14_DIG_TRG_SP2() volatile
    {
        return (REG14 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG14's DIG_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 8-11
     */
    inline void set_REG14_DIG_TRG_SP2(uint32_t value) volatile
    {
        uint32_t curr = REG14;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG14 = curr;
    }

    /**
     * Get REG15's DIG_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 12-15
     */
    inline uint32_t get_REG15_DIG_TRG_SP3() volatile
    {
        return (REG15 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG15's DIG_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P0CTRL_TRG] FOR Setpoints 12-15
     */
    inline void set_REG15_DIG_TRG_SP3(uint32_t value) volatile
    {
        uint32_t curr = REG15;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG15 = curr;
    }

    /**
     * Get REG16's ANA_STBY_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 0-3
     */
    inline uint32_t get_REG16_ANA_STBY_TRG_SP0() volatile
    {
        return (REG16 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG16's ANA_STBY_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 0-3
     */
    inline void set_REG16_ANA_STBY_TRG_SP0(uint32_t value) volatile
    {
        uint32_t curr = REG16;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG16 = curr;
    }

    /**
     * Get REG17's ANA_STBY_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 4-7
     */
    inline uint32_t get_REG17_ANA_STBY_TRG_SP1() volatile
    {
        return (REG17 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG17's ANA_STBY_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 4-7
     */
    inline void set_REG17_ANA_STBY_TRG_SP1(uint32_t value) volatile
    {
        uint32_t curr = REG17;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG17 = curr;
    }

    /**
     * Get REG18's ANA_STBY_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 8-11
     */
    inline uint32_t get_REG18_ANA_STBY_TRG_SP2() volatile
    {
        return (REG18 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG18's ANA_STBY_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 8-11
     */
    inline void set_REG18_ANA_STBY_TRG_SP2(uint32_t value) volatile
    {
        uint32_t curr = REG18;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG18 = curr;
    }

    /**
     * Get REG19's ANA_STBY_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 12-15
     */
    inline uint32_t get_REG19_ANA_STBY_TRG_SP3() volatile
    {
        return (REG19 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG19's ANA_STBY_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P8CTRL_STBY_TRG] FOR Setpoints 12-15
     */
    inline void set_REG19_ANA_STBY_TRG_SP3(uint32_t value) volatile
    {
        uint32_t curr = REG19;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG19 = curr;
    }

    /**
     * Get REG20's DIG_STBY_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 0-3
     */
    inline uint32_t get_REG20_DIG_STBY_TRG_SP0() volatile
    {
        return (REG20 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG20's DIG_STBY_TRG_SP0 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 0-3
     */
    inline void set_REG20_DIG_STBY_TRG_SP0(uint32_t value) volatile
    {
        uint32_t curr = REG20;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG20 = curr;
    }

    /**
     * Get REG21's DIG_STBY_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 4-7
     */
    inline uint32_t get_REG21_DIG_STBY_TRG_SP1() volatile
    {
        return (REG21 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG21's DIG_STBY_TRG_SP1 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 4-7
     */
    inline void set_REG21_DIG_STBY_TRG_SP1(uint32_t value) volatile
    {
        uint32_t curr = REG21;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG21 = curr;
    }

    /**
     * Get REG22's DIG_STBY_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 8-11
     */
    inline uint32_t get_REG22_DIG_STBY_TRG_SP2() volatile
    {
        return (REG22 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG22's DIG_STBY_TRG_SP2 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 8-11
     */
    inline void set_REG22_DIG_STBY_TRG_SP2(uint32_t value) volatile
    {
        uint32_t curr = REG22;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG22 = curr;
    }

    /**
     * Get REG23's DIG_STBY_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 12-15
     */
    inline uint32_t get_REG23_DIG_STBY_TRG_SP3() volatile
    {
        return (REG23 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG23's DIG_STBY_TRG_SP3 field.
     *
     * Configures CTRL1[VDD1P0CTRL_STBY_TRG] FOR Setpoints 12-15
     */
    inline void set_REG23_DIG_STBY_TRG_SP3(uint32_t value) volatile
    {
        uint32_t curr = REG23;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG23 = curr;
    }

    /**
     * Get REG24's OK_COUNT field.
     *
     * Internal count for dcdc_ok timeout
     */
    inline uint32_t get_REG24_OK_COUNT() volatile
    {
        return (REG24 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set REG24's OK_COUNT field.
     *
     * Internal count for dcdc_ok timeout
     */
    inline void set_REG24_OK_COUNT(uint32_t value) volatile
    {
        uint32_t curr = REG24;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        REG24 = curr;
    }
};

static_assert(sizeof(dcdc) == dcdc::size);

static volatile dcdc *const DCDC = reinterpret_cast<dcdc *>(0x40CA8000);

}; // namespace MIMXRT1176::CM7
