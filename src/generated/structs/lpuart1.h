/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/LPUART1_BAUD_MATCFG.h"
#include "../enums/LPUART1_BAUD_OSR.h"
#include "../enums/LPUART1_CTRL_IDLECFG.h"
#include "../enums/LPUART1_FIFO_RXFIFOSIZE.h"
#include "../enums/LPUART1_FIFO_RXIDEN.h"
#include "../enums/LPUART1_FIFO_TXFIFOSIZE.h"
#include "../enums/LPUART1_MODIR_TNP.h"
#include "../enums/LPUART1_PINCFG_TRGSEL.h"
#include "../enums/LPUART1_VERID_FEATURE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * LPUART
 */
struct [[gnu::packed]] lpuart1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 48; /*!< lpuart1's size in bytes. */

    /* Fields. */
    uint32_t VERID;  /*!< (read-write) Version ID Register */
    uint32_t PARAM;  /*!< (read-write) Parameter Register */
    uint32_t GLOBAL; /*!< (read-write) LPUART Global Register */
    uint32_t PINCFG; /*!< (read-write) LPUART Pin Configuration Register */
    uint32_t BAUD;   /*!< (read-write) LPUART Baud Rate Register */
    uint32_t STAT;   /*!< (read-write) LPUART Status Register */
    uint32_t CTRL;   /*!< (read-write) LPUART Control Register */
    uint32_t DATA;   /*!< (read-write) LPUART Data Register */
    uint32_t MATCH;  /*!< (read-write) LPUART Match Address Register */
    uint32_t MODIR;  /*!< (read-write) LPUART Modem IrDA Register */
    uint32_t FIFO;   /*!< (read-write) LPUART FIFO Register */
    uint32_t WATER;  /*!< (read-write) LPUART Watermark Register */

    /* Methods. */

    /**
     * Get VERID's MAJOR field.
     *
     * Major Version Number
     */
    inline uint8_t get_VERID_MAJOR() volatile
    {
        return (VERID >> 24u) & 0b11111111u;
    }

    /**
     * Get VERID's MINOR field.
     *
     * Minor Version Number
     */
    inline uint8_t get_VERID_MINOR() volatile
    {
        return (VERID >> 16u) & 0b11111111u;
    }

    /**
     * Get VERID's FEATURE field.
     *
     * Feature Identification Number
     */
    inline LPUART1_VERID_FEATURE get_VERID_FEATURE() volatile
    {
        return LPUART1_VERID_FEATURE((VERID >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get all of VERID's bit fields.
     *
     * (read-write) Version ID Register
     */
    inline void get_VERID(uint8_t &MAJOR, uint8_t &MINOR,
                          LPUART1_VERID_FEATURE &FEATURE) volatile
    {
        uint32_t curr = VERID;

        MAJOR = (curr >> 24u) & 0b11111111u;
        MINOR = (curr >> 16u) & 0b11111111u;
        FEATURE = LPUART1_VERID_FEATURE((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Get PARAM's RXFIFO field.
     *
     * Receive FIFO Size
     */
    inline uint8_t get_PARAM_RXFIFO() volatile
    {
        return (PARAM >> 8u) & 0b11111111u;
    }

    /**
     * Get PARAM's TXFIFO field.
     *
     * Transmit FIFO Size
     */
    inline uint8_t get_PARAM_TXFIFO() volatile
    {
        return (PARAM >> 0u) & 0b11111111u;
    }

    /**
     * Get all of PARAM's bit fields.
     *
     * (read-write) Parameter Register
     */
    inline void get_PARAM(uint8_t &RXFIFO, uint8_t &TXFIFO) volatile
    {
        uint32_t curr = PARAM;

        RXFIFO = (curr >> 8u) & 0b11111111u;
        TXFIFO = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get GLOBAL's RST bit.
     *
     * Software Reset
     */
    inline bool get_GLOBAL_RST() volatile
    {
        return GLOBAL & (1u << 1u);
    }

    /**
     * Set GLOBAL's RST bit.
     *
     * Software Reset
     */
    inline void set_GLOBAL_RST() volatile
    {
        GLOBAL |= 1u << 1u;
    }

    /**
     * Clear GLOBAL's RST bit.
     *
     * Software Reset
     */
    inline void clear_GLOBAL_RST() volatile
    {
        GLOBAL &= ~(1u << 1u);
    }

    /**
     * Toggle GLOBAL's RST bit.
     *
     * Software Reset
     */
    inline void toggle_GLOBAL_RST() volatile
    {
        GLOBAL ^= 1u << 1u;
    }

    /**
     * Get PINCFG's TRGSEL field.
     *
     * Trigger Select
     */
    inline LPUART1_PINCFG_TRGSEL get_PINCFG_TRGSEL() volatile
    {
        return LPUART1_PINCFG_TRGSEL((PINCFG >> 0u) & 0b11u);
    }

    /**
     * Set PINCFG's TRGSEL field.
     *
     * Trigger Select
     */
    inline void set_PINCFG_TRGSEL(LPUART1_PINCFG_TRGSEL value) volatile
    {
        uint32_t curr = PINCFG;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        PINCFG = curr;
    }

    /**
     * Get BAUD's MAEN1 bit.
     *
     * Match Address Mode Enable 1
     */
    inline bool get_BAUD_MAEN1() volatile
    {
        return BAUD & (1u << 31u);
    }

    /**
     * Set BAUD's MAEN1 bit.
     *
     * Match Address Mode Enable 1
     */
    inline void set_BAUD_MAEN1() volatile
    {
        BAUD |= 1u << 31u;
    }

    /**
     * Clear BAUD's MAEN1 bit.
     *
     * Match Address Mode Enable 1
     */
    inline void clear_BAUD_MAEN1() volatile
    {
        BAUD &= ~(1u << 31u);
    }

    /**
     * Toggle BAUD's MAEN1 bit.
     *
     * Match Address Mode Enable 1
     */
    inline void toggle_BAUD_MAEN1() volatile
    {
        BAUD ^= 1u << 31u;
    }

    /**
     * Get BAUD's MAEN2 bit.
     *
     * Match Address Mode Enable 2
     */
    inline bool get_BAUD_MAEN2() volatile
    {
        return BAUD & (1u << 30u);
    }

    /**
     * Set BAUD's MAEN2 bit.
     *
     * Match Address Mode Enable 2
     */
    inline void set_BAUD_MAEN2() volatile
    {
        BAUD |= 1u << 30u;
    }

    /**
     * Clear BAUD's MAEN2 bit.
     *
     * Match Address Mode Enable 2
     */
    inline void clear_BAUD_MAEN2() volatile
    {
        BAUD &= ~(1u << 30u);
    }

    /**
     * Toggle BAUD's MAEN2 bit.
     *
     * Match Address Mode Enable 2
     */
    inline void toggle_BAUD_MAEN2() volatile
    {
        BAUD ^= 1u << 30u;
    }

    /**
     * Get BAUD's M10 bit.
     *
     * 10-bit Mode select
     */
    inline bool get_BAUD_M10() volatile
    {
        return BAUD & (1u << 29u);
    }

    /**
     * Set BAUD's M10 bit.
     *
     * 10-bit Mode select
     */
    inline void set_BAUD_M10() volatile
    {
        BAUD |= 1u << 29u;
    }

    /**
     * Clear BAUD's M10 bit.
     *
     * 10-bit Mode select
     */
    inline void clear_BAUD_M10() volatile
    {
        BAUD &= ~(1u << 29u);
    }

    /**
     * Toggle BAUD's M10 bit.
     *
     * 10-bit Mode select
     */
    inline void toggle_BAUD_M10() volatile
    {
        BAUD ^= 1u << 29u;
    }

    /**
     * Get BAUD's OSR field.
     *
     * Oversampling Ratio
     */
    inline LPUART1_BAUD_OSR get_BAUD_OSR() volatile
    {
        return LPUART1_BAUD_OSR((BAUD >> 24u) & 0b11111u);
    }

    /**
     * Set BAUD's OSR field.
     *
     * Oversampling Ratio
     */
    inline void set_BAUD_OSR(LPUART1_BAUD_OSR value) volatile
    {
        uint32_t curr = BAUD;

        curr &= ~(0b11111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111u) << 24u;

        BAUD = curr;
    }

    /**
     * Get BAUD's TDMAE bit.
     *
     * Transmitter DMA Enable
     */
    inline bool get_BAUD_TDMAE() volatile
    {
        return BAUD & (1u << 23u);
    }

    /**
     * Set BAUD's TDMAE bit.
     *
     * Transmitter DMA Enable
     */
    inline void set_BAUD_TDMAE() volatile
    {
        BAUD |= 1u << 23u;
    }

    /**
     * Clear BAUD's TDMAE bit.
     *
     * Transmitter DMA Enable
     */
    inline void clear_BAUD_TDMAE() volatile
    {
        BAUD &= ~(1u << 23u);
    }

    /**
     * Toggle BAUD's TDMAE bit.
     *
     * Transmitter DMA Enable
     */
    inline void toggle_BAUD_TDMAE() volatile
    {
        BAUD ^= 1u << 23u;
    }

    /**
     * Get BAUD's RDMAE bit.
     *
     * Receiver Full DMA Enable
     */
    inline bool get_BAUD_RDMAE() volatile
    {
        return BAUD & (1u << 21u);
    }

    /**
     * Set BAUD's RDMAE bit.
     *
     * Receiver Full DMA Enable
     */
    inline void set_BAUD_RDMAE() volatile
    {
        BAUD |= 1u << 21u;
    }

    /**
     * Clear BAUD's RDMAE bit.
     *
     * Receiver Full DMA Enable
     */
    inline void clear_BAUD_RDMAE() volatile
    {
        BAUD &= ~(1u << 21u);
    }

    /**
     * Toggle BAUD's RDMAE bit.
     *
     * Receiver Full DMA Enable
     */
    inline void toggle_BAUD_RDMAE() volatile
    {
        BAUD ^= 1u << 21u;
    }

    /**
     * Get BAUD's MATCFG field.
     *
     * Match Configuration
     */
    inline LPUART1_BAUD_MATCFG get_BAUD_MATCFG() volatile
    {
        return LPUART1_BAUD_MATCFG((BAUD >> 18u) & 0b11u);
    }

    /**
     * Set BAUD's MATCFG field.
     *
     * Match Configuration
     */
    inline void set_BAUD_MATCFG(LPUART1_BAUD_MATCFG value) volatile
    {
        uint32_t curr = BAUD;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        BAUD = curr;
    }

    /**
     * Get BAUD's BOTHEDGE bit.
     *
     * Both Edge Sampling
     */
    inline bool get_BAUD_BOTHEDGE() volatile
    {
        return BAUD & (1u << 17u);
    }

    /**
     * Set BAUD's BOTHEDGE bit.
     *
     * Both Edge Sampling
     */
    inline void set_BAUD_BOTHEDGE() volatile
    {
        BAUD |= 1u << 17u;
    }

    /**
     * Clear BAUD's BOTHEDGE bit.
     *
     * Both Edge Sampling
     */
    inline void clear_BAUD_BOTHEDGE() volatile
    {
        BAUD &= ~(1u << 17u);
    }

    /**
     * Toggle BAUD's BOTHEDGE bit.
     *
     * Both Edge Sampling
     */
    inline void toggle_BAUD_BOTHEDGE() volatile
    {
        BAUD ^= 1u << 17u;
    }

    /**
     * Get BAUD's RESYNCDIS bit.
     *
     * Resynchronization Disable
     */
    inline bool get_BAUD_RESYNCDIS() volatile
    {
        return BAUD & (1u << 16u);
    }

    /**
     * Set BAUD's RESYNCDIS bit.
     *
     * Resynchronization Disable
     */
    inline void set_BAUD_RESYNCDIS() volatile
    {
        BAUD |= 1u << 16u;
    }

    /**
     * Clear BAUD's RESYNCDIS bit.
     *
     * Resynchronization Disable
     */
    inline void clear_BAUD_RESYNCDIS() volatile
    {
        BAUD &= ~(1u << 16u);
    }

    /**
     * Toggle BAUD's RESYNCDIS bit.
     *
     * Resynchronization Disable
     */
    inline void toggle_BAUD_RESYNCDIS() volatile
    {
        BAUD ^= 1u << 16u;
    }

    /**
     * Get BAUD's LBKDIE bit.
     *
     * LIN Break Detect Interrupt Enable
     */
    inline bool get_BAUD_LBKDIE() volatile
    {
        return BAUD & (1u << 15u);
    }

    /**
     * Set BAUD's LBKDIE bit.
     *
     * LIN Break Detect Interrupt Enable
     */
    inline void set_BAUD_LBKDIE() volatile
    {
        BAUD |= 1u << 15u;
    }

    /**
     * Clear BAUD's LBKDIE bit.
     *
     * LIN Break Detect Interrupt Enable
     */
    inline void clear_BAUD_LBKDIE() volatile
    {
        BAUD &= ~(1u << 15u);
    }

    /**
     * Toggle BAUD's LBKDIE bit.
     *
     * LIN Break Detect Interrupt Enable
     */
    inline void toggle_BAUD_LBKDIE() volatile
    {
        BAUD ^= 1u << 15u;
    }

    /**
     * Get BAUD's RXEDGIE bit.
     *
     * RX Input Active Edge Interrupt Enable
     */
    inline bool get_BAUD_RXEDGIE() volatile
    {
        return BAUD & (1u << 14u);
    }

    /**
     * Set BAUD's RXEDGIE bit.
     *
     * RX Input Active Edge Interrupt Enable
     */
    inline void set_BAUD_RXEDGIE() volatile
    {
        BAUD |= 1u << 14u;
    }

    /**
     * Clear BAUD's RXEDGIE bit.
     *
     * RX Input Active Edge Interrupt Enable
     */
    inline void clear_BAUD_RXEDGIE() volatile
    {
        BAUD &= ~(1u << 14u);
    }

    /**
     * Toggle BAUD's RXEDGIE bit.
     *
     * RX Input Active Edge Interrupt Enable
     */
    inline void toggle_BAUD_RXEDGIE() volatile
    {
        BAUD ^= 1u << 14u;
    }

    /**
     * Get BAUD's SBNS bit.
     *
     * Stop Bit Number Select
     */
    inline bool get_BAUD_SBNS() volatile
    {
        return BAUD & (1u << 13u);
    }

    /**
     * Set BAUD's SBNS bit.
     *
     * Stop Bit Number Select
     */
    inline void set_BAUD_SBNS() volatile
    {
        BAUD |= 1u << 13u;
    }

    /**
     * Clear BAUD's SBNS bit.
     *
     * Stop Bit Number Select
     */
    inline void clear_BAUD_SBNS() volatile
    {
        BAUD &= ~(1u << 13u);
    }

    /**
     * Toggle BAUD's SBNS bit.
     *
     * Stop Bit Number Select
     */
    inline void toggle_BAUD_SBNS() volatile
    {
        BAUD ^= 1u << 13u;
    }

    /**
     * Get BAUD's SBR field.
     *
     * Baud Rate Modulo Divisor.
     */
    inline uint16_t get_BAUD_SBR() volatile
    {
        return (BAUD >> 0u) & 0b1111111111111u;
    }

    /**
     * Set BAUD's SBR field.
     *
     * Baud Rate Modulo Divisor.
     */
    inline void set_BAUD_SBR(uint16_t value) volatile
    {
        uint32_t curr = BAUD;

        curr &= ~(0b1111111111111u << 0u);
        curr |= (value & 0b1111111111111u) << 0u;

        BAUD = curr;
    }

    /**
     * Get all of BAUD's bit fields.
     *
     * (read-write) LPUART Baud Rate Register
     */
    inline void get_BAUD(bool &MAEN1, bool &MAEN2, bool &M10,
                         LPUART1_BAUD_OSR &OSR, bool &TDMAE, bool &RDMAE,
                         LPUART1_BAUD_MATCFG &MATCFG, bool &BOTHEDGE,
                         bool &RESYNCDIS, bool &LBKDIE, bool &RXEDGIE,
                         bool &SBNS, uint16_t &SBR) volatile
    {
        uint32_t curr = BAUD;

        MAEN1 = curr & (1u << 31u);
        MAEN2 = curr & (1u << 30u);
        M10 = curr & (1u << 29u);
        OSR = LPUART1_BAUD_OSR((curr >> 24u) & 0b11111u);
        TDMAE = curr & (1u << 23u);
        RDMAE = curr & (1u << 21u);
        MATCFG = LPUART1_BAUD_MATCFG((curr >> 18u) & 0b11u);
        BOTHEDGE = curr & (1u << 17u);
        RESYNCDIS = curr & (1u << 16u);
        LBKDIE = curr & (1u << 15u);
        RXEDGIE = curr & (1u << 14u);
        SBNS = curr & (1u << 13u);
        SBR = (curr >> 0u) & 0b1111111111111u;
    }

    /**
     * Set all of BAUD's bit fields.
     *
     * (read-write) LPUART Baud Rate Register
     */
    inline void set_BAUD(bool MAEN1, bool MAEN2, bool M10,
                         LPUART1_BAUD_OSR OSR, bool TDMAE, bool RDMAE,
                         LPUART1_BAUD_MATCFG MATCFG, bool BOTHEDGE,
                         bool RESYNCDIS, bool LBKDIE, bool RXEDGIE, bool SBNS,
                         uint16_t SBR) volatile
    {
        uint32_t curr = BAUD;

        curr &= ~(0b1u << 31u);
        curr |= (MAEN1 & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (MAEN2 & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (M10 & 0b1u) << 29u;
        curr &= ~(0b11111u << 24u);
        curr |= (std::to_underlying(OSR) & 0b11111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (TDMAE & 0b1u) << 23u;
        curr &= ~(0b1u << 21u);
        curr |= (RDMAE & 0b1u) << 21u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(MATCFG) & 0b11u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (BOTHEDGE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RESYNCDIS & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (LBKDIE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (RXEDGIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (SBNS & 0b1u) << 13u;
        curr &= ~(0b1111111111111u << 0u);
        curr |= (SBR & 0b1111111111111u) << 0u;

        BAUD = curr;
    }

    /**
     * Get STAT's LBKDIF bit.
     *
     * LIN Break Detect Interrupt Flag
     */
    inline bool get_STAT_LBKDIF() volatile
    {
        return STAT & (1u << 31u);
    }

    /**
     * Set STAT's LBKDIF bit.
     *
     * LIN Break Detect Interrupt Flag
     */
    inline void set_STAT_LBKDIF() volatile
    {
        STAT |= 1u << 31u;
    }

    /**
     * Clear STAT's LBKDIF bit.
     *
     * LIN Break Detect Interrupt Flag
     */
    inline void clear_STAT_LBKDIF() volatile
    {
        STAT &= ~(1u << 31u);
    }

    /**
     * Toggle STAT's LBKDIF bit.
     *
     * LIN Break Detect Interrupt Flag
     */
    inline void toggle_STAT_LBKDIF() volatile
    {
        STAT ^= 1u << 31u;
    }

    /**
     * Get STAT's RXEDGIF bit.
     *
     * RXD Pin Active Edge Interrupt Flag
     */
    inline bool get_STAT_RXEDGIF() volatile
    {
        return STAT & (1u << 30u);
    }

    /**
     * Set STAT's RXEDGIF bit.
     *
     * RXD Pin Active Edge Interrupt Flag
     */
    inline void set_STAT_RXEDGIF() volatile
    {
        STAT |= 1u << 30u;
    }

    /**
     * Clear STAT's RXEDGIF bit.
     *
     * RXD Pin Active Edge Interrupt Flag
     */
    inline void clear_STAT_RXEDGIF() volatile
    {
        STAT &= ~(1u << 30u);
    }

    /**
     * Toggle STAT's RXEDGIF bit.
     *
     * RXD Pin Active Edge Interrupt Flag
     */
    inline void toggle_STAT_RXEDGIF() volatile
    {
        STAT ^= 1u << 30u;
    }

    /**
     * Get STAT's MSBF bit.
     *
     * MSB First
     */
    inline bool get_STAT_MSBF() volatile
    {
        return STAT & (1u << 29u);
    }

    /**
     * Set STAT's MSBF bit.
     *
     * MSB First
     */
    inline void set_STAT_MSBF() volatile
    {
        STAT |= 1u << 29u;
    }

    /**
     * Clear STAT's MSBF bit.
     *
     * MSB First
     */
    inline void clear_STAT_MSBF() volatile
    {
        STAT &= ~(1u << 29u);
    }

    /**
     * Toggle STAT's MSBF bit.
     *
     * MSB First
     */
    inline void toggle_STAT_MSBF() volatile
    {
        STAT ^= 1u << 29u;
    }

    /**
     * Get STAT's RXINV bit.
     *
     * Receive Data Inversion
     */
    inline bool get_STAT_RXINV() volatile
    {
        return STAT & (1u << 28u);
    }

    /**
     * Set STAT's RXINV bit.
     *
     * Receive Data Inversion
     */
    inline void set_STAT_RXINV() volatile
    {
        STAT |= 1u << 28u;
    }

    /**
     * Clear STAT's RXINV bit.
     *
     * Receive Data Inversion
     */
    inline void clear_STAT_RXINV() volatile
    {
        STAT &= ~(1u << 28u);
    }

    /**
     * Toggle STAT's RXINV bit.
     *
     * Receive Data Inversion
     */
    inline void toggle_STAT_RXINV() volatile
    {
        STAT ^= 1u << 28u;
    }

    /**
     * Get STAT's RWUID bit.
     *
     * Receive Wake Up Idle Detect
     */
    inline bool get_STAT_RWUID() volatile
    {
        return STAT & (1u << 27u);
    }

    /**
     * Set STAT's RWUID bit.
     *
     * Receive Wake Up Idle Detect
     */
    inline void set_STAT_RWUID() volatile
    {
        STAT |= 1u << 27u;
    }

    /**
     * Clear STAT's RWUID bit.
     *
     * Receive Wake Up Idle Detect
     */
    inline void clear_STAT_RWUID() volatile
    {
        STAT &= ~(1u << 27u);
    }

    /**
     * Toggle STAT's RWUID bit.
     *
     * Receive Wake Up Idle Detect
     */
    inline void toggle_STAT_RWUID() volatile
    {
        STAT ^= 1u << 27u;
    }

    /**
     * Get STAT's BRK13 bit.
     *
     * Break Character Generation Length
     */
    inline bool get_STAT_BRK13() volatile
    {
        return STAT & (1u << 26u);
    }

    /**
     * Set STAT's BRK13 bit.
     *
     * Break Character Generation Length
     */
    inline void set_STAT_BRK13() volatile
    {
        STAT |= 1u << 26u;
    }

    /**
     * Clear STAT's BRK13 bit.
     *
     * Break Character Generation Length
     */
    inline void clear_STAT_BRK13() volatile
    {
        STAT &= ~(1u << 26u);
    }

    /**
     * Toggle STAT's BRK13 bit.
     *
     * Break Character Generation Length
     */
    inline void toggle_STAT_BRK13() volatile
    {
        STAT ^= 1u << 26u;
    }

    /**
     * Get STAT's LBKDE bit.
     *
     * LIN Break Detection Enable
     */
    inline bool get_STAT_LBKDE() volatile
    {
        return STAT & (1u << 25u);
    }

    /**
     * Set STAT's LBKDE bit.
     *
     * LIN Break Detection Enable
     */
    inline void set_STAT_LBKDE() volatile
    {
        STAT |= 1u << 25u;
    }

    /**
     * Clear STAT's LBKDE bit.
     *
     * LIN Break Detection Enable
     */
    inline void clear_STAT_LBKDE() volatile
    {
        STAT &= ~(1u << 25u);
    }

    /**
     * Toggle STAT's LBKDE bit.
     *
     * LIN Break Detection Enable
     */
    inline void toggle_STAT_LBKDE() volatile
    {
        STAT ^= 1u << 25u;
    }

    /**
     * Get STAT's RAF bit.
     *
     * Receiver Active Flag
     */
    inline bool get_STAT_RAF() volatile
    {
        return STAT & (1u << 24u);
    }

    /**
     * Get STAT's TDRE bit.
     *
     * Transmit Data Register Empty Flag
     */
    inline bool get_STAT_TDRE() volatile
    {
        return STAT & (1u << 23u);
    }

    /**
     * Get STAT's TC bit.
     *
     * Transmission Complete Flag
     */
    inline bool get_STAT_TC() volatile
    {
        return STAT & (1u << 22u);
    }

    /**
     * Get STAT's RDRF bit.
     *
     * Receive Data Register Full Flag
     */
    inline bool get_STAT_RDRF() volatile
    {
        return STAT & (1u << 21u);
    }

    /**
     * Get STAT's IDLE bit.
     *
     * Idle Line Flag
     */
    inline bool get_STAT_IDLE() volatile
    {
        return STAT & (1u << 20u);
    }

    /**
     * Set STAT's IDLE bit.
     *
     * Idle Line Flag
     */
    inline void set_STAT_IDLE() volatile
    {
        STAT |= 1u << 20u;
    }

    /**
     * Clear STAT's IDLE bit.
     *
     * Idle Line Flag
     */
    inline void clear_STAT_IDLE() volatile
    {
        STAT &= ~(1u << 20u);
    }

    /**
     * Toggle STAT's IDLE bit.
     *
     * Idle Line Flag
     */
    inline void toggle_STAT_IDLE() volatile
    {
        STAT ^= 1u << 20u;
    }

    /**
     * Get STAT's OR bit.
     *
     * Receiver Overrun Flag
     */
    inline bool get_STAT_OR() volatile
    {
        return STAT & (1u << 19u);
    }

    /**
     * Set STAT's OR bit.
     *
     * Receiver Overrun Flag
     */
    inline void set_STAT_OR() volatile
    {
        STAT |= 1u << 19u;
    }

    /**
     * Clear STAT's OR bit.
     *
     * Receiver Overrun Flag
     */
    inline void clear_STAT_OR() volatile
    {
        STAT &= ~(1u << 19u);
    }

    /**
     * Toggle STAT's OR bit.
     *
     * Receiver Overrun Flag
     */
    inline void toggle_STAT_OR() volatile
    {
        STAT ^= 1u << 19u;
    }

    /**
     * Get STAT's NF bit.
     *
     * Noise Flag
     */
    inline bool get_STAT_NF() volatile
    {
        return STAT & (1u << 18u);
    }

    /**
     * Set STAT's NF bit.
     *
     * Noise Flag
     */
    inline void set_STAT_NF() volatile
    {
        STAT |= 1u << 18u;
    }

    /**
     * Clear STAT's NF bit.
     *
     * Noise Flag
     */
    inline void clear_STAT_NF() volatile
    {
        STAT &= ~(1u << 18u);
    }

    /**
     * Toggle STAT's NF bit.
     *
     * Noise Flag
     */
    inline void toggle_STAT_NF() volatile
    {
        STAT ^= 1u << 18u;
    }

    /**
     * Get STAT's FE bit.
     *
     * Framing Error Flag
     */
    inline bool get_STAT_FE() volatile
    {
        return STAT & (1u << 17u);
    }

    /**
     * Set STAT's FE bit.
     *
     * Framing Error Flag
     */
    inline void set_STAT_FE() volatile
    {
        STAT |= 1u << 17u;
    }

    /**
     * Clear STAT's FE bit.
     *
     * Framing Error Flag
     */
    inline void clear_STAT_FE() volatile
    {
        STAT &= ~(1u << 17u);
    }

    /**
     * Toggle STAT's FE bit.
     *
     * Framing Error Flag
     */
    inline void toggle_STAT_FE() volatile
    {
        STAT ^= 1u << 17u;
    }

    /**
     * Get STAT's PF bit.
     *
     * Parity Error Flag
     */
    inline bool get_STAT_PF() volatile
    {
        return STAT & (1u << 16u);
    }

    /**
     * Set STAT's PF bit.
     *
     * Parity Error Flag
     */
    inline void set_STAT_PF() volatile
    {
        STAT |= 1u << 16u;
    }

    /**
     * Clear STAT's PF bit.
     *
     * Parity Error Flag
     */
    inline void clear_STAT_PF() volatile
    {
        STAT &= ~(1u << 16u);
    }

    /**
     * Toggle STAT's PF bit.
     *
     * Parity Error Flag
     */
    inline void toggle_STAT_PF() volatile
    {
        STAT ^= 1u << 16u;
    }

    /**
     * Get STAT's MA1F bit.
     *
     * Match 1 Flag
     */
    inline bool get_STAT_MA1F() volatile
    {
        return STAT & (1u << 15u);
    }

    /**
     * Set STAT's MA1F bit.
     *
     * Match 1 Flag
     */
    inline void set_STAT_MA1F() volatile
    {
        STAT |= 1u << 15u;
    }

    /**
     * Clear STAT's MA1F bit.
     *
     * Match 1 Flag
     */
    inline void clear_STAT_MA1F() volatile
    {
        STAT &= ~(1u << 15u);
    }

    /**
     * Toggle STAT's MA1F bit.
     *
     * Match 1 Flag
     */
    inline void toggle_STAT_MA1F() volatile
    {
        STAT ^= 1u << 15u;
    }

    /**
     * Get STAT's MA2F bit.
     *
     * Match 2 Flag
     */
    inline bool get_STAT_MA2F() volatile
    {
        return STAT & (1u << 14u);
    }

    /**
     * Set STAT's MA2F bit.
     *
     * Match 2 Flag
     */
    inline void set_STAT_MA2F() volatile
    {
        STAT |= 1u << 14u;
    }

    /**
     * Clear STAT's MA2F bit.
     *
     * Match 2 Flag
     */
    inline void clear_STAT_MA2F() volatile
    {
        STAT &= ~(1u << 14u);
    }

    /**
     * Toggle STAT's MA2F bit.
     *
     * Match 2 Flag
     */
    inline void toggle_STAT_MA2F() volatile
    {
        STAT ^= 1u << 14u;
    }

    /**
     * Get all of STAT's bit fields.
     *
     * (read-write) LPUART Status Register
     */
    inline void get_STAT(bool &LBKDIF, bool &RXEDGIF, bool &MSBF, bool &RXINV,
                         bool &RWUID, bool &BRK13, bool &LBKDE, bool &RAF,
                         bool &TDRE, bool &TC, bool &RDRF, bool &IDLE,
                         bool &OR, bool &NF, bool &FE, bool &PF, bool &MA1F,
                         bool &MA2F) volatile
    {
        uint32_t curr = STAT;

        LBKDIF = curr & (1u << 31u);
        RXEDGIF = curr & (1u << 30u);
        MSBF = curr & (1u << 29u);
        RXINV = curr & (1u << 28u);
        RWUID = curr & (1u << 27u);
        BRK13 = curr & (1u << 26u);
        LBKDE = curr & (1u << 25u);
        RAF = curr & (1u << 24u);
        TDRE = curr & (1u << 23u);
        TC = curr & (1u << 22u);
        RDRF = curr & (1u << 21u);
        IDLE = curr & (1u << 20u);
        OR = curr & (1u << 19u);
        NF = curr & (1u << 18u);
        FE = curr & (1u << 17u);
        PF = curr & (1u << 16u);
        MA1F = curr & (1u << 15u);
        MA2F = curr & (1u << 14u);
    }

    /**
     * Set all of STAT's bit fields.
     *
     * (read-write) LPUART Status Register
     */
    inline void set_STAT(bool LBKDIF, bool RXEDGIF, bool MSBF, bool RXINV,
                         bool RWUID, bool BRK13, bool LBKDE, bool IDLE,
                         bool OR, bool NF, bool FE, bool PF, bool MA1F,
                         bool MA2F) volatile
    {
        uint32_t curr = STAT;

        curr &= ~(0b1u << 31u);
        curr |= (LBKDIF & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (RXEDGIF & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (MSBF & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (RXINV & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (RWUID & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (BRK13 & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (LBKDE & 0b1u) << 25u;
        curr &= ~(0b1u << 20u);
        curr |= (IDLE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (OR & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (NF & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (FE & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (PF & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (MA1F & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (MA2F & 0b1u) << 14u;

        STAT = curr;
    }

    /**
     * Get CTRL's R8T9 bit.
     *
     * Receive Bit 8 / Transmit Bit 9
     */
    inline bool get_CTRL_R8T9() volatile
    {
        return CTRL & (1u << 31u);
    }

    /**
     * Set CTRL's R8T9 bit.
     *
     * Receive Bit 8 / Transmit Bit 9
     */
    inline void set_CTRL_R8T9() volatile
    {
        CTRL |= 1u << 31u;
    }

    /**
     * Clear CTRL's R8T9 bit.
     *
     * Receive Bit 8 / Transmit Bit 9
     */
    inline void clear_CTRL_R8T9() volatile
    {
        CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL's R8T9 bit.
     *
     * Receive Bit 8 / Transmit Bit 9
     */
    inline void toggle_CTRL_R8T9() volatile
    {
        CTRL ^= 1u << 31u;
    }

    /**
     * Get CTRL's R9T8 bit.
     *
     * Receive Bit 9 / Transmit Bit 8
     */
    inline bool get_CTRL_R9T8() volatile
    {
        return CTRL & (1u << 30u);
    }

    /**
     * Set CTRL's R9T8 bit.
     *
     * Receive Bit 9 / Transmit Bit 8
     */
    inline void set_CTRL_R9T8() volatile
    {
        CTRL |= 1u << 30u;
    }

    /**
     * Clear CTRL's R9T8 bit.
     *
     * Receive Bit 9 / Transmit Bit 8
     */
    inline void clear_CTRL_R9T8() volatile
    {
        CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL's R9T8 bit.
     *
     * Receive Bit 9 / Transmit Bit 8
     */
    inline void toggle_CTRL_R9T8() volatile
    {
        CTRL ^= 1u << 30u;
    }

    /**
     * Get CTRL's TXDIR bit.
     *
     * TXD Pin Direction in Single-Wire Mode
     */
    inline bool get_CTRL_TXDIR() volatile
    {
        return CTRL & (1u << 29u);
    }

    /**
     * Set CTRL's TXDIR bit.
     *
     * TXD Pin Direction in Single-Wire Mode
     */
    inline void set_CTRL_TXDIR() volatile
    {
        CTRL |= 1u << 29u;
    }

    /**
     * Clear CTRL's TXDIR bit.
     *
     * TXD Pin Direction in Single-Wire Mode
     */
    inline void clear_CTRL_TXDIR() volatile
    {
        CTRL &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL's TXDIR bit.
     *
     * TXD Pin Direction in Single-Wire Mode
     */
    inline void toggle_CTRL_TXDIR() volatile
    {
        CTRL ^= 1u << 29u;
    }

    /**
     * Get CTRL's TXINV bit.
     *
     * Transmit Data Inversion
     */
    inline bool get_CTRL_TXINV() volatile
    {
        return CTRL & (1u << 28u);
    }

    /**
     * Set CTRL's TXINV bit.
     *
     * Transmit Data Inversion
     */
    inline void set_CTRL_TXINV() volatile
    {
        CTRL |= 1u << 28u;
    }

    /**
     * Clear CTRL's TXINV bit.
     *
     * Transmit Data Inversion
     */
    inline void clear_CTRL_TXINV() volatile
    {
        CTRL &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL's TXINV bit.
     *
     * Transmit Data Inversion
     */
    inline void toggle_CTRL_TXINV() volatile
    {
        CTRL ^= 1u << 28u;
    }

    /**
     * Get CTRL's ORIE bit.
     *
     * Overrun Interrupt Enable
     */
    inline bool get_CTRL_ORIE() volatile
    {
        return CTRL & (1u << 27u);
    }

    /**
     * Set CTRL's ORIE bit.
     *
     * Overrun Interrupt Enable
     */
    inline void set_CTRL_ORIE() volatile
    {
        CTRL |= 1u << 27u;
    }

    /**
     * Clear CTRL's ORIE bit.
     *
     * Overrun Interrupt Enable
     */
    inline void clear_CTRL_ORIE() volatile
    {
        CTRL &= ~(1u << 27u);
    }

    /**
     * Toggle CTRL's ORIE bit.
     *
     * Overrun Interrupt Enable
     */
    inline void toggle_CTRL_ORIE() volatile
    {
        CTRL ^= 1u << 27u;
    }

    /**
     * Get CTRL's NEIE bit.
     *
     * Noise Error Interrupt Enable
     */
    inline bool get_CTRL_NEIE() volatile
    {
        return CTRL & (1u << 26u);
    }

    /**
     * Set CTRL's NEIE bit.
     *
     * Noise Error Interrupt Enable
     */
    inline void set_CTRL_NEIE() volatile
    {
        CTRL |= 1u << 26u;
    }

    /**
     * Clear CTRL's NEIE bit.
     *
     * Noise Error Interrupt Enable
     */
    inline void clear_CTRL_NEIE() volatile
    {
        CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL's NEIE bit.
     *
     * Noise Error Interrupt Enable
     */
    inline void toggle_CTRL_NEIE() volatile
    {
        CTRL ^= 1u << 26u;
    }

    /**
     * Get CTRL's FEIE bit.
     *
     * Framing Error Interrupt Enable
     */
    inline bool get_CTRL_FEIE() volatile
    {
        return CTRL & (1u << 25u);
    }

    /**
     * Set CTRL's FEIE bit.
     *
     * Framing Error Interrupt Enable
     */
    inline void set_CTRL_FEIE() volatile
    {
        CTRL |= 1u << 25u;
    }

    /**
     * Clear CTRL's FEIE bit.
     *
     * Framing Error Interrupt Enable
     */
    inline void clear_CTRL_FEIE() volatile
    {
        CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle CTRL's FEIE bit.
     *
     * Framing Error Interrupt Enable
     */
    inline void toggle_CTRL_FEIE() volatile
    {
        CTRL ^= 1u << 25u;
    }

    /**
     * Get CTRL's PEIE bit.
     *
     * Parity Error Interrupt Enable
     */
    inline bool get_CTRL_PEIE() volatile
    {
        return CTRL & (1u << 24u);
    }

    /**
     * Set CTRL's PEIE bit.
     *
     * Parity Error Interrupt Enable
     */
    inline void set_CTRL_PEIE() volatile
    {
        CTRL |= 1u << 24u;
    }

    /**
     * Clear CTRL's PEIE bit.
     *
     * Parity Error Interrupt Enable
     */
    inline void clear_CTRL_PEIE() volatile
    {
        CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL's PEIE bit.
     *
     * Parity Error Interrupt Enable
     */
    inline void toggle_CTRL_PEIE() volatile
    {
        CTRL ^= 1u << 24u;
    }

    /**
     * Get CTRL's TIE bit.
     *
     * Transmit Interrupt Enable
     */
    inline bool get_CTRL_TIE() volatile
    {
        return CTRL & (1u << 23u);
    }

    /**
     * Set CTRL's TIE bit.
     *
     * Transmit Interrupt Enable
     */
    inline void set_CTRL_TIE() volatile
    {
        CTRL |= 1u << 23u;
    }

    /**
     * Clear CTRL's TIE bit.
     *
     * Transmit Interrupt Enable
     */
    inline void clear_CTRL_TIE() volatile
    {
        CTRL &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL's TIE bit.
     *
     * Transmit Interrupt Enable
     */
    inline void toggle_CTRL_TIE() volatile
    {
        CTRL ^= 1u << 23u;
    }

    /**
     * Get CTRL's TCIE bit.
     *
     * Transmission Complete Interrupt Enable for
     */
    inline bool get_CTRL_TCIE() volatile
    {
        return CTRL & (1u << 22u);
    }

    /**
     * Set CTRL's TCIE bit.
     *
     * Transmission Complete Interrupt Enable for
     */
    inline void set_CTRL_TCIE() volatile
    {
        CTRL |= 1u << 22u;
    }

    /**
     * Clear CTRL's TCIE bit.
     *
     * Transmission Complete Interrupt Enable for
     */
    inline void clear_CTRL_TCIE() volatile
    {
        CTRL &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL's TCIE bit.
     *
     * Transmission Complete Interrupt Enable for
     */
    inline void toggle_CTRL_TCIE() volatile
    {
        CTRL ^= 1u << 22u;
    }

    /**
     * Get CTRL's RIE bit.
     *
     * Receiver Interrupt Enable
     */
    inline bool get_CTRL_RIE() volatile
    {
        return CTRL & (1u << 21u);
    }

    /**
     * Set CTRL's RIE bit.
     *
     * Receiver Interrupt Enable
     */
    inline void set_CTRL_RIE() volatile
    {
        CTRL |= 1u << 21u;
    }

    /**
     * Clear CTRL's RIE bit.
     *
     * Receiver Interrupt Enable
     */
    inline void clear_CTRL_RIE() volatile
    {
        CTRL &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL's RIE bit.
     *
     * Receiver Interrupt Enable
     */
    inline void toggle_CTRL_RIE() volatile
    {
        CTRL ^= 1u << 21u;
    }

    /**
     * Get CTRL's ILIE bit.
     *
     * Idle Line Interrupt Enable
     */
    inline bool get_CTRL_ILIE() volatile
    {
        return CTRL & (1u << 20u);
    }

    /**
     * Set CTRL's ILIE bit.
     *
     * Idle Line Interrupt Enable
     */
    inline void set_CTRL_ILIE() volatile
    {
        CTRL |= 1u << 20u;
    }

    /**
     * Clear CTRL's ILIE bit.
     *
     * Idle Line Interrupt Enable
     */
    inline void clear_CTRL_ILIE() volatile
    {
        CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL's ILIE bit.
     *
     * Idle Line Interrupt Enable
     */
    inline void toggle_CTRL_ILIE() volatile
    {
        CTRL ^= 1u << 20u;
    }

    /**
     * Get CTRL's TE bit.
     *
     * Transmitter Enable
     */
    inline bool get_CTRL_TE() volatile
    {
        return CTRL & (1u << 19u);
    }

    /**
     * Set CTRL's TE bit.
     *
     * Transmitter Enable
     */
    inline void set_CTRL_TE() volatile
    {
        CTRL |= 1u << 19u;
    }

    /**
     * Clear CTRL's TE bit.
     *
     * Transmitter Enable
     */
    inline void clear_CTRL_TE() volatile
    {
        CTRL &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL's TE bit.
     *
     * Transmitter Enable
     */
    inline void toggle_CTRL_TE() volatile
    {
        CTRL ^= 1u << 19u;
    }

    /**
     * Get CTRL's RE bit.
     *
     * Receiver Enable
     */
    inline bool get_CTRL_RE() volatile
    {
        return CTRL & (1u << 18u);
    }

    /**
     * Set CTRL's RE bit.
     *
     * Receiver Enable
     */
    inline void set_CTRL_RE() volatile
    {
        CTRL |= 1u << 18u;
    }

    /**
     * Clear CTRL's RE bit.
     *
     * Receiver Enable
     */
    inline void clear_CTRL_RE() volatile
    {
        CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle CTRL's RE bit.
     *
     * Receiver Enable
     */
    inline void toggle_CTRL_RE() volatile
    {
        CTRL ^= 1u << 18u;
    }

    /**
     * Get CTRL's RWU bit.
     *
     * Receiver Wakeup Control
     */
    inline bool get_CTRL_RWU() volatile
    {
        return CTRL & (1u << 17u);
    }

    /**
     * Set CTRL's RWU bit.
     *
     * Receiver Wakeup Control
     */
    inline void set_CTRL_RWU() volatile
    {
        CTRL |= 1u << 17u;
    }

    /**
     * Clear CTRL's RWU bit.
     *
     * Receiver Wakeup Control
     */
    inline void clear_CTRL_RWU() volatile
    {
        CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL's RWU bit.
     *
     * Receiver Wakeup Control
     */
    inline void toggle_CTRL_RWU() volatile
    {
        CTRL ^= 1u << 17u;
    }

    /**
     * Get CTRL's SBK bit.
     *
     * Send Break
     */
    inline bool get_CTRL_SBK() volatile
    {
        return CTRL & (1u << 16u);
    }

    /**
     * Set CTRL's SBK bit.
     *
     * Send Break
     */
    inline void set_CTRL_SBK() volatile
    {
        CTRL |= 1u << 16u;
    }

    /**
     * Clear CTRL's SBK bit.
     *
     * Send Break
     */
    inline void clear_CTRL_SBK() volatile
    {
        CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL's SBK bit.
     *
     * Send Break
     */
    inline void toggle_CTRL_SBK() volatile
    {
        CTRL ^= 1u << 16u;
    }

    /**
     * Get CTRL's MA1IE bit.
     *
     * Match 1 Interrupt Enable
     */
    inline bool get_CTRL_MA1IE() volatile
    {
        return CTRL & (1u << 15u);
    }

    /**
     * Set CTRL's MA1IE bit.
     *
     * Match 1 Interrupt Enable
     */
    inline void set_CTRL_MA1IE() volatile
    {
        CTRL |= 1u << 15u;
    }

    /**
     * Clear CTRL's MA1IE bit.
     *
     * Match 1 Interrupt Enable
     */
    inline void clear_CTRL_MA1IE() volatile
    {
        CTRL &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL's MA1IE bit.
     *
     * Match 1 Interrupt Enable
     */
    inline void toggle_CTRL_MA1IE() volatile
    {
        CTRL ^= 1u << 15u;
    }

    /**
     * Get CTRL's MA2IE bit.
     *
     * Match 2 Interrupt Enable
     */
    inline bool get_CTRL_MA2IE() volatile
    {
        return CTRL & (1u << 14u);
    }

    /**
     * Set CTRL's MA2IE bit.
     *
     * Match 2 Interrupt Enable
     */
    inline void set_CTRL_MA2IE() volatile
    {
        CTRL |= 1u << 14u;
    }

    /**
     * Clear CTRL's MA2IE bit.
     *
     * Match 2 Interrupt Enable
     */
    inline void clear_CTRL_MA2IE() volatile
    {
        CTRL &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL's MA2IE bit.
     *
     * Match 2 Interrupt Enable
     */
    inline void toggle_CTRL_MA2IE() volatile
    {
        CTRL ^= 1u << 14u;
    }

    /**
     * Get CTRL's M7 bit.
     *
     * 7-Bit Mode Select
     */
    inline bool get_CTRL_M7() volatile
    {
        return CTRL & (1u << 11u);
    }

    /**
     * Set CTRL's M7 bit.
     *
     * 7-Bit Mode Select
     */
    inline void set_CTRL_M7() volatile
    {
        CTRL |= 1u << 11u;
    }

    /**
     * Clear CTRL's M7 bit.
     *
     * 7-Bit Mode Select
     */
    inline void clear_CTRL_M7() volatile
    {
        CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL's M7 bit.
     *
     * 7-Bit Mode Select
     */
    inline void toggle_CTRL_M7() volatile
    {
        CTRL ^= 1u << 11u;
    }

    /**
     * Get CTRL's IDLECFG field.
     *
     * Idle Configuration
     */
    inline LPUART1_CTRL_IDLECFG get_CTRL_IDLECFG() volatile
    {
        return LPUART1_CTRL_IDLECFG((CTRL >> 8u) & 0b111u);
    }

    /**
     * Set CTRL's IDLECFG field.
     *
     * Idle Configuration
     */
    inline void set_CTRL_IDLECFG(LPUART1_CTRL_IDLECFG value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        CTRL = curr;
    }

    /**
     * Get CTRL's LOOPS bit.
     *
     * Loop Mode Select
     */
    inline bool get_CTRL_LOOPS() volatile
    {
        return CTRL & (1u << 7u);
    }

    /**
     * Set CTRL's LOOPS bit.
     *
     * Loop Mode Select
     */
    inline void set_CTRL_LOOPS() volatile
    {
        CTRL |= 1u << 7u;
    }

    /**
     * Clear CTRL's LOOPS bit.
     *
     * Loop Mode Select
     */
    inline void clear_CTRL_LOOPS() volatile
    {
        CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL's LOOPS bit.
     *
     * Loop Mode Select
     */
    inline void toggle_CTRL_LOOPS() volatile
    {
        CTRL ^= 1u << 7u;
    }

    /**
     * Get CTRL's DOZEEN bit.
     *
     * Doze Enable
     */
    inline bool get_CTRL_DOZEEN() volatile
    {
        return CTRL & (1u << 6u);
    }

    /**
     * Set CTRL's DOZEEN bit.
     *
     * Doze Enable
     */
    inline void set_CTRL_DOZEEN() volatile
    {
        CTRL |= 1u << 6u;
    }

    /**
     * Clear CTRL's DOZEEN bit.
     *
     * Doze Enable
     */
    inline void clear_CTRL_DOZEEN() volatile
    {
        CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL's DOZEEN bit.
     *
     * Doze Enable
     */
    inline void toggle_CTRL_DOZEEN() volatile
    {
        CTRL ^= 1u << 6u;
    }

    /**
     * Get CTRL's RSRC bit.
     *
     * Receiver Source Select
     */
    inline bool get_CTRL_RSRC() volatile
    {
        return CTRL & (1u << 5u);
    }

    /**
     * Set CTRL's RSRC bit.
     *
     * Receiver Source Select
     */
    inline void set_CTRL_RSRC() volatile
    {
        CTRL |= 1u << 5u;
    }

    /**
     * Clear CTRL's RSRC bit.
     *
     * Receiver Source Select
     */
    inline void clear_CTRL_RSRC() volatile
    {
        CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL's RSRC bit.
     *
     * Receiver Source Select
     */
    inline void toggle_CTRL_RSRC() volatile
    {
        CTRL ^= 1u << 5u;
    }

    /**
     * Get CTRL's M bit.
     *
     * 9-Bit or 8-Bit Mode Select
     */
    inline bool get_CTRL_M() volatile
    {
        return CTRL & (1u << 4u);
    }

    /**
     * Set CTRL's M bit.
     *
     * 9-Bit or 8-Bit Mode Select
     */
    inline void set_CTRL_M() volatile
    {
        CTRL |= 1u << 4u;
    }

    /**
     * Clear CTRL's M bit.
     *
     * 9-Bit or 8-Bit Mode Select
     */
    inline void clear_CTRL_M() volatile
    {
        CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL's M bit.
     *
     * 9-Bit or 8-Bit Mode Select
     */
    inline void toggle_CTRL_M() volatile
    {
        CTRL ^= 1u << 4u;
    }

    /**
     * Get CTRL's WAKE bit.
     *
     * Receiver Wakeup Method Select
     */
    inline bool get_CTRL_WAKE() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's WAKE bit.
     *
     * Receiver Wakeup Method Select
     */
    inline void set_CTRL_WAKE() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's WAKE bit.
     *
     * Receiver Wakeup Method Select
     */
    inline void clear_CTRL_WAKE() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's WAKE bit.
     *
     * Receiver Wakeup Method Select
     */
    inline void toggle_CTRL_WAKE() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get CTRL's ILT bit.
     *
     * Idle Line Type Select
     */
    inline bool get_CTRL_ILT() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's ILT bit.
     *
     * Idle Line Type Select
     */
    inline void set_CTRL_ILT() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's ILT bit.
     *
     * Idle Line Type Select
     */
    inline void clear_CTRL_ILT() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's ILT bit.
     *
     * Idle Line Type Select
     */
    inline void toggle_CTRL_ILT() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's PE bit.
     *
     * Parity Enable
     */
    inline bool get_CTRL_PE() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's PE bit.
     *
     * Parity Enable
     */
    inline void set_CTRL_PE() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's PE bit.
     *
     * Parity Enable
     */
    inline void clear_CTRL_PE() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's PE bit.
     *
     * Parity Enable
     */
    inline void toggle_CTRL_PE() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's PT bit.
     *
     * Parity Type
     */
    inline bool get_CTRL_PT() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's PT bit.
     *
     * Parity Type
     */
    inline void set_CTRL_PT() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's PT bit.
     *
     * Parity Type
     */
    inline void clear_CTRL_PT() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's PT bit.
     *
     * Parity Type
     */
    inline void toggle_CTRL_PT() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) LPUART Control Register
     */
    inline void get_CTRL(bool &R8T9, bool &R9T8, bool &TXDIR, bool &TXINV,
                         bool &ORIE, bool &NEIE, bool &FEIE, bool &PEIE,
                         bool &TIE, bool &TCIE, bool &RIE, bool &ILIE,
                         bool &TE, bool &RE, bool &RWU, bool &SBK, bool &MA1IE,
                         bool &MA2IE, bool &M7, LPUART1_CTRL_IDLECFG &IDLECFG,
                         bool &LOOPS, bool &DOZEEN, bool &RSRC, bool &M,
                         bool &WAKE, bool &ILT, bool &PE, bool &PT) volatile
    {
        uint32_t curr = CTRL;

        R8T9 = curr & (1u << 31u);
        R9T8 = curr & (1u << 30u);
        TXDIR = curr & (1u << 29u);
        TXINV = curr & (1u << 28u);
        ORIE = curr & (1u << 27u);
        NEIE = curr & (1u << 26u);
        FEIE = curr & (1u << 25u);
        PEIE = curr & (1u << 24u);
        TIE = curr & (1u << 23u);
        TCIE = curr & (1u << 22u);
        RIE = curr & (1u << 21u);
        ILIE = curr & (1u << 20u);
        TE = curr & (1u << 19u);
        RE = curr & (1u << 18u);
        RWU = curr & (1u << 17u);
        SBK = curr & (1u << 16u);
        MA1IE = curr & (1u << 15u);
        MA2IE = curr & (1u << 14u);
        M7 = curr & (1u << 11u);
        IDLECFG = LPUART1_CTRL_IDLECFG((curr >> 8u) & 0b111u);
        LOOPS = curr & (1u << 7u);
        DOZEEN = curr & (1u << 6u);
        RSRC = curr & (1u << 5u);
        M = curr & (1u << 4u);
        WAKE = curr & (1u << 3u);
        ILT = curr & (1u << 2u);
        PE = curr & (1u << 1u);
        PT = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) LPUART Control Register
     */
    inline void set_CTRL(bool R8T9, bool R9T8, bool TXDIR, bool TXINV,
                         bool ORIE, bool NEIE, bool FEIE, bool PEIE, bool TIE,
                         bool TCIE, bool RIE, bool ILIE, bool TE, bool RE,
                         bool RWU, bool SBK, bool MA1IE, bool MA2IE, bool M7,
                         LPUART1_CTRL_IDLECFG IDLECFG, bool LOOPS, bool DOZEEN,
                         bool RSRC, bool M, bool WAKE, bool ILT, bool PE,
                         bool PT) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (R8T9 & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (R9T8 & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (TXDIR & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (TXINV & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (ORIE & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (NEIE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (FEIE & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (PEIE & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (TIE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (TCIE & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (RIE & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ILIE & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (TE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (RE & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (RWU & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SBK & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (MA1IE & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (MA2IE & 0b1u) << 14u;
        curr &= ~(0b1u << 11u);
        curr |= (M7 & 0b1u) << 11u;
        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(IDLECFG) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LOOPS & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (DOZEEN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RSRC & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (M & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (WAKE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ILT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PT & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get DATA's NOISY bit.
     *
     * Noisy Data Received
     */
    inline bool get_DATA_NOISY() volatile
    {
        return DATA & (1u << 15u);
    }

    /**
     * Get DATA's PARITYE bit.
     *
     * Parity Error
     */
    inline bool get_DATA_PARITYE() volatile
    {
        return DATA & (1u << 14u);
    }

    /**
     * Get DATA's FRETSC bit.
     *
     * Frame Error / Transmit Special Character
     */
    inline bool get_DATA_FRETSC() volatile
    {
        return DATA & (1u << 13u);
    }

    /**
     * Set DATA's FRETSC bit.
     *
     * Frame Error / Transmit Special Character
     */
    inline void set_DATA_FRETSC() volatile
    {
        DATA |= 1u << 13u;
    }

    /**
     * Clear DATA's FRETSC bit.
     *
     * Frame Error / Transmit Special Character
     */
    inline void clear_DATA_FRETSC() volatile
    {
        DATA &= ~(1u << 13u);
    }

    /**
     * Toggle DATA's FRETSC bit.
     *
     * Frame Error / Transmit Special Character
     */
    inline void toggle_DATA_FRETSC() volatile
    {
        DATA ^= 1u << 13u;
    }

    /**
     * Get DATA's RXEMPT bit.
     *
     * Receive Buffer Empty
     */
    inline bool get_DATA_RXEMPT() volatile
    {
        return DATA & (1u << 12u);
    }

    /**
     * Get DATA's IDLINE bit.
     *
     * Idle Line
     */
    inline bool get_DATA_IDLINE() volatile
    {
        return DATA & (1u << 11u);
    }

    /**
     * Get DATA's R9T9 bit.
     *
     * R9T9
     */
    inline bool get_DATA_R9T9() volatile
    {
        return DATA & (1u << 9u);
    }

    /**
     * Set DATA's R9T9 bit.
     *
     * R9T9
     */
    inline void set_DATA_R9T9() volatile
    {
        DATA |= 1u << 9u;
    }

    /**
     * Clear DATA's R9T9 bit.
     *
     * R9T9
     */
    inline void clear_DATA_R9T9() volatile
    {
        DATA &= ~(1u << 9u);
    }

    /**
     * Toggle DATA's R9T9 bit.
     *
     * R9T9
     */
    inline void toggle_DATA_R9T9() volatile
    {
        DATA ^= 1u << 9u;
    }

    /**
     * Get DATA's R8T8 bit.
     *
     * R8T8
     */
    inline bool get_DATA_R8T8() volatile
    {
        return DATA & (1u << 8u);
    }

    /**
     * Set DATA's R8T8 bit.
     *
     * R8T8
     */
    inline void set_DATA_R8T8() volatile
    {
        DATA |= 1u << 8u;
    }

    /**
     * Clear DATA's R8T8 bit.
     *
     * R8T8
     */
    inline void clear_DATA_R8T8() volatile
    {
        DATA &= ~(1u << 8u);
    }

    /**
     * Toggle DATA's R8T8 bit.
     *
     * R8T8
     */
    inline void toggle_DATA_R8T8() volatile
    {
        DATA ^= 1u << 8u;
    }

    /**
     * Get DATA's R7T7 bit.
     *
     * R7T7
     */
    inline bool get_DATA_R7T7() volatile
    {
        return DATA & (1u << 7u);
    }

    /**
     * Set DATA's R7T7 bit.
     *
     * R7T7
     */
    inline void set_DATA_R7T7() volatile
    {
        DATA |= 1u << 7u;
    }

    /**
     * Clear DATA's R7T7 bit.
     *
     * R7T7
     */
    inline void clear_DATA_R7T7() volatile
    {
        DATA &= ~(1u << 7u);
    }

    /**
     * Toggle DATA's R7T7 bit.
     *
     * R7T7
     */
    inline void toggle_DATA_R7T7() volatile
    {
        DATA ^= 1u << 7u;
    }

    /**
     * Get DATA's R6T6 bit.
     *
     * R6T6
     */
    inline bool get_DATA_R6T6() volatile
    {
        return DATA & (1u << 6u);
    }

    /**
     * Set DATA's R6T6 bit.
     *
     * R6T6
     */
    inline void set_DATA_R6T6() volatile
    {
        DATA |= 1u << 6u;
    }

    /**
     * Clear DATA's R6T6 bit.
     *
     * R6T6
     */
    inline void clear_DATA_R6T6() volatile
    {
        DATA &= ~(1u << 6u);
    }

    /**
     * Toggle DATA's R6T6 bit.
     *
     * R6T6
     */
    inline void toggle_DATA_R6T6() volatile
    {
        DATA ^= 1u << 6u;
    }

    /**
     * Get DATA's R5T5 bit.
     *
     * R5T5
     */
    inline bool get_DATA_R5T5() volatile
    {
        return DATA & (1u << 5u);
    }

    /**
     * Set DATA's R5T5 bit.
     *
     * R5T5
     */
    inline void set_DATA_R5T5() volatile
    {
        DATA |= 1u << 5u;
    }

    /**
     * Clear DATA's R5T5 bit.
     *
     * R5T5
     */
    inline void clear_DATA_R5T5() volatile
    {
        DATA &= ~(1u << 5u);
    }

    /**
     * Toggle DATA's R5T5 bit.
     *
     * R5T5
     */
    inline void toggle_DATA_R5T5() volatile
    {
        DATA ^= 1u << 5u;
    }

    /**
     * Get DATA's R4T4 bit.
     *
     * R4T4
     */
    inline bool get_DATA_R4T4() volatile
    {
        return DATA & (1u << 4u);
    }

    /**
     * Set DATA's R4T4 bit.
     *
     * R4T4
     */
    inline void set_DATA_R4T4() volatile
    {
        DATA |= 1u << 4u;
    }

    /**
     * Clear DATA's R4T4 bit.
     *
     * R4T4
     */
    inline void clear_DATA_R4T4() volatile
    {
        DATA &= ~(1u << 4u);
    }

    /**
     * Toggle DATA's R4T4 bit.
     *
     * R4T4
     */
    inline void toggle_DATA_R4T4() volatile
    {
        DATA ^= 1u << 4u;
    }

    /**
     * Get DATA's R3T3 bit.
     *
     * R3T3
     */
    inline bool get_DATA_R3T3() volatile
    {
        return DATA & (1u << 3u);
    }

    /**
     * Set DATA's R3T3 bit.
     *
     * R3T3
     */
    inline void set_DATA_R3T3() volatile
    {
        DATA |= 1u << 3u;
    }

    /**
     * Clear DATA's R3T3 bit.
     *
     * R3T3
     */
    inline void clear_DATA_R3T3() volatile
    {
        DATA &= ~(1u << 3u);
    }

    /**
     * Toggle DATA's R3T3 bit.
     *
     * R3T3
     */
    inline void toggle_DATA_R3T3() volatile
    {
        DATA ^= 1u << 3u;
    }

    /**
     * Get DATA's R2T2 bit.
     *
     * R2T2
     */
    inline bool get_DATA_R2T2() volatile
    {
        return DATA & (1u << 2u);
    }

    /**
     * Set DATA's R2T2 bit.
     *
     * R2T2
     */
    inline void set_DATA_R2T2() volatile
    {
        DATA |= 1u << 2u;
    }

    /**
     * Clear DATA's R2T2 bit.
     *
     * R2T2
     */
    inline void clear_DATA_R2T2() volatile
    {
        DATA &= ~(1u << 2u);
    }

    /**
     * Toggle DATA's R2T2 bit.
     *
     * R2T2
     */
    inline void toggle_DATA_R2T2() volatile
    {
        DATA ^= 1u << 2u;
    }

    /**
     * Get DATA's R1T1 bit.
     *
     * R1T1
     */
    inline bool get_DATA_R1T1() volatile
    {
        return DATA & (1u << 1u);
    }

    /**
     * Set DATA's R1T1 bit.
     *
     * R1T1
     */
    inline void set_DATA_R1T1() volatile
    {
        DATA |= 1u << 1u;
    }

    /**
     * Clear DATA's R1T1 bit.
     *
     * R1T1
     */
    inline void clear_DATA_R1T1() volatile
    {
        DATA &= ~(1u << 1u);
    }

    /**
     * Toggle DATA's R1T1 bit.
     *
     * R1T1
     */
    inline void toggle_DATA_R1T1() volatile
    {
        DATA ^= 1u << 1u;
    }

    /**
     * Get DATA's R0T0 bit.
     *
     * R0T0
     */
    inline bool get_DATA_R0T0() volatile
    {
        return DATA & (1u << 0u);
    }

    /**
     * Set DATA's R0T0 bit.
     *
     * R0T0
     */
    inline void set_DATA_R0T0() volatile
    {
        DATA |= 1u << 0u;
    }

    /**
     * Clear DATA's R0T0 bit.
     *
     * R0T0
     */
    inline void clear_DATA_R0T0() volatile
    {
        DATA &= ~(1u << 0u);
    }

    /**
     * Toggle DATA's R0T0 bit.
     *
     * R0T0
     */
    inline void toggle_DATA_R0T0() volatile
    {
        DATA ^= 1u << 0u;
    }

    /**
     * Get all of DATA's bit fields.
     *
     * (read-write) LPUART Data Register
     */
    inline void get_DATA(bool &NOISY, bool &PARITYE, bool &FRETSC,
                         bool &RXEMPT, bool &IDLINE, bool &R9T9, bool &R8T8,
                         bool &R7T7, bool &R6T6, bool &R5T5, bool &R4T4,
                         bool &R3T3, bool &R2T2, bool &R1T1,
                         bool &R0T0) volatile
    {
        uint32_t curr = DATA;

        NOISY = curr & (1u << 15u);
        PARITYE = curr & (1u << 14u);
        FRETSC = curr & (1u << 13u);
        RXEMPT = curr & (1u << 12u);
        IDLINE = curr & (1u << 11u);
        R9T9 = curr & (1u << 9u);
        R8T8 = curr & (1u << 8u);
        R7T7 = curr & (1u << 7u);
        R6T6 = curr & (1u << 6u);
        R5T5 = curr & (1u << 5u);
        R4T4 = curr & (1u << 4u);
        R3T3 = curr & (1u << 3u);
        R2T2 = curr & (1u << 2u);
        R1T1 = curr & (1u << 1u);
        R0T0 = curr & (1u << 0u);
    }

    /**
     * Set all of DATA's bit fields.
     *
     * (read-write) LPUART Data Register
     */
    inline void set_DATA(bool FRETSC, bool R9T9, bool R8T8, bool R7T7,
                         bool R6T6, bool R5T5, bool R4T4, bool R3T3, bool R2T2,
                         bool R1T1, bool R0T0) volatile
    {
        uint32_t curr = DATA;

        curr &= ~(0b1u << 13u);
        curr |= (FRETSC & 0b1u) << 13u;
        curr &= ~(0b1u << 9u);
        curr |= (R9T9 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (R8T8 & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (R7T7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (R6T6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (R5T5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (R4T4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (R3T3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (R2T2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (R1T1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (R0T0 & 0b1u) << 0u;

        DATA = curr;
    }

    /**
     * Get MATCH's MA2 field.
     *
     * Match Address 2
     */
    inline uint16_t get_MATCH_MA2() volatile
    {
        return (MATCH >> 16u) & 0b1111111111u;
    }

    /**
     * Set MATCH's MA2 field.
     *
     * Match Address 2
     */
    inline void set_MATCH_MA2(uint16_t value) volatile
    {
        uint32_t curr = MATCH;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        MATCH = curr;
    }

    /**
     * Get MATCH's MA1 field.
     *
     * Match Address 1
     */
    inline uint16_t get_MATCH_MA1() volatile
    {
        return (MATCH >> 0u) & 0b1111111111u;
    }

    /**
     * Set MATCH's MA1 field.
     *
     * Match Address 1
     */
    inline void set_MATCH_MA1(uint16_t value) volatile
    {
        uint32_t curr = MATCH;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        MATCH = curr;
    }

    /**
     * Get all of MATCH's bit fields.
     *
     * (read-write) LPUART Match Address Register
     */
    inline void get_MATCH(uint16_t &MA2, uint16_t &MA1) volatile
    {
        uint32_t curr = MATCH;

        MA2 = (curr >> 16u) & 0b1111111111u;
        MA1 = (curr >> 0u) & 0b1111111111u;
    }

    /**
     * Set all of MATCH's bit fields.
     *
     * (read-write) LPUART Match Address Register
     */
    inline void set_MATCH(uint16_t MA2, uint16_t MA1) volatile
    {
        uint32_t curr = MATCH;

        curr &= ~(0b1111111111u << 16u);
        curr |= (MA2 & 0b1111111111u) << 16u;
        curr &= ~(0b1111111111u << 0u);
        curr |= (MA1 & 0b1111111111u) << 0u;

        MATCH = curr;
    }

    /**
     * Get MODIR's IREN bit.
     *
     * Infrared enable
     */
    inline bool get_MODIR_IREN() volatile
    {
        return MODIR & (1u << 18u);
    }

    /**
     * Set MODIR's IREN bit.
     *
     * Infrared enable
     */
    inline void set_MODIR_IREN() volatile
    {
        MODIR |= 1u << 18u;
    }

    /**
     * Clear MODIR's IREN bit.
     *
     * Infrared enable
     */
    inline void clear_MODIR_IREN() volatile
    {
        MODIR &= ~(1u << 18u);
    }

    /**
     * Toggle MODIR's IREN bit.
     *
     * Infrared enable
     */
    inline void toggle_MODIR_IREN() volatile
    {
        MODIR ^= 1u << 18u;
    }

    /**
     * Get MODIR's TNP field.
     *
     * Transmitter narrow pulse
     */
    inline LPUART1_MODIR_TNP get_MODIR_TNP() volatile
    {
        return LPUART1_MODIR_TNP((MODIR >> 16u) & 0b11u);
    }

    /**
     * Set MODIR's TNP field.
     *
     * Transmitter narrow pulse
     */
    inline void set_MODIR_TNP(LPUART1_MODIR_TNP value) volatile
    {
        uint32_t curr = MODIR;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        MODIR = curr;
    }

    /**
     * Get MODIR's RTSWATER field.
     *
     * Receive RTS Configuration
     */
    inline uint8_t get_MODIR_RTSWATER() volatile
    {
        return (MODIR >> 8u) & 0b11u;
    }

    /**
     * Set MODIR's RTSWATER field.
     *
     * Receive RTS Configuration
     */
    inline void set_MODIR_RTSWATER(uint8_t value) volatile
    {
        uint32_t curr = MODIR;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        MODIR = curr;
    }

    /**
     * Get MODIR's TXCTSSRC bit.
     *
     * Transmit CTS Source
     */
    inline bool get_MODIR_TXCTSSRC() volatile
    {
        return MODIR & (1u << 5u);
    }

    /**
     * Set MODIR's TXCTSSRC bit.
     *
     * Transmit CTS Source
     */
    inline void set_MODIR_TXCTSSRC() volatile
    {
        MODIR |= 1u << 5u;
    }

    /**
     * Clear MODIR's TXCTSSRC bit.
     *
     * Transmit CTS Source
     */
    inline void clear_MODIR_TXCTSSRC() volatile
    {
        MODIR &= ~(1u << 5u);
    }

    /**
     * Toggle MODIR's TXCTSSRC bit.
     *
     * Transmit CTS Source
     */
    inline void toggle_MODIR_TXCTSSRC() volatile
    {
        MODIR ^= 1u << 5u;
    }

    /**
     * Get MODIR's TXCTSC bit.
     *
     * Transmit CTS Configuration
     */
    inline bool get_MODIR_TXCTSC() volatile
    {
        return MODIR & (1u << 4u);
    }

    /**
     * Set MODIR's TXCTSC bit.
     *
     * Transmit CTS Configuration
     */
    inline void set_MODIR_TXCTSC() volatile
    {
        MODIR |= 1u << 4u;
    }

    /**
     * Clear MODIR's TXCTSC bit.
     *
     * Transmit CTS Configuration
     */
    inline void clear_MODIR_TXCTSC() volatile
    {
        MODIR &= ~(1u << 4u);
    }

    /**
     * Toggle MODIR's TXCTSC bit.
     *
     * Transmit CTS Configuration
     */
    inline void toggle_MODIR_TXCTSC() volatile
    {
        MODIR ^= 1u << 4u;
    }

    /**
     * Get MODIR's RXRTSE bit.
     *
     * Receiver request-to-send enable
     */
    inline bool get_MODIR_RXRTSE() volatile
    {
        return MODIR & (1u << 3u);
    }

    /**
     * Set MODIR's RXRTSE bit.
     *
     * Receiver request-to-send enable
     */
    inline void set_MODIR_RXRTSE() volatile
    {
        MODIR |= 1u << 3u;
    }

    /**
     * Clear MODIR's RXRTSE bit.
     *
     * Receiver request-to-send enable
     */
    inline void clear_MODIR_RXRTSE() volatile
    {
        MODIR &= ~(1u << 3u);
    }

    /**
     * Toggle MODIR's RXRTSE bit.
     *
     * Receiver request-to-send enable
     */
    inline void toggle_MODIR_RXRTSE() volatile
    {
        MODIR ^= 1u << 3u;
    }

    /**
     * Get MODIR's TXRTSPOL bit.
     *
     * Transmitter request-to-send polarity
     */
    inline bool get_MODIR_TXRTSPOL() volatile
    {
        return MODIR & (1u << 2u);
    }

    /**
     * Set MODIR's TXRTSPOL bit.
     *
     * Transmitter request-to-send polarity
     */
    inline void set_MODIR_TXRTSPOL() volatile
    {
        MODIR |= 1u << 2u;
    }

    /**
     * Clear MODIR's TXRTSPOL bit.
     *
     * Transmitter request-to-send polarity
     */
    inline void clear_MODIR_TXRTSPOL() volatile
    {
        MODIR &= ~(1u << 2u);
    }

    /**
     * Toggle MODIR's TXRTSPOL bit.
     *
     * Transmitter request-to-send polarity
     */
    inline void toggle_MODIR_TXRTSPOL() volatile
    {
        MODIR ^= 1u << 2u;
    }

    /**
     * Get MODIR's TXRTSE bit.
     *
     * Transmitter request-to-send enable
     */
    inline bool get_MODIR_TXRTSE() volatile
    {
        return MODIR & (1u << 1u);
    }

    /**
     * Set MODIR's TXRTSE bit.
     *
     * Transmitter request-to-send enable
     */
    inline void set_MODIR_TXRTSE() volatile
    {
        MODIR |= 1u << 1u;
    }

    /**
     * Clear MODIR's TXRTSE bit.
     *
     * Transmitter request-to-send enable
     */
    inline void clear_MODIR_TXRTSE() volatile
    {
        MODIR &= ~(1u << 1u);
    }

    /**
     * Toggle MODIR's TXRTSE bit.
     *
     * Transmitter request-to-send enable
     */
    inline void toggle_MODIR_TXRTSE() volatile
    {
        MODIR ^= 1u << 1u;
    }

    /**
     * Get MODIR's TXCTSE bit.
     *
     * Transmitter clear-to-send enable
     */
    inline bool get_MODIR_TXCTSE() volatile
    {
        return MODIR & (1u << 0u);
    }

    /**
     * Set MODIR's TXCTSE bit.
     *
     * Transmitter clear-to-send enable
     */
    inline void set_MODIR_TXCTSE() volatile
    {
        MODIR |= 1u << 0u;
    }

    /**
     * Clear MODIR's TXCTSE bit.
     *
     * Transmitter clear-to-send enable
     */
    inline void clear_MODIR_TXCTSE() volatile
    {
        MODIR &= ~(1u << 0u);
    }

    /**
     * Toggle MODIR's TXCTSE bit.
     *
     * Transmitter clear-to-send enable
     */
    inline void toggle_MODIR_TXCTSE() volatile
    {
        MODIR ^= 1u << 0u;
    }

    /**
     * Get all of MODIR's bit fields.
     *
     * (read-write) LPUART Modem IrDA Register
     */
    inline void get_MODIR(bool &IREN, LPUART1_MODIR_TNP &TNP,
                          uint8_t &RTSWATER, bool &TXCTSSRC, bool &TXCTSC,
                          bool &RXRTSE, bool &TXRTSPOL, bool &TXRTSE,
                          bool &TXCTSE) volatile
    {
        uint32_t curr = MODIR;

        IREN = curr & (1u << 18u);
        TNP = LPUART1_MODIR_TNP((curr >> 16u) & 0b11u);
        RTSWATER = (curr >> 8u) & 0b11u;
        TXCTSSRC = curr & (1u << 5u);
        TXCTSC = curr & (1u << 4u);
        RXRTSE = curr & (1u << 3u);
        TXRTSPOL = curr & (1u << 2u);
        TXRTSE = curr & (1u << 1u);
        TXCTSE = curr & (1u << 0u);
    }

    /**
     * Set all of MODIR's bit fields.
     *
     * (read-write) LPUART Modem IrDA Register
     */
    inline void set_MODIR(bool IREN, LPUART1_MODIR_TNP TNP, uint8_t RTSWATER,
                          bool TXCTSSRC, bool TXCTSC, bool RXRTSE,
                          bool TXRTSPOL, bool TXRTSE, bool TXCTSE) volatile
    {
        uint32_t curr = MODIR;

        curr &= ~(0b1u << 18u);
        curr |= (IREN & 0b1u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(TNP) & 0b11u) << 16u;
        curr &= ~(0b11u << 8u);
        curr |= (RTSWATER & 0b11u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (TXCTSSRC & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TXCTSC & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (RXRTSE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TXRTSPOL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TXRTSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (TXCTSE & 0b1u) << 0u;

        MODIR = curr;
    }

    /**
     * Get FIFO's TXEMPT bit.
     *
     * Transmit FIFO/Buffer Empty
     */
    inline bool get_FIFO_TXEMPT() volatile
    {
        return FIFO & (1u << 23u);
    }

    /**
     * Get FIFO's RXEMPT bit.
     *
     * Receive FIFO/Buffer Empty
     */
    inline bool get_FIFO_RXEMPT() volatile
    {
        return FIFO & (1u << 22u);
    }

    /**
     * Get FIFO's TXOF bit.
     *
     * Transmitter FIFO Overflow Flag
     */
    inline bool get_FIFO_TXOF() volatile
    {
        return FIFO & (1u << 17u);
    }

    /**
     * Set FIFO's TXOF bit.
     *
     * Transmitter FIFO Overflow Flag
     */
    inline void set_FIFO_TXOF() volatile
    {
        FIFO |= 1u << 17u;
    }

    /**
     * Clear FIFO's TXOF bit.
     *
     * Transmitter FIFO Overflow Flag
     */
    inline void clear_FIFO_TXOF() volatile
    {
        FIFO &= ~(1u << 17u);
    }

    /**
     * Toggle FIFO's TXOF bit.
     *
     * Transmitter FIFO Overflow Flag
     */
    inline void toggle_FIFO_TXOF() volatile
    {
        FIFO ^= 1u << 17u;
    }

    /**
     * Get FIFO's RXUF bit.
     *
     * Receiver FIFO Underflow Flag
     */
    inline bool get_FIFO_RXUF() volatile
    {
        return FIFO & (1u << 16u);
    }

    /**
     * Set FIFO's RXUF bit.
     *
     * Receiver FIFO Underflow Flag
     */
    inline void set_FIFO_RXUF() volatile
    {
        FIFO |= 1u << 16u;
    }

    /**
     * Clear FIFO's RXUF bit.
     *
     * Receiver FIFO Underflow Flag
     */
    inline void clear_FIFO_RXUF() volatile
    {
        FIFO &= ~(1u << 16u);
    }

    /**
     * Toggle FIFO's RXUF bit.
     *
     * Receiver FIFO Underflow Flag
     */
    inline void toggle_FIFO_RXUF() volatile
    {
        FIFO ^= 1u << 16u;
    }

    /**
     * Get FIFO's TXFLUSH bit.
     *
     * Transmit FIFO Flush
     */
    inline bool get_FIFO_TXFLUSH() volatile
    {
        return FIFO & (1u << 15u);
    }

    /**
     * Set FIFO's TXFLUSH bit.
     *
     * Transmit FIFO Flush
     */
    inline void set_FIFO_TXFLUSH() volatile
    {
        FIFO |= 1u << 15u;
    }

    /**
     * Clear FIFO's TXFLUSH bit.
     *
     * Transmit FIFO Flush
     */
    inline void clear_FIFO_TXFLUSH() volatile
    {
        FIFO &= ~(1u << 15u);
    }

    /**
     * Toggle FIFO's TXFLUSH bit.
     *
     * Transmit FIFO Flush
     */
    inline void toggle_FIFO_TXFLUSH() volatile
    {
        FIFO ^= 1u << 15u;
    }

    /**
     * Get FIFO's RXFLUSH bit.
     *
     * Receive FIFO Flush
     */
    inline bool get_FIFO_RXFLUSH() volatile
    {
        return FIFO & (1u << 14u);
    }

    /**
     * Set FIFO's RXFLUSH bit.
     *
     * Receive FIFO Flush
     */
    inline void set_FIFO_RXFLUSH() volatile
    {
        FIFO |= 1u << 14u;
    }

    /**
     * Clear FIFO's RXFLUSH bit.
     *
     * Receive FIFO Flush
     */
    inline void clear_FIFO_RXFLUSH() volatile
    {
        FIFO &= ~(1u << 14u);
    }

    /**
     * Toggle FIFO's RXFLUSH bit.
     *
     * Receive FIFO Flush
     */
    inline void toggle_FIFO_RXFLUSH() volatile
    {
        FIFO ^= 1u << 14u;
    }

    /**
     * Get FIFO's RXIDEN field.
     *
     * Receiver Idle Empty Enable
     */
    inline LPUART1_FIFO_RXIDEN get_FIFO_RXIDEN() volatile
    {
        return LPUART1_FIFO_RXIDEN((FIFO >> 10u) & 0b111u);
    }

    /**
     * Set FIFO's RXIDEN field.
     *
     * Receiver Idle Empty Enable
     */
    inline void set_FIFO_RXIDEN(LPUART1_FIFO_RXIDEN value) volatile
    {
        uint32_t curr = FIFO;

        curr &= ~(0b111u << 10u);
        curr |= (std::to_underlying(value) & 0b111u) << 10u;

        FIFO = curr;
    }

    /**
     * Get FIFO's TXOFE bit.
     *
     * Transmit FIFO Overflow Interrupt Enable
     */
    inline bool get_FIFO_TXOFE() volatile
    {
        return FIFO & (1u << 9u);
    }

    /**
     * Set FIFO's TXOFE bit.
     *
     * Transmit FIFO Overflow Interrupt Enable
     */
    inline void set_FIFO_TXOFE() volatile
    {
        FIFO |= 1u << 9u;
    }

    /**
     * Clear FIFO's TXOFE bit.
     *
     * Transmit FIFO Overflow Interrupt Enable
     */
    inline void clear_FIFO_TXOFE() volatile
    {
        FIFO &= ~(1u << 9u);
    }

    /**
     * Toggle FIFO's TXOFE bit.
     *
     * Transmit FIFO Overflow Interrupt Enable
     */
    inline void toggle_FIFO_TXOFE() volatile
    {
        FIFO ^= 1u << 9u;
    }

    /**
     * Get FIFO's RXUFE bit.
     *
     * Receive FIFO Underflow Interrupt Enable
     */
    inline bool get_FIFO_RXUFE() volatile
    {
        return FIFO & (1u << 8u);
    }

    /**
     * Set FIFO's RXUFE bit.
     *
     * Receive FIFO Underflow Interrupt Enable
     */
    inline void set_FIFO_RXUFE() volatile
    {
        FIFO |= 1u << 8u;
    }

    /**
     * Clear FIFO's RXUFE bit.
     *
     * Receive FIFO Underflow Interrupt Enable
     */
    inline void clear_FIFO_RXUFE() volatile
    {
        FIFO &= ~(1u << 8u);
    }

    /**
     * Toggle FIFO's RXUFE bit.
     *
     * Receive FIFO Underflow Interrupt Enable
     */
    inline void toggle_FIFO_RXUFE() volatile
    {
        FIFO ^= 1u << 8u;
    }

    /**
     * Get FIFO's TXFE bit.
     *
     * Transmit FIFO Enable
     */
    inline bool get_FIFO_TXFE() volatile
    {
        return FIFO & (1u << 7u);
    }

    /**
     * Set FIFO's TXFE bit.
     *
     * Transmit FIFO Enable
     */
    inline void set_FIFO_TXFE() volatile
    {
        FIFO |= 1u << 7u;
    }

    /**
     * Clear FIFO's TXFE bit.
     *
     * Transmit FIFO Enable
     */
    inline void clear_FIFO_TXFE() volatile
    {
        FIFO &= ~(1u << 7u);
    }

    /**
     * Toggle FIFO's TXFE bit.
     *
     * Transmit FIFO Enable
     */
    inline void toggle_FIFO_TXFE() volatile
    {
        FIFO ^= 1u << 7u;
    }

    /**
     * Get FIFO's TXFIFOSIZE field.
     *
     * Transmit FIFO Buffer Depth
     */
    inline LPUART1_FIFO_TXFIFOSIZE get_FIFO_TXFIFOSIZE() volatile
    {
        return LPUART1_FIFO_TXFIFOSIZE((FIFO >> 4u) & 0b111u);
    }

    /**
     * Get FIFO's RXFE bit.
     *
     * Receive FIFO Enable
     */
    inline bool get_FIFO_RXFE() volatile
    {
        return FIFO & (1u << 3u);
    }

    /**
     * Set FIFO's RXFE bit.
     *
     * Receive FIFO Enable
     */
    inline void set_FIFO_RXFE() volatile
    {
        FIFO |= 1u << 3u;
    }

    /**
     * Clear FIFO's RXFE bit.
     *
     * Receive FIFO Enable
     */
    inline void clear_FIFO_RXFE() volatile
    {
        FIFO &= ~(1u << 3u);
    }

    /**
     * Toggle FIFO's RXFE bit.
     *
     * Receive FIFO Enable
     */
    inline void toggle_FIFO_RXFE() volatile
    {
        FIFO ^= 1u << 3u;
    }

    /**
     * Get FIFO's RXFIFOSIZE field.
     *
     * Receive FIFO Buffer Depth
     */
    inline LPUART1_FIFO_RXFIFOSIZE get_FIFO_RXFIFOSIZE() volatile
    {
        return LPUART1_FIFO_RXFIFOSIZE((FIFO >> 0u) & 0b111u);
    }

    /**
     * Get all of FIFO's bit fields.
     *
     * (read-write) LPUART FIFO Register
     */
    inline void get_FIFO(bool &TXEMPT, bool &RXEMPT, bool &TXOF, bool &RXUF,
                         bool &TXFLUSH, bool &RXFLUSH,
                         LPUART1_FIFO_RXIDEN &RXIDEN, bool &TXOFE, bool &RXUFE,
                         bool &TXFE, LPUART1_FIFO_TXFIFOSIZE &TXFIFOSIZE,
                         bool &RXFE,
                         LPUART1_FIFO_RXFIFOSIZE &RXFIFOSIZE) volatile
    {
        uint32_t curr = FIFO;

        TXEMPT = curr & (1u << 23u);
        RXEMPT = curr & (1u << 22u);
        TXOF = curr & (1u << 17u);
        RXUF = curr & (1u << 16u);
        TXFLUSH = curr & (1u << 15u);
        RXFLUSH = curr & (1u << 14u);
        RXIDEN = LPUART1_FIFO_RXIDEN((curr >> 10u) & 0b111u);
        TXOFE = curr & (1u << 9u);
        RXUFE = curr & (1u << 8u);
        TXFE = curr & (1u << 7u);
        TXFIFOSIZE = LPUART1_FIFO_TXFIFOSIZE((curr >> 4u) & 0b111u);
        RXFE = curr & (1u << 3u);
        RXFIFOSIZE = LPUART1_FIFO_RXFIFOSIZE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of FIFO's bit fields.
     *
     * (read-write) LPUART FIFO Register
     */
    inline void set_FIFO(bool TXOF, bool RXUF, bool TXFLUSH, bool RXFLUSH,
                         LPUART1_FIFO_RXIDEN RXIDEN, bool TXOFE, bool RXUFE,
                         bool TXFE, bool RXFE) volatile
    {
        uint32_t curr = FIFO;

        curr &= ~(0b1u << 17u);
        curr |= (TXOF & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (RXUF & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (TXFLUSH & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (RXFLUSH & 0b1u) << 14u;
        curr &= ~(0b111u << 10u);
        curr |= (std::to_underlying(RXIDEN) & 0b111u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (TXOFE & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (RXUFE & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (TXFE & 0b1u) << 7u;
        curr &= ~(0b1u << 3u);
        curr |= (RXFE & 0b1u) << 3u;

        FIFO = curr;
    }

    /**
     * Get WATER's RXCOUNT field.
     *
     * Receive Counter
     */
    inline uint8_t get_WATER_RXCOUNT() volatile
    {
        return (WATER >> 24u) & 0b111u;
    }

    /**
     * Get WATER's RXWATER field.
     *
     * Receive Watermark
     */
    inline uint8_t get_WATER_RXWATER() volatile
    {
        return (WATER >> 16u) & 0b11u;
    }

    /**
     * Set WATER's RXWATER field.
     *
     * Receive Watermark
     */
    inline void set_WATER_RXWATER(uint8_t value) volatile
    {
        uint32_t curr = WATER;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        WATER = curr;
    }

    /**
     * Get WATER's TXCOUNT field.
     *
     * Transmit Counter
     */
    inline uint8_t get_WATER_TXCOUNT() volatile
    {
        return (WATER >> 8u) & 0b111u;
    }

    /**
     * Get WATER's TXWATER field.
     *
     * Transmit Watermark
     */
    inline uint8_t get_WATER_TXWATER() volatile
    {
        return (WATER >> 0u) & 0b11u;
    }

    /**
     * Set WATER's TXWATER field.
     *
     * Transmit Watermark
     */
    inline void set_WATER_TXWATER(uint8_t value) volatile
    {
        uint32_t curr = WATER;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        WATER = curr;
    }

    /**
     * Get all of WATER's bit fields.
     *
     * (read-write) LPUART Watermark Register
     */
    inline void get_WATER(uint8_t &RXCOUNT, uint8_t &RXWATER, uint8_t &TXCOUNT,
                          uint8_t &TXWATER) volatile
    {
        uint32_t curr = WATER;

        RXCOUNT = (curr >> 24u) & 0b111u;
        RXWATER = (curr >> 16u) & 0b11u;
        TXCOUNT = (curr >> 8u) & 0b111u;
        TXWATER = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of WATER's bit fields.
     *
     * (read-write) LPUART Watermark Register
     */
    inline void set_WATER(uint8_t RXWATER, uint8_t TXWATER) volatile
    {
        uint32_t curr = WATER;

        curr &= ~(0b11u << 16u);
        curr |= (RXWATER & 0b11u) << 16u;
        curr &= ~(0b11u << 0u);
        curr |= (TXWATER & 0b11u) << 0u;

        WATER = curr;
    }
};

static_assert(sizeof(lpuart1) == lpuart1::size);

static volatile lpuart1 *const LPUART1 =
    reinterpret_cast<lpuart1 *>(0x4007C000);

static volatile lpuart1 *const LPUART10 =
    reinterpret_cast<lpuart1 *>(0x400A0000);

static volatile lpuart1 *const LPUART11 =
    reinterpret_cast<lpuart1 *>(0x40C24000);

static volatile lpuart1 *const LPUART12 =
    reinterpret_cast<lpuart1 *>(0x40C28000);

static volatile lpuart1 *const LPUART2 =
    reinterpret_cast<lpuart1 *>(0x40080000);

static volatile lpuart1 *const LPUART3 =
    reinterpret_cast<lpuart1 *>(0x40084000);

static volatile lpuart1 *const LPUART4 =
    reinterpret_cast<lpuart1 *>(0x40088000);

static volatile lpuart1 *const LPUART5 =
    reinterpret_cast<lpuart1 *>(0x4008C000);

static volatile lpuart1 *const LPUART6 =
    reinterpret_cast<lpuart1 *>(0x40090000);

static volatile lpuart1 *const LPUART7 =
    reinterpret_cast<lpuart1 *>(0x40094000);

static volatile lpuart1 *const LPUART8 =
    reinterpret_cast<lpuart1 *>(0x40098000);

static volatile lpuart1 *const LPUART9 =
    reinterpret_cast<lpuart1 *>(0x4009C000);

}; // namespace MIMXRT1176::CM7
