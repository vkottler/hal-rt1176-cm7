/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"
#include "REGx_instance.h"

namespace MIMXRT1176::CM7
{

/**
 * IEE
 */
struct [[gnu::packed]] iee__iee_rt1170
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        3968; /*!< iee__iee_rt1170's size in bytes. */

    /* Fields. */
    uint32_t GCFG;  /*!< (read-write) IEE Global Configuration */
    uint32_t STA;   /*!< (read-write) IEE Status */
    uint32_t TSTMD; /*!< (read-write) IEE Test Mode Register */
    uint32_t DPAMS; /*!< (read-write) AES Mask Generation Seed */
    static constexpr std::size_t reserved_padding0_length = 4;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t PC_S_LT; /*!< (read-write) Performance Counter, AES Slave Latency
                         Threshold Value */
    uint32_t PC_M_LT; /*!< (read-write) Performance Counter, AES Master Latency
                         Threshold */
    static constexpr std::size_t reserved_padding1_length = 6;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t PC_BLK_ENC; /*!< (read-write) Performance Counter, Number of AES
                            Block Encryptions */
    uint32_t PC_BLK_DEC; /*!< (read-write) Performance Counter, Number of AES
                            Block Decryptions */
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t PC_SR_TRANS; /*!< (read-write) Performance Counter, Number of AXI
                             Slave Read Transactions */
    uint32_t PC_SW_TRANS; /*!< (read-write) Performance Counter, Number of AXI
                             Slave Write Transactions */
    uint32_t PC_MR_TRANS; /*!< (read-write) Performance Counter, Number of AXI
                             Master Read Transactions */
    uint32_t PC_MW_TRANS; /*!< (read-write) Performance Counter, Number of AXI
                             Master Write Transactions */
    const uint32_t reserved_padding3 = {};
    uint32_t PC_M_MBR; /*!< (read-write) Performance Counter, Number of AXI
                          Master Merge Buffer Read Transactions */
    static constexpr std::size_t reserved_padding4_length = 2;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t PC_SR_TBC_U;  /*!< (read-write) Performance Counter, Upper Slave
                              Read Transactions Byte Count */
    uint32_t PC_SR_TBC_L;  /*!< (read-write) Performance Counter, Lower Slave
                              Read Transactions Byte Count */
    uint32_t PC_SW_TBC_U;  /*!< (read-write) Performance Counter, Upper Slave
                              Write Transactions Byte Count */
    uint32_t PC_SW_TBC_L;  /*!< (read-write) Performance Counter, Lower Slave
                              Write Transactions Byte Count */
    uint32_t PC_MR_TBC_U;  /*!< (read-write) Performance Counter, Upper Master
                              Read Transactions Byte Count */
    uint32_t PC_MR_TBC_L;  /*!< (read-write) Performance Counter, Lower Master
                              Read Transactions Byte Count */
    uint32_t PC_MW_TBC_U;  /*!< (read-write) Performance Counter, Upper Master
                              Write Transactions Byte Count */
    uint32_t PC_MW_TBC_L;  /*!< (read-write) Performance Counter, Lower Master
                              Write Transactions Byte Count */
    uint32_t PC_SR_TLGTT;  /*!< (read-write) Performance Counter, Number of AXI
                              Slave Read Transactions with Latency Greater than
                              the Threshold */
    uint32_t PC_SW_TLGTT;  /*!< (read-write) Performance Counter, Number of AXI
                              Slave Write Transactions with Latency Greater than
                              the Threshold */
    uint32_t PC_MR_TLGTT;  /*!< (read-write) Performance Counter, Number of AXI
                              Master Read Transactions with Latency Greater than
                              the Threshold */
    uint32_t PC_MW_TLGTT;  /*!< (read-write) Performance Counter, Number of AXI
                              Master Write Transactions with Latency Greater
                              than the Threshold */
    uint32_t PC_SR_TLAT_U; /*!< (read-write) Performance Counter, Upper Slave
                              Read Latency Count */
    uint32_t PC_SR_TLAT_L; /*!< (read-write) Performance Counter, Lower Slave
                              Read Latency Count */
    uint32_t PC_SW_TLAT_U; /*!< (read-write) Performance Counter, Upper Slave
                              Write Latency Count */
    uint32_t PC_SW_TLAT_L; /*!< (read-write) Performance Counter, Lower Slave
                              Write Latency Count */
    uint32_t PC_MR_TLAT_U; /*!< (read-write) Performance Counter, Upper Master
                              Read Latency Count */
    uint32_t PC_MR_TLAT_L; /*!< (read-write) Performance Counter, Lower Master
                              Read Latency Count */
    uint32_t PC_MW_TLAT_U; /*!< (read-write) Performance Counter, Upper Master
                              Write Latency Count */
    uint32_t PC_MW_TLAT_L; /*!< (read-write) Performance Counter, Lower Master
                              Write Latency Count */
    uint32_t PC_SR_TNRT_U; /*!< (read-write) Performance Counter, Upper Slave
                              Read Total Non-Responding Time */
    uint32_t PC_SR_TNRT_L; /*!< (read-write) Performance Counter, Lower Slave
                              Read Total Non-Responding Time */
    uint32_t PC_SW_TNRT_U; /*!< (read-write) Performance Counter, Upper Slave
                              Write Total Non-Responding Time */
    uint32_t PC_SW_TNRT_L; /*!< (read-write) Performance Counter, Lower Slave
                              Write Total Non-Responding Time */
    static constexpr std::size_t reserved_padding5_length = 8;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t VIDR1; /*!< (read-write) IEE Version ID Register 1 */
    const uint32_t reserved_padding6 = {};
    uint32_t AESVID; /*!< (read-write) IEE AES Version ID Register */
    static constexpr std::size_t REGx_length = 8;
    REGx_instance REGx[REGx_length]; /*!< Region Registers */
    static constexpr std::size_t reserved_padding7_length = 577;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    static constexpr std::size_t AES_TST_DB_length = 32;
    uint32_t AES_TST_DB[AES_TST_DB_length]; /*!< (read-write) IEE AES Test Mode
                                               Data Buffer */

    /* Methods. */

    /**
     * Set GCFG's RST bit.
     *
     * Reset bit
     */
    inline void set_GCFG_RST() volatile
    {
        GCFG |= 1u << 31u;
    }

    /**
     * Clear GCFG's RST bit.
     *
     * Reset bit
     */
    inline void clear_GCFG_RST() volatile
    {
        GCFG &= ~(1u << 31u);
    }

    /**
     * Toggle GCFG's RST bit.
     *
     * Reset bit
     */
    inline void toggle_GCFG_RST() volatile
    {
        GCFG ^= 1u << 31u;
    }

    /**
     * Set GCFG's CLR_MON bit.
     *
     * Clear monitor bit
     */
    inline void set_GCFG_CLR_MON() volatile
    {
        GCFG |= 1u << 29u;
    }

    /**
     * Clear GCFG's CLR_MON bit.
     *
     * Clear monitor bit
     */
    inline void clear_GCFG_CLR_MON() volatile
    {
        GCFG &= ~(1u << 29u);
    }

    /**
     * Toggle GCFG's CLR_MON bit.
     *
     * Clear monitor bit
     */
    inline void toggle_GCFG_CLR_MON() volatile
    {
        GCFG ^= 1u << 29u;
    }

    /**
     * Get GCFG's MON_EN bit.
     *
     * Monitor enable bit
     */
    inline bool get_GCFG_MON_EN() volatile
    {
        return GCFG & (1u << 28u);
    }

    /**
     * Set GCFG's MON_EN bit.
     *
     * Monitor enable bit
     */
    inline void set_GCFG_MON_EN() volatile
    {
        GCFG |= 1u << 28u;
    }

    /**
     * Clear GCFG's MON_EN bit.
     *
     * Monitor enable bit
     */
    inline void clear_GCFG_MON_EN() volatile
    {
        GCFG &= ~(1u << 28u);
    }

    /**
     * Toggle GCFG's MON_EN bit.
     *
     * Monitor enable bit
     */
    inline void toggle_GCFG_MON_EN() volatile
    {
        GCFG ^= 1u << 28u;
    }

    /**
     * Get GCFG's KEY_RD_DIS bit.
     *
     * Key read disable bit
     */
    inline bool get_GCFG_KEY_RD_DIS() volatile
    {
        return GCFG & (1u << 25u);
    }

    /**
     * Set GCFG's KEY_RD_DIS bit.
     *
     * Key read disable bit
     */
    inline void set_GCFG_KEY_RD_DIS() volatile
    {
        GCFG |= 1u << 25u;
    }

    /**
     * Clear GCFG's KEY_RD_DIS bit.
     *
     * Key read disable bit
     */
    inline void clear_GCFG_KEY_RD_DIS() volatile
    {
        GCFG &= ~(1u << 25u);
    }

    /**
     * Toggle GCFG's KEY_RD_DIS bit.
     *
     * Key read disable bit
     */
    inline void toggle_GCFG_KEY_RD_DIS() volatile
    {
        GCFG ^= 1u << 25u;
    }

    /**
     * Get GCFG's TMD bit.
     *
     * Test mode disable bit
     */
    inline bool get_GCFG_TMD() volatile
    {
        return GCFG & (1u << 17u);
    }

    /**
     * Set GCFG's TMD bit.
     *
     * Test mode disable bit
     */
    inline void set_GCFG_TMD() volatile
    {
        GCFG |= 1u << 17u;
    }

    /**
     * Clear GCFG's TMD bit.
     *
     * Test mode disable bit
     */
    inline void clear_GCFG_TMD() volatile
    {
        GCFG &= ~(1u << 17u);
    }

    /**
     * Toggle GCFG's TMD bit.
     *
     * Test mode disable bit
     */
    inline void toggle_GCFG_TMD() volatile
    {
        GCFG ^= 1u << 17u;
    }

    /**
     * Get GCFG's TME bit.
     *
     * Test mode enable bit
     */
    inline bool get_GCFG_TME() volatile
    {
        return GCFG & (1u << 16u);
    }

    /**
     * Set GCFG's TME bit.
     *
     * Test mode enable bit
     */
    inline void set_GCFG_TME() volatile
    {
        GCFG |= 1u << 16u;
    }

    /**
     * Clear GCFG's TME bit.
     *
     * Test mode enable bit
     */
    inline void clear_GCFG_TME() volatile
    {
        GCFG &= ~(1u << 16u);
    }

    /**
     * Toggle GCFG's TME bit.
     *
     * Test mode enable bit
     */
    inline void toggle_GCFG_TME() volatile
    {
        GCFG ^= 1u << 16u;
    }

    /**
     * Get GCFG's RL7 bit.
     *
     * Region lock 7 bit
     */
    inline bool get_GCFG_RL7() volatile
    {
        return GCFG & (1u << 7u);
    }

    /**
     * Set GCFG's RL7 bit.
     *
     * Region lock 7 bit
     */
    inline void set_GCFG_RL7() volatile
    {
        GCFG |= 1u << 7u;
    }

    /**
     * Clear GCFG's RL7 bit.
     *
     * Region lock 7 bit
     */
    inline void clear_GCFG_RL7() volatile
    {
        GCFG &= ~(1u << 7u);
    }

    /**
     * Toggle GCFG's RL7 bit.
     *
     * Region lock 7 bit
     */
    inline void toggle_GCFG_RL7() volatile
    {
        GCFG ^= 1u << 7u;
    }

    /**
     * Get GCFG's RL6 bit.
     *
     * Region lock 6 bit
     */
    inline bool get_GCFG_RL6() volatile
    {
        return GCFG & (1u << 6u);
    }

    /**
     * Set GCFG's RL6 bit.
     *
     * Region lock 6 bit
     */
    inline void set_GCFG_RL6() volatile
    {
        GCFG |= 1u << 6u;
    }

    /**
     * Clear GCFG's RL6 bit.
     *
     * Region lock 6 bit
     */
    inline void clear_GCFG_RL6() volatile
    {
        GCFG &= ~(1u << 6u);
    }

    /**
     * Toggle GCFG's RL6 bit.
     *
     * Region lock 6 bit
     */
    inline void toggle_GCFG_RL6() volatile
    {
        GCFG ^= 1u << 6u;
    }

    /**
     * Get GCFG's RL5 bit.
     *
     * Region lock 5 bit
     */
    inline bool get_GCFG_RL5() volatile
    {
        return GCFG & (1u << 5u);
    }

    /**
     * Set GCFG's RL5 bit.
     *
     * Region lock 5 bit
     */
    inline void set_GCFG_RL5() volatile
    {
        GCFG |= 1u << 5u;
    }

    /**
     * Clear GCFG's RL5 bit.
     *
     * Region lock 5 bit
     */
    inline void clear_GCFG_RL5() volatile
    {
        GCFG &= ~(1u << 5u);
    }

    /**
     * Toggle GCFG's RL5 bit.
     *
     * Region lock 5 bit
     */
    inline void toggle_GCFG_RL5() volatile
    {
        GCFG ^= 1u << 5u;
    }

    /**
     * Get GCFG's RL4 bit.
     *
     * Region lock 4 bit
     */
    inline bool get_GCFG_RL4() volatile
    {
        return GCFG & (1u << 4u);
    }

    /**
     * Set GCFG's RL4 bit.
     *
     * Region lock 4 bit
     */
    inline void set_GCFG_RL4() volatile
    {
        GCFG |= 1u << 4u;
    }

    /**
     * Clear GCFG's RL4 bit.
     *
     * Region lock 4 bit
     */
    inline void clear_GCFG_RL4() volatile
    {
        GCFG &= ~(1u << 4u);
    }

    /**
     * Toggle GCFG's RL4 bit.
     *
     * Region lock 4 bit
     */
    inline void toggle_GCFG_RL4() volatile
    {
        GCFG ^= 1u << 4u;
    }

    /**
     * Get GCFG's RL3 bit.
     *
     * Region lock 3 bit
     */
    inline bool get_GCFG_RL3() volatile
    {
        return GCFG & (1u << 3u);
    }

    /**
     * Set GCFG's RL3 bit.
     *
     * Region lock 3 bit
     */
    inline void set_GCFG_RL3() volatile
    {
        GCFG |= 1u << 3u;
    }

    /**
     * Clear GCFG's RL3 bit.
     *
     * Region lock 3 bit
     */
    inline void clear_GCFG_RL3() volatile
    {
        GCFG &= ~(1u << 3u);
    }

    /**
     * Toggle GCFG's RL3 bit.
     *
     * Region lock 3 bit
     */
    inline void toggle_GCFG_RL3() volatile
    {
        GCFG ^= 1u << 3u;
    }

    /**
     * Get GCFG's RL2 bit.
     *
     * Region lock 2 bit
     */
    inline bool get_GCFG_RL2() volatile
    {
        return GCFG & (1u << 2u);
    }

    /**
     * Set GCFG's RL2 bit.
     *
     * Region lock 2 bit
     */
    inline void set_GCFG_RL2() volatile
    {
        GCFG |= 1u << 2u;
    }

    /**
     * Clear GCFG's RL2 bit.
     *
     * Region lock 2 bit
     */
    inline void clear_GCFG_RL2() volatile
    {
        GCFG &= ~(1u << 2u);
    }

    /**
     * Toggle GCFG's RL2 bit.
     *
     * Region lock 2 bit
     */
    inline void toggle_GCFG_RL2() volatile
    {
        GCFG ^= 1u << 2u;
    }

    /**
     * Get GCFG's RL1 bit.
     *
     * Region lock 1 bit
     */
    inline bool get_GCFG_RL1() volatile
    {
        return GCFG & (1u << 1u);
    }

    /**
     * Set GCFG's RL1 bit.
     *
     * Region lock 1 bit
     */
    inline void set_GCFG_RL1() volatile
    {
        GCFG |= 1u << 1u;
    }

    /**
     * Clear GCFG's RL1 bit.
     *
     * Region lock 1 bit
     */
    inline void clear_GCFG_RL1() volatile
    {
        GCFG &= ~(1u << 1u);
    }

    /**
     * Toggle GCFG's RL1 bit.
     *
     * Region lock 1 bit
     */
    inline void toggle_GCFG_RL1() volatile
    {
        GCFG ^= 1u << 1u;
    }

    /**
     * Get GCFG's RL0 bit.
     *
     * Region lock 0 bit
     */
    inline bool get_GCFG_RL0() volatile
    {
        return GCFG & (1u << 0u);
    }

    /**
     * Set GCFG's RL0 bit.
     *
     * Region lock 0 bit
     */
    inline void set_GCFG_RL0() volatile
    {
        GCFG |= 1u << 0u;
    }

    /**
     * Clear GCFG's RL0 bit.
     *
     * Region lock 0 bit
     */
    inline void clear_GCFG_RL0() volatile
    {
        GCFG &= ~(1u << 0u);
    }

    /**
     * Toggle GCFG's RL0 bit.
     *
     * Region lock 0 bit
     */
    inline void toggle_GCFG_RL0() volatile
    {
        GCFG ^= 1u << 0u;
    }

    /**
     * Get all of GCFG's bit fields.
     *
     * (read-write) IEE Global Configuration
     */
    inline void get_GCFG(bool &MON_EN, bool &KEY_RD_DIS, bool &TMD, bool &TME,
                         bool &RL7, bool &RL6, bool &RL5, bool &RL4, bool &RL3,
                         bool &RL2, bool &RL1, bool &RL0) volatile
    {
        uint32_t curr = GCFG;

        MON_EN = curr & (1u << 28u);
        KEY_RD_DIS = curr & (1u << 25u);
        TMD = curr & (1u << 17u);
        TME = curr & (1u << 16u);
        RL7 = curr & (1u << 7u);
        RL6 = curr & (1u << 6u);
        RL5 = curr & (1u << 5u);
        RL4 = curr & (1u << 4u);
        RL3 = curr & (1u << 3u);
        RL2 = curr & (1u << 2u);
        RL1 = curr & (1u << 1u);
        RL0 = curr & (1u << 0u);
    }

    /**
     * Set all of GCFG's bit fields.
     *
     * (read-write) IEE Global Configuration
     */
    inline void set_GCFG(bool RST, bool CLR_MON, bool MON_EN, bool KEY_RD_DIS,
                         bool TMD, bool TME, bool RL7, bool RL6, bool RL5,
                         bool RL4, bool RL3, bool RL2, bool RL1,
                         bool RL0) volatile
    {
        uint32_t curr = GCFG;

        curr &= ~(0b1u << 31u);
        curr |= (RST & 0b1u) << 31u;
        curr &= ~(0b1u << 29u);
        curr |= (CLR_MON & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (MON_EN & 0b1u) << 28u;
        curr &= ~(0b1u << 25u);
        curr |= (KEY_RD_DIS & 0b1u) << 25u;
        curr &= ~(0b1u << 17u);
        curr |= (TMD & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (TME & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (RL7 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (RL6 & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RL5 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (RL4 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (RL3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (RL2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (RL1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RL0 & 0b1u) << 0u;

        GCFG = curr;
    }

    /**
     * Get STA's AFD bit.
     *
     * AES fault detected bit
     */
    inline bool get_STA_AFD() volatile
    {
        return STA & (1u << 4u);
    }

    /**
     * Get STA's DSR bit.
     *
     * DPA seed request bit
     */
    inline bool get_STA_DSR() volatile
    {
        return STA & (1u << 0u);
    }

    /**
     * Get all of STA's bit fields.
     *
     * (read-write) IEE Status
     */
    inline void get_STA(bool &AFD, bool &DSR) volatile
    {
        uint32_t curr = STA;

        AFD = curr & (1u << 4u);
        DSR = curr & (1u << 0u);
    }

    /**
     * Get TSTMD's TMLEN field.
     *
     * Test mode length field
     */
    inline uint8_t get_TSTMD_TMLEN() volatile
    {
        return (TSTMD >> 8u) & 0b1111u;
    }

    /**
     * Set TSTMD's TMLEN field.
     *
     * Test mode length field
     */
    inline void set_TSTMD_TMLEN(uint8_t value) volatile
    {
        uint32_t curr = TSTMD;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        TSTMD = curr;
    }

    /**
     * Get TSTMD's TMDONE bit.
     *
     * Test mode done bit
     */
    inline bool get_TSTMD_TMDONE() volatile
    {
        return TSTMD & (1u << 4u);
    }

    /**
     * Get TSTMD's TMCONT bit.
     *
     * Test mode continue bit. Set to indicate that operation will be followed
     * by more data.
     */
    inline bool get_TSTMD_TMCONT() volatile
    {
        return TSTMD & (1u << 3u);
    }

    /**
     * Set TSTMD's TMCONT bit.
     *
     * Test mode continue bit. Set to indicate that operation will be followed
     * by more data.
     */
    inline void set_TSTMD_TMCONT() volatile
    {
        TSTMD |= 1u << 3u;
    }

    /**
     * Clear TSTMD's TMCONT bit.
     *
     * Test mode continue bit. Set to indicate that operation will be followed
     * by more data.
     */
    inline void clear_TSTMD_TMCONT() volatile
    {
        TSTMD &= ~(1u << 3u);
    }

    /**
     * Toggle TSTMD's TMCONT bit.
     *
     * Test mode continue bit. Set to indicate that operation will be followed
     * by more data.
     */
    inline void toggle_TSTMD_TMCONT() volatile
    {
        TSTMD ^= 1u << 3u;
    }

    /**
     * Get TSTMD's TMENCR bit.
     *
     * Test mode encrypt/decrypt bit.
     */
    inline bool get_TSTMD_TMENCR() volatile
    {
        return TSTMD & (1u << 2u);
    }

    /**
     * Set TSTMD's TMENCR bit.
     *
     * Test mode encrypt/decrypt bit.
     */
    inline void set_TSTMD_TMENCR() volatile
    {
        TSTMD |= 1u << 2u;
    }

    /**
     * Clear TSTMD's TMENCR bit.
     *
     * Test mode encrypt/decrypt bit.
     */
    inline void clear_TSTMD_TMENCR() volatile
    {
        TSTMD &= ~(1u << 2u);
    }

    /**
     * Toggle TSTMD's TMENCR bit.
     *
     * Test mode encrypt/decrypt bit.
     */
    inline void toggle_TSTMD_TMENCR() volatile
    {
        TSTMD ^= 1u << 2u;
    }

    /**
     * Get TSTMD's TMR bit.
     *
     * Test mode run bit
     */
    inline bool get_TSTMD_TMR() volatile
    {
        return TSTMD & (1u << 1u);
    }

    /**
     * Set TSTMD's TMR bit.
     *
     * Test mode run bit
     */
    inline void set_TSTMD_TMR() volatile
    {
        TSTMD |= 1u << 1u;
    }

    /**
     * Clear TSTMD's TMR bit.
     *
     * Test mode run bit
     */
    inline void clear_TSTMD_TMR() volatile
    {
        TSTMD &= ~(1u << 1u);
    }

    /**
     * Toggle TSTMD's TMR bit.
     *
     * Test mode run bit
     */
    inline void toggle_TSTMD_TMR() volatile
    {
        TSTMD ^= 1u << 1u;
    }

    /**
     * Get TSTMD's TMRDY bit.
     *
     * Test mode ready bit. All AXI transactions have stopped and test can
     * begin.
     */
    inline bool get_TSTMD_TMRDY() volatile
    {
        return TSTMD & (1u << 0u);
    }

    /**
     * Get all of TSTMD's bit fields.
     *
     * (read-write) IEE Test Mode Register
     */
    inline void get_TSTMD(uint8_t &TMLEN, bool &TMDONE, bool &TMCONT,
                          bool &TMENCR, bool &TMR, bool &TMRDY) volatile
    {
        uint32_t curr = TSTMD;

        TMLEN = (curr >> 8u) & 0b1111u;
        TMDONE = curr & (1u << 4u);
        TMCONT = curr & (1u << 3u);
        TMENCR = curr & (1u << 2u);
        TMR = curr & (1u << 1u);
        TMRDY = curr & (1u << 0u);
    }

    /**
     * Set all of TSTMD's bit fields.
     *
     * (read-write) IEE Test Mode Register
     */
    inline void set_TSTMD(uint8_t TMLEN, bool TMCONT, bool TMENCR,
                          bool TMR) volatile
    {
        uint32_t curr = TSTMD;

        curr &= ~(0b1111u << 8u);
        curr |= (TMLEN & 0b1111u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (TMCONT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (TMENCR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (TMR & 0b1u) << 1u;

        TSTMD = curr;
    }

    /**
     * Set DPAMS's DPAMS field.
     *
     * DPA mask seed
     */
    inline void set_DPAMS_DPAMS(uint32_t value) volatile
    {
        uint32_t curr = DPAMS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        DPAMS = curr;
    }

    /**
     * Get PC_S_LT's SR_LT field.
     *
     * Slave read latency threshold in AXI clock cycles.
     */
    inline uint16_t get_PC_S_LT_SR_LT() volatile
    {
        return (PC_S_LT >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set PC_S_LT's SR_LT field.
     *
     * Slave read latency threshold in AXI clock cycles.
     */
    inline void set_PC_S_LT_SR_LT(uint16_t value) volatile
    {
        uint32_t curr = PC_S_LT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        PC_S_LT = curr;
    }

    /**
     * Get PC_S_LT's SW_LT field.
     *
     * Slave write latency threshold in AXI clock cycles.
     */
    inline uint16_t get_PC_S_LT_SW_LT() volatile
    {
        return (PC_S_LT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_S_LT's SW_LT field.
     *
     * Slave write latency threshold in AXI clock cycles.
     */
    inline void set_PC_S_LT_SW_LT(uint16_t value) volatile
    {
        uint32_t curr = PC_S_LT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_S_LT = curr;
    }

    /**
     * Get all of PC_S_LT's bit fields.
     *
     * (read-write) Performance Counter, AES Slave Latency Threshold Value
     */
    inline void get_PC_S_LT(uint16_t &SR_LT, uint16_t &SW_LT) volatile
    {
        uint32_t curr = PC_S_LT;

        SR_LT = (curr >> 16u) & 0b1111111111111111u;
        SW_LT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of PC_S_LT's bit fields.
     *
     * (read-write) Performance Counter, AES Slave Latency Threshold Value
     */
    inline void set_PC_S_LT(uint16_t SR_LT, uint16_t SW_LT) volatile
    {
        uint32_t curr = PC_S_LT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (SR_LT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (SW_LT & 0b1111111111111111u) << 0u;

        PC_S_LT = curr;
    }

    /**
     * Get PC_M_LT's MR_LT field.
     *
     * Master read latency threshold in AXI clock cycles.
     */
    inline uint16_t get_PC_M_LT_MR_LT() volatile
    {
        return (PC_M_LT >> 16u) & 0b111111111111u;
    }

    /**
     * Set PC_M_LT's MR_LT field.
     *
     * Master read latency threshold in AXI clock cycles.
     */
    inline void set_PC_M_LT_MR_LT(uint16_t value) volatile
    {
        uint32_t curr = PC_M_LT;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PC_M_LT = curr;
    }

    /**
     * Get PC_M_LT's MW_LT field.
     *
     * Master write latency threshold in AXI clock cycles.
     */
    inline uint16_t get_PC_M_LT_MW_LT() volatile
    {
        return (PC_M_LT >> 0u) & 0b111111111111u;
    }

    /**
     * Set PC_M_LT's MW_LT field.
     *
     * Master write latency threshold in AXI clock cycles.
     */
    inline void set_PC_M_LT_MW_LT(uint16_t value) volatile
    {
        uint32_t curr = PC_M_LT;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PC_M_LT = curr;
    }

    /**
     * Get all of PC_M_LT's bit fields.
     *
     * (read-write) Performance Counter, AES Master Latency Threshold
     */
    inline void get_PC_M_LT(uint16_t &MR_LT, uint16_t &MW_LT) volatile
    {
        uint32_t curr = PC_M_LT;

        MR_LT = (curr >> 16u) & 0b111111111111u;
        MW_LT = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PC_M_LT's bit fields.
     *
     * (read-write) Performance Counter, AES Master Latency Threshold
     */
    inline void set_PC_M_LT(uint16_t MR_LT, uint16_t MW_LT) volatile
    {
        uint32_t curr = PC_M_LT;

        curr &= ~(0b111111111111u << 16u);
        curr |= (MR_LT & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (MW_LT & 0b111111111111u) << 0u;

        PC_M_LT = curr;
    }

    /**
     * Get PC_BLK_ENC's BLK_ENC field.
     *
     * Number of AES block encryptions. Does not roll over if value maxes out.
     */
    inline uint32_t get_PC_BLK_ENC_BLK_ENC() volatile
    {
        return (PC_BLK_ENC >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_BLK_ENC's BLK_ENC field.
     *
     * Number of AES block encryptions. Does not roll over if value maxes out.
     */
    inline void set_PC_BLK_ENC_BLK_ENC(uint32_t value) volatile
    {
        uint32_t curr = PC_BLK_ENC;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_BLK_ENC = curr;
    }

    /**
     * Get PC_BLK_DEC's BLK_DEC field.
     *
     * Number of AES block decryptions. Does not roll over if value maxes out.
     */
    inline uint32_t get_PC_BLK_DEC_BLK_DEC() volatile
    {
        return (PC_BLK_DEC >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_BLK_DEC's BLK_DEC field.
     *
     * Number of AES block decryptions. Does not roll over if value maxes out.
     */
    inline void set_PC_BLK_DEC_BLK_DEC(uint32_t value) volatile
    {
        uint32_t curr = PC_BLK_DEC;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_BLK_DEC = curr;
    }

    /**
     * Get PC_SR_TRANS's SR_TRANS field.
     *
     * Number of slave read transactions.
     */
    inline uint32_t get_PC_SR_TRANS_SR_TRANS() volatile
    {
        return (PC_SR_TRANS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SR_TRANS's SR_TRANS field.
     *
     * Number of slave read transactions.
     */
    inline void set_PC_SR_TRANS_SR_TRANS(uint32_t value) volatile
    {
        uint32_t curr = PC_SR_TRANS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SR_TRANS = curr;
    }

    /**
     * Get PC_SW_TRANS's SW_TRANS field.
     *
     * Number of slave write transactions.
     */
    inline uint32_t get_PC_SW_TRANS_SW_TRANS() volatile
    {
        return (PC_SW_TRANS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SW_TRANS's SW_TRANS field.
     *
     * Number of slave write transactions.
     */
    inline void set_PC_SW_TRANS_SW_TRANS(uint32_t value) volatile
    {
        uint32_t curr = PC_SW_TRANS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SW_TRANS = curr;
    }

    /**
     * Get PC_MR_TRANS's MR_TRANS field.
     *
     * Number of master read transactions.
     */
    inline uint32_t get_PC_MR_TRANS_MR_TRANS() volatile
    {
        return (PC_MR_TRANS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_MR_TRANS's MR_TRANS field.
     *
     * Number of master read transactions.
     */
    inline void set_PC_MR_TRANS_MR_TRANS(uint32_t value) volatile
    {
        uint32_t curr = PC_MR_TRANS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_MR_TRANS = curr;
    }

    /**
     * Get PC_MW_TRANS's MW_TRANS field.
     *
     * Number of master write transactions.
     */
    inline uint32_t get_PC_MW_TRANS_MW_TRANS() volatile
    {
        return (PC_MW_TRANS >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_MW_TRANS's MW_TRANS field.
     *
     * Number of master write transactions.
     */
    inline void set_PC_MW_TRANS_MW_TRANS(uint32_t value) volatile
    {
        uint32_t curr = PC_MW_TRANS;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_MW_TRANS = curr;
    }

    /**
     * Get PC_M_MBR's M_MBR field.
     *
     * Number of master merge buffer read transactions.
     */
    inline uint32_t get_PC_M_MBR_M_MBR() volatile
    {
        return (PC_M_MBR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_M_MBR's M_MBR field.
     *
     * Number of master merge buffer read transactions.
     */
    inline void set_PC_M_MBR_M_MBR(uint32_t value) volatile
    {
        uint32_t curr = PC_M_MBR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_M_MBR = curr;
    }

    /**
     * Get PC_SR_TBC_U's SR_TBC field.
     *
     * Number of bytes in slave read transactions. Upper 16 bits of
     * SR_TBC[47:0].
     */
    inline uint16_t get_PC_SR_TBC_U_SR_TBC() volatile
    {
        return (PC_SR_TBC_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_SR_TBC_U's SR_TBC field.
     *
     * Number of bytes in slave read transactions. Upper 16 bits of
     * SR_TBC[47:0].
     */
    inline void set_PC_SR_TBC_U_SR_TBC(uint16_t value) volatile
    {
        uint32_t curr = PC_SR_TBC_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_SR_TBC_U = curr;
    }

    /**
     * Get PC_SR_TBC_L's SR_TBC field.
     *
     * Number of bytes in slave read transactions. Lower 32 bits of
     * SR_TBC[47:0].
     */
    inline uint32_t get_PC_SR_TBC_L_SR_TBC() volatile
    {
        return (PC_SR_TBC_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SR_TBC_L's SR_TBC field.
     *
     * Number of bytes in slave read transactions. Lower 32 bits of
     * SR_TBC[47:0].
     */
    inline void set_PC_SR_TBC_L_SR_TBC(uint32_t value) volatile
    {
        uint32_t curr = PC_SR_TBC_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SR_TBC_L = curr;
    }

    /**
     * Get PC_SW_TBC_U's SW_TBC field.
     *
     * Number of bytes in slave write transactions. Upper 16 bits of
     * SW_TBC[47:0].
     */
    inline uint16_t get_PC_SW_TBC_U_SW_TBC() volatile
    {
        return (PC_SW_TBC_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_SW_TBC_U's SW_TBC field.
     *
     * Number of bytes in slave write transactions. Upper 16 bits of
     * SW_TBC[47:0].
     */
    inline void set_PC_SW_TBC_U_SW_TBC(uint16_t value) volatile
    {
        uint32_t curr = PC_SW_TBC_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_SW_TBC_U = curr;
    }

    /**
     * Get PC_SW_TBC_L's SW_TBC field.
     *
     * Number of bytes in slave write transactions. Lower 32 bits of
     * SW_TBC[47:0].
     */
    inline uint32_t get_PC_SW_TBC_L_SW_TBC() volatile
    {
        return (PC_SW_TBC_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SW_TBC_L's SW_TBC field.
     *
     * Number of bytes in slave write transactions. Lower 32 bits of
     * SW_TBC[47:0].
     */
    inline void set_PC_SW_TBC_L_SW_TBC(uint32_t value) volatile
    {
        uint32_t curr = PC_SW_TBC_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SW_TBC_L = curr;
    }

    /**
     * Get PC_MR_TBC_U's MR_TBC field.
     *
     * Number of bytes in master read transactions. 44 MSBs. Upper 16 bits of
     * MR_TBC[43:0].
     */
    inline uint16_t get_PC_MR_TBC_U_MR_TBC() volatile
    {
        return (PC_MR_TBC_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_MR_TBC_U's MR_TBC field.
     *
     * Number of bytes in master read transactions. 44 MSBs. Upper 16 bits of
     * MR_TBC[43:0].
     */
    inline void set_PC_MR_TBC_U_MR_TBC(uint16_t value) volatile
    {
        uint32_t curr = PC_MR_TBC_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_MR_TBC_U = curr;
    }

    /**
     * Get PC_MR_TBC_L's MR_TBC field.
     *
     * Number of bytes in master read transactions. 44 MSBs. Lower 28 bits of
     * MR_TBC[43:0].
     */
    inline uint32_t get_PC_MR_TBC_L_MR_TBC() volatile
    {
        return (PC_MR_TBC_L >> 4u) & 0b1111111111111111111111111111u;
    }

    /**
     * Set PC_MR_TBC_L's MR_TBC field.
     *
     * Number of bytes in master read transactions. 44 MSBs. Lower 28 bits of
     * MR_TBC[43:0].
     */
    inline void set_PC_MR_TBC_L_MR_TBC(uint32_t value) volatile
    {
        uint32_t curr = PC_MR_TBC_L;

        curr &= ~(0b1111111111111111111111111111u << 4u);
        curr |= (value & 0b1111111111111111111111111111u) << 4u;

        PC_MR_TBC_L = curr;
    }

    /**
     * Get PC_MR_TBC_L's MR_TBC_LSB field.
     *
     * Number of bytes in master read transactions. 4 LSBs, always 0.
     */
    inline uint8_t get_PC_MR_TBC_L_MR_TBC_LSB() volatile
    {
        return (PC_MR_TBC_L >> 0u) & 0b1111u;
    }

    /**
     * Get all of PC_MR_TBC_L's bit fields.
     *
     * (read-write) Performance Counter, Lower Master Read Transactions Byte
     * Count
     */
    inline void get_PC_MR_TBC_L(uint32_t &MR_TBC, uint8_t &MR_TBC_LSB) volatile
    {
        uint32_t curr = PC_MR_TBC_L;

        MR_TBC = (curr >> 4u) & 0b1111111111111111111111111111u;
        MR_TBC_LSB = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get PC_MW_TBC_U's MW_TBC field.
     *
     * Number of bytes in master write transactions. 44 MSBs. Upper 16 bits of
     * MW_TBC[43:0].
     */
    inline uint16_t get_PC_MW_TBC_U_MW_TBC() volatile
    {
        return (PC_MW_TBC_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_MW_TBC_U's MW_TBC field.
     *
     * Number of bytes in master write transactions. 44 MSBs. Upper 16 bits of
     * MW_TBC[43:0].
     */
    inline void set_PC_MW_TBC_U_MW_TBC(uint16_t value) volatile
    {
        uint32_t curr = PC_MW_TBC_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_MW_TBC_U = curr;
    }

    /**
     * Get PC_MW_TBC_L's MW_TBC field.
     *
     * Number of bytes in master write transactions. 44 MSBs. Lower 28 bits of
     * MR_TBC[43:0].
     */
    inline uint32_t get_PC_MW_TBC_L_MW_TBC() volatile
    {
        return (PC_MW_TBC_L >> 4u) & 0b1111111111111111111111111111u;
    }

    /**
     * Set PC_MW_TBC_L's MW_TBC field.
     *
     * Number of bytes in master write transactions. 44 MSBs. Lower 28 bits of
     * MR_TBC[43:0].
     */
    inline void set_PC_MW_TBC_L_MW_TBC(uint32_t value) volatile
    {
        uint32_t curr = PC_MW_TBC_L;

        curr &= ~(0b1111111111111111111111111111u << 4u);
        curr |= (value & 0b1111111111111111111111111111u) << 4u;

        PC_MW_TBC_L = curr;
    }

    /**
     * Get PC_MW_TBC_L's MW_TBC_LSB field.
     *
     * Number of bytes in master write transactions. 4 LSBs, always 0.
     */
    inline uint8_t get_PC_MW_TBC_L_MW_TBC_LSB() volatile
    {
        return (PC_MW_TBC_L >> 0u) & 0b1111u;
    }

    /**
     * Get all of PC_MW_TBC_L's bit fields.
     *
     * (read-write) Performance Counter, Lower Master Write Transactions Byte
     * Count
     */
    inline void get_PC_MW_TBC_L(uint32_t &MW_TBC, uint8_t &MW_TBC_LSB) volatile
    {
        uint32_t curr = PC_MW_TBC_L;

        MW_TBC = (curr >> 4u) & 0b1111111111111111111111111111u;
        MW_TBC_LSB = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get PC_SR_TLGTT's SR_TLGTT field.
     *
     * Number of slave read transactions with latency greater than the
     * threshold.
     */
    inline uint32_t get_PC_SR_TLGTT_SR_TLGTT() volatile
    {
        return (PC_SR_TLGTT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SR_TLGTT's SR_TLGTT field.
     *
     * Number of slave read transactions with latency greater than the
     * threshold.
     */
    inline void set_PC_SR_TLGTT_SR_TLGTT(uint32_t value) volatile
    {
        uint32_t curr = PC_SR_TLGTT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SR_TLGTT = curr;
    }

    /**
     * Get PC_SW_TLGTT's SW_TLGTT field.
     *
     * Number of slave write transactions with latency greater than the
     * threshold.
     */
    inline uint32_t get_PC_SW_TLGTT_SW_TLGTT() volatile
    {
        return (PC_SW_TLGTT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SW_TLGTT's SW_TLGTT field.
     *
     * Number of slave write transactions with latency greater than the
     * threshold.
     */
    inline void set_PC_SW_TLGTT_SW_TLGTT(uint32_t value) volatile
    {
        uint32_t curr = PC_SW_TLGTT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SW_TLGTT = curr;
    }

    /**
     * Get PC_MR_TLGTT's MR_TLGTT field.
     *
     * Number of master read transactions with latency greater than the
     * threshold.
     */
    inline uint32_t get_PC_MR_TLGTT_MR_TLGTT() volatile
    {
        return (PC_MR_TLGTT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_MR_TLGTT's MR_TLGTT field.
     *
     * Number of master read transactions with latency greater than the
     * threshold.
     */
    inline void set_PC_MR_TLGTT_MR_TLGTT(uint32_t value) volatile
    {
        uint32_t curr = PC_MR_TLGTT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_MR_TLGTT = curr;
    }

    /**
     * Get PC_MW_TLGTT's MW_TGTT field.
     *
     * Number of master write transactions with latency greater than the
     * threshold.
     */
    inline uint32_t get_PC_MW_TLGTT_MW_TGTT() volatile
    {
        return (PC_MW_TLGTT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_MW_TLGTT's MW_TGTT field.
     *
     * Number of master write transactions with latency greater than the
     * threshold.
     */
    inline void set_PC_MW_TLGTT_MW_TGTT(uint32_t value) volatile
    {
        uint32_t curr = PC_MW_TLGTT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_MW_TLGTT = curr;
    }

    /**
     * Get PC_SR_TLAT_U's SR_TLAT field.
     *
     * Total slave read latency in AXI clock cycles. Upper 16 bits of
     * SR_TLAT[47:0].
     */
    inline uint16_t get_PC_SR_TLAT_U_SR_TLAT() volatile
    {
        return (PC_SR_TLAT_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_SR_TLAT_U's SR_TLAT field.
     *
     * Total slave read latency in AXI clock cycles. Upper 16 bits of
     * SR_TLAT[47:0].
     */
    inline void set_PC_SR_TLAT_U_SR_TLAT(uint16_t value) volatile
    {
        uint32_t curr = PC_SR_TLAT_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_SR_TLAT_U = curr;
    }

    /**
     * Get PC_SR_TLAT_L's SR_TLAT field.
     *
     * Total slave read latency in AXI clock cycles. Lower 32 bits of
     * SR_TLAT[47:0].
     */
    inline uint32_t get_PC_SR_TLAT_L_SR_TLAT() volatile
    {
        return (PC_SR_TLAT_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SR_TLAT_L's SR_TLAT field.
     *
     * Total slave read latency in AXI clock cycles. Lower 32 bits of
     * SR_TLAT[47:0].
     */
    inline void set_PC_SR_TLAT_L_SR_TLAT(uint32_t value) volatile
    {
        uint32_t curr = PC_SR_TLAT_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SR_TLAT_L = curr;
    }

    /**
     * Get PC_SW_TLAT_U's SW_TLAT field.
     *
     * Total slave write latency in AXI clock cycles. Upper 16 bits of
     * SW_TLAT[47:0].
     */
    inline uint16_t get_PC_SW_TLAT_U_SW_TLAT() volatile
    {
        return (PC_SW_TLAT_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_SW_TLAT_U's SW_TLAT field.
     *
     * Total slave write latency in AXI clock cycles. Upper 16 bits of
     * SW_TLAT[47:0].
     */
    inline void set_PC_SW_TLAT_U_SW_TLAT(uint16_t value) volatile
    {
        uint32_t curr = PC_SW_TLAT_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_SW_TLAT_U = curr;
    }

    /**
     * Get PC_SW_TLAT_L's SW_TLAT field.
     *
     * Total slave write latency in AXI clock cycles. Lower 32 bits of
     * SW_TLAT[47:0].
     */
    inline uint32_t get_PC_SW_TLAT_L_SW_TLAT() volatile
    {
        return (PC_SW_TLAT_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SW_TLAT_L's SW_TLAT field.
     *
     * Total slave write latency in AXI clock cycles. Lower 32 bits of
     * SW_TLAT[47:0].
     */
    inline void set_PC_SW_TLAT_L_SW_TLAT(uint32_t value) volatile
    {
        uint32_t curr = PC_SW_TLAT_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SW_TLAT_L = curr;
    }

    /**
     * Get PC_MR_TLAT_U's MR_TLAT field.
     *
     * Total master read latency in AXI clock cycles. Upper 16 bits of
     * MR_TLAT[47:0].
     */
    inline uint16_t get_PC_MR_TLAT_U_MR_TLAT() volatile
    {
        return (PC_MR_TLAT_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_MR_TLAT_U's MR_TLAT field.
     *
     * Total master read latency in AXI clock cycles. Upper 16 bits of
     * MR_TLAT[47:0].
     */
    inline void set_PC_MR_TLAT_U_MR_TLAT(uint16_t value) volatile
    {
        uint32_t curr = PC_MR_TLAT_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_MR_TLAT_U = curr;
    }

    /**
     * Get PC_MR_TLAT_L's MR_TLAT field.
     *
     * Total master read latency in AXI clock cycles. Lower 32 bits of
     * MR_TLAT[47:0].
     */
    inline uint32_t get_PC_MR_TLAT_L_MR_TLAT() volatile
    {
        return (PC_MR_TLAT_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_MR_TLAT_L's MR_TLAT field.
     *
     * Total master read latency in AXI clock cycles. Lower 32 bits of
     * MR_TLAT[47:0].
     */
    inline void set_PC_MR_TLAT_L_MR_TLAT(uint32_t value) volatile
    {
        uint32_t curr = PC_MR_TLAT_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_MR_TLAT_L = curr;
    }

    /**
     * Get PC_MW_TLAT_U's MW_TLAT field.
     *
     * Total master write latency in AXI clock cycles. Upper 16 bits of
     * MW_TLAT[47:0].
     */
    inline uint16_t get_PC_MW_TLAT_U_MW_TLAT() volatile
    {
        return (PC_MW_TLAT_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_MW_TLAT_U's MW_TLAT field.
     *
     * Total master write latency in AXI clock cycles. Upper 16 bits of
     * MW_TLAT[47:0].
     */
    inline void set_PC_MW_TLAT_U_MW_TLAT(uint16_t value) volatile
    {
        uint32_t curr = PC_MW_TLAT_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_MW_TLAT_U = curr;
    }

    /**
     * Get PC_MW_TLAT_L's MW_TLAT field.
     *
     * Total master write latency in AXI clock cycles. Lower 32 bits of
     * MW_TLAT[47:0].
     */
    inline uint32_t get_PC_MW_TLAT_L_MW_TLAT() volatile
    {
        return (PC_MW_TLAT_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_MW_TLAT_L's MW_TLAT field.
     *
     * Total master write latency in AXI clock cycles. Lower 32 bits of
     * MW_TLAT[47:0].
     */
    inline void set_PC_MW_TLAT_L_MW_TLAT(uint32_t value) volatile
    {
        uint32_t curr = PC_MW_TLAT_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_MW_TLAT_L = curr;
    }

    /**
     * Get PC_SR_TNRT_U's SR_TNRT field.
     *
     * Total slave read non-responding time in AXI clock cycles. Upper 16 bits
     * of SR_TNRT[47:0].
     */
    inline uint16_t get_PC_SR_TNRT_U_SR_TNRT() volatile
    {
        return (PC_SR_TNRT_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_SR_TNRT_U's SR_TNRT field.
     *
     * Total slave read non-responding time in AXI clock cycles. Upper 16 bits
     * of SR_TNRT[47:0].
     */
    inline void set_PC_SR_TNRT_U_SR_TNRT(uint16_t value) volatile
    {
        uint32_t curr = PC_SR_TNRT_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_SR_TNRT_U = curr;
    }

    /**
     * Get PC_SR_TNRT_L's SR_TNRT field.
     *
     * Total slave read non-responding time in AXI clock cycles. Lower 32 bits
     * of SR_TNRT[47:0].
     */
    inline uint32_t get_PC_SR_TNRT_L_SR_TNRT() volatile
    {
        return (PC_SR_TNRT_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SR_TNRT_L's SR_TNRT field.
     *
     * Total slave read non-responding time in AXI clock cycles. Lower 32 bits
     * of SR_TNRT[47:0].
     */
    inline void set_PC_SR_TNRT_L_SR_TNRT(uint32_t value) volatile
    {
        uint32_t curr = PC_SR_TNRT_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SR_TNRT_L = curr;
    }

    /**
     * Get PC_SW_TNRT_U's SW_TNRT field.
     *
     * Total slave write non-responding time in AXI clock cycles. Upper 16 bits
     * of SW_TNRT[47:0].
     */
    inline uint16_t get_PC_SW_TNRT_U_SW_TNRT() volatile
    {
        return (PC_SW_TNRT_U >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PC_SW_TNRT_U's SW_TNRT field.
     *
     * Total slave write non-responding time in AXI clock cycles. Upper 16 bits
     * of SW_TNRT[47:0].
     */
    inline void set_PC_SW_TNRT_U_SW_TNRT(uint16_t value) volatile
    {
        uint32_t curr = PC_SW_TNRT_U;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PC_SW_TNRT_U = curr;
    }

    /**
     * Get PC_SW_TNRT_L's SW_TNRT field.
     *
     * Total slave write non-responding time in AXI clock cycles. Lower 32 bits
     * of SW_TNRT[47:0].
     */
    inline uint32_t get_PC_SW_TNRT_L_SW_TNRT() volatile
    {
        return (PC_SW_TNRT_L >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PC_SW_TNRT_L's SW_TNRT field.
     *
     * Total slave write non-responding time in AXI clock cycles. Lower 32 bits
     * of SW_TNRT[47:0].
     */
    inline void set_PC_SW_TNRT_L_SW_TNRT(uint32_t value) volatile
    {
        uint32_t curr = PC_SW_TNRT_L;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PC_SW_TNRT_L = curr;
    }

    /**
     * Get VIDR1's IP_ID field.
     *
     * ID for IEE.
     */
    inline uint16_t get_VIDR1_IP_ID() volatile
    {
        return (VIDR1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get VIDR1's MAJ_REV field.
     *
     * Major revision number for IEE.
     */
    inline uint8_t get_VIDR1_MAJ_REV() volatile
    {
        return (VIDR1 >> 8u) & 0b11111111u;
    }

    /**
     * Get VIDR1's MIN_REV field.
     *
     * Minor revision number for IEE.
     */
    inline uint8_t get_VIDR1_MIN_REV() volatile
    {
        return (VIDR1 >> 0u) & 0b11111111u;
    }

    /**
     * Get all of VIDR1's bit fields.
     *
     * (read-write) IEE Version ID Register 1
     */
    inline void get_VIDR1(uint16_t &IP_ID, uint8_t &MAJ_REV,
                          uint8_t &MIN_REV) volatile
    {
        uint32_t curr = VIDR1;

        IP_ID = (curr >> 16u) & 0b1111111111111111u;
        MAJ_REV = (curr >> 8u) & 0b11111111u;
        MIN_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get AESVID's AESVID field.
     *
     * AES version ID.
     */
    inline uint8_t get_AESVID_AESVID() volatile
    {
        return (AESVID >> 4u) & 0b1111u;
    }

    /**
     * Get AESVID's AESRN field.
     *
     * AES revision number.
     */
    inline uint8_t get_AESVID_AESRN() volatile
    {
        return (AESVID >> 0u) & 0b1111u;
    }

    /**
     * Get all of AESVID's bit fields.
     *
     * (read-write) IEE AES Version ID Register
     */
    inline void get_AESVID(uint8_t &AESVID, uint8_t &AESRN) volatile
    {
        uint32_t curr = AESVID;

        AESVID = (curr >> 4u) & 0b1111u;
        AESRN = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get AES_TST_DB's AES_TST_DB0 field.
     *
     * AES test mode data buffer.
     */
    inline uint32_t get_AES_TST_DB_AES_TST_DB0(std::size_t index) volatile
    {
        return (AES_TST_DB[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set AES_TST_DB's AES_TST_DB0 field.
     *
     * AES test mode data buffer.
     */
    inline void set_AES_TST_DB_AES_TST_DB0(std::size_t index,
                                           uint32_t value) volatile
    {
        uint32_t curr = AES_TST_DB[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        AES_TST_DB[index] = curr;
    }
};

static_assert(sizeof(iee__iee_rt1170) == iee__iee_rt1170::size);

static volatile iee__iee_rt1170 *const IEE__IEE_RT1170 =
    reinterpret_cast<iee__iee_rt1170 *>(0x4006C000);

}; // namespace MIMXRT1176::CM7
