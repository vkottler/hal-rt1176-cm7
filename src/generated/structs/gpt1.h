/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/GPT1_CR_CLKSRC.h"
#include "../enums/GPT1_CR_IM1.h"
#include "../enums/GPT1_CR_IM2.h"
#include "../enums/GPT1_CR_OM1.h"
#include "../enums/GPT1_CR_OM2.h"
#include "../enums/GPT1_CR_OM3.h"
#include "../enums/GPT1_PR_PRESCALER.h"
#include "../enums/GPT1_PR_PRESCALER24M.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * GPT
 */
struct [[gnu::packed]] gpt1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 40; /*!< gpt1's size in bytes. */

    /* Fields. */
    uint32_t CR; /*!< (read-write) GPT Control Register */
    uint32_t PR; /*!< (read-write) GPT Prescaler Register */
    uint32_t SR; /*!< (read-write) GPT Status Register */
    uint32_t IR; /*!< (read-write) GPT Interrupt Register */
    static constexpr std::size_t OCR_length = 3;
    uint32_t OCR[OCR_length]; /*!< (read-write) GPT Output Compare Register */
    static constexpr std::size_t ICR_length = 2;
    uint32_t ICR[ICR_length]; /*!< (read-write) GPT Input Capture Register */
    uint32_t CNT;             /*!< (read-write) GPT Counter Register */

    /* Methods. */

    /**
     * Get CR's FO3 bit.
     *
     * Force Output Compare for Channel 3
     */
    inline bool get_CR_FO3() volatile
    {
        return CR & (1u << 31u);
    }

    /**
     * Set CR's FO3 bit.
     *
     * Force Output Compare for Channel 3
     */
    inline void set_CR_FO3() volatile
    {
        CR |= 1u << 31u;
    }

    /**
     * Clear CR's FO3 bit.
     *
     * Force Output Compare for Channel 3
     */
    inline void clear_CR_FO3() volatile
    {
        CR &= ~(1u << 31u);
    }

    /**
     * Toggle CR's FO3 bit.
     *
     * Force Output Compare for Channel 3
     */
    inline void toggle_CR_FO3() volatile
    {
        CR ^= 1u << 31u;
    }

    /**
     * Get CR's FO2 bit.
     *
     * Force Output Compare for Channel 2
     */
    inline bool get_CR_FO2() volatile
    {
        return CR & (1u << 30u);
    }

    /**
     * Set CR's FO2 bit.
     *
     * Force Output Compare for Channel 2
     */
    inline void set_CR_FO2() volatile
    {
        CR |= 1u << 30u;
    }

    /**
     * Clear CR's FO2 bit.
     *
     * Force Output Compare for Channel 2
     */
    inline void clear_CR_FO2() volatile
    {
        CR &= ~(1u << 30u);
    }

    /**
     * Toggle CR's FO2 bit.
     *
     * Force Output Compare for Channel 2
     */
    inline void toggle_CR_FO2() volatile
    {
        CR ^= 1u << 30u;
    }

    /**
     * Get CR's FO1 bit.
     *
     * Force Output Compare for Channel 1
     */
    inline bool get_CR_FO1() volatile
    {
        return CR & (1u << 29u);
    }

    /**
     * Set CR's FO1 bit.
     *
     * Force Output Compare for Channel 1
     */
    inline void set_CR_FO1() volatile
    {
        CR |= 1u << 29u;
    }

    /**
     * Clear CR's FO1 bit.
     *
     * Force Output Compare for Channel 1
     */
    inline void clear_CR_FO1() volatile
    {
        CR &= ~(1u << 29u);
    }

    /**
     * Toggle CR's FO1 bit.
     *
     * Force Output Compare for Channel 1
     */
    inline void toggle_CR_FO1() volatile
    {
        CR ^= 1u << 29u;
    }

    /**
     * Get CR's OM3 field.
     *
     * Output Compare Operating Mode for Channel 3
     */
    inline GPT1_CR_OM3 get_CR_OM3() volatile
    {
        return GPT1_CR_OM3((CR >> 26u) & 0b111u);
    }

    /**
     * Set CR's OM3 field.
     *
     * Output Compare Operating Mode for Channel 3
     */
    inline void set_CR_OM3(GPT1_CR_OM3 value) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b111u << 26u);
        curr |= (std::to_underlying(value) & 0b111u) << 26u;

        CR = curr;
    }

    /**
     * Get CR's OM2 field.
     *
     * Output Compare Operating Mode for Channel 2
     */
    inline GPT1_CR_OM2 get_CR_OM2() volatile
    {
        return GPT1_CR_OM2((CR >> 23u) & 0b111u);
    }

    /**
     * Set CR's OM2 field.
     *
     * Output Compare Operating Mode for Channel 2
     */
    inline void set_CR_OM2(GPT1_CR_OM2 value) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b111u << 23u);
        curr |= (std::to_underlying(value) & 0b111u) << 23u;

        CR = curr;
    }

    /**
     * Get CR's OM1 field.
     *
     * Output Compare Operating Mode for Channel 1
     */
    inline GPT1_CR_OM1 get_CR_OM1() volatile
    {
        return GPT1_CR_OM1((CR >> 20u) & 0b111u);
    }

    /**
     * Set CR's OM1 field.
     *
     * Output Compare Operating Mode for Channel 1
     */
    inline void set_CR_OM1(GPT1_CR_OM1 value) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(value) & 0b111u) << 20u;

        CR = curr;
    }

    /**
     * Get CR's IM2 field.
     *
     * Input Capture Operating Mode for Channel 2
     */
    inline GPT1_CR_IM2 get_CR_IM2() volatile
    {
        return GPT1_CR_IM2((CR >> 18u) & 0b11u);
    }

    /**
     * Set CR's IM2 field.
     *
     * Input Capture Operating Mode for Channel 2
     */
    inline void set_CR_IM2(GPT1_CR_IM2 value) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(value) & 0b11u) << 18u;

        CR = curr;
    }

    /**
     * Get CR's IM1 field.
     *
     * Input Capture Operating Mode for Channel 1
     */
    inline GPT1_CR_IM1 get_CR_IM1() volatile
    {
        return GPT1_CR_IM1((CR >> 16u) & 0b11u);
    }

    /**
     * Set CR's IM1 field.
     *
     * Input Capture Operating Mode for Channel 1
     */
    inline void set_CR_IM1(GPT1_CR_IM1 value) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        CR = curr;
    }

    /**
     * Get CR's SWR bit.
     *
     * Software Reset
     */
    inline bool get_CR_SWR() volatile
    {
        return CR & (1u << 15u);
    }

    /**
     * Set CR's SWR bit.
     *
     * Software Reset
     */
    inline void set_CR_SWR() volatile
    {
        CR |= 1u << 15u;
    }

    /**
     * Clear CR's SWR bit.
     *
     * Software Reset
     */
    inline void clear_CR_SWR() volatile
    {
        CR &= ~(1u << 15u);
    }

    /**
     * Toggle CR's SWR bit.
     *
     * Software Reset
     */
    inline void toggle_CR_SWR() volatile
    {
        CR ^= 1u << 15u;
    }

    /**
     * Get CR's EN_24M bit.
     *
     * Enable Oscillator Clock Input
     */
    inline bool get_CR_EN_24M() volatile
    {
        return CR & (1u << 10u);
    }

    /**
     * Set CR's EN_24M bit.
     *
     * Enable Oscillator Clock Input
     */
    inline void set_CR_EN_24M() volatile
    {
        CR |= 1u << 10u;
    }

    /**
     * Clear CR's EN_24M bit.
     *
     * Enable Oscillator Clock Input
     */
    inline void clear_CR_EN_24M() volatile
    {
        CR &= ~(1u << 10u);
    }

    /**
     * Toggle CR's EN_24M bit.
     *
     * Enable Oscillator Clock Input
     */
    inline void toggle_CR_EN_24M() volatile
    {
        CR ^= 1u << 10u;
    }

    /**
     * Get CR's FRR bit.
     *
     * Free-Run or Restart Mode
     */
    inline bool get_CR_FRR() volatile
    {
        return CR & (1u << 9u);
    }

    /**
     * Set CR's FRR bit.
     *
     * Free-Run or Restart Mode
     */
    inline void set_CR_FRR() volatile
    {
        CR |= 1u << 9u;
    }

    /**
     * Clear CR's FRR bit.
     *
     * Free-Run or Restart Mode
     */
    inline void clear_CR_FRR() volatile
    {
        CR &= ~(1u << 9u);
    }

    /**
     * Toggle CR's FRR bit.
     *
     * Free-Run or Restart Mode
     */
    inline void toggle_CR_FRR() volatile
    {
        CR ^= 1u << 9u;
    }

    /**
     * Get CR's CLKSRC field.
     *
     * Clock Source Select
     */
    inline GPT1_CR_CLKSRC get_CR_CLKSRC() volatile
    {
        return GPT1_CR_CLKSRC((CR >> 6u) & 0b111u);
    }

    /**
     * Set CR's CLKSRC field.
     *
     * Clock Source Select
     */
    inline void set_CR_CLKSRC(GPT1_CR_CLKSRC value) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b111u << 6u);
        curr |= (std::to_underlying(value) & 0b111u) << 6u;

        CR = curr;
    }

    /**
     * Get CR's STOPEN bit.
     *
     * GPT Stop Mode Enable
     */
    inline bool get_CR_STOPEN() volatile
    {
        return CR & (1u << 5u);
    }

    /**
     * Set CR's STOPEN bit.
     *
     * GPT Stop Mode Enable
     */
    inline void set_CR_STOPEN() volatile
    {
        CR |= 1u << 5u;
    }

    /**
     * Clear CR's STOPEN bit.
     *
     * GPT Stop Mode Enable
     */
    inline void clear_CR_STOPEN() volatile
    {
        CR &= ~(1u << 5u);
    }

    /**
     * Toggle CR's STOPEN bit.
     *
     * GPT Stop Mode Enable
     */
    inline void toggle_CR_STOPEN() volatile
    {
        CR ^= 1u << 5u;
    }

    /**
     * Get CR's DOZEEN bit.
     *
     * GPT Doze Mode Enable
     */
    inline bool get_CR_DOZEEN() volatile
    {
        return CR & (1u << 4u);
    }

    /**
     * Set CR's DOZEEN bit.
     *
     * GPT Doze Mode Enable
     */
    inline void set_CR_DOZEEN() volatile
    {
        CR |= 1u << 4u;
    }

    /**
     * Clear CR's DOZEEN bit.
     *
     * GPT Doze Mode Enable
     */
    inline void clear_CR_DOZEEN() volatile
    {
        CR &= ~(1u << 4u);
    }

    /**
     * Toggle CR's DOZEEN bit.
     *
     * GPT Doze Mode Enable
     */
    inline void toggle_CR_DOZEEN() volatile
    {
        CR ^= 1u << 4u;
    }

    /**
     * Get CR's WAITEN bit.
     *
     * GPT Wait Mode Enable
     */
    inline bool get_CR_WAITEN() volatile
    {
        return CR & (1u << 3u);
    }

    /**
     * Set CR's WAITEN bit.
     *
     * GPT Wait Mode Enable
     */
    inline void set_CR_WAITEN() volatile
    {
        CR |= 1u << 3u;
    }

    /**
     * Clear CR's WAITEN bit.
     *
     * GPT Wait Mode Enable
     */
    inline void clear_CR_WAITEN() volatile
    {
        CR &= ~(1u << 3u);
    }

    /**
     * Toggle CR's WAITEN bit.
     *
     * GPT Wait Mode Enable
     */
    inline void toggle_CR_WAITEN() volatile
    {
        CR ^= 1u << 3u;
    }

    /**
     * Get CR's DBGEN bit.
     *
     * GPT Debug Mode Enable
     */
    inline bool get_CR_DBGEN() volatile
    {
        return CR & (1u << 2u);
    }

    /**
     * Set CR's DBGEN bit.
     *
     * GPT Debug Mode Enable
     */
    inline void set_CR_DBGEN() volatile
    {
        CR |= 1u << 2u;
    }

    /**
     * Clear CR's DBGEN bit.
     *
     * GPT Debug Mode Enable
     */
    inline void clear_CR_DBGEN() volatile
    {
        CR &= ~(1u << 2u);
    }

    /**
     * Toggle CR's DBGEN bit.
     *
     * GPT Debug Mode Enable
     */
    inline void toggle_CR_DBGEN() volatile
    {
        CR ^= 1u << 2u;
    }

    /**
     * Get CR's ENMOD bit.
     *
     * GPT Enable Mode
     */
    inline bool get_CR_ENMOD() volatile
    {
        return CR & (1u << 1u);
    }

    /**
     * Set CR's ENMOD bit.
     *
     * GPT Enable Mode
     */
    inline void set_CR_ENMOD() volatile
    {
        CR |= 1u << 1u;
    }

    /**
     * Clear CR's ENMOD bit.
     *
     * GPT Enable Mode
     */
    inline void clear_CR_ENMOD() volatile
    {
        CR &= ~(1u << 1u);
    }

    /**
     * Toggle CR's ENMOD bit.
     *
     * GPT Enable Mode
     */
    inline void toggle_CR_ENMOD() volatile
    {
        CR ^= 1u << 1u;
    }

    /**
     * Get CR's EN bit.
     *
     * GPT Enable
     */
    inline bool get_CR_EN() volatile
    {
        return CR & (1u << 0u);
    }

    /**
     * Set CR's EN bit.
     *
     * GPT Enable
     */
    inline void set_CR_EN() volatile
    {
        CR |= 1u << 0u;
    }

    /**
     * Clear CR's EN bit.
     *
     * GPT Enable
     */
    inline void clear_CR_EN() volatile
    {
        CR &= ~(1u << 0u);
    }

    /**
     * Toggle CR's EN bit.
     *
     * GPT Enable
     */
    inline void toggle_CR_EN() volatile
    {
        CR ^= 1u << 0u;
    }

    /**
     * Get all of CR's bit fields.
     *
     * (read-write) GPT Control Register
     */
    inline void get_CR(bool &FO3, bool &FO2, bool &FO1, GPT1_CR_OM3 &OM3,
                       GPT1_CR_OM2 &OM2, GPT1_CR_OM1 &OM1, GPT1_CR_IM2 &IM2,
                       GPT1_CR_IM1 &IM1, bool &SWR, bool &EN_24M, bool &FRR,
                       GPT1_CR_CLKSRC &CLKSRC, bool &STOPEN, bool &DOZEEN,
                       bool &WAITEN, bool &DBGEN, bool &ENMOD,
                       bool &EN) volatile
    {
        uint32_t curr = CR;

        FO3 = curr & (1u << 31u);
        FO2 = curr & (1u << 30u);
        FO1 = curr & (1u << 29u);
        OM3 = GPT1_CR_OM3((curr >> 26u) & 0b111u);
        OM2 = GPT1_CR_OM2((curr >> 23u) & 0b111u);
        OM1 = GPT1_CR_OM1((curr >> 20u) & 0b111u);
        IM2 = GPT1_CR_IM2((curr >> 18u) & 0b11u);
        IM1 = GPT1_CR_IM1((curr >> 16u) & 0b11u);
        SWR = curr & (1u << 15u);
        EN_24M = curr & (1u << 10u);
        FRR = curr & (1u << 9u);
        CLKSRC = GPT1_CR_CLKSRC((curr >> 6u) & 0b111u);
        STOPEN = curr & (1u << 5u);
        DOZEEN = curr & (1u << 4u);
        WAITEN = curr & (1u << 3u);
        DBGEN = curr & (1u << 2u);
        ENMOD = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of CR's bit fields.
     *
     * (read-write) GPT Control Register
     */
    inline void set_CR(bool FO3, bool FO2, bool FO1, GPT1_CR_OM3 OM3,
                       GPT1_CR_OM2 OM2, GPT1_CR_OM1 OM1, GPT1_CR_IM2 IM2,
                       GPT1_CR_IM1 IM1, bool SWR, bool EN_24M, bool FRR,
                       GPT1_CR_CLKSRC CLKSRC, bool STOPEN, bool DOZEEN,
                       bool WAITEN, bool DBGEN, bool ENMOD, bool EN) volatile
    {
        uint32_t curr = CR;

        curr &= ~(0b1u << 31u);
        curr |= (FO3 & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (FO2 & 0b1u) << 30u;
        curr &= ~(0b1u << 29u);
        curr |= (FO1 & 0b1u) << 29u;
        curr &= ~(0b111u << 26u);
        curr |= (std::to_underlying(OM3) & 0b111u) << 26u;
        curr &= ~(0b111u << 23u);
        curr |= (std::to_underlying(OM2) & 0b111u) << 23u;
        curr &= ~(0b111u << 20u);
        curr |= (std::to_underlying(OM1) & 0b111u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (std::to_underlying(IM2) & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(IM1) & 0b11u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (SWR & 0b1u) << 15u;
        curr &= ~(0b1u << 10u);
        curr |= (EN_24M & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (FRR & 0b1u) << 9u;
        curr &= ~(0b111u << 6u);
        curr |= (std::to_underlying(CLKSRC) & 0b111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (STOPEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DOZEEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (WAITEN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DBGEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ENMOD & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        CR = curr;
    }

    /**
     * Get PR's PRESCALER24M field.
     *
     * Prescaler divide value for the oscillator clock
     */
    inline GPT1_PR_PRESCALER24M get_PR_PRESCALER24M() volatile
    {
        return GPT1_PR_PRESCALER24M((PR >> 12u) & 0b1111u);
    }

    /**
     * Set PR's PRESCALER24M field.
     *
     * Prescaler divide value for the oscillator clock
     */
    inline void set_PR_PRESCALER24M(GPT1_PR_PRESCALER24M value) volatile
    {
        uint32_t curr = PR;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        PR = curr;
    }

    /**
     * Get PR's PRESCALER field.
     *
     * Prescaler divide value
     */
    inline GPT1_PR_PRESCALER get_PR_PRESCALER() volatile
    {
        return GPT1_PR_PRESCALER((PR >> 0u) & 0b111111111111u);
    }

    /**
     * Set PR's PRESCALER field.
     *
     * Prescaler divide value
     */
    inline void set_PR_PRESCALER(GPT1_PR_PRESCALER value) volatile
    {
        uint32_t curr = PR;

        curr &= ~(0b111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111111111u) << 0u;

        PR = curr;
    }

    /**
     * Get all of PR's bit fields.
     *
     * (read-write) GPT Prescaler Register
     */
    inline void get_PR(GPT1_PR_PRESCALER24M &PRESCALER24M,
                       GPT1_PR_PRESCALER &PRESCALER) volatile
    {
        uint32_t curr = PR;

        PRESCALER24M = GPT1_PR_PRESCALER24M((curr >> 12u) & 0b1111u);
        PRESCALER = GPT1_PR_PRESCALER((curr >> 0u) & 0b111111111111u);
    }

    /**
     * Set all of PR's bit fields.
     *
     * (read-write) GPT Prescaler Register
     */
    inline void set_PR(GPT1_PR_PRESCALER24M PRESCALER24M,
                       GPT1_PR_PRESCALER PRESCALER) volatile
    {
        uint32_t curr = PR;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(PRESCALER24M) & 0b1111u) << 12u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (std::to_underlying(PRESCALER) & 0b111111111111u) << 0u;

        PR = curr;
    }

    /**
     * Get SR's ROV bit.
     *
     * Rollover Flag
     */
    inline bool get_SR_ROV() volatile
    {
        return SR & (1u << 5u);
    }

    /**
     * Set SR's ROV bit.
     *
     * Rollover Flag
     */
    inline void set_SR_ROV() volatile
    {
        SR |= 1u << 5u;
    }

    /**
     * Clear SR's ROV bit.
     *
     * Rollover Flag
     */
    inline void clear_SR_ROV() volatile
    {
        SR &= ~(1u << 5u);
    }

    /**
     * Toggle SR's ROV bit.
     *
     * Rollover Flag
     */
    inline void toggle_SR_ROV() volatile
    {
        SR ^= 1u << 5u;
    }

    /**
     * Get SR's IF2 bit.
     *
     * Input Capture Flag for Channel 2
     */
    inline bool get_SR_IF2() volatile
    {
        return SR & (1u << 4u);
    }

    /**
     * Set SR's IF2 bit.
     *
     * Input Capture Flag for Channel 2
     */
    inline void set_SR_IF2() volatile
    {
        SR |= 1u << 4u;
    }

    /**
     * Clear SR's IF2 bit.
     *
     * Input Capture Flag for Channel 2
     */
    inline void clear_SR_IF2() volatile
    {
        SR &= ~(1u << 4u);
    }

    /**
     * Toggle SR's IF2 bit.
     *
     * Input Capture Flag for Channel 2
     */
    inline void toggle_SR_IF2() volatile
    {
        SR ^= 1u << 4u;
    }

    /**
     * Get SR's IF1 bit.
     *
     * Input Capture Flag for Channel 1
     */
    inline bool get_SR_IF1() volatile
    {
        return SR & (1u << 3u);
    }

    /**
     * Set SR's IF1 bit.
     *
     * Input Capture Flag for Channel 1
     */
    inline void set_SR_IF1() volatile
    {
        SR |= 1u << 3u;
    }

    /**
     * Clear SR's IF1 bit.
     *
     * Input Capture Flag for Channel 1
     */
    inline void clear_SR_IF1() volatile
    {
        SR &= ~(1u << 3u);
    }

    /**
     * Toggle SR's IF1 bit.
     *
     * Input Capture Flag for Channel 1
     */
    inline void toggle_SR_IF1() volatile
    {
        SR ^= 1u << 3u;
    }

    /**
     * Get SR's OF3 bit.
     *
     * Output Compare Flag for Channel 3
     */
    inline bool get_SR_OF3() volatile
    {
        return SR & (1u << 2u);
    }

    /**
     * Set SR's OF3 bit.
     *
     * Output Compare Flag for Channel 3
     */
    inline void set_SR_OF3() volatile
    {
        SR |= 1u << 2u;
    }

    /**
     * Clear SR's OF3 bit.
     *
     * Output Compare Flag for Channel 3
     */
    inline void clear_SR_OF3() volatile
    {
        SR &= ~(1u << 2u);
    }

    /**
     * Toggle SR's OF3 bit.
     *
     * Output Compare Flag for Channel 3
     */
    inline void toggle_SR_OF3() volatile
    {
        SR ^= 1u << 2u;
    }

    /**
     * Get SR's OF2 bit.
     *
     * Output Compare Flag for Channel 2
     */
    inline bool get_SR_OF2() volatile
    {
        return SR & (1u << 1u);
    }

    /**
     * Set SR's OF2 bit.
     *
     * Output Compare Flag for Channel 2
     */
    inline void set_SR_OF2() volatile
    {
        SR |= 1u << 1u;
    }

    /**
     * Clear SR's OF2 bit.
     *
     * Output Compare Flag for Channel 2
     */
    inline void clear_SR_OF2() volatile
    {
        SR &= ~(1u << 1u);
    }

    /**
     * Toggle SR's OF2 bit.
     *
     * Output Compare Flag for Channel 2
     */
    inline void toggle_SR_OF2() volatile
    {
        SR ^= 1u << 1u;
    }

    /**
     * Get SR's OF1 bit.
     *
     * Output Compare Flag for Channel 1
     */
    inline bool get_SR_OF1() volatile
    {
        return SR & (1u << 0u);
    }

    /**
     * Set SR's OF1 bit.
     *
     * Output Compare Flag for Channel 1
     */
    inline void set_SR_OF1() volatile
    {
        SR |= 1u << 0u;
    }

    /**
     * Clear SR's OF1 bit.
     *
     * Output Compare Flag for Channel 1
     */
    inline void clear_SR_OF1() volatile
    {
        SR &= ~(1u << 0u);
    }

    /**
     * Toggle SR's OF1 bit.
     *
     * Output Compare Flag for Channel 1
     */
    inline void toggle_SR_OF1() volatile
    {
        SR ^= 1u << 0u;
    }

    /**
     * Get all of SR's bit fields.
     *
     * (read-write) GPT Status Register
     */
    inline void get_SR(bool &ROV, bool &IF2, bool &IF1, bool &OF3, bool &OF2,
                       bool &OF1) volatile
    {
        uint32_t curr = SR;

        ROV = curr & (1u << 5u);
        IF2 = curr & (1u << 4u);
        IF1 = curr & (1u << 3u);
        OF3 = curr & (1u << 2u);
        OF2 = curr & (1u << 1u);
        OF1 = curr & (1u << 0u);
    }

    /**
     * Set all of SR's bit fields.
     *
     * (read-write) GPT Status Register
     */
    inline void set_SR(bool ROV, bool IF2, bool IF1, bool OF3, bool OF2,
                       bool OF1) volatile
    {
        uint32_t curr = SR;

        curr &= ~(0b1u << 5u);
        curr |= (ROV & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (IF2 & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IF1 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (OF3 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OF2 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OF1 & 0b1u) << 0u;

        SR = curr;
    }

    /**
     * Get IR's ROVIE bit.
     *
     * Rollover Interrupt Enable
     */
    inline bool get_IR_ROVIE() volatile
    {
        return IR & (1u << 5u);
    }

    /**
     * Set IR's ROVIE bit.
     *
     * Rollover Interrupt Enable
     */
    inline void set_IR_ROVIE() volatile
    {
        IR |= 1u << 5u;
    }

    /**
     * Clear IR's ROVIE bit.
     *
     * Rollover Interrupt Enable
     */
    inline void clear_IR_ROVIE() volatile
    {
        IR &= ~(1u << 5u);
    }

    /**
     * Toggle IR's ROVIE bit.
     *
     * Rollover Interrupt Enable
     */
    inline void toggle_IR_ROVIE() volatile
    {
        IR ^= 1u << 5u;
    }

    /**
     * Get IR's IF2IE bit.
     *
     * Input Capture Flag for Channel 2 Interrupt Enable
     */
    inline bool get_IR_IF2IE() volatile
    {
        return IR & (1u << 4u);
    }

    /**
     * Set IR's IF2IE bit.
     *
     * Input Capture Flag for Channel 2 Interrupt Enable
     */
    inline void set_IR_IF2IE() volatile
    {
        IR |= 1u << 4u;
    }

    /**
     * Clear IR's IF2IE bit.
     *
     * Input Capture Flag for Channel 2 Interrupt Enable
     */
    inline void clear_IR_IF2IE() volatile
    {
        IR &= ~(1u << 4u);
    }

    /**
     * Toggle IR's IF2IE bit.
     *
     * Input Capture Flag for Channel 2 Interrupt Enable
     */
    inline void toggle_IR_IF2IE() volatile
    {
        IR ^= 1u << 4u;
    }

    /**
     * Get IR's IF1IE bit.
     *
     * Input Capture Flag for Channel 1 Interrupt Enable
     */
    inline bool get_IR_IF1IE() volatile
    {
        return IR & (1u << 3u);
    }

    /**
     * Set IR's IF1IE bit.
     *
     * Input Capture Flag for Channel 1 Interrupt Enable
     */
    inline void set_IR_IF1IE() volatile
    {
        IR |= 1u << 3u;
    }

    /**
     * Clear IR's IF1IE bit.
     *
     * Input Capture Flag for Channel 1 Interrupt Enable
     */
    inline void clear_IR_IF1IE() volatile
    {
        IR &= ~(1u << 3u);
    }

    /**
     * Toggle IR's IF1IE bit.
     *
     * Input Capture Flag for Channel 1 Interrupt Enable
     */
    inline void toggle_IR_IF1IE() volatile
    {
        IR ^= 1u << 3u;
    }

    /**
     * Get IR's OF3IE bit.
     *
     * Output Compare Flag for Channel 3 Interrupt Enable
     */
    inline bool get_IR_OF3IE() volatile
    {
        return IR & (1u << 2u);
    }

    /**
     * Set IR's OF3IE bit.
     *
     * Output Compare Flag for Channel 3 Interrupt Enable
     */
    inline void set_IR_OF3IE() volatile
    {
        IR |= 1u << 2u;
    }

    /**
     * Clear IR's OF3IE bit.
     *
     * Output Compare Flag for Channel 3 Interrupt Enable
     */
    inline void clear_IR_OF3IE() volatile
    {
        IR &= ~(1u << 2u);
    }

    /**
     * Toggle IR's OF3IE bit.
     *
     * Output Compare Flag for Channel 3 Interrupt Enable
     */
    inline void toggle_IR_OF3IE() volatile
    {
        IR ^= 1u << 2u;
    }

    /**
     * Get IR's OF2IE bit.
     *
     * Output Compare Flag for Channel 2 Interrupt Enable
     */
    inline bool get_IR_OF2IE() volatile
    {
        return IR & (1u << 1u);
    }

    /**
     * Set IR's OF2IE bit.
     *
     * Output Compare Flag for Channel 2 Interrupt Enable
     */
    inline void set_IR_OF2IE() volatile
    {
        IR |= 1u << 1u;
    }

    /**
     * Clear IR's OF2IE bit.
     *
     * Output Compare Flag for Channel 2 Interrupt Enable
     */
    inline void clear_IR_OF2IE() volatile
    {
        IR &= ~(1u << 1u);
    }

    /**
     * Toggle IR's OF2IE bit.
     *
     * Output Compare Flag for Channel 2 Interrupt Enable
     */
    inline void toggle_IR_OF2IE() volatile
    {
        IR ^= 1u << 1u;
    }

    /**
     * Get IR's OF1IE bit.
     *
     * Output Compare Flag for Channel 1 Interrupt Enable
     */
    inline bool get_IR_OF1IE() volatile
    {
        return IR & (1u << 0u);
    }

    /**
     * Set IR's OF1IE bit.
     *
     * Output Compare Flag for Channel 1 Interrupt Enable
     */
    inline void set_IR_OF1IE() volatile
    {
        IR |= 1u << 0u;
    }

    /**
     * Clear IR's OF1IE bit.
     *
     * Output Compare Flag for Channel 1 Interrupt Enable
     */
    inline void clear_IR_OF1IE() volatile
    {
        IR &= ~(1u << 0u);
    }

    /**
     * Toggle IR's OF1IE bit.
     *
     * Output Compare Flag for Channel 1 Interrupt Enable
     */
    inline void toggle_IR_OF1IE() volatile
    {
        IR ^= 1u << 0u;
    }

    /**
     * Get all of IR's bit fields.
     *
     * (read-write) GPT Interrupt Register
     */
    inline void get_IR(bool &ROVIE, bool &IF2IE, bool &IF1IE, bool &OF3IE,
                       bool &OF2IE, bool &OF1IE) volatile
    {
        uint32_t curr = IR;

        ROVIE = curr & (1u << 5u);
        IF2IE = curr & (1u << 4u);
        IF1IE = curr & (1u << 3u);
        OF3IE = curr & (1u << 2u);
        OF2IE = curr & (1u << 1u);
        OF1IE = curr & (1u << 0u);
    }

    /**
     * Set all of IR's bit fields.
     *
     * (read-write) GPT Interrupt Register
     */
    inline void set_IR(bool ROVIE, bool IF2IE, bool IF1IE, bool OF3IE,
                       bool OF2IE, bool OF1IE) volatile
    {
        uint32_t curr = IR;

        curr &= ~(0b1u << 5u);
        curr |= (ROVIE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (IF2IE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (IF1IE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (OF3IE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OF2IE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OF1IE & 0b1u) << 0u;

        IR = curr;
    }

    /**
     * Get OCR's COMP field.
     *
     * Compare Value
     */
    inline uint32_t get_OCR_COMP(std::size_t index) volatile
    {
        return (OCR[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set OCR's COMP field.
     *
     * Compare Value
     */
    inline void set_OCR_COMP(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = OCR[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        OCR[index] = curr;
    }

    /**
     * Get ICR's CAPT field.
     *
     * Capture Value
     */
    inline uint32_t get_ICR_CAPT(std::size_t index) volatile
    {
        return (ICR[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get CNT's COUNT field.
     *
     * Counter Value
     */
    inline uint32_t get_CNT_COUNT() volatile
    {
        return (CNT >> 0u) & 0b11111111111111111111111111111111u;
    }
};

static_assert(sizeof(gpt1) == gpt1::size);

static volatile gpt1 *const GPT1 = reinterpret_cast<gpt1 *>(0x400EC000);

static volatile gpt1 *const GPT2 = reinterpret_cast<gpt1 *>(0x400F0000);

static volatile gpt1 *const GPT3 = reinterpret_cast<gpt1 *>(0x400F4000);

static volatile gpt1 *const GPT4 = reinterpret_cast<gpt1 *>(0x400F8000);

static volatile gpt1 *const GPT5 = reinterpret_cast<gpt1 *>(0x400FC000);

static volatile gpt1 *const GPT6 = reinterpret_cast<gpt1 *>(0x40100000);

}; // namespace MIMXRT1176::CM7
