/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * CM7_MCM
 */
struct [[gnu::packed]] cm7_mcm
{
    /* Constant attributes. */
    static constexpr std::size_t size = 20; /*!< cm7_mcm's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 4;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t ISCR; /*!< (read-write) Interrupt Status and Control Register */

    /* Methods. */

    /**
     * Get ISCR's FIDCE bit.
     *
     * FPU Input Denormal Interrupt Enable
     */
    inline bool get_ISCR_FIDCE() volatile
    {
        return ISCR & (1u << 31u);
    }

    /**
     * Set ISCR's FIDCE bit.
     *
     * FPU Input Denormal Interrupt Enable
     */
    inline void set_ISCR_FIDCE() volatile
    {
        ISCR |= 1u << 31u;
    }

    /**
     * Clear ISCR's FIDCE bit.
     *
     * FPU Input Denormal Interrupt Enable
     */
    inline void clear_ISCR_FIDCE() volatile
    {
        ISCR &= ~(1u << 31u);
    }

    /**
     * Toggle ISCR's FIDCE bit.
     *
     * FPU Input Denormal Interrupt Enable
     */
    inline void toggle_ISCR_FIDCE() volatile
    {
        ISCR ^= 1u << 31u;
    }

    /**
     * Get ISCR's FIXCE bit.
     *
     * FPU Inexact Interrupt Enable
     */
    inline bool get_ISCR_FIXCE() volatile
    {
        return ISCR & (1u << 28u);
    }

    /**
     * Set ISCR's FIXCE bit.
     *
     * FPU Inexact Interrupt Enable
     */
    inline void set_ISCR_FIXCE() volatile
    {
        ISCR |= 1u << 28u;
    }

    /**
     * Clear ISCR's FIXCE bit.
     *
     * FPU Inexact Interrupt Enable
     */
    inline void clear_ISCR_FIXCE() volatile
    {
        ISCR &= ~(1u << 28u);
    }

    /**
     * Toggle ISCR's FIXCE bit.
     *
     * FPU Inexact Interrupt Enable
     */
    inline void toggle_ISCR_FIXCE() volatile
    {
        ISCR ^= 1u << 28u;
    }

    /**
     * Get ISCR's FUFCE bit.
     *
     * FPU Underflow Interrupt Enable
     */
    inline bool get_ISCR_FUFCE() volatile
    {
        return ISCR & (1u << 27u);
    }

    /**
     * Set ISCR's FUFCE bit.
     *
     * FPU Underflow Interrupt Enable
     */
    inline void set_ISCR_FUFCE() volatile
    {
        ISCR |= 1u << 27u;
    }

    /**
     * Clear ISCR's FUFCE bit.
     *
     * FPU Underflow Interrupt Enable
     */
    inline void clear_ISCR_FUFCE() volatile
    {
        ISCR &= ~(1u << 27u);
    }

    /**
     * Toggle ISCR's FUFCE bit.
     *
     * FPU Underflow Interrupt Enable
     */
    inline void toggle_ISCR_FUFCE() volatile
    {
        ISCR ^= 1u << 27u;
    }

    /**
     * Get ISCR's FOFCE bit.
     *
     * FPU Overflow Interrupt Enable
     */
    inline bool get_ISCR_FOFCE() volatile
    {
        return ISCR & (1u << 26u);
    }

    /**
     * Set ISCR's FOFCE bit.
     *
     * FPU Overflow Interrupt Enable
     */
    inline void set_ISCR_FOFCE() volatile
    {
        ISCR |= 1u << 26u;
    }

    /**
     * Clear ISCR's FOFCE bit.
     *
     * FPU Overflow Interrupt Enable
     */
    inline void clear_ISCR_FOFCE() volatile
    {
        ISCR &= ~(1u << 26u);
    }

    /**
     * Toggle ISCR's FOFCE bit.
     *
     * FPU Overflow Interrupt Enable
     */
    inline void toggle_ISCR_FOFCE() volatile
    {
        ISCR ^= 1u << 26u;
    }

    /**
     * Get ISCR's FDZCE bit.
     *
     * FPU Divide-by-Zero Interrupt Enable
     */
    inline bool get_ISCR_FDZCE() volatile
    {
        return ISCR & (1u << 25u);
    }

    /**
     * Set ISCR's FDZCE bit.
     *
     * FPU Divide-by-Zero Interrupt Enable
     */
    inline void set_ISCR_FDZCE() volatile
    {
        ISCR |= 1u << 25u;
    }

    /**
     * Clear ISCR's FDZCE bit.
     *
     * FPU Divide-by-Zero Interrupt Enable
     */
    inline void clear_ISCR_FDZCE() volatile
    {
        ISCR &= ~(1u << 25u);
    }

    /**
     * Toggle ISCR's FDZCE bit.
     *
     * FPU Divide-by-Zero Interrupt Enable
     */
    inline void toggle_ISCR_FDZCE() volatile
    {
        ISCR ^= 1u << 25u;
    }

    /**
     * Get ISCR's FIOCE bit.
     *
     * FPU Invalid Operation Interrupt Enable
     */
    inline bool get_ISCR_FIOCE() volatile
    {
        return ISCR & (1u << 24u);
    }

    /**
     * Set ISCR's FIOCE bit.
     *
     * FPU Invalid Operation Interrupt Enable
     */
    inline void set_ISCR_FIOCE() volatile
    {
        ISCR |= 1u << 24u;
    }

    /**
     * Clear ISCR's FIOCE bit.
     *
     * FPU Invalid Operation Interrupt Enable
     */
    inline void clear_ISCR_FIOCE() volatile
    {
        ISCR &= ~(1u << 24u);
    }

    /**
     * Toggle ISCR's FIOCE bit.
     *
     * FPU Invalid Operation Interrupt Enable
     */
    inline void toggle_ISCR_FIOCE() volatile
    {
        ISCR ^= 1u << 24u;
    }

    /**
     * Get ISCR's WABE bit.
     *
     * TCM Write Abort Interrupt enable
     */
    inline bool get_ISCR_WABE() volatile
    {
        return ISCR & (1u << 21u);
    }

    /**
     * Set ISCR's WABE bit.
     *
     * TCM Write Abort Interrupt enable
     */
    inline void set_ISCR_WABE() volatile
    {
        ISCR |= 1u << 21u;
    }

    /**
     * Clear ISCR's WABE bit.
     *
     * TCM Write Abort Interrupt enable
     */
    inline void clear_ISCR_WABE() volatile
    {
        ISCR &= ~(1u << 21u);
    }

    /**
     * Toggle ISCR's WABE bit.
     *
     * TCM Write Abort Interrupt enable
     */
    inline void toggle_ISCR_WABE() volatile
    {
        ISCR ^= 1u << 21u;
    }

    /**
     * Get ISCR's FIDC bit.
     *
     * FPU Input Denormal Interrupt Status
     */
    inline bool get_ISCR_FIDC() volatile
    {
        return ISCR & (1u << 15u);
    }

    /**
     * Get ISCR's FIXC bit.
     *
     * FPU Inexact Interrupt Status
     */
    inline bool get_ISCR_FIXC() volatile
    {
        return ISCR & (1u << 12u);
    }

    /**
     * Get ISCR's FUFC bit.
     *
     * FPU Underflow Interrupt Status
     */
    inline bool get_ISCR_FUFC() volatile
    {
        return ISCR & (1u << 11u);
    }

    /**
     * Get ISCR's FOFC bit.
     *
     * FPU Overflow interrupt status
     */
    inline bool get_ISCR_FOFC() volatile
    {
        return ISCR & (1u << 10u);
    }

    /**
     * Get ISCR's FDZC bit.
     *
     * FPU Divide-by-Zero Interrupt Status
     */
    inline bool get_ISCR_FDZC() volatile
    {
        return ISCR & (1u << 9u);
    }

    /**
     * Get ISCR's FIOC bit.
     *
     * FPU Invalid Operation interrupt Status
     */
    inline bool get_ISCR_FIOC() volatile
    {
        return ISCR & (1u << 8u);
    }

    /**
     * Get ISCR's WABSO bit.
     *
     * Write Abort on Slave Overrun
     */
    inline bool get_ISCR_WABSO() volatile
    {
        return ISCR & (1u << 6u);
    }

    /**
     * Get ISCR's WABS bit.
     *
     * Write Abort on Slave
     */
    inline bool get_ISCR_WABS() volatile
    {
        return ISCR & (1u << 5u);
    }

    /**
     * Set ISCR's WABS bit.
     *
     * Write Abort on Slave
     */
    inline void set_ISCR_WABS() volatile
    {
        ISCR |= 1u << 5u;
    }

    /**
     * Clear ISCR's WABS bit.
     *
     * Write Abort on Slave
     */
    inline void clear_ISCR_WABS() volatile
    {
        ISCR &= ~(1u << 5u);
    }

    /**
     * Toggle ISCR's WABS bit.
     *
     * Write Abort on Slave
     */
    inline void toggle_ISCR_WABS() volatile
    {
        ISCR ^= 1u << 5u;
    }

    /**
     * Get all of ISCR's bit fields.
     *
     * (read-write) Interrupt Status and Control Register
     */
    inline void get_ISCR(bool &FIDCE, bool &FIXCE, bool &FUFCE, bool &FOFCE,
                         bool &FDZCE, bool &FIOCE, bool &WABE, bool &FIDC,
                         bool &FIXC, bool &FUFC, bool &FOFC, bool &FDZC,
                         bool &FIOC, bool &WABSO, bool &WABS) volatile
    {
        uint32_t curr = ISCR;

        FIDCE = curr & (1u << 31u);
        FIXCE = curr & (1u << 28u);
        FUFCE = curr & (1u << 27u);
        FOFCE = curr & (1u << 26u);
        FDZCE = curr & (1u << 25u);
        FIOCE = curr & (1u << 24u);
        WABE = curr & (1u << 21u);
        FIDC = curr & (1u << 15u);
        FIXC = curr & (1u << 12u);
        FUFC = curr & (1u << 11u);
        FOFC = curr & (1u << 10u);
        FDZC = curr & (1u << 9u);
        FIOC = curr & (1u << 8u);
        WABSO = curr & (1u << 6u);
        WABS = curr & (1u << 5u);
    }

    /**
     * Set all of ISCR's bit fields.
     *
     * (read-write) Interrupt Status and Control Register
     */
    inline void set_ISCR(bool FIDCE, bool FIXCE, bool FUFCE, bool FOFCE,
                         bool FDZCE, bool FIOCE, bool WABE, bool WABS) volatile
    {
        uint32_t curr = ISCR;

        curr &= ~(0b1u << 31u);
        curr |= (FIDCE & 0b1u) << 31u;
        curr &= ~(0b1u << 28u);
        curr |= (FIXCE & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (FUFCE & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (FOFCE & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (FDZCE & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (FIOCE & 0b1u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (WABE & 0b1u) << 21u;
        curr &= ~(0b1u << 5u);
        curr |= (WABS & 0b1u) << 5u;

        ISCR = curr;
    }
};

static_assert(sizeof(cm7_mcm) == cm7_mcm::size);

static volatile cm7_mcm *const CM7_MCM =
    reinterpret_cast<cm7_mcm *>(0xE0080000);

}; // namespace MIMXRT1176::CM7
