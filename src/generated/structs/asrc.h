/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/ASRC_ASRCFG_POSTMODA.h"
#include "../enums/ASRC_ASRCFG_POSTMODB.h"
#include "../enums/ASRC_ASRCFG_POSTMODC.h"
#include "../enums/ASRC_ASRCFG_PREMODA.h"
#include "../enums/ASRC_ASRCFG_PREMODB.h"
#include "../enums/ASRC_ASRCFG_PREMODC.h"
#include "../enums/ASRC_ASRCNCR_ANCA.h"
#include "../enums/ASRC_ASRCNCR_ANCB.h"
#include "../enums/ASRC_ASRCNCR_ANCC.h"
#include "../enums/ASRC_ASRCSR_AICSA.h"
#include "../enums/ASRC_ASRCSR_AICSB.h"
#include "../enums/ASRC_ASRCSR_AICSC.h"
#include "../enums/ASRC_ASRCSR_AOCSA.h"
#include "../enums/ASRC_ASRCSR_AOCSB.h"
#include "../enums/ASRC_ASRCSR_AOCSC.h"
#include "../enums/ASRC_ASRMCR1_IWD.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * ASRC
 */
struct [[gnu::packed]] asrc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 204; /*!< asrc's size in bytes. */

    /* Fields. */
    uint32_t ASRCTR; /*!< (read-write) ASRC Control Register */
    uint32_t ASRIER; /*!< (read-write) ASRC Interrupt Enable Register */
    const uint32_t reserved_padding0 = {};
    uint32_t ASRCNCR; /*!< (read-write) ASRC Channel Number Configuration
                         Register */
    uint32_t
        ASRCFG; /*!< (read-write) ASRC Filter Configuration Status Register */
    uint32_t ASRCSR;  /*!< (read-write) ASRC Clock Source Register */
    uint32_t ASRCDR1; /*!< (read-write) ASRC Clock Divider Register 1 */
    uint32_t ASRCDR2; /*!< (read-write) ASRC Clock Divider Register 2 */
    uint32_t ASRSTR;  /*!< (read-write) ASRC Status Register */
    static constexpr std::size_t reserved_padding1_length = 7;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    static constexpr std::size_t ASRPM_length = 5;
    uint32_t
        ASRPM[ASRPM_length]; /*!< (read-write) ASRC Parameter Register n */
    uint32_t ASRTFR1; /*!< (read-write) ASRC Task Queue FIFO Register 1 */
    const uint32_t reserved_padding2 = {};
    uint32_t ASRCCR; /*!< (read-write) ASRC Channel Counter Register */
    uint32_t ASRDIA; /*!< (read-write) ASRC Data Input Register for Pair x */
    uint32_t ASRDOA; /*!< (read-write) ASRC Data Output Register for Pair x */
    uint32_t ASRDIB; /*!< (read-write) ASRC Data Input Register for Pair x */
    uint32_t ASRDOB; /*!< (read-write) ASRC Data Output Register for Pair x */
    uint32_t ASRDIC; /*!< (read-write) ASRC Data Input Register for Pair x */
    uint32_t ASRDOC; /*!< (read-write) ASRC Data Output Register for Pair x */
    static constexpr std::size_t reserved_padding3_length = 2;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t
        ASRIDRHA; /*!< (read-write) ASRC Ideal Ratio for Pair A-High Part */
    uint32_t
        ASRIDRLA; /*!< (read-write) ASRC Ideal Ratio for Pair A -Low Part */
    uint32_t
        ASRIDRHB; /*!< (read-write) ASRC Ideal Ratio for Pair B-High Part */
    uint32_t
        ASRIDRLB; /*!< (read-write) ASRC Ideal Ratio for Pair B-Low Part */
    uint32_t
        ASRIDRHC; /*!< (read-write) ASRC Ideal Ratio for Pair C-High Part */
    uint32_t
        ASRIDRLC;    /*!< (read-write) ASRC Ideal Ratio for Pair C-Low Part */
    uint32_t ASR76K; /*!< (read-write) ASRC 76 kHz Period in terms of ASRC
                        processing clock */
    uint32_t ASR56K; /*!< (read-write) ASRC 56 kHz Period in terms of ASRC
                        processing clock */
    uint32_t
        ASRMCRA; /*!< (read-write) ASRC Misc Control Register for Pair A */
    uint32_t ASRFSTA; /*!< (read-write) ASRC FIFO Status Register for Pair A */
    uint32_t
        ASRMCRB; /*!< (read-write) ASRC Misc Control Register for Pair B */
    uint32_t ASRFSTB; /*!< (read-write) ASRC FIFO Status Register for Pair B */
    uint32_t
        ASRMCRC; /*!< (read-write) ASRC Misc Control Register for Pair C */
    uint32_t ASRFSTC; /*!< (read-write) ASRC FIFO Status Register for Pair C */
    static constexpr std::size_t reserved_padding4_length = 2;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    static constexpr std::size_t ASRMCR1_length = 3;
    uint32_t ASRMCR1[ASRMCR1_length]; /*!< (read-write) ASRC Misc Control
                                         Register 1 for Pair X */

    /* Methods. */

    /**
     * Get ASRCTR's ATSC bit.
     *
     * ATSC
     */
    inline bool get_ASRCTR_ATSC() volatile
    {
        return ASRCTR & (1u << 22u);
    }

    /**
     * Set ASRCTR's ATSC bit.
     *
     * ATSC
     */
    inline void set_ASRCTR_ATSC() volatile
    {
        ASRCTR |= 1u << 22u;
    }

    /**
     * Clear ASRCTR's ATSC bit.
     *
     * ATSC
     */
    inline void clear_ASRCTR_ATSC() volatile
    {
        ASRCTR &= ~(1u << 22u);
    }

    /**
     * Toggle ASRCTR's ATSC bit.
     *
     * ATSC
     */
    inline void toggle_ASRCTR_ATSC() volatile
    {
        ASRCTR ^= 1u << 22u;
    }

    /**
     * Get ASRCTR's ATSB bit.
     *
     * ATSB
     */
    inline bool get_ASRCTR_ATSB() volatile
    {
        return ASRCTR & (1u << 21u);
    }

    /**
     * Set ASRCTR's ATSB bit.
     *
     * ATSB
     */
    inline void set_ASRCTR_ATSB() volatile
    {
        ASRCTR |= 1u << 21u;
    }

    /**
     * Clear ASRCTR's ATSB bit.
     *
     * ATSB
     */
    inline void clear_ASRCTR_ATSB() volatile
    {
        ASRCTR &= ~(1u << 21u);
    }

    /**
     * Toggle ASRCTR's ATSB bit.
     *
     * ATSB
     */
    inline void toggle_ASRCTR_ATSB() volatile
    {
        ASRCTR ^= 1u << 21u;
    }

    /**
     * Get ASRCTR's ATSA bit.
     *
     * ATSA
     */
    inline bool get_ASRCTR_ATSA() volatile
    {
        return ASRCTR & (1u << 20u);
    }

    /**
     * Set ASRCTR's ATSA bit.
     *
     * ATSA
     */
    inline void set_ASRCTR_ATSA() volatile
    {
        ASRCTR |= 1u << 20u;
    }

    /**
     * Clear ASRCTR's ATSA bit.
     *
     * ATSA
     */
    inline void clear_ASRCTR_ATSA() volatile
    {
        ASRCTR &= ~(1u << 20u);
    }

    /**
     * Toggle ASRCTR's ATSA bit.
     *
     * ATSA
     */
    inline void toggle_ASRCTR_ATSA() volatile
    {
        ASRCTR ^= 1u << 20u;
    }

    /**
     * Get ASRCTR's USRC bit.
     *
     * USRC
     */
    inline bool get_ASRCTR_USRC() volatile
    {
        return ASRCTR & (1u << 18u);
    }

    /**
     * Set ASRCTR's USRC bit.
     *
     * USRC
     */
    inline void set_ASRCTR_USRC() volatile
    {
        ASRCTR |= 1u << 18u;
    }

    /**
     * Clear ASRCTR's USRC bit.
     *
     * USRC
     */
    inline void clear_ASRCTR_USRC() volatile
    {
        ASRCTR &= ~(1u << 18u);
    }

    /**
     * Toggle ASRCTR's USRC bit.
     *
     * USRC
     */
    inline void toggle_ASRCTR_USRC() volatile
    {
        ASRCTR ^= 1u << 18u;
    }

    /**
     * Get ASRCTR's IDRC bit.
     *
     * IDRC
     */
    inline bool get_ASRCTR_IDRC() volatile
    {
        return ASRCTR & (1u << 17u);
    }

    /**
     * Set ASRCTR's IDRC bit.
     *
     * IDRC
     */
    inline void set_ASRCTR_IDRC() volatile
    {
        ASRCTR |= 1u << 17u;
    }

    /**
     * Clear ASRCTR's IDRC bit.
     *
     * IDRC
     */
    inline void clear_ASRCTR_IDRC() volatile
    {
        ASRCTR &= ~(1u << 17u);
    }

    /**
     * Toggle ASRCTR's IDRC bit.
     *
     * IDRC
     */
    inline void toggle_ASRCTR_IDRC() volatile
    {
        ASRCTR ^= 1u << 17u;
    }

    /**
     * Get ASRCTR's USRB bit.
     *
     * USRB
     */
    inline bool get_ASRCTR_USRB() volatile
    {
        return ASRCTR & (1u << 16u);
    }

    /**
     * Set ASRCTR's USRB bit.
     *
     * USRB
     */
    inline void set_ASRCTR_USRB() volatile
    {
        ASRCTR |= 1u << 16u;
    }

    /**
     * Clear ASRCTR's USRB bit.
     *
     * USRB
     */
    inline void clear_ASRCTR_USRB() volatile
    {
        ASRCTR &= ~(1u << 16u);
    }

    /**
     * Toggle ASRCTR's USRB bit.
     *
     * USRB
     */
    inline void toggle_ASRCTR_USRB() volatile
    {
        ASRCTR ^= 1u << 16u;
    }

    /**
     * Get ASRCTR's IDRB bit.
     *
     * IDRB
     */
    inline bool get_ASRCTR_IDRB() volatile
    {
        return ASRCTR & (1u << 15u);
    }

    /**
     * Set ASRCTR's IDRB bit.
     *
     * IDRB
     */
    inline void set_ASRCTR_IDRB() volatile
    {
        ASRCTR |= 1u << 15u;
    }

    /**
     * Clear ASRCTR's IDRB bit.
     *
     * IDRB
     */
    inline void clear_ASRCTR_IDRB() volatile
    {
        ASRCTR &= ~(1u << 15u);
    }

    /**
     * Toggle ASRCTR's IDRB bit.
     *
     * IDRB
     */
    inline void toggle_ASRCTR_IDRB() volatile
    {
        ASRCTR ^= 1u << 15u;
    }

    /**
     * Get ASRCTR's USRA bit.
     *
     * USRA
     */
    inline bool get_ASRCTR_USRA() volatile
    {
        return ASRCTR & (1u << 14u);
    }

    /**
     * Set ASRCTR's USRA bit.
     *
     * USRA
     */
    inline void set_ASRCTR_USRA() volatile
    {
        ASRCTR |= 1u << 14u;
    }

    /**
     * Clear ASRCTR's USRA bit.
     *
     * USRA
     */
    inline void clear_ASRCTR_USRA() volatile
    {
        ASRCTR &= ~(1u << 14u);
    }

    /**
     * Toggle ASRCTR's USRA bit.
     *
     * USRA
     */
    inline void toggle_ASRCTR_USRA() volatile
    {
        ASRCTR ^= 1u << 14u;
    }

    /**
     * Get ASRCTR's IDRA bit.
     *
     * IDRA
     */
    inline bool get_ASRCTR_IDRA() volatile
    {
        return ASRCTR & (1u << 13u);
    }

    /**
     * Set ASRCTR's IDRA bit.
     *
     * IDRA
     */
    inline void set_ASRCTR_IDRA() volatile
    {
        ASRCTR |= 1u << 13u;
    }

    /**
     * Clear ASRCTR's IDRA bit.
     *
     * IDRA
     */
    inline void clear_ASRCTR_IDRA() volatile
    {
        ASRCTR &= ~(1u << 13u);
    }

    /**
     * Toggle ASRCTR's IDRA bit.
     *
     * IDRA
     */
    inline void toggle_ASRCTR_IDRA() volatile
    {
        ASRCTR ^= 1u << 13u;
    }

    /**
     * Set ASRCTR's SRST bit.
     *
     * SRST
     */
    inline void set_ASRCTR_SRST() volatile
    {
        ASRCTR |= 1u << 4u;
    }

    /**
     * Clear ASRCTR's SRST bit.
     *
     * SRST
     */
    inline void clear_ASRCTR_SRST() volatile
    {
        ASRCTR &= ~(1u << 4u);
    }

    /**
     * Toggle ASRCTR's SRST bit.
     *
     * SRST
     */
    inline void toggle_ASRCTR_SRST() volatile
    {
        ASRCTR ^= 1u << 4u;
    }

    /**
     * Get ASRCTR's ASREC bit.
     *
     * ASREC
     */
    inline bool get_ASRCTR_ASREC() volatile
    {
        return ASRCTR & (1u << 3u);
    }

    /**
     * Set ASRCTR's ASREC bit.
     *
     * ASREC
     */
    inline void set_ASRCTR_ASREC() volatile
    {
        ASRCTR |= 1u << 3u;
    }

    /**
     * Clear ASRCTR's ASREC bit.
     *
     * ASREC
     */
    inline void clear_ASRCTR_ASREC() volatile
    {
        ASRCTR &= ~(1u << 3u);
    }

    /**
     * Toggle ASRCTR's ASREC bit.
     *
     * ASREC
     */
    inline void toggle_ASRCTR_ASREC() volatile
    {
        ASRCTR ^= 1u << 3u;
    }

    /**
     * Get ASRCTR's ASREB bit.
     *
     * ASREB
     */
    inline bool get_ASRCTR_ASREB() volatile
    {
        return ASRCTR & (1u << 2u);
    }

    /**
     * Set ASRCTR's ASREB bit.
     *
     * ASREB
     */
    inline void set_ASRCTR_ASREB() volatile
    {
        ASRCTR |= 1u << 2u;
    }

    /**
     * Clear ASRCTR's ASREB bit.
     *
     * ASREB
     */
    inline void clear_ASRCTR_ASREB() volatile
    {
        ASRCTR &= ~(1u << 2u);
    }

    /**
     * Toggle ASRCTR's ASREB bit.
     *
     * ASREB
     */
    inline void toggle_ASRCTR_ASREB() volatile
    {
        ASRCTR ^= 1u << 2u;
    }

    /**
     * Get ASRCTR's ASREA bit.
     *
     * ASREA
     */
    inline bool get_ASRCTR_ASREA() volatile
    {
        return ASRCTR & (1u << 1u);
    }

    /**
     * Set ASRCTR's ASREA bit.
     *
     * ASREA
     */
    inline void set_ASRCTR_ASREA() volatile
    {
        ASRCTR |= 1u << 1u;
    }

    /**
     * Clear ASRCTR's ASREA bit.
     *
     * ASREA
     */
    inline void clear_ASRCTR_ASREA() volatile
    {
        ASRCTR &= ~(1u << 1u);
    }

    /**
     * Toggle ASRCTR's ASREA bit.
     *
     * ASREA
     */
    inline void toggle_ASRCTR_ASREA() volatile
    {
        ASRCTR ^= 1u << 1u;
    }

    /**
     * Get ASRCTR's ASRCEN bit.
     *
     * ASRCEN
     */
    inline bool get_ASRCTR_ASRCEN() volatile
    {
        return ASRCTR & (1u << 0u);
    }

    /**
     * Set ASRCTR's ASRCEN bit.
     *
     * ASRCEN
     */
    inline void set_ASRCTR_ASRCEN() volatile
    {
        ASRCTR |= 1u << 0u;
    }

    /**
     * Clear ASRCTR's ASRCEN bit.
     *
     * ASRCEN
     */
    inline void clear_ASRCTR_ASRCEN() volatile
    {
        ASRCTR &= ~(1u << 0u);
    }

    /**
     * Toggle ASRCTR's ASRCEN bit.
     *
     * ASRCEN
     */
    inline void toggle_ASRCTR_ASRCEN() volatile
    {
        ASRCTR ^= 1u << 0u;
    }

    /**
     * Get all of ASRCTR's bit fields.
     *
     * (read-write) ASRC Control Register
     */
    inline void get_ASRCTR(bool &ATSC, bool &ATSB, bool &ATSA, bool &USRC,
                           bool &IDRC, bool &USRB, bool &IDRB, bool &USRA,
                           bool &IDRA, bool &ASREC, bool &ASREB, bool &ASREA,
                           bool &ASRCEN) volatile
    {
        uint32_t curr = ASRCTR;

        ATSC = curr & (1u << 22u);
        ATSB = curr & (1u << 21u);
        ATSA = curr & (1u << 20u);
        USRC = curr & (1u << 18u);
        IDRC = curr & (1u << 17u);
        USRB = curr & (1u << 16u);
        IDRB = curr & (1u << 15u);
        USRA = curr & (1u << 14u);
        IDRA = curr & (1u << 13u);
        ASREC = curr & (1u << 3u);
        ASREB = curr & (1u << 2u);
        ASREA = curr & (1u << 1u);
        ASRCEN = curr & (1u << 0u);
    }

    /**
     * Set all of ASRCTR's bit fields.
     *
     * (read-write) ASRC Control Register
     */
    inline void set_ASRCTR(bool ATSC, bool ATSB, bool ATSA, bool USRC,
                           bool IDRC, bool USRB, bool IDRB, bool USRA,
                           bool IDRA, bool SRST, bool ASREC, bool ASREB,
                           bool ASREA, bool ASRCEN) volatile
    {
        uint32_t curr = ASRCTR;

        curr &= ~(0b1u << 22u);
        curr |= (ATSC & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (ATSB & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ATSA & 0b1u) << 20u;
        curr &= ~(0b1u << 18u);
        curr |= (USRC & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (IDRC & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (USRB & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (IDRB & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (USRA & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (IDRA & 0b1u) << 13u;
        curr &= ~(0b1u << 4u);
        curr |= (SRST & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ASREC & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ASREB & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ASREA & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ASRCEN & 0b1u) << 0u;

        ASRCTR = curr;
    }

    /**
     * Get ASRIER's AFPWE bit.
     *
     * AFPWE
     */
    inline bool get_ASRIER_AFPWE() volatile
    {
        return ASRIER & (1u << 7u);
    }

    /**
     * Set ASRIER's AFPWE bit.
     *
     * AFPWE
     */
    inline void set_ASRIER_AFPWE() volatile
    {
        ASRIER |= 1u << 7u;
    }

    /**
     * Clear ASRIER's AFPWE bit.
     *
     * AFPWE
     */
    inline void clear_ASRIER_AFPWE() volatile
    {
        ASRIER &= ~(1u << 7u);
    }

    /**
     * Toggle ASRIER's AFPWE bit.
     *
     * AFPWE
     */
    inline void toggle_ASRIER_AFPWE() volatile
    {
        ASRIER ^= 1u << 7u;
    }

    /**
     * Get ASRIER's AOLIE bit.
     *
     * AOLIE
     */
    inline bool get_ASRIER_AOLIE() volatile
    {
        return ASRIER & (1u << 6u);
    }

    /**
     * Set ASRIER's AOLIE bit.
     *
     * AOLIE
     */
    inline void set_ASRIER_AOLIE() volatile
    {
        ASRIER |= 1u << 6u;
    }

    /**
     * Clear ASRIER's AOLIE bit.
     *
     * AOLIE
     */
    inline void clear_ASRIER_AOLIE() volatile
    {
        ASRIER &= ~(1u << 6u);
    }

    /**
     * Toggle ASRIER's AOLIE bit.
     *
     * AOLIE
     */
    inline void toggle_ASRIER_AOLIE() volatile
    {
        ASRIER ^= 1u << 6u;
    }

    /**
     * Get ASRIER's ADOEC bit.
     *
     * ADOEC
     */
    inline bool get_ASRIER_ADOEC() volatile
    {
        return ASRIER & (1u << 5u);
    }

    /**
     * Set ASRIER's ADOEC bit.
     *
     * ADOEC
     */
    inline void set_ASRIER_ADOEC() volatile
    {
        ASRIER |= 1u << 5u;
    }

    /**
     * Clear ASRIER's ADOEC bit.
     *
     * ADOEC
     */
    inline void clear_ASRIER_ADOEC() volatile
    {
        ASRIER &= ~(1u << 5u);
    }

    /**
     * Toggle ASRIER's ADOEC bit.
     *
     * ADOEC
     */
    inline void toggle_ASRIER_ADOEC() volatile
    {
        ASRIER ^= 1u << 5u;
    }

    /**
     * Get ASRIER's ADOEB bit.
     *
     * ADOEB
     */
    inline bool get_ASRIER_ADOEB() volatile
    {
        return ASRIER & (1u << 4u);
    }

    /**
     * Set ASRIER's ADOEB bit.
     *
     * ADOEB
     */
    inline void set_ASRIER_ADOEB() volatile
    {
        ASRIER |= 1u << 4u;
    }

    /**
     * Clear ASRIER's ADOEB bit.
     *
     * ADOEB
     */
    inline void clear_ASRIER_ADOEB() volatile
    {
        ASRIER &= ~(1u << 4u);
    }

    /**
     * Toggle ASRIER's ADOEB bit.
     *
     * ADOEB
     */
    inline void toggle_ASRIER_ADOEB() volatile
    {
        ASRIER ^= 1u << 4u;
    }

    /**
     * Get ASRIER's ADOEA bit.
     *
     * ADOEA
     */
    inline bool get_ASRIER_ADOEA() volatile
    {
        return ASRIER & (1u << 3u);
    }

    /**
     * Set ASRIER's ADOEA bit.
     *
     * ADOEA
     */
    inline void set_ASRIER_ADOEA() volatile
    {
        ASRIER |= 1u << 3u;
    }

    /**
     * Clear ASRIER's ADOEA bit.
     *
     * ADOEA
     */
    inline void clear_ASRIER_ADOEA() volatile
    {
        ASRIER &= ~(1u << 3u);
    }

    /**
     * Toggle ASRIER's ADOEA bit.
     *
     * ADOEA
     */
    inline void toggle_ASRIER_ADOEA() volatile
    {
        ASRIER ^= 1u << 3u;
    }

    /**
     * Get ASRIER's ADIEC bit.
     *
     * ADIEC
     */
    inline bool get_ASRIER_ADIEC() volatile
    {
        return ASRIER & (1u << 2u);
    }

    /**
     * Set ASRIER's ADIEC bit.
     *
     * ADIEC
     */
    inline void set_ASRIER_ADIEC() volatile
    {
        ASRIER |= 1u << 2u;
    }

    /**
     * Clear ASRIER's ADIEC bit.
     *
     * ADIEC
     */
    inline void clear_ASRIER_ADIEC() volatile
    {
        ASRIER &= ~(1u << 2u);
    }

    /**
     * Toggle ASRIER's ADIEC bit.
     *
     * ADIEC
     */
    inline void toggle_ASRIER_ADIEC() volatile
    {
        ASRIER ^= 1u << 2u;
    }

    /**
     * Get ASRIER's ADIEB bit.
     *
     * ADIEB
     */
    inline bool get_ASRIER_ADIEB() volatile
    {
        return ASRIER & (1u << 1u);
    }

    /**
     * Set ASRIER's ADIEB bit.
     *
     * ADIEB
     */
    inline void set_ASRIER_ADIEB() volatile
    {
        ASRIER |= 1u << 1u;
    }

    /**
     * Clear ASRIER's ADIEB bit.
     *
     * ADIEB
     */
    inline void clear_ASRIER_ADIEB() volatile
    {
        ASRIER &= ~(1u << 1u);
    }

    /**
     * Toggle ASRIER's ADIEB bit.
     *
     * ADIEB
     */
    inline void toggle_ASRIER_ADIEB() volatile
    {
        ASRIER ^= 1u << 1u;
    }

    /**
     * Get ASRIER's ADIEA bit.
     *
     * ADIEA
     */
    inline bool get_ASRIER_ADIEA() volatile
    {
        return ASRIER & (1u << 0u);
    }

    /**
     * Set ASRIER's ADIEA bit.
     *
     * ADIEA
     */
    inline void set_ASRIER_ADIEA() volatile
    {
        ASRIER |= 1u << 0u;
    }

    /**
     * Clear ASRIER's ADIEA bit.
     *
     * ADIEA
     */
    inline void clear_ASRIER_ADIEA() volatile
    {
        ASRIER &= ~(1u << 0u);
    }

    /**
     * Toggle ASRIER's ADIEA bit.
     *
     * ADIEA
     */
    inline void toggle_ASRIER_ADIEA() volatile
    {
        ASRIER ^= 1u << 0u;
    }

    /**
     * Get all of ASRIER's bit fields.
     *
     * (read-write) ASRC Interrupt Enable Register
     */
    inline void get_ASRIER(bool &AFPWE, bool &AOLIE, bool &ADOEC, bool &ADOEB,
                           bool &ADOEA, bool &ADIEC, bool &ADIEB,
                           bool &ADIEA) volatile
    {
        uint32_t curr = ASRIER;

        AFPWE = curr & (1u << 7u);
        AOLIE = curr & (1u << 6u);
        ADOEC = curr & (1u << 5u);
        ADOEB = curr & (1u << 4u);
        ADOEA = curr & (1u << 3u);
        ADIEC = curr & (1u << 2u);
        ADIEB = curr & (1u << 1u);
        ADIEA = curr & (1u << 0u);
    }

    /**
     * Set all of ASRIER's bit fields.
     *
     * (read-write) ASRC Interrupt Enable Register
     */
    inline void set_ASRIER(bool AFPWE, bool AOLIE, bool ADOEC, bool ADOEB,
                           bool ADOEA, bool ADIEC, bool ADIEB,
                           bool ADIEA) volatile
    {
        uint32_t curr = ASRIER;

        curr &= ~(0b1u << 7u);
        curr |= (AFPWE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (AOLIE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ADOEC & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ADOEB & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ADOEA & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ADIEC & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ADIEB & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ADIEA & 0b1u) << 0u;

        ASRIER = curr;
    }

    /**
     * Get ASRCNCR's ANCC field.
     *
     * ANCC
     */
    inline ASRC_ASRCNCR_ANCC get_ASRCNCR_ANCC() volatile
    {
        return ASRC_ASRCNCR_ANCC((ASRCNCR >> 8u) & 0b1111u);
    }

    /**
     * Set ASRCNCR's ANCC field.
     *
     * ANCC
     */
    inline void set_ASRCNCR_ANCC(ASRC_ASRCNCR_ANCC value) volatile
    {
        uint32_t curr = ASRCNCR;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        ASRCNCR = curr;
    }

    /**
     * Get ASRCNCR's ANCB field.
     *
     * ANCB
     */
    inline ASRC_ASRCNCR_ANCB get_ASRCNCR_ANCB() volatile
    {
        return ASRC_ASRCNCR_ANCB((ASRCNCR >> 4u) & 0b1111u);
    }

    /**
     * Set ASRCNCR's ANCB field.
     *
     * ANCB
     */
    inline void set_ASRCNCR_ANCB(ASRC_ASRCNCR_ANCB value) volatile
    {
        uint32_t curr = ASRCNCR;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        ASRCNCR = curr;
    }

    /**
     * Get ASRCNCR's ANCA field.
     *
     * ANCA
     */
    inline ASRC_ASRCNCR_ANCA get_ASRCNCR_ANCA() volatile
    {
        return ASRC_ASRCNCR_ANCA((ASRCNCR >> 0u) & 0b1111u);
    }

    /**
     * Set ASRCNCR's ANCA field.
     *
     * ANCA
     */
    inline void set_ASRCNCR_ANCA(ASRC_ASRCNCR_ANCA value) volatile
    {
        uint32_t curr = ASRCNCR;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        ASRCNCR = curr;
    }

    /**
     * Get all of ASRCNCR's bit fields.
     *
     * (read-write) ASRC Channel Number Configuration Register
     */
    inline void get_ASRCNCR(ASRC_ASRCNCR_ANCC &ANCC, ASRC_ASRCNCR_ANCB &ANCB,
                            ASRC_ASRCNCR_ANCA &ANCA) volatile
    {
        uint32_t curr = ASRCNCR;

        ANCC = ASRC_ASRCNCR_ANCC((curr >> 8u) & 0b1111u);
        ANCB = ASRC_ASRCNCR_ANCB((curr >> 4u) & 0b1111u);
        ANCA = ASRC_ASRCNCR_ANCA((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of ASRCNCR's bit fields.
     *
     * (read-write) ASRC Channel Number Configuration Register
     */
    inline void set_ASRCNCR(ASRC_ASRCNCR_ANCC ANCC, ASRC_ASRCNCR_ANCB ANCB,
                            ASRC_ASRCNCR_ANCA ANCA) volatile
    {
        uint32_t curr = ASRCNCR;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(ANCC) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(ANCB) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(ANCA) & 0b1111u) << 0u;

        ASRCNCR = curr;
    }

    /**
     * Get ASRCFG's INIRQC bit.
     *
     * INIRQC
     */
    inline bool get_ASRCFG_INIRQC() volatile
    {
        return ASRCFG & (1u << 23u);
    }

    /**
     * Get ASRCFG's INIRQB bit.
     *
     * INIRQB
     */
    inline bool get_ASRCFG_INIRQB() volatile
    {
        return ASRCFG & (1u << 22u);
    }

    /**
     * Get ASRCFG's INIRQA bit.
     *
     * INIRQA
     */
    inline bool get_ASRCFG_INIRQA() volatile
    {
        return ASRCFG & (1u << 21u);
    }

    /**
     * Get ASRCFG's NDPRC bit.
     *
     * NDPRC
     */
    inline bool get_ASRCFG_NDPRC() volatile
    {
        return ASRCFG & (1u << 20u);
    }

    /**
     * Set ASRCFG's NDPRC bit.
     *
     * NDPRC
     */
    inline void set_ASRCFG_NDPRC() volatile
    {
        ASRCFG |= 1u << 20u;
    }

    /**
     * Clear ASRCFG's NDPRC bit.
     *
     * NDPRC
     */
    inline void clear_ASRCFG_NDPRC() volatile
    {
        ASRCFG &= ~(1u << 20u);
    }

    /**
     * Toggle ASRCFG's NDPRC bit.
     *
     * NDPRC
     */
    inline void toggle_ASRCFG_NDPRC() volatile
    {
        ASRCFG ^= 1u << 20u;
    }

    /**
     * Get ASRCFG's NDPRB bit.
     *
     * NDPRB
     */
    inline bool get_ASRCFG_NDPRB() volatile
    {
        return ASRCFG & (1u << 19u);
    }

    /**
     * Set ASRCFG's NDPRB bit.
     *
     * NDPRB
     */
    inline void set_ASRCFG_NDPRB() volatile
    {
        ASRCFG |= 1u << 19u;
    }

    /**
     * Clear ASRCFG's NDPRB bit.
     *
     * NDPRB
     */
    inline void clear_ASRCFG_NDPRB() volatile
    {
        ASRCFG &= ~(1u << 19u);
    }

    /**
     * Toggle ASRCFG's NDPRB bit.
     *
     * NDPRB
     */
    inline void toggle_ASRCFG_NDPRB() volatile
    {
        ASRCFG ^= 1u << 19u;
    }

    /**
     * Get ASRCFG's NDPRA bit.
     *
     * NDPRA
     */
    inline bool get_ASRCFG_NDPRA() volatile
    {
        return ASRCFG & (1u << 18u);
    }

    /**
     * Set ASRCFG's NDPRA bit.
     *
     * NDPRA
     */
    inline void set_ASRCFG_NDPRA() volatile
    {
        ASRCFG |= 1u << 18u;
    }

    /**
     * Clear ASRCFG's NDPRA bit.
     *
     * NDPRA
     */
    inline void clear_ASRCFG_NDPRA() volatile
    {
        ASRCFG &= ~(1u << 18u);
    }

    /**
     * Toggle ASRCFG's NDPRA bit.
     *
     * NDPRA
     */
    inline void toggle_ASRCFG_NDPRA() volatile
    {
        ASRCFG ^= 1u << 18u;
    }

    /**
     * Get ASRCFG's POSTMODC field.
     *
     * POSTMODC
     */
    inline ASRC_ASRCFG_POSTMODC get_ASRCFG_POSTMODC() volatile
    {
        return ASRC_ASRCFG_POSTMODC((ASRCFG >> 16u) & 0b11u);
    }

    /**
     * Set ASRCFG's POSTMODC field.
     *
     * POSTMODC
     */
    inline void set_ASRCFG_POSTMODC(ASRC_ASRCFG_POSTMODC value) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(value) & 0b11u) << 16u;

        ASRCFG = curr;
    }

    /**
     * Get ASRCFG's PREMODC field.
     *
     * PREMODC
     */
    inline ASRC_ASRCFG_PREMODC get_ASRCFG_PREMODC() volatile
    {
        return ASRC_ASRCFG_PREMODC((ASRCFG >> 14u) & 0b11u);
    }

    /**
     * Set ASRCFG's PREMODC field.
     *
     * PREMODC
     */
    inline void set_ASRCFG_PREMODC(ASRC_ASRCFG_PREMODC value) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        ASRCFG = curr;
    }

    /**
     * Get ASRCFG's POSTMODB field.
     *
     * POSTMODB
     */
    inline ASRC_ASRCFG_POSTMODB get_ASRCFG_POSTMODB() volatile
    {
        return ASRC_ASRCFG_POSTMODB((ASRCFG >> 12u) & 0b11u);
    }

    /**
     * Set ASRCFG's POSTMODB field.
     *
     * POSTMODB
     */
    inline void set_ASRCFG_POSTMODB(ASRC_ASRCFG_POSTMODB value) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        ASRCFG = curr;
    }

    /**
     * Get ASRCFG's PREMODB field.
     *
     * PREMODB
     */
    inline ASRC_ASRCFG_PREMODB get_ASRCFG_PREMODB() volatile
    {
        return ASRC_ASRCFG_PREMODB((ASRCFG >> 10u) & 0b11u);
    }

    /**
     * Set ASRCFG's PREMODB field.
     *
     * PREMODB
     */
    inline void set_ASRCFG_PREMODB(ASRC_ASRCFG_PREMODB value) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        ASRCFG = curr;
    }

    /**
     * Get ASRCFG's POSTMODA field.
     *
     * POSTMODA
     */
    inline ASRC_ASRCFG_POSTMODA get_ASRCFG_POSTMODA() volatile
    {
        return ASRC_ASRCFG_POSTMODA((ASRCFG >> 8u) & 0b11u);
    }

    /**
     * Set ASRCFG's POSTMODA field.
     *
     * POSTMODA
     */
    inline void set_ASRCFG_POSTMODA(ASRC_ASRCFG_POSTMODA value) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        ASRCFG = curr;
    }

    /**
     * Get ASRCFG's PREMODA field.
     *
     * PREMODA
     */
    inline ASRC_ASRCFG_PREMODA get_ASRCFG_PREMODA() volatile
    {
        return ASRC_ASRCFG_PREMODA((ASRCFG >> 6u) & 0b11u);
    }

    /**
     * Set ASRCFG's PREMODA field.
     *
     * PREMODA
     */
    inline void set_ASRCFG_PREMODA(ASRC_ASRCFG_PREMODA value) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        ASRCFG = curr;
    }

    /**
     * Get all of ASRCFG's bit fields.
     *
     * (read-write) ASRC Filter Configuration Status Register
     */
    inline void get_ASRCFG(bool &INIRQC, bool &INIRQB, bool &INIRQA,
                           bool &NDPRC, bool &NDPRB, bool &NDPRA,
                           ASRC_ASRCFG_POSTMODC &POSTMODC,
                           ASRC_ASRCFG_PREMODC &PREMODC,
                           ASRC_ASRCFG_POSTMODB &POSTMODB,
                           ASRC_ASRCFG_PREMODB &PREMODB,
                           ASRC_ASRCFG_POSTMODA &POSTMODA,
                           ASRC_ASRCFG_PREMODA &PREMODA) volatile
    {
        uint32_t curr = ASRCFG;

        INIRQC = curr & (1u << 23u);
        INIRQB = curr & (1u << 22u);
        INIRQA = curr & (1u << 21u);
        NDPRC = curr & (1u << 20u);
        NDPRB = curr & (1u << 19u);
        NDPRA = curr & (1u << 18u);
        POSTMODC = ASRC_ASRCFG_POSTMODC((curr >> 16u) & 0b11u);
        PREMODC = ASRC_ASRCFG_PREMODC((curr >> 14u) & 0b11u);
        POSTMODB = ASRC_ASRCFG_POSTMODB((curr >> 12u) & 0b11u);
        PREMODB = ASRC_ASRCFG_PREMODB((curr >> 10u) & 0b11u);
        POSTMODA = ASRC_ASRCFG_POSTMODA((curr >> 8u) & 0b11u);
        PREMODA = ASRC_ASRCFG_PREMODA((curr >> 6u) & 0b11u);
    }

    /**
     * Set all of ASRCFG's bit fields.
     *
     * (read-write) ASRC Filter Configuration Status Register
     */
    inline void set_ASRCFG(bool NDPRC, bool NDPRB, bool NDPRA,
                           ASRC_ASRCFG_POSTMODC POSTMODC,
                           ASRC_ASRCFG_PREMODC PREMODC,
                           ASRC_ASRCFG_POSTMODB POSTMODB,
                           ASRC_ASRCFG_PREMODB PREMODB,
                           ASRC_ASRCFG_POSTMODA POSTMODA,
                           ASRC_ASRCFG_PREMODA PREMODA) volatile
    {
        uint32_t curr = ASRCFG;

        curr &= ~(0b1u << 20u);
        curr |= (NDPRC & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (NDPRB & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (NDPRA & 0b1u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (std::to_underlying(POSTMODC) & 0b11u) << 16u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(PREMODC) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(POSTMODB) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(PREMODB) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(POSTMODA) & 0b11u) << 8u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(PREMODA) & 0b11u) << 6u;

        ASRCFG = curr;
    }

    /**
     * Get ASRCSR's AOCSC field.
     *
     * AOCSC
     */
    inline ASRC_ASRCSR_AOCSC get_ASRCSR_AOCSC() volatile
    {
        return ASRC_ASRCSR_AOCSC((ASRCSR >> 20u) & 0b1111u);
    }

    /**
     * Set ASRCSR's AOCSC field.
     *
     * AOCSC
     */
    inline void set_ASRCSR_AOCSC(ASRC_ASRCSR_AOCSC value) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        ASRCSR = curr;
    }

    /**
     * Get ASRCSR's AOCSB field.
     *
     * AOCSB
     */
    inline ASRC_ASRCSR_AOCSB get_ASRCSR_AOCSB() volatile
    {
        return ASRC_ASRCSR_AOCSB((ASRCSR >> 16u) & 0b1111u);
    }

    /**
     * Set ASRCSR's AOCSB field.
     *
     * AOCSB
     */
    inline void set_ASRCSR_AOCSB(ASRC_ASRCSR_AOCSB value) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        ASRCSR = curr;
    }

    /**
     * Get ASRCSR's AOCSA field.
     *
     * AOCSA
     */
    inline ASRC_ASRCSR_AOCSA get_ASRCSR_AOCSA() volatile
    {
        return ASRC_ASRCSR_AOCSA((ASRCSR >> 12u) & 0b1111u);
    }

    /**
     * Set ASRCSR's AOCSA field.
     *
     * AOCSA
     */
    inline void set_ASRCSR_AOCSA(ASRC_ASRCSR_AOCSA value) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        ASRCSR = curr;
    }

    /**
     * Get ASRCSR's AICSC field.
     *
     * AICSC
     */
    inline ASRC_ASRCSR_AICSC get_ASRCSR_AICSC() volatile
    {
        return ASRC_ASRCSR_AICSC((ASRCSR >> 8u) & 0b1111u);
    }

    /**
     * Set ASRCSR's AICSC field.
     *
     * AICSC
     */
    inline void set_ASRCSR_AICSC(ASRC_ASRCSR_AICSC value) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        ASRCSR = curr;
    }

    /**
     * Get ASRCSR's AICSB field.
     *
     * AICSB
     */
    inline ASRC_ASRCSR_AICSB get_ASRCSR_AICSB() volatile
    {
        return ASRC_ASRCSR_AICSB((ASRCSR >> 4u) & 0b1111u);
    }

    /**
     * Set ASRCSR's AICSB field.
     *
     * AICSB
     */
    inline void set_ASRCSR_AICSB(ASRC_ASRCSR_AICSB value) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        ASRCSR = curr;
    }

    /**
     * Get ASRCSR's AICSA field.
     *
     * AICSA
     */
    inline ASRC_ASRCSR_AICSA get_ASRCSR_AICSA() volatile
    {
        return ASRC_ASRCSR_AICSA((ASRCSR >> 0u) & 0b1111u);
    }

    /**
     * Set ASRCSR's AICSA field.
     *
     * AICSA
     */
    inline void set_ASRCSR_AICSA(ASRC_ASRCSR_AICSA value) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        ASRCSR = curr;
    }

    /**
     * Get all of ASRCSR's bit fields.
     *
     * (read-write) ASRC Clock Source Register
     */
    inline void get_ASRCSR(ASRC_ASRCSR_AOCSC &AOCSC, ASRC_ASRCSR_AOCSB &AOCSB,
                           ASRC_ASRCSR_AOCSA &AOCSA, ASRC_ASRCSR_AICSC &AICSC,
                           ASRC_ASRCSR_AICSB &AICSB,
                           ASRC_ASRCSR_AICSA &AICSA) volatile
    {
        uint32_t curr = ASRCSR;

        AOCSC = ASRC_ASRCSR_AOCSC((curr >> 20u) & 0b1111u);
        AOCSB = ASRC_ASRCSR_AOCSB((curr >> 16u) & 0b1111u);
        AOCSA = ASRC_ASRCSR_AOCSA((curr >> 12u) & 0b1111u);
        AICSC = ASRC_ASRCSR_AICSC((curr >> 8u) & 0b1111u);
        AICSB = ASRC_ASRCSR_AICSB((curr >> 4u) & 0b1111u);
        AICSA = ASRC_ASRCSR_AICSA((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of ASRCSR's bit fields.
     *
     * (read-write) ASRC Clock Source Register
     */
    inline void set_ASRCSR(ASRC_ASRCSR_AOCSC AOCSC, ASRC_ASRCSR_AOCSB AOCSB,
                           ASRC_ASRCSR_AOCSA AOCSA, ASRC_ASRCSR_AICSC AICSC,
                           ASRC_ASRCSR_AICSB AICSB,
                           ASRC_ASRCSR_AICSA AICSA) volatile
    {
        uint32_t curr = ASRCSR;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(AOCSC) & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(AOCSB) & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(AOCSA) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(AICSC) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(AICSB) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(AICSA) & 0b1111u) << 0u;

        ASRCSR = curr;
    }

    /**
     * Get ASRCDR1's AOCDB field.
     *
     * AOCDB
     */
    inline uint8_t get_ASRCDR1_AOCDB() volatile
    {
        return (ASRCDR1 >> 21u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AOCDB field.
     *
     * AOCDB
     */
    inline void set_ASRCDR1_AOCDB(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 21u);
        curr |= (value & 0b111u) << 21u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AOCPB field.
     *
     * AOCPB
     */
    inline uint8_t get_ASRCDR1_AOCPB() volatile
    {
        return (ASRCDR1 >> 18u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AOCPB field.
     *
     * AOCPB
     */
    inline void set_ASRCDR1_AOCPB(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 18u);
        curr |= (value & 0b111u) << 18u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AOCDA field.
     *
     * AOCDA
     */
    inline uint8_t get_ASRCDR1_AOCDA() volatile
    {
        return (ASRCDR1 >> 15u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AOCDA field.
     *
     * AOCDA
     */
    inline void set_ASRCDR1_AOCDA(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 15u);
        curr |= (value & 0b111u) << 15u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AOCPA field.
     *
     * AOCPA
     */
    inline uint8_t get_ASRCDR1_AOCPA() volatile
    {
        return (ASRCDR1 >> 12u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AOCPA field.
     *
     * AOCPA
     */
    inline void set_ASRCDR1_AOCPA(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AICDB field.
     *
     * AICDB
     */
    inline uint8_t get_ASRCDR1_AICDB() volatile
    {
        return (ASRCDR1 >> 9u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AICDB field.
     *
     * AICDB
     */
    inline void set_ASRCDR1_AICDB(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 9u);
        curr |= (value & 0b111u) << 9u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AICPB field.
     *
     * AICPB
     */
    inline uint8_t get_ASRCDR1_AICPB() volatile
    {
        return (ASRCDR1 >> 6u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AICPB field.
     *
     * AICPB
     */
    inline void set_ASRCDR1_AICPB(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 6u);
        curr |= (value & 0b111u) << 6u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AICDA field.
     *
     * AICDA
     */
    inline uint8_t get_ASRCDR1_AICDA() volatile
    {
        return (ASRCDR1 >> 3u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AICDA field.
     *
     * AICDA
     */
    inline void set_ASRCDR1_AICDA(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 3u);
        curr |= (value & 0b111u) << 3u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR1's AICPA field.
     *
     * AICPA
     */
    inline uint8_t get_ASRCDR1_AICPA() volatile
    {
        return (ASRCDR1 >> 0u) & 0b111u;
    }

    /**
     * Set ASRCDR1's AICPA field.
     *
     * AICPA
     */
    inline void set_ASRCDR1_AICPA(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        ASRCDR1 = curr;
    }

    /**
     * Get all of ASRCDR1's bit fields.
     *
     * (read-write) ASRC Clock Divider Register 1
     */
    inline void get_ASRCDR1(uint8_t &AOCDB, uint8_t &AOCPB, uint8_t &AOCDA,
                            uint8_t &AOCPA, uint8_t &AICDB, uint8_t &AICPB,
                            uint8_t &AICDA, uint8_t &AICPA) volatile
    {
        uint32_t curr = ASRCDR1;

        AOCDB = (curr >> 21u) & 0b111u;
        AOCPB = (curr >> 18u) & 0b111u;
        AOCDA = (curr >> 15u) & 0b111u;
        AOCPA = (curr >> 12u) & 0b111u;
        AICDB = (curr >> 9u) & 0b111u;
        AICPB = (curr >> 6u) & 0b111u;
        AICDA = (curr >> 3u) & 0b111u;
        AICPA = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of ASRCDR1's bit fields.
     *
     * (read-write) ASRC Clock Divider Register 1
     */
    inline void set_ASRCDR1(uint8_t AOCDB, uint8_t AOCPB, uint8_t AOCDA,
                            uint8_t AOCPA, uint8_t AICDB, uint8_t AICPB,
                            uint8_t AICDA, uint8_t AICPA) volatile
    {
        uint32_t curr = ASRCDR1;

        curr &= ~(0b111u << 21u);
        curr |= (AOCDB & 0b111u) << 21u;
        curr &= ~(0b111u << 18u);
        curr |= (AOCPB & 0b111u) << 18u;
        curr &= ~(0b111u << 15u);
        curr |= (AOCDA & 0b111u) << 15u;
        curr &= ~(0b111u << 12u);
        curr |= (AOCPA & 0b111u) << 12u;
        curr &= ~(0b111u << 9u);
        curr |= (AICDB & 0b111u) << 9u;
        curr &= ~(0b111u << 6u);
        curr |= (AICPB & 0b111u) << 6u;
        curr &= ~(0b111u << 3u);
        curr |= (AICDA & 0b111u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (AICPA & 0b111u) << 0u;

        ASRCDR1 = curr;
    }

    /**
     * Get ASRCDR2's AOCDC field.
     *
     * AOCDC
     */
    inline uint8_t get_ASRCDR2_AOCDC() volatile
    {
        return (ASRCDR2 >> 9u) & 0b111u;
    }

    /**
     * Set ASRCDR2's AOCDC field.
     *
     * AOCDC
     */
    inline void set_ASRCDR2_AOCDC(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR2;

        curr &= ~(0b111u << 9u);
        curr |= (value & 0b111u) << 9u;

        ASRCDR2 = curr;
    }

    /**
     * Get ASRCDR2's AOCPC field.
     *
     * AOCPC
     */
    inline uint8_t get_ASRCDR2_AOCPC() volatile
    {
        return (ASRCDR2 >> 6u) & 0b111u;
    }

    /**
     * Set ASRCDR2's AOCPC field.
     *
     * AOCPC
     */
    inline void set_ASRCDR2_AOCPC(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR2;

        curr &= ~(0b111u << 6u);
        curr |= (value & 0b111u) << 6u;

        ASRCDR2 = curr;
    }

    /**
     * Get ASRCDR2's AICDC field.
     *
     * AICDC
     */
    inline uint8_t get_ASRCDR2_AICDC() volatile
    {
        return (ASRCDR2 >> 3u) & 0b111u;
    }

    /**
     * Set ASRCDR2's AICDC field.
     *
     * AICDC
     */
    inline void set_ASRCDR2_AICDC(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR2;

        curr &= ~(0b111u << 3u);
        curr |= (value & 0b111u) << 3u;

        ASRCDR2 = curr;
    }

    /**
     * Get ASRCDR2's AICPC field.
     *
     * AICPC
     */
    inline uint8_t get_ASRCDR2_AICPC() volatile
    {
        return (ASRCDR2 >> 0u) & 0b111u;
    }

    /**
     * Set ASRCDR2's AICPC field.
     *
     * AICPC
     */
    inline void set_ASRCDR2_AICPC(uint8_t value) volatile
    {
        uint32_t curr = ASRCDR2;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        ASRCDR2 = curr;
    }

    /**
     * Get all of ASRCDR2's bit fields.
     *
     * (read-write) ASRC Clock Divider Register 2
     */
    inline void get_ASRCDR2(uint8_t &AOCDC, uint8_t &AOCPC, uint8_t &AICDC,
                            uint8_t &AICPC) volatile
    {
        uint32_t curr = ASRCDR2;

        AOCDC = (curr >> 9u) & 0b111u;
        AOCPC = (curr >> 6u) & 0b111u;
        AICDC = (curr >> 3u) & 0b111u;
        AICPC = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of ASRCDR2's bit fields.
     *
     * (read-write) ASRC Clock Divider Register 2
     */
    inline void set_ASRCDR2(uint8_t AOCDC, uint8_t AOCPC, uint8_t AICDC,
                            uint8_t AICPC) volatile
    {
        uint32_t curr = ASRCDR2;

        curr &= ~(0b111u << 9u);
        curr |= (AOCDC & 0b111u) << 9u;
        curr &= ~(0b111u << 6u);
        curr |= (AOCPC & 0b111u) << 6u;
        curr &= ~(0b111u << 3u);
        curr |= (AICDC & 0b111u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (AICPC & 0b111u) << 0u;

        ASRCDR2 = curr;
    }

    /**
     * Get ASRSTR's DSLCNT bit.
     *
     * DSLCNT
     */
    inline bool get_ASRSTR_DSLCNT() volatile
    {
        return ASRSTR & (1u << 21u);
    }

    /**
     * Get ASRSTR's ATQOL bit.
     *
     * ATQOL
     */
    inline bool get_ASRSTR_ATQOL() volatile
    {
        return ASRSTR & (1u << 20u);
    }

    /**
     * Get ASRSTR's AOOLC bit.
     *
     * AOOLC
     */
    inline bool get_ASRSTR_AOOLC() volatile
    {
        return ASRSTR & (1u << 19u);
    }

    /**
     * Get ASRSTR's AOOLB bit.
     *
     * AOOLB
     */
    inline bool get_ASRSTR_AOOLB() volatile
    {
        return ASRSTR & (1u << 18u);
    }

    /**
     * Get ASRSTR's AOOLA bit.
     *
     * AOOLA
     */
    inline bool get_ASRSTR_AOOLA() volatile
    {
        return ASRSTR & (1u << 17u);
    }

    /**
     * Get ASRSTR's AIOLC bit.
     *
     * AIOLC
     */
    inline bool get_ASRSTR_AIOLC() volatile
    {
        return ASRSTR & (1u << 16u);
    }

    /**
     * Get ASRSTR's AIOLB bit.
     *
     * AIOLB
     */
    inline bool get_ASRSTR_AIOLB() volatile
    {
        return ASRSTR & (1u << 15u);
    }

    /**
     * Get ASRSTR's AIOLA bit.
     *
     * AIOLA
     */
    inline bool get_ASRSTR_AIOLA() volatile
    {
        return ASRSTR & (1u << 14u);
    }

    /**
     * Get ASRSTR's AODOC bit.
     *
     * AODOC
     */
    inline bool get_ASRSTR_AODOC() volatile
    {
        return ASRSTR & (1u << 13u);
    }

    /**
     * Get ASRSTR's AODOB bit.
     *
     * AODOB
     */
    inline bool get_ASRSTR_AODOB() volatile
    {
        return ASRSTR & (1u << 12u);
    }

    /**
     * Get ASRSTR's AODOA bit.
     *
     * AODOA
     */
    inline bool get_ASRSTR_AODOA() volatile
    {
        return ASRSTR & (1u << 11u);
    }

    /**
     * Get ASRSTR's AIDUC bit.
     *
     * AIDUC
     */
    inline bool get_ASRSTR_AIDUC() volatile
    {
        return ASRSTR & (1u << 10u);
    }

    /**
     * Get ASRSTR's AIDUB bit.
     *
     * AIDUB
     */
    inline bool get_ASRSTR_AIDUB() volatile
    {
        return ASRSTR & (1u << 9u);
    }

    /**
     * Get ASRSTR's AIDUA bit.
     *
     * AIDUA
     */
    inline bool get_ASRSTR_AIDUA() volatile
    {
        return ASRSTR & (1u << 8u);
    }

    /**
     * Get ASRSTR's FPWT bit.
     *
     * FPWT
     */
    inline bool get_ASRSTR_FPWT() volatile
    {
        return ASRSTR & (1u << 7u);
    }

    /**
     * Get ASRSTR's AOLE bit.
     *
     * AOLE
     */
    inline bool get_ASRSTR_AOLE() volatile
    {
        return ASRSTR & (1u << 6u);
    }

    /**
     * Get ASRSTR's AODFC bit.
     *
     * AODFC
     */
    inline bool get_ASRSTR_AODFC() volatile
    {
        return ASRSTR & (1u << 5u);
    }

    /**
     * Get ASRSTR's AODFB bit.
     *
     * AODFB
     */
    inline bool get_ASRSTR_AODFB() volatile
    {
        return ASRSTR & (1u << 4u);
    }

    /**
     * Get ASRSTR's AODFA bit.
     *
     * AODFA
     */
    inline bool get_ASRSTR_AODFA() volatile
    {
        return ASRSTR & (1u << 3u);
    }

    /**
     * Get ASRSTR's AIDEC bit.
     *
     * AIDEC
     */
    inline bool get_ASRSTR_AIDEC() volatile
    {
        return ASRSTR & (1u << 2u);
    }

    /**
     * Get ASRSTR's AIDEB bit.
     *
     * AIDEB
     */
    inline bool get_ASRSTR_AIDEB() volatile
    {
        return ASRSTR & (1u << 1u);
    }

    /**
     * Get ASRSTR's AIDEA bit.
     *
     * AIDEA
     */
    inline bool get_ASRSTR_AIDEA() volatile
    {
        return ASRSTR & (1u << 0u);
    }

    /**
     * Get all of ASRSTR's bit fields.
     *
     * (read-write) ASRC Status Register
     */
    inline void get_ASRSTR(bool &DSLCNT, bool &ATQOL, bool &AOOLC, bool &AOOLB,
                           bool &AOOLA, bool &AIOLC, bool &AIOLB, bool &AIOLA,
                           bool &AODOC, bool &AODOB, bool &AODOA, bool &AIDUC,
                           bool &AIDUB, bool &AIDUA, bool &FPWT, bool &AOLE,
                           bool &AODFC, bool &AODFB, bool &AODFA, bool &AIDEC,
                           bool &AIDEB, bool &AIDEA) volatile
    {
        uint32_t curr = ASRSTR;

        DSLCNT = curr & (1u << 21u);
        ATQOL = curr & (1u << 20u);
        AOOLC = curr & (1u << 19u);
        AOOLB = curr & (1u << 18u);
        AOOLA = curr & (1u << 17u);
        AIOLC = curr & (1u << 16u);
        AIOLB = curr & (1u << 15u);
        AIOLA = curr & (1u << 14u);
        AODOC = curr & (1u << 13u);
        AODOB = curr & (1u << 12u);
        AODOA = curr & (1u << 11u);
        AIDUC = curr & (1u << 10u);
        AIDUB = curr & (1u << 9u);
        AIDUA = curr & (1u << 8u);
        FPWT = curr & (1u << 7u);
        AOLE = curr & (1u << 6u);
        AODFC = curr & (1u << 5u);
        AODFB = curr & (1u << 4u);
        AODFA = curr & (1u << 3u);
        AIDEC = curr & (1u << 2u);
        AIDEB = curr & (1u << 1u);
        AIDEA = curr & (1u << 0u);
    }

    /**
     * Get ASRPM's PARAMETER_VALUE field.
     *
     * PARAMETER_VALUE
     */
    inline uint32_t get_ASRPM_PARAMETER_VALUE(std::size_t index) volatile
    {
        return (ASRPM[index] >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set ASRPM's PARAMETER_VALUE field.
     *
     * PARAMETER_VALUE
     */
    inline void set_ASRPM_PARAMETER_VALUE(std::size_t index,
                                          uint32_t value) volatile
    {
        uint32_t curr = ASRPM[index];

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRPM[index] = curr;
    }

    /**
     * Get ASRTFR1's TF_FILL field.
     *
     * TF_FILL
     */
    inline uint8_t get_ASRTFR1_TF_FILL() volatile
    {
        return (ASRTFR1 >> 13u) & 0b1111111u;
    }

    /**
     * Get ASRTFR1's TF_BASE field.
     *
     * TF_BASE
     */
    inline uint8_t get_ASRTFR1_TF_BASE() volatile
    {
        return (ASRTFR1 >> 6u) & 0b1111111u;
    }

    /**
     * Set ASRTFR1's TF_BASE field.
     *
     * TF_BASE
     */
    inline void set_ASRTFR1_TF_BASE(uint8_t value) volatile
    {
        uint32_t curr = ASRTFR1;

        curr &= ~(0b1111111u << 6u);
        curr |= (value & 0b1111111u) << 6u;

        ASRTFR1 = curr;
    }

    /**
     * Get all of ASRTFR1's bit fields.
     *
     * (read-write) ASRC Task Queue FIFO Register 1
     */
    inline void get_ASRTFR1(uint8_t &TF_FILL, uint8_t &TF_BASE) volatile
    {
        uint32_t curr = ASRTFR1;

        TF_FILL = (curr >> 13u) & 0b1111111u;
        TF_BASE = (curr >> 6u) & 0b1111111u;
    }

    /**
     * Get ASRCCR's ACOC field.
     *
     * ACOC
     */
    inline uint8_t get_ASRCCR_ACOC() volatile
    {
        return (ASRCCR >> 20u) & 0b1111u;
    }

    /**
     * Set ASRCCR's ACOC field.
     *
     * ACOC
     */
    inline void set_ASRCCR_ACOC(uint8_t value) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        ASRCCR = curr;
    }

    /**
     * Get ASRCCR's ACOB field.
     *
     * ACOB
     */
    inline uint8_t get_ASRCCR_ACOB() volatile
    {
        return (ASRCCR >> 16u) & 0b1111u;
    }

    /**
     * Set ASRCCR's ACOB field.
     *
     * ACOB
     */
    inline void set_ASRCCR_ACOB(uint8_t value) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ASRCCR = curr;
    }

    /**
     * Get ASRCCR's ACOA field.
     *
     * ACOA
     */
    inline uint8_t get_ASRCCR_ACOA() volatile
    {
        return (ASRCCR >> 12u) & 0b1111u;
    }

    /**
     * Set ASRCCR's ACOA field.
     *
     * ACOA
     */
    inline void set_ASRCCR_ACOA(uint8_t value) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        ASRCCR = curr;
    }

    /**
     * Get ASRCCR's ACIC field.
     *
     * ACIC
     */
    inline uint8_t get_ASRCCR_ACIC() volatile
    {
        return (ASRCCR >> 8u) & 0b1111u;
    }

    /**
     * Set ASRCCR's ACIC field.
     *
     * ACIC
     */
    inline void set_ASRCCR_ACIC(uint8_t value) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        ASRCCR = curr;
    }

    /**
     * Get ASRCCR's ACIB field.
     *
     * ACIB
     */
    inline uint8_t get_ASRCCR_ACIB() volatile
    {
        return (ASRCCR >> 4u) & 0b1111u;
    }

    /**
     * Set ASRCCR's ACIB field.
     *
     * ACIB
     */
    inline void set_ASRCCR_ACIB(uint8_t value) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        ASRCCR = curr;
    }

    /**
     * Get ASRCCR's ACIA field.
     *
     * ACIA
     */
    inline uint8_t get_ASRCCR_ACIA() volatile
    {
        return (ASRCCR >> 0u) & 0b1111u;
    }

    /**
     * Set ASRCCR's ACIA field.
     *
     * ACIA
     */
    inline void set_ASRCCR_ACIA(uint8_t value) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        ASRCCR = curr;
    }

    /**
     * Get all of ASRCCR's bit fields.
     *
     * (read-write) ASRC Channel Counter Register
     */
    inline void get_ASRCCR(uint8_t &ACOC, uint8_t &ACOB, uint8_t &ACOA,
                           uint8_t &ACIC, uint8_t &ACIB,
                           uint8_t &ACIA) volatile
    {
        uint32_t curr = ASRCCR;

        ACOC = (curr >> 20u) & 0b1111u;
        ACOB = (curr >> 16u) & 0b1111u;
        ACOA = (curr >> 12u) & 0b1111u;
        ACIC = (curr >> 8u) & 0b1111u;
        ACIB = (curr >> 4u) & 0b1111u;
        ACIA = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of ASRCCR's bit fields.
     *
     * (read-write) ASRC Channel Counter Register
     */
    inline void set_ASRCCR(uint8_t ACOC, uint8_t ACOB, uint8_t ACOA,
                           uint8_t ACIC, uint8_t ACIB, uint8_t ACIA) volatile
    {
        uint32_t curr = ASRCCR;

        curr &= ~(0b1111u << 20u);
        curr |= (ACOC & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (ACOB & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (ACOA & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (ACIC & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (ACIB & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (ACIA & 0b1111u) << 0u;

        ASRCCR = curr;
    }

    /**
     * Set ASRDIA's DATA field.
     *
     * DATA
     */
    inline void set_ASRDIA_DATA(uint32_t value) volatile
    {
        uint32_t curr = ASRDIA;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRDIA = curr;
    }

    /**
     * Get ASRDOA's DATA field.
     *
     * DATA
     */
    inline uint32_t get_ASRDOA_DATA() volatile
    {
        return (ASRDOA >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set ASRDIB's DATA field.
     *
     * DATA
     */
    inline void set_ASRDIB_DATA(uint32_t value) volatile
    {
        uint32_t curr = ASRDIB;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRDIB = curr;
    }

    /**
     * Get ASRDOB's DATA field.
     *
     * DATA
     */
    inline uint32_t get_ASRDOB_DATA() volatile
    {
        return (ASRDOB >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set ASRDIC's DATA field.
     *
     * DATA
     */
    inline void set_ASRDIC_DATA(uint32_t value) volatile
    {
        uint32_t curr = ASRDIC;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRDIC = curr;
    }

    /**
     * Get ASRDOC's DATA field.
     *
     * DATA
     */
    inline uint32_t get_ASRDOC_DATA() volatile
    {
        return (ASRDOC >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get ASRIDRHA's IDRATIOA_H field.
     *
     * IDRATIOA_H
     */
    inline uint8_t get_ASRIDRHA_IDRATIOA_H() volatile
    {
        return (ASRIDRHA >> 0u) & 0b11111111u;
    }

    /**
     * Set ASRIDRHA's IDRATIOA_H field.
     *
     * IDRATIOA_H
     */
    inline void set_ASRIDRHA_IDRATIOA_H(uint8_t value) volatile
    {
        uint32_t curr = ASRIDRHA;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        ASRIDRHA = curr;
    }

    /**
     * Get ASRIDRLA's IDRATIOA_L field.
     *
     * IDRATIOA_L
     */
    inline uint32_t get_ASRIDRLA_IDRATIOA_L() volatile
    {
        return (ASRIDRLA >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set ASRIDRLA's IDRATIOA_L field.
     *
     * IDRATIOA_L
     */
    inline void set_ASRIDRLA_IDRATIOA_L(uint32_t value) volatile
    {
        uint32_t curr = ASRIDRLA;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRIDRLA = curr;
    }

    /**
     * Get ASRIDRHB's IDRATIOB_H field.
     *
     * IDRATIOB_H
     */
    inline uint8_t get_ASRIDRHB_IDRATIOB_H() volatile
    {
        return (ASRIDRHB >> 0u) & 0b11111111u;
    }

    /**
     * Set ASRIDRHB's IDRATIOB_H field.
     *
     * IDRATIOB_H
     */
    inline void set_ASRIDRHB_IDRATIOB_H(uint8_t value) volatile
    {
        uint32_t curr = ASRIDRHB;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        ASRIDRHB = curr;
    }

    /**
     * Get ASRIDRLB's IDRATIOB_L field.
     *
     * IDRATIOB_L
     */
    inline uint32_t get_ASRIDRLB_IDRATIOB_L() volatile
    {
        return (ASRIDRLB >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set ASRIDRLB's IDRATIOB_L field.
     *
     * IDRATIOB_L
     */
    inline void set_ASRIDRLB_IDRATIOB_L(uint32_t value) volatile
    {
        uint32_t curr = ASRIDRLB;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRIDRLB = curr;
    }

    /**
     * Get ASRIDRHC's IDRATIOC_H field.
     *
     * IDRATIOC_H
     */
    inline uint8_t get_ASRIDRHC_IDRATIOC_H() volatile
    {
        return (ASRIDRHC >> 0u) & 0b11111111u;
    }

    /**
     * Set ASRIDRHC's IDRATIOC_H field.
     *
     * IDRATIOC_H
     */
    inline void set_ASRIDRHC_IDRATIOC_H(uint8_t value) volatile
    {
        uint32_t curr = ASRIDRHC;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        ASRIDRHC = curr;
    }

    /**
     * Get ASRIDRLC's IDRATIOC_L field.
     *
     * IDRATIOC_L
     */
    inline uint32_t get_ASRIDRLC_IDRATIOC_L() volatile
    {
        return (ASRIDRLC >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set ASRIDRLC's IDRATIOC_L field.
     *
     * IDRATIOC_L
     */
    inline void set_ASRIDRLC_IDRATIOC_L(uint32_t value) volatile
    {
        uint32_t curr = ASRIDRLC;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        ASRIDRLC = curr;
    }

    /**
     * Get ASR76K's ASR76K field.
     *
     * ASR76K
     */
    inline uint32_t get_ASR76K_ASR76K() volatile
    {
        return (ASR76K >> 0u) & 0b11111111111111111u;
    }

    /**
     * Set ASR76K's ASR76K field.
     *
     * ASR76K
     */
    inline void set_ASR76K_ASR76K(uint32_t value) volatile
    {
        uint32_t curr = ASR76K;

        curr &= ~(0b11111111111111111u << 0u);
        curr |= (value & 0b11111111111111111u) << 0u;

        ASR76K = curr;
    }

    /**
     * Get ASR56K's ASR56K field.
     *
     * ASR56K
     */
    inline uint32_t get_ASR56K_ASR56K() volatile
    {
        return (ASR56K >> 0u) & 0b11111111111111111u;
    }

    /**
     * Set ASR56K's ASR56K field.
     *
     * ASR56K
     */
    inline void set_ASR56K_ASR56K(uint32_t value) volatile
    {
        uint32_t curr = ASR56K;

        curr &= ~(0b11111111111111111u << 0u);
        curr |= (value & 0b11111111111111111u) << 0u;

        ASR56K = curr;
    }

    /**
     * Get ASRMCRA's ZEROBUFA bit.
     *
     * ZEROBUFA
     */
    inline bool get_ASRMCRA_ZEROBUFA() volatile
    {
        return ASRMCRA & (1u << 23u);
    }

    /**
     * Set ASRMCRA's ZEROBUFA bit.
     *
     * ZEROBUFA
     */
    inline void set_ASRMCRA_ZEROBUFA() volatile
    {
        ASRMCRA |= 1u << 23u;
    }

    /**
     * Clear ASRMCRA's ZEROBUFA bit.
     *
     * ZEROBUFA
     */
    inline void clear_ASRMCRA_ZEROBUFA() volatile
    {
        ASRMCRA &= ~(1u << 23u);
    }

    /**
     * Toggle ASRMCRA's ZEROBUFA bit.
     *
     * ZEROBUFA
     */
    inline void toggle_ASRMCRA_ZEROBUFA() volatile
    {
        ASRMCRA ^= 1u << 23u;
    }

    /**
     * Get ASRMCRA's EXTTHRSHA bit.
     *
     * EXTTHRSHA
     */
    inline bool get_ASRMCRA_EXTTHRSHA() volatile
    {
        return ASRMCRA & (1u << 22u);
    }

    /**
     * Set ASRMCRA's EXTTHRSHA bit.
     *
     * EXTTHRSHA
     */
    inline void set_ASRMCRA_EXTTHRSHA() volatile
    {
        ASRMCRA |= 1u << 22u;
    }

    /**
     * Clear ASRMCRA's EXTTHRSHA bit.
     *
     * EXTTHRSHA
     */
    inline void clear_ASRMCRA_EXTTHRSHA() volatile
    {
        ASRMCRA &= ~(1u << 22u);
    }

    /**
     * Toggle ASRMCRA's EXTTHRSHA bit.
     *
     * EXTTHRSHA
     */
    inline void toggle_ASRMCRA_EXTTHRSHA() volatile
    {
        ASRMCRA ^= 1u << 22u;
    }

    /**
     * Get ASRMCRA's BUFSTALLA bit.
     *
     * BUFSTALLA
     */
    inline bool get_ASRMCRA_BUFSTALLA() volatile
    {
        return ASRMCRA & (1u << 21u);
    }

    /**
     * Set ASRMCRA's BUFSTALLA bit.
     *
     * BUFSTALLA
     */
    inline void set_ASRMCRA_BUFSTALLA() volatile
    {
        ASRMCRA |= 1u << 21u;
    }

    /**
     * Clear ASRMCRA's BUFSTALLA bit.
     *
     * BUFSTALLA
     */
    inline void clear_ASRMCRA_BUFSTALLA() volatile
    {
        ASRMCRA &= ~(1u << 21u);
    }

    /**
     * Toggle ASRMCRA's BUFSTALLA bit.
     *
     * BUFSTALLA
     */
    inline void toggle_ASRMCRA_BUFSTALLA() volatile
    {
        ASRMCRA ^= 1u << 21u;
    }

    /**
     * Get ASRMCRA's BYPASSPOLYA bit.
     *
     * BYPASSPOLYA
     */
    inline bool get_ASRMCRA_BYPASSPOLYA() volatile
    {
        return ASRMCRA & (1u << 20u);
    }

    /**
     * Set ASRMCRA's BYPASSPOLYA bit.
     *
     * BYPASSPOLYA
     */
    inline void set_ASRMCRA_BYPASSPOLYA() volatile
    {
        ASRMCRA |= 1u << 20u;
    }

    /**
     * Clear ASRMCRA's BYPASSPOLYA bit.
     *
     * BYPASSPOLYA
     */
    inline void clear_ASRMCRA_BYPASSPOLYA() volatile
    {
        ASRMCRA &= ~(1u << 20u);
    }

    /**
     * Toggle ASRMCRA's BYPASSPOLYA bit.
     *
     * BYPASSPOLYA
     */
    inline void toggle_ASRMCRA_BYPASSPOLYA() volatile
    {
        ASRMCRA ^= 1u << 20u;
    }

    /**
     * Get ASRMCRA's OUTFIFO_THRESHOLDA field.
     *
     * OUTFIFO_THRESHOLDA
     */
    inline uint8_t get_ASRMCRA_OUTFIFO_THRESHOLDA() volatile
    {
        return (ASRMCRA >> 12u) & 0b111111u;
    }

    /**
     * Set ASRMCRA's OUTFIFO_THRESHOLDA field.
     *
     * OUTFIFO_THRESHOLDA
     */
    inline void set_ASRMCRA_OUTFIFO_THRESHOLDA(uint8_t value) volatile
    {
        uint32_t curr = ASRMCRA;

        curr &= ~(0b111111u << 12u);
        curr |= (value & 0b111111u) << 12u;

        ASRMCRA = curr;
    }

    /**
     * Get ASRMCRA's RSYNIFA bit.
     *
     * RSYNIFA
     */
    inline bool get_ASRMCRA_RSYNIFA() volatile
    {
        return ASRMCRA & (1u << 11u);
    }

    /**
     * Set ASRMCRA's RSYNIFA bit.
     *
     * RSYNIFA
     */
    inline void set_ASRMCRA_RSYNIFA() volatile
    {
        ASRMCRA |= 1u << 11u;
    }

    /**
     * Clear ASRMCRA's RSYNIFA bit.
     *
     * RSYNIFA
     */
    inline void clear_ASRMCRA_RSYNIFA() volatile
    {
        ASRMCRA &= ~(1u << 11u);
    }

    /**
     * Toggle ASRMCRA's RSYNIFA bit.
     *
     * RSYNIFA
     */
    inline void toggle_ASRMCRA_RSYNIFA() volatile
    {
        ASRMCRA ^= 1u << 11u;
    }

    /**
     * Get ASRMCRA's RSYNOFA bit.
     *
     * RSYNOFA
     */
    inline bool get_ASRMCRA_RSYNOFA() volatile
    {
        return ASRMCRA & (1u << 10u);
    }

    /**
     * Set ASRMCRA's RSYNOFA bit.
     *
     * RSYNOFA
     */
    inline void set_ASRMCRA_RSYNOFA() volatile
    {
        ASRMCRA |= 1u << 10u;
    }

    /**
     * Clear ASRMCRA's RSYNOFA bit.
     *
     * RSYNOFA
     */
    inline void clear_ASRMCRA_RSYNOFA() volatile
    {
        ASRMCRA &= ~(1u << 10u);
    }

    /**
     * Toggle ASRMCRA's RSYNOFA bit.
     *
     * RSYNOFA
     */
    inline void toggle_ASRMCRA_RSYNOFA() volatile
    {
        ASRMCRA ^= 1u << 10u;
    }

    /**
     * Get ASRMCRA's INFIFO_THRESHOLDA field.
     *
     * INFIFO_THRESHOLDA
     */
    inline uint8_t get_ASRMCRA_INFIFO_THRESHOLDA() volatile
    {
        return (ASRMCRA >> 0u) & 0b111111u;
    }

    /**
     * Set ASRMCRA's INFIFO_THRESHOLDA field.
     *
     * INFIFO_THRESHOLDA
     */
    inline void set_ASRMCRA_INFIFO_THRESHOLDA(uint8_t value) volatile
    {
        uint32_t curr = ASRMCRA;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        ASRMCRA = curr;
    }

    /**
     * Get all of ASRMCRA's bit fields.
     *
     * (read-write) ASRC Misc Control Register for Pair A
     */
    inline void get_ASRMCRA(bool &ZEROBUFA, bool &EXTTHRSHA, bool &BUFSTALLA,
                            bool &BYPASSPOLYA, uint8_t &OUTFIFO_THRESHOLDA,
                            bool &RSYNIFA, bool &RSYNOFA,
                            uint8_t &INFIFO_THRESHOLDA) volatile
    {
        uint32_t curr = ASRMCRA;

        ZEROBUFA = curr & (1u << 23u);
        EXTTHRSHA = curr & (1u << 22u);
        BUFSTALLA = curr & (1u << 21u);
        BYPASSPOLYA = curr & (1u << 20u);
        OUTFIFO_THRESHOLDA = (curr >> 12u) & 0b111111u;
        RSYNIFA = curr & (1u << 11u);
        RSYNOFA = curr & (1u << 10u);
        INFIFO_THRESHOLDA = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of ASRMCRA's bit fields.
     *
     * (read-write) ASRC Misc Control Register for Pair A
     */
    inline void set_ASRMCRA(bool ZEROBUFA, bool EXTTHRSHA, bool BUFSTALLA,
                            bool BYPASSPOLYA, uint8_t OUTFIFO_THRESHOLDA,
                            bool RSYNIFA, bool RSYNOFA,
                            uint8_t INFIFO_THRESHOLDA) volatile
    {
        uint32_t curr = ASRMCRA;

        curr &= ~(0b1u << 23u);
        curr |= (ZEROBUFA & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EXTTHRSHA & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (BUFSTALLA & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BYPASSPOLYA & 0b1u) << 20u;
        curr &= ~(0b111111u << 12u);
        curr |= (OUTFIFO_THRESHOLDA & 0b111111u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (RSYNIFA & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RSYNOFA & 0b1u) << 10u;
        curr &= ~(0b111111u << 0u);
        curr |= (INFIFO_THRESHOLDA & 0b111111u) << 0u;

        ASRMCRA = curr;
    }

    /**
     * Get ASRFSTA's OAFA bit.
     *
     * OAFA
     */
    inline bool get_ASRFSTA_OAFA() volatile
    {
        return ASRFSTA & (1u << 23u);
    }

    /**
     * Get ASRFSTA's OUTFIFO_FILLA field.
     *
     * OUTFIFO_FILLA
     */
    inline uint8_t get_ASRFSTA_OUTFIFO_FILLA() volatile
    {
        return (ASRFSTA >> 12u) & 0b1111111u;
    }

    /**
     * Get ASRFSTA's IAEA bit.
     *
     * IAEA
     */
    inline bool get_ASRFSTA_IAEA() volatile
    {
        return ASRFSTA & (1u << 11u);
    }

    /**
     * Get ASRFSTA's INFIFO_FILLA field.
     *
     * INFIFO_FILLA
     */
    inline uint8_t get_ASRFSTA_INFIFO_FILLA() volatile
    {
        return (ASRFSTA >> 0u) & 0b1111111u;
    }

    /**
     * Get all of ASRFSTA's bit fields.
     *
     * (read-write) ASRC FIFO Status Register for Pair A
     */
    inline void get_ASRFSTA(bool &OAFA, uint8_t &OUTFIFO_FILLA, bool &IAEA,
                            uint8_t &INFIFO_FILLA) volatile
    {
        uint32_t curr = ASRFSTA;

        OAFA = curr & (1u << 23u);
        OUTFIFO_FILLA = (curr >> 12u) & 0b1111111u;
        IAEA = curr & (1u << 11u);
        INFIFO_FILLA = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Get ASRMCRB's ZEROBUFB bit.
     *
     * ZEROBUFB
     */
    inline bool get_ASRMCRB_ZEROBUFB() volatile
    {
        return ASRMCRB & (1u << 23u);
    }

    /**
     * Set ASRMCRB's ZEROBUFB bit.
     *
     * ZEROBUFB
     */
    inline void set_ASRMCRB_ZEROBUFB() volatile
    {
        ASRMCRB |= 1u << 23u;
    }

    /**
     * Clear ASRMCRB's ZEROBUFB bit.
     *
     * ZEROBUFB
     */
    inline void clear_ASRMCRB_ZEROBUFB() volatile
    {
        ASRMCRB &= ~(1u << 23u);
    }

    /**
     * Toggle ASRMCRB's ZEROBUFB bit.
     *
     * ZEROBUFB
     */
    inline void toggle_ASRMCRB_ZEROBUFB() volatile
    {
        ASRMCRB ^= 1u << 23u;
    }

    /**
     * Get ASRMCRB's EXTTHRSHB bit.
     *
     * EXTTHRSHB
     */
    inline bool get_ASRMCRB_EXTTHRSHB() volatile
    {
        return ASRMCRB & (1u << 22u);
    }

    /**
     * Set ASRMCRB's EXTTHRSHB bit.
     *
     * EXTTHRSHB
     */
    inline void set_ASRMCRB_EXTTHRSHB() volatile
    {
        ASRMCRB |= 1u << 22u;
    }

    /**
     * Clear ASRMCRB's EXTTHRSHB bit.
     *
     * EXTTHRSHB
     */
    inline void clear_ASRMCRB_EXTTHRSHB() volatile
    {
        ASRMCRB &= ~(1u << 22u);
    }

    /**
     * Toggle ASRMCRB's EXTTHRSHB bit.
     *
     * EXTTHRSHB
     */
    inline void toggle_ASRMCRB_EXTTHRSHB() volatile
    {
        ASRMCRB ^= 1u << 22u;
    }

    /**
     * Get ASRMCRB's BUFSTALLB bit.
     *
     * BUFSTALLB
     */
    inline bool get_ASRMCRB_BUFSTALLB() volatile
    {
        return ASRMCRB & (1u << 21u);
    }

    /**
     * Set ASRMCRB's BUFSTALLB bit.
     *
     * BUFSTALLB
     */
    inline void set_ASRMCRB_BUFSTALLB() volatile
    {
        ASRMCRB |= 1u << 21u;
    }

    /**
     * Clear ASRMCRB's BUFSTALLB bit.
     *
     * BUFSTALLB
     */
    inline void clear_ASRMCRB_BUFSTALLB() volatile
    {
        ASRMCRB &= ~(1u << 21u);
    }

    /**
     * Toggle ASRMCRB's BUFSTALLB bit.
     *
     * BUFSTALLB
     */
    inline void toggle_ASRMCRB_BUFSTALLB() volatile
    {
        ASRMCRB ^= 1u << 21u;
    }

    /**
     * Get ASRMCRB's BYPASSPOLYB bit.
     *
     * BYPASSPOLYB
     */
    inline bool get_ASRMCRB_BYPASSPOLYB() volatile
    {
        return ASRMCRB & (1u << 20u);
    }

    /**
     * Set ASRMCRB's BYPASSPOLYB bit.
     *
     * BYPASSPOLYB
     */
    inline void set_ASRMCRB_BYPASSPOLYB() volatile
    {
        ASRMCRB |= 1u << 20u;
    }

    /**
     * Clear ASRMCRB's BYPASSPOLYB bit.
     *
     * BYPASSPOLYB
     */
    inline void clear_ASRMCRB_BYPASSPOLYB() volatile
    {
        ASRMCRB &= ~(1u << 20u);
    }

    /**
     * Toggle ASRMCRB's BYPASSPOLYB bit.
     *
     * BYPASSPOLYB
     */
    inline void toggle_ASRMCRB_BYPASSPOLYB() volatile
    {
        ASRMCRB ^= 1u << 20u;
    }

    /**
     * Get ASRMCRB's OUTFIFO_THRESHOLDB field.
     *
     * OUTFIFO_THRESHOLDB
     */
    inline uint8_t get_ASRMCRB_OUTFIFO_THRESHOLDB() volatile
    {
        return (ASRMCRB >> 12u) & 0b111111u;
    }

    /**
     * Set ASRMCRB's OUTFIFO_THRESHOLDB field.
     *
     * OUTFIFO_THRESHOLDB
     */
    inline void set_ASRMCRB_OUTFIFO_THRESHOLDB(uint8_t value) volatile
    {
        uint32_t curr = ASRMCRB;

        curr &= ~(0b111111u << 12u);
        curr |= (value & 0b111111u) << 12u;

        ASRMCRB = curr;
    }

    /**
     * Get ASRMCRB's RSYNIFB bit.
     *
     * RSYNIFB
     */
    inline bool get_ASRMCRB_RSYNIFB() volatile
    {
        return ASRMCRB & (1u << 11u);
    }

    /**
     * Set ASRMCRB's RSYNIFB bit.
     *
     * RSYNIFB
     */
    inline void set_ASRMCRB_RSYNIFB() volatile
    {
        ASRMCRB |= 1u << 11u;
    }

    /**
     * Clear ASRMCRB's RSYNIFB bit.
     *
     * RSYNIFB
     */
    inline void clear_ASRMCRB_RSYNIFB() volatile
    {
        ASRMCRB &= ~(1u << 11u);
    }

    /**
     * Toggle ASRMCRB's RSYNIFB bit.
     *
     * RSYNIFB
     */
    inline void toggle_ASRMCRB_RSYNIFB() volatile
    {
        ASRMCRB ^= 1u << 11u;
    }

    /**
     * Get ASRMCRB's RSYNOFB bit.
     *
     * RSYNOFB
     */
    inline bool get_ASRMCRB_RSYNOFB() volatile
    {
        return ASRMCRB & (1u << 10u);
    }

    /**
     * Set ASRMCRB's RSYNOFB bit.
     *
     * RSYNOFB
     */
    inline void set_ASRMCRB_RSYNOFB() volatile
    {
        ASRMCRB |= 1u << 10u;
    }

    /**
     * Clear ASRMCRB's RSYNOFB bit.
     *
     * RSYNOFB
     */
    inline void clear_ASRMCRB_RSYNOFB() volatile
    {
        ASRMCRB &= ~(1u << 10u);
    }

    /**
     * Toggle ASRMCRB's RSYNOFB bit.
     *
     * RSYNOFB
     */
    inline void toggle_ASRMCRB_RSYNOFB() volatile
    {
        ASRMCRB ^= 1u << 10u;
    }

    /**
     * Get ASRMCRB's INFIFO_THRESHOLDB field.
     *
     * INFIFO_THRESHOLDB
     */
    inline uint8_t get_ASRMCRB_INFIFO_THRESHOLDB() volatile
    {
        return (ASRMCRB >> 0u) & 0b111111u;
    }

    /**
     * Set ASRMCRB's INFIFO_THRESHOLDB field.
     *
     * INFIFO_THRESHOLDB
     */
    inline void set_ASRMCRB_INFIFO_THRESHOLDB(uint8_t value) volatile
    {
        uint32_t curr = ASRMCRB;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        ASRMCRB = curr;
    }

    /**
     * Get all of ASRMCRB's bit fields.
     *
     * (read-write) ASRC Misc Control Register for Pair B
     */
    inline void get_ASRMCRB(bool &ZEROBUFB, bool &EXTTHRSHB, bool &BUFSTALLB,
                            bool &BYPASSPOLYB, uint8_t &OUTFIFO_THRESHOLDB,
                            bool &RSYNIFB, bool &RSYNOFB,
                            uint8_t &INFIFO_THRESHOLDB) volatile
    {
        uint32_t curr = ASRMCRB;

        ZEROBUFB = curr & (1u << 23u);
        EXTTHRSHB = curr & (1u << 22u);
        BUFSTALLB = curr & (1u << 21u);
        BYPASSPOLYB = curr & (1u << 20u);
        OUTFIFO_THRESHOLDB = (curr >> 12u) & 0b111111u;
        RSYNIFB = curr & (1u << 11u);
        RSYNOFB = curr & (1u << 10u);
        INFIFO_THRESHOLDB = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of ASRMCRB's bit fields.
     *
     * (read-write) ASRC Misc Control Register for Pair B
     */
    inline void set_ASRMCRB(bool ZEROBUFB, bool EXTTHRSHB, bool BUFSTALLB,
                            bool BYPASSPOLYB, uint8_t OUTFIFO_THRESHOLDB,
                            bool RSYNIFB, bool RSYNOFB,
                            uint8_t INFIFO_THRESHOLDB) volatile
    {
        uint32_t curr = ASRMCRB;

        curr &= ~(0b1u << 23u);
        curr |= (ZEROBUFB & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EXTTHRSHB & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (BUFSTALLB & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BYPASSPOLYB & 0b1u) << 20u;
        curr &= ~(0b111111u << 12u);
        curr |= (OUTFIFO_THRESHOLDB & 0b111111u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (RSYNIFB & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RSYNOFB & 0b1u) << 10u;
        curr &= ~(0b111111u << 0u);
        curr |= (INFIFO_THRESHOLDB & 0b111111u) << 0u;

        ASRMCRB = curr;
    }

    /**
     * Get ASRFSTB's OAFB bit.
     *
     * OAFB
     */
    inline bool get_ASRFSTB_OAFB() volatile
    {
        return ASRFSTB & (1u << 23u);
    }

    /**
     * Get ASRFSTB's OUTFIFO_FILLB field.
     *
     * OUTFIFO_FILLB
     */
    inline uint8_t get_ASRFSTB_OUTFIFO_FILLB() volatile
    {
        return (ASRFSTB >> 12u) & 0b1111111u;
    }

    /**
     * Get ASRFSTB's IAEB bit.
     *
     * IAEB
     */
    inline bool get_ASRFSTB_IAEB() volatile
    {
        return ASRFSTB & (1u << 11u);
    }

    /**
     * Get ASRFSTB's INFIFO_FILLB field.
     *
     * INFIFO_FILLB
     */
    inline uint8_t get_ASRFSTB_INFIFO_FILLB() volatile
    {
        return (ASRFSTB >> 0u) & 0b1111111u;
    }

    /**
     * Get all of ASRFSTB's bit fields.
     *
     * (read-write) ASRC FIFO Status Register for Pair B
     */
    inline void get_ASRFSTB(bool &OAFB, uint8_t &OUTFIFO_FILLB, bool &IAEB,
                            uint8_t &INFIFO_FILLB) volatile
    {
        uint32_t curr = ASRFSTB;

        OAFB = curr & (1u << 23u);
        OUTFIFO_FILLB = (curr >> 12u) & 0b1111111u;
        IAEB = curr & (1u << 11u);
        INFIFO_FILLB = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Get ASRMCRC's ZEROBUFC bit.
     *
     * ZEROBUFC
     */
    inline bool get_ASRMCRC_ZEROBUFC() volatile
    {
        return ASRMCRC & (1u << 23u);
    }

    /**
     * Set ASRMCRC's ZEROBUFC bit.
     *
     * ZEROBUFC
     */
    inline void set_ASRMCRC_ZEROBUFC() volatile
    {
        ASRMCRC |= 1u << 23u;
    }

    /**
     * Clear ASRMCRC's ZEROBUFC bit.
     *
     * ZEROBUFC
     */
    inline void clear_ASRMCRC_ZEROBUFC() volatile
    {
        ASRMCRC &= ~(1u << 23u);
    }

    /**
     * Toggle ASRMCRC's ZEROBUFC bit.
     *
     * ZEROBUFC
     */
    inline void toggle_ASRMCRC_ZEROBUFC() volatile
    {
        ASRMCRC ^= 1u << 23u;
    }

    /**
     * Get ASRMCRC's EXTTHRSHC bit.
     *
     * EXTTHRSHC
     */
    inline bool get_ASRMCRC_EXTTHRSHC() volatile
    {
        return ASRMCRC & (1u << 22u);
    }

    /**
     * Set ASRMCRC's EXTTHRSHC bit.
     *
     * EXTTHRSHC
     */
    inline void set_ASRMCRC_EXTTHRSHC() volatile
    {
        ASRMCRC |= 1u << 22u;
    }

    /**
     * Clear ASRMCRC's EXTTHRSHC bit.
     *
     * EXTTHRSHC
     */
    inline void clear_ASRMCRC_EXTTHRSHC() volatile
    {
        ASRMCRC &= ~(1u << 22u);
    }

    /**
     * Toggle ASRMCRC's EXTTHRSHC bit.
     *
     * EXTTHRSHC
     */
    inline void toggle_ASRMCRC_EXTTHRSHC() volatile
    {
        ASRMCRC ^= 1u << 22u;
    }

    /**
     * Get ASRMCRC's BUFSTALLC bit.
     *
     * BUFSTALLC
     */
    inline bool get_ASRMCRC_BUFSTALLC() volatile
    {
        return ASRMCRC & (1u << 21u);
    }

    /**
     * Set ASRMCRC's BUFSTALLC bit.
     *
     * BUFSTALLC
     */
    inline void set_ASRMCRC_BUFSTALLC() volatile
    {
        ASRMCRC |= 1u << 21u;
    }

    /**
     * Clear ASRMCRC's BUFSTALLC bit.
     *
     * BUFSTALLC
     */
    inline void clear_ASRMCRC_BUFSTALLC() volatile
    {
        ASRMCRC &= ~(1u << 21u);
    }

    /**
     * Toggle ASRMCRC's BUFSTALLC bit.
     *
     * BUFSTALLC
     */
    inline void toggle_ASRMCRC_BUFSTALLC() volatile
    {
        ASRMCRC ^= 1u << 21u;
    }

    /**
     * Get ASRMCRC's BYPASSPOLYC bit.
     *
     * BYPASSPOLYC
     */
    inline bool get_ASRMCRC_BYPASSPOLYC() volatile
    {
        return ASRMCRC & (1u << 20u);
    }

    /**
     * Set ASRMCRC's BYPASSPOLYC bit.
     *
     * BYPASSPOLYC
     */
    inline void set_ASRMCRC_BYPASSPOLYC() volatile
    {
        ASRMCRC |= 1u << 20u;
    }

    /**
     * Clear ASRMCRC's BYPASSPOLYC bit.
     *
     * BYPASSPOLYC
     */
    inline void clear_ASRMCRC_BYPASSPOLYC() volatile
    {
        ASRMCRC &= ~(1u << 20u);
    }

    /**
     * Toggle ASRMCRC's BYPASSPOLYC bit.
     *
     * BYPASSPOLYC
     */
    inline void toggle_ASRMCRC_BYPASSPOLYC() volatile
    {
        ASRMCRC ^= 1u << 20u;
    }

    /**
     * Get ASRMCRC's OUTFIFO_THRESHOLDC field.
     *
     * OUTFIFO_THRESHOLDC
     */
    inline uint8_t get_ASRMCRC_OUTFIFO_THRESHOLDC() volatile
    {
        return (ASRMCRC >> 12u) & 0b111111u;
    }

    /**
     * Set ASRMCRC's OUTFIFO_THRESHOLDC field.
     *
     * OUTFIFO_THRESHOLDC
     */
    inline void set_ASRMCRC_OUTFIFO_THRESHOLDC(uint8_t value) volatile
    {
        uint32_t curr = ASRMCRC;

        curr &= ~(0b111111u << 12u);
        curr |= (value & 0b111111u) << 12u;

        ASRMCRC = curr;
    }

    /**
     * Get ASRMCRC's RSYNIFC bit.
     *
     * RSYNIFC
     */
    inline bool get_ASRMCRC_RSYNIFC() volatile
    {
        return ASRMCRC & (1u << 11u);
    }

    /**
     * Set ASRMCRC's RSYNIFC bit.
     *
     * RSYNIFC
     */
    inline void set_ASRMCRC_RSYNIFC() volatile
    {
        ASRMCRC |= 1u << 11u;
    }

    /**
     * Clear ASRMCRC's RSYNIFC bit.
     *
     * RSYNIFC
     */
    inline void clear_ASRMCRC_RSYNIFC() volatile
    {
        ASRMCRC &= ~(1u << 11u);
    }

    /**
     * Toggle ASRMCRC's RSYNIFC bit.
     *
     * RSYNIFC
     */
    inline void toggle_ASRMCRC_RSYNIFC() volatile
    {
        ASRMCRC ^= 1u << 11u;
    }

    /**
     * Get ASRMCRC's RSYNOFC bit.
     *
     * RSYNOFC
     */
    inline bool get_ASRMCRC_RSYNOFC() volatile
    {
        return ASRMCRC & (1u << 10u);
    }

    /**
     * Set ASRMCRC's RSYNOFC bit.
     *
     * RSYNOFC
     */
    inline void set_ASRMCRC_RSYNOFC() volatile
    {
        ASRMCRC |= 1u << 10u;
    }

    /**
     * Clear ASRMCRC's RSYNOFC bit.
     *
     * RSYNOFC
     */
    inline void clear_ASRMCRC_RSYNOFC() volatile
    {
        ASRMCRC &= ~(1u << 10u);
    }

    /**
     * Toggle ASRMCRC's RSYNOFC bit.
     *
     * RSYNOFC
     */
    inline void toggle_ASRMCRC_RSYNOFC() volatile
    {
        ASRMCRC ^= 1u << 10u;
    }

    /**
     * Get ASRMCRC's INFIFO_THRESHOLDC field.
     *
     * INFIFO_THRESHOLDC
     */
    inline uint8_t get_ASRMCRC_INFIFO_THRESHOLDC() volatile
    {
        return (ASRMCRC >> 0u) & 0b111111u;
    }

    /**
     * Set ASRMCRC's INFIFO_THRESHOLDC field.
     *
     * INFIFO_THRESHOLDC
     */
    inline void set_ASRMCRC_INFIFO_THRESHOLDC(uint8_t value) volatile
    {
        uint32_t curr = ASRMCRC;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        ASRMCRC = curr;
    }

    /**
     * Get all of ASRMCRC's bit fields.
     *
     * (read-write) ASRC Misc Control Register for Pair C
     */
    inline void get_ASRMCRC(bool &ZEROBUFC, bool &EXTTHRSHC, bool &BUFSTALLC,
                            bool &BYPASSPOLYC, uint8_t &OUTFIFO_THRESHOLDC,
                            bool &RSYNIFC, bool &RSYNOFC,
                            uint8_t &INFIFO_THRESHOLDC) volatile
    {
        uint32_t curr = ASRMCRC;

        ZEROBUFC = curr & (1u << 23u);
        EXTTHRSHC = curr & (1u << 22u);
        BUFSTALLC = curr & (1u << 21u);
        BYPASSPOLYC = curr & (1u << 20u);
        OUTFIFO_THRESHOLDC = (curr >> 12u) & 0b111111u;
        RSYNIFC = curr & (1u << 11u);
        RSYNOFC = curr & (1u << 10u);
        INFIFO_THRESHOLDC = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of ASRMCRC's bit fields.
     *
     * (read-write) ASRC Misc Control Register for Pair C
     */
    inline void set_ASRMCRC(bool ZEROBUFC, bool EXTTHRSHC, bool BUFSTALLC,
                            bool BYPASSPOLYC, uint8_t OUTFIFO_THRESHOLDC,
                            bool RSYNIFC, bool RSYNOFC,
                            uint8_t INFIFO_THRESHOLDC) volatile
    {
        uint32_t curr = ASRMCRC;

        curr &= ~(0b1u << 23u);
        curr |= (ZEROBUFC & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (EXTTHRSHC & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (BUFSTALLC & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BYPASSPOLYC & 0b1u) << 20u;
        curr &= ~(0b111111u << 12u);
        curr |= (OUTFIFO_THRESHOLDC & 0b111111u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (RSYNIFC & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (RSYNOFC & 0b1u) << 10u;
        curr &= ~(0b111111u << 0u);
        curr |= (INFIFO_THRESHOLDC & 0b111111u) << 0u;

        ASRMCRC = curr;
    }

    /**
     * Get ASRFSTC's OAFC bit.
     *
     * OAFC
     */
    inline bool get_ASRFSTC_OAFC() volatile
    {
        return ASRFSTC & (1u << 23u);
    }

    /**
     * Get ASRFSTC's OUTFIFO_FILLC field.
     *
     * OUTFIFO_FILLC
     */
    inline uint8_t get_ASRFSTC_OUTFIFO_FILLC() volatile
    {
        return (ASRFSTC >> 12u) & 0b1111111u;
    }

    /**
     * Get ASRFSTC's IAEC bit.
     *
     * IAEC
     */
    inline bool get_ASRFSTC_IAEC() volatile
    {
        return ASRFSTC & (1u << 11u);
    }

    /**
     * Get ASRFSTC's INFIFO_FILLC field.
     *
     * INFIFO_FILLC
     */
    inline uint8_t get_ASRFSTC_INFIFO_FILLC() volatile
    {
        return (ASRFSTC >> 0u) & 0b1111111u;
    }

    /**
     * Get all of ASRFSTC's bit fields.
     *
     * (read-write) ASRC FIFO Status Register for Pair C
     */
    inline void get_ASRFSTC(bool &OAFC, uint8_t &OUTFIFO_FILLC, bool &IAEC,
                            uint8_t &INFIFO_FILLC) volatile
    {
        uint32_t curr = ASRFSTC;

        OAFC = curr & (1u << 23u);
        OUTFIFO_FILLC = (curr >> 12u) & 0b1111111u;
        IAEC = curr & (1u << 11u);
        INFIFO_FILLC = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Get ASRMCR1's IWD field.
     *
     * IWD
     */
    inline ASRC_ASRMCR1_IWD get_ASRMCR1_IWD(std::size_t index) volatile
    {
        return ASRC_ASRMCR1_IWD((ASRMCR1[index] >> 9u) & 0b11u);
    }

    /**
     * Set ASRMCR1's IWD field.
     *
     * IWD
     */
    inline void set_ASRMCR1_IWD(std::size_t index,
                                ASRC_ASRMCR1_IWD value) volatile
    {
        uint32_t curr = ASRMCR1[index];

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(value) & 0b11u) << 9u;

        ASRMCR1[index] = curr;
    }

    /**
     * Get ASRMCR1's IMSB bit.
     *
     * IMSB
     */
    inline bool get_ASRMCR1_IMSB(std::size_t index) volatile
    {
        return ASRMCR1[index] & (1u << 8u);
    }

    /**
     * Set ASRMCR1's IMSB bit.
     *
     * IMSB
     */
    inline void set_ASRMCR1_IMSB() volatile
    {
        ASRMCR1 |= 1u << 8u;
    }

    /**
     * Clear ASRMCR1's IMSB bit.
     *
     * IMSB
     */
    inline void clear_ASRMCR1_IMSB() volatile
    {
        ASRMCR1 &= ~(1u << 8u);
    }

    /**
     * Toggle ASRMCR1's IMSB bit.
     *
     * IMSB
     */
    inline void toggle_ASRMCR1_IMSB() volatile
    {
        ASRMCR1 ^= 1u << 8u;
    }

    /**
     * Get ASRMCR1's OMSB bit.
     *
     * OMSB
     */
    inline bool get_ASRMCR1_OMSB(std::size_t index) volatile
    {
        return ASRMCR1[index] & (1u << 2u);
    }

    /**
     * Set ASRMCR1's OMSB bit.
     *
     * OMSB
     */
    inline void set_ASRMCR1_OMSB() volatile
    {
        ASRMCR1 |= 1u << 2u;
    }

    /**
     * Clear ASRMCR1's OMSB bit.
     *
     * OMSB
     */
    inline void clear_ASRMCR1_OMSB() volatile
    {
        ASRMCR1 &= ~(1u << 2u);
    }

    /**
     * Toggle ASRMCR1's OMSB bit.
     *
     * OMSB
     */
    inline void toggle_ASRMCR1_OMSB() volatile
    {
        ASRMCR1 ^= 1u << 2u;
    }

    /**
     * Get ASRMCR1's OSGN bit.
     *
     * OSGN
     */
    inline bool get_ASRMCR1_OSGN(std::size_t index) volatile
    {
        return ASRMCR1[index] & (1u << 1u);
    }

    /**
     * Set ASRMCR1's OSGN bit.
     *
     * OSGN
     */
    inline void set_ASRMCR1_OSGN() volatile
    {
        ASRMCR1 |= 1u << 1u;
    }

    /**
     * Clear ASRMCR1's OSGN bit.
     *
     * OSGN
     */
    inline void clear_ASRMCR1_OSGN() volatile
    {
        ASRMCR1 &= ~(1u << 1u);
    }

    /**
     * Toggle ASRMCR1's OSGN bit.
     *
     * OSGN
     */
    inline void toggle_ASRMCR1_OSGN() volatile
    {
        ASRMCR1 ^= 1u << 1u;
    }

    /**
     * Get ASRMCR1's OW16 bit.
     *
     * OW16
     */
    inline bool get_ASRMCR1_OW16(std::size_t index) volatile
    {
        return ASRMCR1[index] & (1u << 0u);
    }

    /**
     * Set ASRMCR1's OW16 bit.
     *
     * OW16
     */
    inline void set_ASRMCR1_OW16() volatile
    {
        ASRMCR1 |= 1u << 0u;
    }

    /**
     * Clear ASRMCR1's OW16 bit.
     *
     * OW16
     */
    inline void clear_ASRMCR1_OW16() volatile
    {
        ASRMCR1 &= ~(1u << 0u);
    }

    /**
     * Toggle ASRMCR1's OW16 bit.
     *
     * OW16
     */
    inline void toggle_ASRMCR1_OW16() volatile
    {
        ASRMCR1 ^= 1u << 0u;
    }

    /**
     * Get all of ASRMCR1's bit fields.
     *
     * (read-write) ASRC Misc Control Register 1 for Pair X
     */
    inline void get_ASRMCR1(std::size_t index, ASRC_ASRMCR1_IWD &IWD,
                            bool &IMSB, bool &OMSB, bool &OSGN,
                            bool &OW16) volatile
    {
        uint32_t curr = ASRMCR1[index];

        IWD = ASRC_ASRMCR1_IWD((curr >> 9u) & 0b11u);
        IMSB = curr & (1u << 8u);
        OMSB = curr & (1u << 2u);
        OSGN = curr & (1u << 1u);
        OW16 = curr & (1u << 0u);
    }

    /**
     * Set all of ASRMCR1's bit fields.
     *
     * (read-write) ASRC Misc Control Register 1 for Pair X
     */
    inline void set_ASRMCR1(std::size_t index, ASRC_ASRMCR1_IWD IWD, bool IMSB,
                            bool OMSB, bool OSGN, bool OW16) volatile
    {
        uint32_t curr = ASRMCR1[index];

        curr &= ~(0b11u << 9u);
        curr |= (std::to_underlying(IWD) & 0b11u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (IMSB & 0b1u) << 8u;
        curr &= ~(0b1u << 2u);
        curr |= (OMSB & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OSGN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OW16 & 0b1u) << 0u;

        ASRMCR1[index] = curr;
    }
};

static_assert(sizeof(asrc) == asrc::size);

static volatile asrc *const ASRC = reinterpret_cast<asrc *>(0x40414000);

}; // namespace MIMXRT1176::CM7
