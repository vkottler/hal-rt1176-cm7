/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/SEMC_BR10_MS.h"
#include "../enums/SEMC_BR11_MS.h"
#include "../enums/SEMC_BR9_MS.h"
#include "../enums/SEMC_BR_MS.h"
#include "../enums/SEMC_DBICR0_BL.h"
#include "../enums/SEMC_DBICR0_COL.h"
#include "../enums/SEMC_IOCR_MUX_A8.h"
#include "../enums/SEMC_IOCR_MUX_CLKX0.h"
#include "../enums/SEMC_IOCR_MUX_CLKX1.h"
#include "../enums/SEMC_IOCR_MUX_CSX0.h"
#include "../enums/SEMC_IOCR_MUX_CSX1.h"
#include "../enums/SEMC_IOCR_MUX_CSX2.h"
#include "../enums/SEMC_IOCR_MUX_CSX3.h"
#include "../enums/SEMC_IOCR_MUX_RDY.h"
#include "../enums/SEMC_IPCR1_DATSZ.h"
#include "../enums/SEMC_MCR_BTO.h"
#include "../enums/SEMC_NANDCR0_BL.h"
#include "../enums/SEMC_NANDCR0_COL.h"
#include "../enums/SEMC_NORCR0_AM.h"
#include "../enums/SEMC_NORCR0_BL.h"
#include "../enums/SEMC_NORCR0_COL.h"
#include "../enums/SEMC_SDRAMCR0_BL.h"
#include "../enums/SEMC_SDRAMCR0_CL.h"
#include "../enums/SEMC_SDRAMCR0_COL.h"
#include "../enums/SEMC_SDRAMCR0_PS.h"
#include "../enums/SEMC_SDRAMCR2_ITO.h"
#include "../enums/SEMC_SDRAMCR3_PRESCALE.h"
#include "../enums/SEMC_SDRAMCR3_REBL.h"
#include "../enums/SEMC_SDRAMCR3_RT.h"
#include "../enums/SEMC_SDRAMCR3_UT.h"
#include "../enums/SEMC_SRAMCR0_AM.h"
#include "../enums/SEMC_SRAMCR0_BL.h"
#include "../enums/SEMC_SRAMCR0_COL.h"
#include "../enums/SEMC_SRAMCR4_AM.h"
#include "../enums/SEMC_SRAMCR4_BL.h"
#include "../enums/SEMC_SRAMCR4_COL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * SEMC
 */
struct [[gnu::packed]] semc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 340; /*!< semc's size in bytes. */

    /* Fields. */
    uint32_t MCR;   /*!< (read-write) Module Control Register */
    uint32_t IOCR;  /*!< (read-write) IO MUX Control Register */
    uint32_t BMCR0; /*!< (read-write) Bus (AXI) Master Control Register 0 */
    uint32_t BMCR1; /*!< (read-write) Bus (AXI) Master Control Register 1 */
    static constexpr std::size_t BR_length = 9;
    uint32_t BR[BR_length]; /*!< (read-write) Base Register n */
    uint32_t DLLCR;         /*!< (read-write) DLL Control Register */
    uint32_t INTEN;         /*!< (read-write) Interrupt Enable Register */
    uint32_t INTR;          /*!< (read-write) Interrupt Register */
    uint32_t SDRAMCR0;      /*!< (read-write) SDRAM Control Register 0 */
    uint32_t SDRAMCR1;      /*!< (read-write) SDRAM Control Register 1 */
    uint32_t SDRAMCR2;      /*!< (read-write) SDRAM Control Register 2 */
    uint32_t SDRAMCR3;      /*!< (read-write) SDRAM Control Register 3 */
    uint32_t NANDCR0;       /*!< (read-write) NAND Control Register 0 */
    uint32_t NANDCR1;       /*!< (read-write) NAND Control Register 1 */
    uint32_t NANDCR2;       /*!< (read-write) NAND Control Register 2 */
    uint32_t NANDCR3;       /*!< (read-write) NAND Control Register 3 */
    uint32_t NORCR0;        /*!< (read-write) NOR Control Register 0 */
    uint32_t NORCR1;        /*!< (read-write) NOR Control Register 1 */
    uint32_t NORCR2;        /*!< (read-write) NOR Control Register 2 */
    uint32_t NORCR3;        /*!< (read-write) NOR Control Register 3 */
    uint32_t SRAMCR0;       /*!< (read-write) SRAM Control Register 0 */
    uint32_t SRAMCR1;       /*!< (read-write) SRAM Control Register 1 */
    uint32_t SRAMCR2;       /*!< (read-write) SRAM Control Register 2 */
    uint32_t SRAMCR3;       /*!< (read-write) SRAM Control Register 3 */
    uint32_t DBICR0;        /*!< (read-write) DBI-B Control Register 0 */
    uint32_t DBICR1;        /*!< (read-write) DBI-B Control Register 1 */
    uint32_t DBICR2;        /*!< (read-write) DBI-B Control Register 2 */
    const uint32_t reserved_padding0 = {};
    uint32_t IPCR0;   /*!< (read-write) IP Command Control Register 0 */
    uint32_t IPCR1;   /*!< (read-write) IP Command Control Register 1 */
    uint32_t IPCR2;   /*!< (read-write) IP Command Control Register 2 */
    uint32_t IPCMD;   /*!< (read-write) IP Command Register */
    uint32_t IPTXDAT; /*!< (read-write) TX DATA Register */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t IPRXDAT; /*!< (read-write) RX DATA Register */
    static constexpr std::size_t reserved_padding2_length = 3;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t STS0;  /*!< (read-write) Status Register 0 */
    uint32_t STS1;  /*!< (read-write) Status Register 1 */
    uint32_t STS2;  /*!< (read-write) Status Register 2 */
    uint32_t STS3;  /*!< (read-write) Status Register 3 */
    uint32_t STS4;  /*!< (read-write) Status Register 4 */
    uint32_t STS5;  /*!< (read-write) Status Register 5 */
    uint32_t STS6;  /*!< (read-write) Status Register 6 */
    uint32_t STS7;  /*!< (read-write) Status Register 7 */
    uint32_t STS8;  /*!< (read-write) Status Register 8 */
    uint32_t STS9;  /*!< (read-write) Status Register 9 */
    uint32_t STS10; /*!< (read-write) Status Register 10 */
    uint32_t STS11; /*!< (read-write) Status Register 11 */
    uint32_t STS12; /*!< (read-write) Status Register 12 */
    uint32_t STS13; /*!< (read-write) Status Register 13 */
    uint32_t STS14; /*!< (read-write) Status Register 14 */
    uint32_t STS15; /*!< (read-write) Status Register 15 */
    uint32_t BR9;   /*!< (read-write) Base Register 9 */
    uint32_t BR10;  /*!< (read-write) Base Register 10 */
    uint32_t BR11;  /*!< (read-write) Base Register 11 */
    static constexpr std::size_t reserved_padding3_length = 5;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t SRAMCR4; /*!< (read-write) SRAM Control Register 4 */
    uint32_t SRAMCR5; /*!< (read-write) SRAM Control Register 5 */
    uint32_t SRAMCR6; /*!< (read-write) SRAM Control Register 6 */
    static constexpr std::size_t reserved_padding4_length = 9;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t DCCR; /*!< (read-write) Delay Chain Control Register */

    /* Methods. */

    /**
     * Get MCR's BTO field.
     *
     * Bus timeout cycles
     */
    inline SEMC_MCR_BTO get_MCR_BTO() volatile
    {
        return SEMC_MCR_BTO((MCR >> 24u) & 0b11111u);
    }

    /**
     * Set MCR's BTO field.
     *
     * Bus timeout cycles
     */
    inline void set_MCR_BTO(SEMC_MCR_BTO value) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b11111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111u) << 24u;

        MCR = curr;
    }

    /**
     * Get MCR's CTO field.
     *
     * Command Execution timeout cycles
     */
    inline uint8_t get_MCR_CTO() volatile
    {
        return (MCR >> 16u) & 0b11111111u;
    }

    /**
     * Set MCR's CTO field.
     *
     * Command Execution timeout cycles
     */
    inline void set_MCR_CTO(uint8_t value) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        MCR = curr;
    }

    /**
     * Get MCR's WPOL1 bit.
     *
     * R/B# polarity for NAND device
     */
    inline bool get_MCR_WPOL1() volatile
    {
        return MCR & (1u << 7u);
    }

    /**
     * Set MCR's WPOL1 bit.
     *
     * R/B# polarity for NAND device
     */
    inline void set_MCR_WPOL1() volatile
    {
        MCR |= 1u << 7u;
    }

    /**
     * Clear MCR's WPOL1 bit.
     *
     * R/B# polarity for NAND device
     */
    inline void clear_MCR_WPOL1() volatile
    {
        MCR &= ~(1u << 7u);
    }

    /**
     * Toggle MCR's WPOL1 bit.
     *
     * R/B# polarity for NAND device
     */
    inline void toggle_MCR_WPOL1() volatile
    {
        MCR ^= 1u << 7u;
    }

    /**
     * Get MCR's WPOL0 bit.
     *
     * WAIT/RDY polarity for SRAM/NOR
     */
    inline bool get_MCR_WPOL0() volatile
    {
        return MCR & (1u << 6u);
    }

    /**
     * Set MCR's WPOL0 bit.
     *
     * WAIT/RDY polarity for SRAM/NOR
     */
    inline void set_MCR_WPOL0() volatile
    {
        MCR |= 1u << 6u;
    }

    /**
     * Clear MCR's WPOL0 bit.
     *
     * WAIT/RDY polarity for SRAM/NOR
     */
    inline void clear_MCR_WPOL0() volatile
    {
        MCR &= ~(1u << 6u);
    }

    /**
     * Toggle MCR's WPOL0 bit.
     *
     * WAIT/RDY polarity for SRAM/NOR
     */
    inline void toggle_MCR_WPOL0() volatile
    {
        MCR ^= 1u << 6u;
    }

    /**
     * Get MCR's DQSMD bit.
     *
     * DQS (read strobe) mode
     */
    inline bool get_MCR_DQSMD() volatile
    {
        return MCR & (1u << 2u);
    }

    /**
     * Set MCR's DQSMD bit.
     *
     * DQS (read strobe) mode
     */
    inline void set_MCR_DQSMD() volatile
    {
        MCR |= 1u << 2u;
    }

    /**
     * Clear MCR's DQSMD bit.
     *
     * DQS (read strobe) mode
     */
    inline void clear_MCR_DQSMD() volatile
    {
        MCR &= ~(1u << 2u);
    }

    /**
     * Toggle MCR's DQSMD bit.
     *
     * DQS (read strobe) mode
     */
    inline void toggle_MCR_DQSMD() volatile
    {
        MCR ^= 1u << 2u;
    }

    /**
     * Get MCR's MDIS bit.
     *
     * Module Disable
     */
    inline bool get_MCR_MDIS() volatile
    {
        return MCR & (1u << 1u);
    }

    /**
     * Set MCR's MDIS bit.
     *
     * Module Disable
     */
    inline void set_MCR_MDIS() volatile
    {
        MCR |= 1u << 1u;
    }

    /**
     * Clear MCR's MDIS bit.
     *
     * Module Disable
     */
    inline void clear_MCR_MDIS() volatile
    {
        MCR &= ~(1u << 1u);
    }

    /**
     * Toggle MCR's MDIS bit.
     *
     * Module Disable
     */
    inline void toggle_MCR_MDIS() volatile
    {
        MCR ^= 1u << 1u;
    }

    /**
     * Get MCR's SWRST bit.
     *
     * Software Reset
     */
    inline bool get_MCR_SWRST() volatile
    {
        return MCR & (1u << 0u);
    }

    /**
     * Set MCR's SWRST bit.
     *
     * Software Reset
     */
    inline void set_MCR_SWRST() volatile
    {
        MCR |= 1u << 0u;
    }

    /**
     * Clear MCR's SWRST bit.
     *
     * Software Reset
     */
    inline void clear_MCR_SWRST() volatile
    {
        MCR &= ~(1u << 0u);
    }

    /**
     * Toggle MCR's SWRST bit.
     *
     * Software Reset
     */
    inline void toggle_MCR_SWRST() volatile
    {
        MCR ^= 1u << 0u;
    }

    /**
     * Get all of MCR's bit fields.
     *
     * (read-write) Module Control Register
     */
    inline void get_MCR(SEMC_MCR_BTO &BTO, uint8_t &CTO, bool &WPOL1,
                        bool &WPOL0, bool &DQSMD, bool &MDIS,
                        bool &SWRST) volatile
    {
        uint32_t curr = MCR;

        BTO = SEMC_MCR_BTO((curr >> 24u) & 0b11111u);
        CTO = (curr >> 16u) & 0b11111111u;
        WPOL1 = curr & (1u << 7u);
        WPOL0 = curr & (1u << 6u);
        DQSMD = curr & (1u << 2u);
        MDIS = curr & (1u << 1u);
        SWRST = curr & (1u << 0u);
    }

    /**
     * Set all of MCR's bit fields.
     *
     * (read-write) Module Control Register
     */
    inline void set_MCR(SEMC_MCR_BTO BTO, uint8_t CTO, bool WPOL1, bool WPOL0,
                        bool DQSMD, bool MDIS, bool SWRST) volatile
    {
        uint32_t curr = MCR;

        curr &= ~(0b11111u << 24u);
        curr |= (std::to_underlying(BTO) & 0b11111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (CTO & 0b11111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (WPOL1 & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (WPOL0 & 0b1u) << 6u;
        curr &= ~(0b1u << 2u);
        curr |= (DQSMD & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (MDIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SWRST & 0b1u) << 0u;

        MCR = curr;
    }

    /**
     * Get IOCR's CLKX1_AO bit.
     *
     * SEMC_CLKX1 Always On
     */
    inline bool get_IOCR_CLKX1_AO() volatile
    {
        return IOCR & (1u << 29u);
    }

    /**
     * Set IOCR's CLKX1_AO bit.
     *
     * SEMC_CLKX1 Always On
     */
    inline void set_IOCR_CLKX1_AO() volatile
    {
        IOCR |= 1u << 29u;
    }

    /**
     * Clear IOCR's CLKX1_AO bit.
     *
     * SEMC_CLKX1 Always On
     */
    inline void clear_IOCR_CLKX1_AO() volatile
    {
        IOCR &= ~(1u << 29u);
    }

    /**
     * Toggle IOCR's CLKX1_AO bit.
     *
     * SEMC_CLKX1 Always On
     */
    inline void toggle_IOCR_CLKX1_AO() volatile
    {
        IOCR ^= 1u << 29u;
    }

    /**
     * Get IOCR's CLKX0_AO bit.
     *
     * SEMC_CLKX0 Always On
     */
    inline bool get_IOCR_CLKX0_AO() volatile
    {
        return IOCR & (1u << 28u);
    }

    /**
     * Set IOCR's CLKX0_AO bit.
     *
     * SEMC_CLKX0 Always On
     */
    inline void set_IOCR_CLKX0_AO() volatile
    {
        IOCR |= 1u << 28u;
    }

    /**
     * Clear IOCR's CLKX0_AO bit.
     *
     * SEMC_CLKX0 Always On
     */
    inline void clear_IOCR_CLKX0_AO() volatile
    {
        IOCR &= ~(1u << 28u);
    }

    /**
     * Toggle IOCR's CLKX0_AO bit.
     *
     * SEMC_CLKX0 Always On
     */
    inline void toggle_IOCR_CLKX0_AO() volatile
    {
        IOCR ^= 1u << 28u;
    }

    /**
     * Get IOCR's MUX_CLKX1 field.
     *
     * SEMC_CLKX1 function selection
     */
    inline SEMC_IOCR_MUX_CLKX1 get_IOCR_MUX_CLKX1() volatile
    {
        return SEMC_IOCR_MUX_CLKX1((IOCR >> 26u) & 0b11u);
    }

    /**
     * Set IOCR's MUX_CLKX1 field.
     *
     * SEMC_CLKX1 function selection
     */
    inline void set_IOCR_MUX_CLKX1(SEMC_IOCR_MUX_CLKX1 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_CLKX0 field.
     *
     * SEMC_CLKX0 function selection
     */
    inline SEMC_IOCR_MUX_CLKX0 get_IOCR_MUX_CLKX0() volatile
    {
        return SEMC_IOCR_MUX_CLKX0((IOCR >> 24u) & 0b11u);
    }

    /**
     * Set IOCR's MUX_CLKX0 field.
     *
     * SEMC_CLKX0 function selection
     */
    inline void set_IOCR_MUX_CLKX0(SEMC_IOCR_MUX_CLKX0 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(value) & 0b11u) << 24u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_RDY field.
     *
     * SEMC_RDY function selection
     */
    inline SEMC_IOCR_MUX_RDY get_IOCR_MUX_RDY() volatile
    {
        return SEMC_IOCR_MUX_RDY((IOCR >> 20u) & 0b1111u);
    }

    /**
     * Set IOCR's MUX_RDY field.
     *
     * SEMC_RDY function selection
     */
    inline void set_IOCR_MUX_RDY(SEMC_IOCR_MUX_RDY value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(value) & 0b1111u) << 20u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_CSX3 field.
     *
     * SEMC_CSX3 output selection
     */
    inline SEMC_IOCR_MUX_CSX3 get_IOCR_MUX_CSX3() volatile
    {
        return SEMC_IOCR_MUX_CSX3((IOCR >> 16u) & 0b1111u);
    }

    /**
     * Set IOCR's MUX_CSX3 field.
     *
     * SEMC_CSX3 output selection
     */
    inline void set_IOCR_MUX_CSX3(SEMC_IOCR_MUX_CSX3 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_CSX2 field.
     *
     * SEMC_CSX2 output selection
     */
    inline SEMC_IOCR_MUX_CSX2 get_IOCR_MUX_CSX2() volatile
    {
        return SEMC_IOCR_MUX_CSX2((IOCR >> 12u) & 0b1111u);
    }

    /**
     * Set IOCR's MUX_CSX2 field.
     *
     * SEMC_CSX2 output selection
     */
    inline void set_IOCR_MUX_CSX2(SEMC_IOCR_MUX_CSX2 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_CSX1 field.
     *
     * SEMC_CSX1 output selection
     */
    inline SEMC_IOCR_MUX_CSX1 get_IOCR_MUX_CSX1() volatile
    {
        return SEMC_IOCR_MUX_CSX1((IOCR >> 8u) & 0b1111u);
    }

    /**
     * Set IOCR's MUX_CSX1 field.
     *
     * SEMC_CSX1 output selection
     */
    inline void set_IOCR_MUX_CSX1(SEMC_IOCR_MUX_CSX1 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_CSX0 field.
     *
     * SEMC_CSX0 output selection
     */
    inline SEMC_IOCR_MUX_CSX0 get_IOCR_MUX_CSX0() volatile
    {
        return SEMC_IOCR_MUX_CSX0((IOCR >> 4u) & 0b1111u);
    }

    /**
     * Set IOCR's MUX_CSX0 field.
     *
     * SEMC_CSX0 output selection
     */
    inline void set_IOCR_MUX_CSX0(SEMC_IOCR_MUX_CSX0 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        IOCR = curr;
    }

    /**
     * Get IOCR's MUX_A8 field.
     *
     * SEMC_ADDR08 output selection
     */
    inline SEMC_IOCR_MUX_A8 get_IOCR_MUX_A8() volatile
    {
        return SEMC_IOCR_MUX_A8((IOCR >> 0u) & 0b1111u);
    }

    /**
     * Set IOCR's MUX_A8 field.
     *
     * SEMC_ADDR08 output selection
     */
    inline void set_IOCR_MUX_A8(SEMC_IOCR_MUX_A8 value) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        IOCR = curr;
    }

    /**
     * Get all of IOCR's bit fields.
     *
     * (read-write) IO MUX Control Register
     */
    inline void get_IOCR(
        bool &CLKX1_AO, bool &CLKX0_AO, SEMC_IOCR_MUX_CLKX1 &MUX_CLKX1,
        SEMC_IOCR_MUX_CLKX0 &MUX_CLKX0, SEMC_IOCR_MUX_RDY &MUX_RDY,
        SEMC_IOCR_MUX_CSX3 &MUX_CSX3, SEMC_IOCR_MUX_CSX2 &MUX_CSX2,
        SEMC_IOCR_MUX_CSX1 &MUX_CSX1, SEMC_IOCR_MUX_CSX0 &MUX_CSX0,
        SEMC_IOCR_MUX_A8 &MUX_A8) volatile
    {
        uint32_t curr = IOCR;

        CLKX1_AO = curr & (1u << 29u);
        CLKX0_AO = curr & (1u << 28u);
        MUX_CLKX1 = SEMC_IOCR_MUX_CLKX1((curr >> 26u) & 0b11u);
        MUX_CLKX0 = SEMC_IOCR_MUX_CLKX0((curr >> 24u) & 0b11u);
        MUX_RDY = SEMC_IOCR_MUX_RDY((curr >> 20u) & 0b1111u);
        MUX_CSX3 = SEMC_IOCR_MUX_CSX3((curr >> 16u) & 0b1111u);
        MUX_CSX2 = SEMC_IOCR_MUX_CSX2((curr >> 12u) & 0b1111u);
        MUX_CSX1 = SEMC_IOCR_MUX_CSX1((curr >> 8u) & 0b1111u);
        MUX_CSX0 = SEMC_IOCR_MUX_CSX0((curr >> 4u) & 0b1111u);
        MUX_A8 = SEMC_IOCR_MUX_A8((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of IOCR's bit fields.
     *
     * (read-write) IO MUX Control Register
     */
    inline void set_IOCR(
        bool CLKX1_AO, bool CLKX0_AO, SEMC_IOCR_MUX_CLKX1 MUX_CLKX1,
        SEMC_IOCR_MUX_CLKX0 MUX_CLKX0, SEMC_IOCR_MUX_RDY MUX_RDY,
        SEMC_IOCR_MUX_CSX3 MUX_CSX3, SEMC_IOCR_MUX_CSX2 MUX_CSX2,
        SEMC_IOCR_MUX_CSX1 MUX_CSX1, SEMC_IOCR_MUX_CSX0 MUX_CSX0,
        SEMC_IOCR_MUX_A8 MUX_A8) volatile
    {
        uint32_t curr = IOCR;

        curr &= ~(0b1u << 29u);
        curr |= (CLKX1_AO & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (CLKX0_AO & 0b1u) << 28u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(MUX_CLKX1) & 0b11u) << 26u;
        curr &= ~(0b11u << 24u);
        curr |= (std::to_underlying(MUX_CLKX0) & 0b11u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (std::to_underlying(MUX_RDY) & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(MUX_CSX3) & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(MUX_CSX2) & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MUX_CSX1) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(MUX_CSX0) & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_A8) & 0b1111u) << 0u;

        IOCR = curr;
    }

    /**
     * Get BMCR0's WRWS field.
     *
     * Weight of slave hit with Read/Write Switch
     */
    inline uint8_t get_BMCR0_WRWS() volatile
    {
        return (BMCR0 >> 16u) & 0b11111111u;
    }

    /**
     * Set BMCR0's WRWS field.
     *
     * Weight of slave hit with Read/Write Switch
     */
    inline void set_BMCR0_WRWS(uint8_t value) volatile
    {
        uint32_t curr = BMCR0;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        BMCR0 = curr;
    }

    /**
     * Get BMCR0's WSH field.
     *
     * Weight of Slave Hit without read/write switch
     */
    inline uint8_t get_BMCR0_WSH() volatile
    {
        return (BMCR0 >> 8u) & 0b11111111u;
    }

    /**
     * Set BMCR0's WSH field.
     *
     * Weight of Slave Hit without read/write switch
     */
    inline void set_BMCR0_WSH(uint8_t value) volatile
    {
        uint32_t curr = BMCR0;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        BMCR0 = curr;
    }

    /**
     * Get BMCR0's WAGE field.
     *
     * Weight of AGE
     */
    inline uint8_t get_BMCR0_WAGE() volatile
    {
        return (BMCR0 >> 4u) & 0b1111u;
    }

    /**
     * Set BMCR0's WAGE field.
     *
     * Weight of AGE
     */
    inline void set_BMCR0_WAGE(uint8_t value) volatile
    {
        uint32_t curr = BMCR0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        BMCR0 = curr;
    }

    /**
     * Get BMCR0's WQOS field.
     *
     * Weight of QOS
     */
    inline uint8_t get_BMCR0_WQOS() volatile
    {
        return (BMCR0 >> 0u) & 0b1111u;
    }

    /**
     * Set BMCR0's WQOS field.
     *
     * Weight of QOS
     */
    inline void set_BMCR0_WQOS(uint8_t value) volatile
    {
        uint32_t curr = BMCR0;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        BMCR0 = curr;
    }

    /**
     * Get all of BMCR0's bit fields.
     *
     * (read-write) Bus (AXI) Master Control Register 0
     */
    inline void get_BMCR0(uint8_t &WRWS, uint8_t &WSH, uint8_t &WAGE,
                          uint8_t &WQOS) volatile
    {
        uint32_t curr = BMCR0;

        WRWS = (curr >> 16u) & 0b11111111u;
        WSH = (curr >> 8u) & 0b11111111u;
        WAGE = (curr >> 4u) & 0b1111u;
        WQOS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of BMCR0's bit fields.
     *
     * (read-write) Bus (AXI) Master Control Register 0
     */
    inline void set_BMCR0(uint8_t WRWS, uint8_t WSH, uint8_t WAGE,
                          uint8_t WQOS) volatile
    {
        uint32_t curr = BMCR0;

        curr &= ~(0b11111111u << 16u);
        curr |= (WRWS & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (WSH & 0b11111111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (WAGE & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (WQOS & 0b1111u) << 0u;

        BMCR0 = curr;
    }

    /**
     * Get BMCR1's WBR field.
     *
     * Weight of Bank Rotation
     */
    inline uint8_t get_BMCR1_WBR() volatile
    {
        return (BMCR1 >> 24u) & 0b11111111u;
    }

    /**
     * Set BMCR1's WBR field.
     *
     * Weight of Bank Rotation
     */
    inline void set_BMCR1_WBR(uint8_t value) volatile
    {
        uint32_t curr = BMCR1;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        BMCR1 = curr;
    }

    /**
     * Get BMCR1's WRWS field.
     *
     * Weight of slave hit without Read/Write Switch
     */
    inline uint8_t get_BMCR1_WRWS() volatile
    {
        return (BMCR1 >> 16u) & 0b11111111u;
    }

    /**
     * Set BMCR1's WRWS field.
     *
     * Weight of slave hit without Read/Write Switch
     */
    inline void set_BMCR1_WRWS(uint8_t value) volatile
    {
        uint32_t curr = BMCR1;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        BMCR1 = curr;
    }

    /**
     * Get BMCR1's WPH field.
     *
     * Weight of Page Hit
     */
    inline uint8_t get_BMCR1_WPH() volatile
    {
        return (BMCR1 >> 8u) & 0b11111111u;
    }

    /**
     * Set BMCR1's WPH field.
     *
     * Weight of Page Hit
     */
    inline void set_BMCR1_WPH(uint8_t value) volatile
    {
        uint32_t curr = BMCR1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        BMCR1 = curr;
    }

    /**
     * Get BMCR1's WAGE field.
     *
     * Weight of AGE
     */
    inline uint8_t get_BMCR1_WAGE() volatile
    {
        return (BMCR1 >> 4u) & 0b1111u;
    }

    /**
     * Set BMCR1's WAGE field.
     *
     * Weight of AGE
     */
    inline void set_BMCR1_WAGE(uint8_t value) volatile
    {
        uint32_t curr = BMCR1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        BMCR1 = curr;
    }

    /**
     * Get BMCR1's WQOS field.
     *
     * Weight of QOS
     */
    inline uint8_t get_BMCR1_WQOS() volatile
    {
        return (BMCR1 >> 0u) & 0b1111u;
    }

    /**
     * Set BMCR1's WQOS field.
     *
     * Weight of QOS
     */
    inline void set_BMCR1_WQOS(uint8_t value) volatile
    {
        uint32_t curr = BMCR1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        BMCR1 = curr;
    }

    /**
     * Get all of BMCR1's bit fields.
     *
     * (read-write) Bus (AXI) Master Control Register 1
     */
    inline void get_BMCR1(uint8_t &WBR, uint8_t &WRWS, uint8_t &WPH,
                          uint8_t &WAGE, uint8_t &WQOS) volatile
    {
        uint32_t curr = BMCR1;

        WBR = (curr >> 24u) & 0b11111111u;
        WRWS = (curr >> 16u) & 0b11111111u;
        WPH = (curr >> 8u) & 0b11111111u;
        WAGE = (curr >> 4u) & 0b1111u;
        WQOS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of BMCR1's bit fields.
     *
     * (read-write) Bus (AXI) Master Control Register 1
     */
    inline void set_BMCR1(uint8_t WBR, uint8_t WRWS, uint8_t WPH, uint8_t WAGE,
                          uint8_t WQOS) volatile
    {
        uint32_t curr = BMCR1;

        curr &= ~(0b11111111u << 24u);
        curr |= (WBR & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (WRWS & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (WPH & 0b11111111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (WAGE & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (WQOS & 0b1111u) << 0u;

        BMCR1 = curr;
    }

    /**
     * Get BR's BA field.
     *
     * Base Address
     */
    inline uint32_t get_BR_BA(std::size_t index) volatile
    {
        return (BR[index] >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set BR's BA field.
     *
     * Base Address
     */
    inline void set_BR_BA(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = BR[index];

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        BR[index] = curr;
    }

    /**
     * Get BR's MS field.
     *
     * Memory size
     */
    inline SEMC_BR_MS get_BR_MS(std::size_t index) volatile
    {
        return SEMC_BR_MS((BR[index] >> 1u) & 0b11111u);
    }

    /**
     * Set BR's MS field.
     *
     * Memory size
     */
    inline void set_BR_MS(std::size_t index, SEMC_BR_MS value) volatile
    {
        uint32_t curr = BR[index];

        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(value) & 0b11111u) << 1u;

        BR[index] = curr;
    }

    /**
     * Get BR's VLD bit.
     *
     * Valid
     */
    inline bool get_BR_VLD(std::size_t index) volatile
    {
        return BR[index] & (1u << 0u);
    }

    /**
     * Set BR's VLD bit.
     *
     * Valid
     */
    inline void set_BR_VLD() volatile
    {
        BR |= 1u << 0u;
    }

    /**
     * Clear BR's VLD bit.
     *
     * Valid
     */
    inline void clear_BR_VLD() volatile
    {
        BR &= ~(1u << 0u);
    }

    /**
     * Toggle BR's VLD bit.
     *
     * Valid
     */
    inline void toggle_BR_VLD() volatile
    {
        BR ^= 1u << 0u;
    }

    /**
     * Get all of BR's bit fields.
     *
     * (read-write) Base Register n
     */
    inline void get_BR(std::size_t index, uint32_t &BA, SEMC_BR_MS &MS,
                       bool &VLD) volatile
    {
        uint32_t curr = BR[index];

        BA = (curr >> 12u) & 0b11111111111111111111u;
        MS = SEMC_BR_MS((curr >> 1u) & 0b11111u);
        VLD = curr & (1u << 0u);
    }

    /**
     * Set all of BR's bit fields.
     *
     * (read-write) Base Register n
     */
    inline void set_BR(std::size_t index, uint32_t BA, SEMC_BR_MS MS,
                       bool VLD) volatile
    {
        uint32_t curr = BR[index];

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (BA & 0b11111111111111111111u) << 12u;
        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(MS) & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VLD & 0b1u) << 0u;

        BR[index] = curr;
    }

    /**
     * Get DLLCR's OVRDVAL field.
     *
     * Override Value
     */
    inline uint8_t get_DLLCR_OVRDVAL() volatile
    {
        return (DLLCR >> 9u) & 0b111111u;
    }

    /**
     * Set DLLCR's OVRDVAL field.
     *
     * Override Value
     */
    inline void set_DLLCR_OVRDVAL(uint8_t value) volatile
    {
        uint32_t curr = DLLCR;

        curr &= ~(0b111111u << 9u);
        curr |= (value & 0b111111u) << 9u;

        DLLCR = curr;
    }

    /**
     * Get DLLCR's OVRDEN bit.
     *
     * Override Enable
     */
    inline bool get_DLLCR_OVRDEN() volatile
    {
        return DLLCR & (1u << 8u);
    }

    /**
     * Set DLLCR's OVRDEN bit.
     *
     * Override Enable
     */
    inline void set_DLLCR_OVRDEN() volatile
    {
        DLLCR |= 1u << 8u;
    }

    /**
     * Clear DLLCR's OVRDEN bit.
     *
     * Override Enable
     */
    inline void clear_DLLCR_OVRDEN() volatile
    {
        DLLCR &= ~(1u << 8u);
    }

    /**
     * Toggle DLLCR's OVRDEN bit.
     *
     * Override Enable
     */
    inline void toggle_DLLCR_OVRDEN() volatile
    {
        DLLCR ^= 1u << 8u;
    }

    /**
     * Get DLLCR's SLVDLYTARGET field.
     *
     * Delay Target for Slave
     */
    inline uint8_t get_DLLCR_SLVDLYTARGET() volatile
    {
        return (DLLCR >> 3u) & 0b1111u;
    }

    /**
     * Set DLLCR's SLVDLYTARGET field.
     *
     * Delay Target for Slave
     */
    inline void set_DLLCR_SLVDLYTARGET(uint8_t value) volatile
    {
        uint32_t curr = DLLCR;

        curr &= ~(0b1111u << 3u);
        curr |= (value & 0b1111u) << 3u;

        DLLCR = curr;
    }

    /**
     * Get DLLCR's DLLRESET bit.
     *
     * DLL Reset
     */
    inline bool get_DLLCR_DLLRESET() volatile
    {
        return DLLCR & (1u << 1u);
    }

    /**
     * Set DLLCR's DLLRESET bit.
     *
     * DLL Reset
     */
    inline void set_DLLCR_DLLRESET() volatile
    {
        DLLCR |= 1u << 1u;
    }

    /**
     * Clear DLLCR's DLLRESET bit.
     *
     * DLL Reset
     */
    inline void clear_DLLCR_DLLRESET() volatile
    {
        DLLCR &= ~(1u << 1u);
    }

    /**
     * Toggle DLLCR's DLLRESET bit.
     *
     * DLL Reset
     */
    inline void toggle_DLLCR_DLLRESET() volatile
    {
        DLLCR ^= 1u << 1u;
    }

    /**
     * Get DLLCR's DLLEN bit.
     *
     * DLL calibration enable
     */
    inline bool get_DLLCR_DLLEN() volatile
    {
        return DLLCR & (1u << 0u);
    }

    /**
     * Set DLLCR's DLLEN bit.
     *
     * DLL calibration enable
     */
    inline void set_DLLCR_DLLEN() volatile
    {
        DLLCR |= 1u << 0u;
    }

    /**
     * Clear DLLCR's DLLEN bit.
     *
     * DLL calibration enable
     */
    inline void clear_DLLCR_DLLEN() volatile
    {
        DLLCR &= ~(1u << 0u);
    }

    /**
     * Toggle DLLCR's DLLEN bit.
     *
     * DLL calibration enable
     */
    inline void toggle_DLLCR_DLLEN() volatile
    {
        DLLCR ^= 1u << 0u;
    }

    /**
     * Get all of DLLCR's bit fields.
     *
     * (read-write) DLL Control Register
     */
    inline void get_DLLCR(uint8_t &OVRDVAL, bool &OVRDEN,
                          uint8_t &SLVDLYTARGET, bool &DLLRESET,
                          bool &DLLEN) volatile
    {
        uint32_t curr = DLLCR;

        OVRDVAL = (curr >> 9u) & 0b111111u;
        OVRDEN = curr & (1u << 8u);
        SLVDLYTARGET = (curr >> 3u) & 0b1111u;
        DLLRESET = curr & (1u << 1u);
        DLLEN = curr & (1u << 0u);
    }

    /**
     * Set all of DLLCR's bit fields.
     *
     * (read-write) DLL Control Register
     */
    inline void set_DLLCR(uint8_t OVRDVAL, bool OVRDEN, uint8_t SLVDLYTARGET,
                          bool DLLRESET, bool DLLEN) volatile
    {
        uint32_t curr = DLLCR;

        curr &= ~(0b111111u << 9u);
        curr |= (OVRDVAL & 0b111111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (OVRDEN & 0b1u) << 8u;
        curr &= ~(0b1111u << 3u);
        curr |= (SLVDLYTARGET & 0b1111u) << 3u;
        curr &= ~(0b1u << 1u);
        curr |= (DLLRESET & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (DLLEN & 0b1u) << 0u;

        DLLCR = curr;
    }

    /**
     * Get INTEN's NDNOPENDEN bit.
     *
     * NAND no pending AXI access interrupt enable
     */
    inline bool get_INTEN_NDNOPENDEN() volatile
    {
        return INTEN & (1u << 5u);
    }

    /**
     * Set INTEN's NDNOPENDEN bit.
     *
     * NAND no pending AXI access interrupt enable
     */
    inline void set_INTEN_NDNOPENDEN() volatile
    {
        INTEN |= 1u << 5u;
    }

    /**
     * Clear INTEN's NDNOPENDEN bit.
     *
     * NAND no pending AXI access interrupt enable
     */
    inline void clear_INTEN_NDNOPENDEN() volatile
    {
        INTEN &= ~(1u << 5u);
    }

    /**
     * Toggle INTEN's NDNOPENDEN bit.
     *
     * NAND no pending AXI access interrupt enable
     */
    inline void toggle_INTEN_NDNOPENDEN() volatile
    {
        INTEN ^= 1u << 5u;
    }

    /**
     * Get INTEN's NDPAGEENDEN bit.
     *
     * NAND page end interrupt enable
     */
    inline bool get_INTEN_NDPAGEENDEN() volatile
    {
        return INTEN & (1u << 4u);
    }

    /**
     * Set INTEN's NDPAGEENDEN bit.
     *
     * NAND page end interrupt enable
     */
    inline void set_INTEN_NDPAGEENDEN() volatile
    {
        INTEN |= 1u << 4u;
    }

    /**
     * Clear INTEN's NDPAGEENDEN bit.
     *
     * NAND page end interrupt enable
     */
    inline void clear_INTEN_NDPAGEENDEN() volatile
    {
        INTEN &= ~(1u << 4u);
    }

    /**
     * Toggle INTEN's NDPAGEENDEN bit.
     *
     * NAND page end interrupt enable
     */
    inline void toggle_INTEN_NDPAGEENDEN() volatile
    {
        INTEN ^= 1u << 4u;
    }

    /**
     * Get INTEN's AXIBUSERREN bit.
     *
     * AXI bus error interrupt enable
     */
    inline bool get_INTEN_AXIBUSERREN() volatile
    {
        return INTEN & (1u << 3u);
    }

    /**
     * Set INTEN's AXIBUSERREN bit.
     *
     * AXI bus error interrupt enable
     */
    inline void set_INTEN_AXIBUSERREN() volatile
    {
        INTEN |= 1u << 3u;
    }

    /**
     * Clear INTEN's AXIBUSERREN bit.
     *
     * AXI bus error interrupt enable
     */
    inline void clear_INTEN_AXIBUSERREN() volatile
    {
        INTEN &= ~(1u << 3u);
    }

    /**
     * Toggle INTEN's AXIBUSERREN bit.
     *
     * AXI bus error interrupt enable
     */
    inline void toggle_INTEN_AXIBUSERREN() volatile
    {
        INTEN ^= 1u << 3u;
    }

    /**
     * Get INTEN's AXICMDERREN bit.
     *
     * AXI command error interrupt enable
     */
    inline bool get_INTEN_AXICMDERREN() volatile
    {
        return INTEN & (1u << 2u);
    }

    /**
     * Set INTEN's AXICMDERREN bit.
     *
     * AXI command error interrupt enable
     */
    inline void set_INTEN_AXICMDERREN() volatile
    {
        INTEN |= 1u << 2u;
    }

    /**
     * Clear INTEN's AXICMDERREN bit.
     *
     * AXI command error interrupt enable
     */
    inline void clear_INTEN_AXICMDERREN() volatile
    {
        INTEN &= ~(1u << 2u);
    }

    /**
     * Toggle INTEN's AXICMDERREN bit.
     *
     * AXI command error interrupt enable
     */
    inline void toggle_INTEN_AXICMDERREN() volatile
    {
        INTEN ^= 1u << 2u;
    }

    /**
     * Get INTEN's IPCMDERREN bit.
     *
     * IP command error interrupt enable
     */
    inline bool get_INTEN_IPCMDERREN() volatile
    {
        return INTEN & (1u << 1u);
    }

    /**
     * Set INTEN's IPCMDERREN bit.
     *
     * IP command error interrupt enable
     */
    inline void set_INTEN_IPCMDERREN() volatile
    {
        INTEN |= 1u << 1u;
    }

    /**
     * Clear INTEN's IPCMDERREN bit.
     *
     * IP command error interrupt enable
     */
    inline void clear_INTEN_IPCMDERREN() volatile
    {
        INTEN &= ~(1u << 1u);
    }

    /**
     * Toggle INTEN's IPCMDERREN bit.
     *
     * IP command error interrupt enable
     */
    inline void toggle_INTEN_IPCMDERREN() volatile
    {
        INTEN ^= 1u << 1u;
    }

    /**
     * Get INTEN's IPCMDDONEEN bit.
     *
     * IP command done interrupt enable
     */
    inline bool get_INTEN_IPCMDDONEEN() volatile
    {
        return INTEN & (1u << 0u);
    }

    /**
     * Set INTEN's IPCMDDONEEN bit.
     *
     * IP command done interrupt enable
     */
    inline void set_INTEN_IPCMDDONEEN() volatile
    {
        INTEN |= 1u << 0u;
    }

    /**
     * Clear INTEN's IPCMDDONEEN bit.
     *
     * IP command done interrupt enable
     */
    inline void clear_INTEN_IPCMDDONEEN() volatile
    {
        INTEN &= ~(1u << 0u);
    }

    /**
     * Toggle INTEN's IPCMDDONEEN bit.
     *
     * IP command done interrupt enable
     */
    inline void toggle_INTEN_IPCMDDONEEN() volatile
    {
        INTEN ^= 1u << 0u;
    }

    /**
     * Get all of INTEN's bit fields.
     *
     * (read-write) Interrupt Enable Register
     */
    inline void get_INTEN(bool &NDNOPENDEN, bool &NDPAGEENDEN,
                          bool &AXIBUSERREN, bool &AXICMDERREN,
                          bool &IPCMDERREN, bool &IPCMDDONEEN) volatile
    {
        uint32_t curr = INTEN;

        NDNOPENDEN = curr & (1u << 5u);
        NDPAGEENDEN = curr & (1u << 4u);
        AXIBUSERREN = curr & (1u << 3u);
        AXICMDERREN = curr & (1u << 2u);
        IPCMDERREN = curr & (1u << 1u);
        IPCMDDONEEN = curr & (1u << 0u);
    }

    /**
     * Set all of INTEN's bit fields.
     *
     * (read-write) Interrupt Enable Register
     */
    inline void set_INTEN(bool NDNOPENDEN, bool NDPAGEENDEN, bool AXIBUSERREN,
                          bool AXICMDERREN, bool IPCMDERREN,
                          bool IPCMDDONEEN) volatile
    {
        uint32_t curr = INTEN;

        curr &= ~(0b1u << 5u);
        curr |= (NDNOPENDEN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (NDPAGEENDEN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (AXIBUSERREN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AXICMDERREN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IPCMDERREN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IPCMDDONEEN & 0b1u) << 0u;

        INTEN = curr;
    }

    /**
     * Get INTR's NDNOPEND bit.
     *
     * NAND no pending AXI write transaction interrupt
     */
    inline bool get_INTR_NDNOPEND() volatile
    {
        return INTR & (1u << 5u);
    }

    /**
     * Set INTR's NDNOPEND bit.
     *
     * NAND no pending AXI write transaction interrupt
     */
    inline void set_INTR_NDNOPEND() volatile
    {
        INTR |= 1u << 5u;
    }

    /**
     * Clear INTR's NDNOPEND bit.
     *
     * NAND no pending AXI write transaction interrupt
     */
    inline void clear_INTR_NDNOPEND() volatile
    {
        INTR &= ~(1u << 5u);
    }

    /**
     * Toggle INTR's NDNOPEND bit.
     *
     * NAND no pending AXI write transaction interrupt
     */
    inline void toggle_INTR_NDNOPEND() volatile
    {
        INTR ^= 1u << 5u;
    }

    /**
     * Get INTR's NDPAGEEND bit.
     *
     * NAND page end interrupt
     */
    inline bool get_INTR_NDPAGEEND() volatile
    {
        return INTR & (1u << 4u);
    }

    /**
     * Set INTR's NDPAGEEND bit.
     *
     * NAND page end interrupt
     */
    inline void set_INTR_NDPAGEEND() volatile
    {
        INTR |= 1u << 4u;
    }

    /**
     * Clear INTR's NDPAGEEND bit.
     *
     * NAND page end interrupt
     */
    inline void clear_INTR_NDPAGEEND() volatile
    {
        INTR &= ~(1u << 4u);
    }

    /**
     * Toggle INTR's NDPAGEEND bit.
     *
     * NAND page end interrupt
     */
    inline void toggle_INTR_NDPAGEEND() volatile
    {
        INTR ^= 1u << 4u;
    }

    /**
     * Get INTR's AXIBUSERR bit.
     *
     * AXI bus error interrupt
     */
    inline bool get_INTR_AXIBUSERR() volatile
    {
        return INTR & (1u << 3u);
    }

    /**
     * Set INTR's AXIBUSERR bit.
     *
     * AXI bus error interrupt
     */
    inline void set_INTR_AXIBUSERR() volatile
    {
        INTR |= 1u << 3u;
    }

    /**
     * Clear INTR's AXIBUSERR bit.
     *
     * AXI bus error interrupt
     */
    inline void clear_INTR_AXIBUSERR() volatile
    {
        INTR &= ~(1u << 3u);
    }

    /**
     * Toggle INTR's AXIBUSERR bit.
     *
     * AXI bus error interrupt
     */
    inline void toggle_INTR_AXIBUSERR() volatile
    {
        INTR ^= 1u << 3u;
    }

    /**
     * Get INTR's AXICMDERR bit.
     *
     * AXI command error interrupt
     */
    inline bool get_INTR_AXICMDERR() volatile
    {
        return INTR & (1u << 2u);
    }

    /**
     * Set INTR's AXICMDERR bit.
     *
     * AXI command error interrupt
     */
    inline void set_INTR_AXICMDERR() volatile
    {
        INTR |= 1u << 2u;
    }

    /**
     * Clear INTR's AXICMDERR bit.
     *
     * AXI command error interrupt
     */
    inline void clear_INTR_AXICMDERR() volatile
    {
        INTR &= ~(1u << 2u);
    }

    /**
     * Toggle INTR's AXICMDERR bit.
     *
     * AXI command error interrupt
     */
    inline void toggle_INTR_AXICMDERR() volatile
    {
        INTR ^= 1u << 2u;
    }

    /**
     * Get INTR's IPCMDERR bit.
     *
     * IP command error done interrupt
     */
    inline bool get_INTR_IPCMDERR() volatile
    {
        return INTR & (1u << 1u);
    }

    /**
     * Set INTR's IPCMDERR bit.
     *
     * IP command error done interrupt
     */
    inline void set_INTR_IPCMDERR() volatile
    {
        INTR |= 1u << 1u;
    }

    /**
     * Clear INTR's IPCMDERR bit.
     *
     * IP command error done interrupt
     */
    inline void clear_INTR_IPCMDERR() volatile
    {
        INTR &= ~(1u << 1u);
    }

    /**
     * Toggle INTR's IPCMDERR bit.
     *
     * IP command error done interrupt
     */
    inline void toggle_INTR_IPCMDERR() volatile
    {
        INTR ^= 1u << 1u;
    }

    /**
     * Get INTR's IPCMDDONE bit.
     *
     * IP command normal done interrupt
     */
    inline bool get_INTR_IPCMDDONE() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Set INTR's IPCMDDONE bit.
     *
     * IP command normal done interrupt
     */
    inline void set_INTR_IPCMDDONE() volatile
    {
        INTR |= 1u << 0u;
    }

    /**
     * Clear INTR's IPCMDDONE bit.
     *
     * IP command normal done interrupt
     */
    inline void clear_INTR_IPCMDDONE() volatile
    {
        INTR &= ~(1u << 0u);
    }

    /**
     * Toggle INTR's IPCMDDONE bit.
     *
     * IP command normal done interrupt
     */
    inline void toggle_INTR_IPCMDDONE() volatile
    {
        INTR ^= 1u << 0u;
    }

    /**
     * Get all of INTR's bit fields.
     *
     * (read-write) Interrupt Register
     */
    inline void get_INTR(bool &NDNOPEND, bool &NDPAGEEND, bool &AXIBUSERR,
                         bool &AXICMDERR, bool &IPCMDERR,
                         bool &IPCMDDONE) volatile
    {
        uint32_t curr = INTR;

        NDNOPEND = curr & (1u << 5u);
        NDPAGEEND = curr & (1u << 4u);
        AXIBUSERR = curr & (1u << 3u);
        AXICMDERR = curr & (1u << 2u);
        IPCMDERR = curr & (1u << 1u);
        IPCMDDONE = curr & (1u << 0u);
    }

    /**
     * Set all of INTR's bit fields.
     *
     * (read-write) Interrupt Register
     */
    inline void set_INTR(bool NDNOPEND, bool NDPAGEEND, bool AXIBUSERR,
                         bool AXICMDERR, bool IPCMDERR,
                         bool IPCMDDONE) volatile
    {
        uint32_t curr = INTR;

        curr &= ~(0b1u << 5u);
        curr |= (NDNOPEND & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (NDPAGEEND & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (AXIBUSERR & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AXICMDERR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IPCMDERR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IPCMDDONE & 0b1u) << 0u;

        INTR = curr;
    }

    /**
     * Get SDRAMCR0's BANK2 bit.
     *
     * 2 Bank selection bit
     */
    inline bool get_SDRAMCR0_BANK2() volatile
    {
        return SDRAMCR0 & (1u << 14u);
    }

    /**
     * Set SDRAMCR0's BANK2 bit.
     *
     * 2 Bank selection bit
     */
    inline void set_SDRAMCR0_BANK2() volatile
    {
        SDRAMCR0 |= 1u << 14u;
    }

    /**
     * Clear SDRAMCR0's BANK2 bit.
     *
     * 2 Bank selection bit
     */
    inline void clear_SDRAMCR0_BANK2() volatile
    {
        SDRAMCR0 &= ~(1u << 14u);
    }

    /**
     * Toggle SDRAMCR0's BANK2 bit.
     *
     * 2 Bank selection bit
     */
    inline void toggle_SDRAMCR0_BANK2() volatile
    {
        SDRAMCR0 ^= 1u << 14u;
    }

    /**
     * Get SDRAMCR0's CL field.
     *
     * CAS Latency
     */
    inline SEMC_SDRAMCR0_CL get_SDRAMCR0_CL() volatile
    {
        return SEMC_SDRAMCR0_CL((SDRAMCR0 >> 10u) & 0b11u);
    }

    /**
     * Set SDRAMCR0's CL field.
     *
     * CAS Latency
     */
    inline void set_SDRAMCR0_CL(SEMC_SDRAMCR0_CL value) volatile
    {
        uint32_t curr = SDRAMCR0;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        SDRAMCR0 = curr;
    }

    /**
     * Get SDRAMCR0's COL field.
     *
     * Column address bit number
     */
    inline SEMC_SDRAMCR0_COL get_SDRAMCR0_COL() volatile
    {
        return SEMC_SDRAMCR0_COL((SDRAMCR0 >> 8u) & 0b11u);
    }

    /**
     * Set SDRAMCR0's COL field.
     *
     * Column address bit number
     */
    inline void set_SDRAMCR0_COL(SEMC_SDRAMCR0_COL value) volatile
    {
        uint32_t curr = SDRAMCR0;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        SDRAMCR0 = curr;
    }

    /**
     * Get SDRAMCR0's COL8 bit.
     *
     * Column 8 selection
     */
    inline bool get_SDRAMCR0_COL8() volatile
    {
        return SDRAMCR0 & (1u << 7u);
    }

    /**
     * Set SDRAMCR0's COL8 bit.
     *
     * Column 8 selection
     */
    inline void set_SDRAMCR0_COL8() volatile
    {
        SDRAMCR0 |= 1u << 7u;
    }

    /**
     * Clear SDRAMCR0's COL8 bit.
     *
     * Column 8 selection
     */
    inline void clear_SDRAMCR0_COL8() volatile
    {
        SDRAMCR0 &= ~(1u << 7u);
    }

    /**
     * Toggle SDRAMCR0's COL8 bit.
     *
     * Column 8 selection
     */
    inline void toggle_SDRAMCR0_COL8() volatile
    {
        SDRAMCR0 ^= 1u << 7u;
    }

    /**
     * Get SDRAMCR0's BL field.
     *
     * Burst Length
     */
    inline SEMC_SDRAMCR0_BL get_SDRAMCR0_BL() volatile
    {
        return SEMC_SDRAMCR0_BL((SDRAMCR0 >> 4u) & 0b111u);
    }

    /**
     * Set SDRAMCR0's BL field.
     *
     * Burst Length
     */
    inline void set_SDRAMCR0_BL(SEMC_SDRAMCR0_BL value) volatile
    {
        uint32_t curr = SDRAMCR0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        SDRAMCR0 = curr;
    }

    /**
     * Get SDRAMCR0's PS field.
     *
     * Port Size
     */
    inline SEMC_SDRAMCR0_PS get_SDRAMCR0_PS() volatile
    {
        return SEMC_SDRAMCR0_PS((SDRAMCR0 >> 0u) & 0b11u);
    }

    /**
     * Set SDRAMCR0's PS field.
     *
     * Port Size
     */
    inline void set_SDRAMCR0_PS(SEMC_SDRAMCR0_PS value) volatile
    {
        uint32_t curr = SDRAMCR0;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SDRAMCR0 = curr;
    }

    /**
     * Get all of SDRAMCR0's bit fields.
     *
     * (read-write) SDRAM Control Register 0
     */
    inline void get_SDRAMCR0(bool &BANK2, SEMC_SDRAMCR0_CL &CL,
                             SEMC_SDRAMCR0_COL &COL, bool &COL8,
                             SEMC_SDRAMCR0_BL &BL,
                             SEMC_SDRAMCR0_PS &PS) volatile
    {
        uint32_t curr = SDRAMCR0;

        BANK2 = curr & (1u << 14u);
        CL = SEMC_SDRAMCR0_CL((curr >> 10u) & 0b11u);
        COL = SEMC_SDRAMCR0_COL((curr >> 8u) & 0b11u);
        COL8 = curr & (1u << 7u);
        BL = SEMC_SDRAMCR0_BL((curr >> 4u) & 0b111u);
        PS = SEMC_SDRAMCR0_PS((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of SDRAMCR0's bit fields.
     *
     * (read-write) SDRAM Control Register 0
     */
    inline void set_SDRAMCR0(bool BANK2, SEMC_SDRAMCR0_CL CL,
                             SEMC_SDRAMCR0_COL COL, bool COL8,
                             SEMC_SDRAMCR0_BL BL, SEMC_SDRAMCR0_PS PS) volatile
    {
        uint32_t curr = SDRAMCR0;

        curr &= ~(0b1u << 14u);
        curr |= (BANK2 & 0b1u) << 14u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(CL) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(COL) & 0b11u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (COL8 & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(BL) & 0b111u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(PS) & 0b11u) << 0u;

        SDRAMCR0 = curr;
    }

    /**
     * Get SDRAMCR1's ACT2PRE field.
     *
     * ACTIVE to PRECHARGE minimum time
     */
    inline uint8_t get_SDRAMCR1_ACT2PRE() volatile
    {
        return (SDRAMCR1 >> 20u) & 0b1111u;
    }

    /**
     * Set SDRAMCR1's ACT2PRE field.
     *
     * ACTIVE to PRECHARGE minimum time
     */
    inline void set_SDRAMCR1_ACT2PRE(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        SDRAMCR1 = curr;
    }

    /**
     * Get SDRAMCR1's CKEOFF field.
     *
     * CKE off minimum time
     */
    inline uint8_t get_SDRAMCR1_CKEOFF() volatile
    {
        return (SDRAMCR1 >> 16u) & 0b1111u;
    }

    /**
     * Set SDRAMCR1's CKEOFF field.
     *
     * CKE off minimum time
     */
    inline void set_SDRAMCR1_CKEOFF(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        SDRAMCR1 = curr;
    }

    /**
     * Get SDRAMCR1's WRC field.
     *
     * WRITE recovery time
     */
    inline uint8_t get_SDRAMCR1_WRC() volatile
    {
        return (SDRAMCR1 >> 13u) & 0b111u;
    }

    /**
     * Set SDRAMCR1's WRC field.
     *
     * WRITE recovery time
     */
    inline void set_SDRAMCR1_WRC(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b111u << 13u);
        curr |= (value & 0b111u) << 13u;

        SDRAMCR1 = curr;
    }

    /**
     * Get SDRAMCR1's RFRC field.
     *
     * REFRESH recovery time
     */
    inline uint8_t get_SDRAMCR1_RFRC() volatile
    {
        return (SDRAMCR1 >> 8u) & 0b11111u;
    }

    /**
     * Set SDRAMCR1's RFRC field.
     *
     * REFRESH recovery time
     */
    inline void set_SDRAMCR1_RFRC(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        SDRAMCR1 = curr;
    }

    /**
     * Get SDRAMCR1's ACT2RW field.
     *
     * ACTIVE to READ/WRITE delay
     */
    inline uint8_t get_SDRAMCR1_ACT2RW() volatile
    {
        return (SDRAMCR1 >> 4u) & 0b1111u;
    }

    /**
     * Set SDRAMCR1's ACT2RW field.
     *
     * ACTIVE to READ/WRITE delay
     */
    inline void set_SDRAMCR1_ACT2RW(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        SDRAMCR1 = curr;
    }

    /**
     * Get SDRAMCR1's PRE2ACT field.
     *
     * PRECHARGE to ACTIVE/REFRESH command wait time
     */
    inline uint8_t get_SDRAMCR1_PRE2ACT() volatile
    {
        return (SDRAMCR1 >> 0u) & 0b1111u;
    }

    /**
     * Set SDRAMCR1's PRE2ACT field.
     *
     * PRECHARGE to ACTIVE/REFRESH command wait time
     */
    inline void set_SDRAMCR1_PRE2ACT(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SDRAMCR1 = curr;
    }

    /**
     * Get all of SDRAMCR1's bit fields.
     *
     * (read-write) SDRAM Control Register 1
     */
    inline void get_SDRAMCR1(uint8_t &ACT2PRE, uint8_t &CKEOFF, uint8_t &WRC,
                             uint8_t &RFRC, uint8_t &ACT2RW,
                             uint8_t &PRE2ACT) volatile
    {
        uint32_t curr = SDRAMCR1;

        ACT2PRE = (curr >> 20u) & 0b1111u;
        CKEOFF = (curr >> 16u) & 0b1111u;
        WRC = (curr >> 13u) & 0b111u;
        RFRC = (curr >> 8u) & 0b11111u;
        ACT2RW = (curr >> 4u) & 0b1111u;
        PRE2ACT = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of SDRAMCR1's bit fields.
     *
     * (read-write) SDRAM Control Register 1
     */
    inline void set_SDRAMCR1(uint8_t ACT2PRE, uint8_t CKEOFF, uint8_t WRC,
                             uint8_t RFRC, uint8_t ACT2RW,
                             uint8_t PRE2ACT) volatile
    {
        uint32_t curr = SDRAMCR1;

        curr &= ~(0b1111u << 20u);
        curr |= (ACT2PRE & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (CKEOFF & 0b1111u) << 16u;
        curr &= ~(0b111u << 13u);
        curr |= (WRC & 0b111u) << 13u;
        curr &= ~(0b11111u << 8u);
        curr |= (RFRC & 0b11111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (ACT2RW & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (PRE2ACT & 0b1111u) << 0u;

        SDRAMCR1 = curr;
    }

    /**
     * Get SDRAMCR2's ITO field.
     *
     * SDRAM idle timeout
     */
    inline SEMC_SDRAMCR2_ITO get_SDRAMCR2_ITO() volatile
    {
        return SEMC_SDRAMCR2_ITO((SDRAMCR2 >> 24u) & 0b11111111u);
    }

    /**
     * Set SDRAMCR2's ITO field.
     *
     * SDRAM idle timeout
     */
    inline void set_SDRAMCR2_ITO(SEMC_SDRAMCR2_ITO value) volatile
    {
        uint32_t curr = SDRAMCR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        SDRAMCR2 = curr;
    }

    /**
     * Get SDRAMCR2's ACT2ACT field.
     *
     * ACTIVE to ACTIVE delay
     */
    inline uint8_t get_SDRAMCR2_ACT2ACT() volatile
    {
        return (SDRAMCR2 >> 16u) & 0b11111111u;
    }

    /**
     * Set SDRAMCR2's ACT2ACT field.
     *
     * ACTIVE to ACTIVE delay
     */
    inline void set_SDRAMCR2_ACT2ACT(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR2;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        SDRAMCR2 = curr;
    }

    /**
     * Get SDRAMCR2's REF2REF field.
     *
     * REFRESH to REFRESH delay
     */
    inline uint8_t get_SDRAMCR2_REF2REF() volatile
    {
        return (SDRAMCR2 >> 8u) & 0b11111111u;
    }

    /**
     * Set SDRAMCR2's REF2REF field.
     *
     * REFRESH to REFRESH delay
     */
    inline void set_SDRAMCR2_REF2REF(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR2;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SDRAMCR2 = curr;
    }

    /**
     * Get SDRAMCR2's SRRC field.
     *
     * SELF REFRESH recovery time
     */
    inline uint8_t get_SDRAMCR2_SRRC() volatile
    {
        return (SDRAMCR2 >> 0u) & 0b11111111u;
    }

    /**
     * Set SDRAMCR2's SRRC field.
     *
     * SELF REFRESH recovery time
     */
    inline void set_SDRAMCR2_SRRC(uint8_t value) volatile
    {
        uint32_t curr = SDRAMCR2;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SDRAMCR2 = curr;
    }

    /**
     * Get all of SDRAMCR2's bit fields.
     *
     * (read-write) SDRAM Control Register 2
     */
    inline void get_SDRAMCR2(SEMC_SDRAMCR2_ITO &ITO, uint8_t &ACT2ACT,
                             uint8_t &REF2REF, uint8_t &SRRC) volatile
    {
        uint32_t curr = SDRAMCR2;

        ITO = SEMC_SDRAMCR2_ITO((curr >> 24u) & 0b11111111u);
        ACT2ACT = (curr >> 16u) & 0b11111111u;
        REF2REF = (curr >> 8u) & 0b11111111u;
        SRRC = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of SDRAMCR2's bit fields.
     *
     * (read-write) SDRAM Control Register 2
     */
    inline void set_SDRAMCR2(SEMC_SDRAMCR2_ITO ITO, uint8_t ACT2ACT,
                             uint8_t REF2REF, uint8_t SRRC) volatile
    {
        uint32_t curr = SDRAMCR2;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(ITO) & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (ACT2ACT & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (REF2REF & 0b11111111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (SRRC & 0b11111111u) << 0u;

        SDRAMCR2 = curr;
    }

    /**
     * Get SDRAMCR3's UT field.
     *
     * Urgent refresh threshold
     */
    inline SEMC_SDRAMCR3_UT get_SDRAMCR3_UT() volatile
    {
        return SEMC_SDRAMCR3_UT((SDRAMCR3 >> 24u) & 0b11111111u);
    }

    /**
     * Set SDRAMCR3's UT field.
     *
     * Urgent refresh threshold
     */
    inline void set_SDRAMCR3_UT(SEMC_SDRAMCR3_UT value) volatile
    {
        uint32_t curr = SDRAMCR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        SDRAMCR3 = curr;
    }

    /**
     * Get SDRAMCR3's RT field.
     *
     * Refresh timer period
     */
    inline SEMC_SDRAMCR3_RT get_SDRAMCR3_RT() volatile
    {
        return SEMC_SDRAMCR3_RT((SDRAMCR3 >> 16u) & 0b11111111u);
    }

    /**
     * Set SDRAMCR3's RT field.
     *
     * Refresh timer period
     */
    inline void set_SDRAMCR3_RT(SEMC_SDRAMCR3_RT value) volatile
    {
        uint32_t curr = SDRAMCR3;

        curr &= ~(0b11111111u << 16u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 16u;

        SDRAMCR3 = curr;
    }

    /**
     * Get SDRAMCR3's PRESCALE field.
     *
     * Prescaler period
     */
    inline SEMC_SDRAMCR3_PRESCALE get_SDRAMCR3_PRESCALE() volatile
    {
        return SEMC_SDRAMCR3_PRESCALE((SDRAMCR3 >> 8u) & 0b11111111u);
    }

    /**
     * Set SDRAMCR3's PRESCALE field.
     *
     * Prescaler period
     */
    inline void set_SDRAMCR3_PRESCALE(SEMC_SDRAMCR3_PRESCALE value) volatile
    {
        uint32_t curr = SDRAMCR3;

        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 8u;

        SDRAMCR3 = curr;
    }

    /**
     * Get SDRAMCR3's REBL field.
     *
     * Refresh burst length
     */
    inline SEMC_SDRAMCR3_REBL get_SDRAMCR3_REBL() volatile
    {
        return SEMC_SDRAMCR3_REBL((SDRAMCR3 >> 1u) & 0b111u);
    }

    /**
     * Set SDRAMCR3's REBL field.
     *
     * Refresh burst length
     */
    inline void set_SDRAMCR3_REBL(SEMC_SDRAMCR3_REBL value) volatile
    {
        uint32_t curr = SDRAMCR3;

        curr &= ~(0b111u << 1u);
        curr |= (std::to_underlying(value) & 0b111u) << 1u;

        SDRAMCR3 = curr;
    }

    /**
     * Get SDRAMCR3's REN bit.
     *
     * Refresh enable
     */
    inline bool get_SDRAMCR3_REN() volatile
    {
        return SDRAMCR3 & (1u << 0u);
    }

    /**
     * Set SDRAMCR3's REN bit.
     *
     * Refresh enable
     */
    inline void set_SDRAMCR3_REN() volatile
    {
        SDRAMCR3 |= 1u << 0u;
    }

    /**
     * Clear SDRAMCR3's REN bit.
     *
     * Refresh enable
     */
    inline void clear_SDRAMCR3_REN() volatile
    {
        SDRAMCR3 &= ~(1u << 0u);
    }

    /**
     * Toggle SDRAMCR3's REN bit.
     *
     * Refresh enable
     */
    inline void toggle_SDRAMCR3_REN() volatile
    {
        SDRAMCR3 ^= 1u << 0u;
    }

    /**
     * Get all of SDRAMCR3's bit fields.
     *
     * (read-write) SDRAM Control Register 3
     */
    inline void get_SDRAMCR3(SEMC_SDRAMCR3_UT &UT, SEMC_SDRAMCR3_RT &RT,
                             SEMC_SDRAMCR3_PRESCALE &PRESCALE,
                             SEMC_SDRAMCR3_REBL &REBL, bool &REN) volatile
    {
        uint32_t curr = SDRAMCR3;

        UT = SEMC_SDRAMCR3_UT((curr >> 24u) & 0b11111111u);
        RT = SEMC_SDRAMCR3_RT((curr >> 16u) & 0b11111111u);
        PRESCALE = SEMC_SDRAMCR3_PRESCALE((curr >> 8u) & 0b11111111u);
        REBL = SEMC_SDRAMCR3_REBL((curr >> 1u) & 0b111u);
        REN = curr & (1u << 0u);
    }

    /**
     * Set all of SDRAMCR3's bit fields.
     *
     * (read-write) SDRAM Control Register 3
     */
    inline void set_SDRAMCR3(SEMC_SDRAMCR3_UT UT, SEMC_SDRAMCR3_RT RT,
                             SEMC_SDRAMCR3_PRESCALE PRESCALE,
                             SEMC_SDRAMCR3_REBL REBL, bool REN) volatile
    {
        uint32_t curr = SDRAMCR3;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(UT) & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (std::to_underlying(RT) & 0b11111111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (std::to_underlying(PRESCALE) & 0b11111111u) << 8u;
        curr &= ~(0b111u << 1u);
        curr |= (std::to_underlying(REBL) & 0b111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (REN & 0b1u) << 0u;

        SDRAMCR3 = curr;
    }

    /**
     * Get NANDCR0's COL field.
     *
     * Column address bit number
     */
    inline SEMC_NANDCR0_COL get_NANDCR0_COL() volatile
    {
        return SEMC_NANDCR0_COL((NANDCR0 >> 8u) & 0b111u);
    }

    /**
     * Set NANDCR0's COL field.
     *
     * Column address bit number
     */
    inline void set_NANDCR0_COL(SEMC_NANDCR0_COL value) volatile
    {
        uint32_t curr = NANDCR0;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(value) & 0b111u) << 8u;

        NANDCR0 = curr;
    }

    /**
     * Get NANDCR0's EDO bit.
     *
     * EDO mode enabled
     */
    inline bool get_NANDCR0_EDO() volatile
    {
        return NANDCR0 & (1u << 7u);
    }

    /**
     * Set NANDCR0's EDO bit.
     *
     * EDO mode enabled
     */
    inline void set_NANDCR0_EDO() volatile
    {
        NANDCR0 |= 1u << 7u;
    }

    /**
     * Clear NANDCR0's EDO bit.
     *
     * EDO mode enabled
     */
    inline void clear_NANDCR0_EDO() volatile
    {
        NANDCR0 &= ~(1u << 7u);
    }

    /**
     * Toggle NANDCR0's EDO bit.
     *
     * EDO mode enabled
     */
    inline void toggle_NANDCR0_EDO() volatile
    {
        NANDCR0 ^= 1u << 7u;
    }

    /**
     * Get NANDCR0's BL field.
     *
     * Burst Length
     */
    inline SEMC_NANDCR0_BL get_NANDCR0_BL() volatile
    {
        return SEMC_NANDCR0_BL((NANDCR0 >> 4u) & 0b111u);
    }

    /**
     * Set NANDCR0's BL field.
     *
     * Burst Length
     */
    inline void set_NANDCR0_BL(SEMC_NANDCR0_BL value) volatile
    {
        uint32_t curr = NANDCR0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        NANDCR0 = curr;
    }

    /**
     * Get NANDCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline bool get_NANDCR0_SYNCEN() volatile
    {
        return NANDCR0 & (1u << 1u);
    }

    /**
     * Set NANDCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void set_NANDCR0_SYNCEN() volatile
    {
        NANDCR0 |= 1u << 1u;
    }

    /**
     * Clear NANDCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void clear_NANDCR0_SYNCEN() volatile
    {
        NANDCR0 &= ~(1u << 1u);
    }

    /**
     * Toggle NANDCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void toggle_NANDCR0_SYNCEN() volatile
    {
        NANDCR0 ^= 1u << 1u;
    }

    /**
     * Get NANDCR0's PS bit.
     *
     * Port Size
     */
    inline bool get_NANDCR0_PS() volatile
    {
        return NANDCR0 & (1u << 0u);
    }

    /**
     * Set NANDCR0's PS bit.
     *
     * Port Size
     */
    inline void set_NANDCR0_PS() volatile
    {
        NANDCR0 |= 1u << 0u;
    }

    /**
     * Clear NANDCR0's PS bit.
     *
     * Port Size
     */
    inline void clear_NANDCR0_PS() volatile
    {
        NANDCR0 &= ~(1u << 0u);
    }

    /**
     * Toggle NANDCR0's PS bit.
     *
     * Port Size
     */
    inline void toggle_NANDCR0_PS() volatile
    {
        NANDCR0 ^= 1u << 0u;
    }

    /**
     * Get all of NANDCR0's bit fields.
     *
     * (read-write) NAND Control Register 0
     */
    inline void get_NANDCR0(SEMC_NANDCR0_COL &COL, bool &EDO,
                            SEMC_NANDCR0_BL &BL, bool &SYNCEN,
                            bool &PS) volatile
    {
        uint32_t curr = NANDCR0;

        COL = SEMC_NANDCR0_COL((curr >> 8u) & 0b111u);
        EDO = curr & (1u << 7u);
        BL = SEMC_NANDCR0_BL((curr >> 4u) & 0b111u);
        SYNCEN = curr & (1u << 1u);
        PS = curr & (1u << 0u);
    }

    /**
     * Set all of NANDCR0's bit fields.
     *
     * (read-write) NAND Control Register 0
     */
    inline void set_NANDCR0(SEMC_NANDCR0_COL COL, bool EDO, SEMC_NANDCR0_BL BL,
                            bool SYNCEN, bool PS) volatile
    {
        uint32_t curr = NANDCR0;

        curr &= ~(0b111u << 8u);
        curr |= (std::to_underlying(COL) & 0b111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (EDO & 0b1u) << 7u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(BL) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (SYNCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PS & 0b1u) << 0u;

        NANDCR0 = curr;
    }

    /**
     * Get NANDCR1's CEITV field.
     *
     * CE# interval time
     */
    inline uint8_t get_NANDCR1_CEITV() volatile
    {
        return (NANDCR1 >> 28u) & 0b1111u;
    }

    /**
     * Set NANDCR1's CEITV field.
     *
     * CE# interval time
     */
    inline void set_NANDCR1_CEITV(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's TA field.
     *
     * Turnaround time
     */
    inline uint8_t get_NANDCR1_TA() volatile
    {
        return (NANDCR1 >> 24u) & 0b1111u;
    }

    /**
     * Set NANDCR1's TA field.
     *
     * Turnaround time
     */
    inline void set_NANDCR1_TA(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's REH field.
     *
     * RE# high time
     */
    inline uint8_t get_NANDCR1_REH() volatile
    {
        return (NANDCR1 >> 20u) & 0b1111u;
    }

    /**
     * Set NANDCR1's REH field.
     *
     * RE# high time
     */
    inline void set_NANDCR1_REH(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's REL field.
     *
     * RE# low time
     */
    inline uint8_t get_NANDCR1_REL() volatile
    {
        return (NANDCR1 >> 16u) & 0b1111u;
    }

    /**
     * Set NANDCR1's REL field.
     *
     * RE# low time
     */
    inline void set_NANDCR1_REL(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's WEH field.
     *
     * WE# high time
     */
    inline uint8_t get_NANDCR1_WEH() volatile
    {
        return (NANDCR1 >> 12u) & 0b1111u;
    }

    /**
     * Set NANDCR1's WEH field.
     *
     * WE# high time
     */
    inline void set_NANDCR1_WEH(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's WEL field.
     *
     * WE# low time
     */
    inline uint8_t get_NANDCR1_WEL() volatile
    {
        return (NANDCR1 >> 8u) & 0b1111u;
    }

    /**
     * Set NANDCR1's WEL field.
     *
     * WE# low time
     */
    inline void set_NANDCR1_WEL(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's CEH field.
     *
     * CE# hold time
     */
    inline uint8_t get_NANDCR1_CEH() volatile
    {
        return (NANDCR1 >> 4u) & 0b1111u;
    }

    /**
     * Set NANDCR1's CEH field.
     *
     * CE# hold time
     */
    inline void set_NANDCR1_CEH(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR1's CES field.
     *
     * CE# setup time
     */
    inline uint8_t get_NANDCR1_CES() volatile
    {
        return (NANDCR1 >> 0u) & 0b1111u;
    }

    /**
     * Set NANDCR1's CES field.
     *
     * CE# setup time
     */
    inline void set_NANDCR1_CES(uint8_t value) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        NANDCR1 = curr;
    }

    /**
     * Get all of NANDCR1's bit fields.
     *
     * (read-write) NAND Control Register 1
     */
    inline void get_NANDCR1(uint8_t &CEITV, uint8_t &TA, uint8_t &REH,
                            uint8_t &REL, uint8_t &WEH, uint8_t &WEL,
                            uint8_t &CEH, uint8_t &CES) volatile
    {
        uint32_t curr = NANDCR1;

        CEITV = (curr >> 28u) & 0b1111u;
        TA = (curr >> 24u) & 0b1111u;
        REH = (curr >> 20u) & 0b1111u;
        REL = (curr >> 16u) & 0b1111u;
        WEH = (curr >> 12u) & 0b1111u;
        WEL = (curr >> 8u) & 0b1111u;
        CEH = (curr >> 4u) & 0b1111u;
        CES = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of NANDCR1's bit fields.
     *
     * (read-write) NAND Control Register 1
     */
    inline void set_NANDCR1(uint8_t CEITV, uint8_t TA, uint8_t REH,
                            uint8_t REL, uint8_t WEH, uint8_t WEL, uint8_t CEH,
                            uint8_t CES) volatile
    {
        uint32_t curr = NANDCR1;

        curr &= ~(0b1111u << 28u);
        curr |= (CEITV & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (TA & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (REH & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (REL & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (WEH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WEL & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (CEH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (CES & 0b1111u) << 0u;

        NANDCR1 = curr;
    }

    /**
     * Get NANDCR2's TWB field.
     *
     * WE# high to busy time
     */
    inline uint8_t get_NANDCR2_TWB() volatile
    {
        return (NANDCR2 >> 24u) & 0b111111u;
    }

    /**
     * Set NANDCR2's TWB field.
     *
     * WE# high to busy time
     */
    inline void set_NANDCR2_TWB(uint8_t value) volatile
    {
        uint32_t curr = NANDCR2;

        curr &= ~(0b111111u << 24u);
        curr |= (value & 0b111111u) << 24u;

        NANDCR2 = curr;
    }

    /**
     * Get NANDCR2's TRR field.
     *
     * Ready to RE# low time
     */
    inline uint8_t get_NANDCR2_TRR() volatile
    {
        return (NANDCR2 >> 18u) & 0b111111u;
    }

    /**
     * Set NANDCR2's TRR field.
     *
     * Ready to RE# low time
     */
    inline void set_NANDCR2_TRR(uint8_t value) volatile
    {
        uint32_t curr = NANDCR2;

        curr &= ~(0b111111u << 18u);
        curr |= (value & 0b111111u) << 18u;

        NANDCR2 = curr;
    }

    /**
     * Get NANDCR2's TADL field.
     *
     * Address cycle to data loading time
     */
    inline uint8_t get_NANDCR2_TADL() volatile
    {
        return (NANDCR2 >> 12u) & 0b111111u;
    }

    /**
     * Set NANDCR2's TADL field.
     *
     * Address cycle to data loading time
     */
    inline void set_NANDCR2_TADL(uint8_t value) volatile
    {
        uint32_t curr = NANDCR2;

        curr &= ~(0b111111u << 12u);
        curr |= (value & 0b111111u) << 12u;

        NANDCR2 = curr;
    }

    /**
     * Get NANDCR2's TRHW field.
     *
     * RE# high to WE# low time
     */
    inline uint8_t get_NANDCR2_TRHW() volatile
    {
        return (NANDCR2 >> 6u) & 0b111111u;
    }

    /**
     * Set NANDCR2's TRHW field.
     *
     * RE# high to WE# low time
     */
    inline void set_NANDCR2_TRHW(uint8_t value) volatile
    {
        uint32_t curr = NANDCR2;

        curr &= ~(0b111111u << 6u);
        curr |= (value & 0b111111u) << 6u;

        NANDCR2 = curr;
    }

    /**
     * Get NANDCR2's TWHR field.
     *
     * WE# high to RE# low time
     */
    inline uint8_t get_NANDCR2_TWHR() volatile
    {
        return (NANDCR2 >> 0u) & 0b111111u;
    }

    /**
     * Set NANDCR2's TWHR field.
     *
     * WE# high to RE# low time
     */
    inline void set_NANDCR2_TWHR(uint8_t value) volatile
    {
        uint32_t curr = NANDCR2;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        NANDCR2 = curr;
    }

    /**
     * Get all of NANDCR2's bit fields.
     *
     * (read-write) NAND Control Register 2
     */
    inline void get_NANDCR2(uint8_t &TWB, uint8_t &TRR, uint8_t &TADL,
                            uint8_t &TRHW, uint8_t &TWHR) volatile
    {
        uint32_t curr = NANDCR2;

        TWB = (curr >> 24u) & 0b111111u;
        TRR = (curr >> 18u) & 0b111111u;
        TADL = (curr >> 12u) & 0b111111u;
        TRHW = (curr >> 6u) & 0b111111u;
        TWHR = (curr >> 0u) & 0b111111u;
    }

    /**
     * Set all of NANDCR2's bit fields.
     *
     * (read-write) NAND Control Register 2
     */
    inline void set_NANDCR2(uint8_t TWB, uint8_t TRR, uint8_t TADL,
                            uint8_t TRHW, uint8_t TWHR) volatile
    {
        uint32_t curr = NANDCR2;

        curr &= ~(0b111111u << 24u);
        curr |= (TWB & 0b111111u) << 24u;
        curr &= ~(0b111111u << 18u);
        curr |= (TRR & 0b111111u) << 18u;
        curr &= ~(0b111111u << 12u);
        curr |= (TADL & 0b111111u) << 12u;
        curr &= ~(0b111111u << 6u);
        curr |= (TRHW & 0b111111u) << 6u;
        curr &= ~(0b111111u << 0u);
        curr |= (TWHR & 0b111111u) << 0u;

        NANDCR2 = curr;
    }

    /**
     * Get NANDCR3's WDH field.
     *
     * Write Data Hold time
     */
    inline uint8_t get_NANDCR3_WDH() volatile
    {
        return (NANDCR3 >> 28u) & 0b1111u;
    }

    /**
     * Set NANDCR3's WDH field.
     *
     * Write Data Hold time
     */
    inline void set_NANDCR3_WDH(uint8_t value) volatile
    {
        uint32_t curr = NANDCR3;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        NANDCR3 = curr;
    }

    /**
     * Get NANDCR3's WDS field.
     *
     * Write Data Setup time
     */
    inline uint8_t get_NANDCR3_WDS() volatile
    {
        return (NANDCR3 >> 24u) & 0b1111u;
    }

    /**
     * Set NANDCR3's WDS field.
     *
     * Write Data Setup time
     */
    inline void set_NANDCR3_WDS(uint8_t value) volatile
    {
        uint32_t curr = NANDCR3;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        NANDCR3 = curr;
    }

    /**
     * Get NANDCR3's RDH field.
     *
     * Read Data Hold time
     */
    inline uint8_t get_NANDCR3_RDH() volatile
    {
        return (NANDCR3 >> 20u) & 0b1111u;
    }

    /**
     * Set NANDCR3's RDH field.
     *
     * Read Data Hold time
     */
    inline void set_NANDCR3_RDH(uint8_t value) volatile
    {
        uint32_t curr = NANDCR3;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        NANDCR3 = curr;
    }

    /**
     * Get NANDCR3's RDS field.
     *
     * Read Data Setup time
     */
    inline uint8_t get_NANDCR3_RDS() volatile
    {
        return (NANDCR3 >> 16u) & 0b1111u;
    }

    /**
     * Set NANDCR3's RDS field.
     *
     * Read Data Setup time
     */
    inline void set_NANDCR3_RDS(uint8_t value) volatile
    {
        uint32_t curr = NANDCR3;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        NANDCR3 = curr;
    }

    /**
     * Get NANDCR3's CLE bit.
     *
     * NAND CLE Option
     */
    inline bool get_NANDCR3_CLE() volatile
    {
        return NANDCR3 & (1u << 3u);
    }

    /**
     * Set NANDCR3's CLE bit.
     *
     * NAND CLE Option
     */
    inline void set_NANDCR3_CLE() volatile
    {
        NANDCR3 |= 1u << 3u;
    }

    /**
     * Clear NANDCR3's CLE bit.
     *
     * NAND CLE Option
     */
    inline void clear_NANDCR3_CLE() volatile
    {
        NANDCR3 &= ~(1u << 3u);
    }

    /**
     * Toggle NANDCR3's CLE bit.
     *
     * NAND CLE Option
     */
    inline void toggle_NANDCR3_CLE() volatile
    {
        NANDCR3 ^= 1u << 3u;
    }

    /**
     * Get NANDCR3's NDOPT3 bit.
     *
     * NAND option bit 3
     */
    inline bool get_NANDCR3_NDOPT3() volatile
    {
        return NANDCR3 & (1u << 2u);
    }

    /**
     * Set NANDCR3's NDOPT3 bit.
     *
     * NAND option bit 3
     */
    inline void set_NANDCR3_NDOPT3() volatile
    {
        NANDCR3 |= 1u << 2u;
    }

    /**
     * Clear NANDCR3's NDOPT3 bit.
     *
     * NAND option bit 3
     */
    inline void clear_NANDCR3_NDOPT3() volatile
    {
        NANDCR3 &= ~(1u << 2u);
    }

    /**
     * Toggle NANDCR3's NDOPT3 bit.
     *
     * NAND option bit 3
     */
    inline void toggle_NANDCR3_NDOPT3() volatile
    {
        NANDCR3 ^= 1u << 2u;
    }

    /**
     * Get NANDCR3's NDOPT2 bit.
     *
     * NAND option bit 2
     */
    inline bool get_NANDCR3_NDOPT2() volatile
    {
        return NANDCR3 & (1u << 1u);
    }

    /**
     * Set NANDCR3's NDOPT2 bit.
     *
     * NAND option bit 2
     */
    inline void set_NANDCR3_NDOPT2() volatile
    {
        NANDCR3 |= 1u << 1u;
    }

    /**
     * Clear NANDCR3's NDOPT2 bit.
     *
     * NAND option bit 2
     */
    inline void clear_NANDCR3_NDOPT2() volatile
    {
        NANDCR3 &= ~(1u << 1u);
    }

    /**
     * Toggle NANDCR3's NDOPT2 bit.
     *
     * NAND option bit 2
     */
    inline void toggle_NANDCR3_NDOPT2() volatile
    {
        NANDCR3 ^= 1u << 1u;
    }

    /**
     * Get NANDCR3's NDOPT1 bit.
     *
     * NAND option bit 1
     */
    inline bool get_NANDCR3_NDOPT1() volatile
    {
        return NANDCR3 & (1u << 0u);
    }

    /**
     * Set NANDCR3's NDOPT1 bit.
     *
     * NAND option bit 1
     */
    inline void set_NANDCR3_NDOPT1() volatile
    {
        NANDCR3 |= 1u << 0u;
    }

    /**
     * Clear NANDCR3's NDOPT1 bit.
     *
     * NAND option bit 1
     */
    inline void clear_NANDCR3_NDOPT1() volatile
    {
        NANDCR3 &= ~(1u << 0u);
    }

    /**
     * Toggle NANDCR3's NDOPT1 bit.
     *
     * NAND option bit 1
     */
    inline void toggle_NANDCR3_NDOPT1() volatile
    {
        NANDCR3 ^= 1u << 0u;
    }

    /**
     * Get all of NANDCR3's bit fields.
     *
     * (read-write) NAND Control Register 3
     */
    inline void get_NANDCR3(uint8_t &WDH, uint8_t &WDS, uint8_t &RDH,
                            uint8_t &RDS, bool &CLE, bool &NDOPT3,
                            bool &NDOPT2, bool &NDOPT1) volatile
    {
        uint32_t curr = NANDCR3;

        WDH = (curr >> 28u) & 0b1111u;
        WDS = (curr >> 24u) & 0b1111u;
        RDH = (curr >> 20u) & 0b1111u;
        RDS = (curr >> 16u) & 0b1111u;
        CLE = curr & (1u << 3u);
        NDOPT3 = curr & (1u << 2u);
        NDOPT2 = curr & (1u << 1u);
        NDOPT1 = curr & (1u << 0u);
    }

    /**
     * Set all of NANDCR3's bit fields.
     *
     * (read-write) NAND Control Register 3
     */
    inline void set_NANDCR3(uint8_t WDH, uint8_t WDS, uint8_t RDH, uint8_t RDS,
                            bool CLE, bool NDOPT3, bool NDOPT2,
                            bool NDOPT1) volatile
    {
        uint32_t curr = NANDCR3;

        curr &= ~(0b1111u << 28u);
        curr |= (WDH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (WDS & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (RDH & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (RDS & 0b1111u) << 16u;
        curr &= ~(0b1u << 3u);
        curr |= (CLE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (NDOPT3 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (NDOPT2 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (NDOPT1 & 0b1u) << 0u;

        NANDCR3 = curr;
    }

    /**
     * Get NORCR0's COL field.
     *
     * Column Address bit width
     */
    inline SEMC_NORCR0_COL get_NORCR0_COL() volatile
    {
        return SEMC_NORCR0_COL((NORCR0 >> 12u) & 0b1111u);
    }

    /**
     * Set NORCR0's COL field.
     *
     * Column Address bit width
     */
    inline void set_NORCR0_COL(SEMC_NORCR0_COL value) volatile
    {
        uint32_t curr = NORCR0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        NORCR0 = curr;
    }

    /**
     * Get NORCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline bool get_NORCR0_ADVH() volatile
    {
        return NORCR0 & (1u << 11u);
    }

    /**
     * Set NORCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void set_NORCR0_ADVH() volatile
    {
        NORCR0 |= 1u << 11u;
    }

    /**
     * Clear NORCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void clear_NORCR0_ADVH() volatile
    {
        NORCR0 &= ~(1u << 11u);
    }

    /**
     * Toggle NORCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void toggle_NORCR0_ADVH() volatile
    {
        NORCR0 ^= 1u << 11u;
    }

    /**
     * Get NORCR0's ADVP bit.
     *
     * ADV# Polarity
     */
    inline bool get_NORCR0_ADVP() volatile
    {
        return NORCR0 & (1u << 10u);
    }

    /**
     * Set NORCR0's ADVP bit.
     *
     * ADV# Polarity
     */
    inline void set_NORCR0_ADVP() volatile
    {
        NORCR0 |= 1u << 10u;
    }

    /**
     * Clear NORCR0's ADVP bit.
     *
     * ADV# Polarity
     */
    inline void clear_NORCR0_ADVP() volatile
    {
        NORCR0 &= ~(1u << 10u);
    }

    /**
     * Toggle NORCR0's ADVP bit.
     *
     * ADV# Polarity
     */
    inline void toggle_NORCR0_ADVP() volatile
    {
        NORCR0 ^= 1u << 10u;
    }

    /**
     * Get NORCR0's AM field.
     *
     * Address Mode
     */
    inline SEMC_NORCR0_AM get_NORCR0_AM() volatile
    {
        return SEMC_NORCR0_AM((NORCR0 >> 8u) & 0b11u);
    }

    /**
     * Set NORCR0's AM field.
     *
     * Address Mode
     */
    inline void set_NORCR0_AM(SEMC_NORCR0_AM value) volatile
    {
        uint32_t curr = NORCR0;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        NORCR0 = curr;
    }

    /**
     * Get NORCR0's BL field.
     *
     * Burst Length
     */
    inline SEMC_NORCR0_BL get_NORCR0_BL() volatile
    {
        return SEMC_NORCR0_BL((NORCR0 >> 4u) & 0b111u);
    }

    /**
     * Set NORCR0's BL field.
     *
     * Burst Length
     */
    inline void set_NORCR0_BL(SEMC_NORCR0_BL value) volatile
    {
        uint32_t curr = NORCR0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        NORCR0 = curr;
    }

    /**
     * Get NORCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline bool get_NORCR0_SYNCEN() volatile
    {
        return NORCR0 & (1u << 1u);
    }

    /**
     * Set NORCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void set_NORCR0_SYNCEN() volatile
    {
        NORCR0 |= 1u << 1u;
    }

    /**
     * Clear NORCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void clear_NORCR0_SYNCEN() volatile
    {
        NORCR0 &= ~(1u << 1u);
    }

    /**
     * Toggle NORCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void toggle_NORCR0_SYNCEN() volatile
    {
        NORCR0 ^= 1u << 1u;
    }

    /**
     * Get NORCR0's PS bit.
     *
     * Port Size
     */
    inline bool get_NORCR0_PS() volatile
    {
        return NORCR0 & (1u << 0u);
    }

    /**
     * Set NORCR0's PS bit.
     *
     * Port Size
     */
    inline void set_NORCR0_PS() volatile
    {
        NORCR0 |= 1u << 0u;
    }

    /**
     * Clear NORCR0's PS bit.
     *
     * Port Size
     */
    inline void clear_NORCR0_PS() volatile
    {
        NORCR0 &= ~(1u << 0u);
    }

    /**
     * Toggle NORCR0's PS bit.
     *
     * Port Size
     */
    inline void toggle_NORCR0_PS() volatile
    {
        NORCR0 ^= 1u << 0u;
    }

    /**
     * Get all of NORCR0's bit fields.
     *
     * (read-write) NOR Control Register 0
     */
    inline void get_NORCR0(SEMC_NORCR0_COL &COL, bool &ADVH, bool &ADVP,
                           SEMC_NORCR0_AM &AM, SEMC_NORCR0_BL &BL,
                           bool &SYNCEN, bool &PS) volatile
    {
        uint32_t curr = NORCR0;

        COL = SEMC_NORCR0_COL((curr >> 12u) & 0b1111u);
        ADVH = curr & (1u << 11u);
        ADVP = curr & (1u << 10u);
        AM = SEMC_NORCR0_AM((curr >> 8u) & 0b11u);
        BL = SEMC_NORCR0_BL((curr >> 4u) & 0b111u);
        SYNCEN = curr & (1u << 1u);
        PS = curr & (1u << 0u);
    }

    /**
     * Set all of NORCR0's bit fields.
     *
     * (read-write) NOR Control Register 0
     */
    inline void set_NORCR0(SEMC_NORCR0_COL COL, bool ADVH, bool ADVP,
                           SEMC_NORCR0_AM AM, SEMC_NORCR0_BL BL, bool SYNCEN,
                           bool PS) volatile
    {
        uint32_t curr = NORCR0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(COL) & 0b1111u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ADVH & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ADVP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(AM) & 0b11u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(BL) & 0b111u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (SYNCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PS & 0b1u) << 0u;

        NORCR0 = curr;
    }

    /**
     * Get NORCR1's REH field.
     *
     * RE high time
     */
    inline uint8_t get_NORCR1_REH() volatile
    {
        return (NORCR1 >> 28u) & 0b1111u;
    }

    /**
     * Set NORCR1's REH field.
     *
     * RE high time
     */
    inline void set_NORCR1_REH(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's REL field.
     *
     * RE low time
     */
    inline uint8_t get_NORCR1_REL() volatile
    {
        return (NORCR1 >> 24u) & 0b1111u;
    }

    /**
     * Set NORCR1's REL field.
     *
     * RE low time
     */
    inline void set_NORCR1_REL(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's WEH field.
     *
     * WE high time
     */
    inline uint8_t get_NORCR1_WEH() volatile
    {
        return (NORCR1 >> 20u) & 0b1111u;
    }

    /**
     * Set NORCR1's WEH field.
     *
     * WE high time
     */
    inline void set_NORCR1_WEH(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's WEL field.
     *
     * WE low time
     */
    inline uint8_t get_NORCR1_WEL() volatile
    {
        return (NORCR1 >> 16u) & 0b1111u;
    }

    /**
     * Set NORCR1's WEL field.
     *
     * WE low time
     */
    inline void set_NORCR1_WEL(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's AH field.
     *
     * Address hold time
     */
    inline uint8_t get_NORCR1_AH() volatile
    {
        return (NORCR1 >> 12u) & 0b1111u;
    }

    /**
     * Set NORCR1's AH field.
     *
     * Address hold time
     */
    inline void set_NORCR1_AH(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's AS field.
     *
     * Address setup time
     */
    inline uint8_t get_NORCR1_AS() volatile
    {
        return (NORCR1 >> 8u) & 0b1111u;
    }

    /**
     * Set NORCR1's AS field.
     *
     * Address setup time
     */
    inline void set_NORCR1_AS(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's CEH field.
     *
     * CE hold time
     */
    inline uint8_t get_NORCR1_CEH() volatile
    {
        return (NORCR1 >> 4u) & 0b1111u;
    }

    /**
     * Set NORCR1's CEH field.
     *
     * CE hold time
     */
    inline void set_NORCR1_CEH(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR1's CES field.
     *
     * CE setup time
     */
    inline uint8_t get_NORCR1_CES() volatile
    {
        return (NORCR1 >> 0u) & 0b1111u;
    }

    /**
     * Set NORCR1's CES field.
     *
     * CE setup time
     */
    inline void set_NORCR1_CES(uint8_t value) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        NORCR1 = curr;
    }

    /**
     * Get all of NORCR1's bit fields.
     *
     * (read-write) NOR Control Register 1
     */
    inline void get_NORCR1(uint8_t &REH, uint8_t &REL, uint8_t &WEH,
                           uint8_t &WEL, uint8_t &AH, uint8_t &AS,
                           uint8_t &CEH, uint8_t &CES) volatile
    {
        uint32_t curr = NORCR1;

        REH = (curr >> 28u) & 0b1111u;
        REL = (curr >> 24u) & 0b1111u;
        WEH = (curr >> 20u) & 0b1111u;
        WEL = (curr >> 16u) & 0b1111u;
        AH = (curr >> 12u) & 0b1111u;
        AS = (curr >> 8u) & 0b1111u;
        CEH = (curr >> 4u) & 0b1111u;
        CES = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of NORCR1's bit fields.
     *
     * (read-write) NOR Control Register 1
     */
    inline void set_NORCR1(uint8_t REH, uint8_t REL, uint8_t WEH, uint8_t WEL,
                           uint8_t AH, uint8_t AS, uint8_t CEH,
                           uint8_t CES) volatile
    {
        uint32_t curr = NORCR1;

        curr &= ~(0b1111u << 28u);
        curr |= (REH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (REL & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (WEH & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (WEL & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (AH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (AS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (CEH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (CES & 0b1111u) << 0u;

        NORCR1 = curr;
    }

    /**
     * Get NORCR2's RDH field.
     *
     * Read hold time
     */
    inline uint8_t get_NORCR2_RDH() volatile
    {
        return (NORCR2 >> 28u) & 0b1111u;
    }

    /**
     * Set NORCR2's RDH field.
     *
     * Read hold time
     */
    inline void set_NORCR2_RDH(uint8_t value) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        NORCR2 = curr;
    }

    /**
     * Get NORCR2's CEITV field.
     *
     * CE# interval time
     */
    inline uint8_t get_NORCR2_CEITV() volatile
    {
        return (NORCR2 >> 24u) & 0b1111u;
    }

    /**
     * Set NORCR2's CEITV field.
     *
     * CE# interval time
     */
    inline void set_NORCR2_CEITV(uint8_t value) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        NORCR2 = curr;
    }

    /**
     * Get NORCR2's RD field.
     *
     * Read time
     */
    inline uint8_t get_NORCR2_RD() volatile
    {
        return (NORCR2 >> 20u) & 0b1111u;
    }

    /**
     * Set NORCR2's RD field.
     *
     * Read time
     */
    inline void set_NORCR2_RD(uint8_t value) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        NORCR2 = curr;
    }

    /**
     * Get NORCR2's LC field.
     *
     * Latency count
     */
    inline uint8_t get_NORCR2_LC() volatile
    {
        return (NORCR2 >> 16u) & 0b1111u;
    }

    /**
     * Set NORCR2's LC field.
     *
     * Latency count
     */
    inline void set_NORCR2_LC(uint8_t value) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        NORCR2 = curr;
    }

    /**
     * Get NORCR2's AWDH field.
     *
     * Address to write data hold time
     */
    inline uint8_t get_NORCR2_AWDH() volatile
    {
        return (NORCR2 >> 12u) & 0b1111u;
    }

    /**
     * Set NORCR2's AWDH field.
     *
     * Address to write data hold time
     */
    inline void set_NORCR2_AWDH(uint8_t value) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        NORCR2 = curr;
    }

    /**
     * Get NORCR2's TA field.
     *
     * Turnaround time
     */
    inline uint8_t get_NORCR2_TA() volatile
    {
        return (NORCR2 >> 8u) & 0b1111u;
    }

    /**
     * Set NORCR2's TA field.
     *
     * Turnaround time
     */
    inline void set_NORCR2_TA(uint8_t value) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        NORCR2 = curr;
    }

    /**
     * Get all of NORCR2's bit fields.
     *
     * (read-write) NOR Control Register 2
     */
    inline void get_NORCR2(uint8_t &RDH, uint8_t &CEITV, uint8_t &RD,
                           uint8_t &LC, uint8_t &AWDH, uint8_t &TA) volatile
    {
        uint32_t curr = NORCR2;

        RDH = (curr >> 28u) & 0b1111u;
        CEITV = (curr >> 24u) & 0b1111u;
        RD = (curr >> 20u) & 0b1111u;
        LC = (curr >> 16u) & 0b1111u;
        AWDH = (curr >> 12u) & 0b1111u;
        TA = (curr >> 8u) & 0b1111u;
    }

    /**
     * Set all of NORCR2's bit fields.
     *
     * (read-write) NOR Control Register 2
     */
    inline void set_NORCR2(uint8_t RDH, uint8_t CEITV, uint8_t RD, uint8_t LC,
                           uint8_t AWDH, uint8_t TA) volatile
    {
        uint32_t curr = NORCR2;

        curr &= ~(0b1111u << 28u);
        curr |= (RDH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (CEITV & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (RD & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (LC & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (AWDH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TA & 0b1111u) << 8u;

        NORCR2 = curr;
    }

    /**
     * Get NORCR3's AHSR field.
     *
     * Address hold time for SYNC read
     */
    inline uint8_t get_NORCR3_AHSR() volatile
    {
        return (NORCR3 >> 4u) & 0b1111u;
    }

    /**
     * Set NORCR3's AHSR field.
     *
     * Address hold time for SYNC read
     */
    inline void set_NORCR3_AHSR(uint8_t value) volatile
    {
        uint32_t curr = NORCR3;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        NORCR3 = curr;
    }

    /**
     * Get NORCR3's ASSR field.
     *
     * Address setup time for SYNC read
     */
    inline uint8_t get_NORCR3_ASSR() volatile
    {
        return (NORCR3 >> 0u) & 0b1111u;
    }

    /**
     * Set NORCR3's ASSR field.
     *
     * Address setup time for SYNC read
     */
    inline void set_NORCR3_ASSR(uint8_t value) volatile
    {
        uint32_t curr = NORCR3;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        NORCR3 = curr;
    }

    /**
     * Get all of NORCR3's bit fields.
     *
     * (read-write) NOR Control Register 3
     */
    inline void get_NORCR3(uint8_t &AHSR, uint8_t &ASSR) volatile
    {
        uint32_t curr = NORCR3;

        AHSR = (curr >> 4u) & 0b1111u;
        ASSR = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of NORCR3's bit fields.
     *
     * (read-write) NOR Control Register 3
     */
    inline void set_NORCR3(uint8_t AHSR, uint8_t ASSR) volatile
    {
        uint32_t curr = NORCR3;

        curr &= ~(0b1111u << 4u);
        curr |= (AHSR & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (ASSR & 0b1111u) << 0u;

        NORCR3 = curr;
    }

    /**
     * Get SRAMCR0's COL field.
     *
     * Column Address bit width
     */
    inline SEMC_SRAMCR0_COL get_SRAMCR0_COL() volatile
    {
        return SEMC_SRAMCR0_COL((SRAMCR0 >> 12u) & 0b1111u);
    }

    /**
     * Set SRAMCR0's COL field.
     *
     * Column Address bit width
     */
    inline void set_SRAMCR0_COL(SEMC_SRAMCR0_COL value) volatile
    {
        uint32_t curr = SRAMCR0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        SRAMCR0 = curr;
    }

    /**
     * Get SRAMCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline bool get_SRAMCR0_ADVH() volatile
    {
        return SRAMCR0 & (1u << 11u);
    }

    /**
     * Set SRAMCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void set_SRAMCR0_ADVH() volatile
    {
        SRAMCR0 |= 1u << 11u;
    }

    /**
     * Clear SRAMCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void clear_SRAMCR0_ADVH() volatile
    {
        SRAMCR0 &= ~(1u << 11u);
    }

    /**
     * Toggle SRAMCR0's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void toggle_SRAMCR0_ADVH() volatile
    {
        SRAMCR0 ^= 1u << 11u;
    }

    /**
     * Get SRAMCR0's ADVP bit.
     *
     * ADV# polarity
     */
    inline bool get_SRAMCR0_ADVP() volatile
    {
        return SRAMCR0 & (1u << 10u);
    }

    /**
     * Set SRAMCR0's ADVP bit.
     *
     * ADV# polarity
     */
    inline void set_SRAMCR0_ADVP() volatile
    {
        SRAMCR0 |= 1u << 10u;
    }

    /**
     * Clear SRAMCR0's ADVP bit.
     *
     * ADV# polarity
     */
    inline void clear_SRAMCR0_ADVP() volatile
    {
        SRAMCR0 &= ~(1u << 10u);
    }

    /**
     * Toggle SRAMCR0's ADVP bit.
     *
     * ADV# polarity
     */
    inline void toggle_SRAMCR0_ADVP() volatile
    {
        SRAMCR0 ^= 1u << 10u;
    }

    /**
     * Get SRAMCR0's AM field.
     *
     * Address Mode
     */
    inline SEMC_SRAMCR0_AM get_SRAMCR0_AM() volatile
    {
        return SEMC_SRAMCR0_AM((SRAMCR0 >> 8u) & 0b11u);
    }

    /**
     * Set SRAMCR0's AM field.
     *
     * Address Mode
     */
    inline void set_SRAMCR0_AM(SEMC_SRAMCR0_AM value) volatile
    {
        uint32_t curr = SRAMCR0;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        SRAMCR0 = curr;
    }

    /**
     * Get SRAMCR0's BL field.
     *
     * Burst Length
     */
    inline SEMC_SRAMCR0_BL get_SRAMCR0_BL() volatile
    {
        return SEMC_SRAMCR0_BL((SRAMCR0 >> 4u) & 0b111u);
    }

    /**
     * Set SRAMCR0's BL field.
     *
     * Burst Length
     */
    inline void set_SRAMCR0_BL(SEMC_SRAMCR0_BL value) volatile
    {
        uint32_t curr = SRAMCR0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        SRAMCR0 = curr;
    }

    /**
     * Get SRAMCR0's WAITSP bit.
     *
     * Wait Sample
     */
    inline bool get_SRAMCR0_WAITSP() volatile
    {
        return SRAMCR0 & (1u << 3u);
    }

    /**
     * Set SRAMCR0's WAITSP bit.
     *
     * Wait Sample
     */
    inline void set_SRAMCR0_WAITSP() volatile
    {
        SRAMCR0 |= 1u << 3u;
    }

    /**
     * Clear SRAMCR0's WAITSP bit.
     *
     * Wait Sample
     */
    inline void clear_SRAMCR0_WAITSP() volatile
    {
        SRAMCR0 &= ~(1u << 3u);
    }

    /**
     * Toggle SRAMCR0's WAITSP bit.
     *
     * Wait Sample
     */
    inline void toggle_SRAMCR0_WAITSP() volatile
    {
        SRAMCR0 ^= 1u << 3u;
    }

    /**
     * Get SRAMCR0's WAITEN bit.
     *
     * Wait Enable
     */
    inline bool get_SRAMCR0_WAITEN() volatile
    {
        return SRAMCR0 & (1u << 2u);
    }

    /**
     * Set SRAMCR0's WAITEN bit.
     *
     * Wait Enable
     */
    inline void set_SRAMCR0_WAITEN() volatile
    {
        SRAMCR0 |= 1u << 2u;
    }

    /**
     * Clear SRAMCR0's WAITEN bit.
     *
     * Wait Enable
     */
    inline void clear_SRAMCR0_WAITEN() volatile
    {
        SRAMCR0 &= ~(1u << 2u);
    }

    /**
     * Toggle SRAMCR0's WAITEN bit.
     *
     * Wait Enable
     */
    inline void toggle_SRAMCR0_WAITEN() volatile
    {
        SRAMCR0 ^= 1u << 2u;
    }

    /**
     * Get SRAMCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline bool get_SRAMCR0_SYNCEN() volatile
    {
        return SRAMCR0 & (1u << 1u);
    }

    /**
     * Set SRAMCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void set_SRAMCR0_SYNCEN() volatile
    {
        SRAMCR0 |= 1u << 1u;
    }

    /**
     * Clear SRAMCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void clear_SRAMCR0_SYNCEN() volatile
    {
        SRAMCR0 &= ~(1u << 1u);
    }

    /**
     * Toggle SRAMCR0's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void toggle_SRAMCR0_SYNCEN() volatile
    {
        SRAMCR0 ^= 1u << 1u;
    }

    /**
     * Get SRAMCR0's PS bit.
     *
     * Port Size
     */
    inline bool get_SRAMCR0_PS() volatile
    {
        return SRAMCR0 & (1u << 0u);
    }

    /**
     * Set SRAMCR0's PS bit.
     *
     * Port Size
     */
    inline void set_SRAMCR0_PS() volatile
    {
        SRAMCR0 |= 1u << 0u;
    }

    /**
     * Clear SRAMCR0's PS bit.
     *
     * Port Size
     */
    inline void clear_SRAMCR0_PS() volatile
    {
        SRAMCR0 &= ~(1u << 0u);
    }

    /**
     * Toggle SRAMCR0's PS bit.
     *
     * Port Size
     */
    inline void toggle_SRAMCR0_PS() volatile
    {
        SRAMCR0 ^= 1u << 0u;
    }

    /**
     * Get all of SRAMCR0's bit fields.
     *
     * (read-write) SRAM Control Register 0
     */
    inline void get_SRAMCR0(SEMC_SRAMCR0_COL &COL, bool &ADVH, bool &ADVP,
                            SEMC_SRAMCR0_AM &AM, SEMC_SRAMCR0_BL &BL,
                            bool &WAITSP, bool &WAITEN, bool &SYNCEN,
                            bool &PS) volatile
    {
        uint32_t curr = SRAMCR0;

        COL = SEMC_SRAMCR0_COL((curr >> 12u) & 0b1111u);
        ADVH = curr & (1u << 11u);
        ADVP = curr & (1u << 10u);
        AM = SEMC_SRAMCR0_AM((curr >> 8u) & 0b11u);
        BL = SEMC_SRAMCR0_BL((curr >> 4u) & 0b111u);
        WAITSP = curr & (1u << 3u);
        WAITEN = curr & (1u << 2u);
        SYNCEN = curr & (1u << 1u);
        PS = curr & (1u << 0u);
    }

    /**
     * Set all of SRAMCR0's bit fields.
     *
     * (read-write) SRAM Control Register 0
     */
    inline void set_SRAMCR0(SEMC_SRAMCR0_COL COL, bool ADVH, bool ADVP,
                            SEMC_SRAMCR0_AM AM, SEMC_SRAMCR0_BL BL,
                            bool WAITSP, bool WAITEN, bool SYNCEN,
                            bool PS) volatile
    {
        uint32_t curr = SRAMCR0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(COL) & 0b1111u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ADVH & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ADVP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(AM) & 0b11u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(BL) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (WAITSP & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (WAITEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SYNCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PS & 0b1u) << 0u;

        SRAMCR0 = curr;
    }

    /**
     * Get SRAMCR1's REH field.
     *
     * RE high time
     */
    inline uint8_t get_SRAMCR1_REH() volatile
    {
        return (SRAMCR1 >> 28u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's REH field.
     *
     * RE high time
     */
    inline void set_SRAMCR1_REH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's REL field.
     *
     * RE low time
     */
    inline uint8_t get_SRAMCR1_REL() volatile
    {
        return (SRAMCR1 >> 24u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's REL field.
     *
     * RE low time
     */
    inline void set_SRAMCR1_REL(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's WEH field.
     *
     * WE high time
     */
    inline uint8_t get_SRAMCR1_WEH() volatile
    {
        return (SRAMCR1 >> 20u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's WEH field.
     *
     * WE high time
     */
    inline void set_SRAMCR1_WEH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's WEL field.
     *
     * WE low time
     */
    inline uint8_t get_SRAMCR1_WEL() volatile
    {
        return (SRAMCR1 >> 16u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's WEL field.
     *
     * WE low time
     */
    inline void set_SRAMCR1_WEL(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's AH field.
     *
     * Address hold time
     */
    inline uint8_t get_SRAMCR1_AH() volatile
    {
        return (SRAMCR1 >> 12u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's AH field.
     *
     * Address hold time
     */
    inline void set_SRAMCR1_AH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's AS field.
     *
     * Address setup time
     */
    inline uint8_t get_SRAMCR1_AS() volatile
    {
        return (SRAMCR1 >> 8u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's AS field.
     *
     * Address setup time
     */
    inline void set_SRAMCR1_AS(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's CEH field.
     *
     * CE hold time
     */
    inline uint8_t get_SRAMCR1_CEH() volatile
    {
        return (SRAMCR1 >> 4u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's CEH field.
     *
     * CE hold time
     */
    inline void set_SRAMCR1_CEH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR1's CES field.
     *
     * CE setup time
     */
    inline uint8_t get_SRAMCR1_CES() volatile
    {
        return (SRAMCR1 >> 0u) & 0b1111u;
    }

    /**
     * Set SRAMCR1's CES field.
     *
     * CE setup time
     */
    inline void set_SRAMCR1_CES(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SRAMCR1 = curr;
    }

    /**
     * Get all of SRAMCR1's bit fields.
     *
     * (read-write) SRAM Control Register 1
     */
    inline void get_SRAMCR1(uint8_t &REH, uint8_t &REL, uint8_t &WEH,
                            uint8_t &WEL, uint8_t &AH, uint8_t &AS,
                            uint8_t &CEH, uint8_t &CES) volatile
    {
        uint32_t curr = SRAMCR1;

        REH = (curr >> 28u) & 0b1111u;
        REL = (curr >> 24u) & 0b1111u;
        WEH = (curr >> 20u) & 0b1111u;
        WEL = (curr >> 16u) & 0b1111u;
        AH = (curr >> 12u) & 0b1111u;
        AS = (curr >> 8u) & 0b1111u;
        CEH = (curr >> 4u) & 0b1111u;
        CES = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of SRAMCR1's bit fields.
     *
     * (read-write) SRAM Control Register 1
     */
    inline void set_SRAMCR1(uint8_t REH, uint8_t REL, uint8_t WEH, uint8_t WEL,
                            uint8_t AH, uint8_t AS, uint8_t CEH,
                            uint8_t CES) volatile
    {
        uint32_t curr = SRAMCR1;

        curr &= ~(0b1111u << 28u);
        curr |= (REH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (REL & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (WEH & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (WEL & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (AH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (AS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (CEH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (CES & 0b1111u) << 0u;

        SRAMCR1 = curr;
    }

    /**
     * Get SRAMCR2's RDH field.
     *
     * Read hold time
     */
    inline uint8_t get_SRAMCR2_RDH() volatile
    {
        return (SRAMCR2 >> 28u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's RDH field.
     *
     * Read hold time
     */
    inline void set_SRAMCR2_RDH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's CEITV field.
     *
     * CE# interval time
     */
    inline uint8_t get_SRAMCR2_CEITV() volatile
    {
        return (SRAMCR2 >> 24u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's CEITV field.
     *
     * CE# interval time
     */
    inline void set_SRAMCR2_CEITV(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's RD field.
     *
     * Read time
     */
    inline uint8_t get_SRAMCR2_RD() volatile
    {
        return (SRAMCR2 >> 20u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's RD field.
     *
     * Read time
     */
    inline void set_SRAMCR2_RD(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's LC field.
     *
     * Latency count
     */
    inline uint8_t get_SRAMCR2_LC() volatile
    {
        return (SRAMCR2 >> 16u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's LC field.
     *
     * Latency count
     */
    inline void set_SRAMCR2_LC(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's AWDH field.
     *
     * Address to write data hold time
     */
    inline uint8_t get_SRAMCR2_AWDH() volatile
    {
        return (SRAMCR2 >> 12u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's AWDH field.
     *
     * Address to write data hold time
     */
    inline void set_SRAMCR2_AWDH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's TA field.
     *
     * Turnaround time
     */
    inline uint8_t get_SRAMCR2_TA() volatile
    {
        return (SRAMCR2 >> 8u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's TA field.
     *
     * Turnaround time
     */
    inline void set_SRAMCR2_TA(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's WDH field.
     *
     * Write Data hold time
     */
    inline uint8_t get_SRAMCR2_WDH() volatile
    {
        return (SRAMCR2 >> 4u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's WDH field.
     *
     * Write Data hold time
     */
    inline void set_SRAMCR2_WDH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        SRAMCR2 = curr;
    }

    /**
     * Get SRAMCR2's WDS field.
     *
     * Write Data setup time
     */
    inline uint8_t get_SRAMCR2_WDS() volatile
    {
        return (SRAMCR2 >> 0u) & 0b1111u;
    }

    /**
     * Set SRAMCR2's WDS field.
     *
     * Write Data setup time
     */
    inline void set_SRAMCR2_WDS(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SRAMCR2 = curr;
    }

    /**
     * Get all of SRAMCR2's bit fields.
     *
     * (read-write) SRAM Control Register 2
     */
    inline void get_SRAMCR2(uint8_t &RDH, uint8_t &CEITV, uint8_t &RD,
                            uint8_t &LC, uint8_t &AWDH, uint8_t &TA,
                            uint8_t &WDH, uint8_t &WDS) volatile
    {
        uint32_t curr = SRAMCR2;

        RDH = (curr >> 28u) & 0b1111u;
        CEITV = (curr >> 24u) & 0b1111u;
        RD = (curr >> 20u) & 0b1111u;
        LC = (curr >> 16u) & 0b1111u;
        AWDH = (curr >> 12u) & 0b1111u;
        TA = (curr >> 8u) & 0b1111u;
        WDH = (curr >> 4u) & 0b1111u;
        WDS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of SRAMCR2's bit fields.
     *
     * (read-write) SRAM Control Register 2
     */
    inline void set_SRAMCR2(uint8_t RDH, uint8_t CEITV, uint8_t RD, uint8_t LC,
                            uint8_t AWDH, uint8_t TA, uint8_t WDH,
                            uint8_t WDS) volatile
    {
        uint32_t curr = SRAMCR2;

        curr &= ~(0b1111u << 28u);
        curr |= (RDH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (CEITV & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (RD & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (LC & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (AWDH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TA & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (WDH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (WDS & 0b1111u) << 0u;

        SRAMCR2 = curr;
    }

    /**
     * Get DBICR0's COL field.
     *
     * Column Address bit width
     */
    inline SEMC_DBICR0_COL get_DBICR0_COL() volatile
    {
        return SEMC_DBICR0_COL((DBICR0 >> 12u) & 0b1111u);
    }

    /**
     * Set DBICR0's COL field.
     *
     * Column Address bit width
     */
    inline void set_DBICR0_COL(SEMC_DBICR0_COL value) volatile
    {
        uint32_t curr = DBICR0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        DBICR0 = curr;
    }

    /**
     * Get DBICR0's BL field.
     *
     * Burst Length
     */
    inline SEMC_DBICR0_BL get_DBICR0_BL() volatile
    {
        return SEMC_DBICR0_BL((DBICR0 >> 4u) & 0b111u);
    }

    /**
     * Set DBICR0's BL field.
     *
     * Burst Length
     */
    inline void set_DBICR0_BL(SEMC_DBICR0_BL value) volatile
    {
        uint32_t curr = DBICR0;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        DBICR0 = curr;
    }

    /**
     * Get DBICR0's PS bit.
     *
     * Port Size
     */
    inline bool get_DBICR0_PS() volatile
    {
        return DBICR0 & (1u << 0u);
    }

    /**
     * Set DBICR0's PS bit.
     *
     * Port Size
     */
    inline void set_DBICR0_PS() volatile
    {
        DBICR0 |= 1u << 0u;
    }

    /**
     * Clear DBICR0's PS bit.
     *
     * Port Size
     */
    inline void clear_DBICR0_PS() volatile
    {
        DBICR0 &= ~(1u << 0u);
    }

    /**
     * Toggle DBICR0's PS bit.
     *
     * Port Size
     */
    inline void toggle_DBICR0_PS() volatile
    {
        DBICR0 ^= 1u << 0u;
    }

    /**
     * Get all of DBICR0's bit fields.
     *
     * (read-write) DBI-B Control Register 0
     */
    inline void get_DBICR0(SEMC_DBICR0_COL &COL, SEMC_DBICR0_BL &BL,
                           bool &PS) volatile
    {
        uint32_t curr = DBICR0;

        COL = SEMC_DBICR0_COL((curr >> 12u) & 0b1111u);
        BL = SEMC_DBICR0_BL((curr >> 4u) & 0b111u);
        PS = curr & (1u << 0u);
    }

    /**
     * Set all of DBICR0's bit fields.
     *
     * (read-write) DBI-B Control Register 0
     */
    inline void set_DBICR0(SEMC_DBICR0_COL COL, SEMC_DBICR0_BL BL,
                           bool PS) volatile
    {
        uint32_t curr = DBICR0;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(COL) & 0b1111u) << 12u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(BL) & 0b111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (PS & 0b1u) << 0u;

        DBICR0 = curr;
    }

    /**
     * Get DBICR1's REH field.
     *
     * RDX High Time
     */
    inline uint8_t get_DBICR1_REH() volatile
    {
        return (DBICR1 >> 24u) & 0b1111111u;
    }

    /**
     * Set DBICR1's REH field.
     *
     * RDX High Time
     */
    inline void set_DBICR1_REH(uint8_t value) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111111u << 24u);
        curr |= (value & 0b1111111u) << 24u;

        DBICR1 = curr;
    }

    /**
     * Get DBICR1's REL field.
     *
     * RDX Low Time
     */
    inline uint8_t get_DBICR1_REL() volatile
    {
        return (DBICR1 >> 16u) & 0b1111111u;
    }

    /**
     * Set DBICR1's REL field.
     *
     * RDX Low Time
     */
    inline void set_DBICR1_REL(uint8_t value) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111111u << 16u);
        curr |= (value & 0b1111111u) << 16u;

        DBICR1 = curr;
    }

    /**
     * Get DBICR1's WEH field.
     *
     * WRX High Time
     */
    inline uint8_t get_DBICR1_WEH() volatile
    {
        return (DBICR1 >> 12u) & 0b1111u;
    }

    /**
     * Set DBICR1's WEH field.
     *
     * WRX High Time
     */
    inline void set_DBICR1_WEH(uint8_t value) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        DBICR1 = curr;
    }

    /**
     * Get DBICR1's WEL field.
     *
     * WRX Low Time
     */
    inline uint8_t get_DBICR1_WEL() volatile
    {
        return (DBICR1 >> 8u) & 0b1111u;
    }

    /**
     * Set DBICR1's WEL field.
     *
     * WRX Low Time
     */
    inline void set_DBICR1_WEL(uint8_t value) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        DBICR1 = curr;
    }

    /**
     * Get DBICR1's CEH field.
     *
     * CSX Hold Time
     */
    inline uint8_t get_DBICR1_CEH() volatile
    {
        return (DBICR1 >> 4u) & 0b1111u;
    }

    /**
     * Set DBICR1's CEH field.
     *
     * CSX Hold Time
     */
    inline void set_DBICR1_CEH(uint8_t value) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        DBICR1 = curr;
    }

    /**
     * Get DBICR1's CES field.
     *
     * CSX Setup Time
     */
    inline uint8_t get_DBICR1_CES() volatile
    {
        return (DBICR1 >> 0u) & 0b1111u;
    }

    /**
     * Set DBICR1's CES field.
     *
     * CSX Setup Time
     */
    inline void set_DBICR1_CES(uint8_t value) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        DBICR1 = curr;
    }

    /**
     * Get all of DBICR1's bit fields.
     *
     * (read-write) DBI-B Control Register 1
     */
    inline void get_DBICR1(uint8_t &REH, uint8_t &REL, uint8_t &WEH,
                           uint8_t &WEL, uint8_t &CEH, uint8_t &CES) volatile
    {
        uint32_t curr = DBICR1;

        REH = (curr >> 24u) & 0b1111111u;
        REL = (curr >> 16u) & 0b1111111u;
        WEH = (curr >> 12u) & 0b1111u;
        WEL = (curr >> 8u) & 0b1111u;
        CEH = (curr >> 4u) & 0b1111u;
        CES = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of DBICR1's bit fields.
     *
     * (read-write) DBI-B Control Register 1
     */
    inline void set_DBICR1(uint8_t REH, uint8_t REL, uint8_t WEH, uint8_t WEL,
                           uint8_t CEH, uint8_t CES) volatile
    {
        uint32_t curr = DBICR1;

        curr &= ~(0b1111111u << 24u);
        curr |= (REH & 0b1111111u) << 24u;
        curr &= ~(0b1111111u << 16u);
        curr |= (REL & 0b1111111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (WEH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WEL & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (CEH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (CES & 0b1111u) << 0u;

        DBICR1 = curr;
    }

    /**
     * Get DBICR2's CEITV field.
     *
     * CSX interval time
     */
    inline uint8_t get_DBICR2_CEITV() volatile
    {
        return (DBICR2 >> 0u) & 0b1111u;
    }

    /**
     * Set DBICR2's CEITV field.
     *
     * CSX interval time
     */
    inline void set_DBICR2_CEITV(uint8_t value) volatile
    {
        uint32_t curr = DBICR2;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        DBICR2 = curr;
    }

    /**
     * Get IPCR0's SA field.
     *
     * Slave address
     */
    inline uint32_t get_IPCR0_SA() volatile
    {
        return (IPCR0 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IPCR0's SA field.
     *
     * Slave address
     */
    inline void set_IPCR0_SA(uint32_t value) volatile
    {
        uint32_t curr = IPCR0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IPCR0 = curr;
    }

    /**
     * Get IPCR1's NAND_EXT_ADDR field.
     *
     * NAND Extended Address
     */
    inline uint8_t get_IPCR1_NAND_EXT_ADDR() volatile
    {
        return (IPCR1 >> 8u) & 0b11111111u;
    }

    /**
     * Set IPCR1's NAND_EXT_ADDR field.
     *
     * NAND Extended Address
     */
    inline void set_IPCR1_NAND_EXT_ADDR(uint8_t value) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        IPCR1 = curr;
    }

    /**
     * Get IPCR1's DATSZ field.
     *
     * Data Size in Byte
     */
    inline SEMC_IPCR1_DATSZ get_IPCR1_DATSZ() volatile
    {
        return SEMC_IPCR1_DATSZ((IPCR1 >> 0u) & 0b111u);
    }

    /**
     * Set IPCR1's DATSZ field.
     *
     * Data Size in Byte
     */
    inline void set_IPCR1_DATSZ(SEMC_IPCR1_DATSZ value) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        IPCR1 = curr;
    }

    /**
     * Get all of IPCR1's bit fields.
     *
     * (read-write) IP Command Control Register 1
     */
    inline void get_IPCR1(uint8_t &NAND_EXT_ADDR,
                          SEMC_IPCR1_DATSZ &DATSZ) volatile
    {
        uint32_t curr = IPCR1;

        NAND_EXT_ADDR = (curr >> 8u) & 0b11111111u;
        DATSZ = SEMC_IPCR1_DATSZ((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of IPCR1's bit fields.
     *
     * (read-write) IP Command Control Register 1
     */
    inline void set_IPCR1(uint8_t NAND_EXT_ADDR,
                          SEMC_IPCR1_DATSZ DATSZ) volatile
    {
        uint32_t curr = IPCR1;

        curr &= ~(0b11111111u << 8u);
        curr |= (NAND_EXT_ADDR & 0b11111111u) << 8u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(DATSZ) & 0b111u) << 0u;

        IPCR1 = curr;
    }

    /**
     * Get IPCR2's BM3 bit.
     *
     * Byte Mask for Byte 3 (IPTXDAT bit 31:24)
     */
    inline bool get_IPCR2_BM3() volatile
    {
        return IPCR2 & (1u << 3u);
    }

    /**
     * Set IPCR2's BM3 bit.
     *
     * Byte Mask for Byte 3 (IPTXDAT bit 31:24)
     */
    inline void set_IPCR2_BM3() volatile
    {
        IPCR2 |= 1u << 3u;
    }

    /**
     * Clear IPCR2's BM3 bit.
     *
     * Byte Mask for Byte 3 (IPTXDAT bit 31:24)
     */
    inline void clear_IPCR2_BM3() volatile
    {
        IPCR2 &= ~(1u << 3u);
    }

    /**
     * Toggle IPCR2's BM3 bit.
     *
     * Byte Mask for Byte 3 (IPTXDAT bit 31:24)
     */
    inline void toggle_IPCR2_BM3() volatile
    {
        IPCR2 ^= 1u << 3u;
    }

    /**
     * Get IPCR2's BM2 bit.
     *
     * Byte Mask for Byte 2 (IPTXDAT bit 23:16)
     */
    inline bool get_IPCR2_BM2() volatile
    {
        return IPCR2 & (1u << 2u);
    }

    /**
     * Set IPCR2's BM2 bit.
     *
     * Byte Mask for Byte 2 (IPTXDAT bit 23:16)
     */
    inline void set_IPCR2_BM2() volatile
    {
        IPCR2 |= 1u << 2u;
    }

    /**
     * Clear IPCR2's BM2 bit.
     *
     * Byte Mask for Byte 2 (IPTXDAT bit 23:16)
     */
    inline void clear_IPCR2_BM2() volatile
    {
        IPCR2 &= ~(1u << 2u);
    }

    /**
     * Toggle IPCR2's BM2 bit.
     *
     * Byte Mask for Byte 2 (IPTXDAT bit 23:16)
     */
    inline void toggle_IPCR2_BM2() volatile
    {
        IPCR2 ^= 1u << 2u;
    }

    /**
     * Get IPCR2's BM1 bit.
     *
     * Byte Mask for Byte 1 (IPTXDAT bit 15:8)
     */
    inline bool get_IPCR2_BM1() volatile
    {
        return IPCR2 & (1u << 1u);
    }

    /**
     * Set IPCR2's BM1 bit.
     *
     * Byte Mask for Byte 1 (IPTXDAT bit 15:8)
     */
    inline void set_IPCR2_BM1() volatile
    {
        IPCR2 |= 1u << 1u;
    }

    /**
     * Clear IPCR2's BM1 bit.
     *
     * Byte Mask for Byte 1 (IPTXDAT bit 15:8)
     */
    inline void clear_IPCR2_BM1() volatile
    {
        IPCR2 &= ~(1u << 1u);
    }

    /**
     * Toggle IPCR2's BM1 bit.
     *
     * Byte Mask for Byte 1 (IPTXDAT bit 15:8)
     */
    inline void toggle_IPCR2_BM1() volatile
    {
        IPCR2 ^= 1u << 1u;
    }

    /**
     * Get IPCR2's BM0 bit.
     *
     * Byte Mask for Byte 0 (IPTXDAT bit 7:0)
     */
    inline bool get_IPCR2_BM0() volatile
    {
        return IPCR2 & (1u << 0u);
    }

    /**
     * Set IPCR2's BM0 bit.
     *
     * Byte Mask for Byte 0 (IPTXDAT bit 7:0)
     */
    inline void set_IPCR2_BM0() volatile
    {
        IPCR2 |= 1u << 0u;
    }

    /**
     * Clear IPCR2's BM0 bit.
     *
     * Byte Mask for Byte 0 (IPTXDAT bit 7:0)
     */
    inline void clear_IPCR2_BM0() volatile
    {
        IPCR2 &= ~(1u << 0u);
    }

    /**
     * Toggle IPCR2's BM0 bit.
     *
     * Byte Mask for Byte 0 (IPTXDAT bit 7:0)
     */
    inline void toggle_IPCR2_BM0() volatile
    {
        IPCR2 ^= 1u << 0u;
    }

    /**
     * Get all of IPCR2's bit fields.
     *
     * (read-write) IP Command Control Register 2
     */
    inline void get_IPCR2(bool &BM3, bool &BM2, bool &BM1, bool &BM0) volatile
    {
        uint32_t curr = IPCR2;

        BM3 = curr & (1u << 3u);
        BM2 = curr & (1u << 2u);
        BM1 = curr & (1u << 1u);
        BM0 = curr & (1u << 0u);
    }

    /**
     * Set all of IPCR2's bit fields.
     *
     * (read-write) IP Command Control Register 2
     */
    inline void set_IPCR2(bool BM3, bool BM2, bool BM1, bool BM0) volatile
    {
        uint32_t curr = IPCR2;

        curr &= ~(0b1u << 3u);
        curr |= (BM3 & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (BM2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (BM1 & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (BM0 & 0b1u) << 0u;

        IPCR2 = curr;
    }

    /**
     * Set IPCMD's KEY field.
     *
     * This field should be written with 0xA55A when trigging an IP command for
     * all device types
     */
    inline void set_IPCMD_KEY(uint16_t value) volatile
    {
        uint32_t curr = IPCMD;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        IPCMD = curr;
    }

    /**
     * Get IPCMD's CMD field.
     *
     * SDRAM Commands: 0x8: Read 0x9: Write 0xA: Mode Register Set 0xB: Active
     * 0xC: Auto Refresh 0xD: Self Refresh 0xE: Precharge 0xF: Precharge All
     * Others: Reserved Self Refresh is sent to all SDRAM devices because they
     * share the same SEMC_CLK pin
     */
    inline uint16_t get_IPCMD_CMD() volatile
    {
        return (IPCMD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IPCMD's CMD field.
     *
     * SDRAM Commands: 0x8: Read 0x9: Write 0xA: Mode Register Set 0xB: Active
     * 0xC: Auto Refresh 0xD: Self Refresh 0xE: Precharge 0xF: Precharge All
     * Others: Reserved Self Refresh is sent to all SDRAM devices because they
     * share the same SEMC_CLK pin
     */
    inline void set_IPCMD_CMD(uint16_t value) volatile
    {
        uint32_t curr = IPCMD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IPCMD = curr;
    }

    /**
     * Set all of IPCMD's bit fields.
     *
     * (read-write) IP Command Register
     */
    inline void set_IPCMD(uint16_t KEY, uint16_t CMD) volatile
    {
        uint32_t curr = IPCMD;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (KEY & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (CMD & 0b1111111111111111u) << 0u;

        IPCMD = curr;
    }

    /**
     * Get IPTXDAT's DAT field.
     *
     * Data value to use for an IP write command
     */
    inline uint32_t get_IPTXDAT_DAT() volatile
    {
        return (IPTXDAT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set IPTXDAT's DAT field.
     *
     * Data value to use for an IP write command
     */
    inline void set_IPTXDAT_DAT(uint32_t value) volatile
    {
        uint32_t curr = IPTXDAT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        IPTXDAT = curr;
    }

    /**
     * Get IPRXDAT's DAT field.
     *
     * Data returned by device for an IP read command.
     */
    inline uint32_t get_IPRXDAT_DAT() volatile
    {
        return (IPRXDAT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get STS0's NARDY bit.
     *
     * Indicating NAND device Ready/WAIT# pin level.
     */
    inline bool get_STS0_NARDY() volatile
    {
        return STS0 & (1u << 1u);
    }

    /**
     * Get STS0's IDLE bit.
     *
     * Indicating whether the SEMC is in idle state.
     */
    inline bool get_STS0_IDLE() volatile
    {
        return STS0 & (1u << 0u);
    }

    /**
     * Get all of STS0's bit fields.
     *
     * (read-write) Status Register 0
     */
    inline void get_STS0(bool &NARDY, bool &IDLE) volatile
    {
        uint32_t curr = STS0;

        NARDY = curr & (1u << 1u);
        IDLE = curr & (1u << 0u);
    }

    /**
     * Get STS2's NDWRPEND bit.
     *
     * This field indicating whether there is pending AXI command (write) to
     * NAND device.
     */
    inline bool get_STS2_NDWRPEND() volatile
    {
        return STS2 & (1u << 3u);
    }

    /**
     * Get STS12's NDADDR field.
     *
     * This field indicating the last write address (AXI command) to NAND
     * device (without base address in SEMC_BR4).
     */
    inline uint32_t get_STS12_NDADDR() volatile
    {
        return (STS12 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get STS13's REFSEL field.
     *
     * Sample clock reference delay line delay cell number selection.
     */
    inline uint8_t get_STS13_REFSEL() volatile
    {
        return (STS13 >> 8u) & 0b111111u;
    }

    /**
     * Get STS13's SLVSEL field.
     *
     * Sample clock slave delay line delay cell number selection.
     */
    inline uint8_t get_STS13_SLVSEL() volatile
    {
        return (STS13 >> 2u) & 0b111111u;
    }

    /**
     * Get STS13's REFLOCK bit.
     *
     * Sample clock reference delay line locked.
     */
    inline bool get_STS13_REFLOCK() volatile
    {
        return STS13 & (1u << 1u);
    }

    /**
     * Get STS13's SLVLOCK bit.
     *
     * Sample clock slave delay line locked.
     */
    inline bool get_STS13_SLVLOCK() volatile
    {
        return STS13 & (1u << 0u);
    }

    /**
     * Get all of STS13's bit fields.
     *
     * (read-write) Status Register 13
     */
    inline void get_STS13(uint8_t &REFSEL, uint8_t &SLVSEL, bool &REFLOCK,
                          bool &SLVLOCK) volatile
    {
        uint32_t curr = STS13;

        REFSEL = (curr >> 8u) & 0b111111u;
        SLVSEL = (curr >> 2u) & 0b111111u;
        REFLOCK = curr & (1u << 1u);
        SLVLOCK = curr & (1u << 0u);
    }

    /**
     * Get BR9's BA field.
     *
     * Base Address
     */
    inline uint32_t get_BR9_BA() volatile
    {
        return (BR9 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set BR9's BA field.
     *
     * Base Address
     */
    inline void set_BR9_BA(uint32_t value) volatile
    {
        uint32_t curr = BR9;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        BR9 = curr;
    }

    /**
     * Get BR9's MS field.
     *
     * Memory size
     */
    inline SEMC_BR9_MS get_BR9_MS() volatile
    {
        return SEMC_BR9_MS((BR9 >> 1u) & 0b11111u);
    }

    /**
     * Set BR9's MS field.
     *
     * Memory size
     */
    inline void set_BR9_MS(SEMC_BR9_MS value) volatile
    {
        uint32_t curr = BR9;

        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(value) & 0b11111u) << 1u;

        BR9 = curr;
    }

    /**
     * Get BR9's VLD bit.
     *
     * Valid
     */
    inline bool get_BR9_VLD() volatile
    {
        return BR9 & (1u << 0u);
    }

    /**
     * Set BR9's VLD bit.
     *
     * Valid
     */
    inline void set_BR9_VLD() volatile
    {
        BR9 |= 1u << 0u;
    }

    /**
     * Clear BR9's VLD bit.
     *
     * Valid
     */
    inline void clear_BR9_VLD() volatile
    {
        BR9 &= ~(1u << 0u);
    }

    /**
     * Toggle BR9's VLD bit.
     *
     * Valid
     */
    inline void toggle_BR9_VLD() volatile
    {
        BR9 ^= 1u << 0u;
    }

    /**
     * Get all of BR9's bit fields.
     *
     * (read-write) Base Register 9
     */
    inline void get_BR9(uint32_t &BA, SEMC_BR9_MS &MS, bool &VLD) volatile
    {
        uint32_t curr = BR9;

        BA = (curr >> 12u) & 0b11111111111111111111u;
        MS = SEMC_BR9_MS((curr >> 1u) & 0b11111u);
        VLD = curr & (1u << 0u);
    }

    /**
     * Set all of BR9's bit fields.
     *
     * (read-write) Base Register 9
     */
    inline void set_BR9(uint32_t BA, SEMC_BR9_MS MS, bool VLD) volatile
    {
        uint32_t curr = BR9;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (BA & 0b11111111111111111111u) << 12u;
        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(MS) & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VLD & 0b1u) << 0u;

        BR9 = curr;
    }

    /**
     * Get BR10's BA field.
     *
     * Base Address
     */
    inline uint32_t get_BR10_BA() volatile
    {
        return (BR10 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set BR10's BA field.
     *
     * Base Address
     */
    inline void set_BR10_BA(uint32_t value) volatile
    {
        uint32_t curr = BR10;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        BR10 = curr;
    }

    /**
     * Get BR10's MS field.
     *
     * Memory size
     */
    inline SEMC_BR10_MS get_BR10_MS() volatile
    {
        return SEMC_BR10_MS((BR10 >> 1u) & 0b11111u);
    }

    /**
     * Set BR10's MS field.
     *
     * Memory size
     */
    inline void set_BR10_MS(SEMC_BR10_MS value) volatile
    {
        uint32_t curr = BR10;

        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(value) & 0b11111u) << 1u;

        BR10 = curr;
    }

    /**
     * Get BR10's VLD bit.
     *
     * Valid
     */
    inline bool get_BR10_VLD() volatile
    {
        return BR10 & (1u << 0u);
    }

    /**
     * Set BR10's VLD bit.
     *
     * Valid
     */
    inline void set_BR10_VLD() volatile
    {
        BR10 |= 1u << 0u;
    }

    /**
     * Clear BR10's VLD bit.
     *
     * Valid
     */
    inline void clear_BR10_VLD() volatile
    {
        BR10 &= ~(1u << 0u);
    }

    /**
     * Toggle BR10's VLD bit.
     *
     * Valid
     */
    inline void toggle_BR10_VLD() volatile
    {
        BR10 ^= 1u << 0u;
    }

    /**
     * Get all of BR10's bit fields.
     *
     * (read-write) Base Register 10
     */
    inline void get_BR10(uint32_t &BA, SEMC_BR10_MS &MS, bool &VLD) volatile
    {
        uint32_t curr = BR10;

        BA = (curr >> 12u) & 0b11111111111111111111u;
        MS = SEMC_BR10_MS((curr >> 1u) & 0b11111u);
        VLD = curr & (1u << 0u);
    }

    /**
     * Set all of BR10's bit fields.
     *
     * (read-write) Base Register 10
     */
    inline void set_BR10(uint32_t BA, SEMC_BR10_MS MS, bool VLD) volatile
    {
        uint32_t curr = BR10;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (BA & 0b11111111111111111111u) << 12u;
        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(MS) & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VLD & 0b1u) << 0u;

        BR10 = curr;
    }

    /**
     * Get BR11's BA field.
     *
     * Base Address
     */
    inline uint32_t get_BR11_BA() volatile
    {
        return (BR11 >> 12u) & 0b11111111111111111111u;
    }

    /**
     * Set BR11's BA field.
     *
     * Base Address
     */
    inline void set_BR11_BA(uint32_t value) volatile
    {
        uint32_t curr = BR11;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (value & 0b11111111111111111111u) << 12u;

        BR11 = curr;
    }

    /**
     * Get BR11's MS field.
     *
     * Memory size
     */
    inline SEMC_BR11_MS get_BR11_MS() volatile
    {
        return SEMC_BR11_MS((BR11 >> 1u) & 0b11111u);
    }

    /**
     * Set BR11's MS field.
     *
     * Memory size
     */
    inline void set_BR11_MS(SEMC_BR11_MS value) volatile
    {
        uint32_t curr = BR11;

        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(value) & 0b11111u) << 1u;

        BR11 = curr;
    }

    /**
     * Get BR11's VLD bit.
     *
     * Valid
     */
    inline bool get_BR11_VLD() volatile
    {
        return BR11 & (1u << 0u);
    }

    /**
     * Set BR11's VLD bit.
     *
     * Valid
     */
    inline void set_BR11_VLD() volatile
    {
        BR11 |= 1u << 0u;
    }

    /**
     * Clear BR11's VLD bit.
     *
     * Valid
     */
    inline void clear_BR11_VLD() volatile
    {
        BR11 &= ~(1u << 0u);
    }

    /**
     * Toggle BR11's VLD bit.
     *
     * Valid
     */
    inline void toggle_BR11_VLD() volatile
    {
        BR11 ^= 1u << 0u;
    }

    /**
     * Get all of BR11's bit fields.
     *
     * (read-write) Base Register 11
     */
    inline void get_BR11(uint32_t &BA, SEMC_BR11_MS &MS, bool &VLD) volatile
    {
        uint32_t curr = BR11;

        BA = (curr >> 12u) & 0b11111111111111111111u;
        MS = SEMC_BR11_MS((curr >> 1u) & 0b11111u);
        VLD = curr & (1u << 0u);
    }

    /**
     * Set all of BR11's bit fields.
     *
     * (read-write) Base Register 11
     */
    inline void set_BR11(uint32_t BA, SEMC_BR11_MS MS, bool VLD) volatile
    {
        uint32_t curr = BR11;

        curr &= ~(0b11111111111111111111u << 12u);
        curr |= (BA & 0b11111111111111111111u) << 12u;
        curr &= ~(0b11111u << 1u);
        curr |= (std::to_underlying(MS) & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (VLD & 0b1u) << 0u;

        BR11 = curr;
    }

    /**
     * Get SRAMCR4's COL field.
     *
     * Column Address bit width
     */
    inline SEMC_SRAMCR4_COL get_SRAMCR4_COL() volatile
    {
        return SEMC_SRAMCR4_COL((SRAMCR4 >> 12u) & 0b1111u);
    }

    /**
     * Set SRAMCR4's COL field.
     *
     * Column Address bit width
     */
    inline void set_SRAMCR4_COL(SEMC_SRAMCR4_COL value) volatile
    {
        uint32_t curr = SRAMCR4;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(value) & 0b1111u) << 12u;

        SRAMCR4 = curr;
    }

    /**
     * Get SRAMCR4's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline bool get_SRAMCR4_ADVH() volatile
    {
        return SRAMCR4 & (1u << 11u);
    }

    /**
     * Set SRAMCR4's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void set_SRAMCR4_ADVH() volatile
    {
        SRAMCR4 |= 1u << 11u;
    }

    /**
     * Clear SRAMCR4's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void clear_SRAMCR4_ADVH() volatile
    {
        SRAMCR4 &= ~(1u << 11u);
    }

    /**
     * Toggle SRAMCR4's ADVH bit.
     *
     * ADV# level control during address hold state
     */
    inline void toggle_SRAMCR4_ADVH() volatile
    {
        SRAMCR4 ^= 1u << 11u;
    }

    /**
     * Get SRAMCR4's ADVP bit.
     *
     * ADV# polarity
     */
    inline bool get_SRAMCR4_ADVP() volatile
    {
        return SRAMCR4 & (1u << 10u);
    }

    /**
     * Set SRAMCR4's ADVP bit.
     *
     * ADV# polarity
     */
    inline void set_SRAMCR4_ADVP() volatile
    {
        SRAMCR4 |= 1u << 10u;
    }

    /**
     * Clear SRAMCR4's ADVP bit.
     *
     * ADV# polarity
     */
    inline void clear_SRAMCR4_ADVP() volatile
    {
        SRAMCR4 &= ~(1u << 10u);
    }

    /**
     * Toggle SRAMCR4's ADVP bit.
     *
     * ADV# polarity
     */
    inline void toggle_SRAMCR4_ADVP() volatile
    {
        SRAMCR4 ^= 1u << 10u;
    }

    /**
     * Get SRAMCR4's AM field.
     *
     * Address Mode
     */
    inline SEMC_SRAMCR4_AM get_SRAMCR4_AM() volatile
    {
        return SEMC_SRAMCR4_AM((SRAMCR4 >> 8u) & 0b11u);
    }

    /**
     * Set SRAMCR4's AM field.
     *
     * Address Mode
     */
    inline void set_SRAMCR4_AM(SEMC_SRAMCR4_AM value) volatile
    {
        uint32_t curr = SRAMCR4;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        SRAMCR4 = curr;
    }

    /**
     * Get SRAMCR4's BL field.
     *
     * Burst Length
     */
    inline SEMC_SRAMCR4_BL get_SRAMCR4_BL() volatile
    {
        return SEMC_SRAMCR4_BL((SRAMCR4 >> 4u) & 0b111u);
    }

    /**
     * Set SRAMCR4's BL field.
     *
     * Burst Length
     */
    inline void set_SRAMCR4_BL(SEMC_SRAMCR4_BL value) volatile
    {
        uint32_t curr = SRAMCR4;

        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(value) & 0b111u) << 4u;

        SRAMCR4 = curr;
    }

    /**
     * Get SRAMCR4's WAITSP bit.
     *
     * Wait Sample
     */
    inline bool get_SRAMCR4_WAITSP() volatile
    {
        return SRAMCR4 & (1u << 3u);
    }

    /**
     * Set SRAMCR4's WAITSP bit.
     *
     * Wait Sample
     */
    inline void set_SRAMCR4_WAITSP() volatile
    {
        SRAMCR4 |= 1u << 3u;
    }

    /**
     * Clear SRAMCR4's WAITSP bit.
     *
     * Wait Sample
     */
    inline void clear_SRAMCR4_WAITSP() volatile
    {
        SRAMCR4 &= ~(1u << 3u);
    }

    /**
     * Toggle SRAMCR4's WAITSP bit.
     *
     * Wait Sample
     */
    inline void toggle_SRAMCR4_WAITSP() volatile
    {
        SRAMCR4 ^= 1u << 3u;
    }

    /**
     * Get SRAMCR4's WAITEN bit.
     *
     * Wait Enable
     */
    inline bool get_SRAMCR4_WAITEN() volatile
    {
        return SRAMCR4 & (1u << 2u);
    }

    /**
     * Set SRAMCR4's WAITEN bit.
     *
     * Wait Enable
     */
    inline void set_SRAMCR4_WAITEN() volatile
    {
        SRAMCR4 |= 1u << 2u;
    }

    /**
     * Clear SRAMCR4's WAITEN bit.
     *
     * Wait Enable
     */
    inline void clear_SRAMCR4_WAITEN() volatile
    {
        SRAMCR4 &= ~(1u << 2u);
    }

    /**
     * Toggle SRAMCR4's WAITEN bit.
     *
     * Wait Enable
     */
    inline void toggle_SRAMCR4_WAITEN() volatile
    {
        SRAMCR4 ^= 1u << 2u;
    }

    /**
     * Get SRAMCR4's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline bool get_SRAMCR4_SYNCEN() volatile
    {
        return SRAMCR4 & (1u << 1u);
    }

    /**
     * Set SRAMCR4's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void set_SRAMCR4_SYNCEN() volatile
    {
        SRAMCR4 |= 1u << 1u;
    }

    /**
     * Clear SRAMCR4's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void clear_SRAMCR4_SYNCEN() volatile
    {
        SRAMCR4 &= ~(1u << 1u);
    }

    /**
     * Toggle SRAMCR4's SYNCEN bit.
     *
     * Synchronous Mode Enable
     */
    inline void toggle_SRAMCR4_SYNCEN() volatile
    {
        SRAMCR4 ^= 1u << 1u;
    }

    /**
     * Get SRAMCR4's PS bit.
     *
     * Port Size
     */
    inline bool get_SRAMCR4_PS() volatile
    {
        return SRAMCR4 & (1u << 0u);
    }

    /**
     * Set SRAMCR4's PS bit.
     *
     * Port Size
     */
    inline void set_SRAMCR4_PS() volatile
    {
        SRAMCR4 |= 1u << 0u;
    }

    /**
     * Clear SRAMCR4's PS bit.
     *
     * Port Size
     */
    inline void clear_SRAMCR4_PS() volatile
    {
        SRAMCR4 &= ~(1u << 0u);
    }

    /**
     * Toggle SRAMCR4's PS bit.
     *
     * Port Size
     */
    inline void toggle_SRAMCR4_PS() volatile
    {
        SRAMCR4 ^= 1u << 0u;
    }

    /**
     * Get all of SRAMCR4's bit fields.
     *
     * (read-write) SRAM Control Register 4
     */
    inline void get_SRAMCR4(SEMC_SRAMCR4_COL &COL, bool &ADVH, bool &ADVP,
                            SEMC_SRAMCR4_AM &AM, SEMC_SRAMCR4_BL &BL,
                            bool &WAITSP, bool &WAITEN, bool &SYNCEN,
                            bool &PS) volatile
    {
        uint32_t curr = SRAMCR4;

        COL = SEMC_SRAMCR4_COL((curr >> 12u) & 0b1111u);
        ADVH = curr & (1u << 11u);
        ADVP = curr & (1u << 10u);
        AM = SEMC_SRAMCR4_AM((curr >> 8u) & 0b11u);
        BL = SEMC_SRAMCR4_BL((curr >> 4u) & 0b111u);
        WAITSP = curr & (1u << 3u);
        WAITEN = curr & (1u << 2u);
        SYNCEN = curr & (1u << 1u);
        PS = curr & (1u << 0u);
    }

    /**
     * Set all of SRAMCR4's bit fields.
     *
     * (read-write) SRAM Control Register 4
     */
    inline void set_SRAMCR4(SEMC_SRAMCR4_COL COL, bool ADVH, bool ADVP,
                            SEMC_SRAMCR4_AM AM, SEMC_SRAMCR4_BL BL,
                            bool WAITSP, bool WAITEN, bool SYNCEN,
                            bool PS) volatile
    {
        uint32_t curr = SRAMCR4;

        curr &= ~(0b1111u << 12u);
        curr |= (std::to_underlying(COL) & 0b1111u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ADVH & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ADVP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(AM) & 0b11u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (std::to_underlying(BL) & 0b111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (WAITSP & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (WAITEN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SYNCEN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PS & 0b1u) << 0u;

        SRAMCR4 = curr;
    }

    /**
     * Get SRAMCR5's REH field.
     *
     * RE high time
     */
    inline uint8_t get_SRAMCR5_REH() volatile
    {
        return (SRAMCR5 >> 28u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's REH field.
     *
     * RE high time
     */
    inline void set_SRAMCR5_REH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's REL field.
     *
     * RE low time
     */
    inline uint8_t get_SRAMCR5_REL() volatile
    {
        return (SRAMCR5 >> 24u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's REL field.
     *
     * RE low time
     */
    inline void set_SRAMCR5_REL(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's WEH field.
     *
     * WE high time
     */
    inline uint8_t get_SRAMCR5_WEH() volatile
    {
        return (SRAMCR5 >> 20u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's WEH field.
     *
     * WE high time
     */
    inline void set_SRAMCR5_WEH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's WEL field.
     *
     * WE low time
     */
    inline uint8_t get_SRAMCR5_WEL() volatile
    {
        return (SRAMCR5 >> 16u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's WEL field.
     *
     * WE low time
     */
    inline void set_SRAMCR5_WEL(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's AH field.
     *
     * Address hold time
     */
    inline uint8_t get_SRAMCR5_AH() volatile
    {
        return (SRAMCR5 >> 12u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's AH field.
     *
     * Address hold time
     */
    inline void set_SRAMCR5_AH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's AS field.
     *
     * Address setup time
     */
    inline uint8_t get_SRAMCR5_AS() volatile
    {
        return (SRAMCR5 >> 8u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's AS field.
     *
     * Address setup time
     */
    inline void set_SRAMCR5_AS(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's CEH field.
     *
     * CE hold time
     */
    inline uint8_t get_SRAMCR5_CEH() volatile
    {
        return (SRAMCR5 >> 4u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's CEH field.
     *
     * CE hold time
     */
    inline void set_SRAMCR5_CEH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR5's CES field.
     *
     * CE setup time
     */
    inline uint8_t get_SRAMCR5_CES() volatile
    {
        return (SRAMCR5 >> 0u) & 0b1111u;
    }

    /**
     * Set SRAMCR5's CES field.
     *
     * CE setup time
     */
    inline void set_SRAMCR5_CES(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SRAMCR5 = curr;
    }

    /**
     * Get all of SRAMCR5's bit fields.
     *
     * (read-write) SRAM Control Register 5
     */
    inline void get_SRAMCR5(uint8_t &REH, uint8_t &REL, uint8_t &WEH,
                            uint8_t &WEL, uint8_t &AH, uint8_t &AS,
                            uint8_t &CEH, uint8_t &CES) volatile
    {
        uint32_t curr = SRAMCR5;

        REH = (curr >> 28u) & 0b1111u;
        REL = (curr >> 24u) & 0b1111u;
        WEH = (curr >> 20u) & 0b1111u;
        WEL = (curr >> 16u) & 0b1111u;
        AH = (curr >> 12u) & 0b1111u;
        AS = (curr >> 8u) & 0b1111u;
        CEH = (curr >> 4u) & 0b1111u;
        CES = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of SRAMCR5's bit fields.
     *
     * (read-write) SRAM Control Register 5
     */
    inline void set_SRAMCR5(uint8_t REH, uint8_t REL, uint8_t WEH, uint8_t WEL,
                            uint8_t AH, uint8_t AS, uint8_t CEH,
                            uint8_t CES) volatile
    {
        uint32_t curr = SRAMCR5;

        curr &= ~(0b1111u << 28u);
        curr |= (REH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (REL & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (WEH & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (WEL & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (AH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (AS & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (CEH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (CES & 0b1111u) << 0u;

        SRAMCR5 = curr;
    }

    /**
     * Get SRAMCR6's RDH field.
     *
     * Read hold time
     */
    inline uint8_t get_SRAMCR6_RDH() volatile
    {
        return (SRAMCR6 >> 28u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's RDH field.
     *
     * Read hold time
     */
    inline void set_SRAMCR6_RDH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 28u);
        curr |= (value & 0b1111u) << 28u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's CEITV field.
     *
     * CE# interval time
     */
    inline uint8_t get_SRAMCR6_CEITV() volatile
    {
        return (SRAMCR6 >> 24u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's CEITV field.
     *
     * CE# interval time
     */
    inline void set_SRAMCR6_CEITV(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's RD field.
     *
     * Read time
     */
    inline uint8_t get_SRAMCR6_RD() volatile
    {
        return (SRAMCR6 >> 20u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's RD field.
     *
     * Read time
     */
    inline void set_SRAMCR6_RD(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 20u);
        curr |= (value & 0b1111u) << 20u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's LC field.
     *
     * Latency count
     */
    inline uint8_t get_SRAMCR6_LC() volatile
    {
        return (SRAMCR6 >> 16u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's LC field.
     *
     * Latency count
     */
    inline void set_SRAMCR6_LC(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's AWDH field.
     *
     * Address to write data hold time
     */
    inline uint8_t get_SRAMCR6_AWDH() volatile
    {
        return (SRAMCR6 >> 12u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's AWDH field.
     *
     * Address to write data hold time
     */
    inline void set_SRAMCR6_AWDH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 12u);
        curr |= (value & 0b1111u) << 12u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's TA field.
     *
     * Turnaround time
     */
    inline uint8_t get_SRAMCR6_TA() volatile
    {
        return (SRAMCR6 >> 8u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's TA field.
     *
     * Turnaround time
     */
    inline void set_SRAMCR6_TA(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's WDH field.
     *
     * Write Data hold time
     */
    inline uint8_t get_SRAMCR6_WDH() volatile
    {
        return (SRAMCR6 >> 4u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's WDH field.
     *
     * Write Data hold time
     */
    inline void set_SRAMCR6_WDH(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        SRAMCR6 = curr;
    }

    /**
     * Get SRAMCR6's WDS field.
     *
     * Write Data setup time
     */
    inline uint8_t get_SRAMCR6_WDS() volatile
    {
        return (SRAMCR6 >> 0u) & 0b1111u;
    }

    /**
     * Set SRAMCR6's WDS field.
     *
     * Write Data setup time
     */
    inline void set_SRAMCR6_WDS(uint8_t value) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SRAMCR6 = curr;
    }

    /**
     * Get all of SRAMCR6's bit fields.
     *
     * (read-write) SRAM Control Register 6
     */
    inline void get_SRAMCR6(uint8_t &RDH, uint8_t &CEITV, uint8_t &RD,
                            uint8_t &LC, uint8_t &AWDH, uint8_t &TA,
                            uint8_t &WDH, uint8_t &WDS) volatile
    {
        uint32_t curr = SRAMCR6;

        RDH = (curr >> 28u) & 0b1111u;
        CEITV = (curr >> 24u) & 0b1111u;
        RD = (curr >> 20u) & 0b1111u;
        LC = (curr >> 16u) & 0b1111u;
        AWDH = (curr >> 12u) & 0b1111u;
        TA = (curr >> 8u) & 0b1111u;
        WDH = (curr >> 4u) & 0b1111u;
        WDS = (curr >> 0u) & 0b1111u;
    }

    /**
     * Set all of SRAMCR6's bit fields.
     *
     * (read-write) SRAM Control Register 6
     */
    inline void set_SRAMCR6(uint8_t RDH, uint8_t CEITV, uint8_t RD, uint8_t LC,
                            uint8_t AWDH, uint8_t TA, uint8_t WDH,
                            uint8_t WDS) volatile
    {
        uint32_t curr = SRAMCR6;

        curr &= ~(0b1111u << 28u);
        curr |= (RDH & 0b1111u) << 28u;
        curr &= ~(0b1111u << 24u);
        curr |= (CEITV & 0b1111u) << 24u;
        curr &= ~(0b1111u << 20u);
        curr |= (RD & 0b1111u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (LC & 0b1111u) << 16u;
        curr &= ~(0b1111u << 12u);
        curr |= (AWDH & 0b1111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (TA & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (WDH & 0b1111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (WDS & 0b1111u) << 0u;

        SRAMCR6 = curr;
    }

    /**
     * Get DCCR's SRAMXVAL field.
     *
     * Clock delay line delay cell number selection value for SRAM device 1-3.
     */
    inline uint8_t get_DCCR_SRAMXVAL() volatile
    {
        return (DCCR >> 25u) & 0b11111u;
    }

    /**
     * Set DCCR's SRAMXVAL field.
     *
     * Clock delay line delay cell number selection value for SRAM device 1-3.
     */
    inline void set_DCCR_SRAMXVAL(uint8_t value) volatile
    {
        uint32_t curr = DCCR;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        DCCR = curr;
    }

    /**
     * Get DCCR's SRAMXEN bit.
     *
     * Delay chain insertion enable for SRAM device 1-3.
     */
    inline bool get_DCCR_SRAMXEN() volatile
    {
        return DCCR & (1u << 24u);
    }

    /**
     * Set DCCR's SRAMXEN bit.
     *
     * Delay chain insertion enable for SRAM device 1-3.
     */
    inline void set_DCCR_SRAMXEN() volatile
    {
        DCCR |= 1u << 24u;
    }

    /**
     * Clear DCCR's SRAMXEN bit.
     *
     * Delay chain insertion enable for SRAM device 1-3.
     */
    inline void clear_DCCR_SRAMXEN() volatile
    {
        DCCR &= ~(1u << 24u);
    }

    /**
     * Toggle DCCR's SRAMXEN bit.
     *
     * Delay chain insertion enable for SRAM device 1-3.
     */
    inline void toggle_DCCR_SRAMXEN() volatile
    {
        DCCR ^= 1u << 24u;
    }

    /**
     * Get DCCR's SRAM0VAL field.
     *
     * Clock delay line delay cell number selection value for SRAM device 0.
     */
    inline uint8_t get_DCCR_SRAM0VAL() volatile
    {
        return (DCCR >> 17u) & 0b11111u;
    }

    /**
     * Set DCCR's SRAM0VAL field.
     *
     * Clock delay line delay cell number selection value for SRAM device 0.
     */
    inline void set_DCCR_SRAM0VAL(uint8_t value) volatile
    {
        uint32_t curr = DCCR;

        curr &= ~(0b11111u << 17u);
        curr |= (value & 0b11111u) << 17u;

        DCCR = curr;
    }

    /**
     * Get DCCR's SRAM0EN bit.
     *
     * Delay chain insertion enable for SRAM device 0.
     */
    inline bool get_DCCR_SRAM0EN() volatile
    {
        return DCCR & (1u << 16u);
    }

    /**
     * Set DCCR's SRAM0EN bit.
     *
     * Delay chain insertion enable for SRAM device 0.
     */
    inline void set_DCCR_SRAM0EN() volatile
    {
        DCCR |= 1u << 16u;
    }

    /**
     * Clear DCCR's SRAM0EN bit.
     *
     * Delay chain insertion enable for SRAM device 0.
     */
    inline void clear_DCCR_SRAM0EN() volatile
    {
        DCCR &= ~(1u << 16u);
    }

    /**
     * Toggle DCCR's SRAM0EN bit.
     *
     * Delay chain insertion enable for SRAM device 0.
     */
    inline void toggle_DCCR_SRAM0EN() volatile
    {
        DCCR ^= 1u << 16u;
    }

    /**
     * Get DCCR's NORVAL field.
     *
     * Clock delay line delay cell number selection value for NOR device.
     */
    inline uint8_t get_DCCR_NORVAL() volatile
    {
        return (DCCR >> 9u) & 0b11111u;
    }

    /**
     * Set DCCR's NORVAL field.
     *
     * Clock delay line delay cell number selection value for NOR device.
     */
    inline void set_DCCR_NORVAL(uint8_t value) volatile
    {
        uint32_t curr = DCCR;

        curr &= ~(0b11111u << 9u);
        curr |= (value & 0b11111u) << 9u;

        DCCR = curr;
    }

    /**
     * Get DCCR's NOREN bit.
     *
     * Delay chain insertion enable for NOR device.
     */
    inline bool get_DCCR_NOREN() volatile
    {
        return DCCR & (1u << 8u);
    }

    /**
     * Set DCCR's NOREN bit.
     *
     * Delay chain insertion enable for NOR device.
     */
    inline void set_DCCR_NOREN() volatile
    {
        DCCR |= 1u << 8u;
    }

    /**
     * Clear DCCR's NOREN bit.
     *
     * Delay chain insertion enable for NOR device.
     */
    inline void clear_DCCR_NOREN() volatile
    {
        DCCR &= ~(1u << 8u);
    }

    /**
     * Toggle DCCR's NOREN bit.
     *
     * Delay chain insertion enable for NOR device.
     */
    inline void toggle_DCCR_NOREN() volatile
    {
        DCCR ^= 1u << 8u;
    }

    /**
     * Get DCCR's SDRAMVAL field.
     *
     * Clock delay line delay cell number selection value for SDRAM device.
     */
    inline uint8_t get_DCCR_SDRAMVAL() volatile
    {
        return (DCCR >> 1u) & 0b11111u;
    }

    /**
     * Set DCCR's SDRAMVAL field.
     *
     * Clock delay line delay cell number selection value for SDRAM device.
     */
    inline void set_DCCR_SDRAMVAL(uint8_t value) volatile
    {
        uint32_t curr = DCCR;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        DCCR = curr;
    }

    /**
     * Get DCCR's SDRAMEN bit.
     *
     * Delay chain insertion enable for SRAM device.
     */
    inline bool get_DCCR_SDRAMEN() volatile
    {
        return DCCR & (1u << 0u);
    }

    /**
     * Set DCCR's SDRAMEN bit.
     *
     * Delay chain insertion enable for SRAM device.
     */
    inline void set_DCCR_SDRAMEN() volatile
    {
        DCCR |= 1u << 0u;
    }

    /**
     * Clear DCCR's SDRAMEN bit.
     *
     * Delay chain insertion enable for SRAM device.
     */
    inline void clear_DCCR_SDRAMEN() volatile
    {
        DCCR &= ~(1u << 0u);
    }

    /**
     * Toggle DCCR's SDRAMEN bit.
     *
     * Delay chain insertion enable for SRAM device.
     */
    inline void toggle_DCCR_SDRAMEN() volatile
    {
        DCCR ^= 1u << 0u;
    }

    /**
     * Get all of DCCR's bit fields.
     *
     * (read-write) Delay Chain Control Register
     */
    inline void get_DCCR(uint8_t &SRAMXVAL, bool &SRAMXEN, uint8_t &SRAM0VAL,
                         bool &SRAM0EN, uint8_t &NORVAL, bool &NOREN,
                         uint8_t &SDRAMVAL, bool &SDRAMEN) volatile
    {
        uint32_t curr = DCCR;

        SRAMXVAL = (curr >> 25u) & 0b11111u;
        SRAMXEN = curr & (1u << 24u);
        SRAM0VAL = (curr >> 17u) & 0b11111u;
        SRAM0EN = curr & (1u << 16u);
        NORVAL = (curr >> 9u) & 0b11111u;
        NOREN = curr & (1u << 8u);
        SDRAMVAL = (curr >> 1u) & 0b11111u;
        SDRAMEN = curr & (1u << 0u);
    }

    /**
     * Set all of DCCR's bit fields.
     *
     * (read-write) Delay Chain Control Register
     */
    inline void set_DCCR(uint8_t SRAMXVAL, bool SRAMXEN, uint8_t SRAM0VAL,
                         bool SRAM0EN, uint8_t NORVAL, bool NOREN,
                         uint8_t SDRAMVAL, bool SDRAMEN) volatile
    {
        uint32_t curr = DCCR;

        curr &= ~(0b11111u << 25u);
        curr |= (SRAMXVAL & 0b11111u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (SRAMXEN & 0b1u) << 24u;
        curr &= ~(0b11111u << 17u);
        curr |= (SRAM0VAL & 0b11111u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SRAM0EN & 0b1u) << 16u;
        curr &= ~(0b11111u << 9u);
        curr |= (NORVAL & 0b11111u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (NOREN & 0b1u) << 8u;
        curr &= ~(0b11111u << 1u);
        curr |= (SDRAMVAL & 0b11111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SDRAMEN & 0b1u) << 0u;

        DCCR = curr;
    }
};

static_assert(sizeof(semc) == semc::size);

static volatile semc *const SEMC = reinterpret_cast<semc *>(0x400D4000);

}; // namespace MIMXRT1176::CM7
