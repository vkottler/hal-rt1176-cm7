/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/SNVS_HPCR_HPCALB_VAL.h"
#include "../enums/SNVS_HPCR_PI_FREQ.h"
#include "../enums/SNVS_HPSR_SSM_STATE.h"
#include "../enums/SNVS_HPSR_SYS_SECURITY_CFG.h"
#include "../enums/SNVS_HPSVCR_LPSV_CFG.h"
#include "../enums/SNVS_HPSVCR_OCOTP_CFG.h"
#include "../enums/SNVS_LPCR_LPCALB_VAL.h"
#include "../enums/SNVS_LPMKCR_MASTER_KEY_SEL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * SNVS
 */
struct [[gnu::packed]] snvs
{
    /* Constant attributes. */
    static constexpr std::size_t size = 3072; /*!< snvs's size in bytes. */

    /* Fields. */
    uint32_t HPLR;   /*!< (read-write) SNVS_HP Lock Register */
    uint32_t HPCOMR; /*!< (read-write) SNVS_HP Command Register */
    uint32_t HPCR;   /*!< (read-write) SNVS_HP Control Register */
    uint32_t HPSICR; /*!< (read-write) SNVS_HP Security Interrupt Control
                        Register */
    uint32_t HPSVCR; /*!< (read-write) SNVS_HP Security Violation Control
                        Register */
    uint32_t HPSR;   /*!< (read-write) SNVS_HP Status Register */
    uint32_t
        HPSVSR; /*!< (read-write) SNVS_HP Security Violation Status Register */
    uint32_t HPHACIVR; /*!< (read-write) SNVS_HP High Assurance Counter IV
                          Register */
    uint32_t
        HPHACR; /*!< (read-write) SNVS_HP High Assurance Counter Register */
    uint32_t
        HPRTCMR; /*!< (read-write) SNVS_HP Real Time Counter MSB Register */
    uint32_t
        HPRTCLR; /*!< (read-write) SNVS_HP Real Time Counter LSB Register */
    uint32_t HPTAMR;   /*!< (read-write) SNVS_HP Time Alarm MSB Register */
    uint32_t HPTALR;   /*!< (read-write) SNVS_HP Time Alarm LSB Register */
    uint32_t LPLR;     /*!< (read-write) SNVS_LP Lock Register */
    uint32_t LPCR;     /*!< (read-write) SNVS_LP Control Register */
    uint32_t LPMKCR;   /*!< (read-write) SNVS_LP Master Key Control Register */
    uint32_t LPSVCR;   /*!< (read-write) SNVS_LP Security Violation Control
                          Register */
    uint32_t LPTGFCR;  /*!< (read-write) SNVS_LP Tamper Glitch Filters
                          Configuration Register */
    uint32_t LPTDCR;   /*!< (read-write) SNVS_LP Tamper Detect Configuration
                          Register */
    uint32_t LPSR;     /*!< (read-write) SNVS_LP Status Register */
    uint32_t LPSRTCMR; /*!< (read-write) SNVS_LP Secure Real Time Counter MSB
                          Register */
    uint32_t LPSRTCLR; /*!< (read-write) SNVS_LP Secure Real Time Counter LSB
                          Register */
    uint32_t LPTAR;    /*!< (read-write) SNVS_LP Time Alarm Register */
    uint32_t LPSMCMR;  /*!< (read-write) SNVS_LP Secure Monotonic Counter MSB
                          Register */
    uint32_t LPSMCLR;  /*!< (read-write) SNVS_LP Secure Monotonic Counter LSB
                          Register */
    uint32_t LPLVDR;   /*!< (read-write) SNVS_LP Digital Low-Voltage Detector
                          Register */
    uint32_t LPGPR0_legacy_alias; /*!< (read-write) SNVS_LP General Purpose
                                     Register 0 (legacy alias) */
    static constexpr std::size_t LPZMKR_length = 8;
    uint32_t LPZMKR[LPZMKR_length]; /*!< (read-write) SNVS_LP Zeroizable Master
                                       Key Register */
    const uint32_t reserved_padding0 = {};
    static constexpr std::size_t LPGPR_alias_length = 4;
    uint32_t LPGPR_alias[LPGPR_alias_length]; /*!< (read-write) SNVS_LP General
                                                 Purpose Registers 0 .. 3 */
    uint32_t LPTDC2R; /*!< (read-write) SNVS_LP Tamper Detectors Config 2
                         Register */
    uint32_t
        LPTDSR; /*!< (read-write) SNVS_LP Tamper Detectors Status Register */
    uint32_t LPTGF1CR; /*!< (read-write) SNVS_LP Tamper Glitch Filter 1
                          Configuration Register */
    uint32_t LPTGF2CR; /*!< (read-write) SNVS_LP Tamper Glitch Filter 2
                          Configuration Register */
    static constexpr std::size_t reserved_padding1_length = 4;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t LPAT1CR; /*!< (read-write) SNVS_LP Active Tamper 1 Configuration
                         Register */
    uint32_t LPAT2CR; /*!< (read-write) SNVS_LP Active Tamper 2 Configuration
                         Register */
    uint32_t LPAT3CR; /*!< (read-write) SNVS_LP Active Tamper 3 Configuration
                         Register */
    uint32_t LPAT4CR; /*!< (read-write) SNVS_LP Active Tamper 4 Configuration
                         Register */
    uint32_t LPAT5CR; /*!< (read-write) SNVS_LP Active Tamper 5 Configuration
                         Register */
    static constexpr std::size_t reserved_padding2_length = 3;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t
        LPATCTLR; /*!< (read-write) SNVS_LP Active Tamper Control Register */
    uint32_t LPATCLKR; /*!< (read-write) SNVS_LP Active Tamper Clock Control
                          Register */
    uint32_t LPATRC1R; /*!< (read-write) SNVS_LP Active Tamper Routing Control
                          1 Register */
    uint32_t LPATRC2R; /*!< (read-write) SNVS_LP Active Tamper Routing Control
                          2 Register */
    static constexpr std::size_t reserved_padding3_length = 4;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    static constexpr std::size_t LPGPR_length = 4;
    uint32_t LPGPR[LPGPR_length]; /*!< (read-write) SNVS_LP General Purpose
                                     Registers 0 .. 3 */
    static constexpr std::size_t reserved_padding4_length = 698;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t HPVIDR1; /*!< (read-write) SNVS_HP Version ID Register 1 */
    uint32_t HPVIDR2; /*!< (read-write) SNVS_HP Version ID Register 2 */

    /* Methods. */

    /**
     * Get HPLR's AT5_SL bit.
     *
     * Active Tamper 5 Soft Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline bool get_HPLR_AT5_SL() volatile
    {
        return HPLR & (1u << 28u);
    }

    /**
     * Set HPLR's AT5_SL bit.
     *
     * Active Tamper 5 Soft Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline void set_HPLR_AT5_SL() volatile
    {
        HPLR |= 1u << 28u;
    }

    /**
     * Clear HPLR's AT5_SL bit.
     *
     * Active Tamper 5 Soft Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline void clear_HPLR_AT5_SL() volatile
    {
        HPLR &= ~(1u << 28u);
    }

    /**
     * Toggle HPLR's AT5_SL bit.
     *
     * Active Tamper 5 Soft Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline void toggle_HPLR_AT5_SL() volatile
    {
        HPLR ^= 1u << 28u;
    }

    /**
     * Get HPLR's AT4_SL bit.
     *
     * Active Tamper 4 Soft Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline bool get_HPLR_AT4_SL() volatile
    {
        return HPLR & (1u << 27u);
    }

    /**
     * Set HPLR's AT4_SL bit.
     *
     * Active Tamper 4 Soft Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline void set_HPLR_AT4_SL() volatile
    {
        HPLR |= 1u << 27u;
    }

    /**
     * Clear HPLR's AT4_SL bit.
     *
     * Active Tamper 4 Soft Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline void clear_HPLR_AT4_SL() volatile
    {
        HPLR &= ~(1u << 27u);
    }

    /**
     * Toggle HPLR's AT4_SL bit.
     *
     * Active Tamper 4 Soft Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline void toggle_HPLR_AT4_SL() volatile
    {
        HPLR ^= 1u << 27u;
    }

    /**
     * Get HPLR's AT3_SL bit.
     *
     * Active Tamper 3 Soft Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline bool get_HPLR_AT3_SL() volatile
    {
        return HPLR & (1u << 26u);
    }

    /**
     * Set HPLR's AT3_SL bit.
     *
     * Active Tamper 3 Soft Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline void set_HPLR_AT3_SL() volatile
    {
        HPLR |= 1u << 26u;
    }

    /**
     * Clear HPLR's AT3_SL bit.
     *
     * Active Tamper 3 Soft Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline void clear_HPLR_AT3_SL() volatile
    {
        HPLR &= ~(1u << 26u);
    }

    /**
     * Toggle HPLR's AT3_SL bit.
     *
     * Active Tamper 3 Soft Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline void toggle_HPLR_AT3_SL() volatile
    {
        HPLR ^= 1u << 26u;
    }

    /**
     * Get HPLR's AT2_SL bit.
     *
     * Active Tamper 2 Soft Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline bool get_HPLR_AT2_SL() volatile
    {
        return HPLR & (1u << 25u);
    }

    /**
     * Set HPLR's AT2_SL bit.
     *
     * Active Tamper 2 Soft Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline void set_HPLR_AT2_SL() volatile
    {
        HPLR |= 1u << 25u;
    }

    /**
     * Clear HPLR's AT2_SL bit.
     *
     * Active Tamper 2 Soft Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline void clear_HPLR_AT2_SL() volatile
    {
        HPLR &= ~(1u << 25u);
    }

    /**
     * Toggle HPLR's AT2_SL bit.
     *
     * Active Tamper 2 Soft Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline void toggle_HPLR_AT2_SL() volatile
    {
        HPLR ^= 1u << 25u;
    }

    /**
     * Get HPLR's AT1_SL bit.
     *
     * Active Tamper 1 Soft Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline bool get_HPLR_AT1_SL() volatile
    {
        return HPLR & (1u << 24u);
    }

    /**
     * Set HPLR's AT1_SL bit.
     *
     * Active Tamper 1 Soft Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline void set_HPLR_AT1_SL() volatile
    {
        HPLR |= 1u << 24u;
    }

    /**
     * Clear HPLR's AT1_SL bit.
     *
     * Active Tamper 1 Soft Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline void clear_HPLR_AT1_SL() volatile
    {
        HPLR &= ~(1u << 24u);
    }

    /**
     * Toggle HPLR's AT1_SL bit.
     *
     * Active Tamper 1 Soft Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline void toggle_HPLR_AT1_SL() volatile
    {
        HPLR ^= 1u << 24u;
    }

    /**
     * Get HPLR's HAC_L bit.
     *
     * High Assurance Counter Lock When set, prevents any writes to HPHACIVR,
     * HPHACR, and HAC_EN bit of HPCOMR
     */
    inline bool get_HPLR_HAC_L() volatile
    {
        return HPLR & (1u << 18u);
    }

    /**
     * Set HPLR's HAC_L bit.
     *
     * High Assurance Counter Lock When set, prevents any writes to HPHACIVR,
     * HPHACR, and HAC_EN bit of HPCOMR
     */
    inline void set_HPLR_HAC_L() volatile
    {
        HPLR |= 1u << 18u;
    }

    /**
     * Clear HPLR's HAC_L bit.
     *
     * High Assurance Counter Lock When set, prevents any writes to HPHACIVR,
     * HPHACR, and HAC_EN bit of HPCOMR
     */
    inline void clear_HPLR_HAC_L() volatile
    {
        HPLR &= ~(1u << 18u);
    }

    /**
     * Toggle HPLR's HAC_L bit.
     *
     * High Assurance Counter Lock When set, prevents any writes to HPHACIVR,
     * HPHACR, and HAC_EN bit of HPCOMR
     */
    inline void toggle_HPLR_HAC_L() volatile
    {
        HPLR ^= 1u << 18u;
    }

    /**
     * Get HPLR's HPSICR_L bit.
     *
     * HP Security Interrupt Control Register Lock When set, prevents any
     * writes to the HPSICR
     */
    inline bool get_HPLR_HPSICR_L() volatile
    {
        return HPLR & (1u << 17u);
    }

    /**
     * Set HPLR's HPSICR_L bit.
     *
     * HP Security Interrupt Control Register Lock When set, prevents any
     * writes to the HPSICR
     */
    inline void set_HPLR_HPSICR_L() volatile
    {
        HPLR |= 1u << 17u;
    }

    /**
     * Clear HPLR's HPSICR_L bit.
     *
     * HP Security Interrupt Control Register Lock When set, prevents any
     * writes to the HPSICR
     */
    inline void clear_HPLR_HPSICR_L() volatile
    {
        HPLR &= ~(1u << 17u);
    }

    /**
     * Toggle HPLR's HPSICR_L bit.
     *
     * HP Security Interrupt Control Register Lock When set, prevents any
     * writes to the HPSICR
     */
    inline void toggle_HPLR_HPSICR_L() volatile
    {
        HPLR ^= 1u << 17u;
    }

    /**
     * Get HPLR's HPSVCR_L bit.
     *
     * HP Security Violation Control Register Lock When set, prevents any
     * writes to the HPSVCR
     */
    inline bool get_HPLR_HPSVCR_L() volatile
    {
        return HPLR & (1u << 16u);
    }

    /**
     * Set HPLR's HPSVCR_L bit.
     *
     * HP Security Violation Control Register Lock When set, prevents any
     * writes to the HPSVCR
     */
    inline void set_HPLR_HPSVCR_L() volatile
    {
        HPLR |= 1u << 16u;
    }

    /**
     * Clear HPLR's HPSVCR_L bit.
     *
     * HP Security Violation Control Register Lock When set, prevents any
     * writes to the HPSVCR
     */
    inline void clear_HPLR_HPSVCR_L() volatile
    {
        HPLR &= ~(1u << 16u);
    }

    /**
     * Toggle HPLR's HPSVCR_L bit.
     *
     * HP Security Violation Control Register Lock When set, prevents any
     * writes to the HPSVCR
     */
    inline void toggle_HPLR_HPSVCR_L() volatile
    {
        HPLR ^= 1u << 16u;
    }

    /**
     * Get HPLR's MKS_SL bit.
     *
     * Master Key Select Soft Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LPMKCR
     */
    inline bool get_HPLR_MKS_SL() volatile
    {
        return HPLR & (1u << 9u);
    }

    /**
     * Set HPLR's MKS_SL bit.
     *
     * Master Key Select Soft Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LPMKCR
     */
    inline void set_HPLR_MKS_SL() volatile
    {
        HPLR |= 1u << 9u;
    }

    /**
     * Clear HPLR's MKS_SL bit.
     *
     * Master Key Select Soft Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LPMKCR
     */
    inline void clear_HPLR_MKS_SL() volatile
    {
        HPLR &= ~(1u << 9u);
    }

    /**
     * Toggle HPLR's MKS_SL bit.
     *
     * Master Key Select Soft Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LPMKCR
     */
    inline void toggle_HPLR_MKS_SL() volatile
    {
        HPLR ^= 1u << 9u;
    }

    /**
     * Get HPLR's LPSECR_SL bit.
     *
     * LP Security Events Configuration Register Soft Lock When set, prevents
     * any writes to the LPSECR
     */
    inline bool get_HPLR_LPSECR_SL() volatile
    {
        return HPLR & (1u << 8u);
    }

    /**
     * Set HPLR's LPSECR_SL bit.
     *
     * LP Security Events Configuration Register Soft Lock When set, prevents
     * any writes to the LPSECR
     */
    inline void set_HPLR_LPSECR_SL() volatile
    {
        HPLR |= 1u << 8u;
    }

    /**
     * Clear HPLR's LPSECR_SL bit.
     *
     * LP Security Events Configuration Register Soft Lock When set, prevents
     * any writes to the LPSECR
     */
    inline void clear_HPLR_LPSECR_SL() volatile
    {
        HPLR &= ~(1u << 8u);
    }

    /**
     * Toggle HPLR's LPSECR_SL bit.
     *
     * LP Security Events Configuration Register Soft Lock When set, prevents
     * any writes to the LPSECR
     */
    inline void toggle_HPLR_LPSECR_SL() volatile
    {
        HPLR ^= 1u << 8u;
    }

    /**
     * Get HPLR's LPTGFCR_SL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Soft Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline bool get_HPLR_LPTGFCR_SL() volatile
    {
        return HPLR & (1u << 7u);
    }

    /**
     * Set HPLR's LPTGFCR_SL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Soft Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline void set_HPLR_LPTGFCR_SL() volatile
    {
        HPLR |= 1u << 7u;
    }

    /**
     * Clear HPLR's LPTGFCR_SL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Soft Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline void clear_HPLR_LPTGFCR_SL() volatile
    {
        HPLR &= ~(1u << 7u);
    }

    /**
     * Toggle HPLR's LPTGFCR_SL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Soft Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline void toggle_HPLR_LPTGFCR_SL() volatile
    {
        HPLR ^= 1u << 7u;
    }

    /**
     * Get HPLR's LPSVCR_SL bit.
     *
     * LP Security Violation Control Register Soft Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline bool get_HPLR_LPSVCR_SL() volatile
    {
        return HPLR & (1u << 6u);
    }

    /**
     * Set HPLR's LPSVCR_SL bit.
     *
     * LP Security Violation Control Register Soft Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline void set_HPLR_LPSVCR_SL() volatile
    {
        HPLR |= 1u << 6u;
    }

    /**
     * Clear HPLR's LPSVCR_SL bit.
     *
     * LP Security Violation Control Register Soft Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline void clear_HPLR_LPSVCR_SL() volatile
    {
        HPLR &= ~(1u << 6u);
    }

    /**
     * Toggle HPLR's LPSVCR_SL bit.
     *
     * LP Security Violation Control Register Soft Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline void toggle_HPLR_LPSVCR_SL() volatile
    {
        HPLR ^= 1u << 6u;
    }

    /**
     * Get HPLR's GPR_SL bit.
     *
     * General Purpose Register Soft Lock When set, prevents any writes to the
     * GPR
     */
    inline bool get_HPLR_GPR_SL() volatile
    {
        return HPLR & (1u << 5u);
    }

    /**
     * Set HPLR's GPR_SL bit.
     *
     * General Purpose Register Soft Lock When set, prevents any writes to the
     * GPR
     */
    inline void set_HPLR_GPR_SL() volatile
    {
        HPLR |= 1u << 5u;
    }

    /**
     * Clear HPLR's GPR_SL bit.
     *
     * General Purpose Register Soft Lock When set, prevents any writes to the
     * GPR
     */
    inline void clear_HPLR_GPR_SL() volatile
    {
        HPLR &= ~(1u << 5u);
    }

    /**
     * Toggle HPLR's GPR_SL bit.
     *
     * General Purpose Register Soft Lock When set, prevents any writes to the
     * GPR
     */
    inline void toggle_HPLR_GPR_SL() volatile
    {
        HPLR ^= 1u << 5u;
    }

    /**
     * Get HPLR's MC_SL bit.
     *
     * Monotonic Counter Soft Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline bool get_HPLR_MC_SL() volatile
    {
        return HPLR & (1u << 4u);
    }

    /**
     * Set HPLR's MC_SL bit.
     *
     * Monotonic Counter Soft Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline void set_HPLR_MC_SL() volatile
    {
        HPLR |= 1u << 4u;
    }

    /**
     * Clear HPLR's MC_SL bit.
     *
     * Monotonic Counter Soft Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline void clear_HPLR_MC_SL() volatile
    {
        HPLR &= ~(1u << 4u);
    }

    /**
     * Toggle HPLR's MC_SL bit.
     *
     * Monotonic Counter Soft Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline void toggle_HPLR_MC_SL() volatile
    {
        HPLR ^= 1u << 4u;
    }

    /**
     * Get HPLR's LPCALB_SL bit.
     *
     * LP Calibration Soft Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline bool get_HPLR_LPCALB_SL() volatile
    {
        return HPLR & (1u << 3u);
    }

    /**
     * Set HPLR's LPCALB_SL bit.
     *
     * LP Calibration Soft Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline void set_HPLR_LPCALB_SL() volatile
    {
        HPLR |= 1u << 3u;
    }

    /**
     * Clear HPLR's LPCALB_SL bit.
     *
     * LP Calibration Soft Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline void clear_HPLR_LPCALB_SL() volatile
    {
        HPLR &= ~(1u << 3u);
    }

    /**
     * Toggle HPLR's LPCALB_SL bit.
     *
     * LP Calibration Soft Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline void toggle_HPLR_LPCALB_SL() volatile
    {
        HPLR ^= 1u << 3u;
    }

    /**
     * Get HPLR's SRTC_SL bit.
     *
     * Secure Real Time Counter Soft Lock When set, prevents any writes to the
     * SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline bool get_HPLR_SRTC_SL() volatile
    {
        return HPLR & (1u << 2u);
    }

    /**
     * Set HPLR's SRTC_SL bit.
     *
     * Secure Real Time Counter Soft Lock When set, prevents any writes to the
     * SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline void set_HPLR_SRTC_SL() volatile
    {
        HPLR |= 1u << 2u;
    }

    /**
     * Clear HPLR's SRTC_SL bit.
     *
     * Secure Real Time Counter Soft Lock When set, prevents any writes to the
     * SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline void clear_HPLR_SRTC_SL() volatile
    {
        HPLR &= ~(1u << 2u);
    }

    /**
     * Toggle HPLR's SRTC_SL bit.
     *
     * Secure Real Time Counter Soft Lock When set, prevents any writes to the
     * SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline void toggle_HPLR_SRTC_SL() volatile
    {
        HPLR ^= 1u << 2u;
    }

    /**
     * Get HPLR's ZMK_RSL bit.
     *
     * Zeroizable Master Key Read Soft Lock When set, prevents any software
     * reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline bool get_HPLR_ZMK_RSL() volatile
    {
        return HPLR & (1u << 1u);
    }

    /**
     * Set HPLR's ZMK_RSL bit.
     *
     * Zeroizable Master Key Read Soft Lock When set, prevents any software
     * reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline void set_HPLR_ZMK_RSL() volatile
    {
        HPLR |= 1u << 1u;
    }

    /**
     * Clear HPLR's ZMK_RSL bit.
     *
     * Zeroizable Master Key Read Soft Lock When set, prevents any software
     * reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline void clear_HPLR_ZMK_RSL() volatile
    {
        HPLR &= ~(1u << 1u);
    }

    /**
     * Toggle HPLR's ZMK_RSL bit.
     *
     * Zeroizable Master Key Read Soft Lock When set, prevents any software
     * reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline void toggle_HPLR_ZMK_RSL() volatile
    {
        HPLR ^= 1u << 1u;
    }

    /**
     * Get HPLR's ZMK_WSL bit.
     *
     * Zeroizable Master Key Write Soft Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL,
     * and ZMK_ECC_EN fields of the LPMKCR
     */
    inline bool get_HPLR_ZMK_WSL() volatile
    {
        return HPLR & (1u << 0u);
    }

    /**
     * Set HPLR's ZMK_WSL bit.
     *
     * Zeroizable Master Key Write Soft Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL,
     * and ZMK_ECC_EN fields of the LPMKCR
     */
    inline void set_HPLR_ZMK_WSL() volatile
    {
        HPLR |= 1u << 0u;
    }

    /**
     * Clear HPLR's ZMK_WSL bit.
     *
     * Zeroizable Master Key Write Soft Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL,
     * and ZMK_ECC_EN fields of the LPMKCR
     */
    inline void clear_HPLR_ZMK_WSL() volatile
    {
        HPLR &= ~(1u << 0u);
    }

    /**
     * Toggle HPLR's ZMK_WSL bit.
     *
     * Zeroizable Master Key Write Soft Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and the ZMK_HWP, ZMK_VAL,
     * and ZMK_ECC_EN fields of the LPMKCR
     */
    inline void toggle_HPLR_ZMK_WSL() volatile
    {
        HPLR ^= 1u << 0u;
    }

    /**
     * Get all of HPLR's bit fields.
     *
     * (read-write) SNVS_HP Lock Register
     */
    inline void get_HPLR(bool &AT5_SL, bool &AT4_SL, bool &AT3_SL,
                         bool &AT2_SL, bool &AT1_SL, bool &HAC_L,
                         bool &HPSICR_L, bool &HPSVCR_L, bool &MKS_SL,
                         bool &LPSECR_SL, bool &LPTGFCR_SL, bool &LPSVCR_SL,
                         bool &GPR_SL, bool &MC_SL, bool &LPCALB_SL,
                         bool &SRTC_SL, bool &ZMK_RSL, bool &ZMK_WSL) volatile
    {
        uint32_t curr = HPLR;

        AT5_SL = curr & (1u << 28u);
        AT4_SL = curr & (1u << 27u);
        AT3_SL = curr & (1u << 26u);
        AT2_SL = curr & (1u << 25u);
        AT1_SL = curr & (1u << 24u);
        HAC_L = curr & (1u << 18u);
        HPSICR_L = curr & (1u << 17u);
        HPSVCR_L = curr & (1u << 16u);
        MKS_SL = curr & (1u << 9u);
        LPSECR_SL = curr & (1u << 8u);
        LPTGFCR_SL = curr & (1u << 7u);
        LPSVCR_SL = curr & (1u << 6u);
        GPR_SL = curr & (1u << 5u);
        MC_SL = curr & (1u << 4u);
        LPCALB_SL = curr & (1u << 3u);
        SRTC_SL = curr & (1u << 2u);
        ZMK_RSL = curr & (1u << 1u);
        ZMK_WSL = curr & (1u << 0u);
    }

    /**
     * Set all of HPLR's bit fields.
     *
     * (read-write) SNVS_HP Lock Register
     */
    inline void set_HPLR(bool AT5_SL, bool AT4_SL, bool AT3_SL, bool AT2_SL,
                         bool AT1_SL, bool HAC_L, bool HPSICR_L, bool HPSVCR_L,
                         bool MKS_SL, bool LPSECR_SL, bool LPTGFCR_SL,
                         bool LPSVCR_SL, bool GPR_SL, bool MC_SL,
                         bool LPCALB_SL, bool SRTC_SL, bool ZMK_RSL,
                         bool ZMK_WSL) volatile
    {
        uint32_t curr = HPLR;

        curr &= ~(0b1u << 28u);
        curr |= (AT5_SL & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (AT4_SL & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (AT3_SL & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (AT2_SL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (AT1_SL & 0b1u) << 24u;
        curr &= ~(0b1u << 18u);
        curr |= (HAC_L & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (HPSICR_L & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (HPSVCR_L & 0b1u) << 16u;
        curr &= ~(0b1u << 9u);
        curr |= (MKS_SL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (LPSECR_SL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LPTGFCR_SL & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (LPSVCR_SL & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (GPR_SL & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MC_SL & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LPCALB_SL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SRTC_SL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ZMK_RSL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ZMK_WSL & 0b1u) << 0u;

        HPLR = curr;
    }

    /**
     * Get HPCOMR's NPSWA_EN bit.
     *
     * Non-Privileged Software Access Enable When set, allows non-privileged
     * software to access all SNVS registers, including those that are
     * privileged software read/write access only
     */
    inline bool get_HPCOMR_NPSWA_EN() volatile
    {
        return HPCOMR & (1u << 31u);
    }

    /**
     * Set HPCOMR's NPSWA_EN bit.
     *
     * Non-Privileged Software Access Enable When set, allows non-privileged
     * software to access all SNVS registers, including those that are
     * privileged software read/write access only
     */
    inline void set_HPCOMR_NPSWA_EN() volatile
    {
        HPCOMR |= 1u << 31u;
    }

    /**
     * Clear HPCOMR's NPSWA_EN bit.
     *
     * Non-Privileged Software Access Enable When set, allows non-privileged
     * software to access all SNVS registers, including those that are
     * privileged software read/write access only
     */
    inline void clear_HPCOMR_NPSWA_EN() volatile
    {
        HPCOMR &= ~(1u << 31u);
    }

    /**
     * Toggle HPCOMR's NPSWA_EN bit.
     *
     * Non-Privileged Software Access Enable When set, allows non-privileged
     * software to access all SNVS registers, including those that are
     * privileged software read/write access only
     */
    inline void toggle_HPCOMR_NPSWA_EN() volatile
    {
        HPCOMR ^= 1u << 31u;
    }

    /**
     * Get HPCOMR's HAC_STOP bit.
     *
     * High Assurance Counter Stop This bit can be set only when SSM is in soft
     * fail state
     */
    inline bool get_HPCOMR_HAC_STOP() volatile
    {
        return HPCOMR & (1u << 19u);
    }

    /**
     * Set HPCOMR's HAC_STOP bit.
     *
     * High Assurance Counter Stop This bit can be set only when SSM is in soft
     * fail state
     */
    inline void set_HPCOMR_HAC_STOP() volatile
    {
        HPCOMR |= 1u << 19u;
    }

    /**
     * Clear HPCOMR's HAC_STOP bit.
     *
     * High Assurance Counter Stop This bit can be set only when SSM is in soft
     * fail state
     */
    inline void clear_HPCOMR_HAC_STOP() volatile
    {
        HPCOMR &= ~(1u << 19u);
    }

    /**
     * Toggle HPCOMR's HAC_STOP bit.
     *
     * High Assurance Counter Stop This bit can be set only when SSM is in soft
     * fail state
     */
    inline void toggle_HPCOMR_HAC_STOP() volatile
    {
        HPCOMR ^= 1u << 19u;
    }

    /**
     * Set HPCOMR's HAC_CLEAR bit.
     *
     * High Assurance Counter Clear When set, it clears the High Assurance
     * Counter Register
     */
    inline void set_HPCOMR_HAC_CLEAR() volatile
    {
        HPCOMR |= 1u << 18u;
    }

    /**
     * Clear HPCOMR's HAC_CLEAR bit.
     *
     * High Assurance Counter Clear When set, it clears the High Assurance
     * Counter Register
     */
    inline void clear_HPCOMR_HAC_CLEAR() volatile
    {
        HPCOMR &= ~(1u << 18u);
    }

    /**
     * Toggle HPCOMR's HAC_CLEAR bit.
     *
     * High Assurance Counter Clear When set, it clears the High Assurance
     * Counter Register
     */
    inline void toggle_HPCOMR_HAC_CLEAR() volatile
    {
        HPCOMR ^= 1u << 18u;
    }

    /**
     * Set HPCOMR's HAC_LOAD bit.
     *
     * High Assurance Counter Load When set, it loads the High Assurance
     * Counter Register with the value of the High Assurance Counter Load
     * Register
     */
    inline void set_HPCOMR_HAC_LOAD() volatile
    {
        HPCOMR |= 1u << 17u;
    }

    /**
     * Clear HPCOMR's HAC_LOAD bit.
     *
     * High Assurance Counter Load When set, it loads the High Assurance
     * Counter Register with the value of the High Assurance Counter Load
     * Register
     */
    inline void clear_HPCOMR_HAC_LOAD() volatile
    {
        HPCOMR &= ~(1u << 17u);
    }

    /**
     * Toggle HPCOMR's HAC_LOAD bit.
     *
     * High Assurance Counter Load When set, it loads the High Assurance
     * Counter Register with the value of the High Assurance Counter Load
     * Register
     */
    inline void toggle_HPCOMR_HAC_LOAD() volatile
    {
        HPCOMR ^= 1u << 17u;
    }

    /**
     * Get HPCOMR's HAC_EN bit.
     *
     * High Assurance Counter Enable This bit controls the SSM transition from
     * the soft fail to the hard fail state
     */
    inline bool get_HPCOMR_HAC_EN() volatile
    {
        return HPCOMR & (1u << 16u);
    }

    /**
     * Set HPCOMR's HAC_EN bit.
     *
     * High Assurance Counter Enable This bit controls the SSM transition from
     * the soft fail to the hard fail state
     */
    inline void set_HPCOMR_HAC_EN() volatile
    {
        HPCOMR |= 1u << 16u;
    }

    /**
     * Clear HPCOMR's HAC_EN bit.
     *
     * High Assurance Counter Enable This bit controls the SSM transition from
     * the soft fail to the hard fail state
     */
    inline void clear_HPCOMR_HAC_EN() volatile
    {
        HPCOMR &= ~(1u << 16u);
    }

    /**
     * Toggle HPCOMR's HAC_EN bit.
     *
     * High Assurance Counter Enable This bit controls the SSM transition from
     * the soft fail to the hard fail state
     */
    inline void toggle_HPCOMR_HAC_EN() volatile
    {
        HPCOMR ^= 1u << 16u;
    }

    /**
     * Get HPCOMR's MKS_EN bit.
     *
     * Master Key Select Enable When not set, the one time programmable (OTP)
     * master key is selected by default
     */
    inline bool get_HPCOMR_MKS_EN() volatile
    {
        return HPCOMR & (1u << 13u);
    }

    /**
     * Set HPCOMR's MKS_EN bit.
     *
     * Master Key Select Enable When not set, the one time programmable (OTP)
     * master key is selected by default
     */
    inline void set_HPCOMR_MKS_EN() volatile
    {
        HPCOMR |= 1u << 13u;
    }

    /**
     * Clear HPCOMR's MKS_EN bit.
     *
     * Master Key Select Enable When not set, the one time programmable (OTP)
     * master key is selected by default
     */
    inline void clear_HPCOMR_MKS_EN() volatile
    {
        HPCOMR &= ~(1u << 13u);
    }

    /**
     * Toggle HPCOMR's MKS_EN bit.
     *
     * Master Key Select Enable When not set, the one time programmable (OTP)
     * master key is selected by default
     */
    inline void toggle_HPCOMR_MKS_EN() volatile
    {
        HPCOMR ^= 1u << 13u;
    }

    /**
     * Set HPCOMR's PROG_ZMK bit.
     *
     * Program Zeroizable Master Key This bit activates ZMK hardware
     * programming mechanism
     */
    inline void set_HPCOMR_PROG_ZMK() volatile
    {
        HPCOMR |= 1u << 12u;
    }

    /**
     * Clear HPCOMR's PROG_ZMK bit.
     *
     * Program Zeroizable Master Key This bit activates ZMK hardware
     * programming mechanism
     */
    inline void clear_HPCOMR_PROG_ZMK() volatile
    {
        HPCOMR &= ~(1u << 12u);
    }

    /**
     * Toggle HPCOMR's PROG_ZMK bit.
     *
     * Program Zeroizable Master Key This bit activates ZMK hardware
     * programming mechanism
     */
    inline void toggle_HPCOMR_PROG_ZMK() volatile
    {
        HPCOMR ^= 1u << 12u;
    }

    /**
     * Get HPCOMR's SW_LPSV bit.
     *
     * LP Software Security Violation When set, SNVS_LP treats this bit as a
     * security violation
     */
    inline bool get_HPCOMR_SW_LPSV() volatile
    {
        return HPCOMR & (1u << 10u);
    }

    /**
     * Set HPCOMR's SW_LPSV bit.
     *
     * LP Software Security Violation When set, SNVS_LP treats this bit as a
     * security violation
     */
    inline void set_HPCOMR_SW_LPSV() volatile
    {
        HPCOMR |= 1u << 10u;
    }

    /**
     * Clear HPCOMR's SW_LPSV bit.
     *
     * LP Software Security Violation When set, SNVS_LP treats this bit as a
     * security violation
     */
    inline void clear_HPCOMR_SW_LPSV() volatile
    {
        HPCOMR &= ~(1u << 10u);
    }

    /**
     * Toggle HPCOMR's SW_LPSV bit.
     *
     * LP Software Security Violation When set, SNVS_LP treats this bit as a
     * security violation
     */
    inline void toggle_HPCOMR_SW_LPSV() volatile
    {
        HPCOMR ^= 1u << 10u;
    }

    /**
     * Get HPCOMR's SW_FSV bit.
     *
     * Software Fatal Security Violation When set, the system security monitor
     * treats this bit as a fatal security violation
     */
    inline bool get_HPCOMR_SW_FSV() volatile
    {
        return HPCOMR & (1u << 9u);
    }

    /**
     * Set HPCOMR's SW_FSV bit.
     *
     * Software Fatal Security Violation When set, the system security monitor
     * treats this bit as a fatal security violation
     */
    inline void set_HPCOMR_SW_FSV() volatile
    {
        HPCOMR |= 1u << 9u;
    }

    /**
     * Clear HPCOMR's SW_FSV bit.
     *
     * Software Fatal Security Violation When set, the system security monitor
     * treats this bit as a fatal security violation
     */
    inline void clear_HPCOMR_SW_FSV() volatile
    {
        HPCOMR &= ~(1u << 9u);
    }

    /**
     * Toggle HPCOMR's SW_FSV bit.
     *
     * Software Fatal Security Violation When set, the system security monitor
     * treats this bit as a fatal security violation
     */
    inline void toggle_HPCOMR_SW_FSV() volatile
    {
        HPCOMR ^= 1u << 9u;
    }

    /**
     * Get HPCOMR's SW_SV bit.
     *
     * Software Security Violation When set, the system security monitor treats
     * this bit as a non-fatal security violation
     */
    inline bool get_HPCOMR_SW_SV() volatile
    {
        return HPCOMR & (1u << 8u);
    }

    /**
     * Set HPCOMR's SW_SV bit.
     *
     * Software Security Violation When set, the system security monitor treats
     * this bit as a non-fatal security violation
     */
    inline void set_HPCOMR_SW_SV() volatile
    {
        HPCOMR |= 1u << 8u;
    }

    /**
     * Clear HPCOMR's SW_SV bit.
     *
     * Software Security Violation When set, the system security monitor treats
     * this bit as a non-fatal security violation
     */
    inline void clear_HPCOMR_SW_SV() volatile
    {
        HPCOMR &= ~(1u << 8u);
    }

    /**
     * Toggle HPCOMR's SW_SV bit.
     *
     * Software Security Violation When set, the system security monitor treats
     * this bit as a non-fatal security violation
     */
    inline void toggle_HPCOMR_SW_SV() volatile
    {
        HPCOMR ^= 1u << 8u;
    }

    /**
     * Get HPCOMR's LP_SWR_DIS bit.
     *
     * LP Software Reset Disable When set, disables the LP software reset
     */
    inline bool get_HPCOMR_LP_SWR_DIS() volatile
    {
        return HPCOMR & (1u << 5u);
    }

    /**
     * Set HPCOMR's LP_SWR_DIS bit.
     *
     * LP Software Reset Disable When set, disables the LP software reset
     */
    inline void set_HPCOMR_LP_SWR_DIS() volatile
    {
        HPCOMR |= 1u << 5u;
    }

    /**
     * Clear HPCOMR's LP_SWR_DIS bit.
     *
     * LP Software Reset Disable When set, disables the LP software reset
     */
    inline void clear_HPCOMR_LP_SWR_DIS() volatile
    {
        HPCOMR &= ~(1u << 5u);
    }

    /**
     * Toggle HPCOMR's LP_SWR_DIS bit.
     *
     * LP Software Reset Disable When set, disables the LP software reset
     */
    inline void toggle_HPCOMR_LP_SWR_DIS() volatile
    {
        HPCOMR ^= 1u << 5u;
    }

    /**
     * Set HPCOMR's LP_SWR bit.
     *
     * LP Software Reset When set to 1, most registers in the SNVS_LP section
     * are reset, but the following registers are not reset by an LP software
     * reset: Monotonic Counter Secure Real Time Counter Time Alarm Register
     * This bit cannot be set when the LP_SWR_DIS bit is set
     */
    inline void set_HPCOMR_LP_SWR() volatile
    {
        HPCOMR |= 1u << 4u;
    }

    /**
     * Clear HPCOMR's LP_SWR bit.
     *
     * LP Software Reset When set to 1, most registers in the SNVS_LP section
     * are reset, but the following registers are not reset by an LP software
     * reset: Monotonic Counter Secure Real Time Counter Time Alarm Register
     * This bit cannot be set when the LP_SWR_DIS bit is set
     */
    inline void clear_HPCOMR_LP_SWR() volatile
    {
        HPCOMR &= ~(1u << 4u);
    }

    /**
     * Toggle HPCOMR's LP_SWR bit.
     *
     * LP Software Reset When set to 1, most registers in the SNVS_LP section
     * are reset, but the following registers are not reset by an LP software
     * reset: Monotonic Counter Secure Real Time Counter Time Alarm Register
     * This bit cannot be set when the LP_SWR_DIS bit is set
     */
    inline void toggle_HPCOMR_LP_SWR() volatile
    {
        HPCOMR ^= 1u << 4u;
    }

    /**
     * Get HPCOMR's SSM_SFNS_DIS bit.
     *
     * SSM Soft Fail to Non-Secure State Transition Disable When set, it
     * disables the SSM transition from soft fail to non-secure state
     */
    inline bool get_HPCOMR_SSM_SFNS_DIS() volatile
    {
        return HPCOMR & (1u << 2u);
    }

    /**
     * Set HPCOMR's SSM_SFNS_DIS bit.
     *
     * SSM Soft Fail to Non-Secure State Transition Disable When set, it
     * disables the SSM transition from soft fail to non-secure state
     */
    inline void set_HPCOMR_SSM_SFNS_DIS() volatile
    {
        HPCOMR |= 1u << 2u;
    }

    /**
     * Clear HPCOMR's SSM_SFNS_DIS bit.
     *
     * SSM Soft Fail to Non-Secure State Transition Disable When set, it
     * disables the SSM transition from soft fail to non-secure state
     */
    inline void clear_HPCOMR_SSM_SFNS_DIS() volatile
    {
        HPCOMR &= ~(1u << 2u);
    }

    /**
     * Toggle HPCOMR's SSM_SFNS_DIS bit.
     *
     * SSM Soft Fail to Non-Secure State Transition Disable When set, it
     * disables the SSM transition from soft fail to non-secure state
     */
    inline void toggle_HPCOMR_SSM_SFNS_DIS() volatile
    {
        HPCOMR ^= 1u << 2u;
    }

    /**
     * Get HPCOMR's SSM_ST_DIS bit.
     *
     * SSM Secure to Trusted State Transition Disable When set, disables the
     * SSM transition from secure to trusted state
     */
    inline bool get_HPCOMR_SSM_ST_DIS() volatile
    {
        return HPCOMR & (1u << 1u);
    }

    /**
     * Set HPCOMR's SSM_ST_DIS bit.
     *
     * SSM Secure to Trusted State Transition Disable When set, disables the
     * SSM transition from secure to trusted state
     */
    inline void set_HPCOMR_SSM_ST_DIS() volatile
    {
        HPCOMR |= 1u << 1u;
    }

    /**
     * Clear HPCOMR's SSM_ST_DIS bit.
     *
     * SSM Secure to Trusted State Transition Disable When set, disables the
     * SSM transition from secure to trusted state
     */
    inline void clear_HPCOMR_SSM_ST_DIS() volatile
    {
        HPCOMR &= ~(1u << 1u);
    }

    /**
     * Toggle HPCOMR's SSM_ST_DIS bit.
     *
     * SSM Secure to Trusted State Transition Disable When set, disables the
     * SSM transition from secure to trusted state
     */
    inline void toggle_HPCOMR_SSM_ST_DIS() volatile
    {
        HPCOMR ^= 1u << 1u;
    }

    /**
     * Set HPCOMR's SSM_ST bit.
     *
     * SSM State Transition Transition state of the system security monitor
     */
    inline void set_HPCOMR_SSM_ST() volatile
    {
        HPCOMR |= 1u << 0u;
    }

    /**
     * Clear HPCOMR's SSM_ST bit.
     *
     * SSM State Transition Transition state of the system security monitor
     */
    inline void clear_HPCOMR_SSM_ST() volatile
    {
        HPCOMR &= ~(1u << 0u);
    }

    /**
     * Toggle HPCOMR's SSM_ST bit.
     *
     * SSM State Transition Transition state of the system security monitor
     */
    inline void toggle_HPCOMR_SSM_ST() volatile
    {
        HPCOMR ^= 1u << 0u;
    }

    /**
     * Get all of HPCOMR's bit fields.
     *
     * (read-write) SNVS_HP Command Register
     */
    inline void get_HPCOMR(bool &NPSWA_EN, bool &HAC_STOP, bool &HAC_EN,
                           bool &MKS_EN, bool &SW_LPSV, bool &SW_FSV,
                           bool &SW_SV, bool &LP_SWR_DIS, bool &SSM_SFNS_DIS,
                           bool &SSM_ST_DIS) volatile
    {
        uint32_t curr = HPCOMR;

        NPSWA_EN = curr & (1u << 31u);
        HAC_STOP = curr & (1u << 19u);
        HAC_EN = curr & (1u << 16u);
        MKS_EN = curr & (1u << 13u);
        SW_LPSV = curr & (1u << 10u);
        SW_FSV = curr & (1u << 9u);
        SW_SV = curr & (1u << 8u);
        LP_SWR_DIS = curr & (1u << 5u);
        SSM_SFNS_DIS = curr & (1u << 2u);
        SSM_ST_DIS = curr & (1u << 1u);
    }

    /**
     * Set all of HPCOMR's bit fields.
     *
     * (read-write) SNVS_HP Command Register
     */
    inline void set_HPCOMR(bool NPSWA_EN, bool HAC_STOP, bool HAC_CLEAR,
                           bool HAC_LOAD, bool HAC_EN, bool MKS_EN,
                           bool PROG_ZMK, bool SW_LPSV, bool SW_FSV,
                           bool SW_SV, bool LP_SWR_DIS, bool LP_SWR,
                           bool SSM_SFNS_DIS, bool SSM_ST_DIS,
                           bool SSM_ST) volatile
    {
        uint32_t curr = HPCOMR;

        curr &= ~(0b1u << 31u);
        curr |= (NPSWA_EN & 0b1u) << 31u;
        curr &= ~(0b1u << 19u);
        curr |= (HAC_STOP & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (HAC_CLEAR & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (HAC_LOAD & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (HAC_EN & 0b1u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (MKS_EN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (PROG_ZMK & 0b1u) << 12u;
        curr &= ~(0b1u << 10u);
        curr |= (SW_LPSV & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (SW_FSV & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (SW_SV & 0b1u) << 8u;
        curr &= ~(0b1u << 5u);
        curr |= (LP_SWR_DIS & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (LP_SWR & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (SSM_SFNS_DIS & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SSM_ST_DIS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SSM_ST & 0b1u) << 0u;

        HPCOMR = curr;
    }

    /**
     * Get HPCR's BTN_MASK bit.
     *
     * Button interrupt mask
     */
    inline bool get_HPCR_BTN_MASK() volatile
    {
        return HPCR & (1u << 27u);
    }

    /**
     * Set HPCR's BTN_MASK bit.
     *
     * Button interrupt mask
     */
    inline void set_HPCR_BTN_MASK() volatile
    {
        HPCR |= 1u << 27u;
    }

    /**
     * Clear HPCR's BTN_MASK bit.
     *
     * Button interrupt mask
     */
    inline void clear_HPCR_BTN_MASK() volatile
    {
        HPCR &= ~(1u << 27u);
    }

    /**
     * Toggle HPCR's BTN_MASK bit.
     *
     * Button interrupt mask
     */
    inline void toggle_HPCR_BTN_MASK() volatile
    {
        HPCR ^= 1u << 27u;
    }

    /**
     * Get HPCR's BTN_CONFIG field.
     *
     * Button Configuration
     */
    inline uint8_t get_HPCR_BTN_CONFIG() volatile
    {
        return (HPCR >> 24u) & 0b111u;
    }

    /**
     * Set HPCR's BTN_CONFIG field.
     *
     * Button Configuration
     */
    inline void set_HPCR_BTN_CONFIG(uint8_t value) volatile
    {
        uint32_t curr = HPCR;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        HPCR = curr;
    }

    /**
     * Get HPCR's HP_TS bit.
     *
     * HP Time Synchronize
     */
    inline bool get_HPCR_HP_TS() volatile
    {
        return HPCR & (1u << 16u);
    }

    /**
     * Set HPCR's HP_TS bit.
     *
     * HP Time Synchronize
     */
    inline void set_HPCR_HP_TS() volatile
    {
        HPCR |= 1u << 16u;
    }

    /**
     * Clear HPCR's HP_TS bit.
     *
     * HP Time Synchronize
     */
    inline void clear_HPCR_HP_TS() volatile
    {
        HPCR &= ~(1u << 16u);
    }

    /**
     * Toggle HPCR's HP_TS bit.
     *
     * HP Time Synchronize
     */
    inline void toggle_HPCR_HP_TS() volatile
    {
        HPCR ^= 1u << 16u;
    }

    /**
     * Get HPCR's HPCALB_VAL field.
     *
     * HP Calibration Value Defines signed calibration value for the HP Real
     * Time Counter
     */
    inline SNVS_HPCR_HPCALB_VAL get_HPCR_HPCALB_VAL() volatile
    {
        return SNVS_HPCR_HPCALB_VAL((HPCR >> 10u) & 0b11111u);
    }

    /**
     * Set HPCR's HPCALB_VAL field.
     *
     * HP Calibration Value Defines signed calibration value for the HP Real
     * Time Counter
     */
    inline void set_HPCR_HPCALB_VAL(SNVS_HPCR_HPCALB_VAL value) volatile
    {
        uint32_t curr = HPCR;

        curr &= ~(0b11111u << 10u);
        curr |= (std::to_underlying(value) & 0b11111u) << 10u;

        HPCR = curr;
    }

    /**
     * Get HPCR's HPCALB_EN bit.
     *
     * HP Real Time Counter Calibration Enabled Indicates that the time
     * calibration mechanism is enabled.
     */
    inline bool get_HPCR_HPCALB_EN() volatile
    {
        return HPCR & (1u << 8u);
    }

    /**
     * Set HPCR's HPCALB_EN bit.
     *
     * HP Real Time Counter Calibration Enabled Indicates that the time
     * calibration mechanism is enabled.
     */
    inline void set_HPCR_HPCALB_EN() volatile
    {
        HPCR |= 1u << 8u;
    }

    /**
     * Clear HPCR's HPCALB_EN bit.
     *
     * HP Real Time Counter Calibration Enabled Indicates that the time
     * calibration mechanism is enabled.
     */
    inline void clear_HPCR_HPCALB_EN() volatile
    {
        HPCR &= ~(1u << 8u);
    }

    /**
     * Toggle HPCR's HPCALB_EN bit.
     *
     * HP Real Time Counter Calibration Enabled Indicates that the time
     * calibration mechanism is enabled.
     */
    inline void toggle_HPCR_HPCALB_EN() volatile
    {
        HPCR ^= 1u << 8u;
    }

    /**
     * Get HPCR's PI_FREQ field.
     *
     * Periodic Interrupt Frequency Defines frequency of the periodic interrupt
     */
    inline SNVS_HPCR_PI_FREQ get_HPCR_PI_FREQ() volatile
    {
        return SNVS_HPCR_PI_FREQ((HPCR >> 4u) & 0b1111u);
    }

    /**
     * Set HPCR's PI_FREQ field.
     *
     * Periodic Interrupt Frequency Defines frequency of the periodic interrupt
     */
    inline void set_HPCR_PI_FREQ(SNVS_HPCR_PI_FREQ value) volatile
    {
        uint32_t curr = HPCR;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        HPCR = curr;
    }

    /**
     * Get HPCR's PI_EN bit.
     *
     * HP Periodic Interrupt Enable The periodic interrupt can be generated
     * only if the HP Real Time Counter is enabled
     */
    inline bool get_HPCR_PI_EN() volatile
    {
        return HPCR & (1u << 3u);
    }

    /**
     * Set HPCR's PI_EN bit.
     *
     * HP Periodic Interrupt Enable The periodic interrupt can be generated
     * only if the HP Real Time Counter is enabled
     */
    inline void set_HPCR_PI_EN() volatile
    {
        HPCR |= 1u << 3u;
    }

    /**
     * Clear HPCR's PI_EN bit.
     *
     * HP Periodic Interrupt Enable The periodic interrupt can be generated
     * only if the HP Real Time Counter is enabled
     */
    inline void clear_HPCR_PI_EN() volatile
    {
        HPCR &= ~(1u << 3u);
    }

    /**
     * Toggle HPCR's PI_EN bit.
     *
     * HP Periodic Interrupt Enable The periodic interrupt can be generated
     * only if the HP Real Time Counter is enabled
     */
    inline void toggle_HPCR_PI_EN() volatile
    {
        HPCR ^= 1u << 3u;
    }

    /**
     * Get HPCR's DIS_PI bit.
     *
     * Disable periodic interrupt in the functional interrupt
     */
    inline bool get_HPCR_DIS_PI() volatile
    {
        return HPCR & (1u << 2u);
    }

    /**
     * Set HPCR's DIS_PI bit.
     *
     * Disable periodic interrupt in the functional interrupt
     */
    inline void set_HPCR_DIS_PI() volatile
    {
        HPCR |= 1u << 2u;
    }

    /**
     * Clear HPCR's DIS_PI bit.
     *
     * Disable periodic interrupt in the functional interrupt
     */
    inline void clear_HPCR_DIS_PI() volatile
    {
        HPCR &= ~(1u << 2u);
    }

    /**
     * Toggle HPCR's DIS_PI bit.
     *
     * Disable periodic interrupt in the functional interrupt
     */
    inline void toggle_HPCR_DIS_PI() volatile
    {
        HPCR ^= 1u << 2u;
    }

    /**
     * Get HPCR's HPTA_EN bit.
     *
     * HP Time Alarm Enable When set, the time alarm interrupt is generated if
     * the value in the HP Time Alarm Registers is equal to the value of the HP
     * Real Time Counter
     */
    inline bool get_HPCR_HPTA_EN() volatile
    {
        return HPCR & (1u << 1u);
    }

    /**
     * Set HPCR's HPTA_EN bit.
     *
     * HP Time Alarm Enable When set, the time alarm interrupt is generated if
     * the value in the HP Time Alarm Registers is equal to the value of the HP
     * Real Time Counter
     */
    inline void set_HPCR_HPTA_EN() volatile
    {
        HPCR |= 1u << 1u;
    }

    /**
     * Clear HPCR's HPTA_EN bit.
     *
     * HP Time Alarm Enable When set, the time alarm interrupt is generated if
     * the value in the HP Time Alarm Registers is equal to the value of the HP
     * Real Time Counter
     */
    inline void clear_HPCR_HPTA_EN() volatile
    {
        HPCR &= ~(1u << 1u);
    }

    /**
     * Toggle HPCR's HPTA_EN bit.
     *
     * HP Time Alarm Enable When set, the time alarm interrupt is generated if
     * the value in the HP Time Alarm Registers is equal to the value of the HP
     * Real Time Counter
     */
    inline void toggle_HPCR_HPTA_EN() volatile
    {
        HPCR ^= 1u << 1u;
    }

    /**
     * Get HPCR's RTC_EN bit.
     *
     * HP Real Time Counter Enable
     */
    inline bool get_HPCR_RTC_EN() volatile
    {
        return HPCR & (1u << 0u);
    }

    /**
     * Set HPCR's RTC_EN bit.
     *
     * HP Real Time Counter Enable
     */
    inline void set_HPCR_RTC_EN() volatile
    {
        HPCR |= 1u << 0u;
    }

    /**
     * Clear HPCR's RTC_EN bit.
     *
     * HP Real Time Counter Enable
     */
    inline void clear_HPCR_RTC_EN() volatile
    {
        HPCR &= ~(1u << 0u);
    }

    /**
     * Toggle HPCR's RTC_EN bit.
     *
     * HP Real Time Counter Enable
     */
    inline void toggle_HPCR_RTC_EN() volatile
    {
        HPCR ^= 1u << 0u;
    }

    /**
     * Get all of HPCR's bit fields.
     *
     * (read-write) SNVS_HP Control Register
     */
    inline void get_HPCR(bool &BTN_MASK, uint8_t &BTN_CONFIG, bool &HP_TS,
                         SNVS_HPCR_HPCALB_VAL &HPCALB_VAL, bool &HPCALB_EN,
                         SNVS_HPCR_PI_FREQ &PI_FREQ, bool &PI_EN, bool &DIS_PI,
                         bool &HPTA_EN, bool &RTC_EN) volatile
    {
        uint32_t curr = HPCR;

        BTN_MASK = curr & (1u << 27u);
        BTN_CONFIG = (curr >> 24u) & 0b111u;
        HP_TS = curr & (1u << 16u);
        HPCALB_VAL = SNVS_HPCR_HPCALB_VAL((curr >> 10u) & 0b11111u);
        HPCALB_EN = curr & (1u << 8u);
        PI_FREQ = SNVS_HPCR_PI_FREQ((curr >> 4u) & 0b1111u);
        PI_EN = curr & (1u << 3u);
        DIS_PI = curr & (1u << 2u);
        HPTA_EN = curr & (1u << 1u);
        RTC_EN = curr & (1u << 0u);
    }

    /**
     * Set all of HPCR's bit fields.
     *
     * (read-write) SNVS_HP Control Register
     */
    inline void set_HPCR(bool BTN_MASK, uint8_t BTN_CONFIG, bool HP_TS,
                         SNVS_HPCR_HPCALB_VAL HPCALB_VAL, bool HPCALB_EN,
                         SNVS_HPCR_PI_FREQ PI_FREQ, bool PI_EN, bool DIS_PI,
                         bool HPTA_EN, bool RTC_EN) volatile
    {
        uint32_t curr = HPCR;

        curr &= ~(0b1u << 27u);
        curr |= (BTN_MASK & 0b1u) << 27u;
        curr &= ~(0b111u << 24u);
        curr |= (BTN_CONFIG & 0b111u) << 24u;
        curr &= ~(0b1u << 16u);
        curr |= (HP_TS & 0b1u) << 16u;
        curr &= ~(0b11111u << 10u);
        curr |= (std::to_underlying(HPCALB_VAL) & 0b11111u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (HPCALB_EN & 0b1u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(PI_FREQ) & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PI_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DIS_PI & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (HPTA_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RTC_EN & 0b1u) << 0u;

        HPCR = curr;
    }

    /**
     * Get HPSICR's LPSVI_EN bit.
     *
     * LP Security Violation Interrupt Enable This bit enables generating of
     * the security interrupt to the host processor upon security violation
     * signal from the LP section
     */
    inline bool get_HPSICR_LPSVI_EN() volatile
    {
        return HPSICR & (1u << 31u);
    }

    /**
     * Set HPSICR's LPSVI_EN bit.
     *
     * LP Security Violation Interrupt Enable This bit enables generating of
     * the security interrupt to the host processor upon security violation
     * signal from the LP section
     */
    inline void set_HPSICR_LPSVI_EN() volatile
    {
        HPSICR |= 1u << 31u;
    }

    /**
     * Clear HPSICR's LPSVI_EN bit.
     *
     * LP Security Violation Interrupt Enable This bit enables generating of
     * the security interrupt to the host processor upon security violation
     * signal from the LP section
     */
    inline void clear_HPSICR_LPSVI_EN() volatile
    {
        HPSICR &= ~(1u << 31u);
    }

    /**
     * Toggle HPSICR's LPSVI_EN bit.
     *
     * LP Security Violation Interrupt Enable This bit enables generating of
     * the security interrupt to the host processor upon security violation
     * signal from the LP section
     */
    inline void toggle_HPSICR_LPSVI_EN() volatile
    {
        HPSICR ^= 1u << 31u;
    }

    /**
     * Get HPSICR's OCOTP_EN bit.
     *
     * OCOTP attack error Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the OCOTP attack error security violation
     */
    inline bool get_HPSICR_OCOTP_EN() volatile
    {
        return HPSICR & (1u << 5u);
    }

    /**
     * Set HPSICR's OCOTP_EN bit.
     *
     * OCOTP attack error Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the OCOTP attack error security violation
     */
    inline void set_HPSICR_OCOTP_EN() volatile
    {
        HPSICR |= 1u << 5u;
    }

    /**
     * Clear HPSICR's OCOTP_EN bit.
     *
     * OCOTP attack error Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the OCOTP attack error security violation
     */
    inline void clear_HPSICR_OCOTP_EN() volatile
    {
        HPSICR &= ~(1u << 5u);
    }

    /**
     * Toggle HPSICR's OCOTP_EN bit.
     *
     * OCOTP attack error Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the OCOTP attack error security violation
     */
    inline void toggle_HPSICR_OCOTP_EN() volatile
    {
        HPSICR ^= 1u << 5u;
    }

    /**
     * Get HPSICR's SRC_EN bit.
     *
     * Internal Boot Interrupt Enable Setting this bit to 1 enables generation
     * of the security interrupt to the host processor upon detection of the
     * Internal Boot security violation
     */
    inline bool get_HPSICR_SRC_EN() volatile
    {
        return HPSICR & (1u << 4u);
    }

    /**
     * Set HPSICR's SRC_EN bit.
     *
     * Internal Boot Interrupt Enable Setting this bit to 1 enables generation
     * of the security interrupt to the host processor upon detection of the
     * Internal Boot security violation
     */
    inline void set_HPSICR_SRC_EN() volatile
    {
        HPSICR |= 1u << 4u;
    }

    /**
     * Clear HPSICR's SRC_EN bit.
     *
     * Internal Boot Interrupt Enable Setting this bit to 1 enables generation
     * of the security interrupt to the host processor upon detection of the
     * Internal Boot security violation
     */
    inline void clear_HPSICR_SRC_EN() volatile
    {
        HPSICR &= ~(1u << 4u);
    }

    /**
     * Toggle HPSICR's SRC_EN bit.
     *
     * Internal Boot Interrupt Enable Setting this bit to 1 enables generation
     * of the security interrupt to the host processor upon detection of the
     * Internal Boot security violation
     */
    inline void toggle_HPSICR_SRC_EN() volatile
    {
        HPSICR ^= 1u << 4u;
    }

    /**
     * Get HPSICR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the Watchdog 2 Reset security violation
     */
    inline bool get_HPSICR_WDOG2_EN() volatile
    {
        return HPSICR & (1u << 2u);
    }

    /**
     * Set HPSICR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the Watchdog 2 Reset security violation
     */
    inline void set_HPSICR_WDOG2_EN() volatile
    {
        HPSICR |= 1u << 2u;
    }

    /**
     * Clear HPSICR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the Watchdog 2 Reset security violation
     */
    inline void clear_HPSICR_WDOG2_EN() volatile
    {
        HPSICR &= ~(1u << 2u);
    }

    /**
     * Toggle HPSICR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the Watchdog 2 Reset security violation
     */
    inline void toggle_HPSICR_WDOG2_EN() volatile
    {
        HPSICR ^= 1u << 2u;
    }

    /**
     * Get HPSICR's JTAGC_EN bit.
     *
     * JTAG Active Interrupt Enable Setting this bit to 1 enables generation of
     * the security interrupt to the host processor upon detection of the JTAG
     * Active security violation
     */
    inline bool get_HPSICR_JTAGC_EN() volatile
    {
        return HPSICR & (1u << 1u);
    }

    /**
     * Set HPSICR's JTAGC_EN bit.
     *
     * JTAG Active Interrupt Enable Setting this bit to 1 enables generation of
     * the security interrupt to the host processor upon detection of the JTAG
     * Active security violation
     */
    inline void set_HPSICR_JTAGC_EN() volatile
    {
        HPSICR |= 1u << 1u;
    }

    /**
     * Clear HPSICR's JTAGC_EN bit.
     *
     * JTAG Active Interrupt Enable Setting this bit to 1 enables generation of
     * the security interrupt to the host processor upon detection of the JTAG
     * Active security violation
     */
    inline void clear_HPSICR_JTAGC_EN() volatile
    {
        HPSICR &= ~(1u << 1u);
    }

    /**
     * Toggle HPSICR's JTAGC_EN bit.
     *
     * JTAG Active Interrupt Enable Setting this bit to 1 enables generation of
     * the security interrupt to the host processor upon detection of the JTAG
     * Active security violation
     */
    inline void toggle_HPSICR_JTAGC_EN() volatile
    {
        HPSICR ^= 1u << 1u;
    }

    /**
     * Get HPSICR's CAAM_EN bit.
     *
     * CAAM Security Violation Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the CAAM Security Violation security violation
     */
    inline bool get_HPSICR_CAAM_EN() volatile
    {
        return HPSICR & (1u << 0u);
    }

    /**
     * Set HPSICR's CAAM_EN bit.
     *
     * CAAM Security Violation Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the CAAM Security Violation security violation
     */
    inline void set_HPSICR_CAAM_EN() volatile
    {
        HPSICR |= 1u << 0u;
    }

    /**
     * Clear HPSICR's CAAM_EN bit.
     *
     * CAAM Security Violation Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the CAAM Security Violation security violation
     */
    inline void clear_HPSICR_CAAM_EN() volatile
    {
        HPSICR &= ~(1u << 0u);
    }

    /**
     * Toggle HPSICR's CAAM_EN bit.
     *
     * CAAM Security Violation Interrupt Enable Setting this bit to 1 enables
     * generation of the security interrupt to the host processor upon
     * detection of the CAAM Security Violation security violation
     */
    inline void toggle_HPSICR_CAAM_EN() volatile
    {
        HPSICR ^= 1u << 0u;
    }

    /**
     * Get all of HPSICR's bit fields.
     *
     * (read-write) SNVS_HP Security Interrupt Control Register
     */
    inline void get_HPSICR(bool &LPSVI_EN, bool &OCOTP_EN, bool &SRC_EN,
                           bool &WDOG2_EN, bool &JTAGC_EN,
                           bool &CAAM_EN) volatile
    {
        uint32_t curr = HPSICR;

        LPSVI_EN = curr & (1u << 31u);
        OCOTP_EN = curr & (1u << 5u);
        SRC_EN = curr & (1u << 4u);
        WDOG2_EN = curr & (1u << 2u);
        JTAGC_EN = curr & (1u << 1u);
        CAAM_EN = curr & (1u << 0u);
    }

    /**
     * Set all of HPSICR's bit fields.
     *
     * (read-write) SNVS_HP Security Interrupt Control Register
     */
    inline void set_HPSICR(bool LPSVI_EN, bool OCOTP_EN, bool SRC_EN,
                           bool WDOG2_EN, bool JTAGC_EN, bool CAAM_EN) volatile
    {
        uint32_t curr = HPSICR;

        curr &= ~(0b1u << 31u);
        curr |= (LPSVI_EN & 0b1u) << 31u;
        curr &= ~(0b1u << 5u);
        curr |= (OCOTP_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SRC_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (WDOG2_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (JTAGC_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CAAM_EN & 0b1u) << 0u;

        HPSICR = curr;
    }

    /**
     * Get HPSVCR's LPSV_CFG field.
     *
     * LP Security Violation Configuration This field configures the LP
     * security violation source.
     */
    inline SNVS_HPSVCR_LPSV_CFG get_HPSVCR_LPSV_CFG() volatile
    {
        return SNVS_HPSVCR_LPSV_CFG((HPSVCR >> 30u) & 0b11u);
    }

    /**
     * Set HPSVCR's LPSV_CFG field.
     *
     * LP Security Violation Configuration This field configures the LP
     * security violation source.
     */
    inline void set_HPSVCR_LPSV_CFG(SNVS_HPSVCR_LPSV_CFG value) volatile
    {
        uint32_t curr = HPSVCR;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        HPSVCR = curr;
    }

    /**
     * Get HPSVCR's OCOTP_CFG field.
     *
     * OCOTP attack error Security Violation Configuration This field
     * configures the OCOTP attack error Security Violation Input
     */
    inline SNVS_HPSVCR_OCOTP_CFG get_HPSVCR_OCOTP_CFG() volatile
    {
        return SNVS_HPSVCR_OCOTP_CFG((HPSVCR >> 5u) & 0b11u);
    }

    /**
     * Set HPSVCR's OCOTP_CFG field.
     *
     * OCOTP attack error Security Violation Configuration This field
     * configures the OCOTP attack error Security Violation Input
     */
    inline void set_HPSVCR_OCOTP_CFG(SNVS_HPSVCR_OCOTP_CFG value) volatile
    {
        uint32_t curr = HPSVCR;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        HPSVCR = curr;
    }

    /**
     * Get HPSVCR's SRC_CFG bit.
     *
     * Internal Boot Security Violation Configuration This field configures the
     * Internal Boot Security Violation Input
     */
    inline bool get_HPSVCR_SRC_CFG() volatile
    {
        return HPSVCR & (1u << 4u);
    }

    /**
     * Set HPSVCR's SRC_CFG bit.
     *
     * Internal Boot Security Violation Configuration This field configures the
     * Internal Boot Security Violation Input
     */
    inline void set_HPSVCR_SRC_CFG() volatile
    {
        HPSVCR |= 1u << 4u;
    }

    /**
     * Clear HPSVCR's SRC_CFG bit.
     *
     * Internal Boot Security Violation Configuration This field configures the
     * Internal Boot Security Violation Input
     */
    inline void clear_HPSVCR_SRC_CFG() volatile
    {
        HPSVCR &= ~(1u << 4u);
    }

    /**
     * Toggle HPSVCR's SRC_CFG bit.
     *
     * Internal Boot Security Violation Configuration This field configures the
     * Internal Boot Security Violation Input
     */
    inline void toggle_HPSVCR_SRC_CFG() volatile
    {
        HPSVCR ^= 1u << 4u;
    }

    /**
     * Get HPSVCR's WDOG2_CFG bit.
     *
     * Watchdog 2 Reset Security Violation Configuration This field configures
     * the Watchdog 2 Reset Security Violation Input
     */
    inline bool get_HPSVCR_WDOG2_CFG() volatile
    {
        return HPSVCR & (1u << 2u);
    }

    /**
     * Set HPSVCR's WDOG2_CFG bit.
     *
     * Watchdog 2 Reset Security Violation Configuration This field configures
     * the Watchdog 2 Reset Security Violation Input
     */
    inline void set_HPSVCR_WDOG2_CFG() volatile
    {
        HPSVCR |= 1u << 2u;
    }

    /**
     * Clear HPSVCR's WDOG2_CFG bit.
     *
     * Watchdog 2 Reset Security Violation Configuration This field configures
     * the Watchdog 2 Reset Security Violation Input
     */
    inline void clear_HPSVCR_WDOG2_CFG() volatile
    {
        HPSVCR &= ~(1u << 2u);
    }

    /**
     * Toggle HPSVCR's WDOG2_CFG bit.
     *
     * Watchdog 2 Reset Security Violation Configuration This field configures
     * the Watchdog 2 Reset Security Violation Input
     */
    inline void toggle_HPSVCR_WDOG2_CFG() volatile
    {
        HPSVCR ^= 1u << 2u;
    }

    /**
     * Get HPSVCR's JTAGC_CFG bit.
     *
     * JTAG Active Security Violation Configuration This field configures the
     * JTAG Active Security Violation Input
     */
    inline bool get_HPSVCR_JTAGC_CFG() volatile
    {
        return HPSVCR & (1u << 1u);
    }

    /**
     * Set HPSVCR's JTAGC_CFG bit.
     *
     * JTAG Active Security Violation Configuration This field configures the
     * JTAG Active Security Violation Input
     */
    inline void set_HPSVCR_JTAGC_CFG() volatile
    {
        HPSVCR |= 1u << 1u;
    }

    /**
     * Clear HPSVCR's JTAGC_CFG bit.
     *
     * JTAG Active Security Violation Configuration This field configures the
     * JTAG Active Security Violation Input
     */
    inline void clear_HPSVCR_JTAGC_CFG() volatile
    {
        HPSVCR &= ~(1u << 1u);
    }

    /**
     * Toggle HPSVCR's JTAGC_CFG bit.
     *
     * JTAG Active Security Violation Configuration This field configures the
     * JTAG Active Security Violation Input
     */
    inline void toggle_HPSVCR_JTAGC_CFG() volatile
    {
        HPSVCR ^= 1u << 1u;
    }

    /**
     * Get HPSVCR's CAAM_CFG bit.
     *
     * CAAM Security Violation Security Violation Configuration This field
     * configures the CAAM Security Violation Security Violation Input
     */
    inline bool get_HPSVCR_CAAM_CFG() volatile
    {
        return HPSVCR & (1u << 0u);
    }

    /**
     * Set HPSVCR's CAAM_CFG bit.
     *
     * CAAM Security Violation Security Violation Configuration This field
     * configures the CAAM Security Violation Security Violation Input
     */
    inline void set_HPSVCR_CAAM_CFG() volatile
    {
        HPSVCR |= 1u << 0u;
    }

    /**
     * Clear HPSVCR's CAAM_CFG bit.
     *
     * CAAM Security Violation Security Violation Configuration This field
     * configures the CAAM Security Violation Security Violation Input
     */
    inline void clear_HPSVCR_CAAM_CFG() volatile
    {
        HPSVCR &= ~(1u << 0u);
    }

    /**
     * Toggle HPSVCR's CAAM_CFG bit.
     *
     * CAAM Security Violation Security Violation Configuration This field
     * configures the CAAM Security Violation Security Violation Input
     */
    inline void toggle_HPSVCR_CAAM_CFG() volatile
    {
        HPSVCR ^= 1u << 0u;
    }

    /**
     * Get all of HPSVCR's bit fields.
     *
     * (read-write) SNVS_HP Security Violation Control Register
     */
    inline void get_HPSVCR(SNVS_HPSVCR_LPSV_CFG &LPSV_CFG,
                           SNVS_HPSVCR_OCOTP_CFG &OCOTP_CFG, bool &SRC_CFG,
                           bool &WDOG2_CFG, bool &JTAGC_CFG,
                           bool &CAAM_CFG) volatile
    {
        uint32_t curr = HPSVCR;

        LPSV_CFG = SNVS_HPSVCR_LPSV_CFG((curr >> 30u) & 0b11u);
        OCOTP_CFG = SNVS_HPSVCR_OCOTP_CFG((curr >> 5u) & 0b11u);
        SRC_CFG = curr & (1u << 4u);
        WDOG2_CFG = curr & (1u << 2u);
        JTAGC_CFG = curr & (1u << 1u);
        CAAM_CFG = curr & (1u << 0u);
    }

    /**
     * Set all of HPSVCR's bit fields.
     *
     * (read-write) SNVS_HP Security Violation Control Register
     */
    inline void set_HPSVCR(SNVS_HPSVCR_LPSV_CFG LPSV_CFG,
                           SNVS_HPSVCR_OCOTP_CFG OCOTP_CFG, bool SRC_CFG,
                           bool WDOG2_CFG, bool JTAGC_CFG,
                           bool CAAM_CFG) volatile
    {
        uint32_t curr = HPSVCR;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(LPSV_CFG) & 0b11u) << 30u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(OCOTP_CFG) & 0b11u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SRC_CFG & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (WDOG2_CFG & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (JTAGC_CFG & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CAAM_CFG & 0b1u) << 0u;

        HPSVCR = curr;
    }

    /**
     * Get HPSR's ZMK_ZERO bit.
     *
     * Zeroizable Master Key is Equal to Zero
     */
    inline bool get_HPSR_ZMK_ZERO() volatile
    {
        return HPSR & (1u << 31u);
    }

    /**
     * Get HPSR's OTPMK_ZERO bit.
     *
     * One Time Programmable Master Key is Equal to Zero
     */
    inline bool get_HPSR_OTPMK_ZERO() volatile
    {
        return HPSR & (1u << 27u);
    }

    /**
     * Get HPSR's SYS_SECURE_BOOT bit.
     *
     * System Secure Boot If SYS_SECURE_BOOT is 1, the chip boots from internal
     * ROM
     */
    inline bool get_HPSR_SYS_SECURE_BOOT() volatile
    {
        return HPSR & (1u << 15u);
    }

    /**
     * Get HPSR's SYS_SECURITY_CFG field.
     *
     * System Security Configuration This field reflects the three security
     * configuration inputs to SNVS
     */
    inline SNVS_HPSR_SYS_SECURITY_CFG get_HPSR_SYS_SECURITY_CFG() volatile
    {
        return SNVS_HPSR_SYS_SECURITY_CFG((HPSR >> 12u) & 0b111u);
    }

    /**
     * Get HPSR's SSM_STATE field.
     *
     * System Security Monitor State This field contains the encoded state of
     * the SSM's state machine
     */
    inline SNVS_HPSR_SSM_STATE get_HPSR_SSM_STATE() volatile
    {
        return SNVS_HPSR_SSM_STATE((HPSR >> 8u) & 0b1111u);
    }

    /**
     * Get HPSR's BI bit.
     *
     * Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
     */
    inline bool get_HPSR_BI() volatile
    {
        return HPSR & (1u << 7u);
    }

    /**
     * Set HPSR's BI bit.
     *
     * Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
     */
    inline void set_HPSR_BI() volatile
    {
        HPSR |= 1u << 7u;
    }

    /**
     * Clear HPSR's BI bit.
     *
     * Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
     */
    inline void clear_HPSR_BI() volatile
    {
        HPSR &= ~(1u << 7u);
    }

    /**
     * Toggle HPSR's BI bit.
     *
     * Button Interrupt Signal ipi_snvs_btn_int_b was asserted.
     */
    inline void toggle_HPSR_BI() volatile
    {
        HPSR ^= 1u << 7u;
    }

    /**
     * Get HPSR's BTN bit.
     *
     * Button Value of the BTN input
     */
    inline bool get_HPSR_BTN() volatile
    {
        return HPSR & (1u << 6u);
    }

    /**
     * Get HPSR's LPDIS bit.
     *
     * Low Power Disable If 1, the low power section has been disabled by means
     * of an input signal to SNVS
     */
    inline bool get_HPSR_LPDIS() volatile
    {
        return HPSR & (1u << 4u);
    }

    /**
     * Get HPSR's PI bit.
     *
     * Periodic Interrupt Indicates that periodic interrupt has occurred since
     * this bit was last cleared.
     */
    inline bool get_HPSR_PI() volatile
    {
        return HPSR & (1u << 1u);
    }

    /**
     * Set HPSR's PI bit.
     *
     * Periodic Interrupt Indicates that periodic interrupt has occurred since
     * this bit was last cleared.
     */
    inline void set_HPSR_PI() volatile
    {
        HPSR |= 1u << 1u;
    }

    /**
     * Clear HPSR's PI bit.
     *
     * Periodic Interrupt Indicates that periodic interrupt has occurred since
     * this bit was last cleared.
     */
    inline void clear_HPSR_PI() volatile
    {
        HPSR &= ~(1u << 1u);
    }

    /**
     * Toggle HPSR's PI bit.
     *
     * Periodic Interrupt Indicates that periodic interrupt has occurred since
     * this bit was last cleared.
     */
    inline void toggle_HPSR_PI() volatile
    {
        HPSR ^= 1u << 1u;
    }

    /**
     * Get HPSR's HPTA bit.
     *
     * HP Time Alarm Indicates that the HP Time Alarm has occurred since this
     * bit was last cleared.
     */
    inline bool get_HPSR_HPTA() volatile
    {
        return HPSR & (1u << 0u);
    }

    /**
     * Set HPSR's HPTA bit.
     *
     * HP Time Alarm Indicates that the HP Time Alarm has occurred since this
     * bit was last cleared.
     */
    inline void set_HPSR_HPTA() volatile
    {
        HPSR |= 1u << 0u;
    }

    /**
     * Clear HPSR's HPTA bit.
     *
     * HP Time Alarm Indicates that the HP Time Alarm has occurred since this
     * bit was last cleared.
     */
    inline void clear_HPSR_HPTA() volatile
    {
        HPSR &= ~(1u << 0u);
    }

    /**
     * Toggle HPSR's HPTA bit.
     *
     * HP Time Alarm Indicates that the HP Time Alarm has occurred since this
     * bit was last cleared.
     */
    inline void toggle_HPSR_HPTA() volatile
    {
        HPSR ^= 1u << 0u;
    }

    /**
     * Get all of HPSR's bit fields.
     *
     * (read-write) SNVS_HP Status Register
     */
    inline void get_HPSR(bool &ZMK_ZERO, bool &OTPMK_ZERO,
                         bool &SYS_SECURE_BOOT,
                         SNVS_HPSR_SYS_SECURITY_CFG &SYS_SECURITY_CFG,
                         SNVS_HPSR_SSM_STATE &SSM_STATE, bool &BI, bool &BTN,
                         bool &LPDIS, bool &PI, bool &HPTA) volatile
    {
        uint32_t curr = HPSR;

        ZMK_ZERO = curr & (1u << 31u);
        OTPMK_ZERO = curr & (1u << 27u);
        SYS_SECURE_BOOT = curr & (1u << 15u);
        SYS_SECURITY_CFG = SNVS_HPSR_SYS_SECURITY_CFG((curr >> 12u) & 0b111u);
        SSM_STATE = SNVS_HPSR_SSM_STATE((curr >> 8u) & 0b1111u);
        BI = curr & (1u << 7u);
        BTN = curr & (1u << 6u);
        LPDIS = curr & (1u << 4u);
        PI = curr & (1u << 1u);
        HPTA = curr & (1u << 0u);
    }

    /**
     * Set all of HPSR's bit fields.
     *
     * (read-write) SNVS_HP Status Register
     */
    inline void set_HPSR(bool BI, bool PI, bool HPTA) volatile
    {
        uint32_t curr = HPSR;

        curr &= ~(0b1u << 7u);
        curr |= (BI & 0b1u) << 7u;
        curr &= ~(0b1u << 1u);
        curr |= (PI & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (HPTA & 0b1u) << 0u;

        HPSR = curr;
    }

    /**
     * Get HPSVSR's LP_SEC_VIO bit.
     *
     * LP Security Violation A security volation was detected in the SNVS low
     * power section
     */
    inline bool get_HPSVSR_LP_SEC_VIO() volatile
    {
        return HPSVSR & (1u << 31u);
    }

    /**
     * Get HPSVSR's ZMK_ECC_FAIL bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Failure When set, this
     * bit triggers a bad key violation to the SSM and a security violation to
     * the SNVS_LP section, which clears security sensitive data
     */
    inline bool get_HPSVSR_ZMK_ECC_FAIL() volatile
    {
        return HPSVSR & (1u << 27u);
    }

    /**
     * Set HPSVSR's ZMK_ECC_FAIL bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Failure When set, this
     * bit triggers a bad key violation to the SSM and a security violation to
     * the SNVS_LP section, which clears security sensitive data
     */
    inline void set_HPSVSR_ZMK_ECC_FAIL() volatile
    {
        HPSVSR |= 1u << 27u;
    }

    /**
     * Clear HPSVSR's ZMK_ECC_FAIL bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Failure When set, this
     * bit triggers a bad key violation to the SSM and a security violation to
     * the SNVS_LP section, which clears security sensitive data
     */
    inline void clear_HPSVSR_ZMK_ECC_FAIL() volatile
    {
        HPSVSR &= ~(1u << 27u);
    }

    /**
     * Toggle HPSVSR's ZMK_ECC_FAIL bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Failure When set, this
     * bit triggers a bad key violation to the SSM and a security violation to
     * the SNVS_LP section, which clears security sensitive data
     */
    inline void toggle_HPSVSR_ZMK_ECC_FAIL() volatile
    {
        HPSVSR ^= 1u << 27u;
    }

    /**
     * Get HPSVSR's ZMK_SYNDROME field.
     *
     * Zeroizable Master Key Syndrome The ZMK syndrome indicates the single-bit
     * error location and parity for the ZMK register
     */
    inline uint16_t get_HPSVSR_ZMK_SYNDROME() volatile
    {
        return (HPSVSR >> 16u) & 0b111111111u;
    }

    /**
     * Get HPSVSR's SW_LPSV bit.
     *
     * LP Software Security Violation This bit is a read-only copy of the
     * SW_LPSV bit in the HP Command Register
     */
    inline bool get_HPSVSR_SW_LPSV() volatile
    {
        return HPSVSR & (1u << 15u);
    }

    /**
     * Get HPSVSR's SW_FSV bit.
     *
     * Software Fatal Security Violation This bit is a read-only copy of the
     * SW_FSV bit in the HP Command Register
     */
    inline bool get_HPSVSR_SW_FSV() volatile
    {
        return HPSVSR & (1u << 14u);
    }

    /**
     * Get HPSVSR's SW_SV bit.
     *
     * Software Security Violation This bit is a read-only copy of the SW_SV
     * bit in the HP Command Register
     */
    inline bool get_HPSVSR_SW_SV() volatile
    {
        return HPSVSR & (1u << 13u);
    }

    /**
     * Get HPSVSR's OCOTP bit.
     *
     * OCOTP attack error security violation was detected.
     */
    inline bool get_HPSVSR_OCOTP() volatile
    {
        return HPSVSR & (1u << 5u);
    }

    /**
     * Set HPSVSR's OCOTP bit.
     *
     * OCOTP attack error security violation was detected.
     */
    inline void set_HPSVSR_OCOTP() volatile
    {
        HPSVSR |= 1u << 5u;
    }

    /**
     * Clear HPSVSR's OCOTP bit.
     *
     * OCOTP attack error security violation was detected.
     */
    inline void clear_HPSVSR_OCOTP() volatile
    {
        HPSVSR &= ~(1u << 5u);
    }

    /**
     * Toggle HPSVSR's OCOTP bit.
     *
     * OCOTP attack error security violation was detected.
     */
    inline void toggle_HPSVSR_OCOTP() volatile
    {
        HPSVSR ^= 1u << 5u;
    }

    /**
     * Get HPSVSR's SRC bit.
     *
     * Internal Boot security violation was detected.
     */
    inline bool get_HPSVSR_SRC() volatile
    {
        return HPSVSR & (1u << 4u);
    }

    /**
     * Set HPSVSR's SRC bit.
     *
     * Internal Boot security violation was detected.
     */
    inline void set_HPSVSR_SRC() volatile
    {
        HPSVSR |= 1u << 4u;
    }

    /**
     * Clear HPSVSR's SRC bit.
     *
     * Internal Boot security violation was detected.
     */
    inline void clear_HPSVSR_SRC() volatile
    {
        HPSVSR &= ~(1u << 4u);
    }

    /**
     * Toggle HPSVSR's SRC bit.
     *
     * Internal Boot security violation was detected.
     */
    inline void toggle_HPSVSR_SRC() volatile
    {
        HPSVSR ^= 1u << 4u;
    }

    /**
     * Get HPSVSR's WDOG2 bit.
     *
     * Watchdog 2 Reset security violation was detected.
     */
    inline bool get_HPSVSR_WDOG2() volatile
    {
        return HPSVSR & (1u << 2u);
    }

    /**
     * Set HPSVSR's WDOG2 bit.
     *
     * Watchdog 2 Reset security violation was detected.
     */
    inline void set_HPSVSR_WDOG2() volatile
    {
        HPSVSR |= 1u << 2u;
    }

    /**
     * Clear HPSVSR's WDOG2 bit.
     *
     * Watchdog 2 Reset security violation was detected.
     */
    inline void clear_HPSVSR_WDOG2() volatile
    {
        HPSVSR &= ~(1u << 2u);
    }

    /**
     * Toggle HPSVSR's WDOG2 bit.
     *
     * Watchdog 2 Reset security violation was detected.
     */
    inline void toggle_HPSVSR_WDOG2() volatile
    {
        HPSVSR ^= 1u << 2u;
    }

    /**
     * Get HPSVSR's JTAGC bit.
     *
     * JTAG Active security violation was detected.
     */
    inline bool get_HPSVSR_JTAGC() volatile
    {
        return HPSVSR & (1u << 1u);
    }

    /**
     * Set HPSVSR's JTAGC bit.
     *
     * JTAG Active security violation was detected.
     */
    inline void set_HPSVSR_JTAGC() volatile
    {
        HPSVSR |= 1u << 1u;
    }

    /**
     * Clear HPSVSR's JTAGC bit.
     *
     * JTAG Active security violation was detected.
     */
    inline void clear_HPSVSR_JTAGC() volatile
    {
        HPSVSR &= ~(1u << 1u);
    }

    /**
     * Toggle HPSVSR's JTAGC bit.
     *
     * JTAG Active security violation was detected.
     */
    inline void toggle_HPSVSR_JTAGC() volatile
    {
        HPSVSR ^= 1u << 1u;
    }

    /**
     * Get HPSVSR's CAAM bit.
     *
     * CAAM Security Violation security violation was detected.
     */
    inline bool get_HPSVSR_CAAM() volatile
    {
        return HPSVSR & (1u << 0u);
    }

    /**
     * Set HPSVSR's CAAM bit.
     *
     * CAAM Security Violation security violation was detected.
     */
    inline void set_HPSVSR_CAAM() volatile
    {
        HPSVSR |= 1u << 0u;
    }

    /**
     * Clear HPSVSR's CAAM bit.
     *
     * CAAM Security Violation security violation was detected.
     */
    inline void clear_HPSVSR_CAAM() volatile
    {
        HPSVSR &= ~(1u << 0u);
    }

    /**
     * Toggle HPSVSR's CAAM bit.
     *
     * CAAM Security Violation security violation was detected.
     */
    inline void toggle_HPSVSR_CAAM() volatile
    {
        HPSVSR ^= 1u << 0u;
    }

    /**
     * Get all of HPSVSR's bit fields.
     *
     * (read-write) SNVS_HP Security Violation Status Register
     */
    inline void get_HPSVSR(bool &LP_SEC_VIO, bool &ZMK_ECC_FAIL,
                           uint16_t &ZMK_SYNDROME, bool &SW_LPSV, bool &SW_FSV,
                           bool &SW_SV, bool &OCOTP, bool &SRC, bool &WDOG2,
                           bool &JTAGC, bool &CAAM) volatile
    {
        uint32_t curr = HPSVSR;

        LP_SEC_VIO = curr & (1u << 31u);
        ZMK_ECC_FAIL = curr & (1u << 27u);
        ZMK_SYNDROME = (curr >> 16u) & 0b111111111u;
        SW_LPSV = curr & (1u << 15u);
        SW_FSV = curr & (1u << 14u);
        SW_SV = curr & (1u << 13u);
        OCOTP = curr & (1u << 5u);
        SRC = curr & (1u << 4u);
        WDOG2 = curr & (1u << 2u);
        JTAGC = curr & (1u << 1u);
        CAAM = curr & (1u << 0u);
    }

    /**
     * Set all of HPSVSR's bit fields.
     *
     * (read-write) SNVS_HP Security Violation Status Register
     */
    inline void set_HPSVSR(bool ZMK_ECC_FAIL, bool OCOTP, bool SRC, bool WDOG2,
                           bool JTAGC, bool CAAM) volatile
    {
        uint32_t curr = HPSVSR;

        curr &= ~(0b1u << 27u);
        curr |= (ZMK_ECC_FAIL & 0b1u) << 27u;
        curr &= ~(0b1u << 5u);
        curr |= (OCOTP & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SRC & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (WDOG2 & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (JTAGC & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CAAM & 0b1u) << 0u;

        HPSVSR = curr;
    }

    /**
     * Get HPHACIVR's HAC_COUNTER_IV field.
     *
     * High Assurance Counter Initial Value This register is used to set the
     * starting count value to the high assurance counter
     */
    inline uint32_t get_HPHACIVR_HAC_COUNTER_IV() volatile
    {
        return (HPHACIVR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set HPHACIVR's HAC_COUNTER_IV field.
     *
     * High Assurance Counter Initial Value This register is used to set the
     * starting count value to the high assurance counter
     */
    inline void set_HPHACIVR_HAC_COUNTER_IV(uint32_t value) volatile
    {
        uint32_t curr = HPHACIVR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        HPHACIVR = curr;
    }

    /**
     * Get HPHACR's HAC_COUNTER field.
     *
     * High Assurance Counter When the HAC_EN bit is set and the SSM is in the
     * soft fail state, this counter starts to count down with the system clock
     */
    inline uint32_t get_HPHACR_HAC_COUNTER() volatile
    {
        return (HPHACR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get HPRTCMR's RTC field.
     *
     * HP Real Time Counter The most-significant 15 bits of the RTC
     */
    inline uint16_t get_HPRTCMR_RTC() volatile
    {
        return (HPRTCMR >> 0u) & 0b111111111111111u;
    }

    /**
     * Set HPRTCMR's RTC field.
     *
     * HP Real Time Counter The most-significant 15 bits of the RTC
     */
    inline void set_HPRTCMR_RTC(uint16_t value) volatile
    {
        uint32_t curr = HPRTCMR;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        HPRTCMR = curr;
    }

    /**
     * Get HPRTCLR's RTC field.
     *
     * HP Real Time Counter least-significant 32 bits
     */
    inline uint32_t get_HPRTCLR_RTC() volatile
    {
        return (HPRTCLR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set HPRTCLR's RTC field.
     *
     * HP Real Time Counter least-significant 32 bits
     */
    inline void set_HPRTCLR_RTC(uint32_t value) volatile
    {
        uint32_t curr = HPRTCLR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        HPRTCLR = curr;
    }

    /**
     * Get HPTAMR's HPTA_MS field.
     *
     * HP Time Alarm, most-significant 15 bits
     */
    inline uint16_t get_HPTAMR_HPTA_MS() volatile
    {
        return (HPTAMR >> 0u) & 0b111111111111111u;
    }

    /**
     * Set HPTAMR's HPTA_MS field.
     *
     * HP Time Alarm, most-significant 15 bits
     */
    inline void set_HPTAMR_HPTA_MS(uint16_t value) volatile
    {
        uint32_t curr = HPTAMR;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        HPTAMR = curr;
    }

    /**
     * Get HPTALR's HPTA_LS field.
     *
     * HP Time Alarm, 32 least-significant bits
     */
    inline uint32_t get_HPTALR_HPTA_LS() volatile
    {
        return (HPTALR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set HPTALR's HPTA_LS field.
     *
     * HP Time Alarm, 32 least-significant bits
     */
    inline void set_HPTALR_HPTA_LS(uint32_t value) volatile
    {
        uint32_t curr = HPTALR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        HPTALR = curr;
    }

    /**
     * Get LPLR's AT5_HL bit.
     *
     * Active Tamper 5 Hard Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline bool get_LPLR_AT5_HL() volatile
    {
        return LPLR & (1u << 28u);
    }

    /**
     * Set LPLR's AT5_HL bit.
     *
     * Active Tamper 5 Hard Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline void set_LPLR_AT5_HL() volatile
    {
        LPLR |= 1u << 28u;
    }

    /**
     * Clear LPLR's AT5_HL bit.
     *
     * Active Tamper 5 Hard Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline void clear_LPLR_AT5_HL() volatile
    {
        LPLR &= ~(1u << 28u);
    }

    /**
     * Toggle LPLR's AT5_HL bit.
     *
     * Active Tamper 5 Hard Lock When set, prevents any writes to the Active
     * Tamper 5 registers
     */
    inline void toggle_LPLR_AT5_HL() volatile
    {
        LPLR ^= 1u << 28u;
    }

    /**
     * Get LPLR's AT4_HL bit.
     *
     * Active Tamper 4 Hard Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline bool get_LPLR_AT4_HL() volatile
    {
        return LPLR & (1u << 27u);
    }

    /**
     * Set LPLR's AT4_HL bit.
     *
     * Active Tamper 4 Hard Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline void set_LPLR_AT4_HL() volatile
    {
        LPLR |= 1u << 27u;
    }

    /**
     * Clear LPLR's AT4_HL bit.
     *
     * Active Tamper 4 Hard Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline void clear_LPLR_AT4_HL() volatile
    {
        LPLR &= ~(1u << 27u);
    }

    /**
     * Toggle LPLR's AT4_HL bit.
     *
     * Active Tamper 4 Hard Lock When set, prevents any writes to the Active
     * Tamper 4 registers
     */
    inline void toggle_LPLR_AT4_HL() volatile
    {
        LPLR ^= 1u << 27u;
    }

    /**
     * Get LPLR's AT3_HL bit.
     *
     * Active Tamper 3 Hard Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline bool get_LPLR_AT3_HL() volatile
    {
        return LPLR & (1u << 26u);
    }

    /**
     * Set LPLR's AT3_HL bit.
     *
     * Active Tamper 3 Hard Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline void set_LPLR_AT3_HL() volatile
    {
        LPLR |= 1u << 26u;
    }

    /**
     * Clear LPLR's AT3_HL bit.
     *
     * Active Tamper 3 Hard Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline void clear_LPLR_AT3_HL() volatile
    {
        LPLR &= ~(1u << 26u);
    }

    /**
     * Toggle LPLR's AT3_HL bit.
     *
     * Active Tamper 3 Hard Lock When set, prevents any writes to the Active
     * Tamper 3 registers
     */
    inline void toggle_LPLR_AT3_HL() volatile
    {
        LPLR ^= 1u << 26u;
    }

    /**
     * Get LPLR's AT2_HL bit.
     *
     * Active Tamper 2 Hard Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline bool get_LPLR_AT2_HL() volatile
    {
        return LPLR & (1u << 25u);
    }

    /**
     * Set LPLR's AT2_HL bit.
     *
     * Active Tamper 2 Hard Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline void set_LPLR_AT2_HL() volatile
    {
        LPLR |= 1u << 25u;
    }

    /**
     * Clear LPLR's AT2_HL bit.
     *
     * Active Tamper 2 Hard Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline void clear_LPLR_AT2_HL() volatile
    {
        LPLR &= ~(1u << 25u);
    }

    /**
     * Toggle LPLR's AT2_HL bit.
     *
     * Active Tamper 2 Hard Lock When set, prevents any writes to the Active
     * Tamper 2 registers
     */
    inline void toggle_LPLR_AT2_HL() volatile
    {
        LPLR ^= 1u << 25u;
    }

    /**
     * Get LPLR's AT1_HL bit.
     *
     * Active Tamper 1 Hard Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline bool get_LPLR_AT1_HL() volatile
    {
        return LPLR & (1u << 24u);
    }

    /**
     * Set LPLR's AT1_HL bit.
     *
     * Active Tamper 1 Hard Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline void set_LPLR_AT1_HL() volatile
    {
        LPLR |= 1u << 24u;
    }

    /**
     * Clear LPLR's AT1_HL bit.
     *
     * Active Tamper 1 Hard Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline void clear_LPLR_AT1_HL() volatile
    {
        LPLR &= ~(1u << 24u);
    }

    /**
     * Toggle LPLR's AT1_HL bit.
     *
     * Active Tamper 1 Hard Lock When set, prevents any writes to the Active
     * Tamper 1 registers
     */
    inline void toggle_LPLR_AT1_HL() volatile
    {
        LPLR ^= 1u << 24u;
    }

    /**
     * Get LPLR's MKS_HL bit.
     *
     * Master Key Select Hard Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LP Master Key Control Register
     */
    inline bool get_LPLR_MKS_HL() volatile
    {
        return LPLR & (1u << 9u);
    }

    /**
     * Set LPLR's MKS_HL bit.
     *
     * Master Key Select Hard Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LP Master Key Control Register
     */
    inline void set_LPLR_MKS_HL() volatile
    {
        LPLR |= 1u << 9u;
    }

    /**
     * Clear LPLR's MKS_HL bit.
     *
     * Master Key Select Hard Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LP Master Key Control Register
     */
    inline void clear_LPLR_MKS_HL() volatile
    {
        LPLR &= ~(1u << 9u);
    }

    /**
     * Toggle LPLR's MKS_HL bit.
     *
     * Master Key Select Hard Lock When set, prevents any writes to the
     * MASTER_KEY_SEL field of the LP Master Key Control Register
     */
    inline void toggle_LPLR_MKS_HL() volatile
    {
        LPLR ^= 1u << 9u;
    }

    /**
     * Get LPLR's LPSECR_HL bit.
     *
     * LP Security Events Configuration Register Hard Lock When set, prevents
     * any writes to the LPSECR
     */
    inline bool get_LPLR_LPSECR_HL() volatile
    {
        return LPLR & (1u << 8u);
    }

    /**
     * Set LPLR's LPSECR_HL bit.
     *
     * LP Security Events Configuration Register Hard Lock When set, prevents
     * any writes to the LPSECR
     */
    inline void set_LPLR_LPSECR_HL() volatile
    {
        LPLR |= 1u << 8u;
    }

    /**
     * Clear LPLR's LPSECR_HL bit.
     *
     * LP Security Events Configuration Register Hard Lock When set, prevents
     * any writes to the LPSECR
     */
    inline void clear_LPLR_LPSECR_HL() volatile
    {
        LPLR &= ~(1u << 8u);
    }

    /**
     * Toggle LPLR's LPSECR_HL bit.
     *
     * LP Security Events Configuration Register Hard Lock When set, prevents
     * any writes to the LPSECR
     */
    inline void toggle_LPLR_LPSECR_HL() volatile
    {
        LPLR ^= 1u << 8u;
    }

    /**
     * Get LPLR's LPTGFCR_HL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Hard Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline bool get_LPLR_LPTGFCR_HL() volatile
    {
        return LPLR & (1u << 7u);
    }

    /**
     * Set LPLR's LPTGFCR_HL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Hard Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline void set_LPLR_LPTGFCR_HL() volatile
    {
        LPLR |= 1u << 7u;
    }

    /**
     * Clear LPLR's LPTGFCR_HL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Hard Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline void clear_LPLR_LPTGFCR_HL() volatile
    {
        LPLR &= ~(1u << 7u);
    }

    /**
     * Toggle LPLR's LPTGFCR_HL bit.
     *
     * LP Tamper Glitch Filter Configuration Register Hard Lock When set,
     * prevents any writes to the LPTGFCR
     */
    inline void toggle_LPLR_LPTGFCR_HL() volatile
    {
        LPLR ^= 1u << 7u;
    }

    /**
     * Get LPLR's LPSVCR_HL bit.
     *
     * LP Security Violation Control Register Hard Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline bool get_LPLR_LPSVCR_HL() volatile
    {
        return LPLR & (1u << 6u);
    }

    /**
     * Set LPLR's LPSVCR_HL bit.
     *
     * LP Security Violation Control Register Hard Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline void set_LPLR_LPSVCR_HL() volatile
    {
        LPLR |= 1u << 6u;
    }

    /**
     * Clear LPLR's LPSVCR_HL bit.
     *
     * LP Security Violation Control Register Hard Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline void clear_LPLR_LPSVCR_HL() volatile
    {
        LPLR &= ~(1u << 6u);
    }

    /**
     * Toggle LPLR's LPSVCR_HL bit.
     *
     * LP Security Violation Control Register Hard Lock When set, prevents any
     * writes to the LPSVCR
     */
    inline void toggle_LPLR_LPSVCR_HL() volatile
    {
        LPLR ^= 1u << 6u;
    }

    /**
     * Get LPLR's GPR_HL bit.
     *
     * General Purpose Register Hard Lock When set, prevents any writes to the
     * GPR
     */
    inline bool get_LPLR_GPR_HL() volatile
    {
        return LPLR & (1u << 5u);
    }

    /**
     * Set LPLR's GPR_HL bit.
     *
     * General Purpose Register Hard Lock When set, prevents any writes to the
     * GPR
     */
    inline void set_LPLR_GPR_HL() volatile
    {
        LPLR |= 1u << 5u;
    }

    /**
     * Clear LPLR's GPR_HL bit.
     *
     * General Purpose Register Hard Lock When set, prevents any writes to the
     * GPR
     */
    inline void clear_LPLR_GPR_HL() volatile
    {
        LPLR &= ~(1u << 5u);
    }

    /**
     * Toggle LPLR's GPR_HL bit.
     *
     * General Purpose Register Hard Lock When set, prevents any writes to the
     * GPR
     */
    inline void toggle_LPLR_GPR_HL() volatile
    {
        LPLR ^= 1u << 5u;
    }

    /**
     * Get LPLR's MC_HL bit.
     *
     * Monotonic Counter Hard Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline bool get_LPLR_MC_HL() volatile
    {
        return LPLR & (1u << 4u);
    }

    /**
     * Set LPLR's MC_HL bit.
     *
     * Monotonic Counter Hard Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline void set_LPLR_MC_HL() volatile
    {
        LPLR |= 1u << 4u;
    }

    /**
     * Clear LPLR's MC_HL bit.
     *
     * Monotonic Counter Hard Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline void clear_LPLR_MC_HL() volatile
    {
        LPLR &= ~(1u << 4u);
    }

    /**
     * Toggle LPLR's MC_HL bit.
     *
     * Monotonic Counter Hard Lock When set, prevents any writes (increments)
     * to the MC Registers and MC_ENV bit
     */
    inline void toggle_LPLR_MC_HL() volatile
    {
        LPLR ^= 1u << 4u;
    }

    /**
     * Get LPLR's LPCALB_HL bit.
     *
     * LP Calibration Hard Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline bool get_LPLR_LPCALB_HL() volatile
    {
        return LPLR & (1u << 3u);
    }

    /**
     * Set LPLR's LPCALB_HL bit.
     *
     * LP Calibration Hard Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline void set_LPLR_LPCALB_HL() volatile
    {
        LPLR |= 1u << 3u;
    }

    /**
     * Clear LPLR's LPCALB_HL bit.
     *
     * LP Calibration Hard Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline void clear_LPLR_LPCALB_HL() volatile
    {
        LPLR &= ~(1u << 3u);
    }

    /**
     * Toggle LPLR's LPCALB_HL bit.
     *
     * LP Calibration Hard Lock When set, prevents any writes to the LP
     * Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)
     */
    inline void toggle_LPLR_LPCALB_HL() volatile
    {
        LPLR ^= 1u << 3u;
    }

    /**
     * Get LPLR's SRTC_HL bit.
     *
     * Secure Real Time Counter Hard Lock When set, prevents any writes to the
     * SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline bool get_LPLR_SRTC_HL() volatile
    {
        return LPLR & (1u << 2u);
    }

    /**
     * Set LPLR's SRTC_HL bit.
     *
     * Secure Real Time Counter Hard Lock When set, prevents any writes to the
     * SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline void set_LPLR_SRTC_HL() volatile
    {
        LPLR |= 1u << 2u;
    }

    /**
     * Clear LPLR's SRTC_HL bit.
     *
     * Secure Real Time Counter Hard Lock When set, prevents any writes to the
     * SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline void clear_LPLR_SRTC_HL() volatile
    {
        LPLR &= ~(1u << 2u);
    }

    /**
     * Toggle LPLR's SRTC_HL bit.
     *
     * Secure Real Time Counter Hard Lock When set, prevents any writes to the
     * SRTC registers, SRTC_ENV, and SRTC_INV_EN bits
     */
    inline void toggle_LPLR_SRTC_HL() volatile
    {
        LPLR ^= 1u << 2u;
    }

    /**
     * Get LPLR's ZMK_RHL bit.
     *
     * Zeroizable Master Key Read Hard Lock When set, prevents any software
     * reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline bool get_LPLR_ZMK_RHL() volatile
    {
        return LPLR & (1u << 1u);
    }

    /**
     * Set LPLR's ZMK_RHL bit.
     *
     * Zeroizable Master Key Read Hard Lock When set, prevents any software
     * reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline void set_LPLR_ZMK_RHL() volatile
    {
        LPLR |= 1u << 1u;
    }

    /**
     * Clear LPLR's ZMK_RHL bit.
     *
     * Zeroizable Master Key Read Hard Lock When set, prevents any software
     * reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline void clear_LPLR_ZMK_RHL() volatile
    {
        LPLR &= ~(1u << 1u);
    }

    /**
     * Toggle LPLR's ZMK_RHL bit.
     *
     * Zeroizable Master Key Read Hard Lock When set, prevents any software
     * reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR
     */
    inline void toggle_LPLR_ZMK_RHL() volatile
    {
        LPLR ^= 1u << 1u;
    }

    /**
     * Get LPLR's ZMK_WHL bit.
     *
     * Zeroizable Master Key Write Hard Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and
     * ZMK_ECC_EN fields of the LPMKCR
     */
    inline bool get_LPLR_ZMK_WHL() volatile
    {
        return LPLR & (1u << 0u);
    }

    /**
     * Set LPLR's ZMK_WHL bit.
     *
     * Zeroizable Master Key Write Hard Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and
     * ZMK_ECC_EN fields of the LPMKCR
     */
    inline void set_LPLR_ZMK_WHL() volatile
    {
        LPLR |= 1u << 0u;
    }

    /**
     * Clear LPLR's ZMK_WHL bit.
     *
     * Zeroizable Master Key Write Hard Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and
     * ZMK_ECC_EN fields of the LPMKCR
     */
    inline void clear_LPLR_ZMK_WHL() volatile
    {
        LPLR &= ~(1u << 0u);
    }

    /**
     * Toggle LPLR's ZMK_WHL bit.
     *
     * Zeroizable Master Key Write Hard Lock When set, prevents any writes
     * (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and
     * ZMK_ECC_EN fields of the LPMKCR
     */
    inline void toggle_LPLR_ZMK_WHL() volatile
    {
        LPLR ^= 1u << 0u;
    }

    /**
     * Get all of LPLR's bit fields.
     *
     * (read-write) SNVS_LP Lock Register
     */
    inline void get_LPLR(bool &AT5_HL, bool &AT4_HL, bool &AT3_HL,
                         bool &AT2_HL, bool &AT1_HL, bool &MKS_HL,
                         bool &LPSECR_HL, bool &LPTGFCR_HL, bool &LPSVCR_HL,
                         bool &GPR_HL, bool &MC_HL, bool &LPCALB_HL,
                         bool &SRTC_HL, bool &ZMK_RHL, bool &ZMK_WHL) volatile
    {
        uint32_t curr = LPLR;

        AT5_HL = curr & (1u << 28u);
        AT4_HL = curr & (1u << 27u);
        AT3_HL = curr & (1u << 26u);
        AT2_HL = curr & (1u << 25u);
        AT1_HL = curr & (1u << 24u);
        MKS_HL = curr & (1u << 9u);
        LPSECR_HL = curr & (1u << 8u);
        LPTGFCR_HL = curr & (1u << 7u);
        LPSVCR_HL = curr & (1u << 6u);
        GPR_HL = curr & (1u << 5u);
        MC_HL = curr & (1u << 4u);
        LPCALB_HL = curr & (1u << 3u);
        SRTC_HL = curr & (1u << 2u);
        ZMK_RHL = curr & (1u << 1u);
        ZMK_WHL = curr & (1u << 0u);
    }

    /**
     * Set all of LPLR's bit fields.
     *
     * (read-write) SNVS_LP Lock Register
     */
    inline void set_LPLR(bool AT5_HL, bool AT4_HL, bool AT3_HL, bool AT2_HL,
                         bool AT1_HL, bool MKS_HL, bool LPSECR_HL,
                         bool LPTGFCR_HL, bool LPSVCR_HL, bool GPR_HL,
                         bool MC_HL, bool LPCALB_HL, bool SRTC_HL,
                         bool ZMK_RHL, bool ZMK_WHL) volatile
    {
        uint32_t curr = LPLR;

        curr &= ~(0b1u << 28u);
        curr |= (AT5_HL & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (AT4_HL & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (AT3_HL & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (AT2_HL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (AT1_HL & 0b1u) << 24u;
        curr &= ~(0b1u << 9u);
        curr |= (MKS_HL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (LPSECR_HL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LPTGFCR_HL & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (LPSVCR_HL & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (GPR_HL & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (MC_HL & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LPCALB_HL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (SRTC_HL & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ZMK_RHL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ZMK_WHL & 0b1u) << 0u;

        LPLR = curr;
    }

    /**
     * Get LPCR's GPR_Z_DIS bit.
     *
     * General Purpose Registers Zeroization Disable
     */
    inline bool get_LPCR_GPR_Z_DIS() volatile
    {
        return LPCR & (1u << 24u);
    }

    /**
     * Set LPCR's GPR_Z_DIS bit.
     *
     * General Purpose Registers Zeroization Disable
     */
    inline void set_LPCR_GPR_Z_DIS() volatile
    {
        LPCR |= 1u << 24u;
    }

    /**
     * Clear LPCR's GPR_Z_DIS bit.
     *
     * General Purpose Registers Zeroization Disable
     */
    inline void clear_LPCR_GPR_Z_DIS() volatile
    {
        LPCR &= ~(1u << 24u);
    }

    /**
     * Toggle LPCR's GPR_Z_DIS bit.
     *
     * General Purpose Registers Zeroization Disable
     */
    inline void toggle_LPCR_GPR_Z_DIS() volatile
    {
        LPCR ^= 1u << 24u;
    }

    /**
     * Get LPCR's PK_OVERRIDE bit.
     *
     * PMIC On Request Override The value written to PK_OVERRIDE will be
     * asserted on output signal snvs_lp_pk_override
     */
    inline bool get_LPCR_PK_OVERRIDE() volatile
    {
        return LPCR & (1u << 23u);
    }

    /**
     * Set LPCR's PK_OVERRIDE bit.
     *
     * PMIC On Request Override The value written to PK_OVERRIDE will be
     * asserted on output signal snvs_lp_pk_override
     */
    inline void set_LPCR_PK_OVERRIDE() volatile
    {
        LPCR |= 1u << 23u;
    }

    /**
     * Clear LPCR's PK_OVERRIDE bit.
     *
     * PMIC On Request Override The value written to PK_OVERRIDE will be
     * asserted on output signal snvs_lp_pk_override
     */
    inline void clear_LPCR_PK_OVERRIDE() volatile
    {
        LPCR &= ~(1u << 23u);
    }

    /**
     * Toggle LPCR's PK_OVERRIDE bit.
     *
     * PMIC On Request Override The value written to PK_OVERRIDE will be
     * asserted on output signal snvs_lp_pk_override
     */
    inline void toggle_LPCR_PK_OVERRIDE() volatile
    {
        LPCR ^= 1u << 23u;
    }

    /**
     * Get LPCR's PK_EN bit.
     *
     * PMIC On Request Enable The value written to PK_EN will be asserted on
     * output signal snvs_lp_pk_en
     */
    inline bool get_LPCR_PK_EN() volatile
    {
        return LPCR & (1u << 22u);
    }

    /**
     * Set LPCR's PK_EN bit.
     *
     * PMIC On Request Enable The value written to PK_EN will be asserted on
     * output signal snvs_lp_pk_en
     */
    inline void set_LPCR_PK_EN() volatile
    {
        LPCR |= 1u << 22u;
    }

    /**
     * Clear LPCR's PK_EN bit.
     *
     * PMIC On Request Enable The value written to PK_EN will be asserted on
     * output signal snvs_lp_pk_en
     */
    inline void clear_LPCR_PK_EN() volatile
    {
        LPCR &= ~(1u << 22u);
    }

    /**
     * Toggle LPCR's PK_EN bit.
     *
     * PMIC On Request Enable The value written to PK_EN will be asserted on
     * output signal snvs_lp_pk_en
     */
    inline void toggle_LPCR_PK_EN() volatile
    {
        LPCR ^= 1u << 22u;
    }

    /**
     * Get LPCR's ON_TIME field.
     *
     * The ON_TIME field is used to configure the period of time after BTN is
     * asserted before pmic_en_b is asserted to turn on the SoC power
     */
    inline uint8_t get_LPCR_ON_TIME() volatile
    {
        return (LPCR >> 20u) & 0b11u;
    }

    /**
     * Set LPCR's ON_TIME field.
     *
     * The ON_TIME field is used to configure the period of time after BTN is
     * asserted before pmic_en_b is asserted to turn on the SoC power
     */
    inline void set_LPCR_ON_TIME(uint8_t value) volatile
    {
        uint32_t curr = LPCR;

        curr &= ~(0b11u << 20u);
        curr |= (value & 0b11u) << 20u;

        LPCR = curr;
    }

    /**
     * Get LPCR's DEBOUNCE field.
     *
     * This field configures the amount of debounce time for the BTN input
     * signal
     */
    inline uint8_t get_LPCR_DEBOUNCE() volatile
    {
        return (LPCR >> 18u) & 0b11u;
    }

    /**
     * Set LPCR's DEBOUNCE field.
     *
     * This field configures the amount of debounce time for the BTN input
     * signal
     */
    inline void set_LPCR_DEBOUNCE(uint8_t value) volatile
    {
        uint32_t curr = LPCR;

        curr &= ~(0b11u << 18u);
        curr |= (value & 0b11u) << 18u;

        LPCR = curr;
    }

    /**
     * Get LPCR's BTN_PRESS_TIME field.
     *
     * This field configures the button press time out values for the PMIC
     * Logic
     */
    inline uint8_t get_LPCR_BTN_PRESS_TIME() volatile
    {
        return (LPCR >> 16u) & 0b11u;
    }

    /**
     * Set LPCR's BTN_PRESS_TIME field.
     *
     * This field configures the button press time out values for the PMIC
     * Logic
     */
    inline void set_LPCR_BTN_PRESS_TIME(uint8_t value) volatile
    {
        uint32_t curr = LPCR;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        LPCR = curr;
    }

    /**
     * Get LPCR's LPCALB_VAL field.
     *
     * LP Calibration Value Defines signed calibration value for SRTC
     */
    inline SNVS_LPCR_LPCALB_VAL get_LPCR_LPCALB_VAL() volatile
    {
        return SNVS_LPCR_LPCALB_VAL((LPCR >> 10u) & 0b11111u);
    }

    /**
     * Set LPCR's LPCALB_VAL field.
     *
     * LP Calibration Value Defines signed calibration value for SRTC
     */
    inline void set_LPCR_LPCALB_VAL(SNVS_LPCR_LPCALB_VAL value) volatile
    {
        uint32_t curr = LPCR;

        curr &= ~(0b11111u << 10u);
        curr |= (std::to_underlying(value) & 0b11111u) << 10u;

        LPCR = curr;
    }

    /**
     * Get LPCR's LPCALB_EN bit.
     *
     * LP Calibration Enable When set, enables the SRTC calibration mechanism
     */
    inline bool get_LPCR_LPCALB_EN() volatile
    {
        return LPCR & (1u << 8u);
    }

    /**
     * Set LPCR's LPCALB_EN bit.
     *
     * LP Calibration Enable When set, enables the SRTC calibration mechanism
     */
    inline void set_LPCR_LPCALB_EN() volatile
    {
        LPCR |= 1u << 8u;
    }

    /**
     * Clear LPCR's LPCALB_EN bit.
     *
     * LP Calibration Enable When set, enables the SRTC calibration mechanism
     */
    inline void clear_LPCR_LPCALB_EN() volatile
    {
        LPCR &= ~(1u << 8u);
    }

    /**
     * Toggle LPCR's LPCALB_EN bit.
     *
     * LP Calibration Enable When set, enables the SRTC calibration mechanism
     */
    inline void toggle_LPCR_LPCALB_EN() volatile
    {
        LPCR ^= 1u << 8u;
    }

    /**
     * Get LPCR's LVD_EN bit.
     *
     * Digital Low-Voltage Event Enable By default the detection of a
     * low-voltage event does not cause the pmic_en_b signal to be asserted
     */
    inline bool get_LPCR_LVD_EN() volatile
    {
        return LPCR & (1u << 7u);
    }

    /**
     * Set LPCR's LVD_EN bit.
     *
     * Digital Low-Voltage Event Enable By default the detection of a
     * low-voltage event does not cause the pmic_en_b signal to be asserted
     */
    inline void set_LPCR_LVD_EN() volatile
    {
        LPCR |= 1u << 7u;
    }

    /**
     * Clear LPCR's LVD_EN bit.
     *
     * Digital Low-Voltage Event Enable By default the detection of a
     * low-voltage event does not cause the pmic_en_b signal to be asserted
     */
    inline void clear_LPCR_LVD_EN() volatile
    {
        LPCR &= ~(1u << 7u);
    }

    /**
     * Toggle LPCR's LVD_EN bit.
     *
     * Digital Low-Voltage Event Enable By default the detection of a
     * low-voltage event does not cause the pmic_en_b signal to be asserted
     */
    inline void toggle_LPCR_LVD_EN() volatile
    {
        LPCR ^= 1u << 7u;
    }

    /**
     * Get LPCR's TOP bit.
     *
     * Turn off System Power Asserting this bit causes a signal to be sent to
     * the Power Management IC to turn off the system power
     */
    inline bool get_LPCR_TOP() volatile
    {
        return LPCR & (1u << 6u);
    }

    /**
     * Set LPCR's TOP bit.
     *
     * Turn off System Power Asserting this bit causes a signal to be sent to
     * the Power Management IC to turn off the system power
     */
    inline void set_LPCR_TOP() volatile
    {
        LPCR |= 1u << 6u;
    }

    /**
     * Clear LPCR's TOP bit.
     *
     * Turn off System Power Asserting this bit causes a signal to be sent to
     * the Power Management IC to turn off the system power
     */
    inline void clear_LPCR_TOP() volatile
    {
        LPCR &= ~(1u << 6u);
    }

    /**
     * Toggle LPCR's TOP bit.
     *
     * Turn off System Power Asserting this bit causes a signal to be sent to
     * the Power Management IC to turn off the system power
     */
    inline void toggle_LPCR_TOP() volatile
    {
        LPCR ^= 1u << 6u;
    }

    /**
     * Get LPCR's DP_EN bit.
     *
     * Dumb PMIC Enabled When set, software can control the system power
     */
    inline bool get_LPCR_DP_EN() volatile
    {
        return LPCR & (1u << 5u);
    }

    /**
     * Set LPCR's DP_EN bit.
     *
     * Dumb PMIC Enabled When set, software can control the system power
     */
    inline void set_LPCR_DP_EN() volatile
    {
        LPCR |= 1u << 5u;
    }

    /**
     * Clear LPCR's DP_EN bit.
     *
     * Dumb PMIC Enabled When set, software can control the system power
     */
    inline void clear_LPCR_DP_EN() volatile
    {
        LPCR &= ~(1u << 5u);
    }

    /**
     * Toggle LPCR's DP_EN bit.
     *
     * Dumb PMIC Enabled When set, software can control the system power
     */
    inline void toggle_LPCR_DP_EN() volatile
    {
        LPCR ^= 1u << 5u;
    }

    /**
     * Get LPCR's SRTC_INV_EN bit.
     *
     * If this bit is 1, in the case of a security violation the SRTC stops
     * counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
     */
    inline bool get_LPCR_SRTC_INV_EN() volatile
    {
        return LPCR & (1u << 4u);
    }

    /**
     * Set LPCR's SRTC_INV_EN bit.
     *
     * If this bit is 1, in the case of a security violation the SRTC stops
     * counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
     */
    inline void set_LPCR_SRTC_INV_EN() volatile
    {
        LPCR |= 1u << 4u;
    }

    /**
     * Clear LPCR's SRTC_INV_EN bit.
     *
     * If this bit is 1, in the case of a security violation the SRTC stops
     * counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
     */
    inline void clear_LPCR_SRTC_INV_EN() volatile
    {
        LPCR &= ~(1u << 4u);
    }

    /**
     * Toggle LPCR's SRTC_INV_EN bit.
     *
     * If this bit is 1, in the case of a security violation the SRTC stops
     * counting and the SRTC is invalidated (SRTC_ENV bit is cleared)
     */
    inline void toggle_LPCR_SRTC_INV_EN() volatile
    {
        LPCR ^= 1u << 4u;
    }

    /**
     * Get LPCR's LPWUI_EN bit.
     *
     * LP Wake-Up Interrupt Enable This interrupt line should be connected to
     * the external pin and is intended to inform the external chip about an
     * SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
     */
    inline bool get_LPCR_LPWUI_EN() volatile
    {
        return LPCR & (1u << 3u);
    }

    /**
     * Set LPCR's LPWUI_EN bit.
     *
     * LP Wake-Up Interrupt Enable This interrupt line should be connected to
     * the external pin and is intended to inform the external chip about an
     * SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
     */
    inline void set_LPCR_LPWUI_EN() volatile
    {
        LPCR |= 1u << 3u;
    }

    /**
     * Clear LPCR's LPWUI_EN bit.
     *
     * LP Wake-Up Interrupt Enable This interrupt line should be connected to
     * the external pin and is intended to inform the external chip about an
     * SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
     */
    inline void clear_LPCR_LPWUI_EN() volatile
    {
        LPCR &= ~(1u << 3u);
    }

    /**
     * Toggle LPCR's LPWUI_EN bit.
     *
     * LP Wake-Up Interrupt Enable This interrupt line should be connected to
     * the external pin and is intended to inform the external chip about an
     * SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alarm )
     */
    inline void toggle_LPCR_LPWUI_EN() volatile
    {
        LPCR ^= 1u << 3u;
    }

    /**
     * Get LPCR's MC_ENV bit.
     *
     * Monotonic Counter Enabled and Valid When set, the MC can be incremented
     * (by write transaction to the LPSMCMR or LPSMCLR)
     */
    inline bool get_LPCR_MC_ENV() volatile
    {
        return LPCR & (1u << 2u);
    }

    /**
     * Set LPCR's MC_ENV bit.
     *
     * Monotonic Counter Enabled and Valid When set, the MC can be incremented
     * (by write transaction to the LPSMCMR or LPSMCLR)
     */
    inline void set_LPCR_MC_ENV() volatile
    {
        LPCR |= 1u << 2u;
    }

    /**
     * Clear LPCR's MC_ENV bit.
     *
     * Monotonic Counter Enabled and Valid When set, the MC can be incremented
     * (by write transaction to the LPSMCMR or LPSMCLR)
     */
    inline void clear_LPCR_MC_ENV() volatile
    {
        LPCR &= ~(1u << 2u);
    }

    /**
     * Toggle LPCR's MC_ENV bit.
     *
     * Monotonic Counter Enabled and Valid When set, the MC can be incremented
     * (by write transaction to the LPSMCMR or LPSMCLR)
     */
    inline void toggle_LPCR_MC_ENV() volatile
    {
        LPCR ^= 1u << 2u;
    }

    /**
     * Get LPCR's LPTA_EN bit.
     *
     * LP Time Alarm Enable When set, the SNVS functional interrupt is asserted
     * if the LP Time Alarm Register is equal to the 32 MSBs of the secure real
     * time counter
     */
    inline bool get_LPCR_LPTA_EN() volatile
    {
        return LPCR & (1u << 1u);
    }

    /**
     * Set LPCR's LPTA_EN bit.
     *
     * LP Time Alarm Enable When set, the SNVS functional interrupt is asserted
     * if the LP Time Alarm Register is equal to the 32 MSBs of the secure real
     * time counter
     */
    inline void set_LPCR_LPTA_EN() volatile
    {
        LPCR |= 1u << 1u;
    }

    /**
     * Clear LPCR's LPTA_EN bit.
     *
     * LP Time Alarm Enable When set, the SNVS functional interrupt is asserted
     * if the LP Time Alarm Register is equal to the 32 MSBs of the secure real
     * time counter
     */
    inline void clear_LPCR_LPTA_EN() volatile
    {
        LPCR &= ~(1u << 1u);
    }

    /**
     * Toggle LPCR's LPTA_EN bit.
     *
     * LP Time Alarm Enable When set, the SNVS functional interrupt is asserted
     * if the LP Time Alarm Register is equal to the 32 MSBs of the secure real
     * time counter
     */
    inline void toggle_LPCR_LPTA_EN() volatile
    {
        LPCR ^= 1u << 1u;
    }

    /**
     * Get LPCR's SRTC_ENV bit.
     *
     * Secure Real Time Counter Enabled and Valid When set, the SRTC becomes
     * operational
     */
    inline bool get_LPCR_SRTC_ENV() volatile
    {
        return LPCR & (1u << 0u);
    }

    /**
     * Set LPCR's SRTC_ENV bit.
     *
     * Secure Real Time Counter Enabled and Valid When set, the SRTC becomes
     * operational
     */
    inline void set_LPCR_SRTC_ENV() volatile
    {
        LPCR |= 1u << 0u;
    }

    /**
     * Clear LPCR's SRTC_ENV bit.
     *
     * Secure Real Time Counter Enabled and Valid When set, the SRTC becomes
     * operational
     */
    inline void clear_LPCR_SRTC_ENV() volatile
    {
        LPCR &= ~(1u << 0u);
    }

    /**
     * Toggle LPCR's SRTC_ENV bit.
     *
     * Secure Real Time Counter Enabled and Valid When set, the SRTC becomes
     * operational
     */
    inline void toggle_LPCR_SRTC_ENV() volatile
    {
        LPCR ^= 1u << 0u;
    }

    /**
     * Get all of LPCR's bit fields.
     *
     * (read-write) SNVS_LP Control Register
     */
    inline void get_LPCR(bool &GPR_Z_DIS, bool &PK_OVERRIDE, bool &PK_EN,
                         uint8_t &ON_TIME, uint8_t &DEBOUNCE,
                         uint8_t &BTN_PRESS_TIME,
                         SNVS_LPCR_LPCALB_VAL &LPCALB_VAL, bool &LPCALB_EN,
                         bool &LVD_EN, bool &TOP, bool &DP_EN,
                         bool &SRTC_INV_EN, bool &LPWUI_EN, bool &MC_ENV,
                         bool &LPTA_EN, bool &SRTC_ENV) volatile
    {
        uint32_t curr = LPCR;

        GPR_Z_DIS = curr & (1u << 24u);
        PK_OVERRIDE = curr & (1u << 23u);
        PK_EN = curr & (1u << 22u);
        ON_TIME = (curr >> 20u) & 0b11u;
        DEBOUNCE = (curr >> 18u) & 0b11u;
        BTN_PRESS_TIME = (curr >> 16u) & 0b11u;
        LPCALB_VAL = SNVS_LPCR_LPCALB_VAL((curr >> 10u) & 0b11111u);
        LPCALB_EN = curr & (1u << 8u);
        LVD_EN = curr & (1u << 7u);
        TOP = curr & (1u << 6u);
        DP_EN = curr & (1u << 5u);
        SRTC_INV_EN = curr & (1u << 4u);
        LPWUI_EN = curr & (1u << 3u);
        MC_ENV = curr & (1u << 2u);
        LPTA_EN = curr & (1u << 1u);
        SRTC_ENV = curr & (1u << 0u);
    }

    /**
     * Set all of LPCR's bit fields.
     *
     * (read-write) SNVS_LP Control Register
     */
    inline void set_LPCR(bool GPR_Z_DIS, bool PK_OVERRIDE, bool PK_EN,
                         uint8_t ON_TIME, uint8_t DEBOUNCE,
                         uint8_t BTN_PRESS_TIME,
                         SNVS_LPCR_LPCALB_VAL LPCALB_VAL, bool LPCALB_EN,
                         bool LVD_EN, bool TOP, bool DP_EN, bool SRTC_INV_EN,
                         bool LPWUI_EN, bool MC_ENV, bool LPTA_EN,
                         bool SRTC_ENV) volatile
    {
        uint32_t curr = LPCR;

        curr &= ~(0b1u << 24u);
        curr |= (GPR_Z_DIS & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (PK_OVERRIDE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (PK_EN & 0b1u) << 22u;
        curr &= ~(0b11u << 20u);
        curr |= (ON_TIME & 0b11u) << 20u;
        curr &= ~(0b11u << 18u);
        curr |= (DEBOUNCE & 0b11u) << 18u;
        curr &= ~(0b11u << 16u);
        curr |= (BTN_PRESS_TIME & 0b11u) << 16u;
        curr &= ~(0b11111u << 10u);
        curr |= (std::to_underlying(LPCALB_VAL) & 0b11111u) << 10u;
        curr &= ~(0b1u << 8u);
        curr |= (LPCALB_EN & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (LVD_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TOP & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (DP_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SRTC_INV_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LPWUI_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (MC_ENV & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (LPTA_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRTC_ENV & 0b1u) << 0u;

        LPCR = curr;
    }

    /**
     * Get LPMKCR's ZMK_ECC_VALUE field.
     *
     * Zeroizable Master Key Error Correcting Code Value This field is
     * automatically calculated and set when one is written into ZMK_ECC_EN bit
     * of this register
     */
    inline uint16_t get_LPMKCR_ZMK_ECC_VALUE() volatile
    {
        return (LPMKCR >> 7u) & 0b111111111u;
    }

    /**
     * Get LPMKCR's ZMK_ECC_EN bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Enable Writing one to
     * this field automatically calculates and sets the ZMK ECC value in the
     * ZMK_ECC_VALUE field of this register
     */
    inline bool get_LPMKCR_ZMK_ECC_EN() volatile
    {
        return LPMKCR & (1u << 4u);
    }

    /**
     * Set LPMKCR's ZMK_ECC_EN bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Enable Writing one to
     * this field automatically calculates and sets the ZMK ECC value in the
     * ZMK_ECC_VALUE field of this register
     */
    inline void set_LPMKCR_ZMK_ECC_EN() volatile
    {
        LPMKCR |= 1u << 4u;
    }

    /**
     * Clear LPMKCR's ZMK_ECC_EN bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Enable Writing one to
     * this field automatically calculates and sets the ZMK ECC value in the
     * ZMK_ECC_VALUE field of this register
     */
    inline void clear_LPMKCR_ZMK_ECC_EN() volatile
    {
        LPMKCR &= ~(1u << 4u);
    }

    /**
     * Toggle LPMKCR's ZMK_ECC_EN bit.
     *
     * Zeroizable Master Key Error Correcting Code Check Enable Writing one to
     * this field automatically calculates and sets the ZMK ECC value in the
     * ZMK_ECC_VALUE field of this register
     */
    inline void toggle_LPMKCR_ZMK_ECC_EN() volatile
    {
        LPMKCR ^= 1u << 4u;
    }

    /**
     * Get LPMKCR's ZMK_VAL bit.
     *
     * Zeroizable Master Key Valid When set, the ZMK value can be selected by
     * the master key control block for use by cryptographic modules
     */
    inline bool get_LPMKCR_ZMK_VAL() volatile
    {
        return LPMKCR & (1u << 3u);
    }

    /**
     * Set LPMKCR's ZMK_VAL bit.
     *
     * Zeroizable Master Key Valid When set, the ZMK value can be selected by
     * the master key control block for use by cryptographic modules
     */
    inline void set_LPMKCR_ZMK_VAL() volatile
    {
        LPMKCR |= 1u << 3u;
    }

    /**
     * Clear LPMKCR's ZMK_VAL bit.
     *
     * Zeroizable Master Key Valid When set, the ZMK value can be selected by
     * the master key control block for use by cryptographic modules
     */
    inline void clear_LPMKCR_ZMK_VAL() volatile
    {
        LPMKCR &= ~(1u << 3u);
    }

    /**
     * Toggle LPMKCR's ZMK_VAL bit.
     *
     * Zeroizable Master Key Valid When set, the ZMK value can be selected by
     * the master key control block for use by cryptographic modules
     */
    inline void toggle_LPMKCR_ZMK_VAL() volatile
    {
        LPMKCR ^= 1u << 3u;
    }

    /**
     * Get LPMKCR's ZMK_HWP bit.
     *
     * Zeroizable Master Key hardware Programming mode When set, only the
     * hardware key programming mechanism can set the ZMK and software cannot
     * read it
     */
    inline bool get_LPMKCR_ZMK_HWP() volatile
    {
        return LPMKCR & (1u << 2u);
    }

    /**
     * Set LPMKCR's ZMK_HWP bit.
     *
     * Zeroizable Master Key hardware Programming mode When set, only the
     * hardware key programming mechanism can set the ZMK and software cannot
     * read it
     */
    inline void set_LPMKCR_ZMK_HWP() volatile
    {
        LPMKCR |= 1u << 2u;
    }

    /**
     * Clear LPMKCR's ZMK_HWP bit.
     *
     * Zeroizable Master Key hardware Programming mode When set, only the
     * hardware key programming mechanism can set the ZMK and software cannot
     * read it
     */
    inline void clear_LPMKCR_ZMK_HWP() volatile
    {
        LPMKCR &= ~(1u << 2u);
    }

    /**
     * Toggle LPMKCR's ZMK_HWP bit.
     *
     * Zeroizable Master Key hardware Programming mode When set, only the
     * hardware key programming mechanism can set the ZMK and software cannot
     * read it
     */
    inline void toggle_LPMKCR_ZMK_HWP() volatile
    {
        LPMKCR ^= 1u << 2u;
    }

    /**
     * Get LPMKCR's MASTER_KEY_SEL field.
     *
     * Master Key Select These bits select the SNVS Master Key output when
     * Master Key Select bits are enabled by MKS_EN bit in the HPCOMR
     */
    inline SNVS_LPMKCR_MASTER_KEY_SEL get_LPMKCR_MASTER_KEY_SEL() volatile
    {
        return SNVS_LPMKCR_MASTER_KEY_SEL((LPMKCR >> 0u) & 0b11u);
    }

    /**
     * Set LPMKCR's MASTER_KEY_SEL field.
     *
     * Master Key Select These bits select the SNVS Master Key output when
     * Master Key Select bits are enabled by MKS_EN bit in the HPCOMR
     */
    inline void set_LPMKCR_MASTER_KEY_SEL(
        SNVS_LPMKCR_MASTER_KEY_SEL value) volatile
    {
        uint32_t curr = LPMKCR;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        LPMKCR = curr;
    }

    /**
     * Get all of LPMKCR's bit fields.
     *
     * (read-write) SNVS_LP Master Key Control Register
     */
    inline void get_LPMKCR(uint16_t &ZMK_ECC_VALUE, bool &ZMK_ECC_EN,
                           bool &ZMK_VAL, bool &ZMK_HWP,
                           SNVS_LPMKCR_MASTER_KEY_SEL &MASTER_KEY_SEL) volatile
    {
        uint32_t curr = LPMKCR;

        ZMK_ECC_VALUE = (curr >> 7u) & 0b111111111u;
        ZMK_ECC_EN = curr & (1u << 4u);
        ZMK_VAL = curr & (1u << 3u);
        ZMK_HWP = curr & (1u << 2u);
        MASTER_KEY_SEL = SNVS_LPMKCR_MASTER_KEY_SEL((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of LPMKCR's bit fields.
     *
     * (read-write) SNVS_LP Master Key Control Register
     */
    inline void set_LPMKCR(bool ZMK_ECC_EN, bool ZMK_VAL, bool ZMK_HWP,
                           SNVS_LPMKCR_MASTER_KEY_SEL MASTER_KEY_SEL) volatile
    {
        uint32_t curr = LPMKCR;

        curr &= ~(0b1u << 4u);
        curr |= (ZMK_ECC_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ZMK_VAL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ZMK_HWP & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(MASTER_KEY_SEL) & 0b11u) << 0u;

        LPMKCR = curr;
    }

    /**
     * Get LPSVCR's OCOTP_EN bit.
     *
     * OCOTP attack error Enable This bit enables OCOTP attack error Input
     */
    inline bool get_LPSVCR_OCOTP_EN() volatile
    {
        return LPSVCR & (1u << 5u);
    }

    /**
     * Set LPSVCR's OCOTP_EN bit.
     *
     * OCOTP attack error Enable This bit enables OCOTP attack error Input
     */
    inline void set_LPSVCR_OCOTP_EN() volatile
    {
        LPSVCR |= 1u << 5u;
    }

    /**
     * Clear LPSVCR's OCOTP_EN bit.
     *
     * OCOTP attack error Enable This bit enables OCOTP attack error Input
     */
    inline void clear_LPSVCR_OCOTP_EN() volatile
    {
        LPSVCR &= ~(1u << 5u);
    }

    /**
     * Toggle LPSVCR's OCOTP_EN bit.
     *
     * OCOTP attack error Enable This bit enables OCOTP attack error Input
     */
    inline void toggle_LPSVCR_OCOTP_EN() volatile
    {
        LPSVCR ^= 1u << 5u;
    }

    /**
     * Get LPSVCR's SRC_EN bit.
     *
     * Internal Boot Enable This bit enables Internal Boot Input
     */
    inline bool get_LPSVCR_SRC_EN() volatile
    {
        return LPSVCR & (1u << 4u);
    }

    /**
     * Set LPSVCR's SRC_EN bit.
     *
     * Internal Boot Enable This bit enables Internal Boot Input
     */
    inline void set_LPSVCR_SRC_EN() volatile
    {
        LPSVCR |= 1u << 4u;
    }

    /**
     * Clear LPSVCR's SRC_EN bit.
     *
     * Internal Boot Enable This bit enables Internal Boot Input
     */
    inline void clear_LPSVCR_SRC_EN() volatile
    {
        LPSVCR &= ~(1u << 4u);
    }

    /**
     * Toggle LPSVCR's SRC_EN bit.
     *
     * Internal Boot Enable This bit enables Internal Boot Input
     */
    inline void toggle_LPSVCR_SRC_EN() volatile
    {
        LPSVCR ^= 1u << 4u;
    }

    /**
     * Get LPSVCR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Enable This bit enables Watchdog 2 Reset Input
     */
    inline bool get_LPSVCR_WDOG2_EN() volatile
    {
        return LPSVCR & (1u << 2u);
    }

    /**
     * Set LPSVCR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Enable This bit enables Watchdog 2 Reset Input
     */
    inline void set_LPSVCR_WDOG2_EN() volatile
    {
        LPSVCR |= 1u << 2u;
    }

    /**
     * Clear LPSVCR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Enable This bit enables Watchdog 2 Reset Input
     */
    inline void clear_LPSVCR_WDOG2_EN() volatile
    {
        LPSVCR &= ~(1u << 2u);
    }

    /**
     * Toggle LPSVCR's WDOG2_EN bit.
     *
     * Watchdog 2 Reset Enable This bit enables Watchdog 2 Reset Input
     */
    inline void toggle_LPSVCR_WDOG2_EN() volatile
    {
        LPSVCR ^= 1u << 2u;
    }

    /**
     * Get LPSVCR's JTAGC_EN bit.
     *
     * JTAG Active Enable This bit enables JTAG Active Input
     */
    inline bool get_LPSVCR_JTAGC_EN() volatile
    {
        return LPSVCR & (1u << 1u);
    }

    /**
     * Set LPSVCR's JTAGC_EN bit.
     *
     * JTAG Active Enable This bit enables JTAG Active Input
     */
    inline void set_LPSVCR_JTAGC_EN() volatile
    {
        LPSVCR |= 1u << 1u;
    }

    /**
     * Clear LPSVCR's JTAGC_EN bit.
     *
     * JTAG Active Enable This bit enables JTAG Active Input
     */
    inline void clear_LPSVCR_JTAGC_EN() volatile
    {
        LPSVCR &= ~(1u << 1u);
    }

    /**
     * Toggle LPSVCR's JTAGC_EN bit.
     *
     * JTAG Active Enable This bit enables JTAG Active Input
     */
    inline void toggle_LPSVCR_JTAGC_EN() volatile
    {
        LPSVCR ^= 1u << 1u;
    }

    /**
     * Get LPSVCR's CAAM_EN bit.
     *
     * CAAM Security Violation Enable This bit enables CAAM Security Violation
     * Input
     */
    inline bool get_LPSVCR_CAAM_EN() volatile
    {
        return LPSVCR & (1u << 0u);
    }

    /**
     * Set LPSVCR's CAAM_EN bit.
     *
     * CAAM Security Violation Enable This bit enables CAAM Security Violation
     * Input
     */
    inline void set_LPSVCR_CAAM_EN() volatile
    {
        LPSVCR |= 1u << 0u;
    }

    /**
     * Clear LPSVCR's CAAM_EN bit.
     *
     * CAAM Security Violation Enable This bit enables CAAM Security Violation
     * Input
     */
    inline void clear_LPSVCR_CAAM_EN() volatile
    {
        LPSVCR &= ~(1u << 0u);
    }

    /**
     * Toggle LPSVCR's CAAM_EN bit.
     *
     * CAAM Security Violation Enable This bit enables CAAM Security Violation
     * Input
     */
    inline void toggle_LPSVCR_CAAM_EN() volatile
    {
        LPSVCR ^= 1u << 0u;
    }

    /**
     * Get all of LPSVCR's bit fields.
     *
     * (read-write) SNVS_LP Security Violation Control Register
     */
    inline void get_LPSVCR(bool &OCOTP_EN, bool &SRC_EN, bool &WDOG2_EN,
                           bool &JTAGC_EN, bool &CAAM_EN) volatile
    {
        uint32_t curr = LPSVCR;

        OCOTP_EN = curr & (1u << 5u);
        SRC_EN = curr & (1u << 4u);
        WDOG2_EN = curr & (1u << 2u);
        JTAGC_EN = curr & (1u << 1u);
        CAAM_EN = curr & (1u << 0u);
    }

    /**
     * Set all of LPSVCR's bit fields.
     *
     * (read-write) SNVS_LP Security Violation Control Register
     */
    inline void set_LPSVCR(bool OCOTP_EN, bool SRC_EN, bool WDOG2_EN,
                           bool JTAGC_EN, bool CAAM_EN) volatile
    {
        uint32_t curr = LPSVCR;

        curr &= ~(0b1u << 5u);
        curr |= (OCOTP_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (SRC_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (WDOG2_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (JTAGC_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CAAM_EN & 0b1u) << 0u;

        LPSVCR = curr;
    }

    /**
     * Get LPTGFCR's ETGF2_EN bit.
     *
     * External Tamper Glitch Filter 2 Enable When set, enables the external
     * tamper glitch filter 2.
     */
    inline bool get_LPTGFCR_ETGF2_EN() volatile
    {
        return LPTGFCR & (1u << 31u);
    }

    /**
     * Set LPTGFCR's ETGF2_EN bit.
     *
     * External Tamper Glitch Filter 2 Enable When set, enables the external
     * tamper glitch filter 2.
     */
    inline void set_LPTGFCR_ETGF2_EN() volatile
    {
        LPTGFCR |= 1u << 31u;
    }

    /**
     * Clear LPTGFCR's ETGF2_EN bit.
     *
     * External Tamper Glitch Filter 2 Enable When set, enables the external
     * tamper glitch filter 2.
     */
    inline void clear_LPTGFCR_ETGF2_EN() volatile
    {
        LPTGFCR &= ~(1u << 31u);
    }

    /**
     * Toggle LPTGFCR's ETGF2_EN bit.
     *
     * External Tamper Glitch Filter 2 Enable When set, enables the external
     * tamper glitch filter 2.
     */
    inline void toggle_LPTGFCR_ETGF2_EN() volatile
    {
        LPTGFCR ^= 1u << 31u;
    }

    /**
     * Get LPTGFCR's ETGF2 field.
     *
     * External Tamper Glitch Filter 2 Configures the length of the digital
     * glitch filter for the external tamper 2 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGFCR_ETGF2() volatile
    {
        return (LPTGFCR >> 24u) & 0b1111111u;
    }

    /**
     * Set LPTGFCR's ETGF2 field.
     *
     * External Tamper Glitch Filter 2 Configures the length of the digital
     * glitch filter for the external tamper 2 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGFCR_ETGF2(uint8_t value) volatile
    {
        uint32_t curr = LPTGFCR;

        curr &= ~(0b1111111u << 24u);
        curr |= (value & 0b1111111u) << 24u;

        LPTGFCR = curr;
    }

    /**
     * Get LPTGFCR's ETGF1_EN bit.
     *
     * External Tamper Glitch Filter 1 Enable When set, enables the external
     * tamper glitch filter 1.
     */
    inline bool get_LPTGFCR_ETGF1_EN() volatile
    {
        return LPTGFCR & (1u << 23u);
    }

    /**
     * Set LPTGFCR's ETGF1_EN bit.
     *
     * External Tamper Glitch Filter 1 Enable When set, enables the external
     * tamper glitch filter 1.
     */
    inline void set_LPTGFCR_ETGF1_EN() volatile
    {
        LPTGFCR |= 1u << 23u;
    }

    /**
     * Clear LPTGFCR's ETGF1_EN bit.
     *
     * External Tamper Glitch Filter 1 Enable When set, enables the external
     * tamper glitch filter 1.
     */
    inline void clear_LPTGFCR_ETGF1_EN() volatile
    {
        LPTGFCR &= ~(1u << 23u);
    }

    /**
     * Toggle LPTGFCR's ETGF1_EN bit.
     *
     * External Tamper Glitch Filter 1 Enable When set, enables the external
     * tamper glitch filter 1.
     */
    inline void toggle_LPTGFCR_ETGF1_EN() volatile
    {
        LPTGFCR ^= 1u << 23u;
    }

    /**
     * Get LPTGFCR's ETGF1 field.
     *
     * External Tamper Glitch Filter 1 Configures the length of the digital
     * glitch filter for the external tamper 1 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGFCR_ETGF1() volatile
    {
        return (LPTGFCR >> 16u) & 0b1111111u;
    }

    /**
     * Set LPTGFCR's ETGF1 field.
     *
     * External Tamper Glitch Filter 1 Configures the length of the digital
     * glitch filter for the external tamper 1 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGFCR_ETGF1(uint8_t value) volatile
    {
        uint32_t curr = LPTGFCR;

        curr &= ~(0b1111111u << 16u);
        curr |= (value & 0b1111111u) << 16u;

        LPTGFCR = curr;
    }

    /**
     * Get LPTGFCR's WMTGF_EN bit.
     *
     * Wire-Mesh Tamper Glitch Filter Enable When set, enables the wire-mesh
     * tamper glitch filter
     */
    inline bool get_LPTGFCR_WMTGF_EN() volatile
    {
        return LPTGFCR & (1u << 7u);
    }

    /**
     * Set LPTGFCR's WMTGF_EN bit.
     *
     * Wire-Mesh Tamper Glitch Filter Enable When set, enables the wire-mesh
     * tamper glitch filter
     */
    inline void set_LPTGFCR_WMTGF_EN() volatile
    {
        LPTGFCR |= 1u << 7u;
    }

    /**
     * Clear LPTGFCR's WMTGF_EN bit.
     *
     * Wire-Mesh Tamper Glitch Filter Enable When set, enables the wire-mesh
     * tamper glitch filter
     */
    inline void clear_LPTGFCR_WMTGF_EN() volatile
    {
        LPTGFCR &= ~(1u << 7u);
    }

    /**
     * Toggle LPTGFCR's WMTGF_EN bit.
     *
     * Wire-Mesh Tamper Glitch Filter Enable When set, enables the wire-mesh
     * tamper glitch filter
     */
    inline void toggle_LPTGFCR_WMTGF_EN() volatile
    {
        LPTGFCR ^= 1u << 7u;
    }

    /**
     * Get LPTGFCR's WMTGF field.
     *
     * Wire-Mesh Tamper Glitch Filter Configures the length of the digital
     * glitch filter for the wire-mesh tamper 1 and 2 pins between 1 and 63
     * SRTC clock cycles
     */
    inline uint8_t get_LPTGFCR_WMTGF() volatile
    {
        return (LPTGFCR >> 0u) & 0b11111u;
    }

    /**
     * Set LPTGFCR's WMTGF field.
     *
     * Wire-Mesh Tamper Glitch Filter Configures the length of the digital
     * glitch filter for the wire-mesh tamper 1 and 2 pins between 1 and 63
     * SRTC clock cycles
     */
    inline void set_LPTGFCR_WMTGF(uint8_t value) volatile
    {
        uint32_t curr = LPTGFCR;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        LPTGFCR = curr;
    }

    /**
     * Get all of LPTGFCR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Glitch Filters Configuration Register
     */
    inline void get_LPTGFCR(bool &ETGF2_EN, uint8_t &ETGF2, bool &ETGF1_EN,
                            uint8_t &ETGF1, bool &WMTGF_EN,
                            uint8_t &WMTGF) volatile
    {
        uint32_t curr = LPTGFCR;

        ETGF2_EN = curr & (1u << 31u);
        ETGF2 = (curr >> 24u) & 0b1111111u;
        ETGF1_EN = curr & (1u << 23u);
        ETGF1 = (curr >> 16u) & 0b1111111u;
        WMTGF_EN = curr & (1u << 7u);
        WMTGF = (curr >> 0u) & 0b11111u;
    }

    /**
     * Set all of LPTGFCR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Glitch Filters Configuration Register
     */
    inline void set_LPTGFCR(bool ETGF2_EN, uint8_t ETGF2, bool ETGF1_EN,
                            uint8_t ETGF1, bool WMTGF_EN,
                            uint8_t WMTGF) volatile
    {
        uint32_t curr = LPTGFCR;

        curr &= ~(0b1u << 31u);
        curr |= (ETGF2_EN & 0b1u) << 31u;
        curr &= ~(0b1111111u << 24u);
        curr |= (ETGF2 & 0b1111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ETGF1_EN & 0b1u) << 23u;
        curr &= ~(0b1111111u << 16u);
        curr |= (ETGF1 & 0b1111111u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (WMTGF_EN & 0b1u) << 7u;
        curr &= ~(0b11111u << 0u);
        curr |= (WMTGF & 0b11111u) << 0u;

        LPTGFCR = curr;
    }

    /**
     * Get LPTDCR's OSCB bit.
     *
     * Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
     */
    inline bool get_LPTDCR_OSCB() volatile
    {
        return LPTDCR & (1u << 28u);
    }

    /**
     * Set LPTDCR's OSCB bit.
     *
     * Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
     */
    inline void set_LPTDCR_OSCB() volatile
    {
        LPTDCR |= 1u << 28u;
    }

    /**
     * Clear LPTDCR's OSCB bit.
     *
     * Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
     */
    inline void clear_LPTDCR_OSCB() volatile
    {
        LPTDCR &= ~(1u << 28u);
    }

    /**
     * Toggle LPTDCR's OSCB bit.
     *
     * Oscillator Bypass When OSCB=1 the osc_bypass signal is asserted
     */
    inline void toggle_LPTDCR_OSCB() volatile
    {
        LPTDCR ^= 1u << 28u;
    }

    /**
     * Get LPTDCR's VRC field.
     *
     * Voltage Reference Configuration These configuration bits are wired as an
     * output of the module.
     */
    inline uint8_t get_LPTDCR_VRC() volatile
    {
        return (LPTDCR >> 24u) & 0b111u;
    }

    /**
     * Set LPTDCR's VRC field.
     *
     * Voltage Reference Configuration These configuration bits are wired as an
     * output of the module.
     */
    inline void set_LPTDCR_VRC(uint8_t value) volatile
    {
        uint32_t curr = LPTDCR;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        LPTDCR = curr;
    }

    /**
     * Get LPTDCR's HTDC field.
     *
     * High Temperature Detect Configuration These configuration bits are wired
     * as an output of the module
     */
    inline uint8_t get_LPTDCR_HTDC() volatile
    {
        return (LPTDCR >> 20u) & 0b111u;
    }

    /**
     * Set LPTDCR's HTDC field.
     *
     * High Temperature Detect Configuration These configuration bits are wired
     * as an output of the module
     */
    inline void set_LPTDCR_HTDC(uint8_t value) volatile
    {
        uint32_t curr = LPTDCR;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        LPTDCR = curr;
    }

    /**
     * Get LPTDCR's LTDC field.
     *
     * Low Temp Detect Configuration These configuration bits are wired as an
     * output of the module.
     */
    inline uint8_t get_LPTDCR_LTDC() volatile
    {
        return (LPTDCR >> 16u) & 0b111u;
    }

    /**
     * Set LPTDCR's LTDC field.
     *
     * Low Temp Detect Configuration These configuration bits are wired as an
     * output of the module.
     */
    inline void set_LPTDCR_LTDC(uint8_t value) volatile
    {
        uint32_t curr = LPTDCR;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        LPTDCR = curr;
    }

    /**
     * Get LPTDCR's POR_OBSERV bit.
     *
     * Power On Reset (POR) Observability Flop The asynchronous reset input of
     * this flop is connected directly to the output of the POR analog
     * circuitry (external to the SNVS
     */
    inline bool get_LPTDCR_POR_OBSERV() volatile
    {
        return LPTDCR & (1u << 15u);
    }

    /**
     * Set LPTDCR's POR_OBSERV bit.
     *
     * Power On Reset (POR) Observability Flop The asynchronous reset input of
     * this flop is connected directly to the output of the POR analog
     * circuitry (external to the SNVS
     */
    inline void set_LPTDCR_POR_OBSERV() volatile
    {
        LPTDCR |= 1u << 15u;
    }

    /**
     * Clear LPTDCR's POR_OBSERV bit.
     *
     * Power On Reset (POR) Observability Flop The asynchronous reset input of
     * this flop is connected directly to the output of the POR analog
     * circuitry (external to the SNVS
     */
    inline void clear_LPTDCR_POR_OBSERV() volatile
    {
        LPTDCR &= ~(1u << 15u);
    }

    /**
     * Toggle LPTDCR's POR_OBSERV bit.
     *
     * Power On Reset (POR) Observability Flop The asynchronous reset input of
     * this flop is connected directly to the output of the POR analog
     * circuitry (external to the SNVS
     */
    inline void toggle_LPTDCR_POR_OBSERV() volatile
    {
        LPTDCR ^= 1u << 15u;
    }

    /**
     * Get LPTDCR's PFD_OBSERV bit.
     *
     * System Power Fail Detector (PFD) Observability Flop The asynchronous
     * reset input of this flop is connected directly to the inverted output of
     * the PFD analog circuitry (external to the SNVS block)
     */
    inline bool get_LPTDCR_PFD_OBSERV() volatile
    {
        return LPTDCR & (1u << 14u);
    }

    /**
     * Set LPTDCR's PFD_OBSERV bit.
     *
     * System Power Fail Detector (PFD) Observability Flop The asynchronous
     * reset input of this flop is connected directly to the inverted output of
     * the PFD analog circuitry (external to the SNVS block)
     */
    inline void set_LPTDCR_PFD_OBSERV() volatile
    {
        LPTDCR |= 1u << 14u;
    }

    /**
     * Clear LPTDCR's PFD_OBSERV bit.
     *
     * System Power Fail Detector (PFD) Observability Flop The asynchronous
     * reset input of this flop is connected directly to the inverted output of
     * the PFD analog circuitry (external to the SNVS block)
     */
    inline void clear_LPTDCR_PFD_OBSERV() volatile
    {
        LPTDCR &= ~(1u << 14u);
    }

    /**
     * Toggle LPTDCR's PFD_OBSERV bit.
     *
     * System Power Fail Detector (PFD) Observability Flop The asynchronous
     * reset input of this flop is connected directly to the inverted output of
     * the PFD analog circuitry (external to the SNVS block)
     */
    inline void toggle_LPTDCR_PFD_OBSERV() volatile
    {
        LPTDCR ^= 1u << 14u;
    }

    /**
     * Get LPTDCR's ET2P bit.
     *
     * External Tampering 2 Polarity This bit is used to determine the polarity
     * of external tamper 2.
     */
    inline bool get_LPTDCR_ET2P() volatile
    {
        return LPTDCR & (1u << 12u);
    }

    /**
     * Set LPTDCR's ET2P bit.
     *
     * External Tampering 2 Polarity This bit is used to determine the polarity
     * of external tamper 2.
     */
    inline void set_LPTDCR_ET2P() volatile
    {
        LPTDCR |= 1u << 12u;
    }

    /**
     * Clear LPTDCR's ET2P bit.
     *
     * External Tampering 2 Polarity This bit is used to determine the polarity
     * of external tamper 2.
     */
    inline void clear_LPTDCR_ET2P() volatile
    {
        LPTDCR &= ~(1u << 12u);
    }

    /**
     * Toggle LPTDCR's ET2P bit.
     *
     * External Tampering 2 Polarity This bit is used to determine the polarity
     * of external tamper 2.
     */
    inline void toggle_LPTDCR_ET2P() volatile
    {
        LPTDCR ^= 1u << 12u;
    }

    /**
     * Get LPTDCR's ET1P bit.
     *
     * External Tampering 1 Polarity This bit is used to determine the polarity
     * of external tamper 1.
     */
    inline bool get_LPTDCR_ET1P() volatile
    {
        return LPTDCR & (1u << 11u);
    }

    /**
     * Set LPTDCR's ET1P bit.
     *
     * External Tampering 1 Polarity This bit is used to determine the polarity
     * of external tamper 1.
     */
    inline void set_LPTDCR_ET1P() volatile
    {
        LPTDCR |= 1u << 11u;
    }

    /**
     * Clear LPTDCR's ET1P bit.
     *
     * External Tampering 1 Polarity This bit is used to determine the polarity
     * of external tamper 1.
     */
    inline void clear_LPTDCR_ET1P() volatile
    {
        LPTDCR &= ~(1u << 11u);
    }

    /**
     * Toggle LPTDCR's ET1P bit.
     *
     * External Tampering 1 Polarity This bit is used to determine the polarity
     * of external tamper 1.
     */
    inline void toggle_LPTDCR_ET1P() volatile
    {
        LPTDCR ^= 1u << 11u;
    }

    /**
     * Get LPTDCR's ET2_EN bit.
     *
     * External Tampering 2 Enable When set, external tampering 2 detection
     * generates an LP security violation
     */
    inline bool get_LPTDCR_ET2_EN() volatile
    {
        return LPTDCR & (1u << 10u);
    }

    /**
     * Set LPTDCR's ET2_EN bit.
     *
     * External Tampering 2 Enable When set, external tampering 2 detection
     * generates an LP security violation
     */
    inline void set_LPTDCR_ET2_EN() volatile
    {
        LPTDCR |= 1u << 10u;
    }

    /**
     * Clear LPTDCR's ET2_EN bit.
     *
     * External Tampering 2 Enable When set, external tampering 2 detection
     * generates an LP security violation
     */
    inline void clear_LPTDCR_ET2_EN() volatile
    {
        LPTDCR &= ~(1u << 10u);
    }

    /**
     * Toggle LPTDCR's ET2_EN bit.
     *
     * External Tampering 2 Enable When set, external tampering 2 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDCR_ET2_EN() volatile
    {
        LPTDCR ^= 1u << 10u;
    }

    /**
     * Get LPTDCR's ET1_EN bit.
     *
     * External Tampering 1 Enable When set, external tampering 1 detection
     * generates an LP security violation
     */
    inline bool get_LPTDCR_ET1_EN() volatile
    {
        return LPTDCR & (1u << 9u);
    }

    /**
     * Set LPTDCR's ET1_EN bit.
     *
     * External Tampering 1 Enable When set, external tampering 1 detection
     * generates an LP security violation
     */
    inline void set_LPTDCR_ET1_EN() volatile
    {
        LPTDCR |= 1u << 9u;
    }

    /**
     * Clear LPTDCR's ET1_EN bit.
     *
     * External Tampering 1 Enable When set, external tampering 1 detection
     * generates an LP security violation
     */
    inline void clear_LPTDCR_ET1_EN() volatile
    {
        LPTDCR &= ~(1u << 9u);
    }

    /**
     * Toggle LPTDCR's ET1_EN bit.
     *
     * External Tampering 1 Enable When set, external tampering 1 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDCR_ET1_EN() volatile
    {
        LPTDCR ^= 1u << 9u;
    }

    /**
     * Get LPTDCR's WMT2_EN bit.
     *
     * Wire-Mesh Tampering 2 Enable When set, wire-mesh tampering 2 detection
     * generates an LP security violation
     */
    inline bool get_LPTDCR_WMT2_EN() volatile
    {
        return LPTDCR & (1u << 8u);
    }

    /**
     * Set LPTDCR's WMT2_EN bit.
     *
     * Wire-Mesh Tampering 2 Enable When set, wire-mesh tampering 2 detection
     * generates an LP security violation
     */
    inline void set_LPTDCR_WMT2_EN() volatile
    {
        LPTDCR |= 1u << 8u;
    }

    /**
     * Clear LPTDCR's WMT2_EN bit.
     *
     * Wire-Mesh Tampering 2 Enable When set, wire-mesh tampering 2 detection
     * generates an LP security violation
     */
    inline void clear_LPTDCR_WMT2_EN() volatile
    {
        LPTDCR &= ~(1u << 8u);
    }

    /**
     * Toggle LPTDCR's WMT2_EN bit.
     *
     * Wire-Mesh Tampering 2 Enable When set, wire-mesh tampering 2 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDCR_WMT2_EN() volatile
    {
        LPTDCR ^= 1u << 8u;
    }

    /**
     * Get LPTDCR's WMT1_EN bit.
     *
     * Wire-Mesh Tampering 1 Enable When set, wire-mesh tampering 1 detection
     * generates an LP security violation
     */
    inline bool get_LPTDCR_WMT1_EN() volatile
    {
        return LPTDCR & (1u << 7u);
    }

    /**
     * Set LPTDCR's WMT1_EN bit.
     *
     * Wire-Mesh Tampering 1 Enable When set, wire-mesh tampering 1 detection
     * generates an LP security violation
     */
    inline void set_LPTDCR_WMT1_EN() volatile
    {
        LPTDCR |= 1u << 7u;
    }

    /**
     * Clear LPTDCR's WMT1_EN bit.
     *
     * Wire-Mesh Tampering 1 Enable When set, wire-mesh tampering 1 detection
     * generates an LP security violation
     */
    inline void clear_LPTDCR_WMT1_EN() volatile
    {
        LPTDCR &= ~(1u << 7u);
    }

    /**
     * Toggle LPTDCR's WMT1_EN bit.
     *
     * Wire-Mesh Tampering 1 Enable When set, wire-mesh tampering 1 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDCR_WMT1_EN() volatile
    {
        LPTDCR ^= 1u << 7u;
    }

    /**
     * Get LPTDCR's VT_EN bit.
     *
     * Voltage Tamper Enable Voltage Tamper Enable should be enabled 500 us
     * after setting SCSC_SOSC_CTR [VOLT_TEMP_TAMPER_EN]
     */
    inline bool get_LPTDCR_VT_EN() volatile
    {
        return LPTDCR & (1u << 6u);
    }

    /**
     * Set LPTDCR's VT_EN bit.
     *
     * Voltage Tamper Enable Voltage Tamper Enable should be enabled 500 us
     * after setting SCSC_SOSC_CTR [VOLT_TEMP_TAMPER_EN]
     */
    inline void set_LPTDCR_VT_EN() volatile
    {
        LPTDCR |= 1u << 6u;
    }

    /**
     * Clear LPTDCR's VT_EN bit.
     *
     * Voltage Tamper Enable Voltage Tamper Enable should be enabled 500 us
     * after setting SCSC_SOSC_CTR [VOLT_TEMP_TAMPER_EN]
     */
    inline void clear_LPTDCR_VT_EN() volatile
    {
        LPTDCR &= ~(1u << 6u);
    }

    /**
     * Toggle LPTDCR's VT_EN bit.
     *
     * Voltage Tamper Enable Voltage Tamper Enable should be enabled 500 us
     * after setting SCSC_SOSC_CTR [VOLT_TEMP_TAMPER_EN]
     */
    inline void toggle_LPTDCR_VT_EN() volatile
    {
        LPTDCR ^= 1u << 6u;
    }

    /**
     * Get LPTDCR's TT_EN bit.
     *
     * Temperature Tamper Enable When set, a temperature monitor tamper
     * generates an LP security violation
     */
    inline bool get_LPTDCR_TT_EN() volatile
    {
        return LPTDCR & (1u << 5u);
    }

    /**
     * Set LPTDCR's TT_EN bit.
     *
     * Temperature Tamper Enable When set, a temperature monitor tamper
     * generates an LP security violation
     */
    inline void set_LPTDCR_TT_EN() volatile
    {
        LPTDCR |= 1u << 5u;
    }

    /**
     * Clear LPTDCR's TT_EN bit.
     *
     * Temperature Tamper Enable When set, a temperature monitor tamper
     * generates an LP security violation
     */
    inline void clear_LPTDCR_TT_EN() volatile
    {
        LPTDCR &= ~(1u << 5u);
    }

    /**
     * Toggle LPTDCR's TT_EN bit.
     *
     * Temperature Tamper Enable When set, a temperature monitor tamper
     * generates an LP security violation
     */
    inline void toggle_LPTDCR_TT_EN() volatile
    {
        LPTDCR ^= 1u << 5u;
    }

    /**
     * Get LPTDCR's CT_EN bit.
     *
     * Clock Tamper Enable When set, a clock monitor tamper generates an LP
     * security violation.
     */
    inline bool get_LPTDCR_CT_EN() volatile
    {
        return LPTDCR & (1u << 4u);
    }

    /**
     * Set LPTDCR's CT_EN bit.
     *
     * Clock Tamper Enable When set, a clock monitor tamper generates an LP
     * security violation.
     */
    inline void set_LPTDCR_CT_EN() volatile
    {
        LPTDCR |= 1u << 4u;
    }

    /**
     * Clear LPTDCR's CT_EN bit.
     *
     * Clock Tamper Enable When set, a clock monitor tamper generates an LP
     * security violation.
     */
    inline void clear_LPTDCR_CT_EN() volatile
    {
        LPTDCR &= ~(1u << 4u);
    }

    /**
     * Toggle LPTDCR's CT_EN bit.
     *
     * Clock Tamper Enable When set, a clock monitor tamper generates an LP
     * security violation.
     */
    inline void toggle_LPTDCR_CT_EN() volatile
    {
        LPTDCR ^= 1u << 4u;
    }

    /**
     * Get LPTDCR's MCR_EN bit.
     *
     * MC Rollover Enable When set, an MC Rollover event generates an LP
     * security violation.
     */
    inline bool get_LPTDCR_MCR_EN() volatile
    {
        return LPTDCR & (1u << 2u);
    }

    /**
     * Set LPTDCR's MCR_EN bit.
     *
     * MC Rollover Enable When set, an MC Rollover event generates an LP
     * security violation.
     */
    inline void set_LPTDCR_MCR_EN() volatile
    {
        LPTDCR |= 1u << 2u;
    }

    /**
     * Clear LPTDCR's MCR_EN bit.
     *
     * MC Rollover Enable When set, an MC Rollover event generates an LP
     * security violation.
     */
    inline void clear_LPTDCR_MCR_EN() volatile
    {
        LPTDCR &= ~(1u << 2u);
    }

    /**
     * Toggle LPTDCR's MCR_EN bit.
     *
     * MC Rollover Enable When set, an MC Rollover event generates an LP
     * security violation.
     */
    inline void toggle_LPTDCR_MCR_EN() volatile
    {
        LPTDCR ^= 1u << 2u;
    }

    /**
     * Get LPTDCR's SRTCR_EN bit.
     *
     * SRTC Rollover Enable When set, an SRTC rollover event generates an LP
     * security violation.
     */
    inline bool get_LPTDCR_SRTCR_EN() volatile
    {
        return LPTDCR & (1u << 1u);
    }

    /**
     * Set LPTDCR's SRTCR_EN bit.
     *
     * SRTC Rollover Enable When set, an SRTC rollover event generates an LP
     * security violation.
     */
    inline void set_LPTDCR_SRTCR_EN() volatile
    {
        LPTDCR |= 1u << 1u;
    }

    /**
     * Clear LPTDCR's SRTCR_EN bit.
     *
     * SRTC Rollover Enable When set, an SRTC rollover event generates an LP
     * security violation.
     */
    inline void clear_LPTDCR_SRTCR_EN() volatile
    {
        LPTDCR &= ~(1u << 1u);
    }

    /**
     * Toggle LPTDCR's SRTCR_EN bit.
     *
     * SRTC Rollover Enable When set, an SRTC rollover event generates an LP
     * security violation.
     */
    inline void toggle_LPTDCR_SRTCR_EN() volatile
    {
        LPTDCR ^= 1u << 1u;
    }

    /**
     * Get all of LPTDCR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Detect Configuration Register
     */
    inline void get_LPTDCR(bool &OSCB, uint8_t &VRC, uint8_t &HTDC,
                           uint8_t &LTDC, bool &POR_OBSERV, bool &PFD_OBSERV,
                           bool &ET2P, bool &ET1P, bool &ET2_EN, bool &ET1_EN,
                           bool &WMT2_EN, bool &WMT1_EN, bool &VT_EN,
                           bool &TT_EN, bool &CT_EN, bool &MCR_EN,
                           bool &SRTCR_EN) volatile
    {
        uint32_t curr = LPTDCR;

        OSCB = curr & (1u << 28u);
        VRC = (curr >> 24u) & 0b111u;
        HTDC = (curr >> 20u) & 0b111u;
        LTDC = (curr >> 16u) & 0b111u;
        POR_OBSERV = curr & (1u << 15u);
        PFD_OBSERV = curr & (1u << 14u);
        ET2P = curr & (1u << 12u);
        ET1P = curr & (1u << 11u);
        ET2_EN = curr & (1u << 10u);
        ET1_EN = curr & (1u << 9u);
        WMT2_EN = curr & (1u << 8u);
        WMT1_EN = curr & (1u << 7u);
        VT_EN = curr & (1u << 6u);
        TT_EN = curr & (1u << 5u);
        CT_EN = curr & (1u << 4u);
        MCR_EN = curr & (1u << 2u);
        SRTCR_EN = curr & (1u << 1u);
    }

    /**
     * Set all of LPTDCR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Detect Configuration Register
     */
    inline void set_LPTDCR(bool OSCB, uint8_t VRC, uint8_t HTDC, uint8_t LTDC,
                           bool POR_OBSERV, bool PFD_OBSERV, bool ET2P,
                           bool ET1P, bool ET2_EN, bool ET1_EN, bool WMT2_EN,
                           bool WMT1_EN, bool VT_EN, bool TT_EN, bool CT_EN,
                           bool MCR_EN, bool SRTCR_EN) volatile
    {
        uint32_t curr = LPTDCR;

        curr &= ~(0b1u << 28u);
        curr |= (OSCB & 0b1u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (VRC & 0b111u) << 24u;
        curr &= ~(0b111u << 20u);
        curr |= (HTDC & 0b111u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (LTDC & 0b111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (POR_OBSERV & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (PFD_OBSERV & 0b1u) << 14u;
        curr &= ~(0b1u << 12u);
        curr |= (ET2P & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ET1P & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (ET2_EN & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ET1_EN & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (WMT2_EN & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (WMT1_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (VT_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TT_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CT_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (MCR_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SRTCR_EN & 0b1u) << 1u;

        LPTDCR = curr;
    }

    /**
     * Get LPSR's LPS bit.
     *
     * LP Section is Secured Indicates that the LP section is
     * provisioned/programmed in the secure or trusted state
     */
    inline bool get_LPSR_LPS() volatile
    {
        return LPSR & (1u << 31u);
    }

    /**
     * Get LPSR's LPNS bit.
     *
     * LP Section is Non-Secured Indicates that LP section was
     * provisioned/programmed in the non-secure state
     */
    inline bool get_LPSR_LPNS() volatile
    {
        return LPSR & (1u << 30u);
    }

    /**
     * Get LPSR's SPOF bit.
     *
     * Set Power Off The SPO bit is set when the power button is pressed longer
     * than the configured debounce time
     */
    inline bool get_LPSR_SPOF() volatile
    {
        return LPSR & (1u << 18u);
    }

    /**
     * Set LPSR's SPOF bit.
     *
     * Set Power Off The SPO bit is set when the power button is pressed longer
     * than the configured debounce time
     */
    inline void set_LPSR_SPOF() volatile
    {
        LPSR |= 1u << 18u;
    }

    /**
     * Clear LPSR's SPOF bit.
     *
     * Set Power Off The SPO bit is set when the power button is pressed longer
     * than the configured debounce time
     */
    inline void clear_LPSR_SPOF() volatile
    {
        LPSR &= ~(1u << 18u);
    }

    /**
     * Toggle LPSR's SPOF bit.
     *
     * Set Power Off The SPO bit is set when the power button is pressed longer
     * than the configured debounce time
     */
    inline void toggle_LPSR_SPOF() volatile
    {
        LPSR ^= 1u << 18u;
    }

    /**
     * Get LPSR's EO bit.
     *
     * Emergency Off This bit is set when a power off is requested.
     */
    inline bool get_LPSR_EO() volatile
    {
        return LPSR & (1u << 17u);
    }

    /**
     * Set LPSR's EO bit.
     *
     * Emergency Off This bit is set when a power off is requested.
     */
    inline void set_LPSR_EO() volatile
    {
        LPSR |= 1u << 17u;
    }

    /**
     * Clear LPSR's EO bit.
     *
     * Emergency Off This bit is set when a power off is requested.
     */
    inline void clear_LPSR_EO() volatile
    {
        LPSR &= ~(1u << 17u);
    }

    /**
     * Toggle LPSR's EO bit.
     *
     * Emergency Off This bit is set when a power off is requested.
     */
    inline void toggle_LPSR_EO() volatile
    {
        LPSR ^= 1u << 17u;
    }

    /**
     * Get LPSR's ESVD bit.
     *
     * External Security Violation Detected Indicates that a security violation
     * is detected on one of the HP security violation ports
     */
    inline bool get_LPSR_ESVD() volatile
    {
        return LPSR & (1u << 16u);
    }

    /**
     * Set LPSR's ESVD bit.
     *
     * External Security Violation Detected Indicates that a security violation
     * is detected on one of the HP security violation ports
     */
    inline void set_LPSR_ESVD() volatile
    {
        LPSR |= 1u << 16u;
    }

    /**
     * Clear LPSR's ESVD bit.
     *
     * External Security Violation Detected Indicates that a security violation
     * is detected on one of the HP security violation ports
     */
    inline void clear_LPSR_ESVD() volatile
    {
        LPSR &= ~(1u << 16u);
    }

    /**
     * Toggle LPSR's ESVD bit.
     *
     * External Security Violation Detected Indicates that a security violation
     * is detected on one of the HP security violation ports
     */
    inline void toggle_LPSR_ESVD() volatile
    {
        LPSR ^= 1u << 16u;
    }

    /**
     * Get LPSR's ET2D bit.
     *
     * External Tampering 2 Detected
     */
    inline bool get_LPSR_ET2D() volatile
    {
        return LPSR & (1u << 10u);
    }

    /**
     * Set LPSR's ET2D bit.
     *
     * External Tampering 2 Detected
     */
    inline void set_LPSR_ET2D() volatile
    {
        LPSR |= 1u << 10u;
    }

    /**
     * Clear LPSR's ET2D bit.
     *
     * External Tampering 2 Detected
     */
    inline void clear_LPSR_ET2D() volatile
    {
        LPSR &= ~(1u << 10u);
    }

    /**
     * Toggle LPSR's ET2D bit.
     *
     * External Tampering 2 Detected
     */
    inline void toggle_LPSR_ET2D() volatile
    {
        LPSR ^= 1u << 10u;
    }

    /**
     * Get LPSR's ET1D bit.
     *
     * External Tampering 1 Detected
     */
    inline bool get_LPSR_ET1D() volatile
    {
        return LPSR & (1u << 9u);
    }

    /**
     * Set LPSR's ET1D bit.
     *
     * External Tampering 1 Detected
     */
    inline void set_LPSR_ET1D() volatile
    {
        LPSR |= 1u << 9u;
    }

    /**
     * Clear LPSR's ET1D bit.
     *
     * External Tampering 1 Detected
     */
    inline void clear_LPSR_ET1D() volatile
    {
        LPSR &= ~(1u << 9u);
    }

    /**
     * Toggle LPSR's ET1D bit.
     *
     * External Tampering 1 Detected
     */
    inline void toggle_LPSR_ET1D() volatile
    {
        LPSR ^= 1u << 9u;
    }

    /**
     * Get LPSR's WMT2D bit.
     *
     * Wire-Mesh Tampering 2 Detected
     */
    inline bool get_LPSR_WMT2D() volatile
    {
        return LPSR & (1u << 8u);
    }

    /**
     * Set LPSR's WMT2D bit.
     *
     * Wire-Mesh Tampering 2 Detected
     */
    inline void set_LPSR_WMT2D() volatile
    {
        LPSR |= 1u << 8u;
    }

    /**
     * Clear LPSR's WMT2D bit.
     *
     * Wire-Mesh Tampering 2 Detected
     */
    inline void clear_LPSR_WMT2D() volatile
    {
        LPSR &= ~(1u << 8u);
    }

    /**
     * Toggle LPSR's WMT2D bit.
     *
     * Wire-Mesh Tampering 2 Detected
     */
    inline void toggle_LPSR_WMT2D() volatile
    {
        LPSR ^= 1u << 8u;
    }

    /**
     * Get LPSR's WMT1D bit.
     *
     * Wire-Mesh Tampering 1 Detected
     */
    inline bool get_LPSR_WMT1D() volatile
    {
        return LPSR & (1u << 7u);
    }

    /**
     * Set LPSR's WMT1D bit.
     *
     * Wire-Mesh Tampering 1 Detected
     */
    inline void set_LPSR_WMT1D() volatile
    {
        LPSR |= 1u << 7u;
    }

    /**
     * Clear LPSR's WMT1D bit.
     *
     * Wire-Mesh Tampering 1 Detected
     */
    inline void clear_LPSR_WMT1D() volatile
    {
        LPSR &= ~(1u << 7u);
    }

    /**
     * Toggle LPSR's WMT1D bit.
     *
     * Wire-Mesh Tampering 1 Detected
     */
    inline void toggle_LPSR_WMT1D() volatile
    {
        LPSR ^= 1u << 7u;
    }

    /**
     * Get LPSR's VTD bit.
     *
     * Voltage Tampering Detected
     */
    inline bool get_LPSR_VTD() volatile
    {
        return LPSR & (1u << 6u);
    }

    /**
     * Set LPSR's VTD bit.
     *
     * Voltage Tampering Detected
     */
    inline void set_LPSR_VTD() volatile
    {
        LPSR |= 1u << 6u;
    }

    /**
     * Clear LPSR's VTD bit.
     *
     * Voltage Tampering Detected
     */
    inline void clear_LPSR_VTD() volatile
    {
        LPSR &= ~(1u << 6u);
    }

    /**
     * Toggle LPSR's VTD bit.
     *
     * Voltage Tampering Detected
     */
    inline void toggle_LPSR_VTD() volatile
    {
        LPSR ^= 1u << 6u;
    }

    /**
     * Get LPSR's TTD bit.
     *
     * Temperature Tamper Detected
     */
    inline bool get_LPSR_TTD() volatile
    {
        return LPSR & (1u << 5u);
    }

    /**
     * Set LPSR's TTD bit.
     *
     * Temperature Tamper Detected
     */
    inline void set_LPSR_TTD() volatile
    {
        LPSR |= 1u << 5u;
    }

    /**
     * Clear LPSR's TTD bit.
     *
     * Temperature Tamper Detected
     */
    inline void clear_LPSR_TTD() volatile
    {
        LPSR &= ~(1u << 5u);
    }

    /**
     * Toggle LPSR's TTD bit.
     *
     * Temperature Tamper Detected
     */
    inline void toggle_LPSR_TTD() volatile
    {
        LPSR ^= 1u << 5u;
    }

    /**
     * Get LPSR's CTD bit.
     *
     * Clock Tampering Detected
     */
    inline bool get_LPSR_CTD() volatile
    {
        return LPSR & (1u << 4u);
    }

    /**
     * Set LPSR's CTD bit.
     *
     * Clock Tampering Detected
     */
    inline void set_LPSR_CTD() volatile
    {
        LPSR |= 1u << 4u;
    }

    /**
     * Clear LPSR's CTD bit.
     *
     * Clock Tampering Detected
     */
    inline void clear_LPSR_CTD() volatile
    {
        LPSR &= ~(1u << 4u);
    }

    /**
     * Toggle LPSR's CTD bit.
     *
     * Clock Tampering Detected
     */
    inline void toggle_LPSR_CTD() volatile
    {
        LPSR ^= 1u << 4u;
    }

    /**
     * Get LPSR's LVD bit.
     *
     * Digital Low Voltage Event Detected
     */
    inline bool get_LPSR_LVD() volatile
    {
        return LPSR & (1u << 3u);
    }

    /**
     * Set LPSR's LVD bit.
     *
     * Digital Low Voltage Event Detected
     */
    inline void set_LPSR_LVD() volatile
    {
        LPSR |= 1u << 3u;
    }

    /**
     * Clear LPSR's LVD bit.
     *
     * Digital Low Voltage Event Detected
     */
    inline void clear_LPSR_LVD() volatile
    {
        LPSR &= ~(1u << 3u);
    }

    /**
     * Toggle LPSR's LVD bit.
     *
     * Digital Low Voltage Event Detected
     */
    inline void toggle_LPSR_LVD() volatile
    {
        LPSR ^= 1u << 3u;
    }

    /**
     * Get LPSR's MCR bit.
     *
     * Monotonic Counter Rollover
     */
    inline bool get_LPSR_MCR() volatile
    {
        return LPSR & (1u << 2u);
    }

    /**
     * Set LPSR's MCR bit.
     *
     * Monotonic Counter Rollover
     */
    inline void set_LPSR_MCR() volatile
    {
        LPSR |= 1u << 2u;
    }

    /**
     * Clear LPSR's MCR bit.
     *
     * Monotonic Counter Rollover
     */
    inline void clear_LPSR_MCR() volatile
    {
        LPSR &= ~(1u << 2u);
    }

    /**
     * Toggle LPSR's MCR bit.
     *
     * Monotonic Counter Rollover
     */
    inline void toggle_LPSR_MCR() volatile
    {
        LPSR ^= 1u << 2u;
    }

    /**
     * Get LPSR's SRTCR bit.
     *
     * Secure Real Time Counter Rollover
     */
    inline bool get_LPSR_SRTCR() volatile
    {
        return LPSR & (1u << 1u);
    }

    /**
     * Set LPSR's SRTCR bit.
     *
     * Secure Real Time Counter Rollover
     */
    inline void set_LPSR_SRTCR() volatile
    {
        LPSR |= 1u << 1u;
    }

    /**
     * Clear LPSR's SRTCR bit.
     *
     * Secure Real Time Counter Rollover
     */
    inline void clear_LPSR_SRTCR() volatile
    {
        LPSR &= ~(1u << 1u);
    }

    /**
     * Toggle LPSR's SRTCR bit.
     *
     * Secure Real Time Counter Rollover
     */
    inline void toggle_LPSR_SRTCR() volatile
    {
        LPSR ^= 1u << 1u;
    }

    /**
     * Get LPSR's LPTA bit.
     *
     * LP Time Alarm
     */
    inline bool get_LPSR_LPTA() volatile
    {
        return LPSR & (1u << 0u);
    }

    /**
     * Set LPSR's LPTA bit.
     *
     * LP Time Alarm
     */
    inline void set_LPSR_LPTA() volatile
    {
        LPSR |= 1u << 0u;
    }

    /**
     * Clear LPSR's LPTA bit.
     *
     * LP Time Alarm
     */
    inline void clear_LPSR_LPTA() volatile
    {
        LPSR &= ~(1u << 0u);
    }

    /**
     * Toggle LPSR's LPTA bit.
     *
     * LP Time Alarm
     */
    inline void toggle_LPSR_LPTA() volatile
    {
        LPSR ^= 1u << 0u;
    }

    /**
     * Get all of LPSR's bit fields.
     *
     * (read-write) SNVS_LP Status Register
     */
    inline void get_LPSR(bool &LPS, bool &LPNS, bool &SPOF, bool &EO,
                         bool &ESVD, bool &ET2D, bool &ET1D, bool &WMT2D,
                         bool &WMT1D, bool &VTD, bool &TTD, bool &CTD,
                         bool &LVD, bool &MCR, bool &SRTCR,
                         bool &LPTA) volatile
    {
        uint32_t curr = LPSR;

        LPS = curr & (1u << 31u);
        LPNS = curr & (1u << 30u);
        SPOF = curr & (1u << 18u);
        EO = curr & (1u << 17u);
        ESVD = curr & (1u << 16u);
        ET2D = curr & (1u << 10u);
        ET1D = curr & (1u << 9u);
        WMT2D = curr & (1u << 8u);
        WMT1D = curr & (1u << 7u);
        VTD = curr & (1u << 6u);
        TTD = curr & (1u << 5u);
        CTD = curr & (1u << 4u);
        LVD = curr & (1u << 3u);
        MCR = curr & (1u << 2u);
        SRTCR = curr & (1u << 1u);
        LPTA = curr & (1u << 0u);
    }

    /**
     * Set all of LPSR's bit fields.
     *
     * (read-write) SNVS_LP Status Register
     */
    inline void set_LPSR(bool SPOF, bool EO, bool ESVD, bool ET2D, bool ET1D,
                         bool WMT2D, bool WMT1D, bool VTD, bool TTD, bool CTD,
                         bool LVD, bool MCR, bool SRTCR, bool LPTA) volatile
    {
        uint32_t curr = LPSR;

        curr &= ~(0b1u << 18u);
        curr |= (SPOF & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (EO & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ESVD & 0b1u) << 16u;
        curr &= ~(0b1u << 10u);
        curr |= (ET2D & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (ET1D & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (WMT2D & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (WMT1D & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (VTD & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TTD & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (CTD & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (LVD & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (MCR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SRTCR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (LPTA & 0b1u) << 0u;

        LPSR = curr;
    }

    /**
     * Get LPSRTCMR's SRTC field.
     *
     * LP Secure Real Time Counter The most-significant 15 bits of the SRTC
     */
    inline uint16_t get_LPSRTCMR_SRTC() volatile
    {
        return (LPSRTCMR >> 0u) & 0b111111111111111u;
    }

    /**
     * Set LPSRTCMR's SRTC field.
     *
     * LP Secure Real Time Counter The most-significant 15 bits of the SRTC
     */
    inline void set_LPSRTCMR_SRTC(uint16_t value) volatile
    {
        uint32_t curr = LPSRTCMR;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        LPSRTCMR = curr;
    }

    /**
     * Get LPSRTCLR's SRTC field.
     *
     * LP Secure Real Time Counter least-significant 32 bits This register can
     * be programmed only when SRTC is not active and not locked, meaning the
     * SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set
     */
    inline uint32_t get_LPSRTCLR_SRTC() volatile
    {
        return (LPSRTCLR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LPSRTCLR's SRTC field.
     *
     * LP Secure Real Time Counter least-significant 32 bits This register can
     * be programmed only when SRTC is not active and not locked, meaning the
     * SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set
     */
    inline void set_LPSRTCLR_SRTC(uint32_t value) volatile
    {
        uint32_t curr = LPSRTCLR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPSRTCLR = curr;
    }

    /**
     * Get LPTAR's LPTA field.
     *
     * LP Time Alarm This register can be programmed only when the LP time
     * alarm is disabled (LPTA_EN bit is not set)
     */
    inline uint32_t get_LPTAR_LPTA() volatile
    {
        return (LPTAR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LPTAR's LPTA field.
     *
     * LP Time Alarm This register can be programmed only when the LP time
     * alarm is disabled (LPTA_EN bit is not set)
     */
    inline void set_LPTAR_LPTA(uint32_t value) volatile
    {
        uint32_t curr = LPTAR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPTAR = curr;
    }

    /**
     * Get LPSMCMR's MC_ERA_BITS field.
     *
     * Monotonic Counter Era Bits These bits are inputs to the module and
     * typically connect to fuses
     */
    inline uint16_t get_LPSMCMR_MC_ERA_BITS() volatile
    {
        return (LPSMCMR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get LPSMCMR's MON_COUNTER field.
     *
     * Monotonic Counter most-significant 16 Bits Note that writing to this
     * register does not change the value of this field to the value that was
     * written
     */
    inline uint16_t get_LPSMCMR_MON_COUNTER() volatile
    {
        return (LPSMCMR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LPSMCMR's MON_COUNTER field.
     *
     * Monotonic Counter most-significant 16 Bits Note that writing to this
     * register does not change the value of this field to the value that was
     * written
     */
    inline void set_LPSMCMR_MON_COUNTER(uint16_t value) volatile
    {
        uint32_t curr = LPSMCMR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPSMCMR = curr;
    }

    /**
     * Get all of LPSMCMR's bit fields.
     *
     * (read-write) SNVS_LP Secure Monotonic Counter MSB Register
     */
    inline void get_LPSMCMR(uint16_t &MC_ERA_BITS,
                            uint16_t &MON_COUNTER) volatile
    {
        uint32_t curr = LPSMCMR;

        MC_ERA_BITS = (curr >> 16u) & 0b1111111111111111u;
        MON_COUNTER = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get LPSMCLR's MON_COUNTER field.
     *
     * Monotonic Counter bits Note that writing to this register does not
     * change the value of this field to the value that was written
     */
    inline uint32_t get_LPSMCLR_MON_COUNTER() volatile
    {
        return (LPSMCLR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LPSMCLR's MON_COUNTER field.
     *
     * Monotonic Counter bits Note that writing to this register does not
     * change the value of this field to the value that was written
     */
    inline void set_LPSMCLR_MON_COUNTER(uint32_t value) volatile
    {
        uint32_t curr = LPSMCLR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPSMCLR = curr;
    }

    /**
     * Get LPLVDR's LVD field.
     *
     * Low-Voltage Detector Value
     */
    inline uint32_t get_LPLVDR_LVD() volatile
    {
        return (LPLVDR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LPLVDR's LVD field.
     *
     * Low-Voltage Detector Value
     */
    inline void set_LPLVDR_LVD(uint32_t value) volatile
    {
        uint32_t curr = LPLVDR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPLVDR = curr;
    }

    /**
     * Get LPGPR0_legacy_alias's GPR field.
     *
     * General Purpose Register When GPR_SL or GPR_HL bit is set, the register
     * cannot be programmed.
     */
    inline uint32_t get_LPGPR0_legacy_alias_GPR() volatile
    {
        return (LPGPR0_legacy_alias >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set LPGPR0_legacy_alias's GPR field.
     *
     * General Purpose Register When GPR_SL or GPR_HL bit is set, the register
     * cannot be programmed.
     */
    inline void set_LPGPR0_legacy_alias_GPR(uint32_t value) volatile
    {
        uint32_t curr = LPGPR0_legacy_alias;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPGPR0_legacy_alias = curr;
    }

    /**
     * Get LPZMKR's ZMK field.
     *
     * Zeroizable Master Key Each of these registers contains 32 bits of the
     * 256-bit ZMK value
     */
    inline uint32_t get_LPZMKR_ZMK(std::size_t index) volatile
    {
        return (LPZMKR[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LPZMKR's ZMK field.
     *
     * Zeroizable Master Key Each of these registers contains 32 bits of the
     * 256-bit ZMK value
     */
    inline void set_LPZMKR_ZMK(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = LPZMKR[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPZMKR[index] = curr;
    }

    /**
     * Get LPGPR_alias's GPR field.
     *
     * General Purpose Register When GPR_SL or GPR_HL bit is set, the register
     * cannot be programmed.
     */
    inline uint32_t get_LPGPR_alias_GPR(std::size_t index) volatile
    {
        return (LPGPR_alias[index] >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set LPGPR_alias's GPR field.
     *
     * General Purpose Register When GPR_SL or GPR_HL bit is set, the register
     * cannot be programmed.
     */
    inline void set_LPGPR_alias_GPR(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = LPGPR_alias[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPGPR_alias[index] = curr;
    }

    /**
     * Get LPTDC2R's ET10P bit.
     *
     * External Tampering 10 Polarity This bit is used to determine the
     * polarity of external tamper 10.
     */
    inline bool get_LPTDC2R_ET10P() volatile
    {
        return LPTDC2R & (1u << 23u);
    }

    /**
     * Set LPTDC2R's ET10P bit.
     *
     * External Tampering 10 Polarity This bit is used to determine the
     * polarity of external tamper 10.
     */
    inline void set_LPTDC2R_ET10P() volatile
    {
        LPTDC2R |= 1u << 23u;
    }

    /**
     * Clear LPTDC2R's ET10P bit.
     *
     * External Tampering 10 Polarity This bit is used to determine the
     * polarity of external tamper 10.
     */
    inline void clear_LPTDC2R_ET10P() volatile
    {
        LPTDC2R &= ~(1u << 23u);
    }

    /**
     * Toggle LPTDC2R's ET10P bit.
     *
     * External Tampering 10 Polarity This bit is used to determine the
     * polarity of external tamper 10.
     */
    inline void toggle_LPTDC2R_ET10P() volatile
    {
        LPTDC2R ^= 1u << 23u;
    }

    /**
     * Get LPTDC2R's ET9P bit.
     *
     * External Tampering 9 Polarity This bit is used to determine the polarity
     * of external tamper 9.
     */
    inline bool get_LPTDC2R_ET9P() volatile
    {
        return LPTDC2R & (1u << 22u);
    }

    /**
     * Set LPTDC2R's ET9P bit.
     *
     * External Tampering 9 Polarity This bit is used to determine the polarity
     * of external tamper 9.
     */
    inline void set_LPTDC2R_ET9P() volatile
    {
        LPTDC2R |= 1u << 22u;
    }

    /**
     * Clear LPTDC2R's ET9P bit.
     *
     * External Tampering 9 Polarity This bit is used to determine the polarity
     * of external tamper 9.
     */
    inline void clear_LPTDC2R_ET9P() volatile
    {
        LPTDC2R &= ~(1u << 22u);
    }

    /**
     * Toggle LPTDC2R's ET9P bit.
     *
     * External Tampering 9 Polarity This bit is used to determine the polarity
     * of external tamper 9.
     */
    inline void toggle_LPTDC2R_ET9P() volatile
    {
        LPTDC2R ^= 1u << 22u;
    }

    /**
     * Get LPTDC2R's ET8P bit.
     *
     * External Tampering 8 Polarity This bit is used to determine the polarity
     * of external tamper 8.
     */
    inline bool get_LPTDC2R_ET8P() volatile
    {
        return LPTDC2R & (1u << 21u);
    }

    /**
     * Set LPTDC2R's ET8P bit.
     *
     * External Tampering 8 Polarity This bit is used to determine the polarity
     * of external tamper 8.
     */
    inline void set_LPTDC2R_ET8P() volatile
    {
        LPTDC2R |= 1u << 21u;
    }

    /**
     * Clear LPTDC2R's ET8P bit.
     *
     * External Tampering 8 Polarity This bit is used to determine the polarity
     * of external tamper 8.
     */
    inline void clear_LPTDC2R_ET8P() volatile
    {
        LPTDC2R &= ~(1u << 21u);
    }

    /**
     * Toggle LPTDC2R's ET8P bit.
     *
     * External Tampering 8 Polarity This bit is used to determine the polarity
     * of external tamper 8.
     */
    inline void toggle_LPTDC2R_ET8P() volatile
    {
        LPTDC2R ^= 1u << 21u;
    }

    /**
     * Get LPTDC2R's ET7P bit.
     *
     * External Tampering 7 Polarity This bit is used to determine the polarity
     * of external tamper 7.
     */
    inline bool get_LPTDC2R_ET7P() volatile
    {
        return LPTDC2R & (1u << 20u);
    }

    /**
     * Set LPTDC2R's ET7P bit.
     *
     * External Tampering 7 Polarity This bit is used to determine the polarity
     * of external tamper 7.
     */
    inline void set_LPTDC2R_ET7P() volatile
    {
        LPTDC2R |= 1u << 20u;
    }

    /**
     * Clear LPTDC2R's ET7P bit.
     *
     * External Tampering 7 Polarity This bit is used to determine the polarity
     * of external tamper 7.
     */
    inline void clear_LPTDC2R_ET7P() volatile
    {
        LPTDC2R &= ~(1u << 20u);
    }

    /**
     * Toggle LPTDC2R's ET7P bit.
     *
     * External Tampering 7 Polarity This bit is used to determine the polarity
     * of external tamper 7.
     */
    inline void toggle_LPTDC2R_ET7P() volatile
    {
        LPTDC2R ^= 1u << 20u;
    }

    /**
     * Get LPTDC2R's ET6P bit.
     *
     * External Tampering 6 Polarity This bit is used to determine the polarity
     * of external tamper 6.
     */
    inline bool get_LPTDC2R_ET6P() volatile
    {
        return LPTDC2R & (1u << 19u);
    }

    /**
     * Set LPTDC2R's ET6P bit.
     *
     * External Tampering 6 Polarity This bit is used to determine the polarity
     * of external tamper 6.
     */
    inline void set_LPTDC2R_ET6P() volatile
    {
        LPTDC2R |= 1u << 19u;
    }

    /**
     * Clear LPTDC2R's ET6P bit.
     *
     * External Tampering 6 Polarity This bit is used to determine the polarity
     * of external tamper 6.
     */
    inline void clear_LPTDC2R_ET6P() volatile
    {
        LPTDC2R &= ~(1u << 19u);
    }

    /**
     * Toggle LPTDC2R's ET6P bit.
     *
     * External Tampering 6 Polarity This bit is used to determine the polarity
     * of external tamper 6.
     */
    inline void toggle_LPTDC2R_ET6P() volatile
    {
        LPTDC2R ^= 1u << 19u;
    }

    /**
     * Get LPTDC2R's ET5P bit.
     *
     * External Tampering 5 Polarity This bit is used to determine the polarity
     * of external tamper 5.
     */
    inline bool get_LPTDC2R_ET5P() volatile
    {
        return LPTDC2R & (1u << 18u);
    }

    /**
     * Set LPTDC2R's ET5P bit.
     *
     * External Tampering 5 Polarity This bit is used to determine the polarity
     * of external tamper 5.
     */
    inline void set_LPTDC2R_ET5P() volatile
    {
        LPTDC2R |= 1u << 18u;
    }

    /**
     * Clear LPTDC2R's ET5P bit.
     *
     * External Tampering 5 Polarity This bit is used to determine the polarity
     * of external tamper 5.
     */
    inline void clear_LPTDC2R_ET5P() volatile
    {
        LPTDC2R &= ~(1u << 18u);
    }

    /**
     * Toggle LPTDC2R's ET5P bit.
     *
     * External Tampering 5 Polarity This bit is used to determine the polarity
     * of external tamper 5.
     */
    inline void toggle_LPTDC2R_ET5P() volatile
    {
        LPTDC2R ^= 1u << 18u;
    }

    /**
     * Get LPTDC2R's ET4P bit.
     *
     * External Tampering 4 Polarity This bit is used to determine the polarity
     * of external tamper 4.
     */
    inline bool get_LPTDC2R_ET4P() volatile
    {
        return LPTDC2R & (1u << 17u);
    }

    /**
     * Set LPTDC2R's ET4P bit.
     *
     * External Tampering 4 Polarity This bit is used to determine the polarity
     * of external tamper 4.
     */
    inline void set_LPTDC2R_ET4P() volatile
    {
        LPTDC2R |= 1u << 17u;
    }

    /**
     * Clear LPTDC2R's ET4P bit.
     *
     * External Tampering 4 Polarity This bit is used to determine the polarity
     * of external tamper 4.
     */
    inline void clear_LPTDC2R_ET4P() volatile
    {
        LPTDC2R &= ~(1u << 17u);
    }

    /**
     * Toggle LPTDC2R's ET4P bit.
     *
     * External Tampering 4 Polarity This bit is used to determine the polarity
     * of external tamper 4.
     */
    inline void toggle_LPTDC2R_ET4P() volatile
    {
        LPTDC2R ^= 1u << 17u;
    }

    /**
     * Get LPTDC2R's ET3P bit.
     *
     * External Tampering 3 Polarity This bit is used to determine the polarity
     * of external tamper 3.
     */
    inline bool get_LPTDC2R_ET3P() volatile
    {
        return LPTDC2R & (1u << 16u);
    }

    /**
     * Set LPTDC2R's ET3P bit.
     *
     * External Tampering 3 Polarity This bit is used to determine the polarity
     * of external tamper 3.
     */
    inline void set_LPTDC2R_ET3P() volatile
    {
        LPTDC2R |= 1u << 16u;
    }

    /**
     * Clear LPTDC2R's ET3P bit.
     *
     * External Tampering 3 Polarity This bit is used to determine the polarity
     * of external tamper 3.
     */
    inline void clear_LPTDC2R_ET3P() volatile
    {
        LPTDC2R &= ~(1u << 16u);
    }

    /**
     * Toggle LPTDC2R's ET3P bit.
     *
     * External Tampering 3 Polarity This bit is used to determine the polarity
     * of external tamper 3.
     */
    inline void toggle_LPTDC2R_ET3P() volatile
    {
        LPTDC2R ^= 1u << 16u;
    }

    /**
     * Get LPTDC2R's ET10_EN bit.
     *
     * External Tampering 10 Enable When set, external tampering 10 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET10_EN() volatile
    {
        return LPTDC2R & (1u << 7u);
    }

    /**
     * Set LPTDC2R's ET10_EN bit.
     *
     * External Tampering 10 Enable When set, external tampering 10 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET10_EN() volatile
    {
        LPTDC2R |= 1u << 7u;
    }

    /**
     * Clear LPTDC2R's ET10_EN bit.
     *
     * External Tampering 10 Enable When set, external tampering 10 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET10_EN() volatile
    {
        LPTDC2R &= ~(1u << 7u);
    }

    /**
     * Toggle LPTDC2R's ET10_EN bit.
     *
     * External Tampering 10 Enable When set, external tampering 10 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET10_EN() volatile
    {
        LPTDC2R ^= 1u << 7u;
    }

    /**
     * Get LPTDC2R's ET9_EN bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET9_EN() volatile
    {
        return LPTDC2R & (1u << 6u);
    }

    /**
     * Set LPTDC2R's ET9_EN bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET9_EN() volatile
    {
        LPTDC2R |= 1u << 6u;
    }

    /**
     * Clear LPTDC2R's ET9_EN bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET9_EN() volatile
    {
        LPTDC2R &= ~(1u << 6u);
    }

    /**
     * Toggle LPTDC2R's ET9_EN bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET9_EN() volatile
    {
        LPTDC2R ^= 1u << 6u;
    }

    /**
     * Get LPTDC2R's ET8_EN bit.
     *
     * External Tampering 8 Enable When set, external tampering 8 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET8_EN() volatile
    {
        return LPTDC2R & (1u << 5u);
    }

    /**
     * Set LPTDC2R's ET8_EN bit.
     *
     * External Tampering 8 Enable When set, external tampering 8 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET8_EN() volatile
    {
        LPTDC2R |= 1u << 5u;
    }

    /**
     * Clear LPTDC2R's ET8_EN bit.
     *
     * External Tampering 8 Enable When set, external tampering 8 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET8_EN() volatile
    {
        LPTDC2R &= ~(1u << 5u);
    }

    /**
     * Toggle LPTDC2R's ET8_EN bit.
     *
     * External Tampering 8 Enable When set, external tampering 8 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET8_EN() volatile
    {
        LPTDC2R ^= 1u << 5u;
    }

    /**
     * Get LPTDC2R's ET7_EN bit.
     *
     * External Tampering 7 Enable When set, external tampering 7 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET7_EN() volatile
    {
        return LPTDC2R & (1u << 4u);
    }

    /**
     * Set LPTDC2R's ET7_EN bit.
     *
     * External Tampering 7 Enable When set, external tampering 7 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET7_EN() volatile
    {
        LPTDC2R |= 1u << 4u;
    }

    /**
     * Clear LPTDC2R's ET7_EN bit.
     *
     * External Tampering 7 Enable When set, external tampering 7 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET7_EN() volatile
    {
        LPTDC2R &= ~(1u << 4u);
    }

    /**
     * Toggle LPTDC2R's ET7_EN bit.
     *
     * External Tampering 7 Enable When set, external tampering 7 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET7_EN() volatile
    {
        LPTDC2R ^= 1u << 4u;
    }

    /**
     * Get LPTDC2R's ET6_EN bit.
     *
     * External Tampering 6 Enable When set, external tampering 6 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET6_EN() volatile
    {
        return LPTDC2R & (1u << 3u);
    }

    /**
     * Set LPTDC2R's ET6_EN bit.
     *
     * External Tampering 6 Enable When set, external tampering 6 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET6_EN() volatile
    {
        LPTDC2R |= 1u << 3u;
    }

    /**
     * Clear LPTDC2R's ET6_EN bit.
     *
     * External Tampering 6 Enable When set, external tampering 6 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET6_EN() volatile
    {
        LPTDC2R &= ~(1u << 3u);
    }

    /**
     * Toggle LPTDC2R's ET6_EN bit.
     *
     * External Tampering 6 Enable When set, external tampering 6 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET6_EN() volatile
    {
        LPTDC2R ^= 1u << 3u;
    }

    /**
     * Get LPTDC2R's ET5_EN bit.
     *
     * External Tampering 5 Enable When set, external tampering 5 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET5_EN() volatile
    {
        return LPTDC2R & (1u << 2u);
    }

    /**
     * Set LPTDC2R's ET5_EN bit.
     *
     * External Tampering 5 Enable When set, external tampering 5 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET5_EN() volatile
    {
        LPTDC2R |= 1u << 2u;
    }

    /**
     * Clear LPTDC2R's ET5_EN bit.
     *
     * External Tampering 5 Enable When set, external tampering 5 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET5_EN() volatile
    {
        LPTDC2R &= ~(1u << 2u);
    }

    /**
     * Toggle LPTDC2R's ET5_EN bit.
     *
     * External Tampering 5 Enable When set, external tampering 5 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET5_EN() volatile
    {
        LPTDC2R ^= 1u << 2u;
    }

    /**
     * Get LPTDC2R's ET4_EN bit.
     *
     * External Tampering 4 Enable When set, external tampering 4 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET4_EN() volatile
    {
        return LPTDC2R & (1u << 1u);
    }

    /**
     * Set LPTDC2R's ET4_EN bit.
     *
     * External Tampering 4 Enable When set, external tampering 4 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET4_EN() volatile
    {
        LPTDC2R |= 1u << 1u;
    }

    /**
     * Clear LPTDC2R's ET4_EN bit.
     *
     * External Tampering 4 Enable When set, external tampering 4 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET4_EN() volatile
    {
        LPTDC2R &= ~(1u << 1u);
    }

    /**
     * Toggle LPTDC2R's ET4_EN bit.
     *
     * External Tampering 4 Enable When set, external tampering 4 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET4_EN() volatile
    {
        LPTDC2R ^= 1u << 1u;
    }

    /**
     * Get LPTDC2R's ET3_EN bit.
     *
     * External Tampering 3 Enable When set, external tampering 3 detection
     * generates an LP security violation
     */
    inline bool get_LPTDC2R_ET3_EN() volatile
    {
        return LPTDC2R & (1u << 0u);
    }

    /**
     * Set LPTDC2R's ET3_EN bit.
     *
     * External Tampering 3 Enable When set, external tampering 3 detection
     * generates an LP security violation
     */
    inline void set_LPTDC2R_ET3_EN() volatile
    {
        LPTDC2R |= 1u << 0u;
    }

    /**
     * Clear LPTDC2R's ET3_EN bit.
     *
     * External Tampering 3 Enable When set, external tampering 3 detection
     * generates an LP security violation
     */
    inline void clear_LPTDC2R_ET3_EN() volatile
    {
        LPTDC2R &= ~(1u << 0u);
    }

    /**
     * Toggle LPTDC2R's ET3_EN bit.
     *
     * External Tampering 3 Enable When set, external tampering 3 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDC2R_ET3_EN() volatile
    {
        LPTDC2R ^= 1u << 0u;
    }

    /**
     * Get all of LPTDC2R's bit fields.
     *
     * (read-write) SNVS_LP Tamper Detectors Config 2 Register
     */
    inline void get_LPTDC2R(bool &ET10P, bool &ET9P, bool &ET8P, bool &ET7P,
                            bool &ET6P, bool &ET5P, bool &ET4P, bool &ET3P,
                            bool &ET10_EN, bool &ET9_EN, bool &ET8_EN,
                            bool &ET7_EN, bool &ET6_EN, bool &ET5_EN,
                            bool &ET4_EN, bool &ET3_EN) volatile
    {
        uint32_t curr = LPTDC2R;

        ET10P = curr & (1u << 23u);
        ET9P = curr & (1u << 22u);
        ET8P = curr & (1u << 21u);
        ET7P = curr & (1u << 20u);
        ET6P = curr & (1u << 19u);
        ET5P = curr & (1u << 18u);
        ET4P = curr & (1u << 17u);
        ET3P = curr & (1u << 16u);
        ET10_EN = curr & (1u << 7u);
        ET9_EN = curr & (1u << 6u);
        ET8_EN = curr & (1u << 5u);
        ET7_EN = curr & (1u << 4u);
        ET6_EN = curr & (1u << 3u);
        ET5_EN = curr & (1u << 2u);
        ET4_EN = curr & (1u << 1u);
        ET3_EN = curr & (1u << 0u);
    }

    /**
     * Set all of LPTDC2R's bit fields.
     *
     * (read-write) SNVS_LP Tamper Detectors Config 2 Register
     */
    inline void set_LPTDC2R(bool ET10P, bool ET9P, bool ET8P, bool ET7P,
                            bool ET6P, bool ET5P, bool ET4P, bool ET3P,
                            bool ET10_EN, bool ET9_EN, bool ET8_EN,
                            bool ET7_EN, bool ET6_EN, bool ET5_EN, bool ET4_EN,
                            bool ET3_EN) volatile
    {
        uint32_t curr = LPTDC2R;

        curr &= ~(0b1u << 23u);
        curr |= (ET10P & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ET9P & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (ET8P & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (ET7P & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (ET6P & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (ET5P & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (ET4P & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (ET3P & 0b1u) << 16u;
        curr &= ~(0b1u << 7u);
        curr |= (ET10_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ET9_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ET8_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ET7_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ET6_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ET5_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ET4_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ET3_EN & 0b1u) << 0u;

        LPTDC2R = curr;
    }

    /**
     * Get LPTDSR's ET10D bit.
     *
     * External Tampering 10 Detected
     */
    inline bool get_LPTDSR_ET10D() volatile
    {
        return LPTDSR & (1u << 7u);
    }

    /**
     * Set LPTDSR's ET10D bit.
     *
     * External Tampering 10 Detected
     */
    inline void set_LPTDSR_ET10D() volatile
    {
        LPTDSR |= 1u << 7u;
    }

    /**
     * Clear LPTDSR's ET10D bit.
     *
     * External Tampering 10 Detected
     */
    inline void clear_LPTDSR_ET10D() volatile
    {
        LPTDSR &= ~(1u << 7u);
    }

    /**
     * Toggle LPTDSR's ET10D bit.
     *
     * External Tampering 10 Detected
     */
    inline void toggle_LPTDSR_ET10D() volatile
    {
        LPTDSR ^= 1u << 7u;
    }

    /**
     * Get LPTDSR's ET9D bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline bool get_LPTDSR_ET9D() volatile
    {
        return LPTDSR & (1u << 6u);
    }

    /**
     * Set LPTDSR's ET9D bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline void set_LPTDSR_ET9D() volatile
    {
        LPTDSR |= 1u << 6u;
    }

    /**
     * Clear LPTDSR's ET9D bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline void clear_LPTDSR_ET9D() volatile
    {
        LPTDSR &= ~(1u << 6u);
    }

    /**
     * Toggle LPTDSR's ET9D bit.
     *
     * External Tampering 9 Enable When set, external tampering 9 detection
     * generates an LP security violation
     */
    inline void toggle_LPTDSR_ET9D() volatile
    {
        LPTDSR ^= 1u << 6u;
    }

    /**
     * Get LPTDSR's ET8D bit.
     *
     * External Tampering 8 Detected
     */
    inline bool get_LPTDSR_ET8D() volatile
    {
        return LPTDSR & (1u << 5u);
    }

    /**
     * Set LPTDSR's ET8D bit.
     *
     * External Tampering 8 Detected
     */
    inline void set_LPTDSR_ET8D() volatile
    {
        LPTDSR |= 1u << 5u;
    }

    /**
     * Clear LPTDSR's ET8D bit.
     *
     * External Tampering 8 Detected
     */
    inline void clear_LPTDSR_ET8D() volatile
    {
        LPTDSR &= ~(1u << 5u);
    }

    /**
     * Toggle LPTDSR's ET8D bit.
     *
     * External Tampering 8 Detected
     */
    inline void toggle_LPTDSR_ET8D() volatile
    {
        LPTDSR ^= 1u << 5u;
    }

    /**
     * Get LPTDSR's ET7D bit.
     *
     * External Tampering 7 Detected
     */
    inline bool get_LPTDSR_ET7D() volatile
    {
        return LPTDSR & (1u << 4u);
    }

    /**
     * Set LPTDSR's ET7D bit.
     *
     * External Tampering 7 Detected
     */
    inline void set_LPTDSR_ET7D() volatile
    {
        LPTDSR |= 1u << 4u;
    }

    /**
     * Clear LPTDSR's ET7D bit.
     *
     * External Tampering 7 Detected
     */
    inline void clear_LPTDSR_ET7D() volatile
    {
        LPTDSR &= ~(1u << 4u);
    }

    /**
     * Toggle LPTDSR's ET7D bit.
     *
     * External Tampering 7 Detected
     */
    inline void toggle_LPTDSR_ET7D() volatile
    {
        LPTDSR ^= 1u << 4u;
    }

    /**
     * Get LPTDSR's ET6D bit.
     *
     * External Tampering 6 Detected
     */
    inline bool get_LPTDSR_ET6D() volatile
    {
        return LPTDSR & (1u << 3u);
    }

    /**
     * Set LPTDSR's ET6D bit.
     *
     * External Tampering 6 Detected
     */
    inline void set_LPTDSR_ET6D() volatile
    {
        LPTDSR |= 1u << 3u;
    }

    /**
     * Clear LPTDSR's ET6D bit.
     *
     * External Tampering 6 Detected
     */
    inline void clear_LPTDSR_ET6D() volatile
    {
        LPTDSR &= ~(1u << 3u);
    }

    /**
     * Toggle LPTDSR's ET6D bit.
     *
     * External Tampering 6 Detected
     */
    inline void toggle_LPTDSR_ET6D() volatile
    {
        LPTDSR ^= 1u << 3u;
    }

    /**
     * Get LPTDSR's ET5D bit.
     *
     * External Tampering 5 Detected
     */
    inline bool get_LPTDSR_ET5D() volatile
    {
        return LPTDSR & (1u << 2u);
    }

    /**
     * Set LPTDSR's ET5D bit.
     *
     * External Tampering 5 Detected
     */
    inline void set_LPTDSR_ET5D() volatile
    {
        LPTDSR |= 1u << 2u;
    }

    /**
     * Clear LPTDSR's ET5D bit.
     *
     * External Tampering 5 Detected
     */
    inline void clear_LPTDSR_ET5D() volatile
    {
        LPTDSR &= ~(1u << 2u);
    }

    /**
     * Toggle LPTDSR's ET5D bit.
     *
     * External Tampering 5 Detected
     */
    inline void toggle_LPTDSR_ET5D() volatile
    {
        LPTDSR ^= 1u << 2u;
    }

    /**
     * Get LPTDSR's ET4D bit.
     *
     * External Tampering 4 Detected
     */
    inline bool get_LPTDSR_ET4D() volatile
    {
        return LPTDSR & (1u << 1u);
    }

    /**
     * Set LPTDSR's ET4D bit.
     *
     * External Tampering 4 Detected
     */
    inline void set_LPTDSR_ET4D() volatile
    {
        LPTDSR |= 1u << 1u;
    }

    /**
     * Clear LPTDSR's ET4D bit.
     *
     * External Tampering 4 Detected
     */
    inline void clear_LPTDSR_ET4D() volatile
    {
        LPTDSR &= ~(1u << 1u);
    }

    /**
     * Toggle LPTDSR's ET4D bit.
     *
     * External Tampering 4 Detected
     */
    inline void toggle_LPTDSR_ET4D() volatile
    {
        LPTDSR ^= 1u << 1u;
    }

    /**
     * Get LPTDSR's ET3D bit.
     *
     * External Tampering 3 Detected
     */
    inline bool get_LPTDSR_ET3D() volatile
    {
        return LPTDSR & (1u << 0u);
    }

    /**
     * Set LPTDSR's ET3D bit.
     *
     * External Tampering 3 Detected
     */
    inline void set_LPTDSR_ET3D() volatile
    {
        LPTDSR |= 1u << 0u;
    }

    /**
     * Clear LPTDSR's ET3D bit.
     *
     * External Tampering 3 Detected
     */
    inline void clear_LPTDSR_ET3D() volatile
    {
        LPTDSR &= ~(1u << 0u);
    }

    /**
     * Toggle LPTDSR's ET3D bit.
     *
     * External Tampering 3 Detected
     */
    inline void toggle_LPTDSR_ET3D() volatile
    {
        LPTDSR ^= 1u << 0u;
    }

    /**
     * Get all of LPTDSR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Detectors Status Register
     */
    inline void get_LPTDSR(bool &ET10D, bool &ET9D, bool &ET8D, bool &ET7D,
                           bool &ET6D, bool &ET5D, bool &ET4D,
                           bool &ET3D) volatile
    {
        uint32_t curr = LPTDSR;

        ET10D = curr & (1u << 7u);
        ET9D = curr & (1u << 6u);
        ET8D = curr & (1u << 5u);
        ET7D = curr & (1u << 4u);
        ET6D = curr & (1u << 3u);
        ET5D = curr & (1u << 2u);
        ET4D = curr & (1u << 1u);
        ET3D = curr & (1u << 0u);
    }

    /**
     * Set all of LPTDSR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Detectors Status Register
     */
    inline void set_LPTDSR(bool ET10D, bool ET9D, bool ET8D, bool ET7D,
                           bool ET6D, bool ET5D, bool ET4D, bool ET3D) volatile
    {
        uint32_t curr = LPTDSR;

        curr &= ~(0b1u << 7u);
        curr |= (ET10D & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ET9D & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (ET8D & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (ET7D & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ET6D & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (ET5D & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (ET4D & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ET3D & 0b1u) << 0u;

        LPTDSR = curr;
    }

    /**
     * Get LPTGF1CR's ETGF6_EN bit.
     *
     * External Tamper Glitch Filter 6 Enable When set, enables the external
     * tamper glitch filter 6.
     */
    inline bool get_LPTGF1CR_ETGF6_EN() volatile
    {
        return LPTGF1CR & (1u << 31u);
    }

    /**
     * Set LPTGF1CR's ETGF6_EN bit.
     *
     * External Tamper Glitch Filter 6 Enable When set, enables the external
     * tamper glitch filter 6.
     */
    inline void set_LPTGF1CR_ETGF6_EN() volatile
    {
        LPTGF1CR |= 1u << 31u;
    }

    /**
     * Clear LPTGF1CR's ETGF6_EN bit.
     *
     * External Tamper Glitch Filter 6 Enable When set, enables the external
     * tamper glitch filter 6.
     */
    inline void clear_LPTGF1CR_ETGF6_EN() volatile
    {
        LPTGF1CR &= ~(1u << 31u);
    }

    /**
     * Toggle LPTGF1CR's ETGF6_EN bit.
     *
     * External Tamper Glitch Filter 6 Enable When set, enables the external
     * tamper glitch filter 6.
     */
    inline void toggle_LPTGF1CR_ETGF6_EN() volatile
    {
        LPTGF1CR ^= 1u << 31u;
    }

    /**
     * Get LPTGF1CR's ETGF6 field.
     *
     * External Tamper Glitch Filter 6 Configures the length of the digital
     * glitch filter for the external tamper 6 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF1CR_ETGF6() volatile
    {
        return (LPTGF1CR >> 24u) & 0b1111111u;
    }

    /**
     * Set LPTGF1CR's ETGF6 field.
     *
     * External Tamper Glitch Filter 6 Configures the length of the digital
     * glitch filter for the external tamper 6 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF1CR_ETGF6(uint8_t value) volatile
    {
        uint32_t curr = LPTGF1CR;

        curr &= ~(0b1111111u << 24u);
        curr |= (value & 0b1111111u) << 24u;

        LPTGF1CR = curr;
    }

    /**
     * Get LPTGF1CR's ETGF5_EN bit.
     *
     * External Tamper Glitch Filter 5 Enable When set, enables the external
     * tamper glitch filter 5.
     */
    inline bool get_LPTGF1CR_ETGF5_EN() volatile
    {
        return LPTGF1CR & (1u << 23u);
    }

    /**
     * Set LPTGF1CR's ETGF5_EN bit.
     *
     * External Tamper Glitch Filter 5 Enable When set, enables the external
     * tamper glitch filter 5.
     */
    inline void set_LPTGF1CR_ETGF5_EN() volatile
    {
        LPTGF1CR |= 1u << 23u;
    }

    /**
     * Clear LPTGF1CR's ETGF5_EN bit.
     *
     * External Tamper Glitch Filter 5 Enable When set, enables the external
     * tamper glitch filter 5.
     */
    inline void clear_LPTGF1CR_ETGF5_EN() volatile
    {
        LPTGF1CR &= ~(1u << 23u);
    }

    /**
     * Toggle LPTGF1CR's ETGF5_EN bit.
     *
     * External Tamper Glitch Filter 5 Enable When set, enables the external
     * tamper glitch filter 5.
     */
    inline void toggle_LPTGF1CR_ETGF5_EN() volatile
    {
        LPTGF1CR ^= 1u << 23u;
    }

    /**
     * Get LPTGF1CR's ETGF5 field.
     *
     * External Tamper Glitch Filter 5 Configures the length of the digital
     * glitch filter for the external tamper 5 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF1CR_ETGF5() volatile
    {
        return (LPTGF1CR >> 16u) & 0b1111111u;
    }

    /**
     * Set LPTGF1CR's ETGF5 field.
     *
     * External Tamper Glitch Filter 5 Configures the length of the digital
     * glitch filter for the external tamper 5 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF1CR_ETGF5(uint8_t value) volatile
    {
        uint32_t curr = LPTGF1CR;

        curr &= ~(0b1111111u << 16u);
        curr |= (value & 0b1111111u) << 16u;

        LPTGF1CR = curr;
    }

    /**
     * Get LPTGF1CR's ETGF4_EN bit.
     *
     * External Tamper Glitch Filter 4 Enable When set, enables the external
     * tamper glitch filter 4.
     */
    inline bool get_LPTGF1CR_ETGF4_EN() volatile
    {
        return LPTGF1CR & (1u << 15u);
    }

    /**
     * Set LPTGF1CR's ETGF4_EN bit.
     *
     * External Tamper Glitch Filter 4 Enable When set, enables the external
     * tamper glitch filter 4.
     */
    inline void set_LPTGF1CR_ETGF4_EN() volatile
    {
        LPTGF1CR |= 1u << 15u;
    }

    /**
     * Clear LPTGF1CR's ETGF4_EN bit.
     *
     * External Tamper Glitch Filter 4 Enable When set, enables the external
     * tamper glitch filter 4.
     */
    inline void clear_LPTGF1CR_ETGF4_EN() volatile
    {
        LPTGF1CR &= ~(1u << 15u);
    }

    /**
     * Toggle LPTGF1CR's ETGF4_EN bit.
     *
     * External Tamper Glitch Filter 4 Enable When set, enables the external
     * tamper glitch filter 4.
     */
    inline void toggle_LPTGF1CR_ETGF4_EN() volatile
    {
        LPTGF1CR ^= 1u << 15u;
    }

    /**
     * Get LPTGF1CR's ETGF4 field.
     *
     * External Tamper Glitch Filter 4 Configures the length of the digital
     * glitch filter for the external tamper 4 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF1CR_ETGF4() volatile
    {
        return (LPTGF1CR >> 8u) & 0b1111111u;
    }

    /**
     * Set LPTGF1CR's ETGF4 field.
     *
     * External Tamper Glitch Filter 4 Configures the length of the digital
     * glitch filter for the external tamper 4 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF1CR_ETGF4(uint8_t value) volatile
    {
        uint32_t curr = LPTGF1CR;

        curr &= ~(0b1111111u << 8u);
        curr |= (value & 0b1111111u) << 8u;

        LPTGF1CR = curr;
    }

    /**
     * Get LPTGF1CR's ETGF3_EN bit.
     *
     * External Tamper Glitch Filter 3 Enable When set, enables the external
     * tamper glitch filter 3.
     */
    inline bool get_LPTGF1CR_ETGF3_EN() volatile
    {
        return LPTGF1CR & (1u << 7u);
    }

    /**
     * Set LPTGF1CR's ETGF3_EN bit.
     *
     * External Tamper Glitch Filter 3 Enable When set, enables the external
     * tamper glitch filter 3.
     */
    inline void set_LPTGF1CR_ETGF3_EN() volatile
    {
        LPTGF1CR |= 1u << 7u;
    }

    /**
     * Clear LPTGF1CR's ETGF3_EN bit.
     *
     * External Tamper Glitch Filter 3 Enable When set, enables the external
     * tamper glitch filter 3.
     */
    inline void clear_LPTGF1CR_ETGF3_EN() volatile
    {
        LPTGF1CR &= ~(1u << 7u);
    }

    /**
     * Toggle LPTGF1CR's ETGF3_EN bit.
     *
     * External Tamper Glitch Filter 3 Enable When set, enables the external
     * tamper glitch filter 3.
     */
    inline void toggle_LPTGF1CR_ETGF3_EN() volatile
    {
        LPTGF1CR ^= 1u << 7u;
    }

    /**
     * Get LPTGF1CR's ETGF3 field.
     *
     * External Tamper Glitch Filter 3 Configures the length of the digital
     * glitch filter for the external tamper 3 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF1CR_ETGF3() volatile
    {
        return (LPTGF1CR >> 0u) & 0b1111111u;
    }

    /**
     * Set LPTGF1CR's ETGF3 field.
     *
     * External Tamper Glitch Filter 3 Configures the length of the digital
     * glitch filter for the external tamper 3 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF1CR_ETGF3(uint8_t value) volatile
    {
        uint32_t curr = LPTGF1CR;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        LPTGF1CR = curr;
    }

    /**
     * Get all of LPTGF1CR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Glitch Filter 1 Configuration Register
     */
    inline void get_LPTGF1CR(bool &ETGF6_EN, uint8_t &ETGF6, bool &ETGF5_EN,
                             uint8_t &ETGF5, bool &ETGF4_EN, uint8_t &ETGF4,
                             bool &ETGF3_EN, uint8_t &ETGF3) volatile
    {
        uint32_t curr = LPTGF1CR;

        ETGF6_EN = curr & (1u << 31u);
        ETGF6 = (curr >> 24u) & 0b1111111u;
        ETGF5_EN = curr & (1u << 23u);
        ETGF5 = (curr >> 16u) & 0b1111111u;
        ETGF4_EN = curr & (1u << 15u);
        ETGF4 = (curr >> 8u) & 0b1111111u;
        ETGF3_EN = curr & (1u << 7u);
        ETGF3 = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of LPTGF1CR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Glitch Filter 1 Configuration Register
     */
    inline void set_LPTGF1CR(bool ETGF6_EN, uint8_t ETGF6, bool ETGF5_EN,
                             uint8_t ETGF5, bool ETGF4_EN, uint8_t ETGF4,
                             bool ETGF3_EN, uint8_t ETGF3) volatile
    {
        uint32_t curr = LPTGF1CR;

        curr &= ~(0b1u << 31u);
        curr |= (ETGF6_EN & 0b1u) << 31u;
        curr &= ~(0b1111111u << 24u);
        curr |= (ETGF6 & 0b1111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ETGF5_EN & 0b1u) << 23u;
        curr &= ~(0b1111111u << 16u);
        curr |= (ETGF5 & 0b1111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ETGF4_EN & 0b1u) << 15u;
        curr &= ~(0b1111111u << 8u);
        curr |= (ETGF4 & 0b1111111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ETGF3_EN & 0b1u) << 7u;
        curr &= ~(0b1111111u << 0u);
        curr |= (ETGF3 & 0b1111111u) << 0u;

        LPTGF1CR = curr;
    }

    /**
     * Get LPTGF2CR's ETGF10_EN bit.
     *
     * External Tamper Glitch Filter 10 Enable When set, enables the external
     * tamper glitch filter 10.
     */
    inline bool get_LPTGF2CR_ETGF10_EN() volatile
    {
        return LPTGF2CR & (1u << 31u);
    }

    /**
     * Set LPTGF2CR's ETGF10_EN bit.
     *
     * External Tamper Glitch Filter 10 Enable When set, enables the external
     * tamper glitch filter 10.
     */
    inline void set_LPTGF2CR_ETGF10_EN() volatile
    {
        LPTGF2CR |= 1u << 31u;
    }

    /**
     * Clear LPTGF2CR's ETGF10_EN bit.
     *
     * External Tamper Glitch Filter 10 Enable When set, enables the external
     * tamper glitch filter 10.
     */
    inline void clear_LPTGF2CR_ETGF10_EN() volatile
    {
        LPTGF2CR &= ~(1u << 31u);
    }

    /**
     * Toggle LPTGF2CR's ETGF10_EN bit.
     *
     * External Tamper Glitch Filter 10 Enable When set, enables the external
     * tamper glitch filter 10.
     */
    inline void toggle_LPTGF2CR_ETGF10_EN() volatile
    {
        LPTGF2CR ^= 1u << 31u;
    }

    /**
     * Get LPTGF2CR's ETGF10 field.
     *
     * External Tamper Glitch Filter 10 Configures the length of the digital
     * glitch filter for the external tamper 10 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF2CR_ETGF10() volatile
    {
        return (LPTGF2CR >> 24u) & 0b1111111u;
    }

    /**
     * Set LPTGF2CR's ETGF10 field.
     *
     * External Tamper Glitch Filter 10 Configures the length of the digital
     * glitch filter for the external tamper 10 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF2CR_ETGF10(uint8_t value) volatile
    {
        uint32_t curr = LPTGF2CR;

        curr &= ~(0b1111111u << 24u);
        curr |= (value & 0b1111111u) << 24u;

        LPTGF2CR = curr;
    }

    /**
     * Get LPTGF2CR's ETGF9_EN bit.
     *
     * External Tamper Glitch Filter 9 Enable When set, enables the external
     * tamper glitch filter 9.
     */
    inline bool get_LPTGF2CR_ETGF9_EN() volatile
    {
        return LPTGF2CR & (1u << 23u);
    }

    /**
     * Set LPTGF2CR's ETGF9_EN bit.
     *
     * External Tamper Glitch Filter 9 Enable When set, enables the external
     * tamper glitch filter 9.
     */
    inline void set_LPTGF2CR_ETGF9_EN() volatile
    {
        LPTGF2CR |= 1u << 23u;
    }

    /**
     * Clear LPTGF2CR's ETGF9_EN bit.
     *
     * External Tamper Glitch Filter 9 Enable When set, enables the external
     * tamper glitch filter 9.
     */
    inline void clear_LPTGF2CR_ETGF9_EN() volatile
    {
        LPTGF2CR &= ~(1u << 23u);
    }

    /**
     * Toggle LPTGF2CR's ETGF9_EN bit.
     *
     * External Tamper Glitch Filter 9 Enable When set, enables the external
     * tamper glitch filter 9.
     */
    inline void toggle_LPTGF2CR_ETGF9_EN() volatile
    {
        LPTGF2CR ^= 1u << 23u;
    }

    /**
     * Get LPTGF2CR's ETGF9 field.
     *
     * External Tamper Glitch Filter 9 Configures the length of the digital
     * glitch filter for the external tamper 9 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF2CR_ETGF9() volatile
    {
        return (LPTGF2CR >> 16u) & 0b1111111u;
    }

    /**
     * Set LPTGF2CR's ETGF9 field.
     *
     * External Tamper Glitch Filter 9 Configures the length of the digital
     * glitch filter for the external tamper 9 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF2CR_ETGF9(uint8_t value) volatile
    {
        uint32_t curr = LPTGF2CR;

        curr &= ~(0b1111111u << 16u);
        curr |= (value & 0b1111111u) << 16u;

        LPTGF2CR = curr;
    }

    /**
     * Get LPTGF2CR's ETGF8_EN bit.
     *
     * External Tamper Glitch Filter 8 Enable When set, enables the external
     * tamper glitch filter 8.
     */
    inline bool get_LPTGF2CR_ETGF8_EN() volatile
    {
        return LPTGF2CR & (1u << 15u);
    }

    /**
     * Set LPTGF2CR's ETGF8_EN bit.
     *
     * External Tamper Glitch Filter 8 Enable When set, enables the external
     * tamper glitch filter 8.
     */
    inline void set_LPTGF2CR_ETGF8_EN() volatile
    {
        LPTGF2CR |= 1u << 15u;
    }

    /**
     * Clear LPTGF2CR's ETGF8_EN bit.
     *
     * External Tamper Glitch Filter 8 Enable When set, enables the external
     * tamper glitch filter 8.
     */
    inline void clear_LPTGF2CR_ETGF8_EN() volatile
    {
        LPTGF2CR &= ~(1u << 15u);
    }

    /**
     * Toggle LPTGF2CR's ETGF8_EN bit.
     *
     * External Tamper Glitch Filter 8 Enable When set, enables the external
     * tamper glitch filter 8.
     */
    inline void toggle_LPTGF2CR_ETGF8_EN() volatile
    {
        LPTGF2CR ^= 1u << 15u;
    }

    /**
     * Get LPTGF2CR's ETGF8 field.
     *
     * External Tamper Glitch Filter 8 Configures the length of the digital
     * glitch filter for the external tamper 8 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF2CR_ETGF8() volatile
    {
        return (LPTGF2CR >> 8u) & 0b1111111u;
    }

    /**
     * Set LPTGF2CR's ETGF8 field.
     *
     * External Tamper Glitch Filter 8 Configures the length of the digital
     * glitch filter for the external tamper 8 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF2CR_ETGF8(uint8_t value) volatile
    {
        uint32_t curr = LPTGF2CR;

        curr &= ~(0b1111111u << 8u);
        curr |= (value & 0b1111111u) << 8u;

        LPTGF2CR = curr;
    }

    /**
     * Get LPTGF2CR's ETGF7_EN bit.
     *
     * External Tamper Glitch Filter 7 Enable When set, enables the external
     * tamper glitch filter 7.
     */
    inline bool get_LPTGF2CR_ETGF7_EN() volatile
    {
        return LPTGF2CR & (1u << 7u);
    }

    /**
     * Set LPTGF2CR's ETGF7_EN bit.
     *
     * External Tamper Glitch Filter 7 Enable When set, enables the external
     * tamper glitch filter 7.
     */
    inline void set_LPTGF2CR_ETGF7_EN() volatile
    {
        LPTGF2CR |= 1u << 7u;
    }

    /**
     * Clear LPTGF2CR's ETGF7_EN bit.
     *
     * External Tamper Glitch Filter 7 Enable When set, enables the external
     * tamper glitch filter 7.
     */
    inline void clear_LPTGF2CR_ETGF7_EN() volatile
    {
        LPTGF2CR &= ~(1u << 7u);
    }

    /**
     * Toggle LPTGF2CR's ETGF7_EN bit.
     *
     * External Tamper Glitch Filter 7 Enable When set, enables the external
     * tamper glitch filter 7.
     */
    inline void toggle_LPTGF2CR_ETGF7_EN() volatile
    {
        LPTGF2CR ^= 1u << 7u;
    }

    /**
     * Get LPTGF2CR's ETGF7 field.
     *
     * External Tamper Glitch Filter 7 Configures the length of the digital
     * glitch filter for the external tamper 7 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline uint8_t get_LPTGF2CR_ETGF7() volatile
    {
        return (LPTGF2CR >> 0u) & 0b1111111u;
    }

    /**
     * Set LPTGF2CR's ETGF7 field.
     *
     * External Tamper Glitch Filter 7 Configures the length of the digital
     * glitch filter for the external tamper 7 pin between 128 and 32640 SRTC
     * clock cycles
     */
    inline void set_LPTGF2CR_ETGF7(uint8_t value) volatile
    {
        uint32_t curr = LPTGF2CR;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        LPTGF2CR = curr;
    }

    /**
     * Get all of LPTGF2CR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Glitch Filter 2 Configuration Register
     */
    inline void get_LPTGF2CR(bool &ETGF10_EN, uint8_t &ETGF10, bool &ETGF9_EN,
                             uint8_t &ETGF9, bool &ETGF8_EN, uint8_t &ETGF8,
                             bool &ETGF7_EN, uint8_t &ETGF7) volatile
    {
        uint32_t curr = LPTGF2CR;

        ETGF10_EN = curr & (1u << 31u);
        ETGF10 = (curr >> 24u) & 0b1111111u;
        ETGF9_EN = curr & (1u << 23u);
        ETGF9 = (curr >> 16u) & 0b1111111u;
        ETGF8_EN = curr & (1u << 15u);
        ETGF8 = (curr >> 8u) & 0b1111111u;
        ETGF7_EN = curr & (1u << 7u);
        ETGF7 = (curr >> 0u) & 0b1111111u;
    }

    /**
     * Set all of LPTGF2CR's bit fields.
     *
     * (read-write) SNVS_LP Tamper Glitch Filter 2 Configuration Register
     */
    inline void set_LPTGF2CR(bool ETGF10_EN, uint8_t ETGF10, bool ETGF9_EN,
                             uint8_t ETGF9, bool ETGF8_EN, uint8_t ETGF8,
                             bool ETGF7_EN, uint8_t ETGF7) volatile
    {
        uint32_t curr = LPTGF2CR;

        curr &= ~(0b1u << 31u);
        curr |= (ETGF10_EN & 0b1u) << 31u;
        curr &= ~(0b1111111u << 24u);
        curr |= (ETGF10 & 0b1111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ETGF9_EN & 0b1u) << 23u;
        curr &= ~(0b1111111u << 16u);
        curr |= (ETGF9 & 0b1111111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (ETGF8_EN & 0b1u) << 15u;
        curr &= ~(0b1111111u << 8u);
        curr |= (ETGF8 & 0b1111111u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ETGF7_EN & 0b1u) << 7u;
        curr &= ~(0b1111111u << 0u);
        curr |= (ETGF7 & 0b1111111u) << 0u;

        LPTGF2CR = curr;
    }

    /**
     * Set LPAT1CR's Polynomial field.
     *
     * Active Tamper 1 Polynomial Default Polynomial is 8400h.
     */
    inline void set_LPAT1CR_Polynomial(uint16_t value) volatile
    {
        uint32_t curr = LPAT1CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        LPAT1CR = curr;
    }

    /**
     * Set LPAT1CR's Seed field.
     *
     * Active Tamper 1 Initial Seed Default Seed is 1111h.
     */
    inline void set_LPAT1CR_Seed(uint16_t value) volatile
    {
        uint32_t curr = LPAT1CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPAT1CR = curr;
    }

    /**
     * Set all of LPAT1CR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper 1 Configuration Register
     */
    inline void set_LPAT1CR(uint16_t Polynomial, uint16_t Seed) volatile
    {
        uint32_t curr = LPAT1CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (Polynomial & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Seed & 0b1111111111111111u) << 0u;

        LPAT1CR = curr;
    }

    /**
     * Set LPAT2CR's Polynomial field.
     *
     * Active Tamper 2 Polynomial Default Polynomial is 9C00h.
     */
    inline void set_LPAT2CR_Polynomial(uint16_t value) volatile
    {
        uint32_t curr = LPAT2CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        LPAT2CR = curr;
    }

    /**
     * Set LPAT2CR's Seed field.
     *
     * Active Tamper 2 Initial Seed Default Seed is 2222h.
     */
    inline void set_LPAT2CR_Seed(uint16_t value) volatile
    {
        uint32_t curr = LPAT2CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPAT2CR = curr;
    }

    /**
     * Set all of LPAT2CR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper 2 Configuration Register
     */
    inline void set_LPAT2CR(uint16_t Polynomial, uint16_t Seed) volatile
    {
        uint32_t curr = LPAT2CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (Polynomial & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Seed & 0b1111111111111111u) << 0u;

        LPAT2CR = curr;
    }

    /**
     * Set LPAT3CR's Polynomial field.
     *
     * Active Tamper 3 Polynomial Default Polynomial is CA00h.
     */
    inline void set_LPAT3CR_Polynomial(uint16_t value) volatile
    {
        uint32_t curr = LPAT3CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        LPAT3CR = curr;
    }

    /**
     * Set LPAT3CR's Seed field.
     *
     * Active Tamper 3 Initial Seed Default Seed is 3333h.
     */
    inline void set_LPAT3CR_Seed(uint16_t value) volatile
    {
        uint32_t curr = LPAT3CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPAT3CR = curr;
    }

    /**
     * Set all of LPAT3CR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper 3 Configuration Register
     */
    inline void set_LPAT3CR(uint16_t Polynomial, uint16_t Seed) volatile
    {
        uint32_t curr = LPAT3CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (Polynomial & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Seed & 0b1111111111111111u) << 0u;

        LPAT3CR = curr;
    }

    /**
     * Set LPAT4CR's Polynomial field.
     *
     * Active Tamper 4 Polynomial Default Polynomial is 8580h.
     */
    inline void set_LPAT4CR_Polynomial(uint16_t value) volatile
    {
        uint32_t curr = LPAT4CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        LPAT4CR = curr;
    }

    /**
     * Set LPAT4CR's Seed field.
     *
     * Active Tamper 4 Initial Seed Default Seed is 4444h.
     */
    inline void set_LPAT4CR_Seed(uint16_t value) volatile
    {
        uint32_t curr = LPAT4CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPAT4CR = curr;
    }

    /**
     * Set all of LPAT4CR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper 4 Configuration Register
     */
    inline void set_LPAT4CR(uint16_t Polynomial, uint16_t Seed) volatile
    {
        uint32_t curr = LPAT4CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (Polynomial & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Seed & 0b1111111111111111u) << 0u;

        LPAT4CR = curr;
    }

    /**
     * Set LPAT5CR's Polynomial field.
     *
     * Active Tamper 5 Polynomial Default Polynomial is A840h.
     */
    inline void set_LPAT5CR_Polynomial(uint16_t value) volatile
    {
        uint32_t curr = LPAT5CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        LPAT5CR = curr;
    }

    /**
     * Set LPAT5CR's Seed field.
     *
     * Active Tamper 5 Initial Seed Default Seed is 5555h.
     */
    inline void set_LPAT5CR_Seed(uint16_t value) volatile
    {
        uint32_t curr = LPAT5CR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPAT5CR = curr;
    }

    /**
     * Set all of LPAT5CR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper 5 Configuration Register
     */
    inline void set_LPAT5CR(uint16_t Polynomial, uint16_t Seed) volatile
    {
        uint32_t curr = LPAT5CR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (Polynomial & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Seed & 0b1111111111111111u) << 0u;

        LPAT5CR = curr;
    }

    /**
     * Get LPATCTLR's AT5_PAD_EN bit.
     *
     * Active Tamper 5 Pad Out Enable When set, enables the Active Tamper 5
     * external pad.
     */
    inline bool get_LPATCTLR_AT5_PAD_EN() volatile
    {
        return LPATCTLR & (1u << 20u);
    }

    /**
     * Set LPATCTLR's AT5_PAD_EN bit.
     *
     * Active Tamper 5 Pad Out Enable When set, enables the Active Tamper 5
     * external pad.
     */
    inline void set_LPATCTLR_AT5_PAD_EN() volatile
    {
        LPATCTLR |= 1u << 20u;
    }

    /**
     * Clear LPATCTLR's AT5_PAD_EN bit.
     *
     * Active Tamper 5 Pad Out Enable When set, enables the Active Tamper 5
     * external pad.
     */
    inline void clear_LPATCTLR_AT5_PAD_EN() volatile
    {
        LPATCTLR &= ~(1u << 20u);
    }

    /**
     * Toggle LPATCTLR's AT5_PAD_EN bit.
     *
     * Active Tamper 5 Pad Out Enable When set, enables the Active Tamper 5
     * external pad.
     */
    inline void toggle_LPATCTLR_AT5_PAD_EN() volatile
    {
        LPATCTLR ^= 1u << 20u;
    }

    /**
     * Get LPATCTLR's AT4_PAD_EN bit.
     *
     * Active Tamper 4 Pad Out Enable When set, enables the Active Tamper 4
     * external pad.
     */
    inline bool get_LPATCTLR_AT4_PAD_EN() volatile
    {
        return LPATCTLR & (1u << 19u);
    }

    /**
     * Set LPATCTLR's AT4_PAD_EN bit.
     *
     * Active Tamper 4 Pad Out Enable When set, enables the Active Tamper 4
     * external pad.
     */
    inline void set_LPATCTLR_AT4_PAD_EN() volatile
    {
        LPATCTLR |= 1u << 19u;
    }

    /**
     * Clear LPATCTLR's AT4_PAD_EN bit.
     *
     * Active Tamper 4 Pad Out Enable When set, enables the Active Tamper 4
     * external pad.
     */
    inline void clear_LPATCTLR_AT4_PAD_EN() volatile
    {
        LPATCTLR &= ~(1u << 19u);
    }

    /**
     * Toggle LPATCTLR's AT4_PAD_EN bit.
     *
     * Active Tamper 4 Pad Out Enable When set, enables the Active Tamper 4
     * external pad.
     */
    inline void toggle_LPATCTLR_AT4_PAD_EN() volatile
    {
        LPATCTLR ^= 1u << 19u;
    }

    /**
     * Get LPATCTLR's AT3_PAD_EN bit.
     *
     * Active Tamper 3 Pad Out Enable When set, enables the Active Tamper 3
     * external pad.
     */
    inline bool get_LPATCTLR_AT3_PAD_EN() volatile
    {
        return LPATCTLR & (1u << 18u);
    }

    /**
     * Set LPATCTLR's AT3_PAD_EN bit.
     *
     * Active Tamper 3 Pad Out Enable When set, enables the Active Tamper 3
     * external pad.
     */
    inline void set_LPATCTLR_AT3_PAD_EN() volatile
    {
        LPATCTLR |= 1u << 18u;
    }

    /**
     * Clear LPATCTLR's AT3_PAD_EN bit.
     *
     * Active Tamper 3 Pad Out Enable When set, enables the Active Tamper 3
     * external pad.
     */
    inline void clear_LPATCTLR_AT3_PAD_EN() volatile
    {
        LPATCTLR &= ~(1u << 18u);
    }

    /**
     * Toggle LPATCTLR's AT3_PAD_EN bit.
     *
     * Active Tamper 3 Pad Out Enable When set, enables the Active Tamper 3
     * external pad.
     */
    inline void toggle_LPATCTLR_AT3_PAD_EN() volatile
    {
        LPATCTLR ^= 1u << 18u;
    }

    /**
     * Get LPATCTLR's AT2_PAD_EN bit.
     *
     * Active Tamper 2 Pad Out Enable When set, enables the Active Tamper 2
     * external pad.
     */
    inline bool get_LPATCTLR_AT2_PAD_EN() volatile
    {
        return LPATCTLR & (1u << 17u);
    }

    /**
     * Set LPATCTLR's AT2_PAD_EN bit.
     *
     * Active Tamper 2 Pad Out Enable When set, enables the Active Tamper 2
     * external pad.
     */
    inline void set_LPATCTLR_AT2_PAD_EN() volatile
    {
        LPATCTLR |= 1u << 17u;
    }

    /**
     * Clear LPATCTLR's AT2_PAD_EN bit.
     *
     * Active Tamper 2 Pad Out Enable When set, enables the Active Tamper 2
     * external pad.
     */
    inline void clear_LPATCTLR_AT2_PAD_EN() volatile
    {
        LPATCTLR &= ~(1u << 17u);
    }

    /**
     * Toggle LPATCTLR's AT2_PAD_EN bit.
     *
     * Active Tamper 2 Pad Out Enable When set, enables the Active Tamper 2
     * external pad.
     */
    inline void toggle_LPATCTLR_AT2_PAD_EN() volatile
    {
        LPATCTLR ^= 1u << 17u;
    }

    /**
     * Get LPATCTLR's AT1_PAD_EN bit.
     *
     * Active Tamper 1 Pad Out Enable When set, enables the Active Tamper 1
     * external pad.
     */
    inline bool get_LPATCTLR_AT1_PAD_EN() volatile
    {
        return LPATCTLR & (1u << 16u);
    }

    /**
     * Set LPATCTLR's AT1_PAD_EN bit.
     *
     * Active Tamper 1 Pad Out Enable When set, enables the Active Tamper 1
     * external pad.
     */
    inline void set_LPATCTLR_AT1_PAD_EN() volatile
    {
        LPATCTLR |= 1u << 16u;
    }

    /**
     * Clear LPATCTLR's AT1_PAD_EN bit.
     *
     * Active Tamper 1 Pad Out Enable When set, enables the Active Tamper 1
     * external pad.
     */
    inline void clear_LPATCTLR_AT1_PAD_EN() volatile
    {
        LPATCTLR &= ~(1u << 16u);
    }

    /**
     * Toggle LPATCTLR's AT1_PAD_EN bit.
     *
     * Active Tamper 1 Pad Out Enable When set, enables the Active Tamper 1
     * external pad.
     */
    inline void toggle_LPATCTLR_AT1_PAD_EN() volatile
    {
        LPATCTLR ^= 1u << 16u;
    }

    /**
     * Get LPATCTLR's AT5_EN bit.
     *
     * Active Tamper 5 Enable When set, enables the Active Tamper 5 LFSR.
     */
    inline bool get_LPATCTLR_AT5_EN() volatile
    {
        return LPATCTLR & (1u << 4u);
    }

    /**
     * Set LPATCTLR's AT5_EN bit.
     *
     * Active Tamper 5 Enable When set, enables the Active Tamper 5 LFSR.
     */
    inline void set_LPATCTLR_AT5_EN() volatile
    {
        LPATCTLR |= 1u << 4u;
    }

    /**
     * Clear LPATCTLR's AT5_EN bit.
     *
     * Active Tamper 5 Enable When set, enables the Active Tamper 5 LFSR.
     */
    inline void clear_LPATCTLR_AT5_EN() volatile
    {
        LPATCTLR &= ~(1u << 4u);
    }

    /**
     * Toggle LPATCTLR's AT5_EN bit.
     *
     * Active Tamper 5 Enable When set, enables the Active Tamper 5 LFSR.
     */
    inline void toggle_LPATCTLR_AT5_EN() volatile
    {
        LPATCTLR ^= 1u << 4u;
    }

    /**
     * Get LPATCTLR's AT4_EN bit.
     *
     * Active Tamper 4 Enable When set, enables the Active Tamper 4 LFSR.
     */
    inline bool get_LPATCTLR_AT4_EN() volatile
    {
        return LPATCTLR & (1u << 3u);
    }

    /**
     * Set LPATCTLR's AT4_EN bit.
     *
     * Active Tamper 4 Enable When set, enables the Active Tamper 4 LFSR.
     */
    inline void set_LPATCTLR_AT4_EN() volatile
    {
        LPATCTLR |= 1u << 3u;
    }

    /**
     * Clear LPATCTLR's AT4_EN bit.
     *
     * Active Tamper 4 Enable When set, enables the Active Tamper 4 LFSR.
     */
    inline void clear_LPATCTLR_AT4_EN() volatile
    {
        LPATCTLR &= ~(1u << 3u);
    }

    /**
     * Toggle LPATCTLR's AT4_EN bit.
     *
     * Active Tamper 4 Enable When set, enables the Active Tamper 4 LFSR.
     */
    inline void toggle_LPATCTLR_AT4_EN() volatile
    {
        LPATCTLR ^= 1u << 3u;
    }

    /**
     * Get LPATCTLR's AT3_EN bit.
     *
     * Active Tamper 3 Enable When set, enables the Active Tamper 3 LFSR.
     */
    inline bool get_LPATCTLR_AT3_EN() volatile
    {
        return LPATCTLR & (1u << 2u);
    }

    /**
     * Set LPATCTLR's AT3_EN bit.
     *
     * Active Tamper 3 Enable When set, enables the Active Tamper 3 LFSR.
     */
    inline void set_LPATCTLR_AT3_EN() volatile
    {
        LPATCTLR |= 1u << 2u;
    }

    /**
     * Clear LPATCTLR's AT3_EN bit.
     *
     * Active Tamper 3 Enable When set, enables the Active Tamper 3 LFSR.
     */
    inline void clear_LPATCTLR_AT3_EN() volatile
    {
        LPATCTLR &= ~(1u << 2u);
    }

    /**
     * Toggle LPATCTLR's AT3_EN bit.
     *
     * Active Tamper 3 Enable When set, enables the Active Tamper 3 LFSR.
     */
    inline void toggle_LPATCTLR_AT3_EN() volatile
    {
        LPATCTLR ^= 1u << 2u;
    }

    /**
     * Get LPATCTLR's AT2_EN bit.
     *
     * Active Tamper 2 Enable When set, enables the Active Tamper 2 LFSR.
     */
    inline bool get_LPATCTLR_AT2_EN() volatile
    {
        return LPATCTLR & (1u << 1u);
    }

    /**
     * Set LPATCTLR's AT2_EN bit.
     *
     * Active Tamper 2 Enable When set, enables the Active Tamper 2 LFSR.
     */
    inline void set_LPATCTLR_AT2_EN() volatile
    {
        LPATCTLR |= 1u << 1u;
    }

    /**
     * Clear LPATCTLR's AT2_EN bit.
     *
     * Active Tamper 2 Enable When set, enables the Active Tamper 2 LFSR.
     */
    inline void clear_LPATCTLR_AT2_EN() volatile
    {
        LPATCTLR &= ~(1u << 1u);
    }

    /**
     * Toggle LPATCTLR's AT2_EN bit.
     *
     * Active Tamper 2 Enable When set, enables the Active Tamper 2 LFSR.
     */
    inline void toggle_LPATCTLR_AT2_EN() volatile
    {
        LPATCTLR ^= 1u << 1u;
    }

    /**
     * Get LPATCTLR's AT1_EN bit.
     *
     * Active Tamper 1 Enable When set, enables the Active Tamper 1 LFSR.
     */
    inline bool get_LPATCTLR_AT1_EN() volatile
    {
        return LPATCTLR & (1u << 0u);
    }

    /**
     * Set LPATCTLR's AT1_EN bit.
     *
     * Active Tamper 1 Enable When set, enables the Active Tamper 1 LFSR.
     */
    inline void set_LPATCTLR_AT1_EN() volatile
    {
        LPATCTLR |= 1u << 0u;
    }

    /**
     * Clear LPATCTLR's AT1_EN bit.
     *
     * Active Tamper 1 Enable When set, enables the Active Tamper 1 LFSR.
     */
    inline void clear_LPATCTLR_AT1_EN() volatile
    {
        LPATCTLR &= ~(1u << 0u);
    }

    /**
     * Toggle LPATCTLR's AT1_EN bit.
     *
     * Active Tamper 1 Enable When set, enables the Active Tamper 1 LFSR.
     */
    inline void toggle_LPATCTLR_AT1_EN() volatile
    {
        LPATCTLR ^= 1u << 0u;
    }

    /**
     * Get all of LPATCTLR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Control Register
     */
    inline void get_LPATCTLR(bool &AT5_PAD_EN, bool &AT4_PAD_EN,
                             bool &AT3_PAD_EN, bool &AT2_PAD_EN,
                             bool &AT1_PAD_EN, bool &AT5_EN, bool &AT4_EN,
                             bool &AT3_EN, bool &AT2_EN, bool &AT1_EN) volatile
    {
        uint32_t curr = LPATCTLR;

        AT5_PAD_EN = curr & (1u << 20u);
        AT4_PAD_EN = curr & (1u << 19u);
        AT3_PAD_EN = curr & (1u << 18u);
        AT2_PAD_EN = curr & (1u << 17u);
        AT1_PAD_EN = curr & (1u << 16u);
        AT5_EN = curr & (1u << 4u);
        AT4_EN = curr & (1u << 3u);
        AT3_EN = curr & (1u << 2u);
        AT2_EN = curr & (1u << 1u);
        AT1_EN = curr & (1u << 0u);
    }

    /**
     * Set all of LPATCTLR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Control Register
     */
    inline void set_LPATCTLR(bool AT5_PAD_EN, bool AT4_PAD_EN, bool AT3_PAD_EN,
                             bool AT2_PAD_EN, bool AT1_PAD_EN, bool AT5_EN,
                             bool AT4_EN, bool AT3_EN, bool AT2_EN,
                             bool AT1_EN) volatile
    {
        uint32_t curr = LPATCTLR;

        curr &= ~(0b1u << 20u);
        curr |= (AT5_PAD_EN & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (AT4_PAD_EN & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (AT3_PAD_EN & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (AT2_PAD_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (AT1_PAD_EN & 0b1u) << 16u;
        curr &= ~(0b1u << 4u);
        curr |= (AT5_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (AT4_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AT3_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (AT2_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (AT1_EN & 0b1u) << 0u;

        LPATCTLR = curr;
    }

    /**
     * Get LPATCLKR's AT5_CLK_CTL field.
     *
     * Active Tamper 5 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline uint8_t get_LPATCLKR_AT5_CLK_CTL() volatile
    {
        return (LPATCLKR >> 16u) & 0b11u;
    }

    /**
     * Set LPATCLKR's AT5_CLK_CTL field.
     *
     * Active Tamper 5 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline void set_LPATCLKR_AT5_CLK_CTL(uint8_t value) volatile
    {
        uint32_t curr = LPATCLKR;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        LPATCLKR = curr;
    }

    /**
     * Get LPATCLKR's AT4_CLK_CTL field.
     *
     * Active Tamper 4 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline uint8_t get_LPATCLKR_AT4_CLK_CTL() volatile
    {
        return (LPATCLKR >> 12u) & 0b11u;
    }

    /**
     * Set LPATCLKR's AT4_CLK_CTL field.
     *
     * Active Tamper 4 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline void set_LPATCLKR_AT4_CLK_CTL(uint8_t value) volatile
    {
        uint32_t curr = LPATCLKR;

        curr &= ~(0b11u << 12u);
        curr |= (value & 0b11u) << 12u;

        LPATCLKR = curr;
    }

    /**
     * Get LPATCLKR's AT3_CLK_CTL field.
     *
     * Active Tamper 3 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline uint8_t get_LPATCLKR_AT3_CLK_CTL() volatile
    {
        return (LPATCLKR >> 8u) & 0b11u;
    }

    /**
     * Set LPATCLKR's AT3_CLK_CTL field.
     *
     * Active Tamper 3 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline void set_LPATCLKR_AT3_CLK_CTL(uint8_t value) volatile
    {
        uint32_t curr = LPATCLKR;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        LPATCLKR = curr;
    }

    /**
     * Get LPATCLKR's AT2_CLK_CTL field.
     *
     * Active Tamper 2 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline uint8_t get_LPATCLKR_AT2_CLK_CTL() volatile
    {
        return (LPATCLKR >> 4u) & 0b11u;
    }

    /**
     * Set LPATCLKR's AT2_CLK_CTL field.
     *
     * Active Tamper 2 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline void set_LPATCLKR_AT2_CLK_CTL(uint8_t value) volatile
    {
        uint32_t curr = LPATCLKR;

        curr &= ~(0b11u << 4u);
        curr |= (value & 0b11u) << 4u;

        LPATCLKR = curr;
    }

    /**
     * Get LPATCLKR's AT1_CLK_CTL field.
     *
     * Active Tamper 1 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline uint8_t get_LPATCLKR_AT1_CLK_CTL() volatile
    {
        return (LPATCLKR >> 0u) & 0b11u;
    }

    /**
     * Set LPATCLKR's AT1_CLK_CTL field.
     *
     * Active Tamper 1 Clock Control 00: 16hz 01: 8hz 10: 4hz 11: 2hz
     */
    inline void set_LPATCLKR_AT1_CLK_CTL(uint8_t value) volatile
    {
        uint32_t curr = LPATCLKR;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        LPATCLKR = curr;
    }

    /**
     * Get all of LPATCLKR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Clock Control Register
     */
    inline void get_LPATCLKR(uint8_t &AT5_CLK_CTL, uint8_t &AT4_CLK_CTL,
                             uint8_t &AT3_CLK_CTL, uint8_t &AT2_CLK_CTL,
                             uint8_t &AT1_CLK_CTL) volatile
    {
        uint32_t curr = LPATCLKR;

        AT5_CLK_CTL = (curr >> 16u) & 0b11u;
        AT4_CLK_CTL = (curr >> 12u) & 0b11u;
        AT3_CLK_CTL = (curr >> 8u) & 0b11u;
        AT2_CLK_CTL = (curr >> 4u) & 0b11u;
        AT1_CLK_CTL = (curr >> 0u) & 0b11u;
    }

    /**
     * Set all of LPATCLKR's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Clock Control Register
     */
    inline void set_LPATCLKR(uint8_t AT5_CLK_CTL, uint8_t AT4_CLK_CTL,
                             uint8_t AT3_CLK_CTL, uint8_t AT2_CLK_CTL,
                             uint8_t AT1_CLK_CTL) volatile
    {
        uint32_t curr = LPATCLKR;

        curr &= ~(0b11u << 16u);
        curr |= (AT5_CLK_CTL & 0b11u) << 16u;
        curr &= ~(0b11u << 12u);
        curr |= (AT4_CLK_CTL & 0b11u) << 12u;
        curr &= ~(0b11u << 8u);
        curr |= (AT3_CLK_CTL & 0b11u) << 8u;
        curr &= ~(0b11u << 4u);
        curr |= (AT2_CLK_CTL & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (AT1_CLK_CTL & 0b11u) << 0u;

        LPATCLKR = curr;
    }

    /**
     * Get LPATRC1R's ET8RCTL field.
     *
     * External Tamper 8 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET8RCTL() volatile
    {
        return (LPATRC1R >> 28u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET8RCTL field.
     *
     * External Tamper 8 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET8RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 28u);
        curr |= (value & 0b111u) << 28u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET7RCTL field.
     *
     * External Tamper 7 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET7RCTL() volatile
    {
        return (LPATRC1R >> 24u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET7RCTL field.
     *
     * External Tamper 7 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET7RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 24u);
        curr |= (value & 0b111u) << 24u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET6RCTL field.
     *
     * External Tamper 6 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET6RCTL() volatile
    {
        return (LPATRC1R >> 20u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET6RCTL field.
     *
     * External Tamper 6 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET6RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 20u);
        curr |= (value & 0b111u) << 20u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET5RCTL field.
     *
     * External Tamper 5 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET5RCTL() volatile
    {
        return (LPATRC1R >> 16u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET5RCTL field.
     *
     * External Tamper 5 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET5RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET4RCTL field.
     *
     * External Tamper 4 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET4RCTL() volatile
    {
        return (LPATRC1R >> 12u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET4RCTL field.
     *
     * External Tamper 4 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET4RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET3RCTL field.
     *
     * External Tamper 3 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET3RCTL() volatile
    {
        return (LPATRC1R >> 8u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET3RCTL field.
     *
     * External Tamper 3 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET3RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET2RCTL field.
     *
     * External Tamper 2 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET2RCTL() volatile
    {
        return (LPATRC1R >> 4u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET2RCTL field.
     *
     * External Tamper 2 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET2RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC1R's ET1RCTL field.
     *
     * External Tamper 1 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC1R_ET1RCTL() volatile
    {
        return (LPATRC1R >> 0u) & 0b111u;
    }

    /**
     * Set LPATRC1R's ET1RCTL field.
     *
     * External Tamper 1 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC1R_ET1RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        LPATRC1R = curr;
    }

    /**
     * Get all of LPATRC1R's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Routing Control 1 Register
     */
    inline void get_LPATRC1R(uint8_t &ET8RCTL, uint8_t &ET7RCTL,
                             uint8_t &ET6RCTL, uint8_t &ET5RCTL,
                             uint8_t &ET4RCTL, uint8_t &ET3RCTL,
                             uint8_t &ET2RCTL, uint8_t &ET1RCTL) volatile
    {
        uint32_t curr = LPATRC1R;

        ET8RCTL = (curr >> 28u) & 0b111u;
        ET7RCTL = (curr >> 24u) & 0b111u;
        ET6RCTL = (curr >> 20u) & 0b111u;
        ET5RCTL = (curr >> 16u) & 0b111u;
        ET4RCTL = (curr >> 12u) & 0b111u;
        ET3RCTL = (curr >> 8u) & 0b111u;
        ET2RCTL = (curr >> 4u) & 0b111u;
        ET1RCTL = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of LPATRC1R's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Routing Control 1 Register
     */
    inline void set_LPATRC1R(uint8_t ET8RCTL, uint8_t ET7RCTL, uint8_t ET6RCTL,
                             uint8_t ET5RCTL, uint8_t ET4RCTL, uint8_t ET3RCTL,
                             uint8_t ET2RCTL, uint8_t ET1RCTL) volatile
    {
        uint32_t curr = LPATRC1R;

        curr &= ~(0b111u << 28u);
        curr |= (ET8RCTL & 0b111u) << 28u;
        curr &= ~(0b111u << 24u);
        curr |= (ET7RCTL & 0b111u) << 24u;
        curr &= ~(0b111u << 20u);
        curr |= (ET6RCTL & 0b111u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (ET5RCTL & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (ET4RCTL & 0b111u) << 12u;
        curr &= ~(0b111u << 8u);
        curr |= (ET3RCTL & 0b111u) << 8u;
        curr &= ~(0b111u << 4u);
        curr |= (ET2RCTL & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (ET1RCTL & 0b111u) << 0u;

        LPATRC1R = curr;
    }

    /**
     * Get LPATRC2R's ET10RCTL field.
     *
     * External Tamper 10 Routing Control Any undefined selection will be
     * routed to passive
     */
    inline uint8_t get_LPATRC2R_ET10RCTL() volatile
    {
        return (LPATRC2R >> 4u) & 0b111u;
    }

    /**
     * Set LPATRC2R's ET10RCTL field.
     *
     * External Tamper 10 Routing Control Any undefined selection will be
     * routed to passive
     */
    inline void set_LPATRC2R_ET10RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC2R;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        LPATRC2R = curr;
    }

    /**
     * Get LPATRC2R's ET9RCTL field.
     *
     * External Tamper 9 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline uint8_t get_LPATRC2R_ET9RCTL() volatile
    {
        return (LPATRC2R >> 0u) & 0b111u;
    }

    /**
     * Set LPATRC2R's ET9RCTL field.
     *
     * External Tamper 9 Routing Control Any undefined selection will be routed
     * to passive
     */
    inline void set_LPATRC2R_ET9RCTL(uint8_t value) volatile
    {
        uint32_t curr = LPATRC2R;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        LPATRC2R = curr;
    }

    /**
     * Get all of LPATRC2R's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Routing Control 2 Register
     */
    inline void get_LPATRC2R(uint8_t &ET10RCTL, uint8_t &ET9RCTL) volatile
    {
        uint32_t curr = LPATRC2R;

        ET10RCTL = (curr >> 4u) & 0b111u;
        ET9RCTL = (curr >> 0u) & 0b111u;
    }

    /**
     * Set all of LPATRC2R's bit fields.
     *
     * (read-write) SNVS_LP Active Tamper Routing Control 2 Register
     */
    inline void set_LPATRC2R(uint8_t ET10RCTL, uint8_t ET9RCTL) volatile
    {
        uint32_t curr = LPATRC2R;

        curr &= ~(0b111u << 4u);
        curr |= (ET10RCTL & 0b111u) << 4u;
        curr &= ~(0b111u << 0u);
        curr |= (ET9RCTL & 0b111u) << 0u;

        LPATRC2R = curr;
    }

    /**
     * Get LPGPR's GPR field.
     *
     * General Purpose Register When GPR_SL or GPR_HL bit is set, the register
     * cannot be programmed.
     */
    inline uint32_t get_LPGPR_GPR(std::size_t index) volatile
    {
        return (LPGPR[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LPGPR's GPR field.
     *
     * General Purpose Register When GPR_SL or GPR_HL bit is set, the register
     * cannot be programmed.
     */
    inline void set_LPGPR_GPR(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = LPGPR[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LPGPR[index] = curr;
    }

    /**
     * Get HPVIDR1's IP_ID field.
     *
     * SNVS block ID
     */
    inline uint16_t get_HPVIDR1_IP_ID() volatile
    {
        return (HPVIDR1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Get HPVIDR1's MAJOR_REV field.
     *
     * SNVS block major version number
     */
    inline uint8_t get_HPVIDR1_MAJOR_REV() volatile
    {
        return (HPVIDR1 >> 8u) & 0b11111111u;
    }

    /**
     * Get HPVIDR1's MINOR_REV field.
     *
     * SNVS block minor version number
     */
    inline uint8_t get_HPVIDR1_MINOR_REV() volatile
    {
        return (HPVIDR1 >> 0u) & 0b11111111u;
    }

    /**
     * Get all of HPVIDR1's bit fields.
     *
     * (read-write) SNVS_HP Version ID Register 1
     */
    inline void get_HPVIDR1(uint16_t &IP_ID, uint8_t &MAJOR_REV,
                            uint8_t &MINOR_REV) volatile
    {
        uint32_t curr = HPVIDR1;

        IP_ID = (curr >> 16u) & 0b1111111111111111u;
        MAJOR_REV = (curr >> 8u) & 0b11111111u;
        MINOR_REV = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Get HPVIDR2's IP_ERA field.
     *
     * IP Era 00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5 06h - Era 6
     */
    inline uint8_t get_HPVIDR2_IP_ERA() volatile
    {
        return (HPVIDR2 >> 24u) & 0b11111111u;
    }

    /**
     * Get HPVIDR2's ECO_REV field.
     *
     * SNVS ECO Revision The engineering change order revision number for this
     * release of SNVS.
     */
    inline uint8_t get_HPVIDR2_ECO_REV() volatile
    {
        return (HPVIDR2 >> 8u) & 0b11111111u;
    }

    /**
     * Get all of HPVIDR2's bit fields.
     *
     * (read-write) SNVS_HP Version ID Register 2
     */
    inline void get_HPVIDR2(uint8_t &IP_ERA, uint8_t &ECO_REV) volatile
    {
        uint32_t curr = HPVIDR2;

        IP_ERA = (curr >> 24u) & 0b11111111u;
        ECO_REV = (curr >> 8u) & 0b11111111u;
    }
};

static_assert(sizeof(snvs) == snvs::size);

static volatile snvs *const SNVS = reinterpret_cast<snvs *>(0x40C90000);

}; // namespace MIMXRT1176::CM7
