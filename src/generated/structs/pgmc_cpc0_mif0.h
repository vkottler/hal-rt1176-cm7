/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * PGMC_MIF
 */
struct [[gnu::packed]] pgmc_cpc0_mif0
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        180; /*!< pgmc_cpc0_mif0's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint32_t MIF_AUTHEN_CTRL; /*!< (read-write) MIF Authentication Control */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t MIF_MLPL_SLEEP; /*!< (read-write) MIF MLPL control of SLEEP */
    static constexpr std::size_t reserved_padding2_length = 3;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t MIF_MLPL_IG; /*!< (read-write) MIF MLPL control of IG */
    static constexpr std::size_t reserved_padding3_length = 3;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t MIF_MLPL_LS; /*!< (read-write) MIF MLPL control of LS */
    static constexpr std::size_t reserved_padding4_length = 3;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t MIF_MLPL_HS; /*!< (read-write) MIF MLPL control of HS */
    static constexpr std::size_t reserved_padding5_length = 3;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t MIF_MLPL_STDBY; /*!< (read-write) MIF MLPL control of STDBY */
    static constexpr std::size_t reserved_padding6_length = 3;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t MIF_MLPL_ARR_PDN; /*!< (read-write) MIF MLPL control of array
                                  power down */
    static constexpr std::size_t reserved_padding7_length = 3;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t MIF_MLPL_PER_PDN; /*!< (read-write) MIF MLPL control of peripheral
                                  power down */
    static constexpr std::size_t reserved_padding8_length = 3;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t MIF_MLPL_INITN; /*!< (read-write) MIF MLPL control of INITN */
    static constexpr std::size_t reserved_padding9_length = 11;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t
        MIF_MLPL_ISO; /*!< (read-write) MIF MLPL control of isolation enable */

    /* Methods. */

    /**
     * Get MIF_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline bool get_MIF_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        return MIF_AUTHEN_CTRL & (1u << 20u);
    }

    /**
     * Set MIF_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void set_MIF_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        MIF_AUTHEN_CTRL |= 1u << 20u;
    }

    /**
     * Clear MIF_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void clear_MIF_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        MIF_AUTHEN_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle MIF_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void toggle_MIF_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        MIF_AUTHEN_CTRL ^= 1u << 20u;
    }

    /**
     * Get MIF_MLPL_SLEEP's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_SLEEP_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_SLEEP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_SLEEP's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_SLEEP_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_SLEEP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_SLEEP = curr;
    }

    /**
     * Get MIF_MLPL_IG's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_IG_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_IG >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_IG's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_IG_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_IG;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_IG = curr;
    }

    /**
     * Get MIF_MLPL_LS's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_LS_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_LS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_LS's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_LS_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_LS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_LS = curr;
    }

    /**
     * Get MIF_MLPL_HS's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_HS_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_HS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_HS's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_HS_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_HS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_HS = curr;
    }

    /**
     * Get MIF_MLPL_STDBY's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_STDBY_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_STDBY >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_STDBY's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_STDBY_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_STDBY;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_STDBY = curr;
    }

    /**
     * Get MIF_MLPL_ARR_PDN's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_ARR_PDN_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_ARR_PDN >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_ARR_PDN's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_ARR_PDN_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_ARR_PDN;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_ARR_PDN = curr;
    }

    /**
     * Get MIF_MLPL_PER_PDN's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_PER_PDN_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_PER_PDN >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_PER_PDN's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_PER_PDN_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_PER_PDN;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_PER_PDN = curr;
    }

    /**
     * Get MIF_MLPL_INITN's BYPASS_VDD_OK bit.
     *
     * Bypass vdd_ok. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline bool get_MIF_MLPL_INITN_BYPASS_VDD_OK() volatile
    {
        return MIF_MLPL_INITN & (1u << 31u);
    }

    /**
     * Set MIF_MLPL_INITN's BYPASS_VDD_OK bit.
     *
     * Bypass vdd_ok. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_MIF_MLPL_INITN_BYPASS_VDD_OK() volatile
    {
        MIF_MLPL_INITN |= 1u << 31u;
    }

    /**
     * Clear MIF_MLPL_INITN's BYPASS_VDD_OK bit.
     *
     * Bypass vdd_ok. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void clear_MIF_MLPL_INITN_BYPASS_VDD_OK() volatile
    {
        MIF_MLPL_INITN &= ~(1u << 31u);
    }

    /**
     * Toggle MIF_MLPL_INITN's BYPASS_VDD_OK bit.
     *
     * Bypass vdd_ok. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void toggle_MIF_MLPL_INITN_BYPASS_VDD_OK() volatile
    {
        MIF_MLPL_INITN ^= 1u << 31u;
    }

    /**
     * Get MIF_MLPL_INITN's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_INITN_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_INITN >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_INITN's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_INITN_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_INITN;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_INITN = curr;
    }

    /**
     * Get all of MIF_MLPL_INITN's bit fields.
     *
     * (read-write) MIF MLPL control of INITN
     */
    inline void get_MIF_MLPL_INITN(bool &BYPASS_VDD_OK,
                                   uint16_t &MLPL_CTRL) volatile
    {
        uint32_t curr = MIF_MLPL_INITN;

        BYPASS_VDD_OK = curr & (1u << 31u);
        MLPL_CTRL = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of MIF_MLPL_INITN's bit fields.
     *
     * (read-write) MIF MLPL control of INITN
     */
    inline void set_MIF_MLPL_INITN(bool BYPASS_VDD_OK,
                                   uint16_t MLPL_CTRL) volatile
    {
        uint32_t curr = MIF_MLPL_INITN;

        curr &= ~(0b1u << 31u);
        curr |= (BYPASS_VDD_OK & 0b1u) << 31u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (MLPL_CTRL & 0b1111111111111111u) << 0u;

        MIF_MLPL_INITN = curr;
    }

    /**
     * Get MIF_MLPL_ISO's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline uint16_t get_MIF_MLPL_ISO_MLPL_CTRL() volatile
    {
        return (MIF_MLPL_ISO >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MIF_MLPL_ISO's MLPL_CTRL field.
     *
     * Signal behavior at each MLPL
     */
    inline void set_MIF_MLPL_ISO_MLPL_CTRL(uint16_t value) volatile
    {
        uint32_t curr = MIF_MLPL_ISO;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MIF_MLPL_ISO = curr;
    }
};

static_assert(sizeof(pgmc_cpc0_mif0) == pgmc_cpc0_mif0::size);

static volatile pgmc_cpc0_mif0 *const PGMC_CPC0_MIF0 =
    reinterpret_cast<pgmc_cpc0_mif0 *>(0x40C89100);

static volatile pgmc_cpc0_mif0 *const PGMC_CPC0_MIF1 =
    reinterpret_cast<pgmc_cpc0_mif0 *>(0x40C89200);

static volatile pgmc_cpc0_mif0 *const PGMC_CPC1_MIF0 =
    reinterpret_cast<pgmc_cpc0_mif0 *>(0x40C89500);

static volatile pgmc_cpc0_mif0 *const PGMC_CPC1_MIF1 =
    reinterpret_cast<pgmc_cpc0_mif0 *>(0x40C89600);

}; // namespace MIMXRT1176::CM7
