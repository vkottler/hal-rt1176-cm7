/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_0_IRQ_WAKEUP_STAT_0_31.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_1_IRQ_WAKEUP_STAT_32_63.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_2_IRQ_WAKEUP_STAT_64_95.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_3_IRQ_WAKEUP_STAT_96_127.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_4_IRQ_WAKEUP_STAT_128_159.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_5_IRQ_WAKEUP_STAT_160_191.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_6_IRQ_WAKEUP_STAT_192_223.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_7_IRQ_WAKEUP_MASK_224_255.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_CURRENT.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_PREVIOUS.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE.h"
#include "../enums/GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * GPC_CPU
 */
struct [[gnu::packed]] gpc_cpu_mode_ctrl_0
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        900; /*!< gpc_cpu_mode_ctrl_0's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint32_t CM_AUTHEN_CTRL; /*!< (read-write) CM Authentication Control */
    uint32_t CM_INT_CTRL;    /*!< (read-write) CM Interrupt Control */
    uint32_t CM_MISC;        /*!< (read-write) Miscellaneous */
    uint32_t CM_MODE_CTRL;   /*!< (read-write) CPU mode control */
    uint32_t CM_MODE_STAT;   /*!< (read-write) CM CPU mode Status */
    static constexpr std::size_t reserved_padding1_length = 58;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t CM_IRQ_WAKEUP_MASK_0; /*!< (read-write) CM IRQ0~31 wakeup mask */
    uint32_t CM_IRQ_WAKEUP_MASK_1; /*!< (read-write) CM IRQ32~63 wakeup mask */
    uint32_t CM_IRQ_WAKEUP_MASK_2; /*!< (read-write) CM IRQ64~95 wakeup mask */
    uint32_t
        CM_IRQ_WAKEUP_MASK_3; /*!< (read-write) CM IRQ96~127 wakeup mask */
    uint32_t
        CM_IRQ_WAKEUP_MASK_4; /*!< (read-write) CM IRQ128~159 wakeup mask */
    uint32_t
        CM_IRQ_WAKEUP_MASK_5; /*!< (read-write) CM IRQ160~191 wakeup mask */
    uint32_t
        CM_IRQ_WAKEUP_MASK_6; /*!< (read-write) CM IRQ192~223 wakeup mask */
    uint32_t
        CM_IRQ_WAKEUP_MASK_7; /*!< (read-write) CM IRQ224~255 wakeup mask */
    static constexpr std::size_t reserved_padding2_length = 8;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t
        CM_NON_IRQ_WAKEUP_MASK; /*!< (read-write) CM non-irq wakeup mask */
    static constexpr std::size_t reserved_padding3_length = 3;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t
        CM_IRQ_WAKEUP_STAT_0; /*!< (read-write) CM IRQ0~31 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_1; /*!< (read-write) CM IRQ32~63 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_2; /*!< (read-write) CM IRQ64~95 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_3; /*!< (read-write) CM IRQ96~127 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_4; /*!< (read-write) CM IRQ128~159 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_5; /*!< (read-write) CM IRQ160~191 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_6; /*!< (read-write) CM IRQ192~223 wakeup status */
    uint32_t
        CM_IRQ_WAKEUP_STAT_7; /*!< (read-write) CM IRQ224~255 wakeup status */
    static constexpr std::size_t reserved_padding4_length = 8;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t
        CM_NON_IRQ_WAKEUP_STAT; /*!< (read-write) CM non-irq wakeup status */
    static constexpr std::size_t reserved_padding5_length = 27;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t CM_SLEEP_SSAR_CTRL; /*!< (read-write) CM sleep SSAR control */
    const uint32_t reserved_padding6 = {};
    uint32_t CM_SLEEP_LPCG_CTRL; /*!< (read-write) CM sleep LPCG control */
    const uint32_t reserved_padding7 = {};
    uint32_t CM_SLEEP_PLL_CTRL; /*!< (read-write) CM sleep PLL control */
    const uint32_t reserved_padding8 = {};
    uint32_t CM_SLEEP_ISO_CTRL; /*!< (read-write) CM sleep isolation control */
    const uint32_t reserved_padding9 = {};
    uint32_t CM_SLEEP_RESET_CTRL; /*!< (read-write) CM sleep reset control */
    const uint32_t reserved_padding10 = {};
    uint32_t CM_SLEEP_POWER_CTRL; /*!< (read-write) CM sleep power control */
    static constexpr std::size_t reserved_padding11_length = 25;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t CM_WAKEUP_POWER_CTRL; /*!< (read-write) CM wakeup power control */
    const uint32_t reserved_padding12 = {};
    uint32_t CM_WAKEUP_RESET_CTRL; /*!< (read-write) CM wakeup reset control */
    const uint32_t reserved_padding13 = {};
    uint32_t
        CM_WAKEUP_ISO_CTRL; /*!< (read-write) CM wakeup isolation control */
    const uint32_t reserved_padding14 = {};
    uint32_t CM_WAKEUP_PLL_CTRL; /*!< (read-write) CM wakeup PLL control */
    const uint32_t reserved_padding15 = {};
    uint32_t CM_WAKEUP_LPCG_CTRL; /*!< (read-write) CM wakeup LPCG control */
    const uint32_t reserved_padding16 = {};
    uint32_t CM_WAKEUP_SSAR_CTRL; /*!< (read-write) CM wakeup SSAR control */
    static constexpr std::size_t reserved_padding17_length = 17;
    const uint32_t reserved_padding17[reserved_padding17_length] = {};
    uint32_t CM_SP_CTRL; /*!< (read-write) CM Setpoint Control */
    uint32_t CM_SP_STAT; /*!< (read-write) CM Setpoint Status */
    static constexpr std::size_t reserved_padding18_length = 2;
    const uint32_t reserved_padding18[reserved_padding18_length] = {};
    uint32_t
        CM_RUN_MODE_MAPPING; /*!< (read-write) CM Run Mode Setpoint Allowed */
    uint32_t CM_WAIT_MODE_MAPPING;    /*!< (read-write) CM Wait Mode Setpoint
                                         Allowed */
    uint32_t CM_STOP_MODE_MAPPING;    /*!< (read-write) CM Stop Mode Setpoint
                                         Allowed */
    uint32_t CM_SUSPEND_MODE_MAPPING; /*!< (read-write) CM Suspend Mode
                                         Setpoint Allowed */
    uint32_t CM_SP0_MAPPING;  /*!< (read-write) CM Setpoint 0 Mapping */
    uint32_t CM_SP1_MAPPING;  /*!< (read-write) CM Setpoint 1 Mapping */
    uint32_t CM_SP2_MAPPING;  /*!< (read-write) CM Setpoint 2 Mapping */
    uint32_t CM_SP3_MAPPING;  /*!< (read-write) CM Setpoint 3 Mapping */
    uint32_t CM_SP4_MAPPING;  /*!< (read-write) CM Setpoint 4 Mapping */
    uint32_t CM_SP5_MAPPING;  /*!< (read-write) CM Setpoint 5 Mapping */
    uint32_t CM_SP6_MAPPING;  /*!< (read-write) CM Setpoint 6 Mapping */
    uint32_t CM_SP7_MAPPING;  /*!< (read-write) CM Setpoint 7 Mapping */
    uint32_t CM_SP8_MAPPING;  /*!< (read-write) CM Setpoint 8 Mapping */
    uint32_t CM_SP9_MAPPING;  /*!< (read-write) CM Setpoint 9 Mapping */
    uint32_t CM_SP10_MAPPING; /*!< (read-write) CM Setpoint 10 Mapping */
    uint32_t CM_SP11_MAPPING; /*!< (read-write) CM Setpoint 11 Mapping */
    uint32_t CM_SP12_MAPPING; /*!< (read-write) CM Setpoint 12 Mapping */
    uint32_t CM_SP13_MAPPING; /*!< (read-write) CM Setpoint 13 Mapping */
    uint32_t CM_SP14_MAPPING; /*!< (read-write) CM Setpoint 14 Mapping */
    uint32_t CM_SP15_MAPPING; /*!< (read-write) CM Setpoint 15 Mapping */
    static constexpr std::size_t reserved_padding19_length = 8;
    const uint32_t reserved_padding19[reserved_padding19_length] = {};
    uint32_t CM_STBY_CTRL; /*!< (read-write) CM standby control */

    /* Methods. */

    /**
     * Get CM_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline bool get_CM_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        return CM_AUTHEN_CTRL & (1u << 20u);
    }

    /**
     * Set CM_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void set_CM_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        CM_AUTHEN_CTRL |= 1u << 20u;
    }

    /**
     * Clear CM_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void clear_CM_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        CM_AUTHEN_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CM_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void toggle_CM_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        CM_AUTHEN_CTRL ^= 1u << 20u;
    }

    /**
     * Get CM_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline bool get_CM_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        return CM_AUTHEN_CTRL & (1u << 12u);
    }

    /**
     * Set CM_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void set_CM_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        CM_AUTHEN_CTRL |= 1u << 12u;
    }

    /**
     * Clear CM_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void clear_CM_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        CM_AUTHEN_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CM_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void toggle_CM_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        CM_AUTHEN_CTRL ^= 1u << 12u;
    }

    /**
     * Get CM_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline uint8_t get_CM_AUTHEN_CTRL_WHITE_LIST() volatile
    {
        return (CM_AUTHEN_CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set CM_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline void set_CM_AUTHEN_CTRL_WHITE_LIST(uint8_t value) volatile
    {
        uint32_t curr = CM_AUTHEN_CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CM_AUTHEN_CTRL = curr;
    }

    /**
     * Get CM_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline bool get_CM_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        return CM_AUTHEN_CTRL & (1u << 4u);
    }

    /**
     * Set CM_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void set_CM_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        CM_AUTHEN_CTRL |= 1u << 4u;
    }

    /**
     * Clear CM_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void clear_CM_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        CM_AUTHEN_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CM_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void toggle_CM_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        CM_AUTHEN_CTRL ^= 1u << 4u;
    }

    /**
     * Get CM_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline bool get_CM_AUTHEN_CTRL_NONSECURE() volatile
    {
        return CM_AUTHEN_CTRL & (1u << 1u);
    }

    /**
     * Set CM_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void set_CM_AUTHEN_CTRL_NONSECURE() volatile
    {
        CM_AUTHEN_CTRL |= 1u << 1u;
    }

    /**
     * Clear CM_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void clear_CM_AUTHEN_CTRL_NONSECURE() volatile
    {
        CM_AUTHEN_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CM_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void toggle_CM_AUTHEN_CTRL_NONSECURE() volatile
    {
        CM_AUTHEN_CTRL ^= 1u << 1u;
    }

    /**
     * Get CM_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline bool get_CM_AUTHEN_CTRL_USER() volatile
    {
        return CM_AUTHEN_CTRL & (1u << 0u);
    }

    /**
     * Set CM_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void set_CM_AUTHEN_CTRL_USER() volatile
    {
        CM_AUTHEN_CTRL |= 1u << 0u;
    }

    /**
     * Clear CM_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void clear_CM_AUTHEN_CTRL_USER() volatile
    {
        CM_AUTHEN_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CM_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void toggle_CM_AUTHEN_CTRL_USER() volatile
    {
        CM_AUTHEN_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CM_AUTHEN_CTRL's bit fields.
     *
     * (read-write) CM Authentication Control
     */
    inline void get_CM_AUTHEN_CTRL(bool &LOCK_CFG, bool &LOCK_LIST,
                                   uint8_t &WHITE_LIST, bool &LOCK_SETTING,
                                   bool &NONSECURE, bool &USER) volatile
    {
        uint32_t curr = CM_AUTHEN_CTRL;

        LOCK_CFG = curr & (1u << 20u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_SETTING = curr & (1u << 4u);
        NONSECURE = curr & (1u << 1u);
        USER = curr & (1u << 0u);
    }

    /**
     * Set all of CM_AUTHEN_CTRL's bit fields.
     *
     * (read-write) CM Authentication Control
     */
    inline void set_CM_AUTHEN_CTRL(bool LOCK_CFG, bool LOCK_LIST,
                                   uint8_t WHITE_LIST, bool LOCK_SETTING,
                                   bool NONSECURE, bool USER) volatile
    {
        uint32_t curr = CM_AUTHEN_CTRL;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_CFG & 0b1u) << 20u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_SETTING & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (NONSECURE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (USER & 0b1u) << 0u;

        CM_AUTHEN_CTRL = curr;
    }

    /**
     * Get CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT bit.
     *
     * sp_req_not_allowed_for_soft interrupt status and clear register
     */
    inline bool get_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT() volatile
    {
        return CM_INT_CTRL & (1u << 18u);
    }

    /**
     * Set CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT bit.
     *
     * sp_req_not_allowed_for_soft interrupt status and clear register
     */
    inline void set_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT() volatile
    {
        CM_INT_CTRL |= 1u << 18u;
    }

    /**
     * Clear CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT bit.
     *
     * sp_req_not_allowed_for_soft interrupt status and clear register
     */
    inline void clear_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT() volatile
    {
        CM_INT_CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT bit.
     *
     * sp_req_not_allowed_for_soft interrupt status and clear register
     */
    inline void toggle_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT() volatile
    {
        CM_INT_CTRL ^= 1u << 18u;
    }

    /**
     * Get CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt status and clear register
     */
    inline bool get_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT() volatile
    {
        return CM_INT_CTRL & (1u << 17u);
    }

    /**
     * Set CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt status and clear register
     */
    inline void set_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT() volatile
    {
        CM_INT_CTRL |= 1u << 17u;
    }

    /**
     * Clear CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt status and clear register
     */
    inline void clear_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT() volatile
    {
        CM_INT_CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt status and clear register
     */
    inline void toggle_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT() volatile
    {
        CM_INT_CTRL ^= 1u << 17u;
    }

    /**
     * Get CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT bit.
     *
     * sp_req_not_allowed_for_sleep interrupt status and clear register
     */
    inline bool get_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT() volatile
    {
        return CM_INT_CTRL & (1u << 16u);
    }

    /**
     * Set CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT bit.
     *
     * sp_req_not_allowed_for_sleep interrupt status and clear register
     */
    inline void set_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT() volatile
    {
        CM_INT_CTRL |= 1u << 16u;
    }

    /**
     * Clear CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT bit.
     *
     * sp_req_not_allowed_for_sleep interrupt status and clear register
     */
    inline void clear_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT() volatile
    {
        CM_INT_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT bit.
     *
     * sp_req_not_allowed_for_sleep interrupt status and clear register
     */
    inline void toggle_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT() volatile
    {
        CM_INT_CTRL ^= 1u << 16u;
    }

    /**
     * Get CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT_EN bit.
     *
     * sp_req_not_allowed_for_soft interrupt enable
     */
    inline bool get_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT_EN() volatile
    {
        return CM_INT_CTRL & (1u << 2u);
    }

    /**
     * Set CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT_EN bit.
     *
     * sp_req_not_allowed_for_soft interrupt enable
     */
    inline void set_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT_EN() volatile
    {
        CM_INT_CTRL |= 1u << 2u;
    }

    /**
     * Clear CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT_EN bit.
     *
     * sp_req_not_allowed_for_soft interrupt enable
     */
    inline void clear_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT_EN() volatile
    {
        CM_INT_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SOFT_INT_EN bit.
     *
     * sp_req_not_allowed_for_soft interrupt enable
     */
    inline void toggle_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SOFT_INT_EN() volatile
    {
        CM_INT_CTRL ^= 1u << 2u;
    }

    /**
     * Get CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt enable
     */
    inline bool get_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN() volatile
    {
        return CM_INT_CTRL & (1u << 1u);
    }

    /**
     * Set CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt enable
     */
    inline void set_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN() volatile
    {
        CM_INT_CTRL |= 1u << 1u;
    }

    /**
     * Clear CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt enable
     */
    inline void clear_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN() volatile
    {
        CM_INT_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CM_INT_CTRL's SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN bit.
     *
     * sp_req_not_allowed_for_wakeup interrupt enable
     */
    inline void toggle_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN() volatile
    {
        CM_INT_CTRL ^= 1u << 1u;
    }

    /**
     * Get CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT_EN bit.
     *
     * sp_req_not_allowed_for_sleep interrupt enable
     */
    inline bool get_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT_EN() volatile
    {
        return CM_INT_CTRL & (1u << 0u);
    }

    /**
     * Set CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT_EN bit.
     *
     * sp_req_not_allowed_for_sleep interrupt enable
     */
    inline void set_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT_EN() volatile
    {
        CM_INT_CTRL |= 1u << 0u;
    }

    /**
     * Clear CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT_EN bit.
     *
     * sp_req_not_allowed_for_sleep interrupt enable
     */
    inline void clear_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT_EN() volatile
    {
        CM_INT_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CM_INT_CTRL's SP_REQ_NOT_ALLOWED_SLEEP_INT_EN bit.
     *
     * sp_req_not_allowed_for_sleep interrupt enable
     */
    inline void toggle_CM_INT_CTRL_SP_REQ_NOT_ALLOWED_SLEEP_INT_EN() volatile
    {
        CM_INT_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CM_INT_CTRL's bit fields.
     *
     * (read-write) CM Interrupt Control
     */
    inline void get_CM_INT_CTRL(bool &SP_REQ_NOT_ALLOWED_SOFT_INT,
                                bool &SP_REQ_NOT_ALLOWED_WAKEUP_INT,
                                bool &SP_REQ_NOT_ALLOWED_SLEEP_INT,
                                bool &SP_REQ_NOT_ALLOWED_SOFT_INT_EN,
                                bool &SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN,
                                bool &SP_REQ_NOT_ALLOWED_SLEEP_INT_EN) volatile
    {
        uint32_t curr = CM_INT_CTRL;

        SP_REQ_NOT_ALLOWED_SOFT_INT = curr & (1u << 18u);
        SP_REQ_NOT_ALLOWED_WAKEUP_INT = curr & (1u << 17u);
        SP_REQ_NOT_ALLOWED_SLEEP_INT = curr & (1u << 16u);
        SP_REQ_NOT_ALLOWED_SOFT_INT_EN = curr & (1u << 2u);
        SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN = curr & (1u << 1u);
        SP_REQ_NOT_ALLOWED_SLEEP_INT_EN = curr & (1u << 0u);
    }

    /**
     * Set all of CM_INT_CTRL's bit fields.
     *
     * (read-write) CM Interrupt Control
     */
    inline void set_CM_INT_CTRL(bool SP_REQ_NOT_ALLOWED_SOFT_INT,
                                bool SP_REQ_NOT_ALLOWED_WAKEUP_INT,
                                bool SP_REQ_NOT_ALLOWED_SLEEP_INT,
                                bool SP_REQ_NOT_ALLOWED_SOFT_INT_EN,
                                bool SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN,
                                bool SP_REQ_NOT_ALLOWED_SLEEP_INT_EN) volatile
    {
        uint32_t curr = CM_INT_CTRL;

        curr &= ~(0b1u << 18u);
        curr |= (SP_REQ_NOT_ALLOWED_SOFT_INT & 0b1u) << 18u;
        curr &= ~(0b1u << 17u);
        curr |= (SP_REQ_NOT_ALLOWED_WAKEUP_INT & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (SP_REQ_NOT_ALLOWED_SLEEP_INT & 0b1u) << 16u;
        curr &= ~(0b1u << 2u);
        curr |= (SP_REQ_NOT_ALLOWED_SOFT_INT_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (SP_REQ_NOT_ALLOWED_WAKEUP_INT_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SP_REQ_NOT_ALLOWED_SLEEP_INT_EN & 0b1u) << 0u;

        CM_INT_CTRL = curr;
    }

    /**
     * Get CM_MISC's MASTER_CPU bit.
     *
     * Master CPU
     */
    inline bool get_CM_MISC_MASTER_CPU() volatile
    {
        return CM_MISC & (1u << 4u);
    }

    /**
     * Set CM_MISC's MASTER_CPU bit.
     *
     * Master CPU
     */
    inline void set_CM_MISC_MASTER_CPU() volatile
    {
        CM_MISC |= 1u << 4u;
    }

    /**
     * Clear CM_MISC's MASTER_CPU bit.
     *
     * Master CPU
     */
    inline void clear_CM_MISC_MASTER_CPU() volatile
    {
        CM_MISC &= ~(1u << 4u);
    }

    /**
     * Toggle CM_MISC's MASTER_CPU bit.
     *
     * Master CPU
     */
    inline void toggle_CM_MISC_MASTER_CPU() volatile
    {
        CM_MISC ^= 1u << 4u;
    }

    /**
     * Get CM_MISC's SLEEP_HOLD_STAT bit.
     *
     * Status of cpu_sleep_hold_ack_b
     */
    inline bool get_CM_MISC_SLEEP_HOLD_STAT() volatile
    {
        return CM_MISC & (1u << 2u);
    }

    /**
     * Get CM_MISC's SLEEP_HOLD_EN bit.
     *
     * Allow cpu_sleep_hold_req assert during CPU low power status
     */
    inline bool get_CM_MISC_SLEEP_HOLD_EN() volatile
    {
        return CM_MISC & (1u << 1u);
    }

    /**
     * Set CM_MISC's SLEEP_HOLD_EN bit.
     *
     * Allow cpu_sleep_hold_req assert during CPU low power status
     */
    inline void set_CM_MISC_SLEEP_HOLD_EN() volatile
    {
        CM_MISC |= 1u << 1u;
    }

    /**
     * Clear CM_MISC's SLEEP_HOLD_EN bit.
     *
     * Allow cpu_sleep_hold_req assert during CPU low power status
     */
    inline void clear_CM_MISC_SLEEP_HOLD_EN() volatile
    {
        CM_MISC &= ~(1u << 1u);
    }

    /**
     * Toggle CM_MISC's SLEEP_HOLD_EN bit.
     *
     * Allow cpu_sleep_hold_req assert during CPU low power status
     */
    inline void toggle_CM_MISC_SLEEP_HOLD_EN() volatile
    {
        CM_MISC ^= 1u << 1u;
    }

    /**
     * Get CM_MISC's NMI_STAT bit.
     *
     * Non-masked interrupt status
     */
    inline bool get_CM_MISC_NMI_STAT() volatile
    {
        return CM_MISC & (1u << 0u);
    }

    /**
     * Get all of CM_MISC's bit fields.
     *
     * (read-write) Miscellaneous
     */
    inline void get_CM_MISC(bool &MASTER_CPU, bool &SLEEP_HOLD_STAT,
                            bool &SLEEP_HOLD_EN, bool &NMI_STAT) volatile
    {
        uint32_t curr = CM_MISC;

        MASTER_CPU = curr & (1u << 4u);
        SLEEP_HOLD_STAT = curr & (1u << 2u);
        SLEEP_HOLD_EN = curr & (1u << 1u);
        NMI_STAT = curr & (1u << 0u);
    }

    /**
     * Set all of CM_MISC's bit fields.
     *
     * (read-write) Miscellaneous
     */
    inline void set_CM_MISC(bool MASTER_CPU, bool SLEEP_HOLD_EN) volatile
    {
        uint32_t curr = CM_MISC;

        curr &= ~(0b1u << 4u);
        curr |= (MASTER_CPU & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (SLEEP_HOLD_EN & 0b1u) << 1u;

        CM_MISC = curr;
    }

    /**
     * Get CM_MODE_CTRL's WFE_EN bit.
     *
     * WFE assertion can be sleep event
     */
    inline bool get_CM_MODE_CTRL_WFE_EN() volatile
    {
        return CM_MODE_CTRL & (1u << 4u);
    }

    /**
     * Set CM_MODE_CTRL's WFE_EN bit.
     *
     * WFE assertion can be sleep event
     */
    inline void set_CM_MODE_CTRL_WFE_EN() volatile
    {
        CM_MODE_CTRL |= 1u << 4u;
    }

    /**
     * Clear CM_MODE_CTRL's WFE_EN bit.
     *
     * WFE assertion can be sleep event
     */
    inline void clear_CM_MODE_CTRL_WFE_EN() volatile
    {
        CM_MODE_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CM_MODE_CTRL's WFE_EN bit.
     *
     * WFE assertion can be sleep event
     */
    inline void toggle_CM_MODE_CTRL_WFE_EN() volatile
    {
        CM_MODE_CTRL ^= 1u << 4u;
    }

    /**
     * Get CM_MODE_CTRL's CPU_MODE_TARGET field.
     *
     * The CPU mode the CPU platform should transit to on next sleep event
     */
    inline GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET
    get_CM_MODE_CTRL_CPU_MODE_TARGET() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET(
            (CM_MODE_CTRL >> 0u) & 0b11u);
    }

    /**
     * Set CM_MODE_CTRL's CPU_MODE_TARGET field.
     *
     * The CPU mode the CPU platform should transit to on next sleep event
     */
    inline void set_CM_MODE_CTRL_CPU_MODE_TARGET(
        GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET value) volatile
    {
        uint32_t curr = CM_MODE_CTRL;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CM_MODE_CTRL = curr;
    }

    /**
     * Get all of CM_MODE_CTRL's bit fields.
     *
     * (read-write) CPU mode control
     */
    inline void get_CM_MODE_CTRL(
        bool &WFE_EN, GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET
                          &CPU_MODE_TARGET) volatile
    {
        uint32_t curr = CM_MODE_CTRL;

        WFE_EN = curr & (1u << 4u);
        CPU_MODE_TARGET = GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET(
            (curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CM_MODE_CTRL's bit fields.
     *
     * (read-write) CPU mode control
     */
    inline void set_CM_MODE_CTRL(
        bool WFE_EN, GPC_CPU_MODE_CTRL_0_CM_MODE_CTRL_CPU_MODE_TARGET
                         CPU_MODE_TARGET) volatile
    {
        uint32_t curr = CM_MODE_CTRL;

        curr &= ~(0b1u << 4u);
        curr |= (WFE_EN & 0b1u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CPU_MODE_TARGET) & 0b11u) << 0u;

        CM_MODE_CTRL = curr;
    }

    /**
     * Get CM_MODE_STAT's CPU_MODE_PREVIOUS field.
     *
     * Previous CPU mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_PREVIOUS
    get_CM_MODE_STAT_CPU_MODE_PREVIOUS() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_PREVIOUS(
            (CM_MODE_STAT >> 2u) & 0b11u);
    }

    /**
     * Get CM_MODE_STAT's CPU_MODE_CURRENT field.
     *
     * Current CPU mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_CURRENT
    get_CM_MODE_STAT_CPU_MODE_CURRENT() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_CURRENT(
            (CM_MODE_STAT >> 0u) & 0b11u);
    }

    /**
     * Get all of CM_MODE_STAT's bit fields.
     *
     * (read-write) CM CPU mode Status
     */
    inline void get_CM_MODE_STAT(
        GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_PREVIOUS &CPU_MODE_PREVIOUS,
        GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_CURRENT
            &CPU_MODE_CURRENT) volatile
    {
        uint32_t curr = CM_MODE_STAT;

        CPU_MODE_PREVIOUS = GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_PREVIOUS(
            (curr >> 2u) & 0b11u);
        CPU_MODE_CURRENT = GPC_CPU_MODE_CTRL_0_CM_MODE_STAT_CPU_MODE_CURRENT(
            (curr >> 0u) & 0b11u);
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_0's IRQ_WAKEUP_MASK_0_31 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_0_IRQ_WAKEUP_MASK_0_31() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_0 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_0's IRQ_WAKEUP_MASK_0_31 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_0_IRQ_WAKEUP_MASK_0_31(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_0;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_0 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_1's IRQ_WAKEUP_MASK_32_63 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_1_IRQ_WAKEUP_MASK_32_63() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_1 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_1's IRQ_WAKEUP_MASK_32_63 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_1_IRQ_WAKEUP_MASK_32_63(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_1 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_2's IRQ_WAKEUP_MASK_64_95 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_2_IRQ_WAKEUP_MASK_64_95() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_2 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_2's IRQ_WAKEUP_MASK_64_95 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_2_IRQ_WAKEUP_MASK_64_95(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_2 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_3's IRQ_WAKEUP_MASK_96_127 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_3_IRQ_WAKEUP_MASK_96_127() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_3 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_3's IRQ_WAKEUP_MASK_96_127 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_3_IRQ_WAKEUP_MASK_96_127(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_3;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_3 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_4's IRQ_WAKEUP_MASK_128_159 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_4_IRQ_WAKEUP_MASK_128_159() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_4 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_4's IRQ_WAKEUP_MASK_128_159 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_4_IRQ_WAKEUP_MASK_128_159(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_4;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_4 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_5's IRQ_WAKEUP_MASK_160_191 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_5_IRQ_WAKEUP_MASK_160_191() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_5 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_5's IRQ_WAKEUP_MASK_160_191 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_5_IRQ_WAKEUP_MASK_160_191(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_5;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_5 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_6's IRQ_WAKEUP_MASK_192_223 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_6_IRQ_WAKEUP_MASK_192_223() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_6 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_6's IRQ_WAKEUP_MASK_192_223 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_6_IRQ_WAKEUP_MASK_192_223(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_6;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_6 = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_MASK_7's IRQ_WAKEUP_MASK_224_255 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline uint32_t get_CM_IRQ_WAKEUP_MASK_7_IRQ_WAKEUP_MASK_224_255() volatile
    {
        return (CM_IRQ_WAKEUP_MASK_7 >> 0u) &
               0b11111111111111111111111111111111u;
    }

    /**
     * Set CM_IRQ_WAKEUP_MASK_7's IRQ_WAKEUP_MASK_224_255 field.
     *
     * "1" means the IRQ cannot wakeup CPU platform
     */
    inline void set_CM_IRQ_WAKEUP_MASK_7_IRQ_WAKEUP_MASK_224_255(
        uint32_t value) volatile
    {
        uint32_t curr = CM_IRQ_WAKEUP_MASK_7;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CM_IRQ_WAKEUP_MASK_7 = curr;
    }

    /**
     * Get CM_NON_IRQ_WAKEUP_MASK's DEBUG_WAKEUP_MASK bit.
     *
     * "1" means the debug_wakeup_request cannot wakeup CPU platform
     */
    inline bool get_CM_NON_IRQ_WAKEUP_MASK_DEBUG_WAKEUP_MASK() volatile
    {
        return CM_NON_IRQ_WAKEUP_MASK & (1u << 1u);
    }

    /**
     * Set CM_NON_IRQ_WAKEUP_MASK's DEBUG_WAKEUP_MASK bit.
     *
     * "1" means the debug_wakeup_request cannot wakeup CPU platform
     */
    inline void set_CM_NON_IRQ_WAKEUP_MASK_DEBUG_WAKEUP_MASK() volatile
    {
        CM_NON_IRQ_WAKEUP_MASK |= 1u << 1u;
    }

    /**
     * Clear CM_NON_IRQ_WAKEUP_MASK's DEBUG_WAKEUP_MASK bit.
     *
     * "1" means the debug_wakeup_request cannot wakeup CPU platform
     */
    inline void clear_CM_NON_IRQ_WAKEUP_MASK_DEBUG_WAKEUP_MASK() volatile
    {
        CM_NON_IRQ_WAKEUP_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle CM_NON_IRQ_WAKEUP_MASK's DEBUG_WAKEUP_MASK bit.
     *
     * "1" means the debug_wakeup_request cannot wakeup CPU platform
     */
    inline void toggle_CM_NON_IRQ_WAKEUP_MASK_DEBUG_WAKEUP_MASK() volatile
    {
        CM_NON_IRQ_WAKEUP_MASK ^= 1u << 1u;
    }

    /**
     * Get CM_NON_IRQ_WAKEUP_MASK's EVENT_WAKEUP_MASK bit.
     *
     * There are 256 interrupts and 1 event as a wakeup source for GPC. This
     * field masks the 1 event wakeup source.
     */
    inline bool get_CM_NON_IRQ_WAKEUP_MASK_EVENT_WAKEUP_MASK() volatile
    {
        return CM_NON_IRQ_WAKEUP_MASK & (1u << 0u);
    }

    /**
     * Set CM_NON_IRQ_WAKEUP_MASK's EVENT_WAKEUP_MASK bit.
     *
     * There are 256 interrupts and 1 event as a wakeup source for GPC. This
     * field masks the 1 event wakeup source.
     */
    inline void set_CM_NON_IRQ_WAKEUP_MASK_EVENT_WAKEUP_MASK() volatile
    {
        CM_NON_IRQ_WAKEUP_MASK |= 1u << 0u;
    }

    /**
     * Clear CM_NON_IRQ_WAKEUP_MASK's EVENT_WAKEUP_MASK bit.
     *
     * There are 256 interrupts and 1 event as a wakeup source for GPC. This
     * field masks the 1 event wakeup source.
     */
    inline void clear_CM_NON_IRQ_WAKEUP_MASK_EVENT_WAKEUP_MASK() volatile
    {
        CM_NON_IRQ_WAKEUP_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle CM_NON_IRQ_WAKEUP_MASK's EVENT_WAKEUP_MASK bit.
     *
     * There are 256 interrupts and 1 event as a wakeup source for GPC. This
     * field masks the 1 event wakeup source.
     */
    inline void toggle_CM_NON_IRQ_WAKEUP_MASK_EVENT_WAKEUP_MASK() volatile
    {
        CM_NON_IRQ_WAKEUP_MASK ^= 1u << 0u;
    }

    /**
     * Get all of CM_NON_IRQ_WAKEUP_MASK's bit fields.
     *
     * (read-write) CM non-irq wakeup mask
     */
    inline void get_CM_NON_IRQ_WAKEUP_MASK(bool &DEBUG_WAKEUP_MASK,
                                           bool &EVENT_WAKEUP_MASK) volatile
    {
        uint32_t curr = CM_NON_IRQ_WAKEUP_MASK;

        DEBUG_WAKEUP_MASK = curr & (1u << 1u);
        EVENT_WAKEUP_MASK = curr & (1u << 0u);
    }

    /**
     * Set all of CM_NON_IRQ_WAKEUP_MASK's bit fields.
     *
     * (read-write) CM non-irq wakeup mask
     */
    inline void set_CM_NON_IRQ_WAKEUP_MASK(bool DEBUG_WAKEUP_MASK,
                                           bool EVENT_WAKEUP_MASK) volatile
    {
        uint32_t curr = CM_NON_IRQ_WAKEUP_MASK;

        curr &= ~(0b1u << 1u);
        curr |= (DEBUG_WAKEUP_MASK & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EVENT_WAKEUP_MASK & 0b1u) << 0u;

        CM_NON_IRQ_WAKEUP_MASK = curr;
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_0's IRQ_WAKEUP_STAT_0_31 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_0_IRQ_WAKEUP_STAT_0_31
    get_CM_IRQ_WAKEUP_STAT_0_IRQ_WAKEUP_STAT_0_31() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_0_IRQ_WAKEUP_STAT_0_31(
            (CM_IRQ_WAKEUP_STAT_0 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_1's IRQ_WAKEUP_STAT_32_63 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_1_IRQ_WAKEUP_STAT_32_63
    get_CM_IRQ_WAKEUP_STAT_1_IRQ_WAKEUP_STAT_32_63() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_1_IRQ_WAKEUP_STAT_32_63(
            (CM_IRQ_WAKEUP_STAT_1 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_2's IRQ_WAKEUP_STAT_64_95 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_2_IRQ_WAKEUP_STAT_64_95
    get_CM_IRQ_WAKEUP_STAT_2_IRQ_WAKEUP_STAT_64_95() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_2_IRQ_WAKEUP_STAT_64_95(
            (CM_IRQ_WAKEUP_STAT_2 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_3's IRQ_WAKEUP_STAT_96_127 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_3_IRQ_WAKEUP_STAT_96_127
    get_CM_IRQ_WAKEUP_STAT_3_IRQ_WAKEUP_STAT_96_127() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_3_IRQ_WAKEUP_STAT_96_127(
            (CM_IRQ_WAKEUP_STAT_3 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_4's IRQ_WAKEUP_STAT_128_159 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_4_IRQ_WAKEUP_STAT_128_159
    get_CM_IRQ_WAKEUP_STAT_4_IRQ_WAKEUP_STAT_128_159() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_4_IRQ_WAKEUP_STAT_128_159(
            (CM_IRQ_WAKEUP_STAT_4 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_5's IRQ_WAKEUP_STAT_160_191 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_5_IRQ_WAKEUP_STAT_160_191
    get_CM_IRQ_WAKEUP_STAT_5_IRQ_WAKEUP_STAT_160_191() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_5_IRQ_WAKEUP_STAT_160_191(
            (CM_IRQ_WAKEUP_STAT_5 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_6's IRQ_WAKEUP_STAT_192_223 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_6_IRQ_WAKEUP_STAT_192_223
    get_CM_IRQ_WAKEUP_STAT_6_IRQ_WAKEUP_STAT_192_223() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_6_IRQ_WAKEUP_STAT_192_223(
            (CM_IRQ_WAKEUP_STAT_6 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_IRQ_WAKEUP_STAT_7's IRQ_WAKEUP_MASK_224_255 field.
     *
     * IRQ status
     */
    inline GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_7_IRQ_WAKEUP_MASK_224_255
    get_CM_IRQ_WAKEUP_STAT_7_IRQ_WAKEUP_MASK_224_255() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_IRQ_WAKEUP_STAT_7_IRQ_WAKEUP_MASK_224_255(
            (CM_IRQ_WAKEUP_STAT_7 >> 0u) &
            0b11111111111111111111111111111111u);
    }

    /**
     * Get CM_NON_IRQ_WAKEUP_STAT's DEBUG_WAKEUP_STAT bit.
     *
     * Debug wakeup status
     */
    inline bool get_CM_NON_IRQ_WAKEUP_STAT_DEBUG_WAKEUP_STAT() volatile
    {
        return CM_NON_IRQ_WAKEUP_STAT & (1u << 1u);
    }

    /**
     * Get CM_NON_IRQ_WAKEUP_STAT's EVENT_WAKEUP_STAT bit.
     *
     * Event wakeup status
     */
    inline bool get_CM_NON_IRQ_WAKEUP_STAT_EVENT_WAKEUP_STAT() volatile
    {
        return CM_NON_IRQ_WAKEUP_STAT & (1u << 0u);
    }

    /**
     * Get all of CM_NON_IRQ_WAKEUP_STAT's bit fields.
     *
     * (read-write) CM non-irq wakeup status
     */
    inline void get_CM_NON_IRQ_WAKEUP_STAT(bool &DEBUG_WAKEUP_STAT,
                                           bool &EVENT_WAKEUP_STAT) volatile
    {
        uint32_t curr = CM_NON_IRQ_WAKEUP_STAT;

        DEBUG_WAKEUP_STAT = curr & (1u << 1u);
        EVENT_WAKEUP_STAT = curr & (1u << 0u);
    }

    /**
     * Get CM_SLEEP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_SLEEP_SSAR_CTRL_DISABLE() volatile
    {
        return CM_SLEEP_SSAR_CTRL & (1u << 31u);
    }

    /**
     * Set CM_SLEEP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_SLEEP_SSAR_CTRL_DISABLE() volatile
    {
        CM_SLEEP_SSAR_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_SLEEP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_SLEEP_SSAR_CTRL_DISABLE() volatile
    {
        CM_SLEEP_SSAR_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_SLEEP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_SLEEP_SSAR_CTRL_DISABLE() volatile
    {
        CM_SLEEP_SSAR_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_SLEEP_SSAR_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE
    get_CM_SLEEP_SSAR_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE(
            (CM_SLEEP_SSAR_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_SLEEP_SSAR_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_SLEEP_SSAR_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_SLEEP_SSAR_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_SLEEP_SSAR_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_SSAR_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE.
     */
    inline uint16_t get_CM_SLEEP_SSAR_CTRL_STEP_CNT() volatile
    {
        return (CM_SLEEP_SSAR_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SLEEP_SSAR_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE.
     */
    inline void set_CM_SLEEP_SSAR_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_SLEEP_SSAR_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SLEEP_SSAR_CTRL = curr;
    }

    /**
     * Get all of CM_SLEEP_SSAR_CTRL's bit fields.
     *
     * (read-write) CM sleep SSAR control
     */
    inline void get_CM_SLEEP_SSAR_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_SSAR_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_SLEEP_SSAR_CTRL's bit fields.
     *
     * (read-write) CM sleep SSAR control
     */
    inline void set_CM_SLEEP_SSAR_CTRL(
        bool DISABLE, GPC_CPU_MODE_CTRL_0_CM_SLEEP_SSAR_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_SSAR_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_SLEEP_SSAR_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_SLEEP_LPCG_CTRL_DISABLE() volatile
    {
        return CM_SLEEP_LPCG_CTRL & (1u << 31u);
    }

    /**
     * Set CM_SLEEP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_SLEEP_LPCG_CTRL_DISABLE() volatile
    {
        CM_SLEEP_LPCG_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_SLEEP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_SLEEP_LPCG_CTRL_DISABLE() volatile
    {
        CM_SLEEP_LPCG_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_SLEEP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_SLEEP_LPCG_CTRL_DISABLE() volatile
    {
        CM_SLEEP_LPCG_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_SLEEP_LPCG_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE
    get_CM_SLEEP_LPCG_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE(
            (CM_SLEEP_LPCG_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_SLEEP_LPCG_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_SLEEP_LPCG_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_SLEEP_LPCG_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_SLEEP_LPCG_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_LPCG_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_SLEEP_LPCG_CTRL_STEP_CNT() volatile
    {
        return (CM_SLEEP_LPCG_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SLEEP_LPCG_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_SLEEP_LPCG_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_SLEEP_LPCG_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SLEEP_LPCG_CTRL = curr;
    }

    /**
     * Get all of CM_SLEEP_LPCG_CTRL's bit fields.
     *
     * (read-write) CM sleep LPCG control
     */
    inline void get_CM_SLEEP_LPCG_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_LPCG_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_SLEEP_LPCG_CTRL's bit fields.
     *
     * (read-write) CM sleep LPCG control
     */
    inline void set_CM_SLEEP_LPCG_CTRL(
        bool DISABLE, GPC_CPU_MODE_CTRL_0_CM_SLEEP_LPCG_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_LPCG_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_SLEEP_LPCG_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_SLEEP_PLL_CTRL_DISABLE() volatile
    {
        return CM_SLEEP_PLL_CTRL & (1u << 31u);
    }

    /**
     * Set CM_SLEEP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_SLEEP_PLL_CTRL_DISABLE() volatile
    {
        CM_SLEEP_PLL_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_SLEEP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_SLEEP_PLL_CTRL_DISABLE() volatile
    {
        CM_SLEEP_PLL_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_SLEEP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_SLEEP_PLL_CTRL_DISABLE() volatile
    {
        CM_SLEEP_PLL_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_SLEEP_PLL_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE
    get_CM_SLEEP_PLL_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE(
            (CM_SLEEP_PLL_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_SLEEP_PLL_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_SLEEP_PLL_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_SLEEP_PLL_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_SLEEP_PLL_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_PLL_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_SLEEP_PLL_CTRL_STEP_CNT() volatile
    {
        return (CM_SLEEP_PLL_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SLEEP_PLL_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_SLEEP_PLL_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_SLEEP_PLL_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SLEEP_PLL_CTRL = curr;
    }

    /**
     * Get all of CM_SLEEP_PLL_CTRL's bit fields.
     *
     * (read-write) CM sleep PLL control
     */
    inline void get_CM_SLEEP_PLL_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_PLL_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_SLEEP_PLL_CTRL's bit fields.
     *
     * (read-write) CM sleep PLL control
     */
    inline void set_CM_SLEEP_PLL_CTRL(
        bool DISABLE, GPC_CPU_MODE_CTRL_0_CM_SLEEP_PLL_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_PLL_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_SLEEP_PLL_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_SLEEP_ISO_CTRL_DISABLE() volatile
    {
        return CM_SLEEP_ISO_CTRL & (1u << 31u);
    }

    /**
     * Set CM_SLEEP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_SLEEP_ISO_CTRL_DISABLE() volatile
    {
        CM_SLEEP_ISO_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_SLEEP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_SLEEP_ISO_CTRL_DISABLE() volatile
    {
        CM_SLEEP_ISO_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_SLEEP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_SLEEP_ISO_CTRL_DISABLE() volatile
    {
        CM_SLEEP_ISO_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_SLEEP_ISO_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE
    get_CM_SLEEP_ISO_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE(
            (CM_SLEEP_ISO_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_SLEEP_ISO_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_SLEEP_ISO_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_SLEEP_ISO_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_SLEEP_ISO_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_ISO_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_SLEEP_ISO_CTRL_STEP_CNT() volatile
    {
        return (CM_SLEEP_ISO_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SLEEP_ISO_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_SLEEP_ISO_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_SLEEP_ISO_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SLEEP_ISO_CTRL = curr;
    }

    /**
     * Get all of CM_SLEEP_ISO_CTRL's bit fields.
     *
     * (read-write) CM sleep isolation control
     */
    inline void get_CM_SLEEP_ISO_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_ISO_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_SLEEP_ISO_CTRL's bit fields.
     *
     * (read-write) CM sleep isolation control
     */
    inline void set_CM_SLEEP_ISO_CTRL(
        bool DISABLE, GPC_CPU_MODE_CTRL_0_CM_SLEEP_ISO_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_ISO_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_SLEEP_ISO_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_SLEEP_RESET_CTRL_DISABLE() volatile
    {
        return CM_SLEEP_RESET_CTRL & (1u << 31u);
    }

    /**
     * Set CM_SLEEP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_SLEEP_RESET_CTRL_DISABLE() volatile
    {
        CM_SLEEP_RESET_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_SLEEP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_SLEEP_RESET_CTRL_DISABLE() volatile
    {
        CM_SLEEP_RESET_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_SLEEP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_SLEEP_RESET_CTRL_DISABLE() volatile
    {
        CM_SLEEP_RESET_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_SLEEP_RESET_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE
    get_CM_SLEEP_RESET_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE(
            (CM_SLEEP_RESET_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_SLEEP_RESET_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_SLEEP_RESET_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_SLEEP_RESET_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_SLEEP_RESET_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_RESET_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_SLEEP_RESET_CTRL_STEP_CNT() volatile
    {
        return (CM_SLEEP_RESET_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SLEEP_RESET_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_SLEEP_RESET_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_SLEEP_RESET_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SLEEP_RESET_CTRL = curr;
    }

    /**
     * Get all of CM_SLEEP_RESET_CTRL's bit fields.
     *
     * (read-write) CM sleep reset control
     */
    inline void get_CM_SLEEP_RESET_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_RESET_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_SLEEP_RESET_CTRL's bit fields.
     *
     * (read-write) CM sleep reset control
     */
    inline void set_CM_SLEEP_RESET_CTRL(
        bool DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_RESET_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_RESET_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_SLEEP_RESET_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_SLEEP_POWER_CTRL_DISABLE() volatile
    {
        return CM_SLEEP_POWER_CTRL & (1u << 31u);
    }

    /**
     * Set CM_SLEEP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_SLEEP_POWER_CTRL_DISABLE() volatile
    {
        CM_SLEEP_POWER_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_SLEEP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_SLEEP_POWER_CTRL_DISABLE() volatile
    {
        CM_SLEEP_POWER_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_SLEEP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_SLEEP_POWER_CTRL_DISABLE() volatile
    {
        CM_SLEEP_POWER_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_SLEEP_POWER_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE
    get_CM_SLEEP_POWER_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE(
            (CM_SLEEP_POWER_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_SLEEP_POWER_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_SLEEP_POWER_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_SLEEP_POWER_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_SLEEP_POWER_CTRL = curr;
    }

    /**
     * Get CM_SLEEP_POWER_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_SLEEP_POWER_CTRL_STEP_CNT() volatile
    {
        return (CM_SLEEP_POWER_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SLEEP_POWER_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_SLEEP_POWER_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_SLEEP_POWER_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SLEEP_POWER_CTRL = curr;
    }

    /**
     * Get all of CM_SLEEP_POWER_CTRL's bit fields.
     *
     * (read-write) CM sleep power control
     */
    inline void get_CM_SLEEP_POWER_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_POWER_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_SLEEP_POWER_CTRL's bit fields.
     *
     * (read-write) CM sleep power control
     */
    inline void set_CM_SLEEP_POWER_CTRL(
        bool DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_SLEEP_POWER_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_SLEEP_POWER_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_SLEEP_POWER_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_WAKEUP_POWER_CTRL_DISABLE() volatile
    {
        return CM_WAKEUP_POWER_CTRL & (1u << 31u);
    }

    /**
     * Set CM_WAKEUP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_WAKEUP_POWER_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_POWER_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_WAKEUP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_WAKEUP_POWER_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_POWER_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_WAKEUP_POWER_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_WAKEUP_POWER_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_POWER_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_WAKEUP_POWER_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE
    get_CM_WAKEUP_POWER_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE(
            (CM_WAKEUP_POWER_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_WAKEUP_POWER_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_WAKEUP_POWER_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_WAKEUP_POWER_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_WAKEUP_POWER_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_POWER_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_WAKEUP_POWER_CTRL_STEP_CNT() volatile
    {
        return (CM_WAKEUP_POWER_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAKEUP_POWER_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_WAKEUP_POWER_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_WAKEUP_POWER_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAKEUP_POWER_CTRL = curr;
    }

    /**
     * Get all of CM_WAKEUP_POWER_CTRL's bit fields.
     *
     * (read-write) CM wakeup power control
     */
    inline void get_CM_WAKEUP_POWER_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_POWER_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_WAKEUP_POWER_CTRL's bit fields.
     *
     * (read-write) CM wakeup power control
     */
    inline void set_CM_WAKEUP_POWER_CTRL(
        bool DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_POWER_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_POWER_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_WAKEUP_POWER_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_WAKEUP_RESET_CTRL_DISABLE() volatile
    {
        return CM_WAKEUP_RESET_CTRL & (1u << 31u);
    }

    /**
     * Set CM_WAKEUP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_WAKEUP_RESET_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_RESET_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_WAKEUP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_WAKEUP_RESET_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_RESET_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_WAKEUP_RESET_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_WAKEUP_RESET_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_RESET_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_WAKEUP_RESET_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE
    get_CM_WAKEUP_RESET_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE(
            (CM_WAKEUP_RESET_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_WAKEUP_RESET_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_WAKEUP_RESET_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_WAKEUP_RESET_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_WAKEUP_RESET_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_RESET_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_WAKEUP_RESET_CTRL_STEP_CNT() volatile
    {
        return (CM_WAKEUP_RESET_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAKEUP_RESET_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_WAKEUP_RESET_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_WAKEUP_RESET_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAKEUP_RESET_CTRL = curr;
    }

    /**
     * Get all of CM_WAKEUP_RESET_CTRL's bit fields.
     *
     * (read-write) CM wakeup reset control
     */
    inline void get_CM_WAKEUP_RESET_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_RESET_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_WAKEUP_RESET_CTRL's bit fields.
     *
     * (read-write) CM wakeup reset control
     */
    inline void set_CM_WAKEUP_RESET_CTRL(
        bool DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_RESET_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_RESET_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_WAKEUP_RESET_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_WAKEUP_ISO_CTRL_DISABLE() volatile
    {
        return CM_WAKEUP_ISO_CTRL & (1u << 31u);
    }

    /**
     * Set CM_WAKEUP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_WAKEUP_ISO_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_ISO_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_WAKEUP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_WAKEUP_ISO_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_ISO_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_WAKEUP_ISO_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_WAKEUP_ISO_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_ISO_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_WAKEUP_ISO_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE
    get_CM_WAKEUP_ISO_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE(
            (CM_WAKEUP_ISO_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_WAKEUP_ISO_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_WAKEUP_ISO_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_WAKEUP_ISO_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_WAKEUP_ISO_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_ISO_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_WAKEUP_ISO_CTRL_STEP_CNT() volatile
    {
        return (CM_WAKEUP_ISO_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAKEUP_ISO_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_WAKEUP_ISO_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_WAKEUP_ISO_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAKEUP_ISO_CTRL = curr;
    }

    /**
     * Get all of CM_WAKEUP_ISO_CTRL's bit fields.
     *
     * (read-write) CM wakeup isolation control
     */
    inline void get_CM_WAKEUP_ISO_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_ISO_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_WAKEUP_ISO_CTRL's bit fields.
     *
     * (read-write) CM wakeup isolation control
     */
    inline void set_CM_WAKEUP_ISO_CTRL(
        bool DISABLE, GPC_CPU_MODE_CTRL_0_CM_WAKEUP_ISO_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_ISO_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_WAKEUP_ISO_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_WAKEUP_PLL_CTRL_DISABLE() volatile
    {
        return CM_WAKEUP_PLL_CTRL & (1u << 31u);
    }

    /**
     * Set CM_WAKEUP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_WAKEUP_PLL_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_PLL_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_WAKEUP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_WAKEUP_PLL_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_PLL_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_WAKEUP_PLL_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_WAKEUP_PLL_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_PLL_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_WAKEUP_PLL_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE
    get_CM_WAKEUP_PLL_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE(
            (CM_WAKEUP_PLL_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_WAKEUP_PLL_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_WAKEUP_PLL_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_WAKEUP_PLL_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_WAKEUP_PLL_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_PLL_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_WAKEUP_PLL_CTRL_STEP_CNT() volatile
    {
        return (CM_WAKEUP_PLL_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAKEUP_PLL_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_WAKEUP_PLL_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_WAKEUP_PLL_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAKEUP_PLL_CTRL = curr;
    }

    /**
     * Get all of CM_WAKEUP_PLL_CTRL's bit fields.
     *
     * (read-write) CM wakeup PLL control
     */
    inline void get_CM_WAKEUP_PLL_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_PLL_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_WAKEUP_PLL_CTRL's bit fields.
     *
     * (read-write) CM wakeup PLL control
     */
    inline void set_CM_WAKEUP_PLL_CTRL(
        bool DISABLE, GPC_CPU_MODE_CTRL_0_CM_WAKEUP_PLL_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_PLL_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_WAKEUP_PLL_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_WAKEUP_LPCG_CTRL_DISABLE() volatile
    {
        return CM_WAKEUP_LPCG_CTRL & (1u << 31u);
    }

    /**
     * Set CM_WAKEUP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_WAKEUP_LPCG_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_LPCG_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_WAKEUP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_WAKEUP_LPCG_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_LPCG_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_WAKEUP_LPCG_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_WAKEUP_LPCG_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_LPCG_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_WAKEUP_LPCG_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE
    get_CM_WAKEUP_LPCG_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE(
            (CM_WAKEUP_LPCG_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_WAKEUP_LPCG_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_WAKEUP_LPCG_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_WAKEUP_LPCG_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_WAKEUP_LPCG_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_LPCG_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_WAKEUP_LPCG_CTRL_STEP_CNT() volatile
    {
        return (CM_WAKEUP_LPCG_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAKEUP_LPCG_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_WAKEUP_LPCG_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_WAKEUP_LPCG_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAKEUP_LPCG_CTRL = curr;
    }

    /**
     * Get all of CM_WAKEUP_LPCG_CTRL's bit fields.
     *
     * (read-write) CM wakeup LPCG control
     */
    inline void get_CM_WAKEUP_LPCG_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_LPCG_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_WAKEUP_LPCG_CTRL's bit fields.
     *
     * (read-write) CM wakeup LPCG control
     */
    inline void set_CM_WAKEUP_LPCG_CTRL(
        bool DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_LPCG_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_LPCG_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_WAKEUP_LPCG_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline bool get_CM_WAKEUP_SSAR_CTRL_DISABLE() volatile
    {
        return CM_WAKEUP_SSAR_CTRL & (1u << 31u);
    }

    /**
     * Set CM_WAKEUP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void set_CM_WAKEUP_SSAR_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_SSAR_CTRL |= 1u << 31u;
    }

    /**
     * Clear CM_WAKEUP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void clear_CM_WAKEUP_SSAR_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_SSAR_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CM_WAKEUP_SSAR_CTRL's DISABLE bit.
     *
     * Disable this step
     */
    inline void toggle_CM_WAKEUP_SSAR_CTRL_DISABLE() volatile
    {
        CM_WAKEUP_SSAR_CTRL ^= 1u << 31u;
    }

    /**
     * Get CM_WAKEUP_SSAR_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE
    get_CM_WAKEUP_SSAR_CTRL_CNT_MODE() volatile
    {
        return GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE(
            (CM_WAKEUP_SSAR_CTRL >> 28u) & 0b11u);
    }

    /**
     * Set CM_WAKEUP_SSAR_CTRL's CNT_MODE field.
     *
     * Count mode
     */
    inline void set_CM_WAKEUP_SSAR_CTRL_CNT_MODE(
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE value) volatile
    {
        uint32_t curr = CM_WAKEUP_SSAR_CTRL;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        CM_WAKEUP_SSAR_CTRL = curr;
    }

    /**
     * Get CM_WAKEUP_SSAR_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline uint16_t get_CM_WAKEUP_SSAR_CTRL_STEP_CNT() volatile
    {
        return (CM_WAKEUP_SSAR_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAKEUP_SSAR_CTRL's STEP_CNT field.
     *
     * Step count, useage is depending on CNT_MODE
     */
    inline void set_CM_WAKEUP_SSAR_CTRL_STEP_CNT(uint16_t value) volatile
    {
        uint32_t curr = CM_WAKEUP_SSAR_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAKEUP_SSAR_CTRL = curr;
    }

    /**
     * Get all of CM_WAKEUP_SSAR_CTRL's bit fields.
     *
     * (read-write) CM wakeup SSAR control
     */
    inline void get_CM_WAKEUP_SSAR_CTRL(
        bool &DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE &CNT_MODE,
        uint16_t &STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_SSAR_CTRL;

        DISABLE = curr & (1u << 31u);
        CNT_MODE = GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE(
            (curr >> 28u) & 0b11u);
        STEP_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of CM_WAKEUP_SSAR_CTRL's bit fields.
     *
     * (read-write) CM wakeup SSAR control
     */
    inline void set_CM_WAKEUP_SSAR_CTRL(
        bool DISABLE,
        GPC_CPU_MODE_CTRL_0_CM_WAKEUP_SSAR_CTRL_CNT_MODE CNT_MODE,
        uint16_t STEP_CNT) volatile
    {
        uint32_t curr = CM_WAKEUP_SSAR_CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (DISABLE & 0b1u) << 31u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(CNT_MODE) & 0b11u) << 28u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STEP_CNT & 0b1111111111111111u) << 0u;

        CM_WAKEUP_SSAR_CTRL = curr;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_WAKEUP_SEL bit.
     *
     * Select the Setpoint transiton on the next CPU platform wakeup sequence
     */
    inline bool get_CM_SP_CTRL_CPU_SP_WAKEUP_SEL() volatile
    {
        return CM_SP_CTRL & (1u << 15u);
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_WAKEUP_SEL bit.
     *
     * Select the Setpoint transiton on the next CPU platform wakeup sequence
     */
    inline void set_CM_SP_CTRL_CPU_SP_WAKEUP_SEL() volatile
    {
        CM_SP_CTRL |= 1u << 15u;
    }

    /**
     * Clear CM_SP_CTRL's CPU_SP_WAKEUP_SEL bit.
     *
     * Select the Setpoint transiton on the next CPU platform wakeup sequence
     */
    inline void clear_CM_SP_CTRL_CPU_SP_WAKEUP_SEL() volatile
    {
        CM_SP_CTRL &= ~(1u << 15u);
    }

    /**
     * Toggle CM_SP_CTRL's CPU_SP_WAKEUP_SEL bit.
     *
     * Select the Setpoint transiton on the next CPU platform wakeup sequence
     */
    inline void toggle_CM_SP_CTRL_CPU_SP_WAKEUP_SEL() volatile
    {
        CM_SP_CTRL ^= 1u << 15u;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_WAKEUP field.
     *
     * The Setpoint that CPU want the system to transit to on next CPU platform
     * wakeup sequence
     */
    inline uint8_t get_CM_SP_CTRL_CPU_SP_WAKEUP() volatile
    {
        return (CM_SP_CTRL >> 11u) & 0b1111u;
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_WAKEUP field.
     *
     * The Setpoint that CPU want the system to transit to on next CPU platform
     * wakeup sequence
     */
    inline void set_CM_SP_CTRL_CPU_SP_WAKEUP(uint8_t value) volatile
    {
        uint32_t curr = CM_SP_CTRL;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CM_SP_CTRL = curr;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_WAKEUP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform wakeup sequence
     */
    inline bool get_CM_SP_CTRL_CPU_SP_WAKEUP_EN() volatile
    {
        return CM_SP_CTRL & (1u << 10u);
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_WAKEUP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform wakeup sequence
     */
    inline void set_CM_SP_CTRL_CPU_SP_WAKEUP_EN() volatile
    {
        CM_SP_CTRL |= 1u << 10u;
    }

    /**
     * Clear CM_SP_CTRL's CPU_SP_WAKEUP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform wakeup sequence
     */
    inline void clear_CM_SP_CTRL_CPU_SP_WAKEUP_EN() volatile
    {
        CM_SP_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CM_SP_CTRL's CPU_SP_WAKEUP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform wakeup sequence
     */
    inline void toggle_CM_SP_CTRL_CPU_SP_WAKEUP_EN() volatile
    {
        CM_SP_CTRL ^= 1u << 10u;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_SLEEP field.
     *
     * The Setpoint that CPU want the system to transit to on next CPU platform
     * sleep sequence
     */
    inline uint8_t get_CM_SP_CTRL_CPU_SP_SLEEP() volatile
    {
        return (CM_SP_CTRL >> 6u) & 0b1111u;
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_SLEEP field.
     *
     * The Setpoint that CPU want the system to transit to on next CPU platform
     * sleep sequence
     */
    inline void set_CM_SP_CTRL_CPU_SP_SLEEP(uint8_t value) volatile
    {
        uint32_t curr = CM_SP_CTRL;

        curr &= ~(0b1111u << 6u);
        curr |= (value & 0b1111u) << 6u;

        CM_SP_CTRL = curr;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_SLEEP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform sleep sequence
     */
    inline bool get_CM_SP_CTRL_CPU_SP_SLEEP_EN() volatile
    {
        return CM_SP_CTRL & (1u << 5u);
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_SLEEP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform sleep sequence
     */
    inline void set_CM_SP_CTRL_CPU_SP_SLEEP_EN() volatile
    {
        CM_SP_CTRL |= 1u << 5u;
    }

    /**
     * Clear CM_SP_CTRL's CPU_SP_SLEEP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform sleep sequence
     */
    inline void clear_CM_SP_CTRL_CPU_SP_SLEEP_EN() volatile
    {
        CM_SP_CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle CM_SP_CTRL's CPU_SP_SLEEP_EN bit.
     *
     * 1 means enable Setpoint transition on next CPU platform sleep sequence
     */
    inline void toggle_CM_SP_CTRL_CPU_SP_SLEEP_EN() volatile
    {
        CM_SP_CTRL ^= 1u << 5u;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_RUN field.
     *
     * The Setpoint that CPU want the system to transit to when CPU_SP_RUN_EN
     * is set
     */
    inline uint8_t get_CM_SP_CTRL_CPU_SP_RUN() volatile
    {
        return (CM_SP_CTRL >> 1u) & 0b1111u;
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_RUN field.
     *
     * The Setpoint that CPU want the system to transit to when CPU_SP_RUN_EN
     * is set
     */
    inline void set_CM_SP_CTRL_CPU_SP_RUN(uint8_t value) volatile
    {
        uint32_t curr = CM_SP_CTRL;

        curr &= ~(0b1111u << 1u);
        curr |= (value & 0b1111u) << 1u;

        CM_SP_CTRL = curr;
    }

    /**
     * Get CM_SP_CTRL's CPU_SP_RUN_EN bit.
     *
     * Request a Setpoint transition when this bit is set
     */
    inline bool get_CM_SP_CTRL_CPU_SP_RUN_EN() volatile
    {
        return CM_SP_CTRL & (1u << 0u);
    }

    /**
     * Set CM_SP_CTRL's CPU_SP_RUN_EN bit.
     *
     * Request a Setpoint transition when this bit is set
     */
    inline void set_CM_SP_CTRL_CPU_SP_RUN_EN() volatile
    {
        CM_SP_CTRL |= 1u << 0u;
    }

    /**
     * Clear CM_SP_CTRL's CPU_SP_RUN_EN bit.
     *
     * Request a Setpoint transition when this bit is set
     */
    inline void clear_CM_SP_CTRL_CPU_SP_RUN_EN() volatile
    {
        CM_SP_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CM_SP_CTRL's CPU_SP_RUN_EN bit.
     *
     * Request a Setpoint transition when this bit is set
     */
    inline void toggle_CM_SP_CTRL_CPU_SP_RUN_EN() volatile
    {
        CM_SP_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CM_SP_CTRL's bit fields.
     *
     * (read-write) CM Setpoint Control
     */
    inline void get_CM_SP_CTRL(bool &CPU_SP_WAKEUP_SEL, uint8_t &CPU_SP_WAKEUP,
                               bool &CPU_SP_WAKEUP_EN, uint8_t &CPU_SP_SLEEP,
                               bool &CPU_SP_SLEEP_EN, uint8_t &CPU_SP_RUN,
                               bool &CPU_SP_RUN_EN) volatile
    {
        uint32_t curr = CM_SP_CTRL;

        CPU_SP_WAKEUP_SEL = curr & (1u << 15u);
        CPU_SP_WAKEUP = (curr >> 11u) & 0b1111u;
        CPU_SP_WAKEUP_EN = curr & (1u << 10u);
        CPU_SP_SLEEP = (curr >> 6u) & 0b1111u;
        CPU_SP_SLEEP_EN = curr & (1u << 5u);
        CPU_SP_RUN = (curr >> 1u) & 0b1111u;
        CPU_SP_RUN_EN = curr & (1u << 0u);
    }

    /**
     * Set all of CM_SP_CTRL's bit fields.
     *
     * (read-write) CM Setpoint Control
     */
    inline void set_CM_SP_CTRL(bool CPU_SP_WAKEUP_SEL, uint8_t CPU_SP_WAKEUP,
                               bool CPU_SP_WAKEUP_EN, uint8_t CPU_SP_SLEEP,
                               bool CPU_SP_SLEEP_EN, uint8_t CPU_SP_RUN,
                               bool CPU_SP_RUN_EN) volatile
    {
        uint32_t curr = CM_SP_CTRL;

        curr &= ~(0b1u << 15u);
        curr |= (CPU_SP_WAKEUP_SEL & 0b1u) << 15u;
        curr &= ~(0b1111u << 11u);
        curr |= (CPU_SP_WAKEUP & 0b1111u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (CPU_SP_WAKEUP_EN & 0b1u) << 10u;
        curr &= ~(0b1111u << 6u);
        curr |= (CPU_SP_SLEEP & 0b1111u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (CPU_SP_SLEEP_EN & 0b1u) << 5u;
        curr &= ~(0b1111u << 1u);
        curr |= (CPU_SP_RUN & 0b1111u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CPU_SP_RUN_EN & 0b1u) << 0u;

        CM_SP_CTRL = curr;
    }

    /**
     * Get CM_SP_STAT's CPU_SP_TARGET field.
     *
     * The requested Setpoint from the CPU platform
     */
    inline uint8_t get_CM_SP_STAT_CPU_SP_TARGET() volatile
    {
        return (CM_SP_STAT >> 8u) & 0b1111u;
    }

    /**
     * Get CM_SP_STAT's CPU_SP_PREVIOUS field.
     *
     * The previous Setpoint of the system
     */
    inline uint8_t get_CM_SP_STAT_CPU_SP_PREVIOUS() volatile
    {
        return (CM_SP_STAT >> 4u) & 0b1111u;
    }

    /**
     * Get CM_SP_STAT's CPU_SP_CURRENT field.
     *
     * The current Setpoint of the system
     */
    inline uint8_t get_CM_SP_STAT_CPU_SP_CURRENT() volatile
    {
        return (CM_SP_STAT >> 0u) & 0b1111u;
    }

    /**
     * Get all of CM_SP_STAT's bit fields.
     *
     * (read-write) CM Setpoint Status
     */
    inline void get_CM_SP_STAT(uint8_t &CPU_SP_TARGET,
                               uint8_t &CPU_SP_PREVIOUS,
                               uint8_t &CPU_SP_CURRENT) volatile
    {
        uint32_t curr = CM_SP_STAT;

        CPU_SP_TARGET = (curr >> 8u) & 0b1111u;
        CPU_SP_PREVIOUS = (curr >> 4u) & 0b1111u;
        CPU_SP_CURRENT = (curr >> 0u) & 0b1111u;
    }

    /**
     * Get CM_RUN_MODE_MAPPING's CPU_RUN_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters RUN mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG field
     */
    inline uint16_t get_CM_RUN_MODE_MAPPING_CPU_RUN_MODE_MAPPING() volatile
    {
        return (CM_RUN_MODE_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_RUN_MODE_MAPPING's CPU_RUN_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters RUN mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG field
     */
    inline void set_CM_RUN_MODE_MAPPING_CPU_RUN_MODE_MAPPING(
        uint16_t value) volatile
    {
        uint32_t curr = CM_RUN_MODE_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_RUN_MODE_MAPPING = curr;
    }

    /**
     * Get CM_WAIT_MODE_MAPPING's CPU_WAIT_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters WAIT mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG
     */
    inline uint16_t get_CM_WAIT_MODE_MAPPING_CPU_WAIT_MODE_MAPPING() volatile
    {
        return (CM_WAIT_MODE_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_WAIT_MODE_MAPPING's CPU_WAIT_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters WAIT mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG
     */
    inline void set_CM_WAIT_MODE_MAPPING_CPU_WAIT_MODE_MAPPING(
        uint16_t value) volatile
    {
        uint32_t curr = CM_WAIT_MODE_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_WAIT_MODE_MAPPING = curr;
    }

    /**
     * Get CM_STOP_MODE_MAPPING's CPU_STOP_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters STOP mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG
     */
    inline uint16_t get_CM_STOP_MODE_MAPPING_CPU_STOP_MODE_MAPPING() volatile
    {
        return (CM_STOP_MODE_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_STOP_MODE_MAPPING's CPU_STOP_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters STOP mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG
     */
    inline void set_CM_STOP_MODE_MAPPING_CPU_STOP_MODE_MAPPING(
        uint16_t value) volatile
    {
        uint32_t curr = CM_STOP_MODE_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_STOP_MODE_MAPPING = curr;
    }

    /**
     * Get CM_SUSPEND_MODE_MAPPING's CPU_SUSPEND_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters SUSPEND mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG
     */
    inline uint16_t
    get_CM_SUSPEND_MODE_MAPPING_CPU_SUSPEND_MODE_MAPPING() volatile
    {
        return (CM_SUSPEND_MODE_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SUSPEND_MODE_MAPPING's CPU_SUSPEND_MODE_MAPPING field.
     *
     * Defines which Setpoint is allowed when CPU enters SUSPEND mode. Each bit
     * stands for 1 Setpoint, locked by LOCK_CFG
     */
    inline void set_CM_SUSPEND_MODE_MAPPING_CPU_SUSPEND_MODE_MAPPING(
        uint16_t value) volatile
    {
        uint32_t curr = CM_SUSPEND_MODE_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SUSPEND_MODE_MAPPING = curr;
    }

    /**
     * Get CM_SP0_MAPPING's CPU_SP0_MAPPING field.
     *
     * Defines when SP0 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP0_MAPPING_CPU_SP0_MAPPING() volatile
    {
        return (CM_SP0_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP0_MAPPING's CPU_SP0_MAPPING field.
     *
     * Defines when SP0 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP0_MAPPING_CPU_SP0_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP0_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP0_MAPPING = curr;
    }

    /**
     * Get CM_SP1_MAPPING's CPU_SP1_MAPPING field.
     *
     * Defines when SP1 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP1_MAPPING_CPU_SP1_MAPPING() volatile
    {
        return (CM_SP1_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP1_MAPPING's CPU_SP1_MAPPING field.
     *
     * Defines when SP1 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP1_MAPPING_CPU_SP1_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP1_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP1_MAPPING = curr;
    }

    /**
     * Get CM_SP2_MAPPING's CPU_SP2_MAPPING field.
     *
     * Defines when SP2 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP2_MAPPING_CPU_SP2_MAPPING() volatile
    {
        return (CM_SP2_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP2_MAPPING's CPU_SP2_MAPPING field.
     *
     * Defines when SP2 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP2_MAPPING_CPU_SP2_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP2_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP2_MAPPING = curr;
    }

    /**
     * Get CM_SP3_MAPPING's CPU_SP3_MAPPING field.
     *
     * Defines when SP3 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP3_MAPPING_CPU_SP3_MAPPING() volatile
    {
        return (CM_SP3_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP3_MAPPING's CPU_SP3_MAPPING field.
     *
     * Defines when SP3 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP3_MAPPING_CPU_SP3_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP3_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP3_MAPPING = curr;
    }

    /**
     * Get CM_SP4_MAPPING's CPU_SP4_MAPPING field.
     *
     * Defines when SP4 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP4_MAPPING_CPU_SP4_MAPPING() volatile
    {
        return (CM_SP4_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP4_MAPPING's CPU_SP4_MAPPING field.
     *
     * Defines when SP4 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP4_MAPPING_CPU_SP4_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP4_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP4_MAPPING = curr;
    }

    /**
     * Get CM_SP5_MAPPING's CPU_SP5_MAPPING field.
     *
     * Defines when SP5 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP5_MAPPING_CPU_SP5_MAPPING() volatile
    {
        return (CM_SP5_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP5_MAPPING's CPU_SP5_MAPPING field.
     *
     * Defines when SP5 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP5_MAPPING_CPU_SP5_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP5_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP5_MAPPING = curr;
    }

    /**
     * Get CM_SP6_MAPPING's CPU_SP6_MAPPING field.
     *
     * Defines when SP6 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP6_MAPPING_CPU_SP6_MAPPING() volatile
    {
        return (CM_SP6_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP6_MAPPING's CPU_SP6_MAPPING field.
     *
     * Defines when SP6 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP6_MAPPING_CPU_SP6_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP6_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP6_MAPPING = curr;
    }

    /**
     * Get CM_SP7_MAPPING's CPU_SP7_MAPPING field.
     *
     * Defines when SP7 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP7_MAPPING_CPU_SP7_MAPPING() volatile
    {
        return (CM_SP7_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP7_MAPPING's CPU_SP7_MAPPING field.
     *
     * Defines when SP7 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP7_MAPPING_CPU_SP7_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP7_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP7_MAPPING = curr;
    }

    /**
     * Get CM_SP8_MAPPING's CPU_SP8_MAPPING field.
     *
     * Defines when SP8 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP8_MAPPING_CPU_SP8_MAPPING() volatile
    {
        return (CM_SP8_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP8_MAPPING's CPU_SP8_MAPPING field.
     *
     * Defines when SP8 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP8_MAPPING_CPU_SP8_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP8_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP8_MAPPING = curr;
    }

    /**
     * Get CM_SP9_MAPPING's CPU_SP9_MAPPING field.
     *
     * Defines when SP9 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP9_MAPPING_CPU_SP9_MAPPING() volatile
    {
        return (CM_SP9_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP9_MAPPING's CPU_SP9_MAPPING field.
     *
     * Defines when SP9 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP9_MAPPING_CPU_SP9_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP9_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP9_MAPPING = curr;
    }

    /**
     * Get CM_SP10_MAPPING's CPU_SP10_MAPPING field.
     *
     * Defines when SP10 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP10_MAPPING_CPU_SP10_MAPPING() volatile
    {
        return (CM_SP10_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP10_MAPPING's CPU_SP10_MAPPING field.
     *
     * Defines when SP10 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP10_MAPPING_CPU_SP10_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP10_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP10_MAPPING = curr;
    }

    /**
     * Get CM_SP11_MAPPING's CPU_SP11_MAPPING field.
     *
     * Defines when SP11 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP11_MAPPING_CPU_SP11_MAPPING() volatile
    {
        return (CM_SP11_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP11_MAPPING's CPU_SP11_MAPPING field.
     *
     * Defines when SP11 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP11_MAPPING_CPU_SP11_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP11_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP11_MAPPING = curr;
    }

    /**
     * Get CM_SP12_MAPPING's CPU_SP12_MAPPING field.
     *
     * Defines when SP12 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP12_MAPPING_CPU_SP12_MAPPING() volatile
    {
        return (CM_SP12_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP12_MAPPING's CPU_SP12_MAPPING field.
     *
     * Defines when SP12 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP12_MAPPING_CPU_SP12_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP12_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP12_MAPPING = curr;
    }

    /**
     * Get CM_SP13_MAPPING's CPU_SP13_MAPPING field.
     *
     * Defines when SP13 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP13_MAPPING_CPU_SP13_MAPPING() volatile
    {
        return (CM_SP13_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP13_MAPPING's CPU_SP13_MAPPING field.
     *
     * Defines when SP13 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP13_MAPPING_CPU_SP13_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP13_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP13_MAPPING = curr;
    }

    /**
     * Get CM_SP14_MAPPING's CPU_SP14_MAPPING field.
     *
     * Defines when SP14 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP14_MAPPING_CPU_SP14_MAPPING() volatile
    {
        return (CM_SP14_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP14_MAPPING's CPU_SP14_MAPPING field.
     *
     * Defines when SP14 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP14_MAPPING_CPU_SP14_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP14_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP14_MAPPING = curr;
    }

    /**
     * Get CM_SP15_MAPPING's CPU_SP15_MAPPING field.
     *
     * Defines when SP15 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline uint16_t get_CM_SP15_MAPPING_CPU_SP15_MAPPING() volatile
    {
        return (CM_SP15_MAPPING >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CM_SP15_MAPPING's CPU_SP15_MAPPING field.
     *
     * Defines when SP15 is set as the CPU_SP_TARGET, which SP is allowed,
     * locked by LOCK_CFG field
     */
    inline void set_CM_SP15_MAPPING_CPU_SP15_MAPPING(uint16_t value) volatile
    {
        uint32_t curr = CM_SP15_MAPPING;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CM_SP15_MAPPING = curr;
    }

    /**
     * Get CM_STBY_CTRL's STBY_WAKEUP_BUSY bit.
     *
     * Indicate the CPU is busy exiting standby mode.
     */
    inline bool get_CM_STBY_CTRL_STBY_WAKEUP_BUSY() volatile
    {
        return CM_STBY_CTRL & (1u << 17u);
    }

    /**
     * Get CM_STBY_CTRL's STBY_SLEEP_BUSY bit.
     *
     * Indicate the CPU is busy entering standby mode.
     */
    inline bool get_CM_STBY_CTRL_STBY_SLEEP_BUSY() volatile
    {
        return CM_STBY_CTRL & (1u << 16u);
    }

    /**
     * Get CM_STBY_CTRL's STBY_SUSPEND bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering SUSPEND mode,
     * locked by LOCK_CFG field.
     */
    inline bool get_CM_STBY_CTRL_STBY_SUSPEND() volatile
    {
        return CM_STBY_CTRL & (1u << 2u);
    }

    /**
     * Set CM_STBY_CTRL's STBY_SUSPEND bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering SUSPEND mode,
     * locked by LOCK_CFG field.
     */
    inline void set_CM_STBY_CTRL_STBY_SUSPEND() volatile
    {
        CM_STBY_CTRL |= 1u << 2u;
    }

    /**
     * Clear CM_STBY_CTRL's STBY_SUSPEND bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering SUSPEND mode,
     * locked by LOCK_CFG field.
     */
    inline void clear_CM_STBY_CTRL_STBY_SUSPEND() volatile
    {
        CM_STBY_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CM_STBY_CTRL's STBY_SUSPEND bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering SUSPEND mode,
     * locked by LOCK_CFG field.
     */
    inline void toggle_CM_STBY_CTRL_STBY_SUSPEND() volatile
    {
        CM_STBY_CTRL ^= 1u << 2u;
    }

    /**
     * Get CM_STBY_CTRL's STBY_STOP bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering STOP mode,
     * locked by LOCK_CFG field.
     */
    inline bool get_CM_STBY_CTRL_STBY_STOP() volatile
    {
        return CM_STBY_CTRL & (1u << 1u);
    }

    /**
     * Set CM_STBY_CTRL's STBY_STOP bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering STOP mode,
     * locked by LOCK_CFG field.
     */
    inline void set_CM_STBY_CTRL_STBY_STOP() volatile
    {
        CM_STBY_CTRL |= 1u << 1u;
    }

    /**
     * Clear CM_STBY_CTRL's STBY_STOP bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering STOP mode,
     * locked by LOCK_CFG field.
     */
    inline void clear_CM_STBY_CTRL_STBY_STOP() volatile
    {
        CM_STBY_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CM_STBY_CTRL's STBY_STOP bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering STOP mode,
     * locked by LOCK_CFG field.
     */
    inline void toggle_CM_STBY_CTRL_STBY_STOP() volatile
    {
        CM_STBY_CTRL ^= 1u << 1u;
    }

    /**
     * Get CM_STBY_CTRL's STBY_WAIT bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering WAIT mode,
     * locked by LOCK_CFG field.
     */
    inline bool get_CM_STBY_CTRL_STBY_WAIT() volatile
    {
        return CM_STBY_CTRL & (1u << 0u);
    }

    /**
     * Set CM_STBY_CTRL's STBY_WAIT bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering WAIT mode,
     * locked by LOCK_CFG field.
     */
    inline void set_CM_STBY_CTRL_STBY_WAIT() volatile
    {
        CM_STBY_CTRL |= 1u << 0u;
    }

    /**
     * Clear CM_STBY_CTRL's STBY_WAIT bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering WAIT mode,
     * locked by LOCK_CFG field.
     */
    inline void clear_CM_STBY_CTRL_STBY_WAIT() volatile
    {
        CM_STBY_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CM_STBY_CTRL's STBY_WAIT bit.
     *
     * 0x1: Request the chip into standby mode when CPU entering WAIT mode,
     * locked by LOCK_CFG field.
     */
    inline void toggle_CM_STBY_CTRL_STBY_WAIT() volatile
    {
        CM_STBY_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CM_STBY_CTRL's bit fields.
     *
     * (read-write) CM standby control
     */
    inline void get_CM_STBY_CTRL(bool &STBY_WAKEUP_BUSY, bool &STBY_SLEEP_BUSY,
                                 bool &STBY_SUSPEND, bool &STBY_STOP,
                                 bool &STBY_WAIT) volatile
    {
        uint32_t curr = CM_STBY_CTRL;

        STBY_WAKEUP_BUSY = curr & (1u << 17u);
        STBY_SLEEP_BUSY = curr & (1u << 16u);
        STBY_SUSPEND = curr & (1u << 2u);
        STBY_STOP = curr & (1u << 1u);
        STBY_WAIT = curr & (1u << 0u);
    }

    /**
     * Set all of CM_STBY_CTRL's bit fields.
     *
     * (read-write) CM standby control
     */
    inline void set_CM_STBY_CTRL(bool STBY_SUSPEND, bool STBY_STOP,
                                 bool STBY_WAIT) volatile
    {
        uint32_t curr = CM_STBY_CTRL;

        curr &= ~(0b1u << 2u);
        curr |= (STBY_SUSPEND & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (STBY_STOP & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (STBY_WAIT & 0b1u) << 0u;

        CM_STBY_CTRL = curr;
    }
};

static_assert(sizeof(gpc_cpu_mode_ctrl_0) == gpc_cpu_mode_ctrl_0::size);

static volatile gpc_cpu_mode_ctrl_0 *const GPC_CPU_MODE_CTRL_0 =
    reinterpret_cast<gpc_cpu_mode_ctrl_0 *>(0x40C00000);

static volatile gpc_cpu_mode_ctrl_0 *const GPC_CPU_MODE_CTRL_1 =
    reinterpret_cast<gpc_cpu_mode_ctrl_0 *>(0x40C00800);

}; // namespace MIMXRT1176::CM7
