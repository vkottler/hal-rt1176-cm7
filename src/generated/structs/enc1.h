/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * QDC
 */
struct [[gnu::packed]] enc1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 52; /*!< enc1's size in bytes. */

    /* Fields. */
    uint16_t CTRL;  /*!< (read-write) Control Register */
    uint16_t FILT;  /*!< (read-write) Input Filter Register */
    uint16_t WTR;   /*!< (read-write) Watchdog Timeout Register */
    uint16_t POSD;  /*!< (read-write) Position Difference Counter Register */
    uint16_t POSDH; /*!< (read-write) Position Difference Hold Register */
    uint16_t REV;   /*!< (read-write) Revolution Counter Register */
    uint16_t REVH;  /*!< (read-write) Revolution Hold Register */
    uint16_t UPOS;  /*!< (read-write) Upper Position Counter Register */
    uint16_t LPOS;  /*!< (read-write) Lower Position Counter Register */
    uint16_t UPOSH; /*!< (read-write) Upper Position Hold Register */
    uint16_t LPOSH; /*!< (read-write) Lower Position Hold Register */
    uint16_t UINIT; /*!< (read-write) Upper Initialization Register */
    uint16_t LINIT; /*!< (read-write) Lower Initialization Register */
    uint16_t IMR;   /*!< (read-write) Input Monitor Register */
    uint16_t TST;   /*!< (read-write) Test Register */
    uint16_t CTRL2; /*!< (read-write) Control 2 Register */
    uint16_t UMOD;  /*!< (read-write) Upper Modulus Register */
    uint16_t LMOD;  /*!< (read-write) Lower Modulus Register */
    uint16_t UCOMP; /*!< (read-write) Upper Position Compare Register */
    uint16_t LCOMP; /*!< (read-write) Lower Position Compare Register */
    uint16_t LASTEDGE;   /*!< (read-write) Last Edge Time Register */
    uint16_t LASTEDGEH;  /*!< (read-write) Last Edge Time Hold Register */
    uint16_t POSDPER;    /*!< (read-write) Position Difference Period Counter
                            Register */
    uint16_t POSDPERBFR; /*!< (read-write) Position Difference Period Buffer
                            Register */
    uint16_t
        POSDPERH; /*!< (read-write) Position Difference Period Hold Register */
    uint16_t CTRL3; /*!< (read-write) Control 3 Register */

    /* Methods. */

    /**
     * Get CTRL's HIRQ bit.
     *
     * HOME Signal Transition Interrupt Request
     */
    inline bool get_CTRL_HIRQ() volatile
    {
        return CTRL & (1u << 15u);
    }

    /**
     * Set CTRL's HIRQ bit.
     *
     * HOME Signal Transition Interrupt Request
     */
    inline void set_CTRL_HIRQ() volatile
    {
        CTRL |= 1u << 15u;
    }

    /**
     * Clear CTRL's HIRQ bit.
     *
     * HOME Signal Transition Interrupt Request
     */
    inline void clear_CTRL_HIRQ() volatile
    {
        CTRL &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL's HIRQ bit.
     *
     * HOME Signal Transition Interrupt Request
     */
    inline void toggle_CTRL_HIRQ() volatile
    {
        CTRL ^= 1u << 15u;
    }

    /**
     * Get CTRL's HIE bit.
     *
     * HOME Interrupt Enable
     */
    inline bool get_CTRL_HIE() volatile
    {
        return CTRL & (1u << 14u);
    }

    /**
     * Set CTRL's HIE bit.
     *
     * HOME Interrupt Enable
     */
    inline void set_CTRL_HIE() volatile
    {
        CTRL |= 1u << 14u;
    }

    /**
     * Clear CTRL's HIE bit.
     *
     * HOME Interrupt Enable
     */
    inline void clear_CTRL_HIE() volatile
    {
        CTRL &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL's HIE bit.
     *
     * HOME Interrupt Enable
     */
    inline void toggle_CTRL_HIE() volatile
    {
        CTRL ^= 1u << 14u;
    }

    /**
     * Get CTRL's HIP bit.
     *
     * Enable HOME to Initialize Position Counters UPOS and LPOS
     */
    inline bool get_CTRL_HIP() volatile
    {
        return CTRL & (1u << 13u);
    }

    /**
     * Set CTRL's HIP bit.
     *
     * Enable HOME to Initialize Position Counters UPOS and LPOS
     */
    inline void set_CTRL_HIP() volatile
    {
        CTRL |= 1u << 13u;
    }

    /**
     * Clear CTRL's HIP bit.
     *
     * Enable HOME to Initialize Position Counters UPOS and LPOS
     */
    inline void clear_CTRL_HIP() volatile
    {
        CTRL &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL's HIP bit.
     *
     * Enable HOME to Initialize Position Counters UPOS and LPOS
     */
    inline void toggle_CTRL_HIP() volatile
    {
        CTRL ^= 1u << 13u;
    }

    /**
     * Get CTRL's HNE bit.
     *
     * Use Negative Edge of HOME Input
     */
    inline bool get_CTRL_HNE() volatile
    {
        return CTRL & (1u << 12u);
    }

    /**
     * Set CTRL's HNE bit.
     *
     * Use Negative Edge of HOME Input
     */
    inline void set_CTRL_HNE() volatile
    {
        CTRL |= 1u << 12u;
    }

    /**
     * Clear CTRL's HNE bit.
     *
     * Use Negative Edge of HOME Input
     */
    inline void clear_CTRL_HNE() volatile
    {
        CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL's HNE bit.
     *
     * Use Negative Edge of HOME Input
     */
    inline void toggle_CTRL_HNE() volatile
    {
        CTRL ^= 1u << 12u;
    }

    /**
     * Get CTRL's SWIP bit.
     *
     * Software-Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline bool get_CTRL_SWIP() volatile
    {
        return CTRL & (1u << 11u);
    }

    /**
     * Set CTRL's SWIP bit.
     *
     * Software-Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline void set_CTRL_SWIP() volatile
    {
        CTRL |= 1u << 11u;
    }

    /**
     * Clear CTRL's SWIP bit.
     *
     * Software-Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline void clear_CTRL_SWIP() volatile
    {
        CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL's SWIP bit.
     *
     * Software-Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline void toggle_CTRL_SWIP() volatile
    {
        CTRL ^= 1u << 11u;
    }

    /**
     * Get CTRL's REV bit.
     *
     * Enable Reverse Direction Counting
     */
    inline bool get_CTRL_REV() volatile
    {
        return CTRL & (1u << 10u);
    }

    /**
     * Set CTRL's REV bit.
     *
     * Enable Reverse Direction Counting
     */
    inline void set_CTRL_REV() volatile
    {
        CTRL |= 1u << 10u;
    }

    /**
     * Clear CTRL's REV bit.
     *
     * Enable Reverse Direction Counting
     */
    inline void clear_CTRL_REV() volatile
    {
        CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL's REV bit.
     *
     * Enable Reverse Direction Counting
     */
    inline void toggle_CTRL_REV() volatile
    {
        CTRL ^= 1u << 10u;
    }

    /**
     * Get CTRL's PH1 bit.
     *
     * Enable Signal Phase Count Mode
     */
    inline bool get_CTRL_PH1() volatile
    {
        return CTRL & (1u << 9u);
    }

    /**
     * Set CTRL's PH1 bit.
     *
     * Enable Signal Phase Count Mode
     */
    inline void set_CTRL_PH1() volatile
    {
        CTRL |= 1u << 9u;
    }

    /**
     * Clear CTRL's PH1 bit.
     *
     * Enable Signal Phase Count Mode
     */
    inline void clear_CTRL_PH1() volatile
    {
        CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL's PH1 bit.
     *
     * Enable Signal Phase Count Mode
     */
    inline void toggle_CTRL_PH1() volatile
    {
        CTRL ^= 1u << 9u;
    }

    /**
     * Get CTRL's XIRQ bit.
     *
     * INDEX Pulse Interrupt Request
     */
    inline bool get_CTRL_XIRQ() volatile
    {
        return CTRL & (1u << 8u);
    }

    /**
     * Set CTRL's XIRQ bit.
     *
     * INDEX Pulse Interrupt Request
     */
    inline void set_CTRL_XIRQ() volatile
    {
        CTRL |= 1u << 8u;
    }

    /**
     * Clear CTRL's XIRQ bit.
     *
     * INDEX Pulse Interrupt Request
     */
    inline void clear_CTRL_XIRQ() volatile
    {
        CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL's XIRQ bit.
     *
     * INDEX Pulse Interrupt Request
     */
    inline void toggle_CTRL_XIRQ() volatile
    {
        CTRL ^= 1u << 8u;
    }

    /**
     * Get CTRL's XIE bit.
     *
     * INDEX Pulse Interrupt Enable
     */
    inline bool get_CTRL_XIE() volatile
    {
        return CTRL & (1u << 7u);
    }

    /**
     * Set CTRL's XIE bit.
     *
     * INDEX Pulse Interrupt Enable
     */
    inline void set_CTRL_XIE() volatile
    {
        CTRL |= 1u << 7u;
    }

    /**
     * Clear CTRL's XIE bit.
     *
     * INDEX Pulse Interrupt Enable
     */
    inline void clear_CTRL_XIE() volatile
    {
        CTRL &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL's XIE bit.
     *
     * INDEX Pulse Interrupt Enable
     */
    inline void toggle_CTRL_XIE() volatile
    {
        CTRL ^= 1u << 7u;
    }

    /**
     * Get CTRL's XIP bit.
     *
     * INDEX Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline bool get_CTRL_XIP() volatile
    {
        return CTRL & (1u << 6u);
    }

    /**
     * Set CTRL's XIP bit.
     *
     * INDEX Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline void set_CTRL_XIP() volatile
    {
        CTRL |= 1u << 6u;
    }

    /**
     * Clear CTRL's XIP bit.
     *
     * INDEX Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline void clear_CTRL_XIP() volatile
    {
        CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL's XIP bit.
     *
     * INDEX Triggered Initialization of Position Counters UPOS and LPOS
     */
    inline void toggle_CTRL_XIP() volatile
    {
        CTRL ^= 1u << 6u;
    }

    /**
     * Get CTRL's XNE bit.
     *
     * Use Negative Edge of INDEX Pulse
     */
    inline bool get_CTRL_XNE() volatile
    {
        return CTRL & (1u << 5u);
    }

    /**
     * Set CTRL's XNE bit.
     *
     * Use Negative Edge of INDEX Pulse
     */
    inline void set_CTRL_XNE() volatile
    {
        CTRL |= 1u << 5u;
    }

    /**
     * Clear CTRL's XNE bit.
     *
     * Use Negative Edge of INDEX Pulse
     */
    inline void clear_CTRL_XNE() volatile
    {
        CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL's XNE bit.
     *
     * Use Negative Edge of INDEX Pulse
     */
    inline void toggle_CTRL_XNE() volatile
    {
        CTRL ^= 1u << 5u;
    }

    /**
     * Get CTRL's DIRQ bit.
     *
     * Watchdog Timeout Interrupt Request
     */
    inline bool get_CTRL_DIRQ() volatile
    {
        return CTRL & (1u << 4u);
    }

    /**
     * Set CTRL's DIRQ bit.
     *
     * Watchdog Timeout Interrupt Request
     */
    inline void set_CTRL_DIRQ() volatile
    {
        CTRL |= 1u << 4u;
    }

    /**
     * Clear CTRL's DIRQ bit.
     *
     * Watchdog Timeout Interrupt Request
     */
    inline void clear_CTRL_DIRQ() volatile
    {
        CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL's DIRQ bit.
     *
     * Watchdog Timeout Interrupt Request
     */
    inline void toggle_CTRL_DIRQ() volatile
    {
        CTRL ^= 1u << 4u;
    }

    /**
     * Get CTRL's DIE bit.
     *
     * Watchdog Timeout Interrupt Enable
     */
    inline bool get_CTRL_DIE() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's DIE bit.
     *
     * Watchdog Timeout Interrupt Enable
     */
    inline void set_CTRL_DIE() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's DIE bit.
     *
     * Watchdog Timeout Interrupt Enable
     */
    inline void clear_CTRL_DIE() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's DIE bit.
     *
     * Watchdog Timeout Interrupt Enable
     */
    inline void toggle_CTRL_DIE() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get CTRL's WDE bit.
     *
     * Watchdog Enable
     */
    inline bool get_CTRL_WDE() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's WDE bit.
     *
     * Watchdog Enable
     */
    inline void set_CTRL_WDE() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's WDE bit.
     *
     * Watchdog Enable
     */
    inline void clear_CTRL_WDE() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's WDE bit.
     *
     * Watchdog Enable
     */
    inline void toggle_CTRL_WDE() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's CMPIRQ bit.
     *
     * Compare Interrupt Request
     */
    inline bool get_CTRL_CMPIRQ() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's CMPIRQ bit.
     *
     * Compare Interrupt Request
     */
    inline void set_CTRL_CMPIRQ() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's CMPIRQ bit.
     *
     * Compare Interrupt Request
     */
    inline void clear_CTRL_CMPIRQ() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's CMPIRQ bit.
     *
     * Compare Interrupt Request
     */
    inline void toggle_CTRL_CMPIRQ() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's CMPIE bit.
     *
     * Compare Interrupt Enable
     */
    inline bool get_CTRL_CMPIE() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's CMPIE bit.
     *
     * Compare Interrupt Enable
     */
    inline void set_CTRL_CMPIE() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's CMPIE bit.
     *
     * Compare Interrupt Enable
     */
    inline void clear_CTRL_CMPIE() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's CMPIE bit.
     *
     * Compare Interrupt Enable
     */
    inline void toggle_CTRL_CMPIE() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) Control Register
     */
    inline void get_CTRL(bool &HIRQ, bool &HIE, bool &HIP, bool &HNE,
                         bool &SWIP, bool &REV, bool &PH1, bool &XIRQ,
                         bool &XIE, bool &XIP, bool &XNE, bool &DIRQ,
                         bool &DIE, bool &WDE, bool &CMPIRQ,
                         bool &CMPIE) volatile
    {
        uint16_t curr = CTRL;

        HIRQ = curr & (1u << 15u);
        HIE = curr & (1u << 14u);
        HIP = curr & (1u << 13u);
        HNE = curr & (1u << 12u);
        SWIP = curr & (1u << 11u);
        REV = curr & (1u << 10u);
        PH1 = curr & (1u << 9u);
        XIRQ = curr & (1u << 8u);
        XIE = curr & (1u << 7u);
        XIP = curr & (1u << 6u);
        XNE = curr & (1u << 5u);
        DIRQ = curr & (1u << 4u);
        DIE = curr & (1u << 3u);
        WDE = curr & (1u << 2u);
        CMPIRQ = curr & (1u << 1u);
        CMPIE = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) Control Register
     */
    inline void set_CTRL(bool HIRQ, bool HIE, bool HIP, bool HNE, bool SWIP,
                         bool REV, bool PH1, bool XIRQ, bool XIE, bool XIP,
                         bool XNE, bool DIRQ, bool DIE, bool WDE, bool CMPIRQ,
                         bool CMPIE) volatile
    {
        uint16_t curr = CTRL;

        curr &= ~(0b1u << 15u);
        curr |= (HIRQ & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (HIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (HIP & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (HNE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (SWIP & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (REV & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (PH1 & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (XIRQ & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (XIE & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (XIP & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (XNE & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DIRQ & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (DIE & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (WDE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CMPIRQ & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (CMPIE & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get FILT's FILT_PRSC field.
     *
     * prescaler divide IPbus clock to FILT clk
     */
    inline uint8_t get_FILT_FILT_PRSC() volatile
    {
        return (FILT >> 13u) & 0b111u;
    }

    /**
     * Set FILT's FILT_PRSC field.
     *
     * prescaler divide IPbus clock to FILT clk
     */
    inline void set_FILT_FILT_PRSC(uint8_t value) volatile
    {
        uint16_t curr = FILT;

        curr &= ~(0b111u << 13u);
        curr |= (value & 0b111u) << 13u;

        FILT = curr;
    }

    /**
     * Get FILT's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline uint8_t get_FILT_FILT_CNT() volatile
    {
        return (FILT >> 8u) & 0b111u;
    }

    /**
     * Set FILT's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline void set_FILT_FILT_CNT(uint8_t value) volatile
    {
        uint16_t curr = FILT;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FILT = curr;
    }

    /**
     * Get FILT's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline uint8_t get_FILT_FILT_PER() volatile
    {
        return (FILT >> 0u) & 0b11111111u;
    }

    /**
     * Set FILT's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline void set_FILT_FILT_PER(uint8_t value) volatile
    {
        uint16_t curr = FILT;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        FILT = curr;
    }

    /**
     * Get all of FILT's bit fields.
     *
     * (read-write) Input Filter Register
     */
    inline void get_FILT(uint8_t &FILT_PRSC, uint8_t &FILT_CNT,
                         uint8_t &FILT_PER) volatile
    {
        uint16_t curr = FILT;

        FILT_PRSC = (curr >> 13u) & 0b111u;
        FILT_CNT = (curr >> 8u) & 0b111u;
        FILT_PER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of FILT's bit fields.
     *
     * (read-write) Input Filter Register
     */
    inline void set_FILT(uint8_t FILT_PRSC, uint8_t FILT_CNT,
                         uint8_t FILT_PER) volatile
    {
        uint16_t curr = FILT;

        curr &= ~(0b111u << 13u);
        curr |= (FILT_PRSC & 0b111u) << 13u;
        curr &= ~(0b111u << 8u);
        curr |= (FILT_CNT & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (FILT_PER & 0b11111111u) << 0u;

        FILT = curr;
    }

    /**
     * Get WTR's WDOG field.
     *
     * WDOG
     */
    inline uint16_t get_WTR_WDOG() volatile
    {
        return (WTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set WTR's WDOG field.
     *
     * WDOG
     */
    inline void set_WTR_WDOG(uint16_t value) volatile
    {
        uint16_t curr = WTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        WTR = curr;
    }

    /**
     * Get POSD's POSD field.
     *
     * POSD
     */
    inline uint16_t get_POSD_POSD() volatile
    {
        return (POSD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set POSD's POSD field.
     *
     * POSD
     */
    inline void set_POSD_POSD(uint16_t value) volatile
    {
        uint16_t curr = POSD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        POSD = curr;
    }

    /**
     * Get POSDH's POSDH field.
     *
     * POSDH
     */
    inline uint16_t get_POSDH_POSDH() volatile
    {
        return (POSDH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get REV's REV field.
     *
     * REV
     */
    inline uint16_t get_REV_REV() volatile
    {
        return (REV >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set REV's REV field.
     *
     * REV
     */
    inline void set_REV_REV(uint16_t value) volatile
    {
        uint16_t curr = REV;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        REV = curr;
    }

    /**
     * Get REVH's REVH field.
     *
     * REVH
     */
    inline uint16_t get_REVH_REVH() volatile
    {
        return (REVH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get UPOS's POS field.
     *
     * POS
     */
    inline uint16_t get_UPOS_POS() volatile
    {
        return (UPOS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set UPOS's POS field.
     *
     * POS
     */
    inline void set_UPOS_POS(uint16_t value) volatile
    {
        uint16_t curr = UPOS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        UPOS = curr;
    }

    /**
     * Get LPOS's POS field.
     *
     * POS
     */
    inline uint16_t get_LPOS_POS() volatile
    {
        return (LPOS >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LPOS's POS field.
     *
     * POS
     */
    inline void set_LPOS_POS(uint16_t value) volatile
    {
        uint16_t curr = LPOS;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LPOS = curr;
    }

    /**
     * Get UPOSH's POSH field.
     *
     * POSH
     */
    inline uint16_t get_UPOSH_POSH() volatile
    {
        return (UPOSH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get LPOSH's POSH field.
     *
     * POSH
     */
    inline uint16_t get_LPOSH_POSH() volatile
    {
        return (LPOSH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get UINIT's INIT field.
     *
     * INIT
     */
    inline uint16_t get_UINIT_INIT() volatile
    {
        return (UINIT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set UINIT's INIT field.
     *
     * INIT
     */
    inline void set_UINIT_INIT(uint16_t value) volatile
    {
        uint16_t curr = UINIT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        UINIT = curr;
    }

    /**
     * Get LINIT's INIT field.
     *
     * INIT
     */
    inline uint16_t get_LINIT_INIT() volatile
    {
        return (LINIT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LINIT's INIT field.
     *
     * INIT
     */
    inline void set_LINIT_INIT(uint16_t value) volatile
    {
        uint16_t curr = LINIT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LINIT = curr;
    }

    /**
     * Get IMR's FPHA bit.
     *
     * FPHA
     */
    inline bool get_IMR_FPHA() volatile
    {
        return IMR & (1u << 7u);
    }

    /**
     * Get IMR's FPHB bit.
     *
     * FPHB
     */
    inline bool get_IMR_FPHB() volatile
    {
        return IMR & (1u << 6u);
    }

    /**
     * Get IMR's FIND bit.
     *
     * FIND
     */
    inline bool get_IMR_FIND() volatile
    {
        return IMR & (1u << 5u);
    }

    /**
     * Get IMR's FHOM bit.
     *
     * FHOM
     */
    inline bool get_IMR_FHOM() volatile
    {
        return IMR & (1u << 4u);
    }

    /**
     * Get IMR's PHA bit.
     *
     * PHA
     */
    inline bool get_IMR_PHA() volatile
    {
        return IMR & (1u << 3u);
    }

    /**
     * Get IMR's PHB bit.
     *
     * PHB
     */
    inline bool get_IMR_PHB() volatile
    {
        return IMR & (1u << 2u);
    }

    /**
     * Get IMR's INDEX bit.
     *
     * INDEX
     */
    inline bool get_IMR_INDEX() volatile
    {
        return IMR & (1u << 1u);
    }

    /**
     * Get IMR's HOME bit.
     *
     * HOME
     */
    inline bool get_IMR_HOME() volatile
    {
        return IMR & (1u << 0u);
    }

    /**
     * Get all of IMR's bit fields.
     *
     * (read-write) Input Monitor Register
     */
    inline void get_IMR(bool &FPHA, bool &FPHB, bool &FIND, bool &FHOM,
                        bool &PHA, bool &PHB, bool &INDEX, bool &HOME) volatile
    {
        uint16_t curr = IMR;

        FPHA = curr & (1u << 7u);
        FPHB = curr & (1u << 6u);
        FIND = curr & (1u << 5u);
        FHOM = curr & (1u << 4u);
        PHA = curr & (1u << 3u);
        PHB = curr & (1u << 2u);
        INDEX = curr & (1u << 1u);
        HOME = curr & (1u << 0u);
    }

    /**
     * Get TST's TEN bit.
     *
     * Test Mode Enable
     */
    inline bool get_TST_TEN() volatile
    {
        return TST & (1u << 15u);
    }

    /**
     * Set TST's TEN bit.
     *
     * Test Mode Enable
     */
    inline void set_TST_TEN() volatile
    {
        TST |= 1u << 15u;
    }

    /**
     * Clear TST's TEN bit.
     *
     * Test Mode Enable
     */
    inline void clear_TST_TEN() volatile
    {
        TST &= ~(1u << 15u);
    }

    /**
     * Toggle TST's TEN bit.
     *
     * Test Mode Enable
     */
    inline void toggle_TST_TEN() volatile
    {
        TST ^= 1u << 15u;
    }

    /**
     * Get TST's TCE bit.
     *
     * Test Counter Enable
     */
    inline bool get_TST_TCE() volatile
    {
        return TST & (1u << 14u);
    }

    /**
     * Set TST's TCE bit.
     *
     * Test Counter Enable
     */
    inline void set_TST_TCE() volatile
    {
        TST |= 1u << 14u;
    }

    /**
     * Clear TST's TCE bit.
     *
     * Test Counter Enable
     */
    inline void clear_TST_TCE() volatile
    {
        TST &= ~(1u << 14u);
    }

    /**
     * Toggle TST's TCE bit.
     *
     * Test Counter Enable
     */
    inline void toggle_TST_TCE() volatile
    {
        TST ^= 1u << 14u;
    }

    /**
     * Get TST's QDN bit.
     *
     * Quadrature Decoder Negative Signal
     */
    inline bool get_TST_QDN() volatile
    {
        return TST & (1u << 13u);
    }

    /**
     * Set TST's QDN bit.
     *
     * Quadrature Decoder Negative Signal
     */
    inline void set_TST_QDN() volatile
    {
        TST |= 1u << 13u;
    }

    /**
     * Clear TST's QDN bit.
     *
     * Quadrature Decoder Negative Signal
     */
    inline void clear_TST_QDN() volatile
    {
        TST &= ~(1u << 13u);
    }

    /**
     * Toggle TST's QDN bit.
     *
     * Quadrature Decoder Negative Signal
     */
    inline void toggle_TST_QDN() volatile
    {
        TST ^= 1u << 13u;
    }

    /**
     * Get TST's TEST_PERIOD field.
     *
     * TEST_PERIOD
     */
    inline uint8_t get_TST_TEST_PERIOD() volatile
    {
        return (TST >> 8u) & 0b11111u;
    }

    /**
     * Set TST's TEST_PERIOD field.
     *
     * TEST_PERIOD
     */
    inline void set_TST_TEST_PERIOD(uint8_t value) volatile
    {
        uint16_t curr = TST;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        TST = curr;
    }

    /**
     * Get TST's TEST_COUNT field.
     *
     * TEST_COUNT
     */
    inline uint8_t get_TST_TEST_COUNT() volatile
    {
        return (TST >> 0u) & 0b11111111u;
    }

    /**
     * Set TST's TEST_COUNT field.
     *
     * TEST_COUNT
     */
    inline void set_TST_TEST_COUNT(uint8_t value) volatile
    {
        uint16_t curr = TST;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        TST = curr;
    }

    /**
     * Get all of TST's bit fields.
     *
     * (read-write) Test Register
     */
    inline void get_TST(bool &TEN, bool &TCE, bool &QDN, uint8_t &TEST_PERIOD,
                        uint8_t &TEST_COUNT) volatile
    {
        uint16_t curr = TST;

        TEN = curr & (1u << 15u);
        TCE = curr & (1u << 14u);
        QDN = curr & (1u << 13u);
        TEST_PERIOD = (curr >> 8u) & 0b11111u;
        TEST_COUNT = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of TST's bit fields.
     *
     * (read-write) Test Register
     */
    inline void set_TST(bool TEN, bool TCE, bool QDN, uint8_t TEST_PERIOD,
                        uint8_t TEST_COUNT) volatile
    {
        uint16_t curr = TST;

        curr &= ~(0b1u << 15u);
        curr |= (TEN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TCE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (QDN & 0b1u) << 13u;
        curr &= ~(0b11111u << 8u);
        curr |= (TEST_PERIOD & 0b11111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (TEST_COUNT & 0b11111111u) << 0u;

        TST = curr;
    }

    /**
     * Get CTRL2's SABIRQ bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Request
     */
    inline bool get_CTRL2_SABIRQ() volatile
    {
        return CTRL2 & (1u << 11u);
    }

    /**
     * Set CTRL2's SABIRQ bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Request
     */
    inline void set_CTRL2_SABIRQ() volatile
    {
        CTRL2 |= 1u << 11u;
    }

    /**
     * Clear CTRL2's SABIRQ bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Request
     */
    inline void clear_CTRL2_SABIRQ() volatile
    {
        CTRL2 &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL2's SABIRQ bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Request
     */
    inline void toggle_CTRL2_SABIRQ() volatile
    {
        CTRL2 ^= 1u << 11u;
    }

    /**
     * Get CTRL2's SABIE bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Enable
     */
    inline bool get_CTRL2_SABIE() volatile
    {
        return CTRL2 & (1u << 10u);
    }

    /**
     * Set CTRL2's SABIE bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Enable
     */
    inline void set_CTRL2_SABIE() volatile
    {
        CTRL2 |= 1u << 10u;
    }

    /**
     * Clear CTRL2's SABIE bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Enable
     */
    inline void clear_CTRL2_SABIE() volatile
    {
        CTRL2 &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL2's SABIE bit.
     *
     * Simultaneous PHASEA and PHASEB Change Interrupt Enable
     */
    inline void toggle_CTRL2_SABIE() volatile
    {
        CTRL2 ^= 1u << 10u;
    }

    /**
     * Get CTRL2's OUTCTL bit.
     *
     * Output Control
     */
    inline bool get_CTRL2_OUTCTL() volatile
    {
        return CTRL2 & (1u << 9u);
    }

    /**
     * Set CTRL2's OUTCTL bit.
     *
     * Output Control
     */
    inline void set_CTRL2_OUTCTL() volatile
    {
        CTRL2 |= 1u << 9u;
    }

    /**
     * Clear CTRL2's OUTCTL bit.
     *
     * Output Control
     */
    inline void clear_CTRL2_OUTCTL() volatile
    {
        CTRL2 &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL2's OUTCTL bit.
     *
     * Output Control
     */
    inline void toggle_CTRL2_OUTCTL() volatile
    {
        CTRL2 ^= 1u << 9u;
    }

    /**
     * Get CTRL2's REVMOD bit.
     *
     * Revolution Counter Modulus Enable
     */
    inline bool get_CTRL2_REVMOD() volatile
    {
        return CTRL2 & (1u << 8u);
    }

    /**
     * Set CTRL2's REVMOD bit.
     *
     * Revolution Counter Modulus Enable
     */
    inline void set_CTRL2_REVMOD() volatile
    {
        CTRL2 |= 1u << 8u;
    }

    /**
     * Clear CTRL2's REVMOD bit.
     *
     * Revolution Counter Modulus Enable
     */
    inline void clear_CTRL2_REVMOD() volatile
    {
        CTRL2 &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL2's REVMOD bit.
     *
     * Revolution Counter Modulus Enable
     */
    inline void toggle_CTRL2_REVMOD() volatile
    {
        CTRL2 ^= 1u << 8u;
    }

    /**
     * Get CTRL2's ROIRQ bit.
     *
     * Roll-over Interrupt Request
     */
    inline bool get_CTRL2_ROIRQ() volatile
    {
        return CTRL2 & (1u << 7u);
    }

    /**
     * Set CTRL2's ROIRQ bit.
     *
     * Roll-over Interrupt Request
     */
    inline void set_CTRL2_ROIRQ() volatile
    {
        CTRL2 |= 1u << 7u;
    }

    /**
     * Clear CTRL2's ROIRQ bit.
     *
     * Roll-over Interrupt Request
     */
    inline void clear_CTRL2_ROIRQ() volatile
    {
        CTRL2 &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL2's ROIRQ bit.
     *
     * Roll-over Interrupt Request
     */
    inline void toggle_CTRL2_ROIRQ() volatile
    {
        CTRL2 ^= 1u << 7u;
    }

    /**
     * Get CTRL2's ROIE bit.
     *
     * Roll-over Interrupt Enable
     */
    inline bool get_CTRL2_ROIE() volatile
    {
        return CTRL2 & (1u << 6u);
    }

    /**
     * Set CTRL2's ROIE bit.
     *
     * Roll-over Interrupt Enable
     */
    inline void set_CTRL2_ROIE() volatile
    {
        CTRL2 |= 1u << 6u;
    }

    /**
     * Clear CTRL2's ROIE bit.
     *
     * Roll-over Interrupt Enable
     */
    inline void clear_CTRL2_ROIE() volatile
    {
        CTRL2 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL2's ROIE bit.
     *
     * Roll-over Interrupt Enable
     */
    inline void toggle_CTRL2_ROIE() volatile
    {
        CTRL2 ^= 1u << 6u;
    }

    /**
     * Get CTRL2's RUIRQ bit.
     *
     * Roll-under Interrupt Request
     */
    inline bool get_CTRL2_RUIRQ() volatile
    {
        return CTRL2 & (1u << 5u);
    }

    /**
     * Set CTRL2's RUIRQ bit.
     *
     * Roll-under Interrupt Request
     */
    inline void set_CTRL2_RUIRQ() volatile
    {
        CTRL2 |= 1u << 5u;
    }

    /**
     * Clear CTRL2's RUIRQ bit.
     *
     * Roll-under Interrupt Request
     */
    inline void clear_CTRL2_RUIRQ() volatile
    {
        CTRL2 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL2's RUIRQ bit.
     *
     * Roll-under Interrupt Request
     */
    inline void toggle_CTRL2_RUIRQ() volatile
    {
        CTRL2 ^= 1u << 5u;
    }

    /**
     * Get CTRL2's RUIE bit.
     *
     * Roll-under Interrupt Enable
     */
    inline bool get_CTRL2_RUIE() volatile
    {
        return CTRL2 & (1u << 4u);
    }

    /**
     * Set CTRL2's RUIE bit.
     *
     * Roll-under Interrupt Enable
     */
    inline void set_CTRL2_RUIE() volatile
    {
        CTRL2 |= 1u << 4u;
    }

    /**
     * Clear CTRL2's RUIE bit.
     *
     * Roll-under Interrupt Enable
     */
    inline void clear_CTRL2_RUIE() volatile
    {
        CTRL2 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL2's RUIE bit.
     *
     * Roll-under Interrupt Enable
     */
    inline void toggle_CTRL2_RUIE() volatile
    {
        CTRL2 ^= 1u << 4u;
    }

    /**
     * Get CTRL2's DIR bit.
     *
     * Count Direction Flag
     */
    inline bool get_CTRL2_DIR() volatile
    {
        return CTRL2 & (1u << 3u);
    }

    /**
     * Get CTRL2's MOD bit.
     *
     * Enable Modulo Counting
     */
    inline bool get_CTRL2_MOD() volatile
    {
        return CTRL2 & (1u << 2u);
    }

    /**
     * Set CTRL2's MOD bit.
     *
     * Enable Modulo Counting
     */
    inline void set_CTRL2_MOD() volatile
    {
        CTRL2 |= 1u << 2u;
    }

    /**
     * Clear CTRL2's MOD bit.
     *
     * Enable Modulo Counting
     */
    inline void clear_CTRL2_MOD() volatile
    {
        CTRL2 &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL2's MOD bit.
     *
     * Enable Modulo Counting
     */
    inline void toggle_CTRL2_MOD() volatile
    {
        CTRL2 ^= 1u << 2u;
    }

    /**
     * Get CTRL2's UPDPOS bit.
     *
     * Update Position Registers
     */
    inline bool get_CTRL2_UPDPOS() volatile
    {
        return CTRL2 & (1u << 1u);
    }

    /**
     * Set CTRL2's UPDPOS bit.
     *
     * Update Position Registers
     */
    inline void set_CTRL2_UPDPOS() volatile
    {
        CTRL2 |= 1u << 1u;
    }

    /**
     * Clear CTRL2's UPDPOS bit.
     *
     * Update Position Registers
     */
    inline void clear_CTRL2_UPDPOS() volatile
    {
        CTRL2 &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL2's UPDPOS bit.
     *
     * Update Position Registers
     */
    inline void toggle_CTRL2_UPDPOS() volatile
    {
        CTRL2 ^= 1u << 1u;
    }

    /**
     * Get CTRL2's UPDHLD bit.
     *
     * Update Hold Registers
     */
    inline bool get_CTRL2_UPDHLD() volatile
    {
        return CTRL2 & (1u << 0u);
    }

    /**
     * Set CTRL2's UPDHLD bit.
     *
     * Update Hold Registers
     */
    inline void set_CTRL2_UPDHLD() volatile
    {
        CTRL2 |= 1u << 0u;
    }

    /**
     * Clear CTRL2's UPDHLD bit.
     *
     * Update Hold Registers
     */
    inline void clear_CTRL2_UPDHLD() volatile
    {
        CTRL2 &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL2's UPDHLD bit.
     *
     * Update Hold Registers
     */
    inline void toggle_CTRL2_UPDHLD() volatile
    {
        CTRL2 ^= 1u << 0u;
    }

    /**
     * Get all of CTRL2's bit fields.
     *
     * (read-write) Control 2 Register
     */
    inline void get_CTRL2(bool &SABIRQ, bool &SABIE, bool &OUTCTL,
                          bool &REVMOD, bool &ROIRQ, bool &ROIE, bool &RUIRQ,
                          bool &RUIE, bool &DIR, bool &MOD, bool &UPDPOS,
                          bool &UPDHLD) volatile
    {
        uint16_t curr = CTRL2;

        SABIRQ = curr & (1u << 11u);
        SABIE = curr & (1u << 10u);
        OUTCTL = curr & (1u << 9u);
        REVMOD = curr & (1u << 8u);
        ROIRQ = curr & (1u << 7u);
        ROIE = curr & (1u << 6u);
        RUIRQ = curr & (1u << 5u);
        RUIE = curr & (1u << 4u);
        DIR = curr & (1u << 3u);
        MOD = curr & (1u << 2u);
        UPDPOS = curr & (1u << 1u);
        UPDHLD = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL2's bit fields.
     *
     * (read-write) Control 2 Register
     */
    inline void set_CTRL2(bool SABIRQ, bool SABIE, bool OUTCTL, bool REVMOD,
                          bool ROIRQ, bool ROIE, bool RUIRQ, bool RUIE,
                          bool MOD, bool UPDPOS, bool UPDHLD) volatile
    {
        uint16_t curr = CTRL2;

        curr &= ~(0b1u << 11u);
        curr |= (SABIRQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (SABIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (OUTCTL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (REVMOD & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (ROIRQ & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ROIE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (RUIRQ & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (RUIE & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (MOD & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (UPDPOS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (UPDHLD & 0b1u) << 0u;

        CTRL2 = curr;
    }

    /**
     * Get UMOD's MOD field.
     *
     * MOD
     */
    inline uint16_t get_UMOD_MOD() volatile
    {
        return (UMOD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set UMOD's MOD field.
     *
     * MOD
     */
    inline void set_UMOD_MOD(uint16_t value) volatile
    {
        uint16_t curr = UMOD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        UMOD = curr;
    }

    /**
     * Get LMOD's MOD field.
     *
     * MOD
     */
    inline uint16_t get_LMOD_MOD() volatile
    {
        return (LMOD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LMOD's MOD field.
     *
     * MOD
     */
    inline void set_LMOD_MOD(uint16_t value) volatile
    {
        uint16_t curr = LMOD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LMOD = curr;
    }

    /**
     * Get UCOMP's COMP field.
     *
     * COMP
     */
    inline uint16_t get_UCOMP_COMP() volatile
    {
        return (UCOMP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set UCOMP's COMP field.
     *
     * COMP
     */
    inline void set_UCOMP_COMP(uint16_t value) volatile
    {
        uint16_t curr = UCOMP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        UCOMP = curr;
    }

    /**
     * Get LCOMP's COMP field.
     *
     * COMP
     */
    inline uint16_t get_LCOMP_COMP() volatile
    {
        return (LCOMP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LCOMP's COMP field.
     *
     * COMP
     */
    inline void set_LCOMP_COMP(uint16_t value) volatile
    {
        uint16_t curr = LCOMP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LCOMP = curr;
    }

    /**
     * Get LASTEDGE's LASTEDGE field.
     *
     * Last Edge Time Counter
     */
    inline uint16_t get_LASTEDGE_LASTEDGE() volatile
    {
        return (LASTEDGE >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get LASTEDGEH's LASTEDGEH field.
     *
     * Last Edge Time Hold
     */
    inline uint16_t get_LASTEDGEH_LASTEDGEH() volatile
    {
        return (LASTEDGEH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get POSDPER's POSDPER field.
     *
     * Position difference period
     */
    inline uint16_t get_POSDPER_POSDPER() volatile
    {
        return (POSDPER >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get POSDPERBFR's POSDPERBFR field.
     *
     * Position difference period buffer
     */
    inline uint16_t get_POSDPERBFR_POSDPERBFR() volatile
    {
        return (POSDPERBFR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get POSDPERH's POSDPERH field.
     *
     * Position difference period hold
     */
    inline uint16_t get_POSDPERH_POSDPERH() volatile
    {
        return (POSDPERH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Get CTRL3's PRSC field.
     *
     * Prescaler
     */
    inline uint8_t get_CTRL3_PRSC() volatile
    {
        return (CTRL3 >> 4u) & 0b1111u;
    }

    /**
     * Set CTRL3's PRSC field.
     *
     * Prescaler
     */
    inline void set_CTRL3_PRSC(uint8_t value) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CTRL3 = curr;
    }

    /**
     * Get CTRL3's PMEN bit.
     *
     * Period measurement function enable
     */
    inline bool get_CTRL3_PMEN() volatile
    {
        return CTRL3 & (1u << 0u);
    }

    /**
     * Set CTRL3's PMEN bit.
     *
     * Period measurement function enable
     */
    inline void set_CTRL3_PMEN() volatile
    {
        CTRL3 |= 1u << 0u;
    }

    /**
     * Clear CTRL3's PMEN bit.
     *
     * Period measurement function enable
     */
    inline void clear_CTRL3_PMEN() volatile
    {
        CTRL3 &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL3's PMEN bit.
     *
     * Period measurement function enable
     */
    inline void toggle_CTRL3_PMEN() volatile
    {
        CTRL3 ^= 1u << 0u;
    }

    /**
     * Get all of CTRL3's bit fields.
     *
     * (read-write) Control 3 Register
     */
    inline void get_CTRL3(uint8_t &PRSC, bool &PMEN) volatile
    {
        uint16_t curr = CTRL3;

        PRSC = (curr >> 4u) & 0b1111u;
        PMEN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL3's bit fields.
     *
     * (read-write) Control 3 Register
     */
    inline void set_CTRL3(uint8_t PRSC, bool PMEN) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b1111u << 4u);
        curr |= (PRSC & 0b1111u) << 4u;
        curr &= ~(0b1u << 0u);
        curr |= (PMEN & 0b1u) << 0u;

        CTRL3 = curr;
    }
};

static_assert(sizeof(enc1) == enc1::size);

static volatile enc1 *const ENC1 = reinterpret_cast<enc1 *>(0x40174000);

static volatile enc1 *const ENC2 = reinterpret_cast<enc1 *>(0x40178000);

static volatile enc1 *const ENC3 = reinterpret_cast<enc1 *>(0x4017C000);

static volatile enc1 *const ENC4 = reinterpret_cast<enc1 *>(0x40180000);

}; // namespace MIMXRT1176::CM7
