/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/IOMUXC_CCM_ENET_QOS_REF_CLK_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_IPG_CLK_RMII_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_MDIO_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_RXCLK_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_RXDATA_0_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_RXDATA_1_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_RXDATA_2_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_RXDATA_3_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_RXEN_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_1G_MAC0_TXCLK_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_ENET_QOS_PHY_RXER_I_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_FLEXSPI1_I_DQS_FA_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_LPUART1_LPUART_RXD_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_LPUART1_LPUART_TXD_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER1_TMR0_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER1_TMR1_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER2_TMR0_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER2_TMR1_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER3_TMR0_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER3_TMR1_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER4_TMR0_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_QTIMER4_TMR1_INPUT_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE.h"
#include "../enums/IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK.h"
#include "../enums/IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * IOMUXC
 */
struct [[gnu::packed]] iomuxc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 1816; /*!< iomuxc's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 4;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_00; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_00 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_01; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_01 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_02; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_02 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_03; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_03 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_04; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_04 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_05; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_05 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_06; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_06 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_07; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_07 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_08; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_08 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_09; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_09 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_10; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_10 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_11; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_11 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_12; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_12 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_13; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_13 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_14; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_14 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_15; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_15 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_16; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_16 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_17; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_17 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_18; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_18 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_19; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_19 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_20; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_20 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_21; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_21 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_22; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_22 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_23; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_23 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_24; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_24 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_25; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_25 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_26; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_26 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_27; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_27 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_28; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_28 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_29; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_29 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_30; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_30 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_31; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_31 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_32; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_32 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_33; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_33 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_34; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_34 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_35; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_35 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_36; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_36 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_37; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_37 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_38; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_38 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_39; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_39 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_40; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_40 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B1_41; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B1_41 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_00; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_00 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_01; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_01 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_02; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_02 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_03; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_03 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_04; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_04 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_05; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_05 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_06; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_06 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_07; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_07 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_08; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_08 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_09; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_09 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_10; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_10 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_11; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_11 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_12; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_12 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_13; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_13 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_14; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_14 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_15; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_15 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_16; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_16 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_17; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_17 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_18; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_18 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_19; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_19 SW
                                               MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_EMC_B2_20; /*!< (read-write)
                                               SW_MUX_CTL_PAD_GPIO_EMC_B2_20 SW
                                               MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_00; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_00
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_01; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_01
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_02; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_02
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_03; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_03
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_04; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_04
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_05; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_05
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_06; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_06
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_07; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_07
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_08; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_08
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_09; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_09
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_10; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_10
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_11; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_11
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_12; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_12
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_13; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_13
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_14; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_14
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_15; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_15
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_16; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_16
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_17; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_17
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_18; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_18
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_19; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_19
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_20; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_20
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_21; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_21
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_22; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_22
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_23; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_23
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_24; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_24
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_25; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_25
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_26; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_26
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_27; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_27
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_28; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_28
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_29; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_29
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_30; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_30
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_31; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_31
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_32; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_32
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_33; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_33
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_34; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_34
                                      SW MUX Control Register */
    uint32_t
        SW_MUX_CTL_PAD_GPIO_AD_35; /*!< (read-write) SW_MUX_CTL_PAD_GPIO_AD_35
                                      SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B1_00;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B1_00 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B1_01;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B1_01 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B1_02;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B1_02 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B1_03;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B1_03 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B1_04;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B1_05;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B1_05 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_00;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_00 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_01;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_01 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_02;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_02 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_03;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_03 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_04;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_04 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_05;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_05 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_06;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_06 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_07;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_07 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_08;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_08 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_09;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_09 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_10;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_10 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_SD_B2_11;   /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_SD_B2_11 SW
                                                MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_00; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_00
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_01; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_01
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_02; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_02
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_03; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_03
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_04; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_04
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_05; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_05
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_06; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_06
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_07; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_07
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_08; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_08
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_09; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_09
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_10; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_10
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B1_11; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B1_11
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_00; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_00
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_01; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_01
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_02; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_02
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_03; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_03
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_04; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_04
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_05; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_05
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_06; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_06
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_07; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_07
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_08; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_08
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_09; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_09
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_10; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_10
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_11; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_11
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_12; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_12
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_13; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_13
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_14; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_14
                                                SW MUX Control Register */
    uint32_t SW_MUX_CTL_PAD_GPIO_DISP_B2_15; /*!< (read-write)
                                                SW_MUX_CTL_PAD_GPIO_DISP_B2_15
                                                SW MUX Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_00;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_00 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_01;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_01 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_02;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_02 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_03;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_03 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_04;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_04 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_05;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_05 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_06;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_06 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_07;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_07 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_08;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_08 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_09;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_09 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_10;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_10 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_11;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_11 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_12;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_12 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_13;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_13 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_14;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_14 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_15;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_15 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_16;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_16 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_17;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_17 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_18;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_18 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_19;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_19 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_20;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_20 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_21;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_21 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_22;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_22 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_23;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_23 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_24;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_24 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_25;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_25 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_26;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_26 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_27;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_27 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_28;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_28 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_29;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_29 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_30;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_30 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_31;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_31 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_32;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_32 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_33;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_33 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_34;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_34 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_35;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_35 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_36;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_36 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_37;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_37 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_38;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_38 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_39;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_39 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_40;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_40 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B1_41;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B1_41 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_00;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_00 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_01;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_01 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_02;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_02 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_03;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_03 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_04;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_04 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_05;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_05 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_06;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_06 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_07;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_07 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_08;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_08 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_09;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_09 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_10;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_10 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_11;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_11 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_12;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_12 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_13;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_13 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_14;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_14 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_15;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_15 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_16;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_16 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_17;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_17 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_18;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_18 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_19;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_19 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_EMC_B2_20;  /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_EMC_B2_20 SW
                                                PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_00; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_00
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_01; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_01
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_02; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_02
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_03; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_03
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_04; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_04
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_05; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_05
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_06; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_06
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_07; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_07
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_08; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_08
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_09; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_09
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_10; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_10
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_11; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_11
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_12; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_12
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_13; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_13
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_14; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_14
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_15; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_15
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_16; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_16
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_17; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_17
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_18; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_18
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_19; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_19
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_20; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_20
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_21; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_21
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_22; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_22
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_23; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_23
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_24; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_24
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_25; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_25
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_26; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_26
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_27; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_27
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_28; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_28
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_29; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_29
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_30; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_30
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_31; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_31
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_32; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_32
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_33; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_33
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_34; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_34
                                      SW PAD Control Register */
    uint32_t
        SW_PAD_CTL_PAD_GPIO_AD_35; /*!< (read-write) SW_PAD_CTL_PAD_GPIO_AD_35
                                      SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B1_00;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B1_01;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B1_02;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B1_03;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B1_04;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B1_05;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_00;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_00 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_01;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_01 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_02;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_02 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_03;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_03 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_04;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_04 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_05;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_05 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_06;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_06 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_07;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_07 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_08;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_08 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_09;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_09 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_10;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_10 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_SD_B2_11;   /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_SD_B2_11 SW
                                                PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_00; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_00
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_01; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_01
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_02; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_02
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_03; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_03
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_04; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_04
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_05; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_05
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_06; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_06
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_07; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_07
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_08; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_08
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_09; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_09
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_10; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_10
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B1_11; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B1_11
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_00; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_00
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_01; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_01
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_02; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_02
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_03; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_03
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_04; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_04
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_05; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_05
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_06; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_06
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_07; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_07
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_08; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_08
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_09; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_09
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_10; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_10
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_11; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_11
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_12; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_12
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_13; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_13
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_14; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_14
                                                SW PAD Control Register */
    uint32_t SW_PAD_CTL_PAD_GPIO_DISP_B2_15; /*!< (read-write)
                                                SW_PAD_CTL_PAD_GPIO_DISP_B2_15
                                                SW PAD Control Register */
    uint32_t
        FLEXCAN1_RX_SELECT_INPUT; /*!< (read-write) FLEXCAN1_RX_SELECT_INPUT
                                     DAISY Register */
    uint32_t
        FLEXCAN2_RX_SELECT_INPUT; /*!< (read-write) FLEXCAN2_RX_SELECT_INPUT
                                     DAISY Register */
    uint32_t
        CCM_ENET_QOS_REF_CLK_SELECT_INPUT; /*!< (read-write)
                                              CCM_ENET_QOS_REF_CLK_SELECT_INPUT
                                              DAISY Register */
    uint32_t
        CCM_ENET_QOS_TX_CLK_SELECT_INPUT;    /*!< (read-write)
                                                CCM_ENET_QOS_TX_CLK_SELECT_INPUT
                                                DAISY Register */
    uint32_t ENET_IPG_CLK_RMII_SELECT_INPUT; /*!< (read-write)
                                                ENET_IPG_CLK_RMII_SELECT_INPUT
                                                DAISY Register */
    uint32_t ENET_MAC0_MDIO_SELECT_INPUT;    /*!< (read-write)
                                                ENET_MAC0_MDIO_SELECT_INPUT DAISY
                                                Register */
    uint32_t
        ENET_MAC0_RXDATA_SELECT_INPUT_0; /*!< (read-write)
                                            ENET_MAC0_RXDATA_SELECT_INPUT_0
                                            DAISY Register */
    uint32_t
        ENET_MAC0_RXDATA_SELECT_INPUT_1;   /*!< (read-write)
                                              ENET_MAC0_RXDATA_SELECT_INPUT_1
                                              DAISY Register */
    uint32_t ENET_MAC0_RXEN_SELECT_INPUT;  /*!< (read-write)
                                              ENET_MAC0_RXEN_SELECT_INPUT DAISY
                                              Register */
    uint32_t ENET_MAC0_RXERR_SELECT_INPUT; /*!< (read-write)
                                              ENET_MAC0_RXERR_SELECT_INPUT
                                              DAISY Register */
    uint32_t ENET_MAC0_TXCLK_SELECT_INPUT; /*!< (read-write)
                                              ENET_MAC0_TXCLK_SELECT_INPUT
                                              DAISY Register */
    uint32_t
        ENET_1G_IPG_CLK_RMII_SELECT_INPUT;   /*!< (read-write)
                                                ENET_1G_IPG_CLK_RMII_SELECT_INPUT
                                                DAISY Register */
    uint32_t ENET_1G_MAC0_MDIO_SELECT_INPUT; /*!< (read-write)
                                                ENET_1G_MAC0_MDIO_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        ENET_1G_MAC0_RXCLK_SELECT_INPUT; /*!< (read-write)
                                            ENET_1G_MAC0_RXCLK_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        ENET_1G_MAC0_RXDATA_0_SELECT_INPUT; /*!< (read-write)
                                               ENET_1G_MAC0_RXDATA_0_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        ENET_1G_MAC0_RXDATA_1_SELECT_INPUT; /*!< (read-write)
                                               ENET_1G_MAC0_RXDATA_1_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        ENET_1G_MAC0_RXDATA_2_SELECT_INPUT; /*!< (read-write)
                                               ENET_1G_MAC0_RXDATA_2_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        ENET_1G_MAC0_RXDATA_3_SELECT_INPUT;  /*!< (read-write)
                                                ENET_1G_MAC0_RXDATA_3_SELECT_INPUT
                                                DAISY Register */
    uint32_t ENET_1G_MAC0_RXEN_SELECT_INPUT; /*!< (read-write)
                                                ENET_1G_MAC0_RXEN_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        ENET_1G_MAC0_RXERR_SELECT_INPUT; /*!< (read-write)
                                            ENET_1G_MAC0_RXERR_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        ENET_1G_MAC0_TXCLK_SELECT_INPUT; /*!< (read-write)
                                            ENET_1G_MAC0_TXCLK_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        ENET_QOS_GMII_MDI_I_SELECT_INPUT; /*!< (read-write)
                                             ENET_QOS_GMII_MDI_I_SELECT_INPUT
                                             DAISY Register */
    uint32_t
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_0; /*!< (read-write)
                                              ENET_QOS_PHY_RXD_I_SELECT_INPUT_0
                                              DAISY Register */
    uint32_t
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_1; /*!< (read-write)
                                              ENET_QOS_PHY_RXD_I_SELECT_INPUT_1
                                              DAISY Register */
    uint32_t
        ENET_QOS_PHY_RXDV_I_SELECT_INPUT; /*!< (read-write)
                                             ENET_QOS_PHY_RXDV_I_SELECT_INPUT
                                             DAISY Register */
    uint32_t
        ENET_QOS_PHY_RXER_I_SELECT_INPUT;    /*!< (read-write)
                                                ENET_QOS_PHY_RXER_I_SELECT_INPUT
                                                DAISY Register */
    uint32_t FLEXPWM1_PWMA_SELECT_INPUT_0;   /*!< (read-write)
                                                FLEXPWM1_PWMA_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t FLEXPWM1_PWMA_SELECT_INPUT_1;   /*!< (read-write)
                                                FLEXPWM1_PWMA_SELECT_INPUT_1
                                                DAISY Register */
    uint32_t FLEXPWM1_PWMA_SELECT_INPUT_2;   /*!< (read-write)
                                                FLEXPWM1_PWMA_SELECT_INPUT_2
                                                DAISY Register */
    uint32_t FLEXPWM1_PWMB_SELECT_INPUT_0;   /*!< (read-write)
                                                FLEXPWM1_PWMB_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t FLEXPWM1_PWMB_SELECT_INPUT_1;   /*!< (read-write)
                                                FLEXPWM1_PWMB_SELECT_INPUT_1
                                                DAISY Register */
    uint32_t FLEXPWM1_PWMB_SELECT_INPUT_2;   /*!< (read-write)
                                                FLEXPWM1_PWMB_SELECT_INPUT_2
                                                DAISY Register */
    uint32_t FLEXPWM2_PWMA_SELECT_INPUT_0;   /*!< (read-write)
                                                FLEXPWM2_PWMA_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t FLEXPWM2_PWMA_SELECT_INPUT_1;   /*!< (read-write)
                                                FLEXPWM2_PWMA_SELECT_INPUT_1
                                                DAISY Register */
    uint32_t FLEXPWM2_PWMA_SELECT_INPUT_2;   /*!< (read-write)
                                                FLEXPWM2_PWMA_SELECT_INPUT_2
                                                DAISY Register */
    uint32_t FLEXPWM2_PWMB_SELECT_INPUT_0;   /*!< (read-write)
                                                FLEXPWM2_PWMB_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t FLEXPWM2_PWMB_SELECT_INPUT_1;   /*!< (read-write)
                                                FLEXPWM2_PWMB_SELECT_INPUT_1
                                                DAISY Register */
    uint32_t FLEXPWM2_PWMB_SELECT_INPUT_2;   /*!< (read-write)
                                                FLEXPWM2_PWMB_SELECT_INPUT_2
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMA_SELECT_INPUT_0;   /*!< (read-write)
                                                FLEXPWM3_PWMA_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMA_SELECT_INPUT_1;   /*!< (read-write)
                                                FLEXPWM3_PWMA_SELECT_INPUT_1
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMA_SELECT_INPUT_2;   /*!< (read-write)
                                                FLEXPWM3_PWMA_SELECT_INPUT_2
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMA_SELECT_INPUT_3;   /*!< (read-write)
                                                FLEXPWM3_PWMA_SELECT_INPUT_3
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMB_SELECT_INPUT_0;   /*!< (read-write)
                                                FLEXPWM3_PWMB_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMB_SELECT_INPUT_1;   /*!< (read-write)
                                                FLEXPWM3_PWMB_SELECT_INPUT_1
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMB_SELECT_INPUT_2;   /*!< (read-write)
                                                FLEXPWM3_PWMB_SELECT_INPUT_2
                                                DAISY Register */
    uint32_t FLEXPWM3_PWMB_SELECT_INPUT_3;   /*!< (read-write)
                                                FLEXPWM3_PWMB_SELECT_INPUT_3
                                                DAISY Register */
    uint32_t FLEXSPI1_I_DQS_FA_SELECT_INPUT; /*!< (read-write)
                                                FLEXSPI1_I_DQS_FA_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FA_SELECT_INPUT_0; /*!< (read-write)
                                            FLEXSPI1_I_IO_FA_SELECT_INPUT_0
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FA_SELECT_INPUT_1; /*!< (read-write)
                                            FLEXSPI1_I_IO_FA_SELECT_INPUT_1
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FA_SELECT_INPUT_2; /*!< (read-write)
                                            FLEXSPI1_I_IO_FA_SELECT_INPUT_2
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FA_SELECT_INPUT_3; /*!< (read-write)
                                            FLEXSPI1_I_IO_FA_SELECT_INPUT_3
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FB_SELECT_INPUT_0; /*!< (read-write)
                                            FLEXSPI1_I_IO_FB_SELECT_INPUT_0
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FB_SELECT_INPUT_1; /*!< (read-write)
                                            FLEXSPI1_I_IO_FB_SELECT_INPUT_1
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FB_SELECT_INPUT_2; /*!< (read-write)
                                            FLEXSPI1_I_IO_FB_SELECT_INPUT_2
                                            DAISY Register */
    uint32_t
        FLEXSPI1_I_IO_FB_SELECT_INPUT_3;     /*!< (read-write)
                                                FLEXSPI1_I_IO_FB_SELECT_INPUT_3
                                                DAISY Register */
    uint32_t FLEXSPI1_I_SCK_FA_SELECT_INPUT; /*!< (read-write)
                                                FLEXSPI1_I_SCK_FA_SELECT_INPUT
                                                DAISY Register */
    uint32_t FLEXSPI1_I_SCK_FB_SELECT_INPUT; /*!< (read-write)
                                                FLEXSPI1_I_SCK_FB_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        FLEXSPI2_I_IO_FA_SELECT_INPUT_0; /*!< (read-write)
                                            FLEXSPI2_I_IO_FA_SELECT_INPUT_0
                                            DAISY Register */
    uint32_t
        FLEXSPI2_I_IO_FA_SELECT_INPUT_1; /*!< (read-write)
                                            FLEXSPI2_I_IO_FA_SELECT_INPUT_1
                                            DAISY Register */
    uint32_t
        FLEXSPI2_I_IO_FA_SELECT_INPUT_2; /*!< (read-write)
                                            FLEXSPI2_I_IO_FA_SELECT_INPUT_2
                                            DAISY Register */
    uint32_t
        FLEXSPI2_I_IO_FA_SELECT_INPUT_3;     /*!< (read-write)
                                                FLEXSPI2_I_IO_FA_SELECT_INPUT_3
                                                DAISY Register */
    uint32_t FLEXSPI2_I_SCK_FA_SELECT_INPUT; /*!< (read-write)
                                                FLEXSPI2_I_SCK_FA_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        GPT3_CAPIN1_SELECT_INPUT; /*!< (read-write) GPT3_CAPIN1_SELECT_INPUT
                                     DAISY Register */
    uint32_t
        GPT3_CAPIN2_SELECT_INPUT; /*!< (read-write) GPT3_CAPIN2_SELECT_INPUT
                                     DAISY Register */
    uint32_t GPT3_CLKIN_SELECT_INPUT; /*!< (read-write) GPT3_CLKIN_SELECT_INPUT
                                         DAISY Register */
    uint32_t KPP_COL_SELECT_INPUT_6;  /*!< (read-write) KPP_COL_SELECT_INPUT_6
                                         DAISY Register */
    uint32_t KPP_COL_SELECT_INPUT_7;  /*!< (read-write) KPP_COL_SELECT_INPUT_7
                                         DAISY Register */
    uint32_t KPP_ROW_SELECT_INPUT_6;  /*!< (read-write) KPP_ROW_SELECT_INPUT_6
                                         DAISY Register */
    uint32_t KPP_ROW_SELECT_INPUT_7;  /*!< (read-write) KPP_ROW_SELECT_INPUT_7
                                         DAISY Register */
    uint32_t LPI2C1_LPI2C_SCL_SELECT_INPUT; /*!< (read-write)
                                               LPI2C1_LPI2C_SCL_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C1_LPI2C_SDA_SELECT_INPUT; /*!< (read-write)
                                               LPI2C1_LPI2C_SDA_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C2_LPI2C_SCL_SELECT_INPUT; /*!< (read-write)
                                               LPI2C2_LPI2C_SCL_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C2_LPI2C_SDA_SELECT_INPUT; /*!< (read-write)
                                               LPI2C2_LPI2C_SDA_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C3_LPI2C_SCL_SELECT_INPUT; /*!< (read-write)
                                               LPI2C3_LPI2C_SCL_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C3_LPI2C_SDA_SELECT_INPUT; /*!< (read-write)
                                               LPI2C3_LPI2C_SDA_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C4_LPI2C_SCL_SELECT_INPUT; /*!< (read-write)
                                               LPI2C4_LPI2C_SCL_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPI2C4_LPI2C_SDA_SELECT_INPUT; /*!< (read-write)
                                               LPI2C4_LPI2C_SDA_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        LPSPI1_LPSPI_PCS_SELECT_INPUT_0;    /*!< (read-write)
                                               LPSPI1_LPSPI_PCS_SELECT_INPUT_0
                                               DAISY Register */
    uint32_t LPSPI1_LPSPI_SCK_SELECT_INPUT; /*!< (read-write)
                                               LPSPI1_LPSPI_SCK_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI1_LPSPI_SDI_SELECT_INPUT; /*!< (read-write)
                                               LPSPI1_LPSPI_SDI_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI1_LPSPI_SDO_SELECT_INPUT; /*!< (read-write)
                                               LPSPI1_LPSPI_SDO_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        LPSPI2_LPSPI_PCS_SELECT_INPUT_0; /*!< (read-write)
                                            LPSPI2_LPSPI_PCS_SELECT_INPUT_0
                                            DAISY Register */
    uint32_t
        LPSPI2_LPSPI_PCS_SELECT_INPUT_1;    /*!< (read-write)
                                               LPSPI2_LPSPI_PCS_SELECT_INPUT_1
                                               DAISY Register */
    uint32_t LPSPI2_LPSPI_SCK_SELECT_INPUT; /*!< (read-write)
                                               LPSPI2_LPSPI_SCK_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI2_LPSPI_SDI_SELECT_INPUT; /*!< (read-write)
                                               LPSPI2_LPSPI_SDI_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI2_LPSPI_SDO_SELECT_INPUT; /*!< (read-write)
                                               LPSPI2_LPSPI_SDO_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        LPSPI3_LPSPI_PCS_SELECT_INPUT_0; /*!< (read-write)
                                            LPSPI3_LPSPI_PCS_SELECT_INPUT_0
                                            DAISY Register */
    uint32_t
        LPSPI3_LPSPI_PCS_SELECT_INPUT_1; /*!< (read-write)
                                            LPSPI3_LPSPI_PCS_SELECT_INPUT_1
                                            DAISY Register */
    uint32_t
        LPSPI3_LPSPI_PCS_SELECT_INPUT_2; /*!< (read-write)
                                            LPSPI3_LPSPI_PCS_SELECT_INPUT_2
                                            DAISY Register */
    uint32_t
        LPSPI3_LPSPI_PCS_SELECT_INPUT_3;    /*!< (read-write)
                                               LPSPI3_LPSPI_PCS_SELECT_INPUT_3
                                               DAISY Register */
    uint32_t LPSPI3_LPSPI_SCK_SELECT_INPUT; /*!< (read-write)
                                               LPSPI3_LPSPI_SCK_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI3_LPSPI_SDI_SELECT_INPUT; /*!< (read-write)
                                               LPSPI3_LPSPI_SDI_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI3_LPSPI_SDO_SELECT_INPUT; /*!< (read-write)
                                               LPSPI3_LPSPI_SDO_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        LPSPI4_LPSPI_PCS_SELECT_INPUT_0;    /*!< (read-write)
                                               LPSPI4_LPSPI_PCS_SELECT_INPUT_0
                                               DAISY Register */
    uint32_t LPSPI4_LPSPI_SCK_SELECT_INPUT; /*!< (read-write)
                                               LPSPI4_LPSPI_SCK_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI4_LPSPI_SDI_SELECT_INPUT; /*!< (read-write)
                                               LPSPI4_LPSPI_SDI_SELECT_INPUT
                                               DAISY Register */
    uint32_t LPSPI4_LPSPI_SDO_SELECT_INPUT; /*!< (read-write)
                                               LPSPI4_LPSPI_SDO_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        LPUART1_LPUART_RXD_SELECT_INPUT; /*!< (read-write)
                                            LPUART1_LPUART_RXD_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        LPUART1_LPUART_TXD_SELECT_INPUT; /*!< (read-write)
                                            LPUART1_LPUART_TXD_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        LPUART10_LPUART_RXD_SELECT_INPUT; /*!< (read-write)
                                             LPUART10_LPUART_RXD_SELECT_INPUT
                                             DAISY Register */
    uint32_t
        LPUART10_LPUART_TXD_SELECT_INPUT; /*!< (read-write)
                                             LPUART10_LPUART_TXD_SELECT_INPUT
                                             DAISY Register */
    uint32_t
        LPUART7_LPUART_RXD_SELECT_INPUT; /*!< (read-write)
                                            LPUART7_LPUART_RXD_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        LPUART7_LPUART_TXD_SELECT_INPUT; /*!< (read-write)
                                            LPUART7_LPUART_TXD_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        LPUART8_LPUART_RXD_SELECT_INPUT; /*!< (read-write)
                                            LPUART8_LPUART_RXD_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        LPUART8_LPUART_TXD_SELECT_INPUT; /*!< (read-write)
                                            LPUART8_LPUART_TXD_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER1_TMR0_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER1_TMR0_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER1_TMR1_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER1_TMR1_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER1_TMR2_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER1_TMR2_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER2_TMR0_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER2_TMR0_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER2_TMR1_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER2_TMR1_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER2_TMR2_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER2_TMR2_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER3_TMR0_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER3_TMR0_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER3_TMR1_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER3_TMR1_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER3_TMR2_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER3_TMR2_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER4_TMR0_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER4_TMR0_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER4_TMR1_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER4_TMR1_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        QTIMER4_TMR2_INPUT_SELECT_INPUT; /*!< (read-write)
                                            QTIMER4_TMR2_INPUT_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT;  /*!< (read-write)
                                                SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT
                                                DAISY Register */
    uint32_t SAI1_SAI_RXBCLK_SELECT_INPUT;   /*!< (read-write)
                                                SAI1_SAI_RXBCLK_SELECT_INPUT
                                                DAISY Register */
    uint32_t SAI1_SAI_RXDATA_SELECT_INPUT_0; /*!< (read-write)
                                                SAI1_SAI_RXDATA_SELECT_INPUT_0
                                                DAISY Register */
    uint32_t SAI1_SAI_RXSYNC_SELECT_INPUT;   /*!< (read-write)
                                                SAI1_SAI_RXSYNC_SELECT_INPUT
                                                DAISY Register */
    uint32_t SAI1_SAI_TXBCLK_SELECT_INPUT;   /*!< (read-write)
                                                SAI1_SAI_TXBCLK_SELECT_INPUT
                                                DAISY Register */
    uint32_t SAI1_SAI_TXSYNC_SELECT_INPUT;   /*!< (read-write)
                                                SAI1_SAI_TXSYNC_SELECT_INPUT
                                                DAISY Register */
    static constexpr std::size_t reserved_padding1_length = 6;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t
        EMVSIM1_SIO_SELECT_INPUT; /*!< (read-write) EMVSIM1_SIO_SELECT_INPUT
                                     DAISY Register */
    uint32_t EMVSIM1_IPP_SIMPD_SELECT_INPUT; /*!< (read-write)
                                                EMVSIM1_IPP_SIMPD_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        EMVSIM1_POWER_FAIL_SELECT_INPUT; /*!< (read-write)
                                            EMVSIM1_POWER_FAIL_SELECT_INPUT
                                            DAISY Register */
    uint32_t
        EMVSIM2_SIO_SELECT_INPUT; /*!< (read-write) EMVSIM2_SIO_SELECT_INPUT
                                     DAISY Register */
    uint32_t EMVSIM2_IPP_SIMPD_SELECT_INPUT; /*!< (read-write)
                                                EMVSIM2_IPP_SIMPD_SELECT_INPUT
                                                DAISY Register */
    uint32_t
        EMVSIM2_POWER_FAIL_SELECT_INPUT;   /*!< (read-write)
                                              EMVSIM2_POWER_FAIL_SELECT_INPUT
                                              DAISY Register */
    uint32_t SPDIF_SPDIF_IN1_SELECT_INPUT; /*!< (read-write)
                                              SPDIF_SPDIF_IN1_SELECT_INPUT
                                              DAISY Register */
    uint32_t
        USB_OTG2_OC_SELECT_INPUT; /*!< (read-write) USB_OTG2_OC_SELECT_INPUT
                                     DAISY Register */
    uint32_t USB_OTG_OC_SELECT_INPUT; /*!< (read-write) USB_OTG_OC_SELECT_INPUT
                                         DAISY Register */
    uint32_t USBPHY1_USB_ID_SELECT_INPUT; /*!< (read-write)
                                             USBPHY1_USB_ID_SELECT_INPUT DAISY
                                             Register */
    uint32_t USBPHY2_USB_ID_SELECT_INPUT; /*!< (read-write)
                                             USBPHY2_USB_ID_SELECT_INPUT DAISY
                                             Register */
    uint32_t
        USDHC1_IPP_CARD_DET_SELECT_INPUT;   /*!< (read-write)
                                               USDHC1_IPP_CARD_DET_SELECT_INPUT
                                               DAISY Register */
    uint32_t USDHC1_IPP_WP_ON_SELECT_INPUT; /*!< (read-write)
                                               USDHC1_IPP_WP_ON_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        USDHC2_IPP_CARD_DET_SELECT_INPUT;   /*!< (read-write)
                                               USDHC2_IPP_CARD_DET_SELECT_INPUT
                                               DAISY Register */
    uint32_t USDHC2_IPP_WP_ON_SELECT_INPUT; /*!< (read-write)
                                               USDHC2_IPP_WP_ON_SELECT_INPUT
                                               DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_20; /*!< (read-write) XBAR1_IN_SELECT_INPUT_20
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_21; /*!< (read-write) XBAR1_IN_SELECT_INPUT_21
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_22; /*!< (read-write) XBAR1_IN_SELECT_INPUT_22
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_23; /*!< (read-write) XBAR1_IN_SELECT_INPUT_23
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_24; /*!< (read-write) XBAR1_IN_SELECT_INPUT_24
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_25; /*!< (read-write) XBAR1_IN_SELECT_INPUT_25
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_26; /*!< (read-write) XBAR1_IN_SELECT_INPUT_26
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_27; /*!< (read-write) XBAR1_IN_SELECT_INPUT_27
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_28; /*!< (read-write) XBAR1_IN_SELECT_INPUT_28
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_29; /*!< (read-write) XBAR1_IN_SELECT_INPUT_29
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_30; /*!< (read-write) XBAR1_IN_SELECT_INPUT_30
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_31; /*!< (read-write) XBAR1_IN_SELECT_INPUT_31
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_32; /*!< (read-write) XBAR1_IN_SELECT_INPUT_32
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_33; /*!< (read-write) XBAR1_IN_SELECT_INPUT_33
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_34; /*!< (read-write) XBAR1_IN_SELECT_INPUT_34
                                     DAISY Register */
    uint32_t
        XBAR1_IN_SELECT_INPUT_35; /*!< (read-write) XBAR1_IN_SELECT_INPUT_35
                                     DAISY Register */

    /* Methods. */

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_00;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_00(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_01;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_01(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_02;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_02(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_03;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_03(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_04;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_04(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_05;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_05(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_06 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_06 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_06 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_06 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_06;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_06 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_06 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_06(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_06;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_06 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_06(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_06_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_06;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_06 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_07 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_07 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_07 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_07 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_07;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_07 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_07 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_07(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_07;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_07 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_07(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_07_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_07;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_07 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_08 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_08 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_08 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_08 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_08;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_08 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_08 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_08(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_08;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_08 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_08(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_08_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_08;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_08 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_09 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_09 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_09 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_09 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_09;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_09 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_09 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_09(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_09;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_09 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_09(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_09_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_09;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_09 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_10 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_10 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_10 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_10 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_10;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_10 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_10 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_10(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_10;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_10 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_10(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_10_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_10;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_10 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_11 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_11 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_11 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_11 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_11 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_11 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_11(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_11;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_11 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_11(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_11_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_11;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_11 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_12's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_12 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_12 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_12 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_12 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_12;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_12 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_12 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_12(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_12;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_12 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_12(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_12_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_12;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_12 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_13's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_13 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_13 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_13 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_13 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_13;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_13 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_13 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_13(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_13;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_13 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_13(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_13_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_13;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_13 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_14's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_14 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_14 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_14 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_14 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_14;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_14 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_14 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_14(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_14;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_14 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_14(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_14_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_14;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_14 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_15's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_15 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_15 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_15 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_15 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_15;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_15 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_15 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_15(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_15;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_15 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_15(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_15_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_15;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_15 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_16's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_16 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_16 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_16 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_16 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_16's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_16 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_16's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_16;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_16 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_16's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_16 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_16(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_16;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_16's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_16 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_16(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_16_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_16;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_16 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_17's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_17 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_17 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_17 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_17 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_17's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_17 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_17's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_17;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_17 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_17's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_17 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_17(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_17;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_17's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_17 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_17(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_17_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_17;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_17 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_18's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_18 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_18 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_18 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_18 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_18's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_18 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_18's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_18;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_18 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_18's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_18 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_18(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_18;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_18's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_18 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_18(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_18_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_18;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_18 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_19's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_19 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_19 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_19 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_19 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_19's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_19 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_19's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_19;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_19 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_19's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_19 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_19(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_19;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_19's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_19 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_19(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_19_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_19;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_19 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_20's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_20 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_20 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_20 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_20 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_20's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_20 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_20's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_20;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_20 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_20's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_20 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_20(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_20;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_20's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_20 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_20(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_20_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_20;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_20 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_21's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_21 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_21's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_21 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_21's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_21 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_21's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_21 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_21's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_21 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_21's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_21;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_21 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_21's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_21 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_21(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_21;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_21's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_21 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_21(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_21_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_21;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_21 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_22's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_22 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_22's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_22 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_22's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_22 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_22's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_22 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_22's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_22 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_22's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_22;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_22 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_22's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_22 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_22(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_22;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_22's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_22 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_22(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_22_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_22;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_22 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_23's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_23 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_23's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_23 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_23's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_23 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_23's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_23 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_23's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_23 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_23's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_23;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_23 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_23's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_23 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_23(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_23;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_23's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_23 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_23(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_23_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_23;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_23 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_24's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_24 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_24's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_24 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_24's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_24 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_24's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_24 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_24's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_24 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_24's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_24;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_24 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_24's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_24 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_24(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_24;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_24's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_24 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_24(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_24_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_24;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_24 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_25's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_25 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_25's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_25 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_25's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_25 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_25's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_25 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_25's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_25 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_25's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_25;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_25 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_25's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_25 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_25(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_25;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_25's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_25 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_25(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_25_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_25;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_25 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_26's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_26 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_26's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_26 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_26's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_26 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_26's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_26 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_26's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_26 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_26's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_26;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_26 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_26's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_26 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_26(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_26;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_26's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_26 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_26(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_26_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_26;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_26 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_27's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_27 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_27's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_27 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_27's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_27 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_27's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_27 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_27's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_27 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_27's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_27;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_27 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_27's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_27 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_27(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_27;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_27's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_27 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_27(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_27_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_27;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_27 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_28's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_28 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_28's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_28 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_28's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_28 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_28's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_28 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_28's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_28 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_28's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_28;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_28 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_28's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_28 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_28(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_28;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_28's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_28 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_28(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_28_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_28;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_28 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_29's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_29 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_29's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_29 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_29's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_29 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_29's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_29 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_29's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_29 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_29's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_29;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_29 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_29's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_29 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_29(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_29;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_29's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_29 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_29(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_29_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_29;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_29 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_30's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_30 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_30's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_30 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_30's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_30 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_30's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_30 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_30's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_30 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_30's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_30;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_30 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_30's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_30 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_30(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_30;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_30's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_30 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_30(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_30_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_30;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_30 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_31's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_31 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_31's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_31 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_31's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_31 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_31's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_31 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_31's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_31 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_31's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_31;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_31 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_31's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_31 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_31(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_31;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_31's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_31 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_31(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_31_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_31;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_31 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_32's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_32 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_32's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_32 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_32's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_32 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_32's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_32 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_32's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_32 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_32's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_32;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_32 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_32's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_32 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_32(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_32;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_32's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_32 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_32(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_32_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_32;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_32 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_33's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_33 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_33's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_33 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_33's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_33 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_33's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_33 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_33's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_33 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_33's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_33;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_33 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_33's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_33 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_33(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_33;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_33's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_33 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_33(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_33_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_33;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_33 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_34's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_34 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_34's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_34 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_34's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_34 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_34's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_34 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_34's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_34 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_34's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_34;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_34 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_34's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_34 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_34(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_34;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_34's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_34 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_34(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_34_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_34;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_34 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_35's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_35 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_35's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_35 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_35's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_35 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_35's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_35 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_35's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_35 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_35's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_35;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_35 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_35's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_35 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_35(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_35;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_35's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_35 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_35(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_35_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_35;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_35 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_36's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_36 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_36's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_36 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_36's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_36 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_36's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_36 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_36's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_36 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_36's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_36;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_36 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_36's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_36 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_36(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_36;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_36's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_36 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_36(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_36_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_36;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_36 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_37's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_37 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_37's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_37 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_37's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_37 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_37's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_37 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_37's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_37 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_37's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_37;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_37 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_37's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_37 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_37(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_37;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_37's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_37 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_37(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_37_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_37;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_37 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_38's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_38 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_38's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_38 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_38's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_38 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_38's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_38 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_38's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_38 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_38's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_38;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_38 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_38's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_38 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_38(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_38;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_38's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_38 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_38(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_38_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_38;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_38 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_39's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_39 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_39's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_39 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_39's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_39 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_39's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_39 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_39's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_39 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_39's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_39;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_39 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_39's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_39 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_39(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_39;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_39's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_39 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_39(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_39_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_39;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_39 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_40's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_40 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_40's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_40 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_40's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_40 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_40's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_40 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_40's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_40 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_40's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_40;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_40 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_40's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_40 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_40(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_40;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_40's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_40 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_40(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_40_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_40;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_40 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_41's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B1_41 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_41's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_41 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B1_41's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_41 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B1_41's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B1_41 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B1_41's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B1_41 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B1_41's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_41;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_41 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B1_41's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_41 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B1_41(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_41;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B1_41's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B1_41 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B1_41(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B1_41_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B1_41;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B1_41 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_00;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_00(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_01;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_01(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_02;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_02(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_03;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_03(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_04;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_04(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_05;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_05(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_06 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_06 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_06 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_06 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_06;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_06 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_06 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_06(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_06;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_06 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_06(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_06_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_06;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_06 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_07 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_07 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_07 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_07 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_07;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_07 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_07 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_07(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_07;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_07 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_07(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_07_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_07;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_07 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_08 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_08 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_08 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_08 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_08;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_08 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_08 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_08(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_08;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_08 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_08(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_08_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_08;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_08 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_09 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_09 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_09 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_09 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_09;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_09 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_09 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_09(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_09;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_09 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_09(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_09_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_09;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_09 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_10 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_10 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_10 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_10 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_10;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_10 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_10 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_10(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_10;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_10 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_10(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_10_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_10;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_10 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_11 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_11 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_11 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_11 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_11 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_11 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_11(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_11;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_11 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_11(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_11_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_11;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_11 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_12 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_12 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_12 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_12 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_12;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_12 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_12 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_12(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_12;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_12 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_12(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_12_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_12;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_12 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_13 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_13 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_13 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_13 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_13;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_13 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_13 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_13(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_13;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_13 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_13(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_13_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_13;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_13 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_14 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_14 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_14 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_14 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_14;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_14 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_14 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_14(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_14;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_14 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_14(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_14_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_14;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_14 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_15 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_15 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_15 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_15 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_15;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_15 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_15 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_15(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_15;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_15 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_15(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_15_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_15;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_15 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_16's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_16 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_16 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_16 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_16 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_16's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_16 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_16's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_16;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_16 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_16's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_16 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_16(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_16;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_16's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_16 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_16(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_16_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_16;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_16 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_17's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_17 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_17 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_17 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_17 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_17's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_17 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_17's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_17;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_17 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_17's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_17 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_17(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_17;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_17's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_17 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_17(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_17_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_17;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_17 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_18's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_18 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_18 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_18 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_18 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_18's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_18 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_18's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_18;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_18 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_18's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_18 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_18(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_18;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_18's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_18 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_18(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_18_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_18;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_18 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_19's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_19 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_19 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_19 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_19 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_19's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_19 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_19's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_19;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_19 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_19's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_19 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_19(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_19;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_19's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_19 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_19(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_19_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_19;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_19 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_20's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_EMC_B2_20 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_20 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_EMC_B2_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_20 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_EMC_B2_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_EMC_B2_20 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_EMC_B2_20's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_EMC_B2_20 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_EMC_B2_20's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_20;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_20 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_EMC_B2_20's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_20 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_EMC_B2_20(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_20;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE((curr >> 0u) &
                                                                 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_EMC_B2_20's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_EMC_B2_20 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_EMC_B2_20(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_B2_20_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_EMC_B2_20;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_EMC_B2_20 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_00;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_00(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_01;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_01(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_02;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_02(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_03;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_03(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_04;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_04(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_05;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_05(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_06's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_06_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_06 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_06 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_06 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_06 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_06;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_06 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_06 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_06(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_06;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_06 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_06(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_06;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_06 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_07's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_07_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_07 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_07 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_07 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_07 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_07;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_07 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_07 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_07(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_07;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_07 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_07(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_07;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_07 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_08's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_08_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_08 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_08 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_08 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_08 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_08;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_08 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_08 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_08(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_08;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_08 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_08(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_08;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_08 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_09's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_09_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_09 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_09 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_09 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_09 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_09;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_09 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_09 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_09(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_09;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_09 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_09(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_09;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_09 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_10's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_10_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_10 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_10 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_10 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_10 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_10;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_10 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_10 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_10(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_10;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_10 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_10(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_10;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_10 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_11's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_11_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_11 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_11 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_11 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_11 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_11 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_11 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_11(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_11;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_11 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_11(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_11;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_11 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_12's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_12_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_12 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_12 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_12 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_12 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_12;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_12 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_12 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_12(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_12;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_12 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_12(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_12;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_12 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_13's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_13_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_13 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_13 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_13 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_13 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_13;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_13 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_13 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_13(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_13;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_13 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_13(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_13;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_13 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_14's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_14_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_14 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_14 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_14 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_14 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_14;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_14 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_14 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_14(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_14;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_14 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_14(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_14;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_14 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_15's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_15_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_15 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_15 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_15 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_15 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_15;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_15 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_15 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_15(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_15;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_15 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_15(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_15_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_15;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_15 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_16's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_16_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_16 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_16 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_16 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_16's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_16_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_16 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_16's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_16 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_16's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_16;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_16 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_16's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_16 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_16(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_16;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_16's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_16 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_16(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_16_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_16;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_16 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_17's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_17_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_17 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_17 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_17 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_17's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_17_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_17 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_17's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_17 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_17's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_17;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_17 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_17's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_17 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_17(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_17;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_17's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_17 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_17(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_17_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_17;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_17 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_18's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_18_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_18 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_18 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_18 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_18's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_18_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_18 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_18's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_18 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_18's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_18;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_18 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_18's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_18 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_18(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_18;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_18's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_18 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_18(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_18_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_18;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_18 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_19's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_19_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_19 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_19 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_19 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_19's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_19_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_19 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_19's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_19 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_19's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_19;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_19 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_19's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_19 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_19(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_19;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_19's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_19 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_19(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_19_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_19;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_19 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_20's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_20_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_20 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_20 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_20 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_20's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_20_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_20 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_20's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_20 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_20's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_20;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_20 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_20's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_20 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_20(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_20;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_20's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_20 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_20(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_20_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_20;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_20 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_21's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_21_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_21 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_21's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_21_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_21 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_21's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_21_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_21 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_21's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_21_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_21 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_21's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_21 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_21's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_21;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_21 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_21's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_21 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_21(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_21;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_21's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_21 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_21(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_21_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_21;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_21 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_22's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_22_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_22 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_22's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_22_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_22 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_22's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_22_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_22 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_22's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_22_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_22 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_22's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_22 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_22's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_22;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_22 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_22's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_22 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_22(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_22;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_22's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_22 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_22(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_22_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_22;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_22 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_23's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_23_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_23 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_23's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_23_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_23 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_23's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_23_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_23 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_23's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_23_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_23 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_23's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_23 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_23's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_23;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_23 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_23's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_23 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_23(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_23;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_23's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_23 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_23(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_23_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_23;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_23 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_24's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_24_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_24 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_24's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_24_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_24 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_24's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_24_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_24 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_24's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_24_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_24 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_24's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_24 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_24's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_24;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_24 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_24's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_24 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_24(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_24;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_24's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_24 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_24(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_24_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_24;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_24 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_25's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_25_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_25 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_25's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_25_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_25 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_25's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_25_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_25 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_25's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_25_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_25 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_25's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_25 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_25's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_25;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_25 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_25's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_25 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_25(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_25;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_25's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_25 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_25(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_25_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_25;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_25 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_26's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_26_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_26 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_26's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_26_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_26 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_26's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_26_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_26 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_26's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_26_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_26 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_26's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_26 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_26's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_26;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_26 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_26's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_26 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_26(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_26;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_26's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_26 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_26(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_26_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_26;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_26 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_27's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_27_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_27 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_27's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_27_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_27 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_27's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_27_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_27 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_27's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_27_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_27 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_27's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_27 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_27's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_27;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_27 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_27's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_27 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_27(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_27;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_27's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_27 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_27(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_27_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_27;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_27 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_28's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_28_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_28 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_28's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_28_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_28 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_28's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_28_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_28 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_28's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_28_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_28 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_28's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_28 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_28's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_28;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_28 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_28's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_28 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_28(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_28;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_28's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_28 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_28(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_28_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_28;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_28 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_29's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_29_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_29 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_29's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_29_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_29 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_29's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_29_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_29 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_29's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_29_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_29 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_29's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_29 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_29's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_29;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_29 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_29's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_29 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_29(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_29;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_29's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_29 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_29(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_29_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_29;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_29 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_30's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_30_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_30 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_30's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_30_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_30 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_30's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_30_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_30 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_30's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_30_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_30 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_30's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_30 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_30's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_30;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_30 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_30's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_30 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_30(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_30;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_30's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_30 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_30(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_30_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_30;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_30 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_31's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_31_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_31 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_31's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_31_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_31 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_31's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_31_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_31 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_31's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_31_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_31 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_31's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_31 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_31's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_31;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_31 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_31's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_31 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_31(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_31;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_31's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_31 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_31(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_31_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_31;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_31 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_32's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_32_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_32 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_32's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_32_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_32 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_32's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_32_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_32 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_32's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_32_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_32 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_32's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_32 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_32's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_32;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_32 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_32's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_32 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_32(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_32;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_32's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_32 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_32(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_32_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_32;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_32 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_33's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_33_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_33 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_33's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_33_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_33 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_33's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_33_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_33 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_33's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_33_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_33 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_33's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_33 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_33's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_33;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_33 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_33's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_33 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_33(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_33;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_33's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_33 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_33(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_33_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_33;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_33 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_34's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_34_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_34 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_34's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_34_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_34 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_34's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_34_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_34 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_34's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_34_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_34 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_34's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_34 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_34's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_34;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_34 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_34's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_34 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_34(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_34;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_34's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_34 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_34(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_34_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_34;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_34 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_35's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_AD_35_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_AD_35 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_35's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_35_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_35 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_AD_35's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_AD_35_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_35 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_AD_35's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_AD_35_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_AD_35 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_AD_35's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_AD_35 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_AD_35's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_35;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_35 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_AD_35's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_35 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_AD_35(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_35;

        SION = curr & (1u << 4u);
        MUX_MODE =
            IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_AD_35's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_AD_35 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_AD_35(
        bool SION, IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_35_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_AD_35;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_AD_35 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B1_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B1_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B1_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B1_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_00;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B1_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_00(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B1_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B1_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B1_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B1_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_01;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B1_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_01(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B1_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B1_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B1_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B1_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_02;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B1_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_02(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B1_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B1_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B1_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B1_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_03;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B1_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_03(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B1_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B1_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B1_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B1_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_04;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B1_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_04(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B1_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B1_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B1_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B1_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B1_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B1_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B1_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_05;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B1_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B1_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B1_05(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B1_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B1_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_00;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_00(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_01;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_01(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_02;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_02(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_03;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_03(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_04;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_04(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_05;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_05(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_06_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_06 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_06 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_06 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_06 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_06;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_06 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_06 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_06(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_06;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_06 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_06(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_06_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_06;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_06 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_07_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_07 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_07 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_07 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_07 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_07;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_07 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_07 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_07(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_07;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_07 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_07(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_07_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_07;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_07 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_08_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_08 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_08 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_08 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_08 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_08;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_08 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_08 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_08(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_08;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_08 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_08(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_08_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_08;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_08 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_09_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_09 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_09 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_09 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_09 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_09;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_09 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_09 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_09(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_09;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_09 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_09(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_09_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_09;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_09 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_10_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_10 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_10 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_10 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_10 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_10;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_10 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_10 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_10(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_10;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_10 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_10(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_10_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_10;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_10 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_SD_B2_11_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_SD_B2_11 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_11 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_SD_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_SD_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_SD_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_SD_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_SD_B2_11 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_SD_B2_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_SD_B2_11 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_SD_B2_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_11 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_SD_B2_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_11 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_SD_B2_11(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_11;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE((curr >> 0u) &
                                                                0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_SD_B2_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_SD_B2_11 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_SD_B2_11(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B2_11_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_SD_B2_11;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_SD_B2_11 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_00;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_00(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_01;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_01(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_02;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_02(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_03;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_03(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_04;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_04(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_05;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_05(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_06 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_06 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_06 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_06 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_06;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_06 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_06 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_06(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_06;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_06 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_06(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_06_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_06;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_06 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_07 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_07 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_07 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_07 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_07;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_07 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_07 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_07(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_07;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_07 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_07(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_07_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_07;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_07 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_08 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_08 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_08 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_08 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_08;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_08 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_08 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_08(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_08;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_08 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_08(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_08_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_08;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_08 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_09 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_09 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_09 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_09 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_09;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_09 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_09 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_09(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_09;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_09 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_09(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_09_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_09;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_09 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_10 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_10 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_10 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_10 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_10;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_10 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_10 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_10(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_10;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_10 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_10(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_10_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_10;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_10 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B1_11 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_11 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B1_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B1_11 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B1_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B1_11 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B1_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_11 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B1_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_11 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B1_11(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_11;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B1_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B1_11 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B1_11(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B1_11_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B1_11;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B1_11 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_00 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_00 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_00's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_00 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_00 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_00's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_00;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_00 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_00 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_00(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_00;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_00's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_00 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_00(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_00_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_00;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_00 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_01 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_01 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_01's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_01 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_01 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_01's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_01;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_01 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_01 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_01(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_01;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_01's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_01 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_01(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_01_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_01;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_01 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_02 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_02 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_02's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_02 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_02 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_02's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_02;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_02 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_02 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_02(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_02;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_02's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_02 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_02(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_02_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_02;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_02 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_03 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_03 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_03's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_03 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_03 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_03's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_03;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_03 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_03 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_03(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_03;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_03's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_03 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_03(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_03_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_03;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_03 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_04 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_04 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_04's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_04 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_04 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_04's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_04;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_04 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_04 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_04(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_04;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_04's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_04 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_04(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_04_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_04;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_04 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_05 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_05 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_05's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_05 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_05 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_05's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_05;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_05 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_05 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_05(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_05;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_05's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_05 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_05(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_05_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_05;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_05 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_06 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_06 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_06's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_06 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_06 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_06's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_06;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_06 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_06 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_06(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_06;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_06's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_06 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_06(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_06_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_06;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_06 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_07 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_07 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_07's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_07 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_07 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_07's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_07;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_07 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_07 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_07(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_07;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_07's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_07 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_07(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_07_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_07;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_07 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_08 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_08 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_08's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_08 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_08 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_08's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_08;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_08 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_08 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_08(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_08;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_08's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_08 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_08(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_08_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_08;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_08 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_09 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_09 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_09's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_09 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_09 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_09's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_09;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_09 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_09 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_09(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_09;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_09's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_09 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_09(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_09_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_09;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_09 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_10 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_10 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_10's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_10 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_10 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_10's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_10;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_10 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_10 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_10(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_10;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_10's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_10 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_10(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_10_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_10;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_10 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_11 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_11 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_11's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_11 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_11 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_11's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_11;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_11 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_11 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_11(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_11;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_11's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_11 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_11(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_11_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_11;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_11 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_12 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_12 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_12's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_12 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_12 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_12's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_12;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_12 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_12 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_12(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_12;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_12's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_12 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_12(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_12_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_12;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_12 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_13 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_13 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_13's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_13 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_13 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_13's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_13;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_13 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_13 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_13(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_13;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_13's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_13 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_13(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_13_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_13;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_13 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_14 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_14 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_14's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_14 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_14 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_14's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_14;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_14 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_14 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_14(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_14;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_14's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_14 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_14(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_14_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_14;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_14 = curr;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline bool get_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_SION() volatile
    {
        return SW_MUX_CTL_PAD_GPIO_DISP_B2_15 & (1u << 4u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_15 |= 1u << 4u;
    }

    /**
     * Clear SW_MUX_CTL_PAD_GPIO_DISP_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void clear_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_MUX_CTL_PAD_GPIO_DISP_B2_15's SION bit.
     *
     * Software Input On Field.
     */
    inline void toggle_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_SION() volatile
    {
        SW_MUX_CTL_PAD_GPIO_DISP_B2_15 ^= 1u << 4u;
    }

    /**
     * Get SW_MUX_CTL_PAD_GPIO_DISP_B2_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE
    get_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE() volatile
    {
        return IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE(
            (SW_MUX_CTL_PAD_GPIO_DISP_B2_15 >> 0u) & 0b1111u);
    }

    /**
     * Set SW_MUX_CTL_PAD_GPIO_DISP_B2_15's MUX_MODE field.
     *
     * MUX Mode Select Field.
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE(
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE value) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_15;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_15 = curr;
    }

    /**
     * Get all of SW_MUX_CTL_PAD_GPIO_DISP_B2_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_15 SW MUX Control Register
     */
    inline void get_SW_MUX_CTL_PAD_GPIO_DISP_B2_15(
        bool &SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE &MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_15;

        SION = curr & (1u << 4u);
        MUX_MODE = IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE(
            (curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of SW_MUX_CTL_PAD_GPIO_DISP_B2_15's bit fields.
     *
     * (read-write) SW_MUX_CTL_PAD_GPIO_DISP_B2_15 SW MUX Control Register
     */
    inline void set_SW_MUX_CTL_PAD_GPIO_DISP_B2_15(
        bool SION,
        IOMUXC_SW_MUX_CTL_PAD_GPIO_DISP_B2_15_MUX_MODE MUX_MODE) volatile
    {
        uint32_t curr = SW_MUX_CTL_PAD_GPIO_DISP_B2_15;

        curr &= ~(0b1u << 4u);
        curr |= (SION & 0b1u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(MUX_MODE) & 0b1111u) << 0u;

        SW_MUX_CTL_PAD_GPIO_DISP_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_00 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_00;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_00;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_00_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_01 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_01;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_01;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_01_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_02 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_02;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_02;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_02_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_03 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_03;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_03;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_03_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_04 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_04;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_04;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_04_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_05 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_05;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_05;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_05_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_06 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_06's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_06 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_06's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_06;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_06 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_06 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_06;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_06 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_06 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_06;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_06 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_06_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_07 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_07's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_07 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_07's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_07;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_07 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_07 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_07;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_07 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_07 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_07;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_07 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_07_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_08 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_08's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_08 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_08's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_08;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_08 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_08 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_08;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_08 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_08 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_08;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_08 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_08_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_09 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_09's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_09 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_09's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_09;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_09 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_09 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_09;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_09 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_09 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_09;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_09 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_09_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_10 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_10 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_10's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_10 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_10 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_10;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_10 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_10 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_10;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_10 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_10_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_11 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_11 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_11's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_11 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_11 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_11;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_11 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_11 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_11;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_11 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_11_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_12 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_12's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_12 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_12's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_12;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_12's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_12 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_12's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_12 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_12's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_12;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_12's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_12 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_12's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_12's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_12's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_12 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_12;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_12 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_12_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_13 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_13's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_13 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_13's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_13;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_13's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_13 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_13's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_13 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_13's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_13;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_13's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_13 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_13's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_13's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_13's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_13 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_13;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_13 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_13_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_14 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_14's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_14 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_14's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_14;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_14's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_14 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_14's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_14 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_14's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_14;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_14's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_14 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_14's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_14's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_14's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_14 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_14;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_14 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_14_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_15 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_15's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_15 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_15's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_15;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_15's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_15 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_15's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_15 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_15's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_15;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_15's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_15 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_15's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_15's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_15's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_15 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_15;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_15 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_15_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_16 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_16's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_16 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_16's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_16;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_16's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_16 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_16's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_16 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_16's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_16;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_16's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_16 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_16's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_16's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_16's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_16's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_16 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_16(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_16;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_16's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_16 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_16(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_16_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_17 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_17's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_17 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_17's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_17;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_17's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_17 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_17's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_17 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_17's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_17;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_17's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_17 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_17's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_17's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_17's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_17's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_17 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_17(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_17;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_17's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_17 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_17(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_17_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_18 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_18's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_18 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_18's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_18;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_18's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_18 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_18's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_18 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_18's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_18;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_18's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_18 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_18's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_18's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_18's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_18's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_18 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_18(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_18;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_18's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_18 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_18(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_18_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_19's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_19 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_19's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_19;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_19's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_19 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_19's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_19;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_19's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_19 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_19's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_19 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_19's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_19;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_19's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_19 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_19's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_19's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_19's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_19's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_19 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_19(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_19;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_19's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_19 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_19(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_19_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_19;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_20 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_20's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_20 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_20's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_20;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_20's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_20 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_20's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_20 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_20's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_20;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_20's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_20 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_20's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_20's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_20's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_20's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_20 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_20(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_20;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_20's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_20 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_20(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_20_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_21's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_21 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_21's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_21;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_21's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_21 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_21's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_21;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_21's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_21 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_21's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_21's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_21's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_21's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_21 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_21's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_21;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_21's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_21 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_21's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_21's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_21's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_21's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_21 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_21(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_21;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_21's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_21 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_21(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_21_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_21;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_22's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_22 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_22's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_22;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_22's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_22 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_22's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_22;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_22's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_22 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_22's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_22's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_22's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_22's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_22 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_22's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_22;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_22's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_22 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_22's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_22's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_22's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_22's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_22 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_22(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_22;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_22's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_22 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_22(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_22_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_22;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_23's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_23 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_23's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_23;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_23's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_23 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_23's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_23;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_23's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_23 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_23's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_23's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_23's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_23's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_23 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_23's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_23;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_23's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_23 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_23's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_23's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_23's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_23's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_23 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_23(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_23;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_23's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_23 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_23(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_23_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_23;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_24's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_24 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_24's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_24;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_24's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_24 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_24's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_24;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_24's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_24 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_24's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_24's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_24's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_24's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_24 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_24's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_24;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_24's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_24 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_24's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_24's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_24's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_24's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_24 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_24(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_24;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_24's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_24 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_24(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_24_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_24;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_25's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_25 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_25's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_25;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_25's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_25 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_25's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_25;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_25's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_25 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_25's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_25's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_25's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_25's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_25 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_25's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_25;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_25's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_25 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_25's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_25's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_25's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_25's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_25 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_25(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_25;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_25's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_25 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_25(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_25_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_25;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_26's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_26 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_26's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_26;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_26's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_26 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_26's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_26;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_26's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_26 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_26's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_26's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_26's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_26's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_26 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_26's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_26;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_26's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_26 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_26's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_26's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_26's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_26's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_26 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_26(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_26;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_26's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_26 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_26(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_26_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_26;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_27's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_27 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_27's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_27;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_27's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_27 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_27's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_27;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_27's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_27 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_27's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_27's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_27's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_27's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_27 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_27's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_27;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_27's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_27 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_27's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_27's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_27's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_27's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_27 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_27(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_27;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_27's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_27 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_27(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_27_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_27;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_28's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_28 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_28's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_28;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_28's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_28 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_28's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_28;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_28's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_28 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_28's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_28's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_28's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_28's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_28 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_28's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_28;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_28's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_28 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_28's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_28's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_28's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_28's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_28 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_28(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_28;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_28's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_28 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_28(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_28_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_28;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_29's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_29 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_29's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_29;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_29's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_29 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_29's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_29;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_29's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_29 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_29's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_29's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_29's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_29's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_29 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_29's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_29;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_29's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_29 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_29's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_29's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_29's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_29's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_29 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_29(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_29;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_29's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_29 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_29(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_29_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_29;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_30's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_30 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_30's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_30;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_30's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_30 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_30's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_30;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_30's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_30 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_30's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_30's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_30's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_30's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_30 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_30's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_30;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_30's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_30 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_30's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_30's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_30's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_30's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_30 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_30(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_30;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_30's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_30 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_30(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_30_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_30;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_31's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_31 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_31's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_31;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_31's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_31 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_31's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_31;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_31's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_31 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_31's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_31's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_31's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_31's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_31 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_31's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_31;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_31's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_31 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_31's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_31's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_31's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_31's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_31 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_31(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_31;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_31's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_31 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_31(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_31_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_31;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_32's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_32 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_32's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_32;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_32's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_32 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_32's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_32;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_32's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_32 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_32's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_32's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_32's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_32's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_32 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_32's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_32;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_32's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_32 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_32's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_32's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_32's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_32's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_32 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_32(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_32;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_32's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_32 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_32(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_32_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_32;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_33's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_33 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_33's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_33;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_33's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_33 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_33's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_33;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_33's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_33 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_33's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_33's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_33's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_33's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_33 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_33's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_33;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_33's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_33 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_33's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_33's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_33's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_33's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_33 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_33(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_33;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_33's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_33 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_33(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_33_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_33;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_34's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_34 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_34's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_34;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_34's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_34 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_34's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_34;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_34's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_34 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_34's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_34's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_34's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_34's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_34 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_34's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_34;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_34's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_34 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_34's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_34's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_34's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_34's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_34 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_34(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_34;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_34's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_34 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_34(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_34_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_34;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_35's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_35 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_35's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_35;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_35's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_35 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_35's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_35;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_35's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_35 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_35's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_35's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_35's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_35's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_35 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_35's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_35;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_35's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_35 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_35's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_35's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_35's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_35's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_35 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_35(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_35;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_35's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_35 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_35(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_35_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_35;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_36's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_36 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_36's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_36;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_36's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_36 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_36's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_36;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_36's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_36 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_36's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_36's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_36's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_36's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_36 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_36's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_36;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_36's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_36 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_36's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_36's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_36's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_36's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_36 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_36(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_36;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_36's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_36 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_36(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_36_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_36;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_36 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_37's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_37 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_37's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_37;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_37's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_37 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_37's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_37;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_37's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_37 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_37's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_37's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_37's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_37's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_37 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_37's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_37;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_37's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_37 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_37's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_37's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_37's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_37's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_37 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_37(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_37;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_37's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_37 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_37(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_37_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_37;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_37 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_38's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_38 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_38's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_38;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_38's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_38 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_38's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_38;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_38's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_38 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_38's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_38's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_38's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_38's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_38 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_38's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_38;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_38's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_38 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_38's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_38's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_38's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_38's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_38 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_38(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_38;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_38's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_38 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_38(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_38_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_38;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_38 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_39's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_39 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_39's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_39;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_39's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_39 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_39's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_39;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_39's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_39 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_39's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_39's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_39's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_39's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_39 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_39's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_39;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_39's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_39 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_39's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_39's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_39's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_39's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_39 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_39(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_39;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_39's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_39 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_39(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_39_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_39;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_39 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_40's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_40 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_40's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_40;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_40's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_40 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_40's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_40;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_40's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_40 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_40's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_40's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_40's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_40's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_40 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_40's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_40;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_40's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_40 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_40's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_40's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_40's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_40's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_40 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_40(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_40;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_40's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_40 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_40(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_40_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_40;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_40 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_41's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_41 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_41's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_41;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_41's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_41 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_41's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_41;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_41's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_41 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_41's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_41's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_41's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_41's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B1_41 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_41's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_41;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B1_41's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B1_41 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B1_41's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B1_41's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B1_41's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B1_41's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_41 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B1_41(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_41;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B1_41's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B1_41 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B1_41(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B1_41_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B1_41;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B1_41 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_00 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_00;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_00;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_00_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_01 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_01;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_01;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_01_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_02 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_02;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_02;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_02_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_03 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_03;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_03;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_03_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_04 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_04;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_04;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_04_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_05 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_05;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_05;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_05_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_06 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_06's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_06 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_06's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_06;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_06 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_06 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_06;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_06 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_06 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_06;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_06 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_06_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_07 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_07's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_07 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_07's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_07;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_07 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_07 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_07;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_07 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_07 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_07;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_07 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_07_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_08 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_08's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_08 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_08's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_08;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_08 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_08 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_08;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_08 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_08 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_08;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_08 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_08_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_09 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_09's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_09 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_09's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_09;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_09 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_09 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_09;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_09 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_09 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_09;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_09 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_09_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_10 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_10 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_10's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_10 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_10 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_10;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_10 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_10 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_10;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_10 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_10_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_11 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_11 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_11's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_11 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_11 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_11;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_11 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_11 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_11;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_11 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_11_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_12 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_12's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_12 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_12's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_12;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_12 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_12's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_12 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_12's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_12;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_12's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_12 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_12's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_12's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_12's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_12 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_12;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_12 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_12_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_13 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_13's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_13 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_13's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_13;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_13 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_13's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_13 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_13's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_13;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_13's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_13 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_13's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_13's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_13's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_13 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_13;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_13 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_13_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_14 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_14's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_14 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_14's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_14;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_14 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_14's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_14 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_14's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_14;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_14's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_14 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_14's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_14's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_14's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_14 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_14;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_14 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_14_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_15 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_15's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_15 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_15's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_15;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_15 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_15's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_15 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_15's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_15;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_15's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_15 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_15's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_15's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_15's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_15 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_15;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_15 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_15_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_16 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_16's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_16 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_16's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_16;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_16's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_16 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_16's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_16 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_16's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_16;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_16's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_16 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_16's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_16's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_16's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_16's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_16 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_16(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_16;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_16's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_16 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_16(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_16_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_17 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_17's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_17 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_17's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_17;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_17's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_17 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_17's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_17 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_17's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_17;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_17's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_17 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_17's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_17's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_17's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_17's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_17 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_17(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_17;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_17's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_17 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_17(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_17_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_18 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_18's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_18 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_18's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_18;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_18's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_18 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_18's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_18 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_18's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_18;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_18's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_18 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_18's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_18's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_18's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_18's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_18 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_18(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_18;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_18's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_18 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_18(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_18_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_19's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_19 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_19's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_19;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_19's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_19 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_19's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_19;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_19's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_19 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_19's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_19 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_19's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_19;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_19's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_19 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_19's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_19's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_19's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_19's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_19 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_19(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_19;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_19's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_19 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_19(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_19_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_19;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_20 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_20's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_20 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_20's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_20;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_20's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_20 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_20's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL
    get_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL(
            (SW_PAD_CTL_PAD_GPIO_EMC_B2_20 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_20's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_20;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_EMC_B2_20's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_EMC_B2_20 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_EMC_B2_20's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_EMC_B2_20's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_EMC_B2_20's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_EMC_B2_20's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_20 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_EMC_B2_20(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_20;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_EMC_B2_20's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_EMC_B2_20 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_EMC_B2_20(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_B2_20_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_EMC_B2_20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_EMC_B2_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_00_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_00 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_00_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_00_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_00_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_00 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_00_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_00_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_00_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_00_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_00_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_00_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_00 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_00_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_00_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_00 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_00;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_01_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_01 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_01_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_01_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_01_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_01 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_01_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_01_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_01_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_01_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_01_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_01_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_01 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_01_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_01_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_01 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_01;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_02_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_02 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_02_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_02_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_02_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_02 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_02_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_02_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_02_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_02_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_02_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_02_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_02 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_02_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_02_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_02 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_02;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_03_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_03 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_03_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_03_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_03_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_03 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_03_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_03_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_03_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_03_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_03_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_03_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_03 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_03_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_03_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_03 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_03;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_04_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_04 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_04_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_04_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_04_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_04 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_04_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_04_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_04_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_04_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_04_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_04_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_04 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_04_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_04_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_04 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_04;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_05_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_05 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_05_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_05_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_05_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_05 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_05_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_05_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_05_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_05_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_05_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_05_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_05 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_05_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_05_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_05 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_05;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_06 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_06_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_06 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_06;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_06_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_06 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_06_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_06 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_06_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_06_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_06_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_06 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_06_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_06_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_06_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_06 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_06_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_06_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_06_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_06 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_06_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_06_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_06 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_06 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_06;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_06 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_07 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_07_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_07 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_07;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_07_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_07 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_07_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_07 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_07_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_07_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_07_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_07 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_07_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_07_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_07_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_07 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_07_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_07_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_07_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_07 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_07_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_07_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_07 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_07 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_07;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_07 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_08 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_08_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_08 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_08;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_08_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_08 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_08_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_08 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_08_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_08_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_08_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_08 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_08_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_08_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_08_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_08 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_08_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_08_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_08_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_08 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_08_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_08_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_08 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_08 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_08;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_08 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_09 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_09_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_09 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_09;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_09_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_09 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_09_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_09 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_09_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_09_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_09_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_09 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_09_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_09_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_09_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_09 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_09_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_09_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_09_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_09 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_09_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_09_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_09 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_09 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_09;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_09 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_10 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_10_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_10 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_10_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_10 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_10_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_10 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_10_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_10_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_10_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_10 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_10_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_10_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_10_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_10 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_10_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_10_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_10_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_10 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_10_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_10_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_10 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_10 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_10;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_10 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_11 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_11_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_11 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_11_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_11 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_11_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_11 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_11_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_11_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_11_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_11 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_11_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_11_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_11_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_11 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_11_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_11_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_11_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_11 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_11_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_11_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_11 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_11 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_11;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_11 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_12 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_12_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_12 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_12;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_12_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_12 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_12_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_12 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_12_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_12_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_12_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_12 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_12_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_12_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_12_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_12 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_12_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_12_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_12_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_12 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_12_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_12_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_12 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_12 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_12;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_12 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_13 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_13_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_13 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_13;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_13_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_13 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_13_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_13 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_13_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_13_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_13_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_13 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_13_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_13_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_13_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_13 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_13_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_13_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_13_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_13 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_13_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_13_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_13 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_13 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_13;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_13 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_14 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_14_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_14 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_14;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_14_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_14 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_14_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_14 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_14_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_14_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_14_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_14 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_14_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_14_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_14_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_14 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_14_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_14_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_14_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_14 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_14_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_14_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_14 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_14 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_14;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_14 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_15 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_15_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_15 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_15;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_15_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_15 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_15_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_15 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_15_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_15_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_15_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_15 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_15_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_15_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_15_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_15 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_15_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_15_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_15_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_15 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_15_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_15_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_15 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_15 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_15;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_15 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_15_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_16 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_16_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_16 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_16;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_16_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_16 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_16's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_16_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_16_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_16 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_16's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_16_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_16's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_16_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_16_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_16 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_16's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_16_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_16's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_16_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_16_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_16 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_16's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_16_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_16's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_16_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_16's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_16_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_16 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_16's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_16's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_16_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_16's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_16_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_16 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_16's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_16 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_16(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_16;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_16's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_16 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_16(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_16_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_16;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_16 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_17 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_17_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_17 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_17;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_17_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_17 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_17's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_17_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_17_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_17 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_17's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_17_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_17's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_17_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_17_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_17 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_17's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_17_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_17's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_17_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_17_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_17 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_17's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_17_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_17's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_17_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_17's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_17_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_17 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_17's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_17's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_17_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_17's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_17_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_17 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_17's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_17 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_17(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_17;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_17's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_17 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_17(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_17_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_17;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_17 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_18 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_18_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_18 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_18;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_18_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_18 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_18's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_18_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_18_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_18 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_18's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_18_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_18's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_18_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_18_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_18 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_18's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_18_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_18's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_18_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_18_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_18 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_18's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_18_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_18's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_18_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_18's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_18_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_18 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_18's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_18's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_18_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_18's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_18_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_18 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_18's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_18 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_18(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_18;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_18's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_18 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_18(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_18_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_18;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_18 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_19 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_19;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_19_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_19 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_19;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_19_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_19 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_19's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_19_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_19_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_19 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_19's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_19_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_19's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_19_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_19_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_19 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_19's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_19_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_19's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_19_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_19_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_19 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_19's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_19_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_19's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_19_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_19's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_19_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_19 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_19's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_19's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_19_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_19's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_19_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_19 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_19's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_19 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_19(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_19;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_19's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_19 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_19(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_19_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_19;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_19 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_20 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_20_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_20 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_20;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_20_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_20 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_20's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_20_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_20_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_20 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_20's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_20_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_20's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_20_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_20_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_20 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_20's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_20_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_20's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_20_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_20_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_20 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_20's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_20_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_20's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_20_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_20's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_20_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_20 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_20's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_20's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_20_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_20's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_20_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_20 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_20's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_20 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_20(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_20;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_20's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_20 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_20(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_20_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_20;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_20 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_21 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_21;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_21_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_21 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_21;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_21_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_21 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_21's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_21_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_21's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_21_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_21_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_21 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_21's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_21_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_21's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_21_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_21_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_21 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_21's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_21_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_21's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_21_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_21_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_21 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_21's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_21_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_21's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_21_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_21's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_21_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_21 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_21's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_21's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_21_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_21's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_21_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_21 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_21's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_21 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_21(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_21;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_21's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_21 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_21(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_21_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_21;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_21 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_22 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_22;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_22_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_22 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_22;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_22_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_22 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_22's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_22_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_22's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_22_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_22_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_22 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_22's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_22_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_22's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_22_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_22_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_22 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_22's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_22_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_22's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_22_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_22_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_22 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_22's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_22_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_22's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_22_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_22's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_22_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_22 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_22's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_22's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_22_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_22's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_22_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_22 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_22's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_22 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_22(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_22;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_22's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_22 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_22(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_22_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_22;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_22 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_23 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_23;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_23_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_23 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_23;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_23_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_23 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_23's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_23_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_23's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_23_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_23_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_23 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_23's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_23_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_23's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_23_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_23_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_23 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_23's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_23_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_23's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_23_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_23_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_23 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_23's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_23_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_23's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_23_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_23's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_23_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_23 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_23's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_23's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_23_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_23's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_23_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_23 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_23's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_23 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_23(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_23;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_23's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_23 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_23(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_23_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_23;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_23 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_24 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_24;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_24_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_24 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_24;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_24_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_24 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_24's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_24_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_24's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_24_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_24_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_24 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_24's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_24_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_24's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_24_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_24_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_24 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_24's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_24_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_24's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_24_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_24_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_24 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_24's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_24_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_24's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_24_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_24's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_24_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_24 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_24's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_24's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_24_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_24's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_24_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_24 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_24's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_24 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_24(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_24;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_24's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_24 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_24(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_24_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_24;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_24 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_25 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_25;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_25_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_25 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_25;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_25_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_25 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_25's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_25_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_25's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_25_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_25_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_25 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_25's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_25_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_25's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_25_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_25_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_25 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_25's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_25_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_25's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_25_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_25_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_25 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_25's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_25_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_25's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_25_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_25's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_25_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_25 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_25's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_25's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_25_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_25's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_25_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_25 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_25's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_25 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_25(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_25;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_25's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_25 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_25(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_25_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_25;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_25 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_26 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_26;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_26_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_26 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_26;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_26_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_26 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_26's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_26_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_26's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_26_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_26_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_26 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_26's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_26_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_26's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_26_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_26_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_26 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_26's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_26_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_26's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_26_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_26_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_26 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_26's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_26_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_26's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_26_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_26's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_26_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_26 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_26's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_26's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_26_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_26's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_26_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_26 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_26's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_26 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_26(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_26;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_26's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_26 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_26(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_26_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_26;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_26 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_27 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_27;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_27_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_27 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_27;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_27_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_27 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_27's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_27_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_27's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_27_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_27_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_27 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_27's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_27_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_27's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_27_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_27_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_27 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_27's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_27_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_27's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_27_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_27_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_27 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_27's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_27_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_27's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_27_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_27's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_27_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_27 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_27's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_27's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_27_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_27's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_27_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_27 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_27's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_27 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_27(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_27;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_27's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_27 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_27(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_27_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_27;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_27 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_28 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_28;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_28_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_28 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_28;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_28_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_28 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_28's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_28_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_28's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_28_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_28_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_28 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_28's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_28_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_28's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_28_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_28_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_28 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_28's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_28_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_28's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_28_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_28_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_28 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_28's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_28_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_28's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_28_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_28's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_28_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_28 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_28's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_28's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_28_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_28's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_28_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_28 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_28's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_28 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_28(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_28;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_28's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_28 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_28(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_28_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_28;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_28 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_29 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_29;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_29_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_29 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_29;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_29_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_29 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_29's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_29_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_29's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_29_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_29_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_29 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_29's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_29_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_29's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_29_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_29_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_29 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_29's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_29_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_29's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_29_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_29_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_29 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_29's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_29_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_29's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_29_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_29's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_29_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_29 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_29's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_29's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_29_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_29's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_29_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_29 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_29's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_29 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_29(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_29;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_29's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_29 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_29(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_29_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_29;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_29 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_30 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_30;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_30_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_30 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_30;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_30_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_30 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_30's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_30_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_30's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_30_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_30_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_30 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_30's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_30_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_30's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_30_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_30_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_30 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_30's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_30_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_30's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_30_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_30_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_30 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_30's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_30_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_30's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_30_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_30's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_30_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_30 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_30's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_30's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_30_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_30's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_30_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_30 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_30's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_30 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_30(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_30;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_30's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_30 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_30(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_30_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_30;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_30 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_31 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_31;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_31_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_31 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_31;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_31_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_31 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_31's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_31_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_31's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_31_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_31_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_31 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_31's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_31_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_31's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_31_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_31_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_31 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_31's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_31_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_31's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_31_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_31_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_31 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_31's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_31_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_31's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_31_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_31's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_31_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_31 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_31's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_31's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_31_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_31's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_31_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_31 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_31's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_31 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_31(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_31;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_31's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_31 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_31(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_31_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_31;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_31 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_32 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_32;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_32_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_32 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_32;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_32_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_32 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_32's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_32_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_32's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_32_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_32_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_32 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_32's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_32_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_32's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_32_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_32_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_32 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_32's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_32_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_32's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_32_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_32_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_32 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_32's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_32_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_32's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_32_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_32's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_32_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_32 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_32's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_32's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_32_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_32's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_32_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_32 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_32's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_32 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_32(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_32;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_32's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_32 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_32(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_32_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_32;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_32 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_33 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_33;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_33_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_33 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_33;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_33_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_33 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_33's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_33_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_33's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_33_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_33_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_33 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_33's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_33_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_33's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_33_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_33_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_33 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_33's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_33_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_33's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_33_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_33_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_33 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_33's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_33_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_33's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_33_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_33's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_33_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_33 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_33's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_33's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_33_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_33's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_33_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_33 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_33's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_33 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_33(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_33;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_33's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_33 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_33(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_33_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_33;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_33 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_34 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_34;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_34_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_34 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_34;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_34_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_34 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_34's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_34_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_34's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_34_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_34_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_34 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_34's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_34_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_34's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_34_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_34_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_34 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_34's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_34_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_34's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_34_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_34_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_34 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_34's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_34_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_34's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_34_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_34's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_34_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_34 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_34's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_34's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_34_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_34's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_34_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_34 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_34's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_34 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_34(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_34;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_34's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_34 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_34(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_34_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_34;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_34 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_AD_35 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_35;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_AD_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP
    get_SW_PAD_CTL_PAD_GPIO_AD_35_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP(
            (SW_PAD_CTL_PAD_GPIO_AD_35 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_35;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_AD_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_35_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_35 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_35's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_35_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_35's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_35_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_35_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_35 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_35's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_35_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_35's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_35_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_35_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_35 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_35's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_35_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_35's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_35_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_35_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_35 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_35's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_35_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_35's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_35_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_AD_35's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_AD_35_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_AD_35 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_AD_35's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_AD_35's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_AD_35_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_AD_35's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_AD_35_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_AD_35 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_AD_35's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_35 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_AD_35(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_35;

        DWP_LOCK =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK((curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_AD_35's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_AD_35 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_AD_35(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_35_DWP DWP, bool ODE, bool PUS, bool PUE,
        bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_AD_35;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_AD_35 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_00 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_00;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_00 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B1_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B1_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_00;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B1_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_01 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_01;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_01 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B1_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B1_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_01;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B1_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_02 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_02;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_02 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B1_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B1_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_02;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B1_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_03 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_03;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_03 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B1_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B1_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_03;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B1_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_04 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_04;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_04 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B1_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B1_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_04;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B1_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B1_05 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_05;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B1_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B1_05 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B1_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B1_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_05;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B1_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B1_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B1_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_00 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_00;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_00 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_00;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_00_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_01 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_01;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_01 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_01;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_01_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_02 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_02;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_02 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_02;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_02_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_03 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_03;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_03 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_03;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_03_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_04 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_04;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_04 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_04;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_04_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_05 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_05;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_05 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_05;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_05_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_06 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_06's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_06 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_06's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_06;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_06_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_06 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_06 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_06 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_06 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_06;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_06 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_06 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_06 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_06 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_06 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_06;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_06 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_06_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_07 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_07's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_07 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_07's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_07;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_07_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_07 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_07 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_07 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_07 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_07;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_07 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_07 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_07 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_07 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_07 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_07;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_07 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_07_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_08 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_08's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_08 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_08's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_08;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_08_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_08 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_08 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_08 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_08 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_08;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_08 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_08 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_08 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_08 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_08 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_08;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_08 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_08_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_09 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_09's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_09 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_09's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_09;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_09_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_09 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_09 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_09 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_09 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_09;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_09 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_09 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_09 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_09 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_09 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_09;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_09 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_09_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_10 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_10 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_10's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_10_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_10 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_10 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_10 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_10 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_10;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_10 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_10 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_10 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_10 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_10 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_10;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_10 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_10_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_11 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_11 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_11's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_11_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_11 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_11 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_11 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL
    get_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL(
            (SW_PAD_CTL_PAD_GPIO_SD_B2_11 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_11;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_SD_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_SD_B2_11 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_SD_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_11 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_SD_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_11 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_SD_B2_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_SD_B2_11 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_SD_B2_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_11 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_SD_B2_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_11;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK((curr >> 30u) &
                                                                0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL = IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_SD_B2_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_SD_B2_11 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_SD_B2_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B2_11_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_SD_B2_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_SD_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_00 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_00's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_00;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_00's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_00;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_00_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_01 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_01's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_01;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_01's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_01;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_01_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_02 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_02's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_02;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_02's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_02;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_02_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_03 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_03's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_03;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_03's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_03;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_03_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_04 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_04's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_04;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_04's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_04;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_04_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_05 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_05's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_05;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_05's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_05;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_05_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_06 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_06's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_06 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_06's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_06;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_06 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_06 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_06's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_06;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_06 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_06's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_06 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_06;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_06 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_06_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_07 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_07's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_07 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_07's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_07;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_07 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_07 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_07's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_07;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_07 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_07's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_07 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_07;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_07 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_07_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_08 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_08's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_08 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_08's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_08;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_08 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_08 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_08's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_08;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_08 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_08's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_08 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_08;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_08 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_08_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_09 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_09's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_09 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_09's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_09;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_09 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_09 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_09's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_09;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_09 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_09's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_09 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_09;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_09 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_09_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_10 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_10 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_10's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_10 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_10 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_10's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_10;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_10 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_10's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_10 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_10;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_10 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_10_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_11 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_11 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_11's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_11 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL
    get_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL(
            (SW_PAD_CTL_PAD_GPIO_DISP_B1_11 >> 2u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_11's PULL field.
     *
     * Pull Down Pull Up Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_11;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PDRV() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B1_11 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B1_11's PDRV bit.
     *
     * PDRV Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PDRV() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 ^= 1u << 1u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B1_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_11 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B1_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP &DWP, bool &ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL &PULL, bool &PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_11;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PULL =
            IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL((curr >> 2u) & 0b11u);
        PDRV = curr & (1u << 1u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B1_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B1_11 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B1_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_DWP DWP, bool ODE,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B1_11_PULL PULL, bool PDRV) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B1_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(PULL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (PDRV & 0b1u) << 1u;

        SW_PAD_CTL_PAD_GPIO_DISP_B1_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_00 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_00 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_00;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_00 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_00's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_00 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_00 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_00's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_00 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_00's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_00 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_00's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_00 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_00;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_00's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_00 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_00(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_00_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_00;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_00 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_01 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_01 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_01;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_01 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_01's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_01 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_01 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_01's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_01 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_01's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_01 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_01's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_01 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_01;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_01's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_01 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_01(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_01_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_01;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_01 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_02 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_02 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_02;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_02 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_02's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_02 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_02 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_02's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_02 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_02's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_02 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_02's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_02 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_02;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_02's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_02 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_02(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_02_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_02;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_02 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_03 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_03 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_03;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_03 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_03's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_03 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_03 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_03's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_03 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_03's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_03 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_03's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_03 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_03;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_03's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_03 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_03(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_03_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_03;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_03 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_04 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_04 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_04;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_04 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_04's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_04 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_04 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_04's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_04 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_04's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_04 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_04's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_04 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_04;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_04's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_04 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_04(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_04_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_04;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_04 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_05 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_05 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_05;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_05 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_05's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_05 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_05 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_05's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_05 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_05's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_05 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_05's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_05 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_05;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_05's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_05 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_05(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_05_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_05;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_05 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_06 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_06 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_06;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_06 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_06's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_06 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_06 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_06's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_06 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_06's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_06 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_06's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_06 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_06;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_06's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_06 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_06(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_06_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_06;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_06 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_07 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_07 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_07;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_07 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_07's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_07 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_07 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_07's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_07 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_07's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_07 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_07's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_07 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_07;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_07's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_07 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_07(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_07_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_07;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_07 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_08 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_08 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_08;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_08 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_08's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_08 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_08 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_08's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_08 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_08's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_08 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_08's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_08 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_08;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_08's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_08 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_08(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_08_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_08;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_08 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_09 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_09 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_09;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_09 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_09's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_09 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_09 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_09's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_09 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_09's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_09 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_09's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_09 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_09;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_09's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_09 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_09(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_09_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_09;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_09 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_10 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_10 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_10;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_10 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_10's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_10 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_10 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_10's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_10 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_10's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_10 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_10's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_10 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_10;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_10's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_10 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_10(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_10_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_10;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_10 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_11 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_11 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_11;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_11 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_11's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_11 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_11 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_11's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_11 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_11's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_11 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_11's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_11 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_11;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_11's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_11 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_11(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_11_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_11;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_11 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_12 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_12 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_12;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_12 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_12's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_12 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_12 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_12's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_12 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_12's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_12 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_12's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_12 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_12;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_12's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_12 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_12(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_12_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_12;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_12 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_13 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_13 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_13;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_13 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_13's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_13 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_13 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_13's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_13 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_13's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_13 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_13's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_13 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_13;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_13's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_13 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_13(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_13_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_13;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_13 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_14 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_14 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_14;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_14 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_14's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_14 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_14 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_14's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_14 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_14's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_14 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_14's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_14 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_14;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_14's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_14 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_14(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_14_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_14;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_14 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_15 >> 30u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DWP_LOCK field.
     *
     * Domain write protection lock
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(value) & 0b11u) << 30u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DWP field.
     *
     * Domain write protection
     */
    inline IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP
    get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP() volatile
    {
        return IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP(
            (SW_PAD_CTL_PAD_GPIO_DISP_B2_15 >> 28u) & 0b11u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DWP field.
     *
     * Domain write protection
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP value) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_15;

        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(value) & 0b11u) << 28u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 = curr;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_ODE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_15 & (1u << 4u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 |= 1u << 4u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 &= ~(1u << 4u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_15's ODE bit.
     *
     * Open Drain Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_ODE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 ^= 1u << 4u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUS() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_15 & (1u << 3u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 |= 1u << 3u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 &= ~(1u << 3u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUS bit.
     *
     * Pull Up / Down Config. Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUS() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 ^= 1u << 3u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_15 & (1u << 2u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 |= 1u << 2u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 &= ~(1u << 2u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_15's PUE bit.
     *
     * Pull / Keep Select Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_PUE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 ^= 1u << 2u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DSE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_15 & (1u << 1u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 |= 1u << 1u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 &= ~(1u << 1u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_15's DSE bit.
     *
     * Drive Strength Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DSE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 ^= 1u << 1u;
    }

    /**
     * Get SW_PAD_CTL_PAD_GPIO_DISP_B2_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline bool get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_SRE() volatile
    {
        return SW_PAD_CTL_PAD_GPIO_DISP_B2_15 & (1u << 0u);
    }

    /**
     * Set SW_PAD_CTL_PAD_GPIO_DISP_B2_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 |= 1u << 0u;
    }

    /**
     * Clear SW_PAD_CTL_PAD_GPIO_DISP_B2_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline void clear_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 &= ~(1u << 0u);
    }

    /**
     * Toggle SW_PAD_CTL_PAD_GPIO_DISP_B2_15's SRE bit.
     *
     * Slew Rate Field
     */
    inline void toggle_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_SRE() volatile
    {
        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 ^= 1u << 0u;
    }

    /**
     * Get all of SW_PAD_CTL_PAD_GPIO_DISP_B2_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_15 SW PAD Control Register
     */
    inline void get_SW_PAD_CTL_PAD_GPIO_DISP_B2_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK &DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP &DWP, bool &ODE, bool &PUS,
        bool &PUE, bool &DSE, bool &SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_15;

        DWP_LOCK = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK(
            (curr >> 30u) & 0b11u);
        DWP = IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP((curr >> 28u) & 0b11u);
        ODE = curr & (1u << 4u);
        PUS = curr & (1u << 3u);
        PUE = curr & (1u << 2u);
        DSE = curr & (1u << 1u);
        SRE = curr & (1u << 0u);
    }

    /**
     * Set all of SW_PAD_CTL_PAD_GPIO_DISP_B2_15's bit fields.
     *
     * (read-write) SW_PAD_CTL_PAD_GPIO_DISP_B2_15 SW PAD Control Register
     */
    inline void set_SW_PAD_CTL_PAD_GPIO_DISP_B2_15(
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP_LOCK DWP_LOCK,
        IOMUXC_SW_PAD_CTL_PAD_GPIO_DISP_B2_15_DWP DWP, bool ODE, bool PUS,
        bool PUE, bool DSE, bool SRE) volatile
    {
        uint32_t curr = SW_PAD_CTL_PAD_GPIO_DISP_B2_15;

        curr &= ~(0b11u << 30u);
        curr |= (std::to_underlying(DWP_LOCK) & 0b11u) << 30u;
        curr &= ~(0b11u << 28u);
        curr |= (std::to_underlying(DWP) & 0b11u) << 28u;
        curr &= ~(0b1u << 4u);
        curr |= (ODE & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (PUS & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (PUE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DSE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (SRE & 0b1u) << 0u;

        SW_PAD_CTL_PAD_GPIO_DISP_B2_15 = curr;
    }

    /**
     * Get FLEXCAN1_RX_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY
    get_FLEXCAN1_RX_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY(
            (FLEXCAN1_RX_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set FLEXCAN1_RX_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXCAN1_RX_SELECT_INPUT_DAISY(
        IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = FLEXCAN1_RX_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        FLEXCAN1_RX_SELECT_INPUT = curr;
    }

    /**
     * Get FLEXCAN2_RX_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXCAN2_RX_SELECT_INPUT_DAISY() volatile
    {
        return FLEXCAN2_RX_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set FLEXCAN2_RX_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXCAN2_RX_SELECT_INPUT_DAISY() volatile
    {
        FLEXCAN2_RX_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear FLEXCAN2_RX_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXCAN2_RX_SELECT_INPUT_DAISY() volatile
    {
        FLEXCAN2_RX_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXCAN2_RX_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXCAN2_RX_SELECT_INPUT_DAISY() volatile
    {
        FLEXCAN2_RX_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get CCM_ENET_QOS_REF_CLK_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_CCM_ENET_QOS_REF_CLK_SELECT_INPUT_DAISY
    get_CCM_ENET_QOS_REF_CLK_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_CCM_ENET_QOS_REF_CLK_SELECT_INPUT_DAISY(
            (CCM_ENET_QOS_REF_CLK_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set CCM_ENET_QOS_REF_CLK_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_CCM_ENET_QOS_REF_CLK_SELECT_INPUT_DAISY(
        IOMUXC_CCM_ENET_QOS_REF_CLK_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = CCM_ENET_QOS_REF_CLK_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CCM_ENET_QOS_REF_CLK_SELECT_INPUT = curr;
    }

    /**
     * Get CCM_ENET_QOS_TX_CLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_CCM_ENET_QOS_TX_CLK_SELECT_INPUT_DAISY() volatile
    {
        return CCM_ENET_QOS_TX_CLK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set CCM_ENET_QOS_TX_CLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_CCM_ENET_QOS_TX_CLK_SELECT_INPUT_DAISY() volatile
    {
        CCM_ENET_QOS_TX_CLK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear CCM_ENET_QOS_TX_CLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_CCM_ENET_QOS_TX_CLK_SELECT_INPUT_DAISY() volatile
    {
        CCM_ENET_QOS_TX_CLK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle CCM_ENET_QOS_TX_CLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_CCM_ENET_QOS_TX_CLK_SELECT_INPUT_DAISY() volatile
    {
        CCM_ENET_QOS_TX_CLK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_IPG_CLK_RMII_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY
    get_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY(
            (ENET_IPG_CLK_RMII_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_IPG_CLK_RMII_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY(
        IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_IPG_CLK_RMII_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_IPG_CLK_RMII_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_MAC0_MDIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_MAC0_MDIO_SELECT_INPUT_DAISY() volatile
    {
        return ENET_MAC0_MDIO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_MAC0_MDIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_MAC0_MDIO_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_MDIO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_MAC0_MDIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_MAC0_MDIO_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_MDIO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_MAC0_MDIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_MAC0_MDIO_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_MDIO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_MAC0_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_MAC0_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        return ENET_MAC0_RXDATA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set ENET_MAC0_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_MAC0_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        ENET_MAC0_RXDATA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear ENET_MAC0_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_MAC0_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        ENET_MAC0_RXDATA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_MAC0_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_MAC0_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        ENET_MAC0_RXDATA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get ENET_MAC0_RXDATA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_MAC0_RXDATA_SELECT_INPUT_1_DAISY() volatile
    {
        return ENET_MAC0_RXDATA_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set ENET_MAC0_RXDATA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_MAC0_RXDATA_SELECT_INPUT_1_DAISY() volatile
    {
        ENET_MAC0_RXDATA_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear ENET_MAC0_RXDATA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_MAC0_RXDATA_SELECT_INPUT_1_DAISY() volatile
    {
        ENET_MAC0_RXDATA_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_MAC0_RXDATA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_MAC0_RXDATA_SELECT_INPUT_1_DAISY() volatile
    {
        ENET_MAC0_RXDATA_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get ENET_MAC0_RXEN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_MAC0_RXEN_SELECT_INPUT_DAISY() volatile
    {
        return ENET_MAC0_RXEN_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_MAC0_RXEN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_MAC0_RXEN_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_RXEN_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_MAC0_RXEN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_MAC0_RXEN_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_RXEN_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_MAC0_RXEN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_MAC0_RXEN_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_RXEN_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        return ENET_MAC0_RXERR_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_RXERR_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_RXERR_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_RXERR_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_MAC0_TXCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_MAC0_TXCLK_SELECT_INPUT_DAISY() volatile
    {
        return ENET_MAC0_TXCLK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_MAC0_TXCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_MAC0_TXCLK_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_TXCLK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_MAC0_TXCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_MAC0_TXCLK_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_TXCLK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_MAC0_TXCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_MAC0_TXCLK_SELECT_INPUT_DAISY() volatile
    {
        ENET_MAC0_TXCLK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_1G_IPG_CLK_RMII_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_IPG_CLK_RMII_SELECT_INPUT_DAISY
    get_ENET_1G_IPG_CLK_RMII_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_IPG_CLK_RMII_SELECT_INPUT_DAISY(
            (ENET_1G_IPG_CLK_RMII_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_IPG_CLK_RMII_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_IPG_CLK_RMII_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_IPG_CLK_RMII_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_IPG_CLK_RMII_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_IPG_CLK_RMII_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_MDIO_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_MDIO_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_MDIO_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_MDIO_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_MDIO_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_MDIO_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_MDIO_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_MDIO_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_MDIO_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_MDIO_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXCLK_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_RXCLK_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_RXCLK_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_RXCLK_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_RXCLK_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_RXCLK_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXCLK_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_RXCLK_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_RXCLK_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_RXCLK_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXDATA_0_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_RXDATA_0_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_RXDATA_0_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_RXDATA_0_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_RXDATA_0_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_RXDATA_0_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXDATA_0_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_RXDATA_0_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_RXDATA_0_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_RXDATA_0_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXDATA_1_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_RXDATA_1_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_RXDATA_1_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_RXDATA_1_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_RXDATA_1_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_RXDATA_1_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXDATA_1_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_RXDATA_1_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_RXDATA_1_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_RXDATA_1_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXDATA_2_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_RXDATA_2_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_RXDATA_2_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_RXDATA_2_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_RXDATA_2_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_RXDATA_2_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXDATA_2_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_RXDATA_2_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_RXDATA_2_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_RXDATA_2_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXDATA_3_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_RXDATA_3_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_RXDATA_3_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_RXDATA_3_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_RXDATA_3_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_RXDATA_3_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXDATA_3_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_RXDATA_3_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_RXDATA_3_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_RXDATA_3_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXEN_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_RXEN_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_RXEN_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_RXEN_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_RXEN_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_RXEN_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXEN_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_RXEN_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_RXEN_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_RXEN_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_1G_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_1G_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        return ENET_1G_MAC0_RXERR_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_1G_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        ENET_1G_MAC0_RXERR_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_1G_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_1G_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        ENET_1G_MAC0_RXERR_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_1G_MAC0_RXERR_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_1G_MAC0_RXERR_SELECT_INPUT_DAISY() volatile
    {
        ENET_1G_MAC0_RXERR_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_1G_MAC0_TXCLK_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_1G_MAC0_TXCLK_SELECT_INPUT_DAISY
    get_ENET_1G_MAC0_TXCLK_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_1G_MAC0_TXCLK_SELECT_INPUT_DAISY(
            (ENET_1G_MAC0_TXCLK_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_1G_MAC0_TXCLK_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_1G_MAC0_TXCLK_SELECT_INPUT_DAISY(
        IOMUXC_ENET_1G_MAC0_TXCLK_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_1G_MAC0_TXCLK_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_1G_MAC0_TXCLK_SELECT_INPUT = curr;
    }

    /**
     * Get ENET_QOS_GMII_MDI_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_QOS_GMII_MDI_I_SELECT_INPUT_DAISY() volatile
    {
        return ENET_QOS_GMII_MDI_I_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_QOS_GMII_MDI_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_QOS_GMII_MDI_I_SELECT_INPUT_DAISY() volatile
    {
        ENET_QOS_GMII_MDI_I_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_QOS_GMII_MDI_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_QOS_GMII_MDI_I_SELECT_INPUT_DAISY() volatile
    {
        ENET_QOS_GMII_MDI_I_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_QOS_GMII_MDI_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_QOS_GMII_MDI_I_SELECT_INPUT_DAISY() volatile
    {
        ENET_QOS_GMII_MDI_I_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_QOS_PHY_RXD_I_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_QOS_PHY_RXD_I_SELECT_INPUT_0_DAISY() volatile
    {
        return ENET_QOS_PHY_RXD_I_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set ENET_QOS_PHY_RXD_I_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_QOS_PHY_RXD_I_SELECT_INPUT_0_DAISY() volatile
    {
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear ENET_QOS_PHY_RXD_I_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_QOS_PHY_RXD_I_SELECT_INPUT_0_DAISY() volatile
    {
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_QOS_PHY_RXD_I_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_QOS_PHY_RXD_I_SELECT_INPUT_0_DAISY() volatile
    {
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get ENET_QOS_PHY_RXD_I_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_QOS_PHY_RXD_I_SELECT_INPUT_1_DAISY() volatile
    {
        return ENET_QOS_PHY_RXD_I_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set ENET_QOS_PHY_RXD_I_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_QOS_PHY_RXD_I_SELECT_INPUT_1_DAISY() volatile
    {
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear ENET_QOS_PHY_RXD_I_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_QOS_PHY_RXD_I_SELECT_INPUT_1_DAISY() volatile
    {
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_QOS_PHY_RXD_I_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_QOS_PHY_RXD_I_SELECT_INPUT_1_DAISY() volatile
    {
        ENET_QOS_PHY_RXD_I_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get ENET_QOS_PHY_RXDV_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_ENET_QOS_PHY_RXDV_I_SELECT_INPUT_DAISY() volatile
    {
        return ENET_QOS_PHY_RXDV_I_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set ENET_QOS_PHY_RXDV_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_QOS_PHY_RXDV_I_SELECT_INPUT_DAISY() volatile
    {
        ENET_QOS_PHY_RXDV_I_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear ENET_QOS_PHY_RXDV_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_ENET_QOS_PHY_RXDV_I_SELECT_INPUT_DAISY() volatile
    {
        ENET_QOS_PHY_RXDV_I_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle ENET_QOS_PHY_RXDV_I_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_ENET_QOS_PHY_RXDV_I_SELECT_INPUT_DAISY() volatile
    {
        ENET_QOS_PHY_RXDV_I_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get ENET_QOS_PHY_RXER_I_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_ENET_QOS_PHY_RXER_I_SELECT_INPUT_DAISY
    get_ENET_QOS_PHY_RXER_I_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_ENET_QOS_PHY_RXER_I_SELECT_INPUT_DAISY(
            (ENET_QOS_PHY_RXER_I_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set ENET_QOS_PHY_RXER_I_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_ENET_QOS_PHY_RXER_I_SELECT_INPUT_DAISY(
        IOMUXC_ENET_QOS_PHY_RXER_I_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = ENET_QOS_PHY_RXER_I_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        ENET_QOS_PHY_RXER_I_SELECT_INPUT = curr;
    }

    /**
     * Get FLEXPWM1_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXPWM1_PWMA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXPWM1_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM1_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM1_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM1_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXPWM1_PWMA_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXPWM1_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM1_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM1_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM1_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXPWM1_PWMA_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXPWM1_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM1_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM1_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM1_PWMA_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM1_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXPWM1_PWMB_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXPWM1_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM1_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM1_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM1_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXPWM1_PWMB_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXPWM1_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM1_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM1_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM1_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXPWM1_PWMB_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXPWM1_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM1_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM1_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM1_PWMB_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM2_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM2_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXPWM2_PWMA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXPWM2_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM2_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM2_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM2_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM2_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM2_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM2_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM2_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXPWM2_PWMA_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXPWM2_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM2_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM2_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM2_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM2_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM2_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM2_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM2_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXPWM2_PWMA_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXPWM2_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM2_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM2_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM2_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM2_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM2_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM2_PWMA_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM2_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM2_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXPWM2_PWMB_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXPWM2_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM2_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM2_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM2_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM2_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM2_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM2_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM2_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXPWM2_PWMB_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXPWM2_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM2_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM2_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM2_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM2_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM2_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM2_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM2_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXPWM2_PWMB_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXPWM2_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM2_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM2_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM2_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM2_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM2_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM2_PWMB_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXPWM3_PWMA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXPWM3_PWMA_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXPWM3_PWMA_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMA_SELECT_INPUT_3_DAISY() volatile
    {
        return FLEXPWM3_PWMA_SELECT_INPUT_3 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_3 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_3 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXPWM3_PWMA_SELECT_INPUT_3 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXPWM3_PWMB_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXPWM3_PWMB_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXPWM3_PWMB_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXPWM3_PWMB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXPWM3_PWMB_SELECT_INPUT_3_DAISY() volatile
    {
        return FLEXPWM3_PWMB_SELECT_INPUT_3 & (1u << 0u);
    }

    /**
     * Set FLEXPWM3_PWMB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXPWM3_PWMB_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_3 |= 1u << 0u;
    }

    /**
     * Clear FLEXPWM3_PWMB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXPWM3_PWMB_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_3 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXPWM3_PWMB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXPWM3_PWMB_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXPWM3_PWMB_SELECT_INPUT_3 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_DQS_FA_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_FLEXSPI1_I_DQS_FA_SELECT_INPUT_DAISY
    get_FLEXSPI1_I_DQS_FA_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_FLEXSPI1_I_DQS_FA_SELECT_INPUT_DAISY(
            (FLEXSPI1_I_DQS_FA_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set FLEXSPI1_I_DQS_FA_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_DQS_FA_SELECT_INPUT_DAISY(
        IOMUXC_FLEXSPI1_I_DQS_FA_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = FLEXSPI1_I_DQS_FA_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        FLEXSPI1_I_DQS_FA_SELECT_INPUT = curr;
    }

    /**
     * Get FLEXSPI1_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FA_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FA_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FA_SELECT_INPUT_3 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_3 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_3 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI1_I_IO_FA_SELECT_INPUT_3 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FB_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FB_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FB_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FB_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FB_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FB_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FB_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FB_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FB_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FB_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FB_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FB_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_IO_FB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_IO_FB_SELECT_INPUT_3_DAISY() volatile
    {
        return FLEXSPI1_I_IO_FB_SELECT_INPUT_3 & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_IO_FB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_IO_FB_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_3 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_IO_FB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_IO_FB_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_3 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_IO_FB_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_IO_FB_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI1_I_IO_FB_SELECT_INPUT_3 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        return FLEXSPI1_I_SCK_FA_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI1_I_SCK_FA_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI1_I_SCK_FA_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI1_I_SCK_FA_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI1_I_SCK_FB_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI1_I_SCK_FB_SELECT_INPUT_DAISY() volatile
    {
        return FLEXSPI1_I_SCK_FB_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set FLEXSPI1_I_SCK_FB_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI1_I_SCK_FB_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI1_I_SCK_FB_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI1_I_SCK_FB_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI1_I_SCK_FB_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI1_I_SCK_FB_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI1_I_SCK_FB_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI1_I_SCK_FB_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI1_I_SCK_FB_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI2_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI2_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        return FLEXSPI2_I_IO_FA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set FLEXSPI2_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI2_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI2_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI2_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI2_I_IO_FA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI2_I_IO_FA_SELECT_INPUT_0_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI2_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI2_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        return FLEXSPI2_I_IO_FA_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set FLEXSPI2_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI2_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI2_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI2_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI2_I_IO_FA_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI2_I_IO_FA_SELECT_INPUT_1_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI2_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI2_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        return FLEXSPI2_I_IO_FA_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set FLEXSPI2_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI2_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI2_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI2_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI2_I_IO_FA_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI2_I_IO_FA_SELECT_INPUT_2_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI2_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI2_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        return FLEXSPI2_I_IO_FA_SELECT_INPUT_3 & (1u << 0u);
    }

    /**
     * Set FLEXSPI2_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI2_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_3 |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI2_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI2_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_3 &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI2_I_IO_FA_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI2_I_IO_FA_SELECT_INPUT_3_DAISY() volatile
    {
        FLEXSPI2_I_IO_FA_SELECT_INPUT_3 ^= 1u << 0u;
    }

    /**
     * Get FLEXSPI2_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_FLEXSPI2_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        return FLEXSPI2_I_SCK_FA_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set FLEXSPI2_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_FLEXSPI2_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI2_I_SCK_FA_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear FLEXSPI2_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_FLEXSPI2_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI2_I_SCK_FA_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle FLEXSPI2_I_SCK_FA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_FLEXSPI2_I_SCK_FA_SELECT_INPUT_DAISY() volatile
    {
        FLEXSPI2_I_SCK_FA_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get GPT3_CAPIN1_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_GPT3_CAPIN1_SELECT_INPUT_DAISY() volatile
    {
        return GPT3_CAPIN1_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set GPT3_CAPIN1_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_GPT3_CAPIN1_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CAPIN1_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear GPT3_CAPIN1_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_GPT3_CAPIN1_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CAPIN1_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle GPT3_CAPIN1_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_GPT3_CAPIN1_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CAPIN1_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get GPT3_CAPIN2_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_GPT3_CAPIN2_SELECT_INPUT_DAISY() volatile
    {
        return GPT3_CAPIN2_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set GPT3_CAPIN2_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_GPT3_CAPIN2_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CAPIN2_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear GPT3_CAPIN2_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_GPT3_CAPIN2_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CAPIN2_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle GPT3_CAPIN2_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_GPT3_CAPIN2_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CAPIN2_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get GPT3_CLKIN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_GPT3_CLKIN_SELECT_INPUT_DAISY() volatile
    {
        return GPT3_CLKIN_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set GPT3_CLKIN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_GPT3_CLKIN_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CLKIN_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear GPT3_CLKIN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_GPT3_CLKIN_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CLKIN_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle GPT3_CLKIN_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_GPT3_CLKIN_SELECT_INPUT_DAISY() volatile
    {
        GPT3_CLKIN_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get KPP_COL_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_KPP_COL_SELECT_INPUT_6_DAISY() volatile
    {
        return KPP_COL_SELECT_INPUT_6 & (1u << 0u);
    }

    /**
     * Set KPP_COL_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_KPP_COL_SELECT_INPUT_6_DAISY() volatile
    {
        KPP_COL_SELECT_INPUT_6 |= 1u << 0u;
    }

    /**
     * Clear KPP_COL_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_KPP_COL_SELECT_INPUT_6_DAISY() volatile
    {
        KPP_COL_SELECT_INPUT_6 &= ~(1u << 0u);
    }

    /**
     * Toggle KPP_COL_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_KPP_COL_SELECT_INPUT_6_DAISY() volatile
    {
        KPP_COL_SELECT_INPUT_6 ^= 1u << 0u;
    }

    /**
     * Get KPP_COL_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_KPP_COL_SELECT_INPUT_7_DAISY() volatile
    {
        return KPP_COL_SELECT_INPUT_7 & (1u << 0u);
    }

    /**
     * Set KPP_COL_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_KPP_COL_SELECT_INPUT_7_DAISY() volatile
    {
        KPP_COL_SELECT_INPUT_7 |= 1u << 0u;
    }

    /**
     * Clear KPP_COL_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_KPP_COL_SELECT_INPUT_7_DAISY() volatile
    {
        KPP_COL_SELECT_INPUT_7 &= ~(1u << 0u);
    }

    /**
     * Toggle KPP_COL_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_KPP_COL_SELECT_INPUT_7_DAISY() volatile
    {
        KPP_COL_SELECT_INPUT_7 ^= 1u << 0u;
    }

    /**
     * Get KPP_ROW_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_KPP_ROW_SELECT_INPUT_6_DAISY() volatile
    {
        return KPP_ROW_SELECT_INPUT_6 & (1u << 0u);
    }

    /**
     * Set KPP_ROW_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_KPP_ROW_SELECT_INPUT_6_DAISY() volatile
    {
        KPP_ROW_SELECT_INPUT_6 |= 1u << 0u;
    }

    /**
     * Clear KPP_ROW_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_KPP_ROW_SELECT_INPUT_6_DAISY() volatile
    {
        KPP_ROW_SELECT_INPUT_6 &= ~(1u << 0u);
    }

    /**
     * Toggle KPP_ROW_SELECT_INPUT_6's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_KPP_ROW_SELECT_INPUT_6_DAISY() volatile
    {
        KPP_ROW_SELECT_INPUT_6 ^= 1u << 0u;
    }

    /**
     * Get KPP_ROW_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_KPP_ROW_SELECT_INPUT_7_DAISY() volatile
    {
        return KPP_ROW_SELECT_INPUT_7 & (1u << 0u);
    }

    /**
     * Set KPP_ROW_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_KPP_ROW_SELECT_INPUT_7_DAISY() volatile
    {
        KPP_ROW_SELECT_INPUT_7 |= 1u << 0u;
    }

    /**
     * Clear KPP_ROW_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_KPP_ROW_SELECT_INPUT_7_DAISY() volatile
    {
        KPP_ROW_SELECT_INPUT_7 &= ~(1u << 0u);
    }

    /**
     * Toggle KPP_ROW_SELECT_INPUT_7's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_KPP_ROW_SELECT_INPUT_7_DAISY() volatile
    {
        KPP_ROW_SELECT_INPUT_7 ^= 1u << 0u;
    }

    /**
     * Get LPI2C1_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C1_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C1_LPI2C_SCL_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C1_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C1_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C1_LPI2C_SCL_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C1_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C1_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C1_LPI2C_SCL_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C1_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C1_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C1_LPI2C_SCL_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C1_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C1_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C1_LPI2C_SDA_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C1_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C1_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C1_LPI2C_SDA_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C1_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C1_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C1_LPI2C_SDA_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C1_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C1_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C1_LPI2C_SDA_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C2_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C2_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C2_LPI2C_SCL_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C2_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C2_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C2_LPI2C_SCL_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C2_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C2_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C2_LPI2C_SCL_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C2_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C2_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C2_LPI2C_SCL_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C2_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C2_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C2_LPI2C_SDA_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C2_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C2_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C2_LPI2C_SDA_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C2_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C2_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C2_LPI2C_SDA_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C2_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C2_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C2_LPI2C_SDA_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C3_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C3_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C3_LPI2C_SCL_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C3_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C3_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C3_LPI2C_SCL_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C3_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C3_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C3_LPI2C_SCL_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C3_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C3_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C3_LPI2C_SCL_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C3_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C3_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C3_LPI2C_SDA_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C3_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C3_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C3_LPI2C_SDA_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C3_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C3_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C3_LPI2C_SDA_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C3_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C3_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C3_LPI2C_SDA_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C4_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C4_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C4_LPI2C_SCL_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C4_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C4_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C4_LPI2C_SCL_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C4_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C4_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C4_LPI2C_SCL_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C4_LPI2C_SCL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C4_LPI2C_SCL_SELECT_INPUT_DAISY() volatile
    {
        LPI2C4_LPI2C_SCL_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPI2C4_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPI2C4_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        return LPI2C4_LPI2C_SDA_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPI2C4_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPI2C4_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C4_LPI2C_SDA_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPI2C4_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPI2C4_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C4_LPI2C_SDA_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPI2C4_LPI2C_SDA_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPI2C4_LPI2C_SDA_SELECT_INPUT_DAISY() volatile
    {
        LPI2C4_LPI2C_SDA_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI1_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI1_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        return LPSPI1_LPSPI_PCS_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set LPSPI1_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI1_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI1_LPSPI_PCS_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear LPSPI1_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI1_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI1_LPSPI_PCS_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI1_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI1_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI1_LPSPI_PCS_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get LPSPI1_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI1_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI1_LPSPI_SCK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI1_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI1_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SCK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI1_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI1_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SCK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI1_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI1_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SCK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI1_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI1_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI1_LPSPI_SDI_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI1_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI1_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SDI_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI1_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI1_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SDI_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI1_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI1_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SDI_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI1_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI1_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI1_LPSPI_SDO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI1_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI1_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SDO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI1_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI1_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SDO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI1_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI1_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI1_LPSPI_SDO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI2_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI2_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        return LPSPI2_LPSPI_PCS_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set LPSPI2_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI2_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI2_LPSPI_PCS_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear LPSPI2_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI2_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI2_LPSPI_PCS_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI2_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI2_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI2_LPSPI_PCS_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get LPSPI2_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI2_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        return LPSPI2_LPSPI_PCS_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set LPSPI2_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI2_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        LPSPI2_LPSPI_PCS_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear LPSPI2_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI2_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        LPSPI2_LPSPI_PCS_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI2_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI2_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        LPSPI2_LPSPI_PCS_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get LPSPI2_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI2_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI2_LPSPI_SCK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI2_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI2_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SCK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI2_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI2_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SCK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI2_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI2_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SCK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI2_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI2_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI2_LPSPI_SDI_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI2_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI2_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SDI_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI2_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI2_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SDI_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI2_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI2_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SDI_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI2_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI2_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI2_LPSPI_SDO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI2_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI2_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SDO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI2_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI2_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SDO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI2_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI2_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI2_LPSPI_SDO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        return LPSPI3_LPSPI_PCS_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        return LPSPI3_LPSPI_PCS_SELECT_INPUT_1 & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_1 |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_1 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_PCS_SELECT_INPUT_1's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_PCS_SELECT_INPUT_1_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_1 ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_PCS_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_PCS_SELECT_INPUT_2_DAISY() volatile
    {
        return LPSPI3_LPSPI_PCS_SELECT_INPUT_2 & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_PCS_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_PCS_SELECT_INPUT_2_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_2 |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_PCS_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_PCS_SELECT_INPUT_2_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_2 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_PCS_SELECT_INPUT_2's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_PCS_SELECT_INPUT_2_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_2 ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_PCS_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_PCS_SELECT_INPUT_3_DAISY() volatile
    {
        return LPSPI3_LPSPI_PCS_SELECT_INPUT_3 & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_PCS_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_PCS_SELECT_INPUT_3_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_3 |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_PCS_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_PCS_SELECT_INPUT_3_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_3 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_PCS_SELECT_INPUT_3's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_PCS_SELECT_INPUT_3_DAISY() volatile
    {
        LPSPI3_LPSPI_PCS_SELECT_INPUT_3 ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI3_LPSPI_SCK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SCK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SCK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SCK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI3_LPSPI_SDI_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SDI_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SDI_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SDI_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI3_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI3_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI3_LPSPI_SDO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI3_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI3_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SDO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI3_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI3_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SDO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI3_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI3_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI3_LPSPI_SDO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI4_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI4_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        return LPSPI4_LPSPI_PCS_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set LPSPI4_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI4_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI4_LPSPI_PCS_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear LPSPI4_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI4_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI4_LPSPI_PCS_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI4_LPSPI_PCS_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI4_LPSPI_PCS_SELECT_INPUT_0_DAISY() volatile
    {
        LPSPI4_LPSPI_PCS_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get LPSPI4_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI4_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI4_LPSPI_SCK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI4_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI4_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SCK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI4_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI4_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SCK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI4_LPSPI_SCK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI4_LPSPI_SCK_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SCK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI4_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI4_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI4_LPSPI_SDI_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI4_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI4_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SDI_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI4_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI4_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SDI_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI4_LPSPI_SDI_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI4_LPSPI_SDI_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SDI_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPSPI4_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPSPI4_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        return LPSPI4_LPSPI_SDO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPSPI4_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPSPI4_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SDO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPSPI4_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPSPI4_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SDO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPSPI4_LPSPI_SDO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPSPI4_LPSPI_SDO_SELECT_INPUT_DAISY() volatile
    {
        LPSPI4_LPSPI_SDO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPUART1_LPUART_RXD_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_LPUART1_LPUART_RXD_SELECT_INPUT_DAISY
    get_LPUART1_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_LPUART1_LPUART_RXD_SELECT_INPUT_DAISY(
            (LPUART1_LPUART_RXD_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set LPUART1_LPUART_RXD_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART1_LPUART_RXD_SELECT_INPUT_DAISY(
        IOMUXC_LPUART1_LPUART_RXD_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = LPUART1_LPUART_RXD_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        LPUART1_LPUART_RXD_SELECT_INPUT = curr;
    }

    /**
     * Get LPUART1_LPUART_TXD_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_LPUART1_LPUART_TXD_SELECT_INPUT_DAISY
    get_LPUART1_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_LPUART1_LPUART_TXD_SELECT_INPUT_DAISY(
            (LPUART1_LPUART_TXD_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set LPUART1_LPUART_TXD_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART1_LPUART_TXD_SELECT_INPUT_DAISY(
        IOMUXC_LPUART1_LPUART_TXD_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = LPUART1_LPUART_TXD_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        LPUART1_LPUART_TXD_SELECT_INPUT = curr;
    }

    /**
     * Get LPUART10_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPUART10_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        return LPUART10_LPUART_RXD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPUART10_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART10_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART10_LPUART_RXD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPUART10_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPUART10_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART10_LPUART_RXD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPUART10_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPUART10_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART10_LPUART_RXD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPUART10_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPUART10_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        return LPUART10_LPUART_TXD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPUART10_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART10_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART10_LPUART_TXD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPUART10_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPUART10_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART10_LPUART_TXD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPUART10_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPUART10_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART10_LPUART_TXD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPUART7_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPUART7_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        return LPUART7_LPUART_RXD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPUART7_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART7_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART7_LPUART_RXD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPUART7_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPUART7_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART7_LPUART_RXD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPUART7_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPUART7_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART7_LPUART_RXD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPUART7_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPUART7_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        return LPUART7_LPUART_TXD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPUART7_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART7_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART7_LPUART_TXD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPUART7_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPUART7_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART7_LPUART_TXD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPUART7_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPUART7_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART7_LPUART_TXD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPUART8_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPUART8_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        return LPUART8_LPUART_RXD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPUART8_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART8_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART8_LPUART_RXD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPUART8_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPUART8_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART8_LPUART_RXD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPUART8_LPUART_RXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPUART8_LPUART_RXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART8_LPUART_RXD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get LPUART8_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_LPUART8_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        return LPUART8_LPUART_TXD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set LPUART8_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_LPUART8_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART8_LPUART_TXD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear LPUART8_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_LPUART8_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART8_LPUART_TXD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle LPUART8_LPUART_TXD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_LPUART8_LPUART_TXD_SELECT_INPUT_DAISY() volatile
    {
        LPUART8_LPUART_TXD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get QTIMER1_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER1_TMR0_INPUT_SELECT_INPUT_DAISY
    get_QTIMER1_TMR0_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER1_TMR0_INPUT_SELECT_INPUT_DAISY(
            (QTIMER1_TMR0_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER1_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER1_TMR0_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER1_TMR0_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER1_TMR0_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER1_TMR0_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER1_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER1_TMR1_INPUT_SELECT_INPUT_DAISY
    get_QTIMER1_TMR1_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER1_TMR1_INPUT_SELECT_INPUT_DAISY(
            (QTIMER1_TMR1_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER1_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER1_TMR1_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER1_TMR1_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER1_TMR1_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER1_TMR1_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER1_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_QTIMER1_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return QTIMER1_TMR2_INPUT_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set QTIMER1_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER1_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER1_TMR2_INPUT_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear QTIMER1_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_QTIMER1_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER1_TMR2_INPUT_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle QTIMER1_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_QTIMER1_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER1_TMR2_INPUT_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get QTIMER2_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER2_TMR0_INPUT_SELECT_INPUT_DAISY
    get_QTIMER2_TMR0_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER2_TMR0_INPUT_SELECT_INPUT_DAISY(
            (QTIMER2_TMR0_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER2_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER2_TMR0_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER2_TMR0_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER2_TMR0_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER2_TMR0_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER2_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER2_TMR1_INPUT_SELECT_INPUT_DAISY
    get_QTIMER2_TMR1_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER2_TMR1_INPUT_SELECT_INPUT_DAISY(
            (QTIMER2_TMR1_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER2_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER2_TMR1_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER2_TMR1_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER2_TMR1_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER2_TMR1_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER2_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_QTIMER2_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return QTIMER2_TMR2_INPUT_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set QTIMER2_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER2_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER2_TMR2_INPUT_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear QTIMER2_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_QTIMER2_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER2_TMR2_INPUT_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle QTIMER2_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_QTIMER2_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER2_TMR2_INPUT_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get QTIMER3_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER3_TMR0_INPUT_SELECT_INPUT_DAISY
    get_QTIMER3_TMR0_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER3_TMR0_INPUT_SELECT_INPUT_DAISY(
            (QTIMER3_TMR0_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER3_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER3_TMR0_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER3_TMR0_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER3_TMR0_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER3_TMR0_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER3_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER3_TMR1_INPUT_SELECT_INPUT_DAISY
    get_QTIMER3_TMR1_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER3_TMR1_INPUT_SELECT_INPUT_DAISY(
            (QTIMER3_TMR1_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER3_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER3_TMR1_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER3_TMR1_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER3_TMR1_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER3_TMR1_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER3_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_QTIMER3_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return QTIMER3_TMR2_INPUT_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set QTIMER3_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER3_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER3_TMR2_INPUT_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear QTIMER3_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_QTIMER3_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER3_TMR2_INPUT_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle QTIMER3_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_QTIMER3_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER3_TMR2_INPUT_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get QTIMER4_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER4_TMR0_INPUT_SELECT_INPUT_DAISY
    get_QTIMER4_TMR0_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER4_TMR0_INPUT_SELECT_INPUT_DAISY(
            (QTIMER4_TMR0_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER4_TMR0_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER4_TMR0_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER4_TMR0_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER4_TMR0_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER4_TMR0_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER4_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_QTIMER4_TMR1_INPUT_SELECT_INPUT_DAISY
    get_QTIMER4_TMR1_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_QTIMER4_TMR1_INPUT_SELECT_INPUT_DAISY(
            (QTIMER4_TMR1_INPUT_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set QTIMER4_TMR1_INPUT_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER4_TMR1_INPUT_SELECT_INPUT_DAISY(
        IOMUXC_QTIMER4_TMR1_INPUT_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = QTIMER4_TMR1_INPUT_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        QTIMER4_TMR1_INPUT_SELECT_INPUT = curr;
    }

    /**
     * Get QTIMER4_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_QTIMER4_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        return QTIMER4_TMR2_INPUT_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set QTIMER4_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_QTIMER4_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER4_TMR2_INPUT_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear QTIMER4_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_QTIMER4_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER4_TMR2_INPUT_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle QTIMER4_TMR2_INPUT_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_QTIMER4_TMR2_INPUT_SELECT_INPUT_DAISY() volatile
    {
        QTIMER4_TMR2_INPUT_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT_DAISY() volatile
    {
        return SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_IPG_CLK_SAI_MCLK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get SAI1_SAI_RXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_SAI1_SAI_RXBCLK_SELECT_INPUT_DAISY() volatile
    {
        return SAI1_SAI_RXBCLK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set SAI1_SAI_RXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SAI1_SAI_RXBCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_RXBCLK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear SAI1_SAI_RXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_SAI1_SAI_RXBCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_RXBCLK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle SAI1_SAI_RXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_SAI1_SAI_RXBCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_RXBCLK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get SAI1_SAI_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_SAI1_SAI_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        return SAI1_SAI_RXDATA_SELECT_INPUT_0 & (1u << 0u);
    }

    /**
     * Set SAI1_SAI_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SAI1_SAI_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        SAI1_SAI_RXDATA_SELECT_INPUT_0 |= 1u << 0u;
    }

    /**
     * Clear SAI1_SAI_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_SAI1_SAI_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        SAI1_SAI_RXDATA_SELECT_INPUT_0 &= ~(1u << 0u);
    }

    /**
     * Toggle SAI1_SAI_RXDATA_SELECT_INPUT_0's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_SAI1_SAI_RXDATA_SELECT_INPUT_0_DAISY() volatile
    {
        SAI1_SAI_RXDATA_SELECT_INPUT_0 ^= 1u << 0u;
    }

    /**
     * Get SAI1_SAI_RXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_SAI1_SAI_RXSYNC_SELECT_INPUT_DAISY() volatile
    {
        return SAI1_SAI_RXSYNC_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set SAI1_SAI_RXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SAI1_SAI_RXSYNC_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_RXSYNC_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear SAI1_SAI_RXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_SAI1_SAI_RXSYNC_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_RXSYNC_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle SAI1_SAI_RXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_SAI1_SAI_RXSYNC_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_RXSYNC_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get SAI1_SAI_TXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_SAI1_SAI_TXBCLK_SELECT_INPUT_DAISY() volatile
    {
        return SAI1_SAI_TXBCLK_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set SAI1_SAI_TXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SAI1_SAI_TXBCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_TXBCLK_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear SAI1_SAI_TXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_SAI1_SAI_TXBCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_TXBCLK_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle SAI1_SAI_TXBCLK_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_SAI1_SAI_TXBCLK_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_TXBCLK_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get SAI1_SAI_TXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_SAI1_SAI_TXSYNC_SELECT_INPUT_DAISY() volatile
    {
        return SAI1_SAI_TXSYNC_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set SAI1_SAI_TXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SAI1_SAI_TXSYNC_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_TXSYNC_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear SAI1_SAI_TXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_SAI1_SAI_TXSYNC_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_TXSYNC_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle SAI1_SAI_TXSYNC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_SAI1_SAI_TXSYNC_SELECT_INPUT_DAISY() volatile
    {
        SAI1_SAI_TXSYNC_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get EMVSIM1_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_EMVSIM1_SIO_SELECT_INPUT_DAISY() volatile
    {
        return EMVSIM1_SIO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set EMVSIM1_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_EMVSIM1_SIO_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_SIO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear EMVSIM1_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_EMVSIM1_SIO_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_SIO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle EMVSIM1_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_EMVSIM1_SIO_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_SIO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get EMVSIM1_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_EMVSIM1_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        return EMVSIM1_IPP_SIMPD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set EMVSIM1_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_EMVSIM1_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_IPP_SIMPD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear EMVSIM1_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_EMVSIM1_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_IPP_SIMPD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle EMVSIM1_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_EMVSIM1_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_IPP_SIMPD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get EMVSIM1_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_EMVSIM1_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        return EMVSIM1_POWER_FAIL_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set EMVSIM1_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_EMVSIM1_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_POWER_FAIL_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear EMVSIM1_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_EMVSIM1_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_POWER_FAIL_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle EMVSIM1_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_EMVSIM1_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM1_POWER_FAIL_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get EMVSIM2_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_EMVSIM2_SIO_SELECT_INPUT_DAISY() volatile
    {
        return EMVSIM2_SIO_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set EMVSIM2_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_EMVSIM2_SIO_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_SIO_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear EMVSIM2_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_EMVSIM2_SIO_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_SIO_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle EMVSIM2_SIO_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_EMVSIM2_SIO_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_SIO_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get EMVSIM2_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_EMVSIM2_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        return EMVSIM2_IPP_SIMPD_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set EMVSIM2_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_EMVSIM2_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_IPP_SIMPD_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear EMVSIM2_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_EMVSIM2_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_IPP_SIMPD_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle EMVSIM2_IPP_SIMPD_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_EMVSIM2_IPP_SIMPD_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_IPP_SIMPD_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get EMVSIM2_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_EMVSIM2_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        return EMVSIM2_POWER_FAIL_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set EMVSIM2_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_EMVSIM2_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_POWER_FAIL_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear EMVSIM2_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_EMVSIM2_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_POWER_FAIL_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle EMVSIM2_POWER_FAIL_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_EMVSIM2_POWER_FAIL_SELECT_INPUT_DAISY() volatile
    {
        EMVSIM2_POWER_FAIL_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get SPDIF_SPDIF_IN1_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY
    get_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY() volatile
    {
        return IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY(
            (SPDIF_SPDIF_IN1_SELECT_INPUT >> 0u) & 0b11u);
    }

    /**
     * Set SPDIF_SPDIF_IN1_SELECT_INPUT's DAISY field.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY(
        IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY value) volatile
    {
        uint32_t curr = SPDIF_SPDIF_IN1_SELECT_INPUT;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        SPDIF_SPDIF_IN1_SELECT_INPUT = curr;
    }

    /**
     * Get USB_OTG2_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USB_OTG2_OC_SELECT_INPUT_DAISY() volatile
    {
        return USB_OTG2_OC_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USB_OTG2_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USB_OTG2_OC_SELECT_INPUT_DAISY() volatile
    {
        USB_OTG2_OC_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USB_OTG2_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USB_OTG2_OC_SELECT_INPUT_DAISY() volatile
    {
        USB_OTG2_OC_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USB_OTG2_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USB_OTG2_OC_SELECT_INPUT_DAISY() volatile
    {
        USB_OTG2_OC_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USB_OTG_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USB_OTG_OC_SELECT_INPUT_DAISY() volatile
    {
        return USB_OTG_OC_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USB_OTG_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USB_OTG_OC_SELECT_INPUT_DAISY() volatile
    {
        USB_OTG_OC_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USB_OTG_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USB_OTG_OC_SELECT_INPUT_DAISY() volatile
    {
        USB_OTG_OC_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USB_OTG_OC_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USB_OTG_OC_SELECT_INPUT_DAISY() volatile
    {
        USB_OTG_OC_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USBPHY1_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USBPHY1_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        return USBPHY1_USB_ID_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USBPHY1_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USBPHY1_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        USBPHY1_USB_ID_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USBPHY1_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USBPHY1_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        USBPHY1_USB_ID_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USBPHY1_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USBPHY1_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        USBPHY1_USB_ID_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USBPHY2_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USBPHY2_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        return USBPHY2_USB_ID_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USBPHY2_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USBPHY2_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        USBPHY2_USB_ID_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USBPHY2_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USBPHY2_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        USBPHY2_USB_ID_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USBPHY2_USB_ID_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USBPHY2_USB_ID_SELECT_INPUT_DAISY() volatile
    {
        USBPHY2_USB_ID_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USDHC1_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        return USDHC1_IPP_CARD_DET_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USDHC1_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        USDHC1_IPP_CARD_DET_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USDHC1_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        USDHC1_IPP_CARD_DET_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USDHC1_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        USDHC1_IPP_CARD_DET_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USDHC1_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        return USDHC1_IPP_WP_ON_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USDHC1_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        USDHC1_IPP_WP_ON_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USDHC1_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        USDHC1_IPP_WP_ON_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USDHC1_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        USDHC1_IPP_WP_ON_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USDHC2_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        return USDHC2_IPP_CARD_DET_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USDHC2_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        USDHC2_IPP_CARD_DET_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USDHC2_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        USDHC2_IPP_CARD_DET_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USDHC2_IPP_CARD_DET_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY() volatile
    {
        USDHC2_IPP_CARD_DET_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get USDHC2_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        return USDHC2_IPP_WP_ON_SELECT_INPUT & (1u << 0u);
    }

    /**
     * Set USDHC2_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        USDHC2_IPP_WP_ON_SELECT_INPUT |= 1u << 0u;
    }

    /**
     * Clear USDHC2_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        USDHC2_IPP_WP_ON_SELECT_INPUT &= ~(1u << 0u);
    }

    /**
     * Toggle USDHC2_IPP_WP_ON_SELECT_INPUT's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY() volatile
    {
        USDHC2_IPP_WP_ON_SELECT_INPUT ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_20's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_20_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_20 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_20's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_20_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_20 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_20's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_20_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_20 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_20's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_20_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_20 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_21's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_21_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_21 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_21's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_21_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_21 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_21's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_21_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_21 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_21's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_21_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_21 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_22's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_22_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_22 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_22's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_22_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_22 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_22's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_22_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_22 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_22's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_22_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_22 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_23's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_23_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_23 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_23's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_23_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_23 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_23's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_23_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_23 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_23's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_23_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_23 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_24's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_24_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_24 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_24's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_24_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_24 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_24's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_24_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_24 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_24's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_24_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_24 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_25's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_25_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_25 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_25's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_25_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_25 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_25's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_25_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_25 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_25's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_25_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_25 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_26's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_26_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_26 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_26's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_26_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_26 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_26's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_26_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_26 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_26's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_26_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_26 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_27's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_27_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_27 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_27's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_27_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_27 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_27's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_27_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_27 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_27's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_27_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_27 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_28's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_28_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_28 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_28's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_28_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_28 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_28's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_28_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_28 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_28's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_28_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_28 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_29's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_29_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_29 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_29's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_29_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_29 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_29's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_29_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_29 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_29's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_29_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_29 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_30's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_30_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_30 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_30's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_30_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_30 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_30's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_30_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_30 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_30's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_30_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_30 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_31's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_31_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_31 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_31's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_31_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_31 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_31's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_31_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_31 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_31's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_31_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_31 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_32's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_32_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_32 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_32's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_32_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_32 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_32's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_32_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_32 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_32's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_32_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_32 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_33's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_33_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_33 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_33's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_33_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_33 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_33's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_33_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_33 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_33's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_33_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_33 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_34's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_34_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_34 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_34's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_34_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_34 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_34's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_34_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_34 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_34's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_34_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_34 ^= 1u << 0u;
    }

    /**
     * Get XBAR1_IN_SELECT_INPUT_35's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline bool get_XBAR1_IN_SELECT_INPUT_35_DAISY() volatile
    {
        return XBAR1_IN_SELECT_INPUT_35 & (1u << 0u);
    }

    /**
     * Set XBAR1_IN_SELECT_INPUT_35's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void set_XBAR1_IN_SELECT_INPUT_35_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_35 |= 1u << 0u;
    }

    /**
     * Clear XBAR1_IN_SELECT_INPUT_35's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void clear_XBAR1_IN_SELECT_INPUT_35_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_35 &= ~(1u << 0u);
    }

    /**
     * Toggle XBAR1_IN_SELECT_INPUT_35's DAISY bit.
     *
     * Selecting Pads Involved in Daisy Chain.
     */
    inline void toggle_XBAR1_IN_SELECT_INPUT_35_DAISY() volatile
    {
        XBAR1_IN_SELECT_INPUT_35 ^= 1u << 0u;
    }
};

static_assert(sizeof(iomuxc) == iomuxc::size);

static volatile iomuxc *const IOMUXC = reinterpret_cast<iomuxc *>(0x400E8000);

}; // namespace MIMXRT1176::CM7
