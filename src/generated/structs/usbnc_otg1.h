/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * USBNC
 */
struct [[gnu::packed]] usbnc_otg1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 20; /*!< usbnc_otg1's size in bytes. */

    /* Fields. */
    uint32_t CTRL1; /*!< (read-write) USB OTG Control 1 Register */
    uint32_t CTRL2; /*!< (read-write) USB OTG Control 2 Register */
    static constexpr std::size_t reserved_padding0_length = 2;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t HSIC_CTRL; /*!< (read-write) USB Host HSIC Control Register */

    /* Methods. */

    /**
     * Get CTRL1's WIR bit.
     *
     * WIR
     */
    inline bool get_CTRL1_WIR() volatile
    {
        return CTRL1 & (1u << 31u);
    }

    /**
     * Get CTRL1's WKUP_DPDM_EN bit.
     *
     * Wake-up on DPDM change enable
     */
    inline bool get_CTRL1_WKUP_DPDM_EN() volatile
    {
        return CTRL1 & (1u << 29u);
    }

    /**
     * Set CTRL1's WKUP_DPDM_EN bit.
     *
     * Wake-up on DPDM change enable
     */
    inline void set_CTRL1_WKUP_DPDM_EN() volatile
    {
        CTRL1 |= 1u << 29u;
    }

    /**
     * Clear CTRL1's WKUP_DPDM_EN bit.
     *
     * Wake-up on DPDM change enable
     */
    inline void clear_CTRL1_WKUP_DPDM_EN() volatile
    {
        CTRL1 &= ~(1u << 29u);
    }

    /**
     * Toggle CTRL1's WKUP_DPDM_EN bit.
     *
     * Wake-up on DPDM change enable
     */
    inline void toggle_CTRL1_WKUP_DPDM_EN() volatile
    {
        CTRL1 ^= 1u << 29u;
    }

    /**
     * Get CTRL1's WKUP_VBUS_EN bit.
     *
     * WKUP_VBUS_EN
     */
    inline bool get_CTRL1_WKUP_VBUS_EN() volatile
    {
        return CTRL1 & (1u << 17u);
    }

    /**
     * Set CTRL1's WKUP_VBUS_EN bit.
     *
     * WKUP_VBUS_EN
     */
    inline void set_CTRL1_WKUP_VBUS_EN() volatile
    {
        CTRL1 |= 1u << 17u;
    }

    /**
     * Clear CTRL1's WKUP_VBUS_EN bit.
     *
     * WKUP_VBUS_EN
     */
    inline void clear_CTRL1_WKUP_VBUS_EN() volatile
    {
        CTRL1 &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL1's WKUP_VBUS_EN bit.
     *
     * WKUP_VBUS_EN
     */
    inline void toggle_CTRL1_WKUP_VBUS_EN() volatile
    {
        CTRL1 ^= 1u << 17u;
    }

    /**
     * Get CTRL1's WKUP_ID_EN bit.
     *
     * WKUP_ID_EN
     */
    inline bool get_CTRL1_WKUP_ID_EN() volatile
    {
        return CTRL1 & (1u << 16u);
    }

    /**
     * Set CTRL1's WKUP_ID_EN bit.
     *
     * WKUP_ID_EN
     */
    inline void set_CTRL1_WKUP_ID_EN() volatile
    {
        CTRL1 |= 1u << 16u;
    }

    /**
     * Clear CTRL1's WKUP_ID_EN bit.
     *
     * WKUP_ID_EN
     */
    inline void clear_CTRL1_WKUP_ID_EN() volatile
    {
        CTRL1 &= ~(1u << 16u);
    }

    /**
     * Toggle CTRL1's WKUP_ID_EN bit.
     *
     * WKUP_ID_EN
     */
    inline void toggle_CTRL1_WKUP_ID_EN() volatile
    {
        CTRL1 ^= 1u << 16u;
    }

    /**
     * Get CTRL1's WKUP_SW bit.
     *
     * WKUP_SW
     */
    inline bool get_CTRL1_WKUP_SW() volatile
    {
        return CTRL1 & (1u << 15u);
    }

    /**
     * Set CTRL1's WKUP_SW bit.
     *
     * WKUP_SW
     */
    inline void set_CTRL1_WKUP_SW() volatile
    {
        CTRL1 |= 1u << 15u;
    }

    /**
     * Clear CTRL1's WKUP_SW bit.
     *
     * WKUP_SW
     */
    inline void clear_CTRL1_WKUP_SW() volatile
    {
        CTRL1 &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL1's WKUP_SW bit.
     *
     * WKUP_SW
     */
    inline void toggle_CTRL1_WKUP_SW() volatile
    {
        CTRL1 ^= 1u << 15u;
    }

    /**
     * Get CTRL1's WKUP_SW_EN bit.
     *
     * WKUP_SW_EN
     */
    inline bool get_CTRL1_WKUP_SW_EN() volatile
    {
        return CTRL1 & (1u << 14u);
    }

    /**
     * Set CTRL1's WKUP_SW_EN bit.
     *
     * WKUP_SW_EN
     */
    inline void set_CTRL1_WKUP_SW_EN() volatile
    {
        CTRL1 |= 1u << 14u;
    }

    /**
     * Clear CTRL1's WKUP_SW_EN bit.
     *
     * WKUP_SW_EN
     */
    inline void clear_CTRL1_WKUP_SW_EN() volatile
    {
        CTRL1 &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL1's WKUP_SW_EN bit.
     *
     * WKUP_SW_EN
     */
    inline void toggle_CTRL1_WKUP_SW_EN() volatile
    {
        CTRL1 ^= 1u << 14u;
    }

    /**
     * Get CTRL1's WIE bit.
     *
     * WIE
     */
    inline bool get_CTRL1_WIE() volatile
    {
        return CTRL1 & (1u << 10u);
    }

    /**
     * Set CTRL1's WIE bit.
     *
     * WIE
     */
    inline void set_CTRL1_WIE() volatile
    {
        CTRL1 |= 1u << 10u;
    }

    /**
     * Clear CTRL1's WIE bit.
     *
     * WIE
     */
    inline void clear_CTRL1_WIE() volatile
    {
        CTRL1 &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL1's WIE bit.
     *
     * WIE
     */
    inline void toggle_CTRL1_WIE() volatile
    {
        CTRL1 ^= 1u << 10u;
    }

    /**
     * Get CTRL1's PWR_POL bit.
     *
     * PWR_POL
     */
    inline bool get_CTRL1_PWR_POL() volatile
    {
        return CTRL1 & (1u << 9u);
    }

    /**
     * Set CTRL1's PWR_POL bit.
     *
     * PWR_POL
     */
    inline void set_CTRL1_PWR_POL() volatile
    {
        CTRL1 |= 1u << 9u;
    }

    /**
     * Clear CTRL1's PWR_POL bit.
     *
     * PWR_POL
     */
    inline void clear_CTRL1_PWR_POL() volatile
    {
        CTRL1 &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL1's PWR_POL bit.
     *
     * PWR_POL
     */
    inline void toggle_CTRL1_PWR_POL() volatile
    {
        CTRL1 ^= 1u << 9u;
    }

    /**
     * Get CTRL1's OVER_CUR_POL bit.
     *
     * OVER_CUR_POL
     */
    inline bool get_CTRL1_OVER_CUR_POL() volatile
    {
        return CTRL1 & (1u << 8u);
    }

    /**
     * Set CTRL1's OVER_CUR_POL bit.
     *
     * OVER_CUR_POL
     */
    inline void set_CTRL1_OVER_CUR_POL() volatile
    {
        CTRL1 |= 1u << 8u;
    }

    /**
     * Clear CTRL1's OVER_CUR_POL bit.
     *
     * OVER_CUR_POL
     */
    inline void clear_CTRL1_OVER_CUR_POL() volatile
    {
        CTRL1 &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL1's OVER_CUR_POL bit.
     *
     * OVER_CUR_POL
     */
    inline void toggle_CTRL1_OVER_CUR_POL() volatile
    {
        CTRL1 ^= 1u << 8u;
    }

    /**
     * Get CTRL1's OVER_CUR_DIS bit.
     *
     * OVER_CUR_DIS
     */
    inline bool get_CTRL1_OVER_CUR_DIS() volatile
    {
        return CTRL1 & (1u << 7u);
    }

    /**
     * Set CTRL1's OVER_CUR_DIS bit.
     *
     * OVER_CUR_DIS
     */
    inline void set_CTRL1_OVER_CUR_DIS() volatile
    {
        CTRL1 |= 1u << 7u;
    }

    /**
     * Clear CTRL1's OVER_CUR_DIS bit.
     *
     * OVER_CUR_DIS
     */
    inline void clear_CTRL1_OVER_CUR_DIS() volatile
    {
        CTRL1 &= ~(1u << 7u);
    }

    /**
     * Toggle CTRL1's OVER_CUR_DIS bit.
     *
     * OVER_CUR_DIS
     */
    inline void toggle_CTRL1_OVER_CUR_DIS() volatile
    {
        CTRL1 ^= 1u << 7u;
    }

    /**
     * Get all of CTRL1's bit fields.
     *
     * (read-write) USB OTG Control 1 Register
     */
    inline void get_CTRL1(bool &WIR, bool &WKUP_DPDM_EN, bool &WKUP_VBUS_EN,
                          bool &WKUP_ID_EN, bool &WKUP_SW, bool &WKUP_SW_EN,
                          bool &WIE, bool &PWR_POL, bool &OVER_CUR_POL,
                          bool &OVER_CUR_DIS) volatile
    {
        uint32_t curr = CTRL1;

        WIR = curr & (1u << 31u);
        WKUP_DPDM_EN = curr & (1u << 29u);
        WKUP_VBUS_EN = curr & (1u << 17u);
        WKUP_ID_EN = curr & (1u << 16u);
        WKUP_SW = curr & (1u << 15u);
        WKUP_SW_EN = curr & (1u << 14u);
        WIE = curr & (1u << 10u);
        PWR_POL = curr & (1u << 9u);
        OVER_CUR_POL = curr & (1u << 8u);
        OVER_CUR_DIS = curr & (1u << 7u);
    }

    /**
     * Set all of CTRL1's bit fields.
     *
     * (read-write) USB OTG Control 1 Register
     */
    inline void set_CTRL1(bool WKUP_DPDM_EN, bool WKUP_VBUS_EN,
                          bool WKUP_ID_EN, bool WKUP_SW, bool WKUP_SW_EN,
                          bool WIE, bool PWR_POL, bool OVER_CUR_POL,
                          bool OVER_CUR_DIS) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1u << 29u);
        curr |= (WKUP_DPDM_EN & 0b1u) << 29u;
        curr &= ~(0b1u << 17u);
        curr |= (WKUP_VBUS_EN & 0b1u) << 17u;
        curr &= ~(0b1u << 16u);
        curr |= (WKUP_ID_EN & 0b1u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (WKUP_SW & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (WKUP_SW_EN & 0b1u) << 14u;
        curr &= ~(0b1u << 10u);
        curr |= (WIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (PWR_POL & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (OVER_CUR_POL & 0b1u) << 8u;
        curr &= ~(0b1u << 7u);
        curr |= (OVER_CUR_DIS & 0b1u) << 7u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL2's UTMI_CLK_VLD bit.
     *
     * UTMI_CLK_VLD
     */
    inline bool get_CTRL2_UTMI_CLK_VLD() volatile
    {
        return CTRL2 & (1u << 31u);
    }

    /**
     * Set CTRL2's UTMI_CLK_VLD bit.
     *
     * UTMI_CLK_VLD
     */
    inline void set_CTRL2_UTMI_CLK_VLD() volatile
    {
        CTRL2 |= 1u << 31u;
    }

    /**
     * Clear CTRL2's UTMI_CLK_VLD bit.
     *
     * UTMI_CLK_VLD
     */
    inline void clear_CTRL2_UTMI_CLK_VLD() volatile
    {
        CTRL2 &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL2's UTMI_CLK_VLD bit.
     *
     * UTMI_CLK_VLD
     */
    inline void toggle_CTRL2_UTMI_CLK_VLD() volatile
    {
        CTRL2 ^= 1u << 31u;
    }

    /**
     * Get CTRL2's LOWSPEED_EN bit.
     *
     * LOWSPEED_EN
     */
    inline bool get_CTRL2_LOWSPEED_EN() volatile
    {
        return CTRL2 & (1u << 3u);
    }

    /**
     * Set CTRL2's LOWSPEED_EN bit.
     *
     * LOWSPEED_EN
     */
    inline void set_CTRL2_LOWSPEED_EN() volatile
    {
        CTRL2 |= 1u << 3u;
    }

    /**
     * Clear CTRL2's LOWSPEED_EN bit.
     *
     * LOWSPEED_EN
     */
    inline void clear_CTRL2_LOWSPEED_EN() volatile
    {
        CTRL2 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL2's LOWSPEED_EN bit.
     *
     * LOWSPEED_EN
     */
    inline void toggle_CTRL2_LOWSPEED_EN() volatile
    {
        CTRL2 ^= 1u << 3u;
    }

    /**
     * Get CTRL2's AUTURESUME_EN bit.
     *
     * Auto Resume Enable
     */
    inline bool get_CTRL2_AUTURESUME_EN() volatile
    {
        return CTRL2 & (1u << 2u);
    }

    /**
     * Set CTRL2's AUTURESUME_EN bit.
     *
     * Auto Resume Enable
     */
    inline void set_CTRL2_AUTURESUME_EN() volatile
    {
        CTRL2 |= 1u << 2u;
    }

    /**
     * Clear CTRL2's AUTURESUME_EN bit.
     *
     * Auto Resume Enable
     */
    inline void clear_CTRL2_AUTURESUME_EN() volatile
    {
        CTRL2 &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL2's AUTURESUME_EN bit.
     *
     * Auto Resume Enable
     */
    inline void toggle_CTRL2_AUTURESUME_EN() volatile
    {
        CTRL2 ^= 1u << 2u;
    }

    /**
     * Get CTRL2's VBUS_SOURCE_SEL field.
     *
     * VBUS_SOURCE_SEL
     */
    inline USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL
    get_CTRL2_VBUS_SOURCE_SEL() volatile
    {
        return USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL((CTRL2 >> 0u) & 0b11u);
    }

    /**
     * Set CTRL2's VBUS_SOURCE_SEL field.
     *
     * VBUS_SOURCE_SEL
     */
    inline void set_CTRL2_VBUS_SOURCE_SEL(
        USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CTRL2 = curr;
    }

    /**
     * Get all of CTRL2's bit fields.
     *
     * (read-write) USB OTG Control 2 Register
     */
    inline void get_CTRL2(
        bool &UTMI_CLK_VLD, bool &LOWSPEED_EN, bool &AUTURESUME_EN,
        USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL &VBUS_SOURCE_SEL) volatile
    {
        uint32_t curr = CTRL2;

        UTMI_CLK_VLD = curr & (1u << 31u);
        LOWSPEED_EN = curr & (1u << 3u);
        AUTURESUME_EN = curr & (1u << 2u);
        VBUS_SOURCE_SEL =
            USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CTRL2's bit fields.
     *
     * (read-write) USB OTG Control 2 Register
     */
    inline void set_CTRL2(
        bool UTMI_CLK_VLD, bool LOWSPEED_EN, bool AUTURESUME_EN,
        USBNC_OTG1_CTRL2_VBUS_SOURCE_SEL VBUS_SOURCE_SEL) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b1u << 31u);
        curr |= (UTMI_CLK_VLD & 0b1u) << 31u;
        curr &= ~(0b1u << 3u);
        curr |= (LOWSPEED_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AUTURESUME_EN & 0b1u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(VBUS_SOURCE_SEL) & 0b11u) << 0u;

        CTRL2 = curr;
    }

    /**
     * Get HSIC_CTRL's CLK_VLD bit.
     *
     * CLK_VLD
     */
    inline bool get_HSIC_CTRL_CLK_VLD() volatile
    {
        return HSIC_CTRL & (1u << 31u);
    }

    /**
     * Get HSIC_CTRL's HSIC_EN bit.
     *
     * HSIC_EN
     */
    inline bool get_HSIC_CTRL_HSIC_EN() volatile
    {
        return HSIC_CTRL & (1u << 12u);
    }

    /**
     * Set HSIC_CTRL's HSIC_EN bit.
     *
     * HSIC_EN
     */
    inline void set_HSIC_CTRL_HSIC_EN() volatile
    {
        HSIC_CTRL |= 1u << 12u;
    }

    /**
     * Clear HSIC_CTRL's HSIC_EN bit.
     *
     * HSIC_EN
     */
    inline void clear_HSIC_CTRL_HSIC_EN() volatile
    {
        HSIC_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle HSIC_CTRL's HSIC_EN bit.
     *
     * HSIC_EN
     */
    inline void toggle_HSIC_CTRL_HSIC_EN() volatile
    {
        HSIC_CTRL ^= 1u << 12u;
    }

    /**
     * Get HSIC_CTRL's HSIC_CLK_ON bit.
     *
     * HSIC_CLK_ON
     */
    inline bool get_HSIC_CTRL_HSIC_CLK_ON() volatile
    {
        return HSIC_CTRL & (1u << 11u);
    }

    /**
     * Set HSIC_CTRL's HSIC_CLK_ON bit.
     *
     * HSIC_CLK_ON
     */
    inline void set_HSIC_CTRL_HSIC_CLK_ON() volatile
    {
        HSIC_CTRL |= 1u << 11u;
    }

    /**
     * Clear HSIC_CTRL's HSIC_CLK_ON bit.
     *
     * HSIC_CLK_ON
     */
    inline void clear_HSIC_CTRL_HSIC_CLK_ON() volatile
    {
        HSIC_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle HSIC_CTRL's HSIC_CLK_ON bit.
     *
     * HSIC_CLK_ON
     */
    inline void toggle_HSIC_CTRL_HSIC_CLK_ON() volatile
    {
        HSIC_CTRL ^= 1u << 11u;
    }

    /**
     * Get all of HSIC_CTRL's bit fields.
     *
     * (read-write) USB Host HSIC Control Register
     */
    inline void get_HSIC_CTRL(bool &CLK_VLD, bool &HSIC_EN,
                              bool &HSIC_CLK_ON) volatile
    {
        uint32_t curr = HSIC_CTRL;

        CLK_VLD = curr & (1u << 31u);
        HSIC_EN = curr & (1u << 12u);
        HSIC_CLK_ON = curr & (1u << 11u);
    }

    /**
     * Set all of HSIC_CTRL's bit fields.
     *
     * (read-write) USB Host HSIC Control Register
     */
    inline void set_HSIC_CTRL(bool HSIC_EN, bool HSIC_CLK_ON) volatile
    {
        uint32_t curr = HSIC_CTRL;

        curr &= ~(0b1u << 12u);
        curr |= (HSIC_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (HSIC_CLK_ON & 0b1u) << 11u;

        HSIC_CTRL = curr;
    }
};

static_assert(sizeof(usbnc_otg1) == usbnc_otg1::size);

static volatile usbnc_otg1 *const USBNC_OTG1 =
    reinterpret_cast<usbnc_otg1 *>(0x40430200);

static volatile usbnc_otg1 *const USBNC_OTG2 =
    reinterpret_cast<usbnc_otg1 *>(0x4042C200);

}; // namespace MIMXRT1176::CM7
