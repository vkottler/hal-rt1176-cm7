/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/PXP_AS_CTRL_ALPHA_CTRL.h"
#include "../enums/PXP_AS_CTRL_FORMAT.h"
#include "../enums/PXP_AS_CTRL_ROP.h"
#include "../enums/PXP_CTRL_CLR_ROTATE.h"
#include "../enums/PXP_CTRL_ROTATE.h"
#include "../enums/PXP_CTRL_SET_ROTATE.h"
#include "../enums/PXP_CTRL_TOG_ROTATE.h"
#include "../enums/PXP_OUT_CTRL_CLR_FORMAT.h"
#include "../enums/PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT.h"
#include "../enums/PXP_OUT_CTRL_FORMAT.h"
#include "../enums/PXP_OUT_CTRL_INTERLACED_OUTPUT.h"
#include "../enums/PXP_OUT_CTRL_SET_FORMAT.h"
#include "../enums/PXP_OUT_CTRL_SET_INTERLACED_OUTPUT.h"
#include "../enums/PXP_OUT_CTRL_TOG_FORMAT.h"
#include "../enums/PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT.h"
#include "../enums/PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE.h"
#include "../enums/PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE.h"
#include "../enums/PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE.h"
#include "../enums/PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE.h"
#include "../enums/PXP_POWER_ROT_MEM_LP_STATE.h"
#include "../enums/PXP_PS_CTRL_CLR_DECX.h"
#include "../enums/PXP_PS_CTRL_CLR_DECY.h"
#include "../enums/PXP_PS_CTRL_CLR_FORMAT.h"
#include "../enums/PXP_PS_CTRL_DECX.h"
#include "../enums/PXP_PS_CTRL_DECY.h"
#include "../enums/PXP_PS_CTRL_FORMAT.h"
#include "../enums/PXP_PS_CTRL_SET_DECX.h"
#include "../enums/PXP_PS_CTRL_SET_DECY.h"
#include "../enums/PXP_PS_CTRL_SET_FORMAT.h"
#include "../enums/PXP_PS_CTRL_TOG_DECX.h"
#include "../enums/PXP_PS_CTRL_TOG_DECY.h"
#include "../enums/PXP_PS_CTRL_TOG_FORMAT.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * PXP v2.0 Register Reference Index
 */
struct [[gnu::packed]] pxp
{
    /* Constant attributes. */
    static constexpr std::size_t size = 1092; /*!< pxp's size in bytes. */

    /* Fields. */
    uint32_t CTRL;         /*!< (read-write) Control Register 0 */
    uint32_t CTRL_SET;     /*!< (read-write) Control Register 0 */
    uint32_t CTRL_CLR;     /*!< (read-write) Control Register 0 */
    uint32_t CTRL_TOG;     /*!< (read-write) Control Register 0 */
    uint32_t STAT;         /*!< (read-write) Status Register */
    uint32_t STAT_SET;     /*!< (read-write) Status Register */
    uint32_t STAT_CLR;     /*!< (read-write) Status Register */
    uint32_t STAT_TOG;     /*!< (read-write) Status Register */
    uint32_t OUT_CTRL;     /*!< (read-write) Output Buffer Control Register */
    uint32_t OUT_CTRL_SET; /*!< (read-write) Output Buffer Control Register */
    uint32_t OUT_CTRL_CLR; /*!< (read-write) Output Buffer Control Register */
    uint32_t OUT_CTRL_TOG; /*!< (read-write) Output Buffer Control Register */
    uint32_t OUT_BUF;      /*!< (read-write) Output Frame Buffer Pointer */
    static constexpr std::size_t reserved_padding0_length = 3;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t OUT_BUF2; /*!< (read-write) Output Frame Buffer Pointer #2 */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t OUT_PITCH; /*!< (read-write) Output Buffer Pitch */
    static constexpr std::size_t reserved_padding2_length = 3;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t
        OUT_LRC; /*!< (read-write) Output Surface Lower Right Coordinate */
    static constexpr std::size_t reserved_padding3_length = 3;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t OUT_PS_ULC; /*!< (read-write) Processed Surface Upper Left
                            Coordinate */
    static constexpr std::size_t reserved_padding4_length = 3;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t OUT_PS_LRC; /*!< (read-write) Processed Surface Lower Right
                            Coordinate */
    static constexpr std::size_t reserved_padding5_length = 3;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t
        OUT_AS_ULC; /*!< (read-write) Alpha Surface Upper Left Coordinate */
    static constexpr std::size_t reserved_padding6_length = 3;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t
        OUT_AS_LRC; /*!< (read-write) Alpha Surface Lower Right Coordinate */
    static constexpr std::size_t reserved_padding7_length = 3;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t
        PS_CTRL; /*!< (read-write) Processed Surface (PS) Control Register */
    uint32_t PS_CTRL_SET; /*!< (read-write) Processed Surface (PS) Control
                             Register */
    uint32_t PS_CTRL_CLR; /*!< (read-write) Processed Surface (PS) Control
                             Register */
    uint32_t PS_CTRL_TOG; /*!< (read-write) Processed Surface (PS) Control
                             Register */
    uint32_t PS_BUF;      /*!< (read-write) PS Input Buffer Address */
    static constexpr std::size_t reserved_padding8_length = 3;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t PS_UBUF; /*!< (read-write) PS U/Cb or 2 Plane UV Input Buffer
                         Address */
    static constexpr std::size_t reserved_padding9_length = 3;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t PS_VBUF; /*!< (read-write) PS V/Cr Input Buffer Address */
    static constexpr std::size_t reserved_padding10_length = 3;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t PS_PITCH; /*!< (read-write) Processed Surface Pitch */
    static constexpr std::size_t reserved_padding11_length = 3;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t PS_BACKGROUND; /*!< (read-write) PS Background Color */
    static constexpr std::size_t reserved_padding12_length = 3;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t PS_SCALE; /*!< (read-write) PS Scale Factor Register */
    static constexpr std::size_t reserved_padding13_length = 3;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t PS_OFFSET; /*!< (read-write) PS Scale Offset Register */
    static constexpr std::size_t reserved_padding14_length = 3;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t PS_CLRKEYLOW; /*!< (read-write) PS Color Key Low */
    static constexpr std::size_t reserved_padding15_length = 3;
    const uint32_t reserved_padding15[reserved_padding15_length] = {};
    uint32_t PS_CLRKEYHIGH; /*!< (read-write) PS Color Key High */
    static constexpr std::size_t reserved_padding16_length = 3;
    const uint32_t reserved_padding16[reserved_padding16_length] = {};
    uint32_t AS_CTRL; /*!< (read-write) Alpha Surface Control */
    static constexpr std::size_t reserved_padding17_length = 3;
    const uint32_t reserved_padding17[reserved_padding17_length] = {};
    uint32_t AS_BUF; /*!< (read-write) Alpha Surface Buffer Pointer */
    static constexpr std::size_t reserved_padding18_length = 3;
    const uint32_t reserved_padding18[reserved_padding18_length] = {};
    uint32_t AS_PITCH; /*!< (read-write) Alpha Surface Pitch */
    static constexpr std::size_t reserved_padding19_length = 3;
    const uint32_t reserved_padding19[reserved_padding19_length] = {};
    uint32_t AS_CLRKEYLOW; /*!< (read-write) Overlay Color Key Low */
    static constexpr std::size_t reserved_padding20_length = 3;
    const uint32_t reserved_padding20[reserved_padding20_length] = {};
    uint32_t AS_CLRKEYHIGH; /*!< (read-write) Overlay Color Key High */
    static constexpr std::size_t reserved_padding21_length = 3;
    const uint32_t reserved_padding21[reserved_padding21_length] = {};
    uint32_t CSC1_COEF0; /*!< (read-write) Color Space Conversion Coefficient
                            Register 0 */
    static constexpr std::size_t reserved_padding22_length = 3;
    const uint32_t reserved_padding22[reserved_padding22_length] = {};
    uint32_t CSC1_COEF1; /*!< (read-write) Color Space Conversion Coefficient
                            Register 1 */
    static constexpr std::size_t reserved_padding23_length = 3;
    const uint32_t reserved_padding23[reserved_padding23_length] = {};
    uint32_t CSC1_COEF2; /*!< (read-write) Color Space Conversion Coefficient
                            Register 2 */
    static constexpr std::size_t reserved_padding24_length = 87;
    const uint32_t reserved_padding24[reserved_padding24_length] = {};
    uint32_t POWER; /*!< (read-write) PXP Power Control Register */
    static constexpr std::size_t reserved_padding25_length = 55;
    const uint32_t reserved_padding25[reserved_padding25_length] = {};
    uint32_t NEXT; /*!< (read-write) Next Frame Pointer */
    static constexpr std::size_t reserved_padding26_length = 15;
    const uint32_t reserved_padding26[reserved_padding26_length] = {};
    uint32_t PORTER_DUFF_CTRL; /*!< (read-write) PXP Alpha Engine A Control
                                  Register. */

    /* Methods. */

    /**
     * Get CTRL's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline bool get_CTRL_SFTRST() volatile
    {
        return CTRL & (1u << 31u);
    }

    /**
     * Set CTRL's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void set_CTRL_SFTRST() volatile
    {
        CTRL |= 1u << 31u;
    }

    /**
     * Clear CTRL's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void clear_CTRL_SFTRST() volatile
    {
        CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void toggle_CTRL_SFTRST() volatile
    {
        CTRL ^= 1u << 31u;
    }

    /**
     * Get CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_CLKGATE() volatile
    {
        return CTRL & (1u << 30u);
    }

    /**
     * Set CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_CLKGATE() volatile
    {
        CTRL |= 1u << 30u;
    }

    /**
     * Clear CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_CLKGATE() volatile
    {
        CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_CLKGATE() volatile
    {
        CTRL ^= 1u << 30u;
    }

    /**
     * Get CTRL's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline bool get_CTRL_EN_REPEAT() volatile
    {
        return CTRL & (1u << 28u);
    }

    /**
     * Set CTRL's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void set_CTRL_EN_REPEAT() volatile
    {
        CTRL |= 1u << 28u;
    }

    /**
     * Clear CTRL's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void clear_CTRL_EN_REPEAT() volatile
    {
        CTRL &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void toggle_CTRL_EN_REPEAT() volatile
    {
        CTRL ^= 1u << 28u;
    }

    /**
     * Get CTRL's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline bool get_CTRL_BLOCK_SIZE() volatile
    {
        return CTRL & (1u << 23u);
    }

    /**
     * Set CTRL's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void set_CTRL_BLOCK_SIZE() volatile
    {
        CTRL |= 1u << 23u;
    }

    /**
     * Clear CTRL's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void clear_CTRL_BLOCK_SIZE() volatile
    {
        CTRL &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void toggle_CTRL_BLOCK_SIZE() volatile
    {
        CTRL ^= 1u << 23u;
    }

    /**
     * Get CTRL's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline bool get_CTRL_ROT_POS() volatile
    {
        return CTRL & (1u << 22u);
    }

    /**
     * Set CTRL's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void set_CTRL_ROT_POS() volatile
    {
        CTRL |= 1u << 22u;
    }

    /**
     * Clear CTRL's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void clear_CTRL_ROT_POS() volatile
    {
        CTRL &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void toggle_CTRL_ROT_POS() volatile
    {
        CTRL ^= 1u << 22u;
    }

    /**
     * Get CTRL's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline bool get_CTRL_VFLIP() volatile
    {
        return CTRL & (1u << 11u);
    }

    /**
     * Set CTRL's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void set_CTRL_VFLIP() volatile
    {
        CTRL |= 1u << 11u;
    }

    /**
     * Clear CTRL's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void clear_CTRL_VFLIP() volatile
    {
        CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_VFLIP() volatile
    {
        CTRL ^= 1u << 11u;
    }

    /**
     * Get CTRL's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline bool get_CTRL_HFLIP() volatile
    {
        return CTRL & (1u << 10u);
    }

    /**
     * Set CTRL's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void set_CTRL_HFLIP() volatile
    {
        CTRL |= 1u << 10u;
    }

    /**
     * Clear CTRL's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void clear_CTRL_HFLIP() volatile
    {
        CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_HFLIP() volatile
    {
        CTRL ^= 1u << 10u;
    }

    /**
     * Get CTRL's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline PXP_CTRL_ROTATE get_CTRL_ROTATE() volatile
    {
        return PXP_CTRL_ROTATE((CTRL >> 8u) & 0b11u);
    }

    /**
     * Set CTRL's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline void set_CTRL_ROTATE(PXP_CTRL_ROTATE value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL = curr;
    }

    /**
     * Get CTRL's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline bool get_CTRL_ENABLE_LCD_HANDSHAKE() volatile
    {
        return CTRL & (1u << 4u);
    }

    /**
     * Set CTRL's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void set_CTRL_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL |= 1u << 4u;
    }

    /**
     * Clear CTRL's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void clear_CTRL_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void toggle_CTRL_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL ^= 1u << 4u;
    }

    /**
     * Get CTRL's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline bool get_CTRL_NEXT_IRQ_ENABLE() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void set_CTRL_NEXT_IRQ_ENABLE() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void clear_CTRL_NEXT_IRQ_ENABLE() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void toggle_CTRL_NEXT_IRQ_ENABLE() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline bool get_CTRL_IRQ_ENABLE() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void set_CTRL_IRQ_ENABLE() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void clear_CTRL_IRQ_ENABLE() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void toggle_CTRL_IRQ_ENABLE() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline bool get_CTRL_ENABLE() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void set_CTRL_ENABLE() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void clear_CTRL_ENABLE() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void toggle_CTRL_ENABLE() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void get_CTRL(bool &SFTRST, bool &CLKGATE, bool &EN_REPEAT,
                         bool &BLOCK_SIZE, bool &ROT_POS, bool &VFLIP,
                         bool &HFLIP, PXP_CTRL_ROTATE &ROTATE,
                         bool &ENABLE_LCD_HANDSHAKE, bool &NEXT_IRQ_ENABLE,
                         bool &IRQ_ENABLE, bool &ENABLE) volatile
    {
        uint32_t curr = CTRL;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        EN_REPEAT = curr & (1u << 28u);
        BLOCK_SIZE = curr & (1u << 23u);
        ROT_POS = curr & (1u << 22u);
        VFLIP = curr & (1u << 11u);
        HFLIP = curr & (1u << 10u);
        ROTATE = PXP_CTRL_ROTATE((curr >> 8u) & 0b11u);
        ENABLE_LCD_HANDSHAKE = curr & (1u << 4u);
        NEXT_IRQ_ENABLE = curr & (1u << 2u);
        IRQ_ENABLE = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void set_CTRL(bool SFTRST, bool CLKGATE, bool EN_REPEAT,
                         bool BLOCK_SIZE, bool ROT_POS, bool VFLIP, bool HFLIP,
                         PXP_CTRL_ROTATE ROTATE, bool ENABLE_LCD_HANDSHAKE,
                         bool NEXT_IRQ_ENABLE, bool IRQ_ENABLE,
                         bool ENABLE) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (EN_REPEAT & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (BLOCK_SIZE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ROT_POS & 0b1u) << 22u;
        curr &= ~(0b1u << 11u);
        curr |= (VFLIP & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (HFLIP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(ROTATE) & 0b11u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (ENABLE_LCD_HANDSHAKE & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (NEXT_IRQ_ENABLE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IRQ_ENABLE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL_SET's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline bool get_CTRL_SET_SFTRST() volatile
    {
        return CTRL_SET & (1u << 31u);
    }

    /**
     * Set CTRL_SET's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void set_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET |= 1u << 31u;
    }

    /**
     * Clear CTRL_SET's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void clear_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_SET's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void toggle_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET ^= 1u << 31u;
    }

    /**
     * Get CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_SET_CLKGATE() volatile
    {
        return CTRL_SET & (1u << 30u);
    }

    /**
     * Set CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET |= 1u << 30u;
    }

    /**
     * Clear CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET ^= 1u << 30u;
    }

    /**
     * Get CTRL_SET's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline bool get_CTRL_SET_EN_REPEAT() volatile
    {
        return CTRL_SET & (1u << 28u);
    }

    /**
     * Set CTRL_SET's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void set_CTRL_SET_EN_REPEAT() volatile
    {
        CTRL_SET |= 1u << 28u;
    }

    /**
     * Clear CTRL_SET's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void clear_CTRL_SET_EN_REPEAT() volatile
    {
        CTRL_SET &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL_SET's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void toggle_CTRL_SET_EN_REPEAT() volatile
    {
        CTRL_SET ^= 1u << 28u;
    }

    /**
     * Get CTRL_SET's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline bool get_CTRL_SET_BLOCK_SIZE() volatile
    {
        return CTRL_SET & (1u << 23u);
    }

    /**
     * Set CTRL_SET's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void set_CTRL_SET_BLOCK_SIZE() volatile
    {
        CTRL_SET |= 1u << 23u;
    }

    /**
     * Clear CTRL_SET's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void clear_CTRL_SET_BLOCK_SIZE() volatile
    {
        CTRL_SET &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL_SET's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void toggle_CTRL_SET_BLOCK_SIZE() volatile
    {
        CTRL_SET ^= 1u << 23u;
    }

    /**
     * Get CTRL_SET's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline bool get_CTRL_SET_ROT_POS() volatile
    {
        return CTRL_SET & (1u << 22u);
    }

    /**
     * Set CTRL_SET's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void set_CTRL_SET_ROT_POS() volatile
    {
        CTRL_SET |= 1u << 22u;
    }

    /**
     * Clear CTRL_SET's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void clear_CTRL_SET_ROT_POS() volatile
    {
        CTRL_SET &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL_SET's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void toggle_CTRL_SET_ROT_POS() volatile
    {
        CTRL_SET ^= 1u << 22u;
    }

    /**
     * Get CTRL_SET's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline bool get_CTRL_SET_VFLIP() volatile
    {
        return CTRL_SET & (1u << 11u);
    }

    /**
     * Set CTRL_SET's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void set_CTRL_SET_VFLIP() volatile
    {
        CTRL_SET |= 1u << 11u;
    }

    /**
     * Clear CTRL_SET's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void clear_CTRL_SET_VFLIP() volatile
    {
        CTRL_SET &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_SET's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_SET_VFLIP() volatile
    {
        CTRL_SET ^= 1u << 11u;
    }

    /**
     * Get CTRL_SET's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline bool get_CTRL_SET_HFLIP() volatile
    {
        return CTRL_SET & (1u << 10u);
    }

    /**
     * Set CTRL_SET's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void set_CTRL_SET_HFLIP() volatile
    {
        CTRL_SET |= 1u << 10u;
    }

    /**
     * Clear CTRL_SET's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void clear_CTRL_SET_HFLIP() volatile
    {
        CTRL_SET &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL_SET's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_SET_HFLIP() volatile
    {
        CTRL_SET ^= 1u << 10u;
    }

    /**
     * Get CTRL_SET's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline PXP_CTRL_SET_ROTATE get_CTRL_SET_ROTATE() volatile
    {
        return PXP_CTRL_SET_ROTATE((CTRL_SET >> 8u) & 0b11u);
    }

    /**
     * Set CTRL_SET's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline void set_CTRL_SET_ROTATE(PXP_CTRL_SET_ROTATE value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline bool get_CTRL_SET_ENABLE_LCD_HANDSHAKE() volatile
    {
        return CTRL_SET & (1u << 4u);
    }

    /**
     * Set CTRL_SET's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void set_CTRL_SET_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_SET |= 1u << 4u;
    }

    /**
     * Clear CTRL_SET's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void clear_CTRL_SET_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_SET &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL_SET's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void toggle_CTRL_SET_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_SET ^= 1u << 4u;
    }

    /**
     * Get CTRL_SET's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline bool get_CTRL_SET_NEXT_IRQ_ENABLE() volatile
    {
        return CTRL_SET & (1u << 2u);
    }

    /**
     * Set CTRL_SET's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void set_CTRL_SET_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_SET |= 1u << 2u;
    }

    /**
     * Clear CTRL_SET's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void clear_CTRL_SET_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_SET &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_SET's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void toggle_CTRL_SET_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_SET ^= 1u << 2u;
    }

    /**
     * Get CTRL_SET's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline bool get_CTRL_SET_IRQ_ENABLE() volatile
    {
        return CTRL_SET & (1u << 1u);
    }

    /**
     * Set CTRL_SET's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void set_CTRL_SET_IRQ_ENABLE() volatile
    {
        CTRL_SET |= 1u << 1u;
    }

    /**
     * Clear CTRL_SET's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void clear_CTRL_SET_IRQ_ENABLE() volatile
    {
        CTRL_SET &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_SET's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void toggle_CTRL_SET_IRQ_ENABLE() volatile
    {
        CTRL_SET ^= 1u << 1u;
    }

    /**
     * Get CTRL_SET's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline bool get_CTRL_SET_ENABLE() volatile
    {
        return CTRL_SET & (1u << 0u);
    }

    /**
     * Set CTRL_SET's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void set_CTRL_SET_ENABLE() volatile
    {
        CTRL_SET |= 1u << 0u;
    }

    /**
     * Clear CTRL_SET's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void clear_CTRL_SET_ENABLE() volatile
    {
        CTRL_SET &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_SET's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void toggle_CTRL_SET_ENABLE() volatile
    {
        CTRL_SET ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_SET's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void get_CTRL_SET(bool &SFTRST, bool &CLKGATE, bool &EN_REPEAT,
                             bool &BLOCK_SIZE, bool &ROT_POS, bool &VFLIP,
                             bool &HFLIP, PXP_CTRL_SET_ROTATE &ROTATE,
                             bool &ENABLE_LCD_HANDSHAKE, bool &NEXT_IRQ_ENABLE,
                             bool &IRQ_ENABLE, bool &ENABLE) volatile
    {
        uint32_t curr = CTRL_SET;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        EN_REPEAT = curr & (1u << 28u);
        BLOCK_SIZE = curr & (1u << 23u);
        ROT_POS = curr & (1u << 22u);
        VFLIP = curr & (1u << 11u);
        HFLIP = curr & (1u << 10u);
        ROTATE = PXP_CTRL_SET_ROTATE((curr >> 8u) & 0b11u);
        ENABLE_LCD_HANDSHAKE = curr & (1u << 4u);
        NEXT_IRQ_ENABLE = curr & (1u << 2u);
        IRQ_ENABLE = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_SET's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void set_CTRL_SET(bool SFTRST, bool CLKGATE, bool EN_REPEAT,
                             bool BLOCK_SIZE, bool ROT_POS, bool VFLIP,
                             bool HFLIP, PXP_CTRL_SET_ROTATE ROTATE,
                             bool ENABLE_LCD_HANDSHAKE, bool NEXT_IRQ_ENABLE,
                             bool IRQ_ENABLE, bool ENABLE) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (EN_REPEAT & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (BLOCK_SIZE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ROT_POS & 0b1u) << 22u;
        curr &= ~(0b1u << 11u);
        curr |= (VFLIP & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (HFLIP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(ROTATE) & 0b11u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (ENABLE_LCD_HANDSHAKE & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (NEXT_IRQ_ENABLE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IRQ_ENABLE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_CLR's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline bool get_CTRL_CLR_SFTRST() volatile
    {
        return CTRL_CLR & (1u << 31u);
    }

    /**
     * Set CTRL_CLR's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void set_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR |= 1u << 31u;
    }

    /**
     * Clear CTRL_CLR's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void clear_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_CLR's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void toggle_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR ^= 1u << 31u;
    }

    /**
     * Get CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_CLR_CLKGATE() volatile
    {
        return CTRL_CLR & (1u << 30u);
    }

    /**
     * Set CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR |= 1u << 30u;
    }

    /**
     * Clear CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR ^= 1u << 30u;
    }

    /**
     * Get CTRL_CLR's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline bool get_CTRL_CLR_EN_REPEAT() volatile
    {
        return CTRL_CLR & (1u << 28u);
    }

    /**
     * Set CTRL_CLR's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void set_CTRL_CLR_EN_REPEAT() volatile
    {
        CTRL_CLR |= 1u << 28u;
    }

    /**
     * Clear CTRL_CLR's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void clear_CTRL_CLR_EN_REPEAT() volatile
    {
        CTRL_CLR &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL_CLR's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void toggle_CTRL_CLR_EN_REPEAT() volatile
    {
        CTRL_CLR ^= 1u << 28u;
    }

    /**
     * Get CTRL_CLR's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline bool get_CTRL_CLR_BLOCK_SIZE() volatile
    {
        return CTRL_CLR & (1u << 23u);
    }

    /**
     * Set CTRL_CLR's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void set_CTRL_CLR_BLOCK_SIZE() volatile
    {
        CTRL_CLR |= 1u << 23u;
    }

    /**
     * Clear CTRL_CLR's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void clear_CTRL_CLR_BLOCK_SIZE() volatile
    {
        CTRL_CLR &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL_CLR's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void toggle_CTRL_CLR_BLOCK_SIZE() volatile
    {
        CTRL_CLR ^= 1u << 23u;
    }

    /**
     * Get CTRL_CLR's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline bool get_CTRL_CLR_ROT_POS() volatile
    {
        return CTRL_CLR & (1u << 22u);
    }

    /**
     * Set CTRL_CLR's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void set_CTRL_CLR_ROT_POS() volatile
    {
        CTRL_CLR |= 1u << 22u;
    }

    /**
     * Clear CTRL_CLR's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void clear_CTRL_CLR_ROT_POS() volatile
    {
        CTRL_CLR &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL_CLR's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void toggle_CTRL_CLR_ROT_POS() volatile
    {
        CTRL_CLR ^= 1u << 22u;
    }

    /**
     * Get CTRL_CLR's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline bool get_CTRL_CLR_VFLIP() volatile
    {
        return CTRL_CLR & (1u << 11u);
    }

    /**
     * Set CTRL_CLR's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void set_CTRL_CLR_VFLIP() volatile
    {
        CTRL_CLR |= 1u << 11u;
    }

    /**
     * Clear CTRL_CLR's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void clear_CTRL_CLR_VFLIP() volatile
    {
        CTRL_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_CLR's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_CLR_VFLIP() volatile
    {
        CTRL_CLR ^= 1u << 11u;
    }

    /**
     * Get CTRL_CLR's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline bool get_CTRL_CLR_HFLIP() volatile
    {
        return CTRL_CLR & (1u << 10u);
    }

    /**
     * Set CTRL_CLR's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void set_CTRL_CLR_HFLIP() volatile
    {
        CTRL_CLR |= 1u << 10u;
    }

    /**
     * Clear CTRL_CLR's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void clear_CTRL_CLR_HFLIP() volatile
    {
        CTRL_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL_CLR's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_CLR_HFLIP() volatile
    {
        CTRL_CLR ^= 1u << 10u;
    }

    /**
     * Get CTRL_CLR's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline PXP_CTRL_CLR_ROTATE get_CTRL_CLR_ROTATE() volatile
    {
        return PXP_CTRL_CLR_ROTATE((CTRL_CLR >> 8u) & 0b11u);
    }

    /**
     * Set CTRL_CLR's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline void set_CTRL_CLR_ROTATE(PXP_CTRL_CLR_ROTATE value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline bool get_CTRL_CLR_ENABLE_LCD_HANDSHAKE() volatile
    {
        return CTRL_CLR & (1u << 4u);
    }

    /**
     * Set CTRL_CLR's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void set_CTRL_CLR_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_CLR |= 1u << 4u;
    }

    /**
     * Clear CTRL_CLR's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void clear_CTRL_CLR_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_CLR &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL_CLR's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void toggle_CTRL_CLR_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_CLR ^= 1u << 4u;
    }

    /**
     * Get CTRL_CLR's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline bool get_CTRL_CLR_NEXT_IRQ_ENABLE() volatile
    {
        return CTRL_CLR & (1u << 2u);
    }

    /**
     * Set CTRL_CLR's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void set_CTRL_CLR_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_CLR |= 1u << 2u;
    }

    /**
     * Clear CTRL_CLR's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void clear_CTRL_CLR_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_CLR's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void toggle_CTRL_CLR_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_CLR ^= 1u << 2u;
    }

    /**
     * Get CTRL_CLR's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline bool get_CTRL_CLR_IRQ_ENABLE() volatile
    {
        return CTRL_CLR & (1u << 1u);
    }

    /**
     * Set CTRL_CLR's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void set_CTRL_CLR_IRQ_ENABLE() volatile
    {
        CTRL_CLR |= 1u << 1u;
    }

    /**
     * Clear CTRL_CLR's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void clear_CTRL_CLR_IRQ_ENABLE() volatile
    {
        CTRL_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_CLR's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void toggle_CTRL_CLR_IRQ_ENABLE() volatile
    {
        CTRL_CLR ^= 1u << 1u;
    }

    /**
     * Get CTRL_CLR's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline bool get_CTRL_CLR_ENABLE() volatile
    {
        return CTRL_CLR & (1u << 0u);
    }

    /**
     * Set CTRL_CLR's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void set_CTRL_CLR_ENABLE() volatile
    {
        CTRL_CLR |= 1u << 0u;
    }

    /**
     * Clear CTRL_CLR's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void clear_CTRL_CLR_ENABLE() volatile
    {
        CTRL_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_CLR's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void toggle_CTRL_CLR_ENABLE() volatile
    {
        CTRL_CLR ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_CLR's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void get_CTRL_CLR(bool &SFTRST, bool &CLKGATE, bool &EN_REPEAT,
                             bool &BLOCK_SIZE, bool &ROT_POS, bool &VFLIP,
                             bool &HFLIP, PXP_CTRL_CLR_ROTATE &ROTATE,
                             bool &ENABLE_LCD_HANDSHAKE, bool &NEXT_IRQ_ENABLE,
                             bool &IRQ_ENABLE, bool &ENABLE) volatile
    {
        uint32_t curr = CTRL_CLR;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        EN_REPEAT = curr & (1u << 28u);
        BLOCK_SIZE = curr & (1u << 23u);
        ROT_POS = curr & (1u << 22u);
        VFLIP = curr & (1u << 11u);
        HFLIP = curr & (1u << 10u);
        ROTATE = PXP_CTRL_CLR_ROTATE((curr >> 8u) & 0b11u);
        ENABLE_LCD_HANDSHAKE = curr & (1u << 4u);
        NEXT_IRQ_ENABLE = curr & (1u << 2u);
        IRQ_ENABLE = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_CLR's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void set_CTRL_CLR(bool SFTRST, bool CLKGATE, bool EN_REPEAT,
                             bool BLOCK_SIZE, bool ROT_POS, bool VFLIP,
                             bool HFLIP, PXP_CTRL_CLR_ROTATE ROTATE,
                             bool ENABLE_LCD_HANDSHAKE, bool NEXT_IRQ_ENABLE,
                             bool IRQ_ENABLE, bool ENABLE) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (EN_REPEAT & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (BLOCK_SIZE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ROT_POS & 0b1u) << 22u;
        curr &= ~(0b1u << 11u);
        curr |= (VFLIP & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (HFLIP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(ROTATE) & 0b11u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (ENABLE_LCD_HANDSHAKE & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (NEXT_IRQ_ENABLE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IRQ_ENABLE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_TOG's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline bool get_CTRL_TOG_SFTRST() volatile
    {
        return CTRL_TOG & (1u << 31u);
    }

    /**
     * Set CTRL_TOG's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void set_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG |= 1u << 31u;
    }

    /**
     * Clear CTRL_TOG's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void clear_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_TOG's SFTRST bit.
     *
     * This bit can be turned on and then off to reset the PXP block to its
     * default state.
     */
    inline void toggle_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG ^= 1u << 31u;
    }

    /**
     * Get CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_TOG_CLKGATE() volatile
    {
        return CTRL_TOG & (1u << 30u);
    }

    /**
     * Set CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG |= 1u << 30u;
    }

    /**
     * Clear CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG ^= 1u << 30u;
    }

    /**
     * Get CTRL_TOG's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline bool get_CTRL_TOG_EN_REPEAT() volatile
    {
        return CTRL_TOG & (1u << 28u);
    }

    /**
     * Set CTRL_TOG's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void set_CTRL_TOG_EN_REPEAT() volatile
    {
        CTRL_TOG |= 1u << 28u;
    }

    /**
     * Clear CTRL_TOG's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void clear_CTRL_TOG_EN_REPEAT() volatile
    {
        CTRL_TOG &= ~(1u << 28u);
    }

    /**
     * Toggle CTRL_TOG's EN_REPEAT bit.
     *
     * Enable the PXP to run continuously
     */
    inline void toggle_CTRL_TOG_EN_REPEAT() volatile
    {
        CTRL_TOG ^= 1u << 28u;
    }

    /**
     * Get CTRL_TOG's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline bool get_CTRL_TOG_BLOCK_SIZE() volatile
    {
        return CTRL_TOG & (1u << 23u);
    }

    /**
     * Set CTRL_TOG's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void set_CTRL_TOG_BLOCK_SIZE() volatile
    {
        CTRL_TOG |= 1u << 23u;
    }

    /**
     * Clear CTRL_TOG's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void clear_CTRL_TOG_BLOCK_SIZE() volatile
    {
        CTRL_TOG &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL_TOG's BLOCK_SIZE bit.
     *
     * Select the block size to process.
     */
    inline void toggle_CTRL_TOG_BLOCK_SIZE() volatile
    {
        CTRL_TOG ^= 1u << 23u;
    }

    /**
     * Get CTRL_TOG's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline bool get_CTRL_TOG_ROT_POS() volatile
    {
        return CTRL_TOG & (1u << 22u);
    }

    /**
     * Set CTRL_TOG's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void set_CTRL_TOG_ROT_POS() volatile
    {
        CTRL_TOG |= 1u << 22u;
    }

    /**
     * Clear CTRL_TOG's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void clear_CTRL_TOG_ROT_POS() volatile
    {
        CTRL_TOG &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL_TOG's ROT_POS bit.
     *
     * This bit controls where rotation will occur in the PXP datapath
     */
    inline void toggle_CTRL_TOG_ROT_POS() volatile
    {
        CTRL_TOG ^= 1u << 22u;
    }

    /**
     * Get CTRL_TOG's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline bool get_CTRL_TOG_VFLIP() volatile
    {
        return CTRL_TOG & (1u << 11u);
    }

    /**
     * Set CTRL_TOG's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void set_CTRL_TOG_VFLIP() volatile
    {
        CTRL_TOG |= 1u << 11u;
    }

    /**
     * Clear CTRL_TOG's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void clear_CTRL_TOG_VFLIP() volatile
    {
        CTRL_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL_TOG's VFLIP bit.
     *
     * Indicates that the output buffer should be flipped vertically (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_TOG_VFLIP() volatile
    {
        CTRL_TOG ^= 1u << 11u;
    }

    /**
     * Get CTRL_TOG's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline bool get_CTRL_TOG_HFLIP() volatile
    {
        return CTRL_TOG & (1u << 10u);
    }

    /**
     * Set CTRL_TOG's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void set_CTRL_TOG_HFLIP() volatile
    {
        CTRL_TOG |= 1u << 10u;
    }

    /**
     * Clear CTRL_TOG's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void clear_CTRL_TOG_HFLIP() volatile
    {
        CTRL_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL_TOG's HFLIP bit.
     *
     * Indicates that the output buffer should be flipped horizontally (effect
     * applied before rotation).
     */
    inline void toggle_CTRL_TOG_HFLIP() volatile
    {
        CTRL_TOG ^= 1u << 10u;
    }

    /**
     * Get CTRL_TOG's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline PXP_CTRL_TOG_ROTATE get_CTRL_TOG_ROTATE() volatile
    {
        return PXP_CTRL_TOG_ROTATE((CTRL_TOG >> 8u) & 0b11u);
    }

    /**
     * Set CTRL_TOG's ROTATE field.
     *
     * Indicates the clockwise rotation to be applied at the output buffer
     */
    inline void set_CTRL_TOG_ROTATE(PXP_CTRL_TOG_ROTATE value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline bool get_CTRL_TOG_ENABLE_LCD_HANDSHAKE() volatile
    {
        return CTRL_TOG & (1u << 4u);
    }

    /**
     * Set CTRL_TOG's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void set_CTRL_TOG_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_TOG |= 1u << 4u;
    }

    /**
     * Clear CTRL_TOG's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void clear_CTRL_TOG_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_TOG &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL_TOG's ENABLE_LCD_HANDSHAKE bit.
     *
     * Enable handshake with LCD controller
     */
    inline void toggle_CTRL_TOG_ENABLE_LCD_HANDSHAKE() volatile
    {
        CTRL_TOG ^= 1u << 4u;
    }

    /**
     * Get CTRL_TOG's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline bool get_CTRL_TOG_NEXT_IRQ_ENABLE() volatile
    {
        return CTRL_TOG & (1u << 2u);
    }

    /**
     * Set CTRL_TOG's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void set_CTRL_TOG_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_TOG |= 1u << 2u;
    }

    /**
     * Clear CTRL_TOG's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void clear_CTRL_TOG_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_TOG's NEXT_IRQ_ENABLE bit.
     *
     * Next command interrupt enable
     */
    inline void toggle_CTRL_TOG_NEXT_IRQ_ENABLE() volatile
    {
        CTRL_TOG ^= 1u << 2u;
    }

    /**
     * Get CTRL_TOG's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline bool get_CTRL_TOG_IRQ_ENABLE() volatile
    {
        return CTRL_TOG & (1u << 1u);
    }

    /**
     * Set CTRL_TOG's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void set_CTRL_TOG_IRQ_ENABLE() volatile
    {
        CTRL_TOG |= 1u << 1u;
    }

    /**
     * Clear CTRL_TOG's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void clear_CTRL_TOG_IRQ_ENABLE() volatile
    {
        CTRL_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_TOG's IRQ_ENABLE bit.
     *
     * Interrupt enable When using the PXP_NEXT functionality to reprogram the
     * PXP, the new value of this bit will be used and may therefore enable or
     * disable an interrupt unintentionally
     */
    inline void toggle_CTRL_TOG_IRQ_ENABLE() volatile
    {
        CTRL_TOG ^= 1u << 1u;
    }

    /**
     * Get CTRL_TOG's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline bool get_CTRL_TOG_ENABLE() volatile
    {
        return CTRL_TOG & (1u << 0u);
    }

    /**
     * Set CTRL_TOG's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void set_CTRL_TOG_ENABLE() volatile
    {
        CTRL_TOG |= 1u << 0u;
    }

    /**
     * Clear CTRL_TOG's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void clear_CTRL_TOG_ENABLE() volatile
    {
        CTRL_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_TOG's ENABLE bit.
     *
     * Enables PXP operation with specified parameters
     */
    inline void toggle_CTRL_TOG_ENABLE() volatile
    {
        CTRL_TOG ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_TOG's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void get_CTRL_TOG(bool &SFTRST, bool &CLKGATE, bool &EN_REPEAT,
                             bool &BLOCK_SIZE, bool &ROT_POS, bool &VFLIP,
                             bool &HFLIP, PXP_CTRL_TOG_ROTATE &ROTATE,
                             bool &ENABLE_LCD_HANDSHAKE, bool &NEXT_IRQ_ENABLE,
                             bool &IRQ_ENABLE, bool &ENABLE) volatile
    {
        uint32_t curr = CTRL_TOG;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        EN_REPEAT = curr & (1u << 28u);
        BLOCK_SIZE = curr & (1u << 23u);
        ROT_POS = curr & (1u << 22u);
        VFLIP = curr & (1u << 11u);
        HFLIP = curr & (1u << 10u);
        ROTATE = PXP_CTRL_TOG_ROTATE((curr >> 8u) & 0b11u);
        ENABLE_LCD_HANDSHAKE = curr & (1u << 4u);
        NEXT_IRQ_ENABLE = curr & (1u << 2u);
        IRQ_ENABLE = curr & (1u << 1u);
        ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_TOG's bit fields.
     *
     * (read-write) Control Register 0
     */
    inline void set_CTRL_TOG(bool SFTRST, bool CLKGATE, bool EN_REPEAT,
                             bool BLOCK_SIZE, bool ROT_POS, bool VFLIP,
                             bool HFLIP, PXP_CTRL_TOG_ROTATE ROTATE,
                             bool ENABLE_LCD_HANDSHAKE, bool NEXT_IRQ_ENABLE,
                             bool IRQ_ENABLE, bool ENABLE) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 28u);
        curr |= (EN_REPEAT & 0b1u) << 28u;
        curr &= ~(0b1u << 23u);
        curr |= (BLOCK_SIZE & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (ROT_POS & 0b1u) << 22u;
        curr &= ~(0b1u << 11u);
        curr |= (VFLIP & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (HFLIP & 0b1u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(ROTATE) & 0b11u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (ENABLE_LCD_HANDSHAKE & 0b1u) << 4u;
        curr &= ~(0b1u << 2u);
        curr |= (NEXT_IRQ_ENABLE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (IRQ_ENABLE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;

        CTRL_TOG = curr;
    }

    /**
     * Get STAT's BLOCKX field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_BLOCKX() volatile
    {
        return (STAT >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT's BLOCKY field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_BLOCKY() volatile
    {
        return (STAT >> 16u) & 0b11111111u;
    }

    /**
     * Get STAT's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline bool get_STAT_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        return STAT & (1u << 8u);
    }

    /**
     * Set STAT's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void set_STAT_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT |= 1u << 8u;
    }

    /**
     * Clear STAT's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void clear_STAT_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT &= ~(1u << 8u);
    }

    /**
     * Toggle STAT's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void toggle_STAT_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT ^= 1u << 8u;
    }

    /**
     * Get STAT's AXI_ERROR_ID field.
     *
     * Indicates the AXI ID of the failing bus operation.
     */
    inline uint8_t get_STAT_AXI_ERROR_ID() volatile
    {
        return (STAT >> 4u) & 0b1111u;
    }

    /**
     * Get STAT's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline bool get_STAT_NEXT_IRQ() volatile
    {
        return STAT & (1u << 3u);
    }

    /**
     * Set STAT's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void set_STAT_NEXT_IRQ() volatile
    {
        STAT |= 1u << 3u;
    }

    /**
     * Clear STAT's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void clear_STAT_NEXT_IRQ() volatile
    {
        STAT &= ~(1u << 3u);
    }

    /**
     * Toggle STAT's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void toggle_STAT_NEXT_IRQ() volatile
    {
        STAT ^= 1u << 3u;
    }

    /**
     * Get STAT's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline bool get_STAT_AXI_READ_ERROR() volatile
    {
        return STAT & (1u << 2u);
    }

    /**
     * Set STAT's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void set_STAT_AXI_READ_ERROR() volatile
    {
        STAT |= 1u << 2u;
    }

    /**
     * Clear STAT's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void clear_STAT_AXI_READ_ERROR() volatile
    {
        STAT &= ~(1u << 2u);
    }

    /**
     * Toggle STAT's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void toggle_STAT_AXI_READ_ERROR() volatile
    {
        STAT ^= 1u << 2u;
    }

    /**
     * Get STAT's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline bool get_STAT_AXI_WRITE_ERROR() volatile
    {
        return STAT & (1u << 1u);
    }

    /**
     * Set STAT's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void set_STAT_AXI_WRITE_ERROR() volatile
    {
        STAT |= 1u << 1u;
    }

    /**
     * Clear STAT's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void clear_STAT_AXI_WRITE_ERROR() volatile
    {
        STAT &= ~(1u << 1u);
    }

    /**
     * Toggle STAT's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void toggle_STAT_AXI_WRITE_ERROR() volatile
    {
        STAT ^= 1u << 1u;
    }

    /**
     * Get STAT's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline bool get_STAT_IRQ() volatile
    {
        return STAT & (1u << 0u);
    }

    /**
     * Set STAT's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void set_STAT_IRQ() volatile
    {
        STAT |= 1u << 0u;
    }

    /**
     * Clear STAT's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void clear_STAT_IRQ() volatile
    {
        STAT &= ~(1u << 0u);
    }

    /**
     * Toggle STAT's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void toggle_STAT_IRQ() volatile
    {
        STAT ^= 1u << 0u;
    }

    /**
     * Get all of STAT's bit fields.
     *
     * (read-write) Status Register
     */
    inline void get_STAT(uint8_t &BLOCKX, uint8_t &BLOCKY,
                         bool &LUT_DMA_LOAD_DONE_IRQ, uint8_t &AXI_ERROR_ID,
                         bool &NEXT_IRQ, bool &AXI_READ_ERROR,
                         bool &AXI_WRITE_ERROR, bool &IRQ) volatile
    {
        uint32_t curr = STAT;

        BLOCKX = (curr >> 24u) & 0b11111111u;
        BLOCKY = (curr >> 16u) & 0b11111111u;
        LUT_DMA_LOAD_DONE_IRQ = curr & (1u << 8u);
        AXI_ERROR_ID = (curr >> 4u) & 0b1111u;
        NEXT_IRQ = curr & (1u << 3u);
        AXI_READ_ERROR = curr & (1u << 2u);
        AXI_WRITE_ERROR = curr & (1u << 1u);
        IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of STAT's bit fields.
     *
     * (read-write) Status Register
     */
    inline void set_STAT(bool LUT_DMA_LOAD_DONE_IRQ, bool NEXT_IRQ,
                         bool AXI_READ_ERROR, bool AXI_WRITE_ERROR,
                         bool IRQ) volatile
    {
        uint32_t curr = STAT;

        curr &= ~(0b1u << 8u);
        curr |= (LUT_DMA_LOAD_DONE_IRQ & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (NEXT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AXI_READ_ERROR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (AXI_WRITE_ERROR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IRQ & 0b1u) << 0u;

        STAT = curr;
    }

    /**
     * Get STAT_SET's BLOCKX field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_SET_BLOCKX() volatile
    {
        return (STAT_SET >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT_SET's BLOCKY field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_SET_BLOCKY() volatile
    {
        return (STAT_SET >> 16u) & 0b11111111u;
    }

    /**
     * Get STAT_SET's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline bool get_STAT_SET_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        return STAT_SET & (1u << 8u);
    }

    /**
     * Set STAT_SET's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void set_STAT_SET_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_SET |= 1u << 8u;
    }

    /**
     * Clear STAT_SET's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void clear_STAT_SET_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_SET &= ~(1u << 8u);
    }

    /**
     * Toggle STAT_SET's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void toggle_STAT_SET_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_SET ^= 1u << 8u;
    }

    /**
     * Get STAT_SET's AXI_ERROR_ID field.
     *
     * Indicates the AXI ID of the failing bus operation.
     */
    inline uint8_t get_STAT_SET_AXI_ERROR_ID() volatile
    {
        return (STAT_SET >> 4u) & 0b1111u;
    }

    /**
     * Get STAT_SET's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline bool get_STAT_SET_NEXT_IRQ() volatile
    {
        return STAT_SET & (1u << 3u);
    }

    /**
     * Set STAT_SET's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void set_STAT_SET_NEXT_IRQ() volatile
    {
        STAT_SET |= 1u << 3u;
    }

    /**
     * Clear STAT_SET's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void clear_STAT_SET_NEXT_IRQ() volatile
    {
        STAT_SET &= ~(1u << 3u);
    }

    /**
     * Toggle STAT_SET's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void toggle_STAT_SET_NEXT_IRQ() volatile
    {
        STAT_SET ^= 1u << 3u;
    }

    /**
     * Get STAT_SET's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline bool get_STAT_SET_AXI_READ_ERROR() volatile
    {
        return STAT_SET & (1u << 2u);
    }

    /**
     * Set STAT_SET's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void set_STAT_SET_AXI_READ_ERROR() volatile
    {
        STAT_SET |= 1u << 2u;
    }

    /**
     * Clear STAT_SET's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void clear_STAT_SET_AXI_READ_ERROR() volatile
    {
        STAT_SET &= ~(1u << 2u);
    }

    /**
     * Toggle STAT_SET's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void toggle_STAT_SET_AXI_READ_ERROR() volatile
    {
        STAT_SET ^= 1u << 2u;
    }

    /**
     * Get STAT_SET's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline bool get_STAT_SET_AXI_WRITE_ERROR() volatile
    {
        return STAT_SET & (1u << 1u);
    }

    /**
     * Set STAT_SET's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void set_STAT_SET_AXI_WRITE_ERROR() volatile
    {
        STAT_SET |= 1u << 1u;
    }

    /**
     * Clear STAT_SET's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void clear_STAT_SET_AXI_WRITE_ERROR() volatile
    {
        STAT_SET &= ~(1u << 1u);
    }

    /**
     * Toggle STAT_SET's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void toggle_STAT_SET_AXI_WRITE_ERROR() volatile
    {
        STAT_SET ^= 1u << 1u;
    }

    /**
     * Get STAT_SET's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline bool get_STAT_SET_IRQ() volatile
    {
        return STAT_SET & (1u << 0u);
    }

    /**
     * Set STAT_SET's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void set_STAT_SET_IRQ() volatile
    {
        STAT_SET |= 1u << 0u;
    }

    /**
     * Clear STAT_SET's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void clear_STAT_SET_IRQ() volatile
    {
        STAT_SET &= ~(1u << 0u);
    }

    /**
     * Toggle STAT_SET's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void toggle_STAT_SET_IRQ() volatile
    {
        STAT_SET ^= 1u << 0u;
    }

    /**
     * Get all of STAT_SET's bit fields.
     *
     * (read-write) Status Register
     */
    inline void get_STAT_SET(uint8_t &BLOCKX, uint8_t &BLOCKY,
                             bool &LUT_DMA_LOAD_DONE_IRQ,
                             uint8_t &AXI_ERROR_ID, bool &NEXT_IRQ,
                             bool &AXI_READ_ERROR, bool &AXI_WRITE_ERROR,
                             bool &IRQ) volatile
    {
        uint32_t curr = STAT_SET;

        BLOCKX = (curr >> 24u) & 0b11111111u;
        BLOCKY = (curr >> 16u) & 0b11111111u;
        LUT_DMA_LOAD_DONE_IRQ = curr & (1u << 8u);
        AXI_ERROR_ID = (curr >> 4u) & 0b1111u;
        NEXT_IRQ = curr & (1u << 3u);
        AXI_READ_ERROR = curr & (1u << 2u);
        AXI_WRITE_ERROR = curr & (1u << 1u);
        IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of STAT_SET's bit fields.
     *
     * (read-write) Status Register
     */
    inline void set_STAT_SET(bool LUT_DMA_LOAD_DONE_IRQ, bool NEXT_IRQ,
                             bool AXI_READ_ERROR, bool AXI_WRITE_ERROR,
                             bool IRQ) volatile
    {
        uint32_t curr = STAT_SET;

        curr &= ~(0b1u << 8u);
        curr |= (LUT_DMA_LOAD_DONE_IRQ & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (NEXT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AXI_READ_ERROR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (AXI_WRITE_ERROR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IRQ & 0b1u) << 0u;

        STAT_SET = curr;
    }

    /**
     * Get STAT_CLR's BLOCKX field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_CLR_BLOCKX() volatile
    {
        return (STAT_CLR >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT_CLR's BLOCKY field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_CLR_BLOCKY() volatile
    {
        return (STAT_CLR >> 16u) & 0b11111111u;
    }

    /**
     * Get STAT_CLR's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline bool get_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        return STAT_CLR & (1u << 8u);
    }

    /**
     * Set STAT_CLR's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void set_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_CLR |= 1u << 8u;
    }

    /**
     * Clear STAT_CLR's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void clear_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_CLR &= ~(1u << 8u);
    }

    /**
     * Toggle STAT_CLR's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void toggle_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_CLR ^= 1u << 8u;
    }

    /**
     * Get STAT_CLR's AXI_ERROR_ID field.
     *
     * Indicates the AXI ID of the failing bus operation.
     */
    inline uint8_t get_STAT_CLR_AXI_ERROR_ID() volatile
    {
        return (STAT_CLR >> 4u) & 0b1111u;
    }

    /**
     * Get STAT_CLR's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline bool get_STAT_CLR_NEXT_IRQ() volatile
    {
        return STAT_CLR & (1u << 3u);
    }

    /**
     * Set STAT_CLR's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void set_STAT_CLR_NEXT_IRQ() volatile
    {
        STAT_CLR |= 1u << 3u;
    }

    /**
     * Clear STAT_CLR's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void clear_STAT_CLR_NEXT_IRQ() volatile
    {
        STAT_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle STAT_CLR's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void toggle_STAT_CLR_NEXT_IRQ() volatile
    {
        STAT_CLR ^= 1u << 3u;
    }

    /**
     * Get STAT_CLR's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline bool get_STAT_CLR_AXI_READ_ERROR() volatile
    {
        return STAT_CLR & (1u << 2u);
    }

    /**
     * Set STAT_CLR's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void set_STAT_CLR_AXI_READ_ERROR() volatile
    {
        STAT_CLR |= 1u << 2u;
    }

    /**
     * Clear STAT_CLR's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void clear_STAT_CLR_AXI_READ_ERROR() volatile
    {
        STAT_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle STAT_CLR's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void toggle_STAT_CLR_AXI_READ_ERROR() volatile
    {
        STAT_CLR ^= 1u << 2u;
    }

    /**
     * Get STAT_CLR's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline bool get_STAT_CLR_AXI_WRITE_ERROR() volatile
    {
        return STAT_CLR & (1u << 1u);
    }

    /**
     * Set STAT_CLR's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void set_STAT_CLR_AXI_WRITE_ERROR() volatile
    {
        STAT_CLR |= 1u << 1u;
    }

    /**
     * Clear STAT_CLR's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void clear_STAT_CLR_AXI_WRITE_ERROR() volatile
    {
        STAT_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle STAT_CLR's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void toggle_STAT_CLR_AXI_WRITE_ERROR() volatile
    {
        STAT_CLR ^= 1u << 1u;
    }

    /**
     * Get STAT_CLR's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline bool get_STAT_CLR_IRQ() volatile
    {
        return STAT_CLR & (1u << 0u);
    }

    /**
     * Set STAT_CLR's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void set_STAT_CLR_IRQ() volatile
    {
        STAT_CLR |= 1u << 0u;
    }

    /**
     * Clear STAT_CLR's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void clear_STAT_CLR_IRQ() volatile
    {
        STAT_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle STAT_CLR's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void toggle_STAT_CLR_IRQ() volatile
    {
        STAT_CLR ^= 1u << 0u;
    }

    /**
     * Get all of STAT_CLR's bit fields.
     *
     * (read-write) Status Register
     */
    inline void get_STAT_CLR(uint8_t &BLOCKX, uint8_t &BLOCKY,
                             bool &LUT_DMA_LOAD_DONE_IRQ,
                             uint8_t &AXI_ERROR_ID, bool &NEXT_IRQ,
                             bool &AXI_READ_ERROR, bool &AXI_WRITE_ERROR,
                             bool &IRQ) volatile
    {
        uint32_t curr = STAT_CLR;

        BLOCKX = (curr >> 24u) & 0b11111111u;
        BLOCKY = (curr >> 16u) & 0b11111111u;
        LUT_DMA_LOAD_DONE_IRQ = curr & (1u << 8u);
        AXI_ERROR_ID = (curr >> 4u) & 0b1111u;
        NEXT_IRQ = curr & (1u << 3u);
        AXI_READ_ERROR = curr & (1u << 2u);
        AXI_WRITE_ERROR = curr & (1u << 1u);
        IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of STAT_CLR's bit fields.
     *
     * (read-write) Status Register
     */
    inline void set_STAT_CLR(bool LUT_DMA_LOAD_DONE_IRQ, bool NEXT_IRQ,
                             bool AXI_READ_ERROR, bool AXI_WRITE_ERROR,
                             bool IRQ) volatile
    {
        uint32_t curr = STAT_CLR;

        curr &= ~(0b1u << 8u);
        curr |= (LUT_DMA_LOAD_DONE_IRQ & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (NEXT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AXI_READ_ERROR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (AXI_WRITE_ERROR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IRQ & 0b1u) << 0u;

        STAT_CLR = curr;
    }

    /**
     * Get STAT_TOG's BLOCKX field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_TOG_BLOCKX() volatile
    {
        return (STAT_TOG >> 24u) & 0b11111111u;
    }

    /**
     * Get STAT_TOG's BLOCKY field.
     *
     * Indicates the X coordinate of the block currently being rendered.
     */
    inline uint8_t get_STAT_TOG_BLOCKY() volatile
    {
        return (STAT_TOG >> 16u) & 0b11111111u;
    }

    /**
     * Get STAT_TOG's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline bool get_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        return STAT_TOG & (1u << 8u);
    }

    /**
     * Set STAT_TOG's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void set_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_TOG |= 1u << 8u;
    }

    /**
     * Clear STAT_TOG's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void clear_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_TOG &= ~(1u << 8u);
    }

    /**
     * Toggle STAT_TOG's LUT_DMA_LOAD_DONE_IRQ bit.
     *
     * Indicates that the LUT DMA transfer has completed.
     */
    inline void toggle_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ() volatile
    {
        STAT_TOG ^= 1u << 8u;
    }

    /**
     * Get STAT_TOG's AXI_ERROR_ID field.
     *
     * Indicates the AXI ID of the failing bus operation.
     */
    inline uint8_t get_STAT_TOG_AXI_ERROR_ID() volatile
    {
        return (STAT_TOG >> 4u) & 0b1111u;
    }

    /**
     * Get STAT_TOG's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline bool get_STAT_TOG_NEXT_IRQ() volatile
    {
        return STAT_TOG & (1u << 3u);
    }

    /**
     * Set STAT_TOG's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void set_STAT_TOG_NEXT_IRQ() volatile
    {
        STAT_TOG |= 1u << 3u;
    }

    /**
     * Clear STAT_TOG's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void clear_STAT_TOG_NEXT_IRQ() volatile
    {
        STAT_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle STAT_TOG's NEXT_IRQ bit.
     *
     * Indicates that a command issued with the "Next Command" functionality
     * has been issued and that a new command may be initiated with a write to
     * the PXP_NEXT register
     */
    inline void toggle_STAT_TOG_NEXT_IRQ() volatile
    {
        STAT_TOG ^= 1u << 3u;
    }

    /**
     * Get STAT_TOG's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline bool get_STAT_TOG_AXI_READ_ERROR() volatile
    {
        return STAT_TOG & (1u << 2u);
    }

    /**
     * Set STAT_TOG's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void set_STAT_TOG_AXI_READ_ERROR() volatile
    {
        STAT_TOG |= 1u << 2u;
    }

    /**
     * Clear STAT_TOG's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void clear_STAT_TOG_AXI_READ_ERROR() volatile
    {
        STAT_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle STAT_TOG's AXI_READ_ERROR bit.
     *
     * Indicates PXP encountered an AXI read error and processing has been
     * terminated.
     */
    inline void toggle_STAT_TOG_AXI_READ_ERROR() volatile
    {
        STAT_TOG ^= 1u << 2u;
    }

    /**
     * Get STAT_TOG's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline bool get_STAT_TOG_AXI_WRITE_ERROR() volatile
    {
        return STAT_TOG & (1u << 1u);
    }

    /**
     * Set STAT_TOG's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void set_STAT_TOG_AXI_WRITE_ERROR() volatile
    {
        STAT_TOG |= 1u << 1u;
    }

    /**
     * Clear STAT_TOG's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void clear_STAT_TOG_AXI_WRITE_ERROR() volatile
    {
        STAT_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle STAT_TOG's AXI_WRITE_ERROR bit.
     *
     * Indicates PXP encountered an AXI write error and processing has been
     * terminated.
     */
    inline void toggle_STAT_TOG_AXI_WRITE_ERROR() volatile
    {
        STAT_TOG ^= 1u << 1u;
    }

    /**
     * Get STAT_TOG's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline bool get_STAT_TOG_IRQ() volatile
    {
        return STAT_TOG & (1u << 0u);
    }

    /**
     * Set STAT_TOG's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void set_STAT_TOG_IRQ() volatile
    {
        STAT_TOG |= 1u << 0u;
    }

    /**
     * Clear STAT_TOG's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void clear_STAT_TOG_IRQ() volatile
    {
        STAT_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle STAT_TOG's IRQ bit.
     *
     * Indicates current PXP interrupt status
     */
    inline void toggle_STAT_TOG_IRQ() volatile
    {
        STAT_TOG ^= 1u << 0u;
    }

    /**
     * Get all of STAT_TOG's bit fields.
     *
     * (read-write) Status Register
     */
    inline void get_STAT_TOG(uint8_t &BLOCKX, uint8_t &BLOCKY,
                             bool &LUT_DMA_LOAD_DONE_IRQ,
                             uint8_t &AXI_ERROR_ID, bool &NEXT_IRQ,
                             bool &AXI_READ_ERROR, bool &AXI_WRITE_ERROR,
                             bool &IRQ) volatile
    {
        uint32_t curr = STAT_TOG;

        BLOCKX = (curr >> 24u) & 0b11111111u;
        BLOCKY = (curr >> 16u) & 0b11111111u;
        LUT_DMA_LOAD_DONE_IRQ = curr & (1u << 8u);
        AXI_ERROR_ID = (curr >> 4u) & 0b1111u;
        NEXT_IRQ = curr & (1u << 3u);
        AXI_READ_ERROR = curr & (1u << 2u);
        AXI_WRITE_ERROR = curr & (1u << 1u);
        IRQ = curr & (1u << 0u);
    }

    /**
     * Set all of STAT_TOG's bit fields.
     *
     * (read-write) Status Register
     */
    inline void set_STAT_TOG(bool LUT_DMA_LOAD_DONE_IRQ, bool NEXT_IRQ,
                             bool AXI_READ_ERROR, bool AXI_WRITE_ERROR,
                             bool IRQ) volatile
    {
        uint32_t curr = STAT_TOG;

        curr &= ~(0b1u << 8u);
        curr |= (LUT_DMA_LOAD_DONE_IRQ & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (NEXT_IRQ & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (AXI_READ_ERROR & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (AXI_WRITE_ERROR & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IRQ & 0b1u) << 0u;

        STAT_TOG = curr;
    }

    /**
     * Get OUT_CTRL's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline uint8_t get_OUT_CTRL_ALPHA() volatile
    {
        return (OUT_CTRL >> 24u) & 0b11111111u;
    }

    /**
     * Set OUT_CTRL's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline void set_OUT_CTRL_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = OUT_CTRL;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        OUT_CTRL = curr;
    }

    /**
     * Get OUT_CTRL's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline bool get_OUT_CTRL_ALPHA_OUTPUT() volatile
    {
        return OUT_CTRL & (1u << 23u);
    }

    /**
     * Set OUT_CTRL's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void set_OUT_CTRL_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL |= 1u << 23u;
    }

    /**
     * Clear OUT_CTRL's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void clear_OUT_CTRL_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_CTRL's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void toggle_OUT_CTRL_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL ^= 1u << 23u;
    }

    /**
     * Get OUT_CTRL's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline PXP_OUT_CTRL_INTERLACED_OUTPUT
    get_OUT_CTRL_INTERLACED_OUTPUT() volatile
    {
        return PXP_OUT_CTRL_INTERLACED_OUTPUT((OUT_CTRL >> 8u) & 0b11u);
    }

    /**
     * Set OUT_CTRL's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline void set_OUT_CTRL_INTERLACED_OUTPUT(
        PXP_OUT_CTRL_INTERLACED_OUTPUT value) volatile
    {
        uint32_t curr = OUT_CTRL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        OUT_CTRL = curr;
    }

    /**
     * Get OUT_CTRL's FORMAT field.
     *
     * Output framebuffer format
     */
    inline PXP_OUT_CTRL_FORMAT get_OUT_CTRL_FORMAT() volatile
    {
        return PXP_OUT_CTRL_FORMAT((OUT_CTRL >> 0u) & 0b11111u);
    }

    /**
     * Set OUT_CTRL's FORMAT field.
     *
     * Output framebuffer format
     */
    inline void set_OUT_CTRL_FORMAT(PXP_OUT_CTRL_FORMAT value) volatile
    {
        uint32_t curr = OUT_CTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        OUT_CTRL = curr;
    }

    /**
     * Get all of OUT_CTRL's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void get_OUT_CTRL(uint8_t &ALPHA, bool &ALPHA_OUTPUT,
                             PXP_OUT_CTRL_INTERLACED_OUTPUT &INTERLACED_OUTPUT,
                             PXP_OUT_CTRL_FORMAT &FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL;

        ALPHA = (curr >> 24u) & 0b11111111u;
        ALPHA_OUTPUT = curr & (1u << 23u);
        INTERLACED_OUTPUT =
            PXP_OUT_CTRL_INTERLACED_OUTPUT((curr >> 8u) & 0b11u);
        FORMAT = PXP_OUT_CTRL_FORMAT((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of OUT_CTRL's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void set_OUT_CTRL(uint8_t ALPHA, bool ALPHA_OUTPUT,
                             PXP_OUT_CTRL_INTERLACED_OUTPUT INTERLACED_OUTPUT,
                             PXP_OUT_CTRL_FORMAT FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL;

        curr &= ~(0b11111111u << 24u);
        curr |= (ALPHA & 0b11111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ALPHA_OUTPUT & 0b1u) << 23u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(INTERLACED_OUTPUT) & 0b11u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b11111u) << 0u;

        OUT_CTRL = curr;
    }

    /**
     * Get OUT_CTRL_SET's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline uint8_t get_OUT_CTRL_SET_ALPHA() volatile
    {
        return (OUT_CTRL_SET >> 24u) & 0b11111111u;
    }

    /**
     * Set OUT_CTRL_SET's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline void set_OUT_CTRL_SET_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = OUT_CTRL_SET;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        OUT_CTRL_SET = curr;
    }

    /**
     * Get OUT_CTRL_SET's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline bool get_OUT_CTRL_SET_ALPHA_OUTPUT() volatile
    {
        return OUT_CTRL_SET & (1u << 23u);
    }

    /**
     * Set OUT_CTRL_SET's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void set_OUT_CTRL_SET_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_SET |= 1u << 23u;
    }

    /**
     * Clear OUT_CTRL_SET's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void clear_OUT_CTRL_SET_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_SET &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_CTRL_SET's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void toggle_OUT_CTRL_SET_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_SET ^= 1u << 23u;
    }

    /**
     * Get OUT_CTRL_SET's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline PXP_OUT_CTRL_SET_INTERLACED_OUTPUT
    get_OUT_CTRL_SET_INTERLACED_OUTPUT() volatile
    {
        return PXP_OUT_CTRL_SET_INTERLACED_OUTPUT((OUT_CTRL_SET >> 8u) &
                                                  0b11u);
    }

    /**
     * Set OUT_CTRL_SET's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline void set_OUT_CTRL_SET_INTERLACED_OUTPUT(
        PXP_OUT_CTRL_SET_INTERLACED_OUTPUT value) volatile
    {
        uint32_t curr = OUT_CTRL_SET;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        OUT_CTRL_SET = curr;
    }

    /**
     * Get OUT_CTRL_SET's FORMAT field.
     *
     * Output framebuffer format
     */
    inline PXP_OUT_CTRL_SET_FORMAT get_OUT_CTRL_SET_FORMAT() volatile
    {
        return PXP_OUT_CTRL_SET_FORMAT((OUT_CTRL_SET >> 0u) & 0b11111u);
    }

    /**
     * Set OUT_CTRL_SET's FORMAT field.
     *
     * Output framebuffer format
     */
    inline void set_OUT_CTRL_SET_FORMAT(PXP_OUT_CTRL_SET_FORMAT value) volatile
    {
        uint32_t curr = OUT_CTRL_SET;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        OUT_CTRL_SET = curr;
    }

    /**
     * Get all of OUT_CTRL_SET's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void get_OUT_CTRL_SET(
        uint8_t &ALPHA, bool &ALPHA_OUTPUT,
        PXP_OUT_CTRL_SET_INTERLACED_OUTPUT &INTERLACED_OUTPUT,
        PXP_OUT_CTRL_SET_FORMAT &FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL_SET;

        ALPHA = (curr >> 24u) & 0b11111111u;
        ALPHA_OUTPUT = curr & (1u << 23u);
        INTERLACED_OUTPUT =
            PXP_OUT_CTRL_SET_INTERLACED_OUTPUT((curr >> 8u) & 0b11u);
        FORMAT = PXP_OUT_CTRL_SET_FORMAT((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of OUT_CTRL_SET's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void set_OUT_CTRL_SET(
        uint8_t ALPHA, bool ALPHA_OUTPUT,
        PXP_OUT_CTRL_SET_INTERLACED_OUTPUT INTERLACED_OUTPUT,
        PXP_OUT_CTRL_SET_FORMAT FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL_SET;

        curr &= ~(0b11111111u << 24u);
        curr |= (ALPHA & 0b11111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ALPHA_OUTPUT & 0b1u) << 23u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(INTERLACED_OUTPUT) & 0b11u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b11111u) << 0u;

        OUT_CTRL_SET = curr;
    }

    /**
     * Get OUT_CTRL_CLR's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline uint8_t get_OUT_CTRL_CLR_ALPHA() volatile
    {
        return (OUT_CTRL_CLR >> 24u) & 0b11111111u;
    }

    /**
     * Set OUT_CTRL_CLR's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline void set_OUT_CTRL_CLR_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = OUT_CTRL_CLR;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        OUT_CTRL_CLR = curr;
    }

    /**
     * Get OUT_CTRL_CLR's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline bool get_OUT_CTRL_CLR_ALPHA_OUTPUT() volatile
    {
        return OUT_CTRL_CLR & (1u << 23u);
    }

    /**
     * Set OUT_CTRL_CLR's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void set_OUT_CTRL_CLR_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_CLR |= 1u << 23u;
    }

    /**
     * Clear OUT_CTRL_CLR's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void clear_OUT_CTRL_CLR_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_CLR &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_CTRL_CLR's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void toggle_OUT_CTRL_CLR_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_CLR ^= 1u << 23u;
    }

    /**
     * Get OUT_CTRL_CLR's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT
    get_OUT_CTRL_CLR_INTERLACED_OUTPUT() volatile
    {
        return PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT((OUT_CTRL_CLR >> 8u) &
                                                  0b11u);
    }

    /**
     * Set OUT_CTRL_CLR's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline void set_OUT_CTRL_CLR_INTERLACED_OUTPUT(
        PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT value) volatile
    {
        uint32_t curr = OUT_CTRL_CLR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        OUT_CTRL_CLR = curr;
    }

    /**
     * Get OUT_CTRL_CLR's FORMAT field.
     *
     * Output framebuffer format
     */
    inline PXP_OUT_CTRL_CLR_FORMAT get_OUT_CTRL_CLR_FORMAT() volatile
    {
        return PXP_OUT_CTRL_CLR_FORMAT((OUT_CTRL_CLR >> 0u) & 0b11111u);
    }

    /**
     * Set OUT_CTRL_CLR's FORMAT field.
     *
     * Output framebuffer format
     */
    inline void set_OUT_CTRL_CLR_FORMAT(PXP_OUT_CTRL_CLR_FORMAT value) volatile
    {
        uint32_t curr = OUT_CTRL_CLR;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        OUT_CTRL_CLR = curr;
    }

    /**
     * Get all of OUT_CTRL_CLR's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void get_OUT_CTRL_CLR(
        uint8_t &ALPHA, bool &ALPHA_OUTPUT,
        PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT &INTERLACED_OUTPUT,
        PXP_OUT_CTRL_CLR_FORMAT &FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL_CLR;

        ALPHA = (curr >> 24u) & 0b11111111u;
        ALPHA_OUTPUT = curr & (1u << 23u);
        INTERLACED_OUTPUT =
            PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT((curr >> 8u) & 0b11u);
        FORMAT = PXP_OUT_CTRL_CLR_FORMAT((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of OUT_CTRL_CLR's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void set_OUT_CTRL_CLR(
        uint8_t ALPHA, bool ALPHA_OUTPUT,
        PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT INTERLACED_OUTPUT,
        PXP_OUT_CTRL_CLR_FORMAT FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL_CLR;

        curr &= ~(0b11111111u << 24u);
        curr |= (ALPHA & 0b11111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ALPHA_OUTPUT & 0b1u) << 23u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(INTERLACED_OUTPUT) & 0b11u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b11111u) << 0u;

        OUT_CTRL_CLR = curr;
    }

    /**
     * Get OUT_CTRL_TOG's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline uint8_t get_OUT_CTRL_TOG_ALPHA() volatile
    {
        return (OUT_CTRL_TOG >> 24u) & 0b11111111u;
    }

    /**
     * Set OUT_CTRL_TOG's ALPHA field.
     *
     * When generating an output buffer with an alpha component, the value in
     * this field will be used when enabled to override the alpha passed
     * through the pixel data pipeline
     */
    inline void set_OUT_CTRL_TOG_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = OUT_CTRL_TOG;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        OUT_CTRL_TOG = curr;
    }

    /**
     * Get OUT_CTRL_TOG's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline bool get_OUT_CTRL_TOG_ALPHA_OUTPUT() volatile
    {
        return OUT_CTRL_TOG & (1u << 23u);
    }

    /**
     * Set OUT_CTRL_TOG's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void set_OUT_CTRL_TOG_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_TOG |= 1u << 23u;
    }

    /**
     * Clear OUT_CTRL_TOG's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void clear_OUT_CTRL_TOG_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_TOG &= ~(1u << 23u);
    }

    /**
     * Toggle OUT_CTRL_TOG's ALPHA_OUTPUT bit.
     *
     * Indicates that alpha component in output buffer pixels should be
     * overwritten by PXP_OUT_CTRL[ALPHA]
     */
    inline void toggle_OUT_CTRL_TOG_ALPHA_OUTPUT() volatile
    {
        OUT_CTRL_TOG ^= 1u << 23u;
    }

    /**
     * Get OUT_CTRL_TOG's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT
    get_OUT_CTRL_TOG_INTERLACED_OUTPUT() volatile
    {
        return PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT((OUT_CTRL_TOG >> 8u) &
                                                  0b11u);
    }

    /**
     * Set OUT_CTRL_TOG's INTERLACED_OUTPUT field.
     *
     * Determines how the PXP writes it's output data
     */
    inline void set_OUT_CTRL_TOG_INTERLACED_OUTPUT(
        PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT value) volatile
    {
        uint32_t curr = OUT_CTRL_TOG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        OUT_CTRL_TOG = curr;
    }

    /**
     * Get OUT_CTRL_TOG's FORMAT field.
     *
     * Output framebuffer format
     */
    inline PXP_OUT_CTRL_TOG_FORMAT get_OUT_CTRL_TOG_FORMAT() volatile
    {
        return PXP_OUT_CTRL_TOG_FORMAT((OUT_CTRL_TOG >> 0u) & 0b11111u);
    }

    /**
     * Set OUT_CTRL_TOG's FORMAT field.
     *
     * Output framebuffer format
     */
    inline void set_OUT_CTRL_TOG_FORMAT(PXP_OUT_CTRL_TOG_FORMAT value) volatile
    {
        uint32_t curr = OUT_CTRL_TOG;

        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111u) << 0u;

        OUT_CTRL_TOG = curr;
    }

    /**
     * Get all of OUT_CTRL_TOG's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void get_OUT_CTRL_TOG(
        uint8_t &ALPHA, bool &ALPHA_OUTPUT,
        PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT &INTERLACED_OUTPUT,
        PXP_OUT_CTRL_TOG_FORMAT &FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL_TOG;

        ALPHA = (curr >> 24u) & 0b11111111u;
        ALPHA_OUTPUT = curr & (1u << 23u);
        INTERLACED_OUTPUT =
            PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT((curr >> 8u) & 0b11u);
        FORMAT = PXP_OUT_CTRL_TOG_FORMAT((curr >> 0u) & 0b11111u);
    }

    /**
     * Set all of OUT_CTRL_TOG's bit fields.
     *
     * (read-write) Output Buffer Control Register
     */
    inline void set_OUT_CTRL_TOG(
        uint8_t ALPHA, bool ALPHA_OUTPUT,
        PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT INTERLACED_OUTPUT,
        PXP_OUT_CTRL_TOG_FORMAT FORMAT) volatile
    {
        uint32_t curr = OUT_CTRL_TOG;

        curr &= ~(0b11111111u << 24u);
        curr |= (ALPHA & 0b11111111u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (ALPHA_OUTPUT & 0b1u) << 23u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(INTERLACED_OUTPUT) & 0b11u) << 8u;
        curr &= ~(0b11111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b11111u) << 0u;

        OUT_CTRL_TOG = curr;
    }

    /**
     * Get OUT_BUF's ADDR field.
     *
     * Current address pointer for the output frame buffer
     */
    inline uint32_t get_OUT_BUF_ADDR() volatile
    {
        return (OUT_BUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set OUT_BUF's ADDR field.
     *
     * Current address pointer for the output frame buffer
     */
    inline void set_OUT_BUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = OUT_BUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        OUT_BUF = curr;
    }

    /**
     * Get OUT_BUF2's ADDR field.
     *
     * Current address pointer for the output frame buffer
     */
    inline uint32_t get_OUT_BUF2_ADDR() volatile
    {
        return (OUT_BUF2 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set OUT_BUF2's ADDR field.
     *
     * Current address pointer for the output frame buffer
     */
    inline void set_OUT_BUF2_ADDR(uint32_t value) volatile
    {
        uint32_t curr = OUT_BUF2;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        OUT_BUF2 = curr;
    }

    /**
     * Get OUT_PITCH's PITCH field.
     *
     * Indicates the number of bytes in memory between two vertically adjacent
     * pixels.
     */
    inline uint16_t get_OUT_PITCH_PITCH() volatile
    {
        return (OUT_PITCH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set OUT_PITCH's PITCH field.
     *
     * Indicates the number of bytes in memory between two vertically adjacent
     * pixels.
     */
    inline void set_OUT_PITCH_PITCH(uint16_t value) volatile
    {
        uint32_t curr = OUT_PITCH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        OUT_PITCH = curr;
    }

    /**
     * Get OUT_LRC's X field.
     *
     * Indicates number of horizontal PIXELS in the output surface
     * (non-rotated)
     */
    inline uint16_t get_OUT_LRC_X() volatile
    {
        return (OUT_LRC >> 16u) & 0b11111111111111u;
    }

    /**
     * Set OUT_LRC's X field.
     *
     * Indicates number of horizontal PIXELS in the output surface
     * (non-rotated)
     */
    inline void set_OUT_LRC_X(uint16_t value) volatile
    {
        uint32_t curr = OUT_LRC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (value & 0b11111111111111u) << 16u;

        OUT_LRC = curr;
    }

    /**
     * Get OUT_LRC's Y field.
     *
     * Indicates the number of vertical PIXELS in the output surface
     * (non-rotated)
     */
    inline uint16_t get_OUT_LRC_Y() volatile
    {
        return (OUT_LRC >> 0u) & 0b11111111111111u;
    }

    /**
     * Set OUT_LRC's Y field.
     *
     * Indicates the number of vertical PIXELS in the output surface
     * (non-rotated)
     */
    inline void set_OUT_LRC_Y(uint16_t value) volatile
    {
        uint32_t curr = OUT_LRC;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        OUT_LRC = curr;
    }

    /**
     * Get all of OUT_LRC's bit fields.
     *
     * (read-write) Output Surface Lower Right Coordinate
     */
    inline void get_OUT_LRC(uint16_t &X, uint16_t &Y) volatile
    {
        uint32_t curr = OUT_LRC;

        X = (curr >> 16u) & 0b11111111111111u;
        Y = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Set all of OUT_LRC's bit fields.
     *
     * (read-write) Output Surface Lower Right Coordinate
     */
    inline void set_OUT_LRC(uint16_t X, uint16_t Y) volatile
    {
        uint32_t curr = OUT_LRC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (X & 0b11111111111111u) << 16u;
        curr &= ~(0b11111111111111u << 0u);
        curr |= (Y & 0b11111111111111u) << 0u;

        OUT_LRC = curr;
    }

    /**
     * Get OUT_PS_ULC's X field.
     *
     * This field indicates the upper left X-coordinate (in pixels) of the
     * processed surface (PS) in the output buffer
     */
    inline uint16_t get_OUT_PS_ULC_X() volatile
    {
        return (OUT_PS_ULC >> 16u) & 0b11111111111111u;
    }

    /**
     * Set OUT_PS_ULC's X field.
     *
     * This field indicates the upper left X-coordinate (in pixels) of the
     * processed surface (PS) in the output buffer
     */
    inline void set_OUT_PS_ULC_X(uint16_t value) volatile
    {
        uint32_t curr = OUT_PS_ULC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (value & 0b11111111111111u) << 16u;

        OUT_PS_ULC = curr;
    }

    /**
     * Get OUT_PS_ULC's Y field.
     *
     * This field indicates the upper left Y-coordinate (in pixels) of the
     * processed surface in the output buffer
     */
    inline uint16_t get_OUT_PS_ULC_Y() volatile
    {
        return (OUT_PS_ULC >> 0u) & 0b11111111111111u;
    }

    /**
     * Set OUT_PS_ULC's Y field.
     *
     * This field indicates the upper left Y-coordinate (in pixels) of the
     * processed surface in the output buffer
     */
    inline void set_OUT_PS_ULC_Y(uint16_t value) volatile
    {
        uint32_t curr = OUT_PS_ULC;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        OUT_PS_ULC = curr;
    }

    /**
     * Get all of OUT_PS_ULC's bit fields.
     *
     * (read-write) Processed Surface Upper Left Coordinate
     */
    inline void get_OUT_PS_ULC(uint16_t &X, uint16_t &Y) volatile
    {
        uint32_t curr = OUT_PS_ULC;

        X = (curr >> 16u) & 0b11111111111111u;
        Y = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Set all of OUT_PS_ULC's bit fields.
     *
     * (read-write) Processed Surface Upper Left Coordinate
     */
    inline void set_OUT_PS_ULC(uint16_t X, uint16_t Y) volatile
    {
        uint32_t curr = OUT_PS_ULC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (X & 0b11111111111111u) << 16u;
        curr &= ~(0b11111111111111u << 0u);
        curr |= (Y & 0b11111111111111u) << 0u;

        OUT_PS_ULC = curr;
    }

    /**
     * Get OUT_PS_LRC's X field.
     *
     * This field indicates the lower right X-coordinate (in pixels) of the
     * processed surface (PS) in the output frame buffer
     */
    inline uint16_t get_OUT_PS_LRC_X() volatile
    {
        return (OUT_PS_LRC >> 16u) & 0b11111111111111u;
    }

    /**
     * Set OUT_PS_LRC's X field.
     *
     * This field indicates the lower right X-coordinate (in pixels) of the
     * processed surface (PS) in the output frame buffer
     */
    inline void set_OUT_PS_LRC_X(uint16_t value) volatile
    {
        uint32_t curr = OUT_PS_LRC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (value & 0b11111111111111u) << 16u;

        OUT_PS_LRC = curr;
    }

    /**
     * Get OUT_PS_LRC's Y field.
     *
     * This field indicates the lower right Y-coordinate (in pixels) of the
     * processed surface in the output frame buffer
     */
    inline uint16_t get_OUT_PS_LRC_Y() volatile
    {
        return (OUT_PS_LRC >> 0u) & 0b11111111111111u;
    }

    /**
     * Set OUT_PS_LRC's Y field.
     *
     * This field indicates the lower right Y-coordinate (in pixels) of the
     * processed surface in the output frame buffer
     */
    inline void set_OUT_PS_LRC_Y(uint16_t value) volatile
    {
        uint32_t curr = OUT_PS_LRC;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        OUT_PS_LRC = curr;
    }

    /**
     * Get all of OUT_PS_LRC's bit fields.
     *
     * (read-write) Processed Surface Lower Right Coordinate
     */
    inline void get_OUT_PS_LRC(uint16_t &X, uint16_t &Y) volatile
    {
        uint32_t curr = OUT_PS_LRC;

        X = (curr >> 16u) & 0b11111111111111u;
        Y = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Set all of OUT_PS_LRC's bit fields.
     *
     * (read-write) Processed Surface Lower Right Coordinate
     */
    inline void set_OUT_PS_LRC(uint16_t X, uint16_t Y) volatile
    {
        uint32_t curr = OUT_PS_LRC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (X & 0b11111111111111u) << 16u;
        curr &= ~(0b11111111111111u << 0u);
        curr |= (Y & 0b11111111111111u) << 0u;

        OUT_PS_LRC = curr;
    }

    /**
     * Get OUT_AS_ULC's X field.
     *
     * This field indicates the upper left X-coordinate (in pixels) of the
     * alpha surface (AS) in the output frame buffer
     */
    inline uint16_t get_OUT_AS_ULC_X() volatile
    {
        return (OUT_AS_ULC >> 16u) & 0b11111111111111u;
    }

    /**
     * Set OUT_AS_ULC's X field.
     *
     * This field indicates the upper left X-coordinate (in pixels) of the
     * alpha surface (AS) in the output frame buffer
     */
    inline void set_OUT_AS_ULC_X(uint16_t value) volatile
    {
        uint32_t curr = OUT_AS_ULC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (value & 0b11111111111111u) << 16u;

        OUT_AS_ULC = curr;
    }

    /**
     * Get OUT_AS_ULC's Y field.
     *
     * This field indicates the upper left Y-coordinate (in pixels) of the
     * alpha surface in the output frame buffer
     */
    inline uint16_t get_OUT_AS_ULC_Y() volatile
    {
        return (OUT_AS_ULC >> 0u) & 0b11111111111111u;
    }

    /**
     * Set OUT_AS_ULC's Y field.
     *
     * This field indicates the upper left Y-coordinate (in pixels) of the
     * alpha surface in the output frame buffer
     */
    inline void set_OUT_AS_ULC_Y(uint16_t value) volatile
    {
        uint32_t curr = OUT_AS_ULC;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        OUT_AS_ULC = curr;
    }

    /**
     * Get all of OUT_AS_ULC's bit fields.
     *
     * (read-write) Alpha Surface Upper Left Coordinate
     */
    inline void get_OUT_AS_ULC(uint16_t &X, uint16_t &Y) volatile
    {
        uint32_t curr = OUT_AS_ULC;

        X = (curr >> 16u) & 0b11111111111111u;
        Y = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Set all of OUT_AS_ULC's bit fields.
     *
     * (read-write) Alpha Surface Upper Left Coordinate
     */
    inline void set_OUT_AS_ULC(uint16_t X, uint16_t Y) volatile
    {
        uint32_t curr = OUT_AS_ULC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (X & 0b11111111111111u) << 16u;
        curr &= ~(0b11111111111111u << 0u);
        curr |= (Y & 0b11111111111111u) << 0u;

        OUT_AS_ULC = curr;
    }

    /**
     * Get OUT_AS_LRC's X field.
     *
     * This field indicates the lower right X-coordinate (in pixels) of the
     * alpha surface (AS) in the output frame buffer
     */
    inline uint16_t get_OUT_AS_LRC_X() volatile
    {
        return (OUT_AS_LRC >> 16u) & 0b11111111111111u;
    }

    /**
     * Set OUT_AS_LRC's X field.
     *
     * This field indicates the lower right X-coordinate (in pixels) of the
     * alpha surface (AS) in the output frame buffer
     */
    inline void set_OUT_AS_LRC_X(uint16_t value) volatile
    {
        uint32_t curr = OUT_AS_LRC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (value & 0b11111111111111u) << 16u;

        OUT_AS_LRC = curr;
    }

    /**
     * Get OUT_AS_LRC's Y field.
     *
     * This field indicates the lower right Y-coordinate (in pixels) of the
     * alpha surface in the output frame buffer
     */
    inline uint16_t get_OUT_AS_LRC_Y() volatile
    {
        return (OUT_AS_LRC >> 0u) & 0b11111111111111u;
    }

    /**
     * Set OUT_AS_LRC's Y field.
     *
     * This field indicates the lower right Y-coordinate (in pixels) of the
     * alpha surface in the output frame buffer
     */
    inline void set_OUT_AS_LRC_Y(uint16_t value) volatile
    {
        uint32_t curr = OUT_AS_LRC;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        OUT_AS_LRC = curr;
    }

    /**
     * Get all of OUT_AS_LRC's bit fields.
     *
     * (read-write) Alpha Surface Lower Right Coordinate
     */
    inline void get_OUT_AS_LRC(uint16_t &X, uint16_t &Y) volatile
    {
        uint32_t curr = OUT_AS_LRC;

        X = (curr >> 16u) & 0b11111111111111u;
        Y = (curr >> 0u) & 0b11111111111111u;
    }

    /**
     * Set all of OUT_AS_LRC's bit fields.
     *
     * (read-write) Alpha Surface Lower Right Coordinate
     */
    inline void set_OUT_AS_LRC(uint16_t X, uint16_t Y) volatile
    {
        uint32_t curr = OUT_AS_LRC;

        curr &= ~(0b11111111111111u << 16u);
        curr |= (X & 0b11111111111111u) << 16u;
        curr &= ~(0b11111111111111u << 0u);
        curr |= (Y & 0b11111111111111u) << 0u;

        OUT_AS_LRC = curr;
    }

    /**
     * Get PS_CTRL's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline PXP_PS_CTRL_DECX get_PS_CTRL_DECX() volatile
    {
        return PXP_PS_CTRL_DECX((PS_CTRL >> 10u) & 0b11u);
    }

    /**
     * Set PS_CTRL's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline void set_PS_CTRL_DECX(PXP_PS_CTRL_DECX value) volatile
    {
        uint32_t curr = PS_CTRL;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        PS_CTRL = curr;
    }

    /**
     * Get PS_CTRL's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline PXP_PS_CTRL_DECY get_PS_CTRL_DECY() volatile
    {
        return PXP_PS_CTRL_DECY((PS_CTRL >> 8u) & 0b11u);
    }

    /**
     * Set PS_CTRL's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline void set_PS_CTRL_DECY(PXP_PS_CTRL_DECY value) volatile
    {
        uint32_t curr = PS_CTRL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        PS_CTRL = curr;
    }

    /**
     * Get PS_CTRL's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline bool get_PS_CTRL_WB_SWAP() volatile
    {
        return PS_CTRL & (1u << 6u);
    }

    /**
     * Set PS_CTRL's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void set_PS_CTRL_WB_SWAP() volatile
    {
        PS_CTRL |= 1u << 6u;
    }

    /**
     * Clear PS_CTRL's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void clear_PS_CTRL_WB_SWAP() volatile
    {
        PS_CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle PS_CTRL's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void toggle_PS_CTRL_WB_SWAP() volatile
    {
        PS_CTRL ^= 1u << 6u;
    }

    /**
     * Get PS_CTRL's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline PXP_PS_CTRL_FORMAT get_PS_CTRL_FORMAT() volatile
    {
        return PXP_PS_CTRL_FORMAT((PS_CTRL >> 0u) & 0b111111u);
    }

    /**
     * Set PS_CTRL's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline void set_PS_CTRL_FORMAT(PXP_PS_CTRL_FORMAT value) volatile
    {
        uint32_t curr = PS_CTRL;

        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111u) << 0u;

        PS_CTRL = curr;
    }

    /**
     * Get all of PS_CTRL's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void get_PS_CTRL(PXP_PS_CTRL_DECX &DECX, PXP_PS_CTRL_DECY &DECY,
                            bool &WB_SWAP, PXP_PS_CTRL_FORMAT &FORMAT) volatile
    {
        uint32_t curr = PS_CTRL;

        DECX = PXP_PS_CTRL_DECX((curr >> 10u) & 0b11u);
        DECY = PXP_PS_CTRL_DECY((curr >> 8u) & 0b11u);
        WB_SWAP = curr & (1u << 6u);
        FORMAT = PXP_PS_CTRL_FORMAT((curr >> 0u) & 0b111111u);
    }

    /**
     * Set all of PS_CTRL's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void set_PS_CTRL(PXP_PS_CTRL_DECX DECX, PXP_PS_CTRL_DECY DECY,
                            bool WB_SWAP, PXP_PS_CTRL_FORMAT FORMAT) volatile
    {
        uint32_t curr = PS_CTRL;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(DECX) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(DECY) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (WB_SWAP & 0b1u) << 6u;
        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b111111u) << 0u;

        PS_CTRL = curr;
    }

    /**
     * Get PS_CTRL_SET's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline PXP_PS_CTRL_SET_DECX get_PS_CTRL_SET_DECX() volatile
    {
        return PXP_PS_CTRL_SET_DECX((PS_CTRL_SET >> 10u) & 0b11u);
    }

    /**
     * Set PS_CTRL_SET's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline void set_PS_CTRL_SET_DECX(PXP_PS_CTRL_SET_DECX value) volatile
    {
        uint32_t curr = PS_CTRL_SET;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        PS_CTRL_SET = curr;
    }

    /**
     * Get PS_CTRL_SET's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline PXP_PS_CTRL_SET_DECY get_PS_CTRL_SET_DECY() volatile
    {
        return PXP_PS_CTRL_SET_DECY((PS_CTRL_SET >> 8u) & 0b11u);
    }

    /**
     * Set PS_CTRL_SET's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline void set_PS_CTRL_SET_DECY(PXP_PS_CTRL_SET_DECY value) volatile
    {
        uint32_t curr = PS_CTRL_SET;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        PS_CTRL_SET = curr;
    }

    /**
     * Get PS_CTRL_SET's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline bool get_PS_CTRL_SET_WB_SWAP() volatile
    {
        return PS_CTRL_SET & (1u << 6u);
    }

    /**
     * Set PS_CTRL_SET's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void set_PS_CTRL_SET_WB_SWAP() volatile
    {
        PS_CTRL_SET |= 1u << 6u;
    }

    /**
     * Clear PS_CTRL_SET's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void clear_PS_CTRL_SET_WB_SWAP() volatile
    {
        PS_CTRL_SET &= ~(1u << 6u);
    }

    /**
     * Toggle PS_CTRL_SET's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void toggle_PS_CTRL_SET_WB_SWAP() volatile
    {
        PS_CTRL_SET ^= 1u << 6u;
    }

    /**
     * Get PS_CTRL_SET's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline PXP_PS_CTRL_SET_FORMAT get_PS_CTRL_SET_FORMAT() volatile
    {
        return PXP_PS_CTRL_SET_FORMAT((PS_CTRL_SET >> 0u) & 0b111111u);
    }

    /**
     * Set PS_CTRL_SET's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline void set_PS_CTRL_SET_FORMAT(PXP_PS_CTRL_SET_FORMAT value) volatile
    {
        uint32_t curr = PS_CTRL_SET;

        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111u) << 0u;

        PS_CTRL_SET = curr;
    }

    /**
     * Get all of PS_CTRL_SET's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void get_PS_CTRL_SET(PXP_PS_CTRL_SET_DECX &DECX,
                                PXP_PS_CTRL_SET_DECY &DECY, bool &WB_SWAP,
                                PXP_PS_CTRL_SET_FORMAT &FORMAT) volatile
    {
        uint32_t curr = PS_CTRL_SET;

        DECX = PXP_PS_CTRL_SET_DECX((curr >> 10u) & 0b11u);
        DECY = PXP_PS_CTRL_SET_DECY((curr >> 8u) & 0b11u);
        WB_SWAP = curr & (1u << 6u);
        FORMAT = PXP_PS_CTRL_SET_FORMAT((curr >> 0u) & 0b111111u);
    }

    /**
     * Set all of PS_CTRL_SET's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void set_PS_CTRL_SET(PXP_PS_CTRL_SET_DECX DECX,
                                PXP_PS_CTRL_SET_DECY DECY, bool WB_SWAP,
                                PXP_PS_CTRL_SET_FORMAT FORMAT) volatile
    {
        uint32_t curr = PS_CTRL_SET;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(DECX) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(DECY) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (WB_SWAP & 0b1u) << 6u;
        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b111111u) << 0u;

        PS_CTRL_SET = curr;
    }

    /**
     * Get PS_CTRL_CLR's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline PXP_PS_CTRL_CLR_DECX get_PS_CTRL_CLR_DECX() volatile
    {
        return PXP_PS_CTRL_CLR_DECX((PS_CTRL_CLR >> 10u) & 0b11u);
    }

    /**
     * Set PS_CTRL_CLR's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline void set_PS_CTRL_CLR_DECX(PXP_PS_CTRL_CLR_DECX value) volatile
    {
        uint32_t curr = PS_CTRL_CLR;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        PS_CTRL_CLR = curr;
    }

    /**
     * Get PS_CTRL_CLR's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline PXP_PS_CTRL_CLR_DECY get_PS_CTRL_CLR_DECY() volatile
    {
        return PXP_PS_CTRL_CLR_DECY((PS_CTRL_CLR >> 8u) & 0b11u);
    }

    /**
     * Set PS_CTRL_CLR's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline void set_PS_CTRL_CLR_DECY(PXP_PS_CTRL_CLR_DECY value) volatile
    {
        uint32_t curr = PS_CTRL_CLR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        PS_CTRL_CLR = curr;
    }

    /**
     * Get PS_CTRL_CLR's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline bool get_PS_CTRL_CLR_WB_SWAP() volatile
    {
        return PS_CTRL_CLR & (1u << 6u);
    }

    /**
     * Set PS_CTRL_CLR's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void set_PS_CTRL_CLR_WB_SWAP() volatile
    {
        PS_CTRL_CLR |= 1u << 6u;
    }

    /**
     * Clear PS_CTRL_CLR's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void clear_PS_CTRL_CLR_WB_SWAP() volatile
    {
        PS_CTRL_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle PS_CTRL_CLR's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void toggle_PS_CTRL_CLR_WB_SWAP() volatile
    {
        PS_CTRL_CLR ^= 1u << 6u;
    }

    /**
     * Get PS_CTRL_CLR's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline PXP_PS_CTRL_CLR_FORMAT get_PS_CTRL_CLR_FORMAT() volatile
    {
        return PXP_PS_CTRL_CLR_FORMAT((PS_CTRL_CLR >> 0u) & 0b111111u);
    }

    /**
     * Set PS_CTRL_CLR's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline void set_PS_CTRL_CLR_FORMAT(PXP_PS_CTRL_CLR_FORMAT value) volatile
    {
        uint32_t curr = PS_CTRL_CLR;

        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111u) << 0u;

        PS_CTRL_CLR = curr;
    }

    /**
     * Get all of PS_CTRL_CLR's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void get_PS_CTRL_CLR(PXP_PS_CTRL_CLR_DECX &DECX,
                                PXP_PS_CTRL_CLR_DECY &DECY, bool &WB_SWAP,
                                PXP_PS_CTRL_CLR_FORMAT &FORMAT) volatile
    {
        uint32_t curr = PS_CTRL_CLR;

        DECX = PXP_PS_CTRL_CLR_DECX((curr >> 10u) & 0b11u);
        DECY = PXP_PS_CTRL_CLR_DECY((curr >> 8u) & 0b11u);
        WB_SWAP = curr & (1u << 6u);
        FORMAT = PXP_PS_CTRL_CLR_FORMAT((curr >> 0u) & 0b111111u);
    }

    /**
     * Set all of PS_CTRL_CLR's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void set_PS_CTRL_CLR(PXP_PS_CTRL_CLR_DECX DECX,
                                PXP_PS_CTRL_CLR_DECY DECY, bool WB_SWAP,
                                PXP_PS_CTRL_CLR_FORMAT FORMAT) volatile
    {
        uint32_t curr = PS_CTRL_CLR;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(DECX) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(DECY) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (WB_SWAP & 0b1u) << 6u;
        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b111111u) << 0u;

        PS_CTRL_CLR = curr;
    }

    /**
     * Get PS_CTRL_TOG's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline PXP_PS_CTRL_TOG_DECX get_PS_CTRL_TOG_DECX() volatile
    {
        return PXP_PS_CTRL_TOG_DECX((PS_CTRL_TOG >> 10u) & 0b11u);
    }

    /**
     * Set PS_CTRL_TOG's DECX field.
     *
     * Horizontal pre decimation filter control.
     */
    inline void set_PS_CTRL_TOG_DECX(PXP_PS_CTRL_TOG_DECX value) volatile
    {
        uint32_t curr = PS_CTRL_TOG;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        PS_CTRL_TOG = curr;
    }

    /**
     * Get PS_CTRL_TOG's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline PXP_PS_CTRL_TOG_DECY get_PS_CTRL_TOG_DECY() volatile
    {
        return PXP_PS_CTRL_TOG_DECY((PS_CTRL_TOG >> 8u) & 0b11u);
    }

    /**
     * Set PS_CTRL_TOG's DECY field.
     *
     * Verticle pre decimation filter control.
     */
    inline void set_PS_CTRL_TOG_DECY(PXP_PS_CTRL_TOG_DECY value) volatile
    {
        uint32_t curr = PS_CTRL_TOG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        PS_CTRL_TOG = curr;
    }

    /**
     * Get PS_CTRL_TOG's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline bool get_PS_CTRL_TOG_WB_SWAP() volatile
    {
        return PS_CTRL_TOG & (1u << 6u);
    }

    /**
     * Set PS_CTRL_TOG's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void set_PS_CTRL_TOG_WB_SWAP() volatile
    {
        PS_CTRL_TOG |= 1u << 6u;
    }

    /**
     * Clear PS_CTRL_TOG's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void clear_PS_CTRL_TOG_WB_SWAP() volatile
    {
        PS_CTRL_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle PS_CTRL_TOG's WB_SWAP bit.
     *
     * Swap bytes in words. For each 16 bit word, the two bytes will be
     * swapped.
     */
    inline void toggle_PS_CTRL_TOG_WB_SWAP() volatile
    {
        PS_CTRL_TOG ^= 1u << 6u;
    }

    /**
     * Get PS_CTRL_TOG's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline PXP_PS_CTRL_TOG_FORMAT get_PS_CTRL_TOG_FORMAT() volatile
    {
        return PXP_PS_CTRL_TOG_FORMAT((PS_CTRL_TOG >> 0u) & 0b111111u);
    }

    /**
     * Set PS_CTRL_TOG's FORMAT field.
     *
     * PS buffer format. To select between YUV and YCbCr formats, see bit 31 of
     * the CSC1_COEF0 register.
     */
    inline void set_PS_CTRL_TOG_FORMAT(PXP_PS_CTRL_TOG_FORMAT value) volatile
    {
        uint32_t curr = PS_CTRL_TOG;

        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111u) << 0u;

        PS_CTRL_TOG = curr;
    }

    /**
     * Get all of PS_CTRL_TOG's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void get_PS_CTRL_TOG(PXP_PS_CTRL_TOG_DECX &DECX,
                                PXP_PS_CTRL_TOG_DECY &DECY, bool &WB_SWAP,
                                PXP_PS_CTRL_TOG_FORMAT &FORMAT) volatile
    {
        uint32_t curr = PS_CTRL_TOG;

        DECX = PXP_PS_CTRL_TOG_DECX((curr >> 10u) & 0b11u);
        DECY = PXP_PS_CTRL_TOG_DECY((curr >> 8u) & 0b11u);
        WB_SWAP = curr & (1u << 6u);
        FORMAT = PXP_PS_CTRL_TOG_FORMAT((curr >> 0u) & 0b111111u);
    }

    /**
     * Set all of PS_CTRL_TOG's bit fields.
     *
     * (read-write) Processed Surface (PS) Control Register
     */
    inline void set_PS_CTRL_TOG(PXP_PS_CTRL_TOG_DECX DECX,
                                PXP_PS_CTRL_TOG_DECY DECY, bool WB_SWAP,
                                PXP_PS_CTRL_TOG_FORMAT FORMAT) volatile
    {
        uint32_t curr = PS_CTRL_TOG;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(DECX) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(DECY) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (WB_SWAP & 0b1u) << 6u;
        curr &= ~(0b111111u << 0u);
        curr |= (std::to_underlying(FORMAT) & 0b111111u) << 0u;

        PS_CTRL_TOG = curr;
    }

    /**
     * Get PS_BUF's ADDR field.
     *
     * Address pointer for the PS RGB or Y (luma) input buffer.
     */
    inline uint32_t get_PS_BUF_ADDR() volatile
    {
        return (PS_BUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PS_BUF's ADDR field.
     *
     * Address pointer for the PS RGB or Y (luma) input buffer.
     */
    inline void set_PS_BUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = PS_BUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PS_BUF = curr;
    }

    /**
     * Get PS_UBUF's ADDR field.
     *
     * Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.
     */
    inline uint32_t get_PS_UBUF_ADDR() volatile
    {
        return (PS_UBUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PS_UBUF's ADDR field.
     *
     * Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.
     */
    inline void set_PS_UBUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = PS_UBUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PS_UBUF = curr;
    }

    /**
     * Get PS_VBUF's ADDR field.
     *
     * Address pointer for the PS V/Cr Chroma input buffer.
     */
    inline uint32_t get_PS_VBUF_ADDR() volatile
    {
        return (PS_VBUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set PS_VBUF's ADDR field.
     *
     * Address pointer for the PS V/Cr Chroma input buffer.
     */
    inline void set_PS_VBUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = PS_VBUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        PS_VBUF = curr;
    }

    /**
     * Get PS_PITCH's PITCH field.
     *
     * Indicates the number of bytes in memory between two vertically adjacent
     * pixels.
     */
    inline uint16_t get_PS_PITCH_PITCH() volatile
    {
        return (PS_PITCH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PS_PITCH's PITCH field.
     *
     * Indicates the number of bytes in memory between two vertically adjacent
     * pixels.
     */
    inline void set_PS_PITCH_PITCH(uint16_t value) volatile
    {
        uint32_t curr = PS_PITCH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PS_PITCH = curr;
    }

    /**
     * Get PS_BACKGROUND's COLOR field.
     *
     * Background color (in 24bpp format) for any pixels not within the buffer
     * range specified by the PS ULC/LRC
     */
    inline uint32_t get_PS_BACKGROUND_COLOR() volatile
    {
        return (PS_BACKGROUND >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set PS_BACKGROUND's COLOR field.
     *
     * Background color (in 24bpp format) for any pixels not within the buffer
     * range specified by the PS ULC/LRC
     */
    inline void set_PS_BACKGROUND_COLOR(uint32_t value) volatile
    {
        uint32_t curr = PS_BACKGROUND;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        PS_BACKGROUND = curr;
    }

    /**
     * Get PS_SCALE's YSCALE field.
     *
     * This is a two bit integer and 12 bit fractional representation (##
     */
    inline uint16_t get_PS_SCALE_YSCALE() volatile
    {
        return (PS_SCALE >> 16u) & 0b111111111111111u;
    }

    /**
     * Set PS_SCALE's YSCALE field.
     *
     * This is a two bit integer and 12 bit fractional representation (##
     */
    inline void set_PS_SCALE_YSCALE(uint16_t value) volatile
    {
        uint32_t curr = PS_SCALE;

        curr &= ~(0b111111111111111u << 16u);
        curr |= (value & 0b111111111111111u) << 16u;

        PS_SCALE = curr;
    }

    /**
     * Get PS_SCALE's XSCALE field.
     *
     * This is a two bit integer and 12 bit fractional representation (##
     */
    inline uint16_t get_PS_SCALE_XSCALE() volatile
    {
        return (PS_SCALE >> 0u) & 0b111111111111111u;
    }

    /**
     * Set PS_SCALE's XSCALE field.
     *
     * This is a two bit integer and 12 bit fractional representation (##
     */
    inline void set_PS_SCALE_XSCALE(uint16_t value) volatile
    {
        uint32_t curr = PS_SCALE;

        curr &= ~(0b111111111111111u << 0u);
        curr |= (value & 0b111111111111111u) << 0u;

        PS_SCALE = curr;
    }

    /**
     * Get all of PS_SCALE's bit fields.
     *
     * (read-write) PS Scale Factor Register
     */
    inline void get_PS_SCALE(uint16_t &YSCALE, uint16_t &XSCALE) volatile
    {
        uint32_t curr = PS_SCALE;

        YSCALE = (curr >> 16u) & 0b111111111111111u;
        XSCALE = (curr >> 0u) & 0b111111111111111u;
    }

    /**
     * Set all of PS_SCALE's bit fields.
     *
     * (read-write) PS Scale Factor Register
     */
    inline void set_PS_SCALE(uint16_t YSCALE, uint16_t XSCALE) volatile
    {
        uint32_t curr = PS_SCALE;

        curr &= ~(0b111111111111111u << 16u);
        curr |= (YSCALE & 0b111111111111111u) << 16u;
        curr &= ~(0b111111111111111u << 0u);
        curr |= (XSCALE & 0b111111111111111u) << 0u;

        PS_SCALE = curr;
    }

    /**
     * Get PS_OFFSET's YOFFSET field.
     *
     * This is a 12 bit fractional representation (0
     */
    inline uint16_t get_PS_OFFSET_YOFFSET() volatile
    {
        return (PS_OFFSET >> 16u) & 0b111111111111u;
    }

    /**
     * Set PS_OFFSET's YOFFSET field.
     *
     * This is a 12 bit fractional representation (0
     */
    inline void set_PS_OFFSET_YOFFSET(uint16_t value) volatile
    {
        uint32_t curr = PS_OFFSET;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PS_OFFSET = curr;
    }

    /**
     * Get PS_OFFSET's XOFFSET field.
     *
     * This is a 12 bit fractional representation (0
     */
    inline uint16_t get_PS_OFFSET_XOFFSET() volatile
    {
        return (PS_OFFSET >> 0u) & 0b111111111111u;
    }

    /**
     * Set PS_OFFSET's XOFFSET field.
     *
     * This is a 12 bit fractional representation (0
     */
    inline void set_PS_OFFSET_XOFFSET(uint16_t value) volatile
    {
        uint32_t curr = PS_OFFSET;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PS_OFFSET = curr;
    }

    /**
     * Get all of PS_OFFSET's bit fields.
     *
     * (read-write) PS Scale Offset Register
     */
    inline void get_PS_OFFSET(uint16_t &YOFFSET, uint16_t &XOFFSET) volatile
    {
        uint32_t curr = PS_OFFSET;

        YOFFSET = (curr >> 16u) & 0b111111111111u;
        XOFFSET = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PS_OFFSET's bit fields.
     *
     * (read-write) PS Scale Offset Register
     */
    inline void set_PS_OFFSET(uint16_t YOFFSET, uint16_t XOFFSET) volatile
    {
        uint32_t curr = PS_OFFSET;

        curr &= ~(0b111111111111u << 16u);
        curr |= (YOFFSET & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (XOFFSET & 0b111111111111u) << 0u;

        PS_OFFSET = curr;
    }

    /**
     * Get PS_CLRKEYLOW's PIXEL field.
     *
     * Low range of color key applied to PS buffer
     */
    inline uint32_t get_PS_CLRKEYLOW_PIXEL() volatile
    {
        return (PS_CLRKEYLOW >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set PS_CLRKEYLOW's PIXEL field.
     *
     * Low range of color key applied to PS buffer
     */
    inline void set_PS_CLRKEYLOW_PIXEL(uint32_t value) volatile
    {
        uint32_t curr = PS_CLRKEYLOW;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        PS_CLRKEYLOW = curr;
    }

    /**
     * Get PS_CLRKEYHIGH's PIXEL field.
     *
     * High range of color key applied to PS buffer
     */
    inline uint32_t get_PS_CLRKEYHIGH_PIXEL() volatile
    {
        return (PS_CLRKEYHIGH >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set PS_CLRKEYHIGH's PIXEL field.
     *
     * High range of color key applied to PS buffer
     */
    inline void set_PS_CLRKEYHIGH_PIXEL(uint32_t value) volatile
    {
        uint32_t curr = PS_CLRKEYHIGH;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        PS_CLRKEYHIGH = curr;
    }

    /**
     * Get AS_CTRL's ALPHA_INVERT bit.
     *
     * Setting this bit to logic 0 will not alter the alpha value
     */
    inline bool get_AS_CTRL_ALPHA_INVERT() volatile
    {
        return AS_CTRL & (1u << 20u);
    }

    /**
     * Set AS_CTRL's ALPHA_INVERT bit.
     *
     * Setting this bit to logic 0 will not alter the alpha value
     */
    inline void set_AS_CTRL_ALPHA_INVERT() volatile
    {
        AS_CTRL |= 1u << 20u;
    }

    /**
     * Clear AS_CTRL's ALPHA_INVERT bit.
     *
     * Setting this bit to logic 0 will not alter the alpha value
     */
    inline void clear_AS_CTRL_ALPHA_INVERT() volatile
    {
        AS_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle AS_CTRL's ALPHA_INVERT bit.
     *
     * Setting this bit to logic 0 will not alter the alpha value
     */
    inline void toggle_AS_CTRL_ALPHA_INVERT() volatile
    {
        AS_CTRL ^= 1u << 20u;
    }

    /**
     * Get AS_CTRL's ROP field.
     *
     * Indicates a raster operation to perform when enabled
     */
    inline PXP_AS_CTRL_ROP get_AS_CTRL_ROP() volatile
    {
        return PXP_AS_CTRL_ROP((AS_CTRL >> 16u) & 0b1111u);
    }

    /**
     * Set AS_CTRL's ROP field.
     *
     * Indicates a raster operation to perform when enabled
     */
    inline void set_AS_CTRL_ROP(PXP_AS_CTRL_ROP value) volatile
    {
        uint32_t curr = AS_CTRL;

        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111u) << 16u;

        AS_CTRL = curr;
    }

    /**
     * Get AS_CTRL's ALPHA field.
     *
     * Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values are
     * programmed in PXP_AS_CTRL[ALPHA_CTRL]
     */
    inline uint8_t get_AS_CTRL_ALPHA() volatile
    {
        return (AS_CTRL >> 8u) & 0b11111111u;
    }

    /**
     * Set AS_CTRL's ALPHA field.
     *
     * Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values are
     * programmed in PXP_AS_CTRL[ALPHA_CTRL]
     */
    inline void set_AS_CTRL_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = AS_CTRL;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        AS_CTRL = curr;
    }

    /**
     * Get AS_CTRL's FORMAT field.
     *
     * Indicates the input buffer format for AS.
     */
    inline PXP_AS_CTRL_FORMAT get_AS_CTRL_FORMAT() volatile
    {
        return PXP_AS_CTRL_FORMAT((AS_CTRL >> 4u) & 0b1111u);
    }

    /**
     * Set AS_CTRL's FORMAT field.
     *
     * Indicates the input buffer format for AS.
     */
    inline void set_AS_CTRL_FORMAT(PXP_AS_CTRL_FORMAT value) volatile
    {
        uint32_t curr = AS_CTRL;

        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(value) & 0b1111u) << 4u;

        AS_CTRL = curr;
    }

    /**
     * Get AS_CTRL's ENABLE_COLORKEY bit.
     *
     * Indicates that colorkey functionality is enabled for this alpha surface
     */
    inline bool get_AS_CTRL_ENABLE_COLORKEY() volatile
    {
        return AS_CTRL & (1u << 3u);
    }

    /**
     * Set AS_CTRL's ENABLE_COLORKEY bit.
     *
     * Indicates that colorkey functionality is enabled for this alpha surface
     */
    inline void set_AS_CTRL_ENABLE_COLORKEY() volatile
    {
        AS_CTRL |= 1u << 3u;
    }

    /**
     * Clear AS_CTRL's ENABLE_COLORKEY bit.
     *
     * Indicates that colorkey functionality is enabled for this alpha surface
     */
    inline void clear_AS_CTRL_ENABLE_COLORKEY() volatile
    {
        AS_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle AS_CTRL's ENABLE_COLORKEY bit.
     *
     * Indicates that colorkey functionality is enabled for this alpha surface
     */
    inline void toggle_AS_CTRL_ENABLE_COLORKEY() volatile
    {
        AS_CTRL ^= 1u << 3u;
    }

    /**
     * Get AS_CTRL's ALPHA_CTRL field.
     *
     * Determines how the alpha value is constructed for this alpha surface
     */
    inline PXP_AS_CTRL_ALPHA_CTRL get_AS_CTRL_ALPHA_CTRL() volatile
    {
        return PXP_AS_CTRL_ALPHA_CTRL((AS_CTRL >> 1u) & 0b11u);
    }

    /**
     * Set AS_CTRL's ALPHA_CTRL field.
     *
     * Determines how the alpha value is constructed for this alpha surface
     */
    inline void set_AS_CTRL_ALPHA_CTRL(PXP_AS_CTRL_ALPHA_CTRL value) volatile
    {
        uint32_t curr = AS_CTRL;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        AS_CTRL = curr;
    }

    /**
     * Get all of AS_CTRL's bit fields.
     *
     * (read-write) Alpha Surface Control
     */
    inline void get_AS_CTRL(bool &ALPHA_INVERT, PXP_AS_CTRL_ROP &ROP,
                            uint8_t &ALPHA, PXP_AS_CTRL_FORMAT &FORMAT,
                            bool &ENABLE_COLORKEY,
                            PXP_AS_CTRL_ALPHA_CTRL &ALPHA_CTRL) volatile
    {
        uint32_t curr = AS_CTRL;

        ALPHA_INVERT = curr & (1u << 20u);
        ROP = PXP_AS_CTRL_ROP((curr >> 16u) & 0b1111u);
        ALPHA = (curr >> 8u) & 0b11111111u;
        FORMAT = PXP_AS_CTRL_FORMAT((curr >> 4u) & 0b1111u);
        ENABLE_COLORKEY = curr & (1u << 3u);
        ALPHA_CTRL = PXP_AS_CTRL_ALPHA_CTRL((curr >> 1u) & 0b11u);
    }

    /**
     * Set all of AS_CTRL's bit fields.
     *
     * (read-write) Alpha Surface Control
     */
    inline void set_AS_CTRL(bool ALPHA_INVERT, PXP_AS_CTRL_ROP ROP,
                            uint8_t ALPHA, PXP_AS_CTRL_FORMAT FORMAT,
                            bool ENABLE_COLORKEY,
                            PXP_AS_CTRL_ALPHA_CTRL ALPHA_CTRL) volatile
    {
        uint32_t curr = AS_CTRL;

        curr &= ~(0b1u << 20u);
        curr |= (ALPHA_INVERT & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (std::to_underlying(ROP) & 0b1111u) << 16u;
        curr &= ~(0b11111111u << 8u);
        curr |= (ALPHA & 0b11111111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (std::to_underlying(FORMAT) & 0b1111u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (ENABLE_COLORKEY & 0b1u) << 3u;
        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(ALPHA_CTRL) & 0b11u) << 1u;

        AS_CTRL = curr;
    }

    /**
     * Get AS_BUF's ADDR field.
     *
     * Address pointer for the alpha surface 0 buffer.
     */
    inline uint32_t get_AS_BUF_ADDR() volatile
    {
        return (AS_BUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set AS_BUF's ADDR field.
     *
     * Address pointer for the alpha surface 0 buffer.
     */
    inline void set_AS_BUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = AS_BUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        AS_BUF = curr;
    }

    /**
     * Get AS_PITCH's PITCH field.
     *
     * Indicates the number of bytes in memory between two vertically adjacent
     * pixels.
     */
    inline uint16_t get_AS_PITCH_PITCH() volatile
    {
        return (AS_PITCH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set AS_PITCH's PITCH field.
     *
     * Indicates the number of bytes in memory between two vertically adjacent
     * pixels.
     */
    inline void set_AS_PITCH_PITCH(uint16_t value) volatile
    {
        uint32_t curr = AS_PITCH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        AS_PITCH = curr;
    }

    /**
     * Get AS_CLRKEYLOW's PIXEL field.
     *
     * Low range of RGB color key applied to AS buffer. Each overlay has an
     * independent colorkey enable.
     */
    inline uint32_t get_AS_CLRKEYLOW_PIXEL() volatile
    {
        return (AS_CLRKEYLOW >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set AS_CLRKEYLOW's PIXEL field.
     *
     * Low range of RGB color key applied to AS buffer. Each overlay has an
     * independent colorkey enable.
     */
    inline void set_AS_CLRKEYLOW_PIXEL(uint32_t value) volatile
    {
        uint32_t curr = AS_CLRKEYLOW;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        AS_CLRKEYLOW = curr;
    }

    /**
     * Get AS_CLRKEYHIGH's PIXEL field.
     *
     * High range of RGB color key applied to AS buffer. Each overlay has an
     * independent colorkey enable.
     */
    inline uint32_t get_AS_CLRKEYHIGH_PIXEL() volatile
    {
        return (AS_CLRKEYHIGH >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set AS_CLRKEYHIGH's PIXEL field.
     *
     * High range of RGB color key applied to AS buffer. Each overlay has an
     * independent colorkey enable.
     */
    inline void set_AS_CLRKEYHIGH_PIXEL(uint32_t value) volatile
    {
        uint32_t curr = AS_CLRKEYHIGH;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        AS_CLRKEYHIGH = curr;
    }

    /**
     * Get CSC1_COEF0's YCBCR_MODE bit.
     *
     * Set to 1 when performing YCbCr conversion to RGB
     */
    inline bool get_CSC1_COEF0_YCBCR_MODE() volatile
    {
        return CSC1_COEF0 & (1u << 31u);
    }

    /**
     * Set CSC1_COEF0's YCBCR_MODE bit.
     *
     * Set to 1 when performing YCbCr conversion to RGB
     */
    inline void set_CSC1_COEF0_YCBCR_MODE() volatile
    {
        CSC1_COEF0 |= 1u << 31u;
    }

    /**
     * Clear CSC1_COEF0's YCBCR_MODE bit.
     *
     * Set to 1 when performing YCbCr conversion to RGB
     */
    inline void clear_CSC1_COEF0_YCBCR_MODE() volatile
    {
        CSC1_COEF0 &= ~(1u << 31u);
    }

    /**
     * Toggle CSC1_COEF0's YCBCR_MODE bit.
     *
     * Set to 1 when performing YCbCr conversion to RGB
     */
    inline void toggle_CSC1_COEF0_YCBCR_MODE() volatile
    {
        CSC1_COEF0 ^= 1u << 31u;
    }

    /**
     * Get CSC1_COEF0's BYPASS bit.
     *
     * Bypass the CSC unit in the scaling engine
     */
    inline bool get_CSC1_COEF0_BYPASS() volatile
    {
        return CSC1_COEF0 & (1u << 30u);
    }

    /**
     * Set CSC1_COEF0's BYPASS bit.
     *
     * Bypass the CSC unit in the scaling engine
     */
    inline void set_CSC1_COEF0_BYPASS() volatile
    {
        CSC1_COEF0 |= 1u << 30u;
    }

    /**
     * Clear CSC1_COEF0's BYPASS bit.
     *
     * Bypass the CSC unit in the scaling engine
     */
    inline void clear_CSC1_COEF0_BYPASS() volatile
    {
        CSC1_COEF0 &= ~(1u << 30u);
    }

    /**
     * Toggle CSC1_COEF0's BYPASS bit.
     *
     * Bypass the CSC unit in the scaling engine
     */
    inline void toggle_CSC1_COEF0_BYPASS() volatile
    {
        CSC1_COEF0 ^= 1u << 30u;
    }

    /**
     * Get CSC1_COEF0's C0 field.
     *
     * Two's compliment Y multiplier coefficient. YUV=0x100 (1.000) YCbCr=0x12A
     * (1.164)
     */
    inline uint16_t get_CSC1_COEF0_C0() volatile
    {
        return (CSC1_COEF0 >> 18u) & 0b11111111111u;
    }

    /**
     * Set CSC1_COEF0's C0 field.
     *
     * Two's compliment Y multiplier coefficient. YUV=0x100 (1.000) YCbCr=0x12A
     * (1.164)
     */
    inline void set_CSC1_COEF0_C0(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF0;

        curr &= ~(0b11111111111u << 18u);
        curr |= (value & 0b11111111111u) << 18u;

        CSC1_COEF0 = curr;
    }

    /**
     * Get CSC1_COEF0's UV_OFFSET field.
     *
     * Two's compliment phase offset implicit for CbCr data
     */
    inline uint16_t get_CSC1_COEF0_UV_OFFSET() volatile
    {
        return (CSC1_COEF0 >> 9u) & 0b111111111u;
    }

    /**
     * Set CSC1_COEF0's UV_OFFSET field.
     *
     * Two's compliment phase offset implicit for CbCr data
     */
    inline void set_CSC1_COEF0_UV_OFFSET(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF0;

        curr &= ~(0b111111111u << 9u);
        curr |= (value & 0b111111111u) << 9u;

        CSC1_COEF0 = curr;
    }

    /**
     * Get CSC1_COEF0's Y_OFFSET field.
     *
     * Two's compliment amplitude offset implicit in the Y data
     */
    inline uint16_t get_CSC1_COEF0_Y_OFFSET() volatile
    {
        return (CSC1_COEF0 >> 0u) & 0b111111111u;
    }

    /**
     * Set CSC1_COEF0's Y_OFFSET field.
     *
     * Two's compliment amplitude offset implicit in the Y data
     */
    inline void set_CSC1_COEF0_Y_OFFSET(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF0;

        curr &= ~(0b111111111u << 0u);
        curr |= (value & 0b111111111u) << 0u;

        CSC1_COEF0 = curr;
    }

    /**
     * Get all of CSC1_COEF0's bit fields.
     *
     * (read-write) Color Space Conversion Coefficient Register 0
     */
    inline void get_CSC1_COEF0(bool &YCBCR_MODE, bool &BYPASS, uint16_t &C0,
                               uint16_t &UV_OFFSET,
                               uint16_t &Y_OFFSET) volatile
    {
        uint32_t curr = CSC1_COEF0;

        YCBCR_MODE = curr & (1u << 31u);
        BYPASS = curr & (1u << 30u);
        C0 = (curr >> 18u) & 0b11111111111u;
        UV_OFFSET = (curr >> 9u) & 0b111111111u;
        Y_OFFSET = (curr >> 0u) & 0b111111111u;
    }

    /**
     * Set all of CSC1_COEF0's bit fields.
     *
     * (read-write) Color Space Conversion Coefficient Register 0
     */
    inline void set_CSC1_COEF0(bool YCBCR_MODE, bool BYPASS, uint16_t C0,
                               uint16_t UV_OFFSET, uint16_t Y_OFFSET) volatile
    {
        uint32_t curr = CSC1_COEF0;

        curr &= ~(0b1u << 31u);
        curr |= (YCBCR_MODE & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (BYPASS & 0b1u) << 30u;
        curr &= ~(0b11111111111u << 18u);
        curr |= (C0 & 0b11111111111u) << 18u;
        curr &= ~(0b111111111u << 9u);
        curr |= (UV_OFFSET & 0b111111111u) << 9u;
        curr &= ~(0b111111111u << 0u);
        curr |= (Y_OFFSET & 0b111111111u) << 0u;

        CSC1_COEF0 = curr;
    }

    /**
     * Get CSC1_COEF1's C1 field.
     *
     * Two's compliment Red V/Cr multiplier coefficient. YUV=0x123 (1.140)
     * YCbCr=0x198 (1.596)
     */
    inline uint16_t get_CSC1_COEF1_C1() volatile
    {
        return (CSC1_COEF1 >> 16u) & 0b11111111111u;
    }

    /**
     * Set CSC1_COEF1's C1 field.
     *
     * Two's compliment Red V/Cr multiplier coefficient. YUV=0x123 (1.140)
     * YCbCr=0x198 (1.596)
     */
    inline void set_CSC1_COEF1_C1(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF1;

        curr &= ~(0b11111111111u << 16u);
        curr |= (value & 0b11111111111u) << 16u;

        CSC1_COEF1 = curr;
    }

    /**
     * Get CSC1_COEF1's C4 field.
     *
     * Two's compliment Blue U/Cb multiplier coefficient. YUV=0x208 (2.032)
     * YCbCr=0x204 (2.017)
     */
    inline uint16_t get_CSC1_COEF1_C4() volatile
    {
        return (CSC1_COEF1 >> 0u) & 0b11111111111u;
    }

    /**
     * Set CSC1_COEF1's C4 field.
     *
     * Two's compliment Blue U/Cb multiplier coefficient. YUV=0x208 (2.032)
     * YCbCr=0x204 (2.017)
     */
    inline void set_CSC1_COEF1_C4(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF1;

        curr &= ~(0b11111111111u << 0u);
        curr |= (value & 0b11111111111u) << 0u;

        CSC1_COEF1 = curr;
    }

    /**
     * Get all of CSC1_COEF1's bit fields.
     *
     * (read-write) Color Space Conversion Coefficient Register 1
     */
    inline void get_CSC1_COEF1(uint16_t &C1, uint16_t &C4) volatile
    {
        uint32_t curr = CSC1_COEF1;

        C1 = (curr >> 16u) & 0b11111111111u;
        C4 = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Set all of CSC1_COEF1's bit fields.
     *
     * (read-write) Color Space Conversion Coefficient Register 1
     */
    inline void set_CSC1_COEF1(uint16_t C1, uint16_t C4) volatile
    {
        uint32_t curr = CSC1_COEF1;

        curr &= ~(0b11111111111u << 16u);
        curr |= (C1 & 0b11111111111u) << 16u;
        curr &= ~(0b11111111111u << 0u);
        curr |= (C4 & 0b11111111111u) << 0u;

        CSC1_COEF1 = curr;
    }

    /**
     * Get CSC1_COEF2's C2 field.
     *
     * Two's complement Green V/Cr multiplier coefficient. YUV=0x76B (-0.581)
     * YCbCr=0x730 (-0.813)
     */
    inline uint16_t get_CSC1_COEF2_C2() volatile
    {
        return (CSC1_COEF2 >> 16u) & 0b11111111111u;
    }

    /**
     * Set CSC1_COEF2's C2 field.
     *
     * Two's complement Green V/Cr multiplier coefficient. YUV=0x76B (-0.581)
     * YCbCr=0x730 (-0.813)
     */
    inline void set_CSC1_COEF2_C2(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF2;

        curr &= ~(0b11111111111u << 16u);
        curr |= (value & 0b11111111111u) << 16u;

        CSC1_COEF2 = curr;
    }

    /**
     * Get CSC1_COEF2's C3 field.
     *
     * Two's complement Green U/Cb multiplier coefficient. YUV=0x79C (-0.394)
     * YCbCr=0x79C (-0.392)
     */
    inline uint16_t get_CSC1_COEF2_C3() volatile
    {
        return (CSC1_COEF2 >> 0u) & 0b11111111111u;
    }

    /**
     * Set CSC1_COEF2's C3 field.
     *
     * Two's complement Green U/Cb multiplier coefficient. YUV=0x79C (-0.394)
     * YCbCr=0x79C (-0.392)
     */
    inline void set_CSC1_COEF2_C3(uint16_t value) volatile
    {
        uint32_t curr = CSC1_COEF2;

        curr &= ~(0b11111111111u << 0u);
        curr |= (value & 0b11111111111u) << 0u;

        CSC1_COEF2 = curr;
    }

    /**
     * Get all of CSC1_COEF2's bit fields.
     *
     * (read-write) Color Space Conversion Coefficient Register 2
     */
    inline void get_CSC1_COEF2(uint16_t &C2, uint16_t &C3) volatile
    {
        uint32_t curr = CSC1_COEF2;

        C2 = (curr >> 16u) & 0b11111111111u;
        C3 = (curr >> 0u) & 0b11111111111u;
    }

    /**
     * Set all of CSC1_COEF2's bit fields.
     *
     * (read-write) Color Space Conversion Coefficient Register 2
     */
    inline void set_CSC1_COEF2(uint16_t C2, uint16_t C3) volatile
    {
        uint32_t curr = CSC1_COEF2;

        curr &= ~(0b11111111111u << 16u);
        curr |= (C2 & 0b11111111111u) << 16u;
        curr &= ~(0b11111111111u << 0u);
        curr |= (C3 & 0b11111111111u) << 0u;

        CSC1_COEF2 = curr;
    }

    /**
     * Get POWER's ROT_MEM_LP_STATE field.
     *
     * Select the low power state of the Rotation (ROT) memory.
     */
    inline PXP_POWER_ROT_MEM_LP_STATE get_POWER_ROT_MEM_LP_STATE() volatile
    {
        return PXP_POWER_ROT_MEM_LP_STATE((POWER >> 9u) & 0b111u);
    }

    /**
     * Set POWER's ROT_MEM_LP_STATE field.
     *
     * Select the low power state of the Rotation (ROT) memory.
     */
    inline void set_POWER_ROT_MEM_LP_STATE(
        PXP_POWER_ROT_MEM_LP_STATE value) volatile
    {
        uint32_t curr = POWER;

        curr &= ~(0b111u << 9u);
        curr |= (std::to_underlying(value) & 0b111u) << 9u;

        POWER = curr;
    }

    /**
     * Get NEXT's POINTER field.
     *
     * A pointer to a data structure containing register values to be used when
     * processing the next frame
     */
    inline uint32_t get_NEXT_POINTER() volatile
    {
        return (NEXT >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set NEXT's POINTER field.
     *
     * A pointer to a data structure containing register values to be used when
     * processing the next frame
     */
    inline void set_NEXT_POINTER(uint32_t value) volatile
    {
        uint32_t curr = NEXT;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        NEXT = curr;
    }

    /**
     * Get NEXT's ENABLED bit.
     *
     * Indicates that the "next frame" functionality has been enabled
     */
    inline bool get_NEXT_ENABLED() volatile
    {
        return NEXT & (1u << 0u);
    }

    /**
     * Get all of NEXT's bit fields.
     *
     * (read-write) Next Frame Pointer
     */
    inline void get_NEXT(uint32_t &POINTER, bool &ENABLED) volatile
    {
        uint32_t curr = NEXT;

        POINTER = (curr >> 2u) & 0b111111111111111111111111111111u;
        ENABLED = curr & (1u << 0u);
    }

    /**
     * Get PORTER_DUFF_CTRL's S1_GLOBAL_ALPHA field.
     *
     * s1 global alpha
     */
    inline uint8_t get_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA() volatile
    {
        return (PORTER_DUFF_CTRL >> 24u) & 0b11111111u;
    }

    /**
     * Set PORTER_DUFF_CTRL's S1_GLOBAL_ALPHA field.
     *
     * s1 global alpha
     */
    inline void set_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11111111u << 24u);
        curr |= (value & 0b11111111u) << 24u;

        PORTER_DUFF_CTRL = curr;
    }

    /**
     * Get PORTER_DUFF_CTRL's S0_GLOBAL_ALPHA field.
     *
     * s0 global alpha
     */
    inline uint8_t get_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA() volatile
    {
        return (PORTER_DUFF_CTRL >> 16u) & 0b11111111u;
    }

    /**
     * Set PORTER_DUFF_CTRL's S0_GLOBAL_ALPHA field.
     *
     * s0 global alpha
     */
    inline void set_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA(uint8_t value) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        PORTER_DUFF_CTRL = curr;
    }

    /**
     * Get PORTER_DUFF_CTRL's S1_COLOR_MODE bit.
     *
     * s1 color mode
     */
    inline bool get_PORTER_DUFF_CTRL_S1_COLOR_MODE() volatile
    {
        return PORTER_DUFF_CTRL & (1u << 13u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S1_COLOR_MODE bit.
     *
     * s1 color mode
     */
    inline void set_PORTER_DUFF_CTRL_S1_COLOR_MODE() volatile
    {
        PORTER_DUFF_CTRL |= 1u << 13u;
    }

    /**
     * Clear PORTER_DUFF_CTRL's S1_COLOR_MODE bit.
     *
     * s1 color mode
     */
    inline void clear_PORTER_DUFF_CTRL_S1_COLOR_MODE() volatile
    {
        PORTER_DUFF_CTRL &= ~(1u << 13u);
    }

    /**
     * Toggle PORTER_DUFF_CTRL's S1_COLOR_MODE bit.
     *
     * s1 color mode
     */
    inline void toggle_PORTER_DUFF_CTRL_S1_COLOR_MODE() volatile
    {
        PORTER_DUFF_CTRL ^= 1u << 13u;
    }

    /**
     * Get PORTER_DUFF_CTRL's S1_ALPHA_MODE bit.
     *
     * s1 alpha mode (Porter-Duff Alpha mode)
     */
    inline bool get_PORTER_DUFF_CTRL_S1_ALPHA_MODE() volatile
    {
        return PORTER_DUFF_CTRL & (1u << 12u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S1_ALPHA_MODE bit.
     *
     * s1 alpha mode (Porter-Duff Alpha mode)
     */
    inline void set_PORTER_DUFF_CTRL_S1_ALPHA_MODE() volatile
    {
        PORTER_DUFF_CTRL |= 1u << 12u;
    }

    /**
     * Clear PORTER_DUFF_CTRL's S1_ALPHA_MODE bit.
     *
     * s1 alpha mode (Porter-Duff Alpha mode)
     */
    inline void clear_PORTER_DUFF_CTRL_S1_ALPHA_MODE() volatile
    {
        PORTER_DUFF_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle PORTER_DUFF_CTRL's S1_ALPHA_MODE bit.
     *
     * s1 alpha mode (Porter-Duff Alpha mode)
     */
    inline void toggle_PORTER_DUFF_CTRL_S1_ALPHA_MODE() volatile
    {
        PORTER_DUFF_CTRL ^= 1u << 12u;
    }

    /**
     * Get PORTER_DUFF_CTRL's S1_GLOBAL_ALPHA_MODE field.
     *
     * s1 global alpha mode (Porter-Duff Global Alpha mode)
     */
    inline PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE
    get_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE() volatile
    {
        return PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE(
            (PORTER_DUFF_CTRL >> 10u) & 0b11u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S1_GLOBAL_ALPHA_MODE field.
     *
     * s1 global alpha mode (Porter-Duff Global Alpha mode)
     */
    inline void set_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE(
        PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE value) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        PORTER_DUFF_CTRL = curr;
    }

    /**
     * Get PORTER_DUFF_CTRL's S1_S0_FACTOR_MODE field.
     *
     * s1 to s0 factor mode (Porter-Duff factor mode)
     */
    inline PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE
    get_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE() volatile
    {
        return PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE(
            (PORTER_DUFF_CTRL >> 8u) & 0b11u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S1_S0_FACTOR_MODE field.
     *
     * s1 to s0 factor mode (Porter-Duff factor mode)
     */
    inline void set_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE(
        PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE value) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        PORTER_DUFF_CTRL = curr;
    }

    /**
     * Get PORTER_DUFF_CTRL's S0_COLOR_MODE bit.
     *
     * s0 color mode (Porter-Duff color mode)
     */
    inline bool get_PORTER_DUFF_CTRL_S0_COLOR_MODE() volatile
    {
        return PORTER_DUFF_CTRL & (1u << 6u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S0_COLOR_MODE bit.
     *
     * s0 color mode (Porter-Duff color mode)
     */
    inline void set_PORTER_DUFF_CTRL_S0_COLOR_MODE() volatile
    {
        PORTER_DUFF_CTRL |= 1u << 6u;
    }

    /**
     * Clear PORTER_DUFF_CTRL's S0_COLOR_MODE bit.
     *
     * s0 color mode (Porter-Duff color mode)
     */
    inline void clear_PORTER_DUFF_CTRL_S0_COLOR_MODE() volatile
    {
        PORTER_DUFF_CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle PORTER_DUFF_CTRL's S0_COLOR_MODE bit.
     *
     * s0 color mode (Porter-Duff color mode)
     */
    inline void toggle_PORTER_DUFF_CTRL_S0_COLOR_MODE() volatile
    {
        PORTER_DUFF_CTRL ^= 1u << 6u;
    }

    /**
     * Get PORTER_DUFF_CTRL's S0_ALPHA_MODE bit.
     *
     * s0 alpha mode (Porter-Duff alpha mode)
     */
    inline bool get_PORTER_DUFF_CTRL_S0_ALPHA_MODE() volatile
    {
        return PORTER_DUFF_CTRL & (1u << 5u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S0_ALPHA_MODE bit.
     *
     * s0 alpha mode (Porter-Duff alpha mode)
     */
    inline void set_PORTER_DUFF_CTRL_S0_ALPHA_MODE() volatile
    {
        PORTER_DUFF_CTRL |= 1u << 5u;
    }

    /**
     * Clear PORTER_DUFF_CTRL's S0_ALPHA_MODE bit.
     *
     * s0 alpha mode (Porter-Duff alpha mode)
     */
    inline void clear_PORTER_DUFF_CTRL_S0_ALPHA_MODE() volatile
    {
        PORTER_DUFF_CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle PORTER_DUFF_CTRL's S0_ALPHA_MODE bit.
     *
     * s0 alpha mode (Porter-Duff alpha mode)
     */
    inline void toggle_PORTER_DUFF_CTRL_S0_ALPHA_MODE() volatile
    {
        PORTER_DUFF_CTRL ^= 1u << 5u;
    }

    /**
     * Get PORTER_DUFF_CTRL's S0_GLOBAL_ALPHA_MODE field.
     *
     * s0 global alpha mode
     */
    inline PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE
    get_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE() volatile
    {
        return PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE(
            (PORTER_DUFF_CTRL >> 3u) & 0b11u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S0_GLOBAL_ALPHA_MODE field.
     *
     * s0 global alpha mode
     */
    inline void set_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE(
        PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE value) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11u << 3u);
        curr |= (std::to_underlying(value) & 0b11u) << 3u;

        PORTER_DUFF_CTRL = curr;
    }

    /**
     * Get PORTER_DUFF_CTRL's S0_S1_FACTOR_MODE field.
     *
     * s0 to s1 factor mode
     */
    inline PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE
    get_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE() volatile
    {
        return PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE(
            (PORTER_DUFF_CTRL >> 1u) & 0b11u);
    }

    /**
     * Set PORTER_DUFF_CTRL's S0_S1_FACTOR_MODE field.
     *
     * s0 to s1 factor mode
     */
    inline void set_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE(
        PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE value) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        PORTER_DUFF_CTRL = curr;
    }

    /**
     * Get PORTER_DUFF_CTRL's PORTER_DUFF_ENABLE bit.
     *
     * Porter-Duff Enable
     */
    inline bool get_PORTER_DUFF_CTRL_PORTER_DUFF_ENABLE() volatile
    {
        return PORTER_DUFF_CTRL & (1u << 0u);
    }

    /**
     * Set PORTER_DUFF_CTRL's PORTER_DUFF_ENABLE bit.
     *
     * Porter-Duff Enable
     */
    inline void set_PORTER_DUFF_CTRL_PORTER_DUFF_ENABLE() volatile
    {
        PORTER_DUFF_CTRL |= 1u << 0u;
    }

    /**
     * Clear PORTER_DUFF_CTRL's PORTER_DUFF_ENABLE bit.
     *
     * Porter-Duff Enable
     */
    inline void clear_PORTER_DUFF_CTRL_PORTER_DUFF_ENABLE() volatile
    {
        PORTER_DUFF_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle PORTER_DUFF_CTRL's PORTER_DUFF_ENABLE bit.
     *
     * Porter-Duff Enable
     */
    inline void toggle_PORTER_DUFF_CTRL_PORTER_DUFF_ENABLE() volatile
    {
        PORTER_DUFF_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of PORTER_DUFF_CTRL's bit fields.
     *
     * (read-write) PXP Alpha Engine A Control Register.
     */
    inline void get_PORTER_DUFF_CTRL(
        uint8_t &S1_GLOBAL_ALPHA, uint8_t &S0_GLOBAL_ALPHA,
        bool &S1_COLOR_MODE, bool &S1_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE &S1_GLOBAL_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE &S1_S0_FACTOR_MODE,
        bool &S0_COLOR_MODE, bool &S0_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE &S0_GLOBAL_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE &S0_S1_FACTOR_MODE,
        bool &PORTER_DUFF_ENABLE) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        S1_GLOBAL_ALPHA = (curr >> 24u) & 0b11111111u;
        S0_GLOBAL_ALPHA = (curr >> 16u) & 0b11111111u;
        S1_COLOR_MODE = curr & (1u << 13u);
        S1_ALPHA_MODE = curr & (1u << 12u);
        S1_GLOBAL_ALPHA_MODE =
            PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE((curr >> 10u) & 0b11u);
        S1_S0_FACTOR_MODE =
            PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE((curr >> 8u) & 0b11u);
        S0_COLOR_MODE = curr & (1u << 6u);
        S0_ALPHA_MODE = curr & (1u << 5u);
        S0_GLOBAL_ALPHA_MODE =
            PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE((curr >> 3u) & 0b11u);
        S0_S1_FACTOR_MODE =
            PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE((curr >> 1u) & 0b11u);
        PORTER_DUFF_ENABLE = curr & (1u << 0u);
    }

    /**
     * Set all of PORTER_DUFF_CTRL's bit fields.
     *
     * (read-write) PXP Alpha Engine A Control Register.
     */
    inline void set_PORTER_DUFF_CTRL(
        uint8_t S1_GLOBAL_ALPHA, uint8_t S0_GLOBAL_ALPHA, bool S1_COLOR_MODE,
        bool S1_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE S1_GLOBAL_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE S1_S0_FACTOR_MODE,
        bool S0_COLOR_MODE, bool S0_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE S0_GLOBAL_ALPHA_MODE,
        PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE S0_S1_FACTOR_MODE,
        bool PORTER_DUFF_ENABLE) volatile
    {
        uint32_t curr = PORTER_DUFF_CTRL;

        curr &= ~(0b11111111u << 24u);
        curr |= (S1_GLOBAL_ALPHA & 0b11111111u) << 24u;
        curr &= ~(0b11111111u << 16u);
        curr |= (S0_GLOBAL_ALPHA & 0b11111111u) << 16u;
        curr &= ~(0b1u << 13u);
        curr |= (S1_COLOR_MODE & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (S1_ALPHA_MODE & 0b1u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(S1_GLOBAL_ALPHA_MODE) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(S1_S0_FACTOR_MODE) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (S0_COLOR_MODE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (S0_ALPHA_MODE & 0b1u) << 5u;
        curr &= ~(0b11u << 3u);
        curr |= (std::to_underlying(S0_GLOBAL_ALPHA_MODE) & 0b11u) << 3u;
        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(S0_S1_FACTOR_MODE) & 0b11u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PORTER_DUFF_ENABLE & 0b1u) << 0u;

        PORTER_DUFF_CTRL = curr;
    }
};

static_assert(sizeof(pxp) == pxp::size);

static volatile pxp *const PXP = reinterpret_cast<pxp *>(0x40814000);

}; // namespace MIMXRT1176::CM7
