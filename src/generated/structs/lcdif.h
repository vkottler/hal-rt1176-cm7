/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_CLR_ODD_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_CLR_OUTSTANDING_REQS.h"
#include "../enums/LCDIF_CTRL2_EVEN_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_ODD_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_OUTSTANDING_REQS.h"
#include "../enums/LCDIF_CTRL2_SET_EVEN_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_SET_ODD_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_SET_OUTSTANDING_REQS.h"
#include "../enums/LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_TOG_ODD_LINE_PATTERN.h"
#include "../enums/LCDIF_CTRL2_TOG_OUTSTANDING_REQS.h"
#include "../enums/LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH.h"
#include "../enums/LCDIF_CTRL_CLR_WORD_LENGTH.h"
#include "../enums/LCDIF_CTRL_CSC_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_INPUT_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_LCD_DATABUS_WIDTH.h"
#include "../enums/LCDIF_CTRL_SET_CSC_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_SET_LCD_DATABUS_WIDTH.h"
#include "../enums/LCDIF_CTRL_SET_WORD_LENGTH.h"
#include "../enums/LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE.h"
#include "../enums/LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH.h"
#include "../enums/LCDIF_CTRL_TOG_WORD_LENGTH.h"
#include "../enums/LCDIF_CTRL_WORD_LENGTH.h"
#include "../enums/LCDIF_PIGEON_0_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_0_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_0_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_0_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_0_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_0_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_0_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_10_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_10_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_10_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_10_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_10_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_10_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_10_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_11_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_11_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_11_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_11_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_11_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_11_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_11_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_1_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_1_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_1_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_1_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_1_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_1_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_1_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_2_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_2_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_2_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_2_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_2_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_2_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_2_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_3_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_3_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_3_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_3_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_3_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_3_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_3_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_4_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_4_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_4_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_4_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_4_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_4_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_4_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_5_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_5_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_5_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_5_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_5_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_5_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_5_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_6_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_6_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_6_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_6_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_6_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_6_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_6_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_7_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_7_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_7_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_7_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_7_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_7_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_7_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_8_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_8_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_8_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_8_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_8_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_8_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_8_2_SIG_LOGIC.h"
#include "../enums/LCDIF_PIGEON_9_0_INC_SEL.h"
#include "../enums/LCDIF_PIGEON_9_0_MASK_CNT_SEL.h"
#include "../enums/LCDIF_PIGEON_9_0_STATE_MASK.h"
#include "../enums/LCDIF_PIGEON_9_1_CLR_CNT.h"
#include "../enums/LCDIF_PIGEON_9_1_SET_CNT.h"
#include "../enums/LCDIF_PIGEON_9_2_SIG_ANOTHER.h"
#include "../enums/LCDIF_PIGEON_9_2_SIG_LOGIC.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * LCDIF Register Reference Index
 */
struct [[gnu::packed]] lcdif
{
    /* Constant attributes. */
    static constexpr std::size_t size = 2884; /*!< lcdif's size in bytes. */

    /* Fields. */
    uint32_t CTRL;      /*!< (read-write) LCDIF General Control Register */
    uint32_t CTRL_SET;  /*!< (read-write) LCDIF General Control Register */
    uint32_t CTRL_CLR;  /*!< (read-write) LCDIF General Control Register */
    uint32_t CTRL_TOG;  /*!< (read-write) LCDIF General Control Register */
    uint32_t CTRL1;     /*!< (read-write) LCDIF General Control1 Register */
    uint32_t CTRL1_SET; /*!< (read-write) LCDIF General Control1 Register */
    uint32_t CTRL1_CLR; /*!< (read-write) LCDIF General Control1 Register */
    uint32_t CTRL1_TOG; /*!< (read-write) LCDIF General Control1 Register */
    uint32_t CTRL2;     /*!< (read-write) LCDIF General Control2 Register */
    uint32_t CTRL2_SET; /*!< (read-write) LCDIF General Control2 Register */
    uint32_t CTRL2_CLR; /*!< (read-write) LCDIF General Control2 Register */
    uint32_t CTRL2_TOG; /*!< (read-write) LCDIF General Control2 Register */
    uint32_t TRANSFER_COUNT; /*!< (read-write) LCDIF Horizontal and Vertical
                                Valid Data Count Register */
    static constexpr std::size_t reserved_padding0_length = 3;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t CUR_BUF; /*!< (read-write) LCD Interface Current Buffer Address
                         Register */
    static constexpr std::size_t reserved_padding1_length = 3;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t NEXT_BUF; /*!< (read-write) LCD Interface Next Buffer Address
                          Register */
    static constexpr std::size_t reserved_padding2_length = 7;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t VDCTRL0;     /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                             Control Register0 */
    uint32_t VDCTRL0_SET; /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                             Control Register0 */
    uint32_t VDCTRL0_CLR; /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                             Control Register0 */
    uint32_t VDCTRL0_TOG; /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                             Control Register0 */
    uint32_t VDCTRL1;     /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                             Control Register1 */
    static constexpr std::size_t reserved_padding3_length = 3;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t VDCTRL2; /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                         Control Register2 */
    static constexpr std::size_t reserved_padding4_length = 3;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t VDCTRL3; /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                         Control Register3 */
    static constexpr std::size_t reserved_padding5_length = 3;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t VDCTRL4; /*!< (read-write) LCDIF VSYNC Mode and Dotclk Mode
                         Control Register4 */
    static constexpr std::size_t reserved_padding6_length = 55;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t
        BM_ERROR_STAT; /*!< (read-write) Bus Master Error Status Register */
    static constexpr std::size_t reserved_padding7_length = 3;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t CRC_STAT; /*!< (read-write) CRC Status Register */
    static constexpr std::size_t reserved_padding8_length = 3;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t STAT; /*!< (read-write) LCD Interface Status Register */
    static constexpr std::size_t reserved_padding9_length = 19;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t THRES; /*!< (read-write) LCDIF Threshold Register */
    static constexpr std::size_t reserved_padding10_length = 95;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t
        PIGEONCTRL0; /*!< (read-write) LCDIF Pigeon Mode Control0 Register */
    uint32_t PIGEONCTRL0_SET; /*!< (read-write) LCDIF Pigeon Mode Control0
                                 Register */
    uint32_t PIGEONCTRL0_CLR; /*!< (read-write) LCDIF Pigeon Mode Control0
                                 Register */
    uint32_t PIGEONCTRL0_TOG; /*!< (read-write) LCDIF Pigeon Mode Control0
                                 Register */
    uint32_t
        PIGEONCTRL1; /*!< (read-write) LCDIF Pigeon Mode Control1 Register */
    uint32_t PIGEONCTRL1_SET; /*!< (read-write) LCDIF Pigeon Mode Control1
                                 Register */
    uint32_t PIGEONCTRL1_CLR; /*!< (read-write) LCDIF Pigeon Mode Control1
                                 Register */
    uint32_t PIGEONCTRL1_TOG; /*!< (read-write) LCDIF Pigeon Mode Control1
                                 Register */
    uint32_t
        PIGEONCTRL2; /*!< (read-write) LCDIF Pigeon Mode Control2 Register */
    uint32_t PIGEONCTRL2_SET; /*!< (read-write) LCDIF Pigeon Mode Control2
                                 Register */
    uint32_t PIGEONCTRL2_CLR; /*!< (read-write) LCDIF Pigeon Mode Control2
                                 Register */
    uint32_t PIGEONCTRL2_TOG; /*!< (read-write) LCDIF Pigeon Mode Control2
                                 Register */
    static constexpr std::size_t reserved_padding11_length = 276;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t PIGEON_0_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding12_length = 3;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t PIGEON_0_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding13_length = 3;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t PIGEON_0_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding14_length = 7;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t PIGEON_1_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding15_length = 3;
    const uint32_t reserved_padding15[reserved_padding15_length] = {};
    uint32_t PIGEON_1_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding16_length = 3;
    const uint32_t reserved_padding16[reserved_padding16_length] = {};
    uint32_t PIGEON_1_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding17_length = 7;
    const uint32_t reserved_padding17[reserved_padding17_length] = {};
    uint32_t PIGEON_2_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding18_length = 3;
    const uint32_t reserved_padding18[reserved_padding18_length] = {};
    uint32_t PIGEON_2_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding19_length = 3;
    const uint32_t reserved_padding19[reserved_padding19_length] = {};
    uint32_t PIGEON_2_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding20_length = 7;
    const uint32_t reserved_padding20[reserved_padding20_length] = {};
    uint32_t PIGEON_3_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding21_length = 3;
    const uint32_t reserved_padding21[reserved_padding21_length] = {};
    uint32_t PIGEON_3_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding22_length = 3;
    const uint32_t reserved_padding22[reserved_padding22_length] = {};
    uint32_t PIGEON_3_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding23_length = 7;
    const uint32_t reserved_padding23[reserved_padding23_length] = {};
    uint32_t PIGEON_4_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding24_length = 3;
    const uint32_t reserved_padding24[reserved_padding24_length] = {};
    uint32_t PIGEON_4_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding25_length = 3;
    const uint32_t reserved_padding25[reserved_padding25_length] = {};
    uint32_t PIGEON_4_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding26_length = 7;
    const uint32_t reserved_padding26[reserved_padding26_length] = {};
    uint32_t PIGEON_5_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding27_length = 3;
    const uint32_t reserved_padding27[reserved_padding27_length] = {};
    uint32_t PIGEON_5_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding28_length = 3;
    const uint32_t reserved_padding28[reserved_padding28_length] = {};
    uint32_t PIGEON_5_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding29_length = 7;
    const uint32_t reserved_padding29[reserved_padding29_length] = {};
    uint32_t PIGEON_6_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding30_length = 3;
    const uint32_t reserved_padding30[reserved_padding30_length] = {};
    uint32_t PIGEON_6_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding31_length = 3;
    const uint32_t reserved_padding31[reserved_padding31_length] = {};
    uint32_t PIGEON_6_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding32_length = 7;
    const uint32_t reserved_padding32[reserved_padding32_length] = {};
    uint32_t PIGEON_7_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding33_length = 3;
    const uint32_t reserved_padding33[reserved_padding33_length] = {};
    uint32_t PIGEON_7_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding34_length = 3;
    const uint32_t reserved_padding34[reserved_padding34_length] = {};
    uint32_t PIGEON_7_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding35_length = 7;
    const uint32_t reserved_padding35[reserved_padding35_length] = {};
    uint32_t PIGEON_8_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding36_length = 3;
    const uint32_t reserved_padding36[reserved_padding36_length] = {};
    uint32_t PIGEON_8_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding37_length = 3;
    const uint32_t reserved_padding37[reserved_padding37_length] = {};
    uint32_t PIGEON_8_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding38_length = 7;
    const uint32_t reserved_padding38[reserved_padding38_length] = {};
    uint32_t PIGEON_9_0; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding39_length = 3;
    const uint32_t reserved_padding39[reserved_padding39_length] = {};
    uint32_t PIGEON_9_1; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding40_length = 3;
    const uint32_t reserved_padding40[reserved_padding40_length] = {};
    uint32_t PIGEON_9_2; /*!< (read-write) Panel Interface Signal Generator
                            Register */
    static constexpr std::size_t reserved_padding41_length = 7;
    const uint32_t reserved_padding41[reserved_padding41_length] = {};
    uint32_t PIGEON_10_0; /*!< (read-write) Panel Interface Signal Generator
                             Register */
    static constexpr std::size_t reserved_padding42_length = 3;
    const uint32_t reserved_padding42[reserved_padding42_length] = {};
    uint32_t PIGEON_10_1; /*!< (read-write) Panel Interface Signal Generator
                             Register */
    static constexpr std::size_t reserved_padding43_length = 3;
    const uint32_t reserved_padding43[reserved_padding43_length] = {};
    uint32_t PIGEON_10_2; /*!< (read-write) Panel Interface Signal Generator
                             Register */
    static constexpr std::size_t reserved_padding44_length = 7;
    const uint32_t reserved_padding44[reserved_padding44_length] = {};
    uint32_t PIGEON_11_0; /*!< (read-write) Panel Interface Signal Generator
                             Register */
    static constexpr std::size_t reserved_padding45_length = 3;
    const uint32_t reserved_padding45[reserved_padding45_length] = {};
    uint32_t PIGEON_11_1; /*!< (read-write) Panel Interface Signal Generator
                             Register */
    static constexpr std::size_t reserved_padding46_length = 3;
    const uint32_t reserved_padding46[reserved_padding46_length] = {};
    uint32_t PIGEON_11_2; /*!< (read-write) Panel Interface Signal Generator
                             Register */
    static constexpr std::size_t reserved_padding47_length = 7;
    const uint32_t reserved_padding47[reserved_padding47_length] = {};
    uint32_t LUT_CTRL; /*!< (read-write) Look Up Table Control Register */
    static constexpr std::size_t reserved_padding48_length = 3;
    const uint32_t reserved_padding48[reserved_padding48_length] = {};
    uint32_t LUT0_ADDR; /*!< (read-write) Lookup Table 0 Index Register */
    static constexpr std::size_t reserved_padding49_length = 3;
    const uint32_t reserved_padding49[reserved_padding49_length] = {};
    uint32_t LUT0_DATA; /*!< (read-write) Lookup Table 0 Data Register */
    static constexpr std::size_t reserved_padding50_length = 3;
    const uint32_t reserved_padding50[reserved_padding50_length] = {};
    uint32_t LUT1_ADDR; /*!< (read-write) Lookup Table 1 Index Register */
    static constexpr std::size_t reserved_padding51_length = 3;
    const uint32_t reserved_padding51[reserved_padding51_length] = {};
    uint32_t LUT1_DATA; /*!< (read-write) Lookup Table 1 Data Register */

    /* Methods. */

    /**
     * Get CTRL's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline bool get_CTRL_SFTRST() volatile
    {
        return CTRL & (1u << 31u);
    }

    /**
     * Set CTRL's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void set_CTRL_SFTRST() volatile
    {
        CTRL |= 1u << 31u;
    }

    /**
     * Clear CTRL's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void clear_CTRL_SFTRST() volatile
    {
        CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void toggle_CTRL_SFTRST() volatile
    {
        CTRL ^= 1u << 31u;
    }

    /**
     * Get CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_CLKGATE() volatile
    {
        return CTRL & (1u << 30u);
    }

    /**
     * Set CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_CLKGATE() volatile
    {
        CTRL |= 1u << 30u;
    }

    /**
     * Clear CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_CLKGATE() volatile
    {
        CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_CLKGATE() volatile
    {
        CTRL ^= 1u << 30u;
    }

    /**
     * Get CTRL's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline bool get_CTRL_DATA_SHIFT_DIR() volatile
    {
        return CTRL & (1u << 26u);
    }

    /**
     * Set CTRL's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void set_CTRL_DATA_SHIFT_DIR() volatile
    {
        CTRL |= 1u << 26u;
    }

    /**
     * Clear CTRL's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void clear_CTRL_DATA_SHIFT_DIR() volatile
    {
        CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void toggle_CTRL_DATA_SHIFT_DIR() volatile
    {
        CTRL ^= 1u << 26u;
    }

    /**
     * Get CTRL's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline uint8_t get_CTRL_SHIFT_NUM_BITS() volatile
    {
        return (CTRL >> 21u) & 0b11111u;
    }

    /**
     * Set CTRL's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline void set_CTRL_SHIFT_NUM_BITS(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11111u << 21u);
        curr |= (value & 0b11111u) << 21u;

        CTRL = curr;
    }

    /**
     * Get CTRL's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline bool get_CTRL_BYPASS_COUNT() volatile
    {
        return CTRL & (1u << 19u);
    }

    /**
     * Set CTRL's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void set_CTRL_BYPASS_COUNT() volatile
    {
        CTRL |= 1u << 19u;
    }

    /**
     * Clear CTRL's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void clear_CTRL_BYPASS_COUNT() volatile
    {
        CTRL &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void toggle_CTRL_BYPASS_COUNT() volatile
    {
        CTRL ^= 1u << 19u;
    }

    /**
     * Get CTRL's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline bool get_CTRL_DOTCLK_MODE() volatile
    {
        return CTRL & (1u << 17u);
    }

    /**
     * Set CTRL's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void set_CTRL_DOTCLK_MODE() volatile
    {
        CTRL |= 1u << 17u;
    }

    /**
     * Clear CTRL's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void clear_CTRL_DOTCLK_MODE() volatile
    {
        CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void toggle_CTRL_DOTCLK_MODE() volatile
    {
        CTRL ^= 1u << 17u;
    }

    /**
     * Get CTRL's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline LCDIF_CTRL_INPUT_DATA_SWIZZLE get_CTRL_INPUT_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_INPUT_DATA_SWIZZLE((CTRL >> 14u) & 0b11u);
    }

    /**
     * Set CTRL's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline void set_CTRL_INPUT_DATA_SWIZZLE(
        LCDIF_CTRL_INPUT_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CTRL = curr;
    }

    /**
     * Get CTRL's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline LCDIF_CTRL_CSC_DATA_SWIZZLE get_CTRL_CSC_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_CSC_DATA_SWIZZLE((CTRL >> 12u) & 0b11u);
    }

    /**
     * Set CTRL's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline void set_CTRL_CSC_DATA_SWIZZLE(
        LCDIF_CTRL_CSC_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CTRL = curr;
    }

    /**
     * Get CTRL's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline LCDIF_CTRL_LCD_DATABUS_WIDTH get_CTRL_LCD_DATABUS_WIDTH() volatile
    {
        return LCDIF_CTRL_LCD_DATABUS_WIDTH((CTRL >> 10u) & 0b11u);
    }

    /**
     * Set CTRL's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline void set_CTRL_LCD_DATABUS_WIDTH(
        LCDIF_CTRL_LCD_DATABUS_WIDTH value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CTRL = curr;
    }

    /**
     * Get CTRL's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline LCDIF_CTRL_WORD_LENGTH get_CTRL_WORD_LENGTH() volatile
    {
        return LCDIF_CTRL_WORD_LENGTH((CTRL >> 8u) & 0b11u);
    }

    /**
     * Set CTRL's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline void set_CTRL_WORD_LENGTH(LCDIF_CTRL_WORD_LENGTH value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL = curr;
    }

    /**
     * Get CTRL's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline bool get_CTRL_ENABLE_PXP_HANDSHAKE() volatile
    {
        return CTRL & (1u << 6u);
    }

    /**
     * Set CTRL's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void set_CTRL_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL |= 1u << 6u;
    }

    /**
     * Clear CTRL's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void clear_CTRL_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void toggle_CTRL_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL ^= 1u << 6u;
    }

    /**
     * Get CTRL's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline bool get_CTRL_MASTER() volatile
    {
        return CTRL & (1u << 5u);
    }

    /**
     * Set CTRL's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void set_CTRL_MASTER() volatile
    {
        CTRL |= 1u << 5u;
    }

    /**
     * Clear CTRL's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void clear_CTRL_MASTER() volatile
    {
        CTRL &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void toggle_CTRL_MASTER() volatile
    {
        CTRL ^= 1u << 5u;
    }

    /**
     * Get CTRL's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline bool get_CTRL_DATA_FORMAT_16_BIT() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void set_CTRL_DATA_FORMAT_16_BIT() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void clear_CTRL_DATA_FORMAT_16_BIT() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void toggle_CTRL_DATA_FORMAT_16_BIT() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get CTRL's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline bool get_CTRL_DATA_FORMAT_18_BIT() volatile
    {
        return CTRL & (1u << 2u);
    }

    /**
     * Set CTRL's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void set_CTRL_DATA_FORMAT_18_BIT() volatile
    {
        CTRL |= 1u << 2u;
    }

    /**
     * Clear CTRL's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void clear_CTRL_DATA_FORMAT_18_BIT() volatile
    {
        CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void toggle_CTRL_DATA_FORMAT_18_BIT() volatile
    {
        CTRL ^= 1u << 2u;
    }

    /**
     * Get CTRL's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline bool get_CTRL_DATA_FORMAT_24_BIT() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void set_CTRL_DATA_FORMAT_24_BIT() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void clear_CTRL_DATA_FORMAT_24_BIT() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void toggle_CTRL_DATA_FORMAT_24_BIT() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline bool get_CTRL_RUN() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void set_CTRL_RUN() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void clear_CTRL_RUN() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void toggle_CTRL_RUN() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void get_CTRL(bool &SFTRST, bool &CLKGATE, bool &DATA_SHIFT_DIR,
                         uint8_t &SHIFT_NUM_BITS, bool &BYPASS_COUNT,
                         bool &DOTCLK_MODE,
                         LCDIF_CTRL_INPUT_DATA_SWIZZLE &INPUT_DATA_SWIZZLE,
                         LCDIF_CTRL_CSC_DATA_SWIZZLE &CSC_DATA_SWIZZLE,
                         LCDIF_CTRL_LCD_DATABUS_WIDTH &LCD_DATABUS_WIDTH,
                         LCDIF_CTRL_WORD_LENGTH &WORD_LENGTH,
                         bool &ENABLE_PXP_HANDSHAKE, bool &MASTER,
                         bool &DATA_FORMAT_16_BIT, bool &DATA_FORMAT_18_BIT,
                         bool &DATA_FORMAT_24_BIT, bool &RUN) volatile
    {
        uint32_t curr = CTRL;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        DATA_SHIFT_DIR = curr & (1u << 26u);
        SHIFT_NUM_BITS = (curr >> 21u) & 0b11111u;
        BYPASS_COUNT = curr & (1u << 19u);
        DOTCLK_MODE = curr & (1u << 17u);
        INPUT_DATA_SWIZZLE =
            LCDIF_CTRL_INPUT_DATA_SWIZZLE((curr >> 14u) & 0b11u);
        CSC_DATA_SWIZZLE = LCDIF_CTRL_CSC_DATA_SWIZZLE((curr >> 12u) & 0b11u);
        LCD_DATABUS_WIDTH =
            LCDIF_CTRL_LCD_DATABUS_WIDTH((curr >> 10u) & 0b11u);
        WORD_LENGTH = LCDIF_CTRL_WORD_LENGTH((curr >> 8u) & 0b11u);
        ENABLE_PXP_HANDSHAKE = curr & (1u << 6u);
        MASTER = curr & (1u << 5u);
        DATA_FORMAT_16_BIT = curr & (1u << 3u);
        DATA_FORMAT_18_BIT = curr & (1u << 2u);
        DATA_FORMAT_24_BIT = curr & (1u << 1u);
        RUN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void set_CTRL(bool SFTRST, bool CLKGATE, bool DATA_SHIFT_DIR,
                         uint8_t SHIFT_NUM_BITS, bool BYPASS_COUNT,
                         bool DOTCLK_MODE,
                         LCDIF_CTRL_INPUT_DATA_SWIZZLE INPUT_DATA_SWIZZLE,
                         LCDIF_CTRL_CSC_DATA_SWIZZLE CSC_DATA_SWIZZLE,
                         LCDIF_CTRL_LCD_DATABUS_WIDTH LCD_DATABUS_WIDTH,
                         LCDIF_CTRL_WORD_LENGTH WORD_LENGTH,
                         bool ENABLE_PXP_HANDSHAKE, bool MASTER,
                         bool DATA_FORMAT_16_BIT, bool DATA_FORMAT_18_BIT,
                         bool DATA_FORMAT_24_BIT, bool RUN) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (DATA_SHIFT_DIR & 0b1u) << 26u;
        curr &= ~(0b11111u << 21u);
        curr |= (SHIFT_NUM_BITS & 0b11111u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (BYPASS_COUNT & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DOTCLK_MODE & 0b1u) << 17u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(INPUT_DATA_SWIZZLE) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(CSC_DATA_SWIZZLE) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(LCD_DATABUS_WIDTH) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(WORD_LENGTH) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (ENABLE_PXP_HANDSHAKE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MASTER & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (DATA_FORMAT_16_BIT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DATA_FORMAT_18_BIT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DATA_FORMAT_24_BIT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RUN & 0b1u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL_SET's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline bool get_CTRL_SET_SFTRST() volatile
    {
        return CTRL_SET & (1u << 31u);
    }

    /**
     * Set CTRL_SET's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void set_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET |= 1u << 31u;
    }

    /**
     * Clear CTRL_SET's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void clear_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_SET's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void toggle_CTRL_SET_SFTRST() volatile
    {
        CTRL_SET ^= 1u << 31u;
    }

    /**
     * Get CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_SET_CLKGATE() volatile
    {
        return CTRL_SET & (1u << 30u);
    }

    /**
     * Set CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET |= 1u << 30u;
    }

    /**
     * Clear CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_SET's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_SET_CLKGATE() volatile
    {
        CTRL_SET ^= 1u << 30u;
    }

    /**
     * Get CTRL_SET's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline bool get_CTRL_SET_DATA_SHIFT_DIR() volatile
    {
        return CTRL_SET & (1u << 26u);
    }

    /**
     * Set CTRL_SET's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void set_CTRL_SET_DATA_SHIFT_DIR() volatile
    {
        CTRL_SET |= 1u << 26u;
    }

    /**
     * Clear CTRL_SET's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void clear_CTRL_SET_DATA_SHIFT_DIR() volatile
    {
        CTRL_SET &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL_SET's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void toggle_CTRL_SET_DATA_SHIFT_DIR() volatile
    {
        CTRL_SET ^= 1u << 26u;
    }

    /**
     * Get CTRL_SET's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline uint8_t get_CTRL_SET_SHIFT_NUM_BITS() volatile
    {
        return (CTRL_SET >> 21u) & 0b11111u;
    }

    /**
     * Set CTRL_SET's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline void set_CTRL_SET_SHIFT_NUM_BITS(uint8_t value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b11111u << 21u);
        curr |= (value & 0b11111u) << 21u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline bool get_CTRL_SET_BYPASS_COUNT() volatile
    {
        return CTRL_SET & (1u << 19u);
    }

    /**
     * Set CTRL_SET's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void set_CTRL_SET_BYPASS_COUNT() volatile
    {
        CTRL_SET |= 1u << 19u;
    }

    /**
     * Clear CTRL_SET's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void clear_CTRL_SET_BYPASS_COUNT() volatile
    {
        CTRL_SET &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL_SET's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void toggle_CTRL_SET_BYPASS_COUNT() volatile
    {
        CTRL_SET ^= 1u << 19u;
    }

    /**
     * Get CTRL_SET's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline bool get_CTRL_SET_DOTCLK_MODE() volatile
    {
        return CTRL_SET & (1u << 17u);
    }

    /**
     * Set CTRL_SET's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void set_CTRL_SET_DOTCLK_MODE() volatile
    {
        CTRL_SET |= 1u << 17u;
    }

    /**
     * Clear CTRL_SET's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void clear_CTRL_SET_DOTCLK_MODE() volatile
    {
        CTRL_SET &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL_SET's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void toggle_CTRL_SET_DOTCLK_MODE() volatile
    {
        CTRL_SET ^= 1u << 17u;
    }

    /**
     * Get CTRL_SET's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE
    get_CTRL_SET_INPUT_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE((CTRL_SET >> 14u) & 0b11u);
    }

    /**
     * Set CTRL_SET's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline void set_CTRL_SET_INPUT_DATA_SWIZZLE(
        LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline LCDIF_CTRL_SET_CSC_DATA_SWIZZLE
    get_CTRL_SET_CSC_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_SET_CSC_DATA_SWIZZLE((CTRL_SET >> 12u) & 0b11u);
    }

    /**
     * Set CTRL_SET's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline void set_CTRL_SET_CSC_DATA_SWIZZLE(
        LCDIF_CTRL_SET_CSC_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline LCDIF_CTRL_SET_LCD_DATABUS_WIDTH
    get_CTRL_SET_LCD_DATABUS_WIDTH() volatile
    {
        return LCDIF_CTRL_SET_LCD_DATABUS_WIDTH((CTRL_SET >> 10u) & 0b11u);
    }

    /**
     * Set CTRL_SET's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline void set_CTRL_SET_LCD_DATABUS_WIDTH(
        LCDIF_CTRL_SET_LCD_DATABUS_WIDTH value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline LCDIF_CTRL_SET_WORD_LENGTH get_CTRL_SET_WORD_LENGTH() volatile
    {
        return LCDIF_CTRL_SET_WORD_LENGTH((CTRL_SET >> 8u) & 0b11u);
    }

    /**
     * Set CTRL_SET's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline void set_CTRL_SET_WORD_LENGTH(
        LCDIF_CTRL_SET_WORD_LENGTH value) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_SET's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline bool get_CTRL_SET_ENABLE_PXP_HANDSHAKE() volatile
    {
        return CTRL_SET & (1u << 6u);
    }

    /**
     * Set CTRL_SET's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void set_CTRL_SET_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_SET |= 1u << 6u;
    }

    /**
     * Clear CTRL_SET's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void clear_CTRL_SET_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_SET &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL_SET's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void toggle_CTRL_SET_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_SET ^= 1u << 6u;
    }

    /**
     * Get CTRL_SET's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline bool get_CTRL_SET_MASTER() volatile
    {
        return CTRL_SET & (1u << 5u);
    }

    /**
     * Set CTRL_SET's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void set_CTRL_SET_MASTER() volatile
    {
        CTRL_SET |= 1u << 5u;
    }

    /**
     * Clear CTRL_SET's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void clear_CTRL_SET_MASTER() volatile
    {
        CTRL_SET &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL_SET's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void toggle_CTRL_SET_MASTER() volatile
    {
        CTRL_SET ^= 1u << 5u;
    }

    /**
     * Get CTRL_SET's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline bool get_CTRL_SET_DATA_FORMAT_16_BIT() volatile
    {
        return CTRL_SET & (1u << 3u);
    }

    /**
     * Set CTRL_SET's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void set_CTRL_SET_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_SET |= 1u << 3u;
    }

    /**
     * Clear CTRL_SET's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void clear_CTRL_SET_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_SET &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL_SET's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void toggle_CTRL_SET_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_SET ^= 1u << 3u;
    }

    /**
     * Get CTRL_SET's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline bool get_CTRL_SET_DATA_FORMAT_18_BIT() volatile
    {
        return CTRL_SET & (1u << 2u);
    }

    /**
     * Set CTRL_SET's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void set_CTRL_SET_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_SET |= 1u << 2u;
    }

    /**
     * Clear CTRL_SET's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void clear_CTRL_SET_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_SET &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_SET's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void toggle_CTRL_SET_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_SET ^= 1u << 2u;
    }

    /**
     * Get CTRL_SET's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline bool get_CTRL_SET_DATA_FORMAT_24_BIT() volatile
    {
        return CTRL_SET & (1u << 1u);
    }

    /**
     * Set CTRL_SET's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void set_CTRL_SET_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_SET |= 1u << 1u;
    }

    /**
     * Clear CTRL_SET's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void clear_CTRL_SET_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_SET &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_SET's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void toggle_CTRL_SET_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_SET ^= 1u << 1u;
    }

    /**
     * Get CTRL_SET's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline bool get_CTRL_SET_RUN() volatile
    {
        return CTRL_SET & (1u << 0u);
    }

    /**
     * Set CTRL_SET's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void set_CTRL_SET_RUN() volatile
    {
        CTRL_SET |= 1u << 0u;
    }

    /**
     * Clear CTRL_SET's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void clear_CTRL_SET_RUN() volatile
    {
        CTRL_SET &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_SET's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void toggle_CTRL_SET_RUN() volatile
    {
        CTRL_SET ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_SET's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void get_CTRL_SET(
        bool &SFTRST, bool &CLKGATE, bool &DATA_SHIFT_DIR,
        uint8_t &SHIFT_NUM_BITS, bool &BYPASS_COUNT, bool &DOTCLK_MODE,
        LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE &INPUT_DATA_SWIZZLE,
        LCDIF_CTRL_SET_CSC_DATA_SWIZZLE &CSC_DATA_SWIZZLE,
        LCDIF_CTRL_SET_LCD_DATABUS_WIDTH &LCD_DATABUS_WIDTH,
        LCDIF_CTRL_SET_WORD_LENGTH &WORD_LENGTH, bool &ENABLE_PXP_HANDSHAKE,
        bool &MASTER, bool &DATA_FORMAT_16_BIT, bool &DATA_FORMAT_18_BIT,
        bool &DATA_FORMAT_24_BIT, bool &RUN) volatile
    {
        uint32_t curr = CTRL_SET;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        DATA_SHIFT_DIR = curr & (1u << 26u);
        SHIFT_NUM_BITS = (curr >> 21u) & 0b11111u;
        BYPASS_COUNT = curr & (1u << 19u);
        DOTCLK_MODE = curr & (1u << 17u);
        INPUT_DATA_SWIZZLE =
            LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE((curr >> 14u) & 0b11u);
        CSC_DATA_SWIZZLE =
            LCDIF_CTRL_SET_CSC_DATA_SWIZZLE((curr >> 12u) & 0b11u);
        LCD_DATABUS_WIDTH =
            LCDIF_CTRL_SET_LCD_DATABUS_WIDTH((curr >> 10u) & 0b11u);
        WORD_LENGTH = LCDIF_CTRL_SET_WORD_LENGTH((curr >> 8u) & 0b11u);
        ENABLE_PXP_HANDSHAKE = curr & (1u << 6u);
        MASTER = curr & (1u << 5u);
        DATA_FORMAT_16_BIT = curr & (1u << 3u);
        DATA_FORMAT_18_BIT = curr & (1u << 2u);
        DATA_FORMAT_24_BIT = curr & (1u << 1u);
        RUN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_SET's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void set_CTRL_SET(
        bool SFTRST, bool CLKGATE, bool DATA_SHIFT_DIR, uint8_t SHIFT_NUM_BITS,
        bool BYPASS_COUNT, bool DOTCLK_MODE,
        LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE INPUT_DATA_SWIZZLE,
        LCDIF_CTRL_SET_CSC_DATA_SWIZZLE CSC_DATA_SWIZZLE,
        LCDIF_CTRL_SET_LCD_DATABUS_WIDTH LCD_DATABUS_WIDTH,
        LCDIF_CTRL_SET_WORD_LENGTH WORD_LENGTH, bool ENABLE_PXP_HANDSHAKE,
        bool MASTER, bool DATA_FORMAT_16_BIT, bool DATA_FORMAT_18_BIT,
        bool DATA_FORMAT_24_BIT, bool RUN) volatile
    {
        uint32_t curr = CTRL_SET;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (DATA_SHIFT_DIR & 0b1u) << 26u;
        curr &= ~(0b11111u << 21u);
        curr |= (SHIFT_NUM_BITS & 0b11111u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (BYPASS_COUNT & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DOTCLK_MODE & 0b1u) << 17u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(INPUT_DATA_SWIZZLE) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(CSC_DATA_SWIZZLE) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(LCD_DATABUS_WIDTH) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(WORD_LENGTH) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (ENABLE_PXP_HANDSHAKE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MASTER & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (DATA_FORMAT_16_BIT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DATA_FORMAT_18_BIT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DATA_FORMAT_24_BIT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RUN & 0b1u) << 0u;

        CTRL_SET = curr;
    }

    /**
     * Get CTRL_CLR's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline bool get_CTRL_CLR_SFTRST() volatile
    {
        return CTRL_CLR & (1u << 31u);
    }

    /**
     * Set CTRL_CLR's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void set_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR |= 1u << 31u;
    }

    /**
     * Clear CTRL_CLR's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void clear_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_CLR's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void toggle_CTRL_CLR_SFTRST() volatile
    {
        CTRL_CLR ^= 1u << 31u;
    }

    /**
     * Get CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_CLR_CLKGATE() volatile
    {
        return CTRL_CLR & (1u << 30u);
    }

    /**
     * Set CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR |= 1u << 30u;
    }

    /**
     * Clear CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_CLR's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_CLR_CLKGATE() volatile
    {
        CTRL_CLR ^= 1u << 30u;
    }

    /**
     * Get CTRL_CLR's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline bool get_CTRL_CLR_DATA_SHIFT_DIR() volatile
    {
        return CTRL_CLR & (1u << 26u);
    }

    /**
     * Set CTRL_CLR's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void set_CTRL_CLR_DATA_SHIFT_DIR() volatile
    {
        CTRL_CLR |= 1u << 26u;
    }

    /**
     * Clear CTRL_CLR's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void clear_CTRL_CLR_DATA_SHIFT_DIR() volatile
    {
        CTRL_CLR &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL_CLR's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void toggle_CTRL_CLR_DATA_SHIFT_DIR() volatile
    {
        CTRL_CLR ^= 1u << 26u;
    }

    /**
     * Get CTRL_CLR's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline uint8_t get_CTRL_CLR_SHIFT_NUM_BITS() volatile
    {
        return (CTRL_CLR >> 21u) & 0b11111u;
    }

    /**
     * Set CTRL_CLR's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline void set_CTRL_CLR_SHIFT_NUM_BITS(uint8_t value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b11111u << 21u);
        curr |= (value & 0b11111u) << 21u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline bool get_CTRL_CLR_BYPASS_COUNT() volatile
    {
        return CTRL_CLR & (1u << 19u);
    }

    /**
     * Set CTRL_CLR's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void set_CTRL_CLR_BYPASS_COUNT() volatile
    {
        CTRL_CLR |= 1u << 19u;
    }

    /**
     * Clear CTRL_CLR's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void clear_CTRL_CLR_BYPASS_COUNT() volatile
    {
        CTRL_CLR &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL_CLR's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void toggle_CTRL_CLR_BYPASS_COUNT() volatile
    {
        CTRL_CLR ^= 1u << 19u;
    }

    /**
     * Get CTRL_CLR's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline bool get_CTRL_CLR_DOTCLK_MODE() volatile
    {
        return CTRL_CLR & (1u << 17u);
    }

    /**
     * Set CTRL_CLR's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void set_CTRL_CLR_DOTCLK_MODE() volatile
    {
        CTRL_CLR |= 1u << 17u;
    }

    /**
     * Clear CTRL_CLR's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void clear_CTRL_CLR_DOTCLK_MODE() volatile
    {
        CTRL_CLR &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL_CLR's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void toggle_CTRL_CLR_DOTCLK_MODE() volatile
    {
        CTRL_CLR ^= 1u << 17u;
    }

    /**
     * Get CTRL_CLR's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE
    get_CTRL_CLR_INPUT_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE((CTRL_CLR >> 14u) & 0b11u);
    }

    /**
     * Set CTRL_CLR's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline void set_CTRL_CLR_INPUT_DATA_SWIZZLE(
        LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE
    get_CTRL_CLR_CSC_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE((CTRL_CLR >> 12u) & 0b11u);
    }

    /**
     * Set CTRL_CLR's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline void set_CTRL_CLR_CSC_DATA_SWIZZLE(
        LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH
    get_CTRL_CLR_LCD_DATABUS_WIDTH() volatile
    {
        return LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH((CTRL_CLR >> 10u) & 0b11u);
    }

    /**
     * Set CTRL_CLR's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline void set_CTRL_CLR_LCD_DATABUS_WIDTH(
        LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline LCDIF_CTRL_CLR_WORD_LENGTH get_CTRL_CLR_WORD_LENGTH() volatile
    {
        return LCDIF_CTRL_CLR_WORD_LENGTH((CTRL_CLR >> 8u) & 0b11u);
    }

    /**
     * Set CTRL_CLR's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline void set_CTRL_CLR_WORD_LENGTH(
        LCDIF_CTRL_CLR_WORD_LENGTH value) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_CLR's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline bool get_CTRL_CLR_ENABLE_PXP_HANDSHAKE() volatile
    {
        return CTRL_CLR & (1u << 6u);
    }

    /**
     * Set CTRL_CLR's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void set_CTRL_CLR_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_CLR |= 1u << 6u;
    }

    /**
     * Clear CTRL_CLR's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void clear_CTRL_CLR_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_CLR &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL_CLR's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void toggle_CTRL_CLR_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_CLR ^= 1u << 6u;
    }

    /**
     * Get CTRL_CLR's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline bool get_CTRL_CLR_MASTER() volatile
    {
        return CTRL_CLR & (1u << 5u);
    }

    /**
     * Set CTRL_CLR's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void set_CTRL_CLR_MASTER() volatile
    {
        CTRL_CLR |= 1u << 5u;
    }

    /**
     * Clear CTRL_CLR's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void clear_CTRL_CLR_MASTER() volatile
    {
        CTRL_CLR &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL_CLR's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void toggle_CTRL_CLR_MASTER() volatile
    {
        CTRL_CLR ^= 1u << 5u;
    }

    /**
     * Get CTRL_CLR's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline bool get_CTRL_CLR_DATA_FORMAT_16_BIT() volatile
    {
        return CTRL_CLR & (1u << 3u);
    }

    /**
     * Set CTRL_CLR's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void set_CTRL_CLR_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_CLR |= 1u << 3u;
    }

    /**
     * Clear CTRL_CLR's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void clear_CTRL_CLR_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_CLR &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL_CLR's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void toggle_CTRL_CLR_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_CLR ^= 1u << 3u;
    }

    /**
     * Get CTRL_CLR's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline bool get_CTRL_CLR_DATA_FORMAT_18_BIT() volatile
    {
        return CTRL_CLR & (1u << 2u);
    }

    /**
     * Set CTRL_CLR's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void set_CTRL_CLR_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_CLR |= 1u << 2u;
    }

    /**
     * Clear CTRL_CLR's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void clear_CTRL_CLR_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_CLR &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_CLR's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void toggle_CTRL_CLR_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_CLR ^= 1u << 2u;
    }

    /**
     * Get CTRL_CLR's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline bool get_CTRL_CLR_DATA_FORMAT_24_BIT() volatile
    {
        return CTRL_CLR & (1u << 1u);
    }

    /**
     * Set CTRL_CLR's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void set_CTRL_CLR_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_CLR |= 1u << 1u;
    }

    /**
     * Clear CTRL_CLR's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void clear_CTRL_CLR_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_CLR's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void toggle_CTRL_CLR_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_CLR ^= 1u << 1u;
    }

    /**
     * Get CTRL_CLR's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline bool get_CTRL_CLR_RUN() volatile
    {
        return CTRL_CLR & (1u << 0u);
    }

    /**
     * Set CTRL_CLR's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void set_CTRL_CLR_RUN() volatile
    {
        CTRL_CLR |= 1u << 0u;
    }

    /**
     * Clear CTRL_CLR's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void clear_CTRL_CLR_RUN() volatile
    {
        CTRL_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_CLR's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void toggle_CTRL_CLR_RUN() volatile
    {
        CTRL_CLR ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_CLR's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void get_CTRL_CLR(
        bool &SFTRST, bool &CLKGATE, bool &DATA_SHIFT_DIR,
        uint8_t &SHIFT_NUM_BITS, bool &BYPASS_COUNT, bool &DOTCLK_MODE,
        LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE &INPUT_DATA_SWIZZLE,
        LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE &CSC_DATA_SWIZZLE,
        LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH &LCD_DATABUS_WIDTH,
        LCDIF_CTRL_CLR_WORD_LENGTH &WORD_LENGTH, bool &ENABLE_PXP_HANDSHAKE,
        bool &MASTER, bool &DATA_FORMAT_16_BIT, bool &DATA_FORMAT_18_BIT,
        bool &DATA_FORMAT_24_BIT, bool &RUN) volatile
    {
        uint32_t curr = CTRL_CLR;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        DATA_SHIFT_DIR = curr & (1u << 26u);
        SHIFT_NUM_BITS = (curr >> 21u) & 0b11111u;
        BYPASS_COUNT = curr & (1u << 19u);
        DOTCLK_MODE = curr & (1u << 17u);
        INPUT_DATA_SWIZZLE =
            LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE((curr >> 14u) & 0b11u);
        CSC_DATA_SWIZZLE =
            LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE((curr >> 12u) & 0b11u);
        LCD_DATABUS_WIDTH =
            LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH((curr >> 10u) & 0b11u);
        WORD_LENGTH = LCDIF_CTRL_CLR_WORD_LENGTH((curr >> 8u) & 0b11u);
        ENABLE_PXP_HANDSHAKE = curr & (1u << 6u);
        MASTER = curr & (1u << 5u);
        DATA_FORMAT_16_BIT = curr & (1u << 3u);
        DATA_FORMAT_18_BIT = curr & (1u << 2u);
        DATA_FORMAT_24_BIT = curr & (1u << 1u);
        RUN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_CLR's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void set_CTRL_CLR(
        bool SFTRST, bool CLKGATE, bool DATA_SHIFT_DIR, uint8_t SHIFT_NUM_BITS,
        bool BYPASS_COUNT, bool DOTCLK_MODE,
        LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE INPUT_DATA_SWIZZLE,
        LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE CSC_DATA_SWIZZLE,
        LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH LCD_DATABUS_WIDTH,
        LCDIF_CTRL_CLR_WORD_LENGTH WORD_LENGTH, bool ENABLE_PXP_HANDSHAKE,
        bool MASTER, bool DATA_FORMAT_16_BIT, bool DATA_FORMAT_18_BIT,
        bool DATA_FORMAT_24_BIT, bool RUN) volatile
    {
        uint32_t curr = CTRL_CLR;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (DATA_SHIFT_DIR & 0b1u) << 26u;
        curr &= ~(0b11111u << 21u);
        curr |= (SHIFT_NUM_BITS & 0b11111u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (BYPASS_COUNT & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DOTCLK_MODE & 0b1u) << 17u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(INPUT_DATA_SWIZZLE) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(CSC_DATA_SWIZZLE) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(LCD_DATABUS_WIDTH) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(WORD_LENGTH) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (ENABLE_PXP_HANDSHAKE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MASTER & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (DATA_FORMAT_16_BIT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DATA_FORMAT_18_BIT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DATA_FORMAT_24_BIT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RUN & 0b1u) << 0u;

        CTRL_CLR = curr;
    }

    /**
     * Get CTRL_TOG's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline bool get_CTRL_TOG_SFTRST() volatile
    {
        return CTRL_TOG & (1u << 31u);
    }

    /**
     * Set CTRL_TOG's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void set_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG |= 1u << 31u;
    }

    /**
     * Clear CTRL_TOG's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void clear_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL_TOG's SFTRST bit.
     *
     * This bit must be set to zero to enable normal operation of the LCDIF
     */
    inline void toggle_CTRL_TOG_SFTRST() volatile
    {
        CTRL_TOG ^= 1u << 31u;
    }

    /**
     * Get CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline bool get_CTRL_TOG_CLKGATE() volatile
    {
        return CTRL_TOG & (1u << 30u);
    }

    /**
     * Set CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void set_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG |= 1u << 30u;
    }

    /**
     * Clear CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void clear_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL_TOG's CLKGATE bit.
     *
     * This bit must be set to zero for normal operation
     */
    inline void toggle_CTRL_TOG_CLKGATE() volatile
    {
        CTRL_TOG ^= 1u << 30u;
    }

    /**
     * Get CTRL_TOG's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline bool get_CTRL_TOG_DATA_SHIFT_DIR() volatile
    {
        return CTRL_TOG & (1u << 26u);
    }

    /**
     * Set CTRL_TOG's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void set_CTRL_TOG_DATA_SHIFT_DIR() volatile
    {
        CTRL_TOG |= 1u << 26u;
    }

    /**
     * Clear CTRL_TOG's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void clear_CTRL_TOG_DATA_SHIFT_DIR() volatile
    {
        CTRL_TOG &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL_TOG's DATA_SHIFT_DIR bit.
     *
     * Use this bit to determine the direction of shift of transmit data.
     */
    inline void toggle_CTRL_TOG_DATA_SHIFT_DIR() volatile
    {
        CTRL_TOG ^= 1u << 26u;
    }

    /**
     * Get CTRL_TOG's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline uint8_t get_CTRL_TOG_SHIFT_NUM_BITS() volatile
    {
        return (CTRL_TOG >> 21u) & 0b11111u;
    }

    /**
     * Set CTRL_TOG's SHIFT_NUM_BITS field.
     *
     * The data to be transmitted is shifted left or right by this number of
     * bits.
     */
    inline void set_CTRL_TOG_SHIFT_NUM_BITS(uint8_t value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b11111u << 21u);
        curr |= (value & 0b11111u) << 21u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline bool get_CTRL_TOG_BYPASS_COUNT() volatile
    {
        return CTRL_TOG & (1u << 19u);
    }

    /**
     * Set CTRL_TOG's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void set_CTRL_TOG_BYPASS_COUNT() volatile
    {
        CTRL_TOG |= 1u << 19u;
    }

    /**
     * Clear CTRL_TOG's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void clear_CTRL_TOG_BYPASS_COUNT() volatile
    {
        CTRL_TOG &= ~(1u << 19u);
    }

    /**
     * Toggle CTRL_TOG's BYPASS_COUNT bit.
     *
     * When this bit is 0, it means that LCDIF will stop the block operation
     * and turn off the RUN bit after the amount of data indicated by the
     * LCDIF_TRANSFER_COUNT register has been transferred out
     */
    inline void toggle_CTRL_TOG_BYPASS_COUNT() volatile
    {
        CTRL_TOG ^= 1u << 19u;
    }

    /**
     * Get CTRL_TOG's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline bool get_CTRL_TOG_DOTCLK_MODE() volatile
    {
        return CTRL_TOG & (1u << 17u);
    }

    /**
     * Set CTRL_TOG's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void set_CTRL_TOG_DOTCLK_MODE() volatile
    {
        CTRL_TOG |= 1u << 17u;
    }

    /**
     * Clear CTRL_TOG's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void clear_CTRL_TOG_DOTCLK_MODE() volatile
    {
        CTRL_TOG &= ~(1u << 17u);
    }

    /**
     * Toggle CTRL_TOG's DOTCLK_MODE bit.
     *
     * Set this bit to 1 to make the hardware go into the DOTCLK mode, i
     */
    inline void toggle_CTRL_TOG_DOTCLK_MODE() volatile
    {
        CTRL_TOG ^= 1u << 17u;
    }

    /**
     * Get CTRL_TOG's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE
    get_CTRL_TOG_INPUT_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE((CTRL_TOG >> 14u) & 0b11u);
    }

    /**
     * Set CTRL_TOG's INPUT_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes fetched by the bus master
     * interface
     */
    inline void set_CTRL_TOG_INPUT_DATA_SWIZZLE(
        LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE
    get_CTRL_TOG_CSC_DATA_SWIZZLE() volatile
    {
        return LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE((CTRL_TOG >> 12u) & 0b11u);
    }

    /**
     * Set CTRL_TOG's CSC_DATA_SWIZZLE field.
     *
     * This field specifies how to swap the bytes after the data has been
     * converted into an internal representation of 24 bits per pixel and
     * before it is transmitted over the LCD interface bus
     */
    inline void set_CTRL_TOG_CSC_DATA_SWIZZLE(
        LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(value) & 0b11u) << 12u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH
    get_CTRL_TOG_LCD_DATABUS_WIDTH() volatile
    {
        return LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH((CTRL_TOG >> 10u) & 0b11u);
    }

    /**
     * Set CTRL_TOG's LCD_DATABUS_WIDTH field.
     *
     * LCD Data bus transfer width. When LUT enabled, this field should be set
     * to 0x01.
     */
    inline void set_CTRL_TOG_LCD_DATABUS_WIDTH(
        LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(value) & 0b11u) << 10u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline LCDIF_CTRL_TOG_WORD_LENGTH get_CTRL_TOG_WORD_LENGTH() volatile
    {
        return LCDIF_CTRL_TOG_WORD_LENGTH((CTRL_TOG >> 8u) & 0b11u);
    }

    /**
     * Set CTRL_TOG's WORD_LENGTH field.
     *
     * Input data format.
     */
    inline void set_CTRL_TOG_WORD_LENGTH(
        LCDIF_CTRL_TOG_WORD_LENGTH value) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(value) & 0b11u) << 8u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL_TOG's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline bool get_CTRL_TOG_ENABLE_PXP_HANDSHAKE() volatile
    {
        return CTRL_TOG & (1u << 6u);
    }

    /**
     * Set CTRL_TOG's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void set_CTRL_TOG_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_TOG |= 1u << 6u;
    }

    /**
     * Clear CTRL_TOG's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void clear_CTRL_TOG_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_TOG &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL_TOG's ENABLE_PXP_HANDSHAKE bit.
     *
     * If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as
     * bus master and the handshake mechanism between LCDIF and PXP will be
     * turned on
     */
    inline void toggle_CTRL_TOG_ENABLE_PXP_HANDSHAKE() volatile
    {
        CTRL_TOG ^= 1u << 6u;
    }

    /**
     * Get CTRL_TOG's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline bool get_CTRL_TOG_MASTER() volatile
    {
        return CTRL_TOG & (1u << 5u);
    }

    /**
     * Set CTRL_TOG's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void set_CTRL_TOG_MASTER() volatile
    {
        CTRL_TOG |= 1u << 5u;
    }

    /**
     * Clear CTRL_TOG's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void clear_CTRL_TOG_MASTER() volatile
    {
        CTRL_TOG &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL_TOG's MASTER bit.
     *
     * Set this bit to make the LCDIF act as a bus master
     */
    inline void toggle_CTRL_TOG_MASTER() volatile
    {
        CTRL_TOG ^= 1u << 5u;
    }

    /**
     * Get CTRL_TOG's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline bool get_CTRL_TOG_DATA_FORMAT_16_BIT() volatile
    {
        return CTRL_TOG & (1u << 3u);
    }

    /**
     * Set CTRL_TOG's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void set_CTRL_TOG_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_TOG |= 1u << 3u;
    }

    /**
     * Clear CTRL_TOG's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void clear_CTRL_TOG_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_TOG &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL_TOG's DATA_FORMAT_16_BIT bit.
     *
     * When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data
     * is in ARGB555 format
     */
    inline void toggle_CTRL_TOG_DATA_FORMAT_16_BIT() volatile
    {
        CTRL_TOG ^= 1u << 3u;
    }

    /**
     * Get CTRL_TOG's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline bool get_CTRL_TOG_DATA_FORMAT_18_BIT() volatile
    {
        return CTRL_TOG & (1u << 2u);
    }

    /**
     * Set CTRL_TOG's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void set_CTRL_TOG_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_TOG |= 1u << 2u;
    }

    /**
     * Clear CTRL_TOG's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void clear_CTRL_TOG_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_TOG &= ~(1u << 2u);
    }

    /**
     * Toggle CTRL_TOG's DATA_FORMAT_18_BIT bit.
     *
     * Used only when WORD_LENGTH = 2, i.e. 18-bit.
     */
    inline void toggle_CTRL_TOG_DATA_FORMAT_18_BIT() volatile
    {
        CTRL_TOG ^= 1u << 2u;
    }

    /**
     * Get CTRL_TOG's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline bool get_CTRL_TOG_DATA_FORMAT_24_BIT() volatile
    {
        return CTRL_TOG & (1u << 1u);
    }

    /**
     * Set CTRL_TOG's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void set_CTRL_TOG_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_TOG |= 1u << 1u;
    }

    /**
     * Clear CTRL_TOG's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void clear_CTRL_TOG_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL_TOG's DATA_FORMAT_24_BIT bit.
     *
     * Used only when WORD_LENGTH = 3, i
     */
    inline void toggle_CTRL_TOG_DATA_FORMAT_24_BIT() volatile
    {
        CTRL_TOG ^= 1u << 1u;
    }

    /**
     * Get CTRL_TOG's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline bool get_CTRL_TOG_RUN() volatile
    {
        return CTRL_TOG & (1u << 0u);
    }

    /**
     * Set CTRL_TOG's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void set_CTRL_TOG_RUN() volatile
    {
        CTRL_TOG |= 1u << 0u;
    }

    /**
     * Clear CTRL_TOG's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void clear_CTRL_TOG_RUN() volatile
    {
        CTRL_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL_TOG's RUN bit.
     *
     * When this bit is set by software, the LCDIF will begin transferring data
     * between the SoC and the display
     */
    inline void toggle_CTRL_TOG_RUN() volatile
    {
        CTRL_TOG ^= 1u << 0u;
    }

    /**
     * Get all of CTRL_TOG's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void get_CTRL_TOG(
        bool &SFTRST, bool &CLKGATE, bool &DATA_SHIFT_DIR,
        uint8_t &SHIFT_NUM_BITS, bool &BYPASS_COUNT, bool &DOTCLK_MODE,
        LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE &INPUT_DATA_SWIZZLE,
        LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE &CSC_DATA_SWIZZLE,
        LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH &LCD_DATABUS_WIDTH,
        LCDIF_CTRL_TOG_WORD_LENGTH &WORD_LENGTH, bool &ENABLE_PXP_HANDSHAKE,
        bool &MASTER, bool &DATA_FORMAT_16_BIT, bool &DATA_FORMAT_18_BIT,
        bool &DATA_FORMAT_24_BIT, bool &RUN) volatile
    {
        uint32_t curr = CTRL_TOG;

        SFTRST = curr & (1u << 31u);
        CLKGATE = curr & (1u << 30u);
        DATA_SHIFT_DIR = curr & (1u << 26u);
        SHIFT_NUM_BITS = (curr >> 21u) & 0b11111u;
        BYPASS_COUNT = curr & (1u << 19u);
        DOTCLK_MODE = curr & (1u << 17u);
        INPUT_DATA_SWIZZLE =
            LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE((curr >> 14u) & 0b11u);
        CSC_DATA_SWIZZLE =
            LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE((curr >> 12u) & 0b11u);
        LCD_DATABUS_WIDTH =
            LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH((curr >> 10u) & 0b11u);
        WORD_LENGTH = LCDIF_CTRL_TOG_WORD_LENGTH((curr >> 8u) & 0b11u);
        ENABLE_PXP_HANDSHAKE = curr & (1u << 6u);
        MASTER = curr & (1u << 5u);
        DATA_FORMAT_16_BIT = curr & (1u << 3u);
        DATA_FORMAT_18_BIT = curr & (1u << 2u);
        DATA_FORMAT_24_BIT = curr & (1u << 1u);
        RUN = curr & (1u << 0u);
    }

    /**
     * Set all of CTRL_TOG's bit fields.
     *
     * (read-write) LCDIF General Control Register
     */
    inline void set_CTRL_TOG(
        bool SFTRST, bool CLKGATE, bool DATA_SHIFT_DIR, uint8_t SHIFT_NUM_BITS,
        bool BYPASS_COUNT, bool DOTCLK_MODE,
        LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE INPUT_DATA_SWIZZLE,
        LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE CSC_DATA_SWIZZLE,
        LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH LCD_DATABUS_WIDTH,
        LCDIF_CTRL_TOG_WORD_LENGTH WORD_LENGTH, bool ENABLE_PXP_HANDSHAKE,
        bool MASTER, bool DATA_FORMAT_16_BIT, bool DATA_FORMAT_18_BIT,
        bool DATA_FORMAT_24_BIT, bool RUN) volatile
    {
        uint32_t curr = CTRL_TOG;

        curr &= ~(0b1u << 31u);
        curr |= (SFTRST & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CLKGATE & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (DATA_SHIFT_DIR & 0b1u) << 26u;
        curr &= ~(0b11111u << 21u);
        curr |= (SHIFT_NUM_BITS & 0b11111u) << 21u;
        curr &= ~(0b1u << 19u);
        curr |= (BYPASS_COUNT & 0b1u) << 19u;
        curr &= ~(0b1u << 17u);
        curr |= (DOTCLK_MODE & 0b1u) << 17u;
        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(INPUT_DATA_SWIZZLE) & 0b11u) << 14u;
        curr &= ~(0b11u << 12u);
        curr |= (std::to_underlying(CSC_DATA_SWIZZLE) & 0b11u) << 12u;
        curr &= ~(0b11u << 10u);
        curr |= (std::to_underlying(LCD_DATABUS_WIDTH) & 0b11u) << 10u;
        curr &= ~(0b11u << 8u);
        curr |= (std::to_underlying(WORD_LENGTH) & 0b11u) << 8u;
        curr &= ~(0b1u << 6u);
        curr |= (ENABLE_PXP_HANDSHAKE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MASTER & 0b1u) << 5u;
        curr &= ~(0b1u << 3u);
        curr |= (DATA_FORMAT_16_BIT & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (DATA_FORMAT_18_BIT & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (DATA_FORMAT_24_BIT & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (RUN & 0b1u) << 0u;

        CTRL_TOG = curr;
    }

    /**
     * Get CTRL1's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline bool get_CTRL1_IMAGE_DATA_SELECT() volatile
    {
        return CTRL1 & (1u << 31u);
    }

    /**
     * Set CTRL1's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void set_CTRL1_IMAGE_DATA_SELECT() volatile
    {
        CTRL1 |= 1u << 31u;
    }

    /**
     * Clear CTRL1's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void clear_CTRL1_IMAGE_DATA_SELECT() volatile
    {
        CTRL1 &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL1's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void toggle_CTRL1_IMAGE_DATA_SELECT() volatile
    {
        CTRL1 ^= 1u << 31u;
    }

    /**
     * Get CTRL1's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline bool get_CTRL1_CS_OUT_SELECT() volatile
    {
        return CTRL1 & (1u << 30u);
    }

    /**
     * Set CTRL1's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void set_CTRL1_CS_OUT_SELECT() volatile
    {
        CTRL1 |= 1u << 30u;
    }

    /**
     * Clear CTRL1's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void clear_CTRL1_CS_OUT_SELECT() volatile
    {
        CTRL1 &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL1's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void toggle_CTRL1_CS_OUT_SELECT() volatile
    {
        CTRL1 ^= 1u << 30u;
    }

    /**
     * Get CTRL1's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline bool get_CTRL1_BM_ERROR_IRQ_EN() volatile
    {
        return CTRL1 & (1u << 26u);
    }

    /**
     * Set CTRL1's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void set_CTRL1_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1 |= 1u << 26u;
    }

    /**
     * Clear CTRL1's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void clear_CTRL1_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1 &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL1's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void toggle_CTRL1_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1 ^= 1u << 26u;
    }

    /**
     * Get CTRL1's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_BM_ERROR_IRQ() volatile
    {
        return CTRL1 & (1u << 25u);
    }

    /**
     * Set CTRL1's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_BM_ERROR_IRQ() volatile
    {
        CTRL1 |= 1u << 25u;
    }

    /**
     * Clear CTRL1's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_BM_ERROR_IRQ() volatile
    {
        CTRL1 &= ~(1u << 25u);
    }

    /**
     * Toggle CTRL1's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_BM_ERROR_IRQ() volatile
    {
        CTRL1 ^= 1u << 25u;
    }

    /**
     * Get CTRL1's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline bool get_CTRL1_RECOVER_ON_UNDERFLOW() volatile
    {
        return CTRL1 & (1u << 24u);
    }

    /**
     * Set CTRL1's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void set_CTRL1_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1 |= 1u << 24u;
    }

    /**
     * Clear CTRL1's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void clear_CTRL1_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1 &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL1's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void toggle_CTRL1_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1 ^= 1u << 24u;
    }

    /**
     * Get CTRL1's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline bool get_CTRL1_INTERLACE_FIELDS() volatile
    {
        return CTRL1 & (1u << 23u);
    }

    /**
     * Set CTRL1's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void set_CTRL1_INTERLACE_FIELDS() volatile
    {
        CTRL1 |= 1u << 23u;
    }

    /**
     * Clear CTRL1's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void clear_CTRL1_INTERLACE_FIELDS() volatile
    {
        CTRL1 &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL1's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void toggle_CTRL1_INTERLACE_FIELDS() volatile
    {
        CTRL1 ^= 1u << 23u;
    }

    /**
     * Get CTRL1's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline bool get_CTRL1_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        return CTRL1 & (1u << 22u);
    }

    /**
     * Set CTRL1's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void set_CTRL1_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1 |= 1u << 22u;
    }

    /**
     * Clear CTRL1's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void clear_CTRL1_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1 &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL1's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void toggle_CTRL1_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1 ^= 1u << 22u;
    }

    /**
     * Get CTRL1's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline bool get_CTRL1_FIFO_CLEAR() volatile
    {
        return CTRL1 & (1u << 21u);
    }

    /**
     * Set CTRL1's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void set_CTRL1_FIFO_CLEAR() volatile
    {
        CTRL1 |= 1u << 21u;
    }

    /**
     * Clear CTRL1's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void clear_CTRL1_FIFO_CLEAR() volatile
    {
        CTRL1 &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL1's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void toggle_CTRL1_FIFO_CLEAR() volatile
    {
        CTRL1 ^= 1u << 21u;
    }

    /**
     * Get CTRL1's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline bool get_CTRL1_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        return CTRL1 & (1u << 20u);
    }

    /**
     * Set CTRL1's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void set_CTRL1_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1 |= 1u << 20u;
    }

    /**
     * Clear CTRL1's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void clear_CTRL1_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1 &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL1's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void toggle_CTRL1_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1 ^= 1u << 20u;
    }

    /**
     * Get CTRL1's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline uint8_t get_CTRL1_BYTE_PACKING_FORMAT() volatile
    {
        return (CTRL1 >> 16u) & 0b1111u;
    }

    /**
     * Set CTRL1's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline void set_CTRL1_BYTE_PACKING_FORMAT(uint8_t value) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_OVERFLOW_IRQ_EN() volatile
    {
        return CTRL1 & (1u << 15u);
    }

    /**
     * Set CTRL1's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1 |= 1u << 15u;
    }

    /**
     * Clear CTRL1's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1 &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL1's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1 ^= 1u << 15u;
    }

    /**
     * Get CTRL1's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_UNDERFLOW_IRQ_EN() volatile
    {
        return CTRL1 & (1u << 14u);
    }

    /**
     * Set CTRL1's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1 |= 1u << 14u;
    }

    /**
     * Clear CTRL1's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1 &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL1's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1 ^= 1u << 14u;
    }

    /**
     * Get CTRL1's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline bool get_CTRL1_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        return CTRL1 & (1u << 13u);
    }

    /**
     * Set CTRL1's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void set_CTRL1_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1 |= 1u << 13u;
    }

    /**
     * Clear CTRL1's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void clear_CTRL1_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1 &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL1's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void toggle_CTRL1_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1 ^= 1u << 13u;
    }

    /**
     * Get CTRL1's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline bool get_CTRL1_VSYNC_EDGE_IRQ_EN() volatile
    {
        return CTRL1 & (1u << 12u);
    }

    /**
     * Set CTRL1's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void set_CTRL1_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1 |= 1u << 12u;
    }

    /**
     * Clear CTRL1's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void clear_CTRL1_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1 &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL1's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void toggle_CTRL1_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1 ^= 1u << 12u;
    }

    /**
     * Get CTRL1's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_OVERFLOW_IRQ() volatile
    {
        return CTRL1 & (1u << 11u);
    }

    /**
     * Set CTRL1's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_OVERFLOW_IRQ() volatile
    {
        CTRL1 |= 1u << 11u;
    }

    /**
     * Clear CTRL1's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_OVERFLOW_IRQ() volatile
    {
        CTRL1 &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL1's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_OVERFLOW_IRQ() volatile
    {
        CTRL1 ^= 1u << 11u;
    }

    /**
     * Get CTRL1's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_UNDERFLOW_IRQ() volatile
    {
        return CTRL1 & (1u << 10u);
    }

    /**
     * Set CTRL1's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_UNDERFLOW_IRQ() volatile
    {
        CTRL1 |= 1u << 10u;
    }

    /**
     * Clear CTRL1's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_UNDERFLOW_IRQ() volatile
    {
        CTRL1 &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL1's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_UNDERFLOW_IRQ() volatile
    {
        CTRL1 ^= 1u << 10u;
    }

    /**
     * Get CTRL1's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_CUR_FRAME_DONE_IRQ() volatile
    {
        return CTRL1 & (1u << 9u);
    }

    /**
     * Set CTRL1's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1 |= 1u << 9u;
    }

    /**
     * Clear CTRL1's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1 &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL1's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1 ^= 1u << 9u;
    }

    /**
     * Get CTRL1's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_VSYNC_EDGE_IRQ() volatile
    {
        return CTRL1 & (1u << 8u);
    }

    /**
     * Set CTRL1's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1 |= 1u << 8u;
    }

    /**
     * Clear CTRL1's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1 &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL1's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1 ^= 1u << 8u;
    }

    /**
     * Get all of CTRL1's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void get_CTRL1(bool &IMAGE_DATA_SELECT, bool &CS_OUT_SELECT,
                          bool &BM_ERROR_IRQ_EN, bool &BM_ERROR_IRQ,
                          bool &RECOVER_ON_UNDERFLOW, bool &INTERLACE_FIELDS,
                          bool &START_INTERLACE_FROM_SECOND_FIELD,
                          bool &FIFO_CLEAR, bool &IRQ_ON_ALTERNATE_FIELDS,
                          uint8_t &BYTE_PACKING_FORMAT, bool &OVERFLOW_IRQ_EN,
                          bool &UNDERFLOW_IRQ_EN, bool &CUR_FRAME_DONE_IRQ_EN,
                          bool &VSYNC_EDGE_IRQ_EN, bool &OVERFLOW_IRQ,
                          bool &UNDERFLOW_IRQ, bool &CUR_FRAME_DONE_IRQ,
                          bool &VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1;

        IMAGE_DATA_SELECT = curr & (1u << 31u);
        CS_OUT_SELECT = curr & (1u << 30u);
        BM_ERROR_IRQ_EN = curr & (1u << 26u);
        BM_ERROR_IRQ = curr & (1u << 25u);
        RECOVER_ON_UNDERFLOW = curr & (1u << 24u);
        INTERLACE_FIELDS = curr & (1u << 23u);
        START_INTERLACE_FROM_SECOND_FIELD = curr & (1u << 22u);
        FIFO_CLEAR = curr & (1u << 21u);
        IRQ_ON_ALTERNATE_FIELDS = curr & (1u << 20u);
        BYTE_PACKING_FORMAT = (curr >> 16u) & 0b1111u;
        OVERFLOW_IRQ_EN = curr & (1u << 15u);
        UNDERFLOW_IRQ_EN = curr & (1u << 14u);
        CUR_FRAME_DONE_IRQ_EN = curr & (1u << 13u);
        VSYNC_EDGE_IRQ_EN = curr & (1u << 12u);
        OVERFLOW_IRQ = curr & (1u << 11u);
        UNDERFLOW_IRQ = curr & (1u << 10u);
        CUR_FRAME_DONE_IRQ = curr & (1u << 9u);
        VSYNC_EDGE_IRQ = curr & (1u << 8u);
    }

    /**
     * Set all of CTRL1's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void set_CTRL1(bool IMAGE_DATA_SELECT, bool CS_OUT_SELECT,
                          bool BM_ERROR_IRQ_EN, bool BM_ERROR_IRQ,
                          bool RECOVER_ON_UNDERFLOW, bool INTERLACE_FIELDS,
                          bool START_INTERLACE_FROM_SECOND_FIELD,
                          bool FIFO_CLEAR, bool IRQ_ON_ALTERNATE_FIELDS,
                          uint8_t BYTE_PACKING_FORMAT, bool OVERFLOW_IRQ_EN,
                          bool UNDERFLOW_IRQ_EN, bool CUR_FRAME_DONE_IRQ_EN,
                          bool VSYNC_EDGE_IRQ_EN, bool OVERFLOW_IRQ,
                          bool UNDERFLOW_IRQ, bool CUR_FRAME_DONE_IRQ,
                          bool VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1;

        curr &= ~(0b1u << 31u);
        curr |= (IMAGE_DATA_SELECT & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CS_OUT_SELECT & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (BM_ERROR_IRQ_EN & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (BM_ERROR_IRQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RECOVER_ON_UNDERFLOW & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (INTERLACE_FIELDS & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (START_INTERLACE_FROM_SECOND_FIELD & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (FIFO_CLEAR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (IRQ_ON_ALTERNATE_FIELDS & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (BYTE_PACKING_FORMAT & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (OVERFLOW_IRQ_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (UNDERFLOW_IRQ_EN & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CUR_FRAME_DONE_IRQ_EN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (VSYNC_EDGE_IRQ_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (OVERFLOW_IRQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (UNDERFLOW_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (CUR_FRAME_DONE_IRQ & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VSYNC_EDGE_IRQ & 0b1u) << 8u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1_SET's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline bool get_CTRL1_SET_IMAGE_DATA_SELECT() volatile
    {
        return CTRL1_SET & (1u << 31u);
    }

    /**
     * Set CTRL1_SET's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void set_CTRL1_SET_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_SET |= 1u << 31u;
    }

    /**
     * Clear CTRL1_SET's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void clear_CTRL1_SET_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_SET &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL1_SET's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void toggle_CTRL1_SET_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_SET ^= 1u << 31u;
    }

    /**
     * Get CTRL1_SET's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline bool get_CTRL1_SET_CS_OUT_SELECT() volatile
    {
        return CTRL1_SET & (1u << 30u);
    }

    /**
     * Set CTRL1_SET's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void set_CTRL1_SET_CS_OUT_SELECT() volatile
    {
        CTRL1_SET |= 1u << 30u;
    }

    /**
     * Clear CTRL1_SET's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void clear_CTRL1_SET_CS_OUT_SELECT() volatile
    {
        CTRL1_SET &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL1_SET's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void toggle_CTRL1_SET_CS_OUT_SELECT() volatile
    {
        CTRL1_SET ^= 1u << 30u;
    }

    /**
     * Get CTRL1_SET's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline bool get_CTRL1_SET_BM_ERROR_IRQ_EN() volatile
    {
        return CTRL1_SET & (1u << 26u);
    }

    /**
     * Set CTRL1_SET's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void set_CTRL1_SET_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_SET |= 1u << 26u;
    }

    /**
     * Clear CTRL1_SET's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void clear_CTRL1_SET_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_SET &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL1_SET's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void toggle_CTRL1_SET_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_SET ^= 1u << 26u;
    }

    /**
     * Get CTRL1_SET's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_SET_BM_ERROR_IRQ() volatile
    {
        return CTRL1_SET & (1u << 25u);
    }

    /**
     * Set CTRL1_SET's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_SET_BM_ERROR_IRQ() volatile
    {
        CTRL1_SET |= 1u << 25u;
    }

    /**
     * Clear CTRL1_SET's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_SET_BM_ERROR_IRQ() volatile
    {
        CTRL1_SET &= ~(1u << 25u);
    }

    /**
     * Toggle CTRL1_SET's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_SET_BM_ERROR_IRQ() volatile
    {
        CTRL1_SET ^= 1u << 25u;
    }

    /**
     * Get CTRL1_SET's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline bool get_CTRL1_SET_RECOVER_ON_UNDERFLOW() volatile
    {
        return CTRL1_SET & (1u << 24u);
    }

    /**
     * Set CTRL1_SET's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void set_CTRL1_SET_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_SET |= 1u << 24u;
    }

    /**
     * Clear CTRL1_SET's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void clear_CTRL1_SET_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_SET &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL1_SET's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void toggle_CTRL1_SET_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_SET ^= 1u << 24u;
    }

    /**
     * Get CTRL1_SET's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline bool get_CTRL1_SET_INTERLACE_FIELDS() volatile
    {
        return CTRL1_SET & (1u << 23u);
    }

    /**
     * Set CTRL1_SET's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void set_CTRL1_SET_INTERLACE_FIELDS() volatile
    {
        CTRL1_SET |= 1u << 23u;
    }

    /**
     * Clear CTRL1_SET's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void clear_CTRL1_SET_INTERLACE_FIELDS() volatile
    {
        CTRL1_SET &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL1_SET's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void toggle_CTRL1_SET_INTERLACE_FIELDS() volatile
    {
        CTRL1_SET ^= 1u << 23u;
    }

    /**
     * Get CTRL1_SET's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline bool get_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        return CTRL1_SET & (1u << 22u);
    }

    /**
     * Set CTRL1_SET's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void set_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_SET |= 1u << 22u;
    }

    /**
     * Clear CTRL1_SET's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void clear_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_SET &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL1_SET's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void toggle_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_SET ^= 1u << 22u;
    }

    /**
     * Get CTRL1_SET's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline bool get_CTRL1_SET_FIFO_CLEAR() volatile
    {
        return CTRL1_SET & (1u << 21u);
    }

    /**
     * Set CTRL1_SET's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void set_CTRL1_SET_FIFO_CLEAR() volatile
    {
        CTRL1_SET |= 1u << 21u;
    }

    /**
     * Clear CTRL1_SET's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void clear_CTRL1_SET_FIFO_CLEAR() volatile
    {
        CTRL1_SET &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL1_SET's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void toggle_CTRL1_SET_FIFO_CLEAR() volatile
    {
        CTRL1_SET ^= 1u << 21u;
    }

    /**
     * Get CTRL1_SET's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline bool get_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        return CTRL1_SET & (1u << 20u);
    }

    /**
     * Set CTRL1_SET's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void set_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_SET |= 1u << 20u;
    }

    /**
     * Clear CTRL1_SET's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void clear_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_SET &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL1_SET's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void toggle_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_SET ^= 1u << 20u;
    }

    /**
     * Get CTRL1_SET's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline uint8_t get_CTRL1_SET_BYTE_PACKING_FORMAT() volatile
    {
        return (CTRL1_SET >> 16u) & 0b1111u;
    }

    /**
     * Set CTRL1_SET's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline void set_CTRL1_SET_BYTE_PACKING_FORMAT(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_SET;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CTRL1_SET = curr;
    }

    /**
     * Get CTRL1_SET's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_SET_OVERFLOW_IRQ_EN() volatile
    {
        return CTRL1_SET & (1u << 15u);
    }

    /**
     * Set CTRL1_SET's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_SET_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_SET |= 1u << 15u;
    }

    /**
     * Clear CTRL1_SET's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_SET_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_SET &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL1_SET's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_SET_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_SET ^= 1u << 15u;
    }

    /**
     * Get CTRL1_SET's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_SET_UNDERFLOW_IRQ_EN() volatile
    {
        return CTRL1_SET & (1u << 14u);
    }

    /**
     * Set CTRL1_SET's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_SET_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_SET |= 1u << 14u;
    }

    /**
     * Clear CTRL1_SET's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_SET_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_SET &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL1_SET's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_SET_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_SET ^= 1u << 14u;
    }

    /**
     * Get CTRL1_SET's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline bool get_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        return CTRL1_SET & (1u << 13u);
    }

    /**
     * Set CTRL1_SET's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void set_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_SET |= 1u << 13u;
    }

    /**
     * Clear CTRL1_SET's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void clear_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_SET &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL1_SET's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void toggle_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_SET ^= 1u << 13u;
    }

    /**
     * Get CTRL1_SET's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline bool get_CTRL1_SET_VSYNC_EDGE_IRQ_EN() volatile
    {
        return CTRL1_SET & (1u << 12u);
    }

    /**
     * Set CTRL1_SET's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void set_CTRL1_SET_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_SET |= 1u << 12u;
    }

    /**
     * Clear CTRL1_SET's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void clear_CTRL1_SET_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_SET &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL1_SET's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void toggle_CTRL1_SET_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_SET ^= 1u << 12u;
    }

    /**
     * Get CTRL1_SET's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_SET_OVERFLOW_IRQ() volatile
    {
        return CTRL1_SET & (1u << 11u);
    }

    /**
     * Set CTRL1_SET's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_SET_OVERFLOW_IRQ() volatile
    {
        CTRL1_SET |= 1u << 11u;
    }

    /**
     * Clear CTRL1_SET's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_SET_OVERFLOW_IRQ() volatile
    {
        CTRL1_SET &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL1_SET's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_SET_OVERFLOW_IRQ() volatile
    {
        CTRL1_SET ^= 1u << 11u;
    }

    /**
     * Get CTRL1_SET's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_SET_UNDERFLOW_IRQ() volatile
    {
        return CTRL1_SET & (1u << 10u);
    }

    /**
     * Set CTRL1_SET's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_SET_UNDERFLOW_IRQ() volatile
    {
        CTRL1_SET |= 1u << 10u;
    }

    /**
     * Clear CTRL1_SET's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_SET_UNDERFLOW_IRQ() volatile
    {
        CTRL1_SET &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL1_SET's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_SET_UNDERFLOW_IRQ() volatile
    {
        CTRL1_SET ^= 1u << 10u;
    }

    /**
     * Get CTRL1_SET's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_SET_CUR_FRAME_DONE_IRQ() volatile
    {
        return CTRL1_SET & (1u << 9u);
    }

    /**
     * Set CTRL1_SET's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_SET_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_SET |= 1u << 9u;
    }

    /**
     * Clear CTRL1_SET's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_SET_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_SET &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL1_SET's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_SET_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_SET ^= 1u << 9u;
    }

    /**
     * Get CTRL1_SET's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_SET_VSYNC_EDGE_IRQ() volatile
    {
        return CTRL1_SET & (1u << 8u);
    }

    /**
     * Set CTRL1_SET's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_SET_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_SET |= 1u << 8u;
    }

    /**
     * Clear CTRL1_SET's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_SET_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_SET &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL1_SET's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_SET_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_SET ^= 1u << 8u;
    }

    /**
     * Get all of CTRL1_SET's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void get_CTRL1_SET(
        bool &IMAGE_DATA_SELECT, bool &CS_OUT_SELECT, bool &BM_ERROR_IRQ_EN,
        bool &BM_ERROR_IRQ, bool &RECOVER_ON_UNDERFLOW, bool &INTERLACE_FIELDS,
        bool &START_INTERLACE_FROM_SECOND_FIELD, bool &FIFO_CLEAR,
        bool &IRQ_ON_ALTERNATE_FIELDS, uint8_t &BYTE_PACKING_FORMAT,
        bool &OVERFLOW_IRQ_EN, bool &UNDERFLOW_IRQ_EN,
        bool &CUR_FRAME_DONE_IRQ_EN, bool &VSYNC_EDGE_IRQ_EN,
        bool &OVERFLOW_IRQ, bool &UNDERFLOW_IRQ, bool &CUR_FRAME_DONE_IRQ,
        bool &VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1_SET;

        IMAGE_DATA_SELECT = curr & (1u << 31u);
        CS_OUT_SELECT = curr & (1u << 30u);
        BM_ERROR_IRQ_EN = curr & (1u << 26u);
        BM_ERROR_IRQ = curr & (1u << 25u);
        RECOVER_ON_UNDERFLOW = curr & (1u << 24u);
        INTERLACE_FIELDS = curr & (1u << 23u);
        START_INTERLACE_FROM_SECOND_FIELD = curr & (1u << 22u);
        FIFO_CLEAR = curr & (1u << 21u);
        IRQ_ON_ALTERNATE_FIELDS = curr & (1u << 20u);
        BYTE_PACKING_FORMAT = (curr >> 16u) & 0b1111u;
        OVERFLOW_IRQ_EN = curr & (1u << 15u);
        UNDERFLOW_IRQ_EN = curr & (1u << 14u);
        CUR_FRAME_DONE_IRQ_EN = curr & (1u << 13u);
        VSYNC_EDGE_IRQ_EN = curr & (1u << 12u);
        OVERFLOW_IRQ = curr & (1u << 11u);
        UNDERFLOW_IRQ = curr & (1u << 10u);
        CUR_FRAME_DONE_IRQ = curr & (1u << 9u);
        VSYNC_EDGE_IRQ = curr & (1u << 8u);
    }

    /**
     * Set all of CTRL1_SET's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void set_CTRL1_SET(bool IMAGE_DATA_SELECT, bool CS_OUT_SELECT,
                              bool BM_ERROR_IRQ_EN, bool BM_ERROR_IRQ,
                              bool RECOVER_ON_UNDERFLOW, bool INTERLACE_FIELDS,
                              bool START_INTERLACE_FROM_SECOND_FIELD,
                              bool FIFO_CLEAR, bool IRQ_ON_ALTERNATE_FIELDS,
                              uint8_t BYTE_PACKING_FORMAT,
                              bool OVERFLOW_IRQ_EN, bool UNDERFLOW_IRQ_EN,
                              bool CUR_FRAME_DONE_IRQ_EN,
                              bool VSYNC_EDGE_IRQ_EN, bool OVERFLOW_IRQ,
                              bool UNDERFLOW_IRQ, bool CUR_FRAME_DONE_IRQ,
                              bool VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1_SET;

        curr &= ~(0b1u << 31u);
        curr |= (IMAGE_DATA_SELECT & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CS_OUT_SELECT & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (BM_ERROR_IRQ_EN & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (BM_ERROR_IRQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RECOVER_ON_UNDERFLOW & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (INTERLACE_FIELDS & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (START_INTERLACE_FROM_SECOND_FIELD & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (FIFO_CLEAR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (IRQ_ON_ALTERNATE_FIELDS & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (BYTE_PACKING_FORMAT & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (OVERFLOW_IRQ_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (UNDERFLOW_IRQ_EN & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CUR_FRAME_DONE_IRQ_EN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (VSYNC_EDGE_IRQ_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (OVERFLOW_IRQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (UNDERFLOW_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (CUR_FRAME_DONE_IRQ & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VSYNC_EDGE_IRQ & 0b1u) << 8u;

        CTRL1_SET = curr;
    }

    /**
     * Get CTRL1_CLR's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline bool get_CTRL1_CLR_IMAGE_DATA_SELECT() volatile
    {
        return CTRL1_CLR & (1u << 31u);
    }

    /**
     * Set CTRL1_CLR's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void set_CTRL1_CLR_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_CLR |= 1u << 31u;
    }

    /**
     * Clear CTRL1_CLR's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void clear_CTRL1_CLR_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_CLR &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL1_CLR's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void toggle_CTRL1_CLR_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_CLR ^= 1u << 31u;
    }

    /**
     * Get CTRL1_CLR's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline bool get_CTRL1_CLR_CS_OUT_SELECT() volatile
    {
        return CTRL1_CLR & (1u << 30u);
    }

    /**
     * Set CTRL1_CLR's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void set_CTRL1_CLR_CS_OUT_SELECT() volatile
    {
        CTRL1_CLR |= 1u << 30u;
    }

    /**
     * Clear CTRL1_CLR's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void clear_CTRL1_CLR_CS_OUT_SELECT() volatile
    {
        CTRL1_CLR &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL1_CLR's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void toggle_CTRL1_CLR_CS_OUT_SELECT() volatile
    {
        CTRL1_CLR ^= 1u << 30u;
    }

    /**
     * Get CTRL1_CLR's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline bool get_CTRL1_CLR_BM_ERROR_IRQ_EN() volatile
    {
        return CTRL1_CLR & (1u << 26u);
    }

    /**
     * Set CTRL1_CLR's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void set_CTRL1_CLR_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_CLR |= 1u << 26u;
    }

    /**
     * Clear CTRL1_CLR's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void clear_CTRL1_CLR_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_CLR &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL1_CLR's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void toggle_CTRL1_CLR_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_CLR ^= 1u << 26u;
    }

    /**
     * Get CTRL1_CLR's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_CLR_BM_ERROR_IRQ() volatile
    {
        return CTRL1_CLR & (1u << 25u);
    }

    /**
     * Set CTRL1_CLR's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_CLR_BM_ERROR_IRQ() volatile
    {
        CTRL1_CLR |= 1u << 25u;
    }

    /**
     * Clear CTRL1_CLR's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_CLR_BM_ERROR_IRQ() volatile
    {
        CTRL1_CLR &= ~(1u << 25u);
    }

    /**
     * Toggle CTRL1_CLR's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_CLR_BM_ERROR_IRQ() volatile
    {
        CTRL1_CLR ^= 1u << 25u;
    }

    /**
     * Get CTRL1_CLR's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline bool get_CTRL1_CLR_RECOVER_ON_UNDERFLOW() volatile
    {
        return CTRL1_CLR & (1u << 24u);
    }

    /**
     * Set CTRL1_CLR's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void set_CTRL1_CLR_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_CLR |= 1u << 24u;
    }

    /**
     * Clear CTRL1_CLR's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void clear_CTRL1_CLR_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_CLR &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL1_CLR's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void toggle_CTRL1_CLR_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_CLR ^= 1u << 24u;
    }

    /**
     * Get CTRL1_CLR's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline bool get_CTRL1_CLR_INTERLACE_FIELDS() volatile
    {
        return CTRL1_CLR & (1u << 23u);
    }

    /**
     * Set CTRL1_CLR's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void set_CTRL1_CLR_INTERLACE_FIELDS() volatile
    {
        CTRL1_CLR |= 1u << 23u;
    }

    /**
     * Clear CTRL1_CLR's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void clear_CTRL1_CLR_INTERLACE_FIELDS() volatile
    {
        CTRL1_CLR &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL1_CLR's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void toggle_CTRL1_CLR_INTERLACE_FIELDS() volatile
    {
        CTRL1_CLR ^= 1u << 23u;
    }

    /**
     * Get CTRL1_CLR's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline bool get_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        return CTRL1_CLR & (1u << 22u);
    }

    /**
     * Set CTRL1_CLR's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void set_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_CLR |= 1u << 22u;
    }

    /**
     * Clear CTRL1_CLR's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void clear_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_CLR &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL1_CLR's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void toggle_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_CLR ^= 1u << 22u;
    }

    /**
     * Get CTRL1_CLR's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline bool get_CTRL1_CLR_FIFO_CLEAR() volatile
    {
        return CTRL1_CLR & (1u << 21u);
    }

    /**
     * Set CTRL1_CLR's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void set_CTRL1_CLR_FIFO_CLEAR() volatile
    {
        CTRL1_CLR |= 1u << 21u;
    }

    /**
     * Clear CTRL1_CLR's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void clear_CTRL1_CLR_FIFO_CLEAR() volatile
    {
        CTRL1_CLR &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL1_CLR's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void toggle_CTRL1_CLR_FIFO_CLEAR() volatile
    {
        CTRL1_CLR ^= 1u << 21u;
    }

    /**
     * Get CTRL1_CLR's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline bool get_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        return CTRL1_CLR & (1u << 20u);
    }

    /**
     * Set CTRL1_CLR's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void set_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_CLR |= 1u << 20u;
    }

    /**
     * Clear CTRL1_CLR's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void clear_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL1_CLR's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void toggle_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_CLR ^= 1u << 20u;
    }

    /**
     * Get CTRL1_CLR's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline uint8_t get_CTRL1_CLR_BYTE_PACKING_FORMAT() volatile
    {
        return (CTRL1_CLR >> 16u) & 0b1111u;
    }

    /**
     * Set CTRL1_CLR's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline void set_CTRL1_CLR_BYTE_PACKING_FORMAT(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_CLR;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CTRL1_CLR = curr;
    }

    /**
     * Get CTRL1_CLR's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_CLR_OVERFLOW_IRQ_EN() volatile
    {
        return CTRL1_CLR & (1u << 15u);
    }

    /**
     * Set CTRL1_CLR's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_CLR_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_CLR |= 1u << 15u;
    }

    /**
     * Clear CTRL1_CLR's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_CLR_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_CLR &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL1_CLR's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_CLR_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_CLR ^= 1u << 15u;
    }

    /**
     * Get CTRL1_CLR's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_CLR_UNDERFLOW_IRQ_EN() volatile
    {
        return CTRL1_CLR & (1u << 14u);
    }

    /**
     * Set CTRL1_CLR's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_CLR_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_CLR |= 1u << 14u;
    }

    /**
     * Clear CTRL1_CLR's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_CLR_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_CLR &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL1_CLR's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_CLR_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_CLR ^= 1u << 14u;
    }

    /**
     * Get CTRL1_CLR's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline bool get_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        return CTRL1_CLR & (1u << 13u);
    }

    /**
     * Set CTRL1_CLR's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void set_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_CLR |= 1u << 13u;
    }

    /**
     * Clear CTRL1_CLR's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void clear_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_CLR &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL1_CLR's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void toggle_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_CLR ^= 1u << 13u;
    }

    /**
     * Get CTRL1_CLR's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline bool get_CTRL1_CLR_VSYNC_EDGE_IRQ_EN() volatile
    {
        return CTRL1_CLR & (1u << 12u);
    }

    /**
     * Set CTRL1_CLR's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void set_CTRL1_CLR_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_CLR |= 1u << 12u;
    }

    /**
     * Clear CTRL1_CLR's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void clear_CTRL1_CLR_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_CLR &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL1_CLR's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void toggle_CTRL1_CLR_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_CLR ^= 1u << 12u;
    }

    /**
     * Get CTRL1_CLR's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_CLR_OVERFLOW_IRQ() volatile
    {
        return CTRL1_CLR & (1u << 11u);
    }

    /**
     * Set CTRL1_CLR's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_CLR_OVERFLOW_IRQ() volatile
    {
        CTRL1_CLR |= 1u << 11u;
    }

    /**
     * Clear CTRL1_CLR's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_CLR_OVERFLOW_IRQ() volatile
    {
        CTRL1_CLR &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL1_CLR's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_CLR_OVERFLOW_IRQ() volatile
    {
        CTRL1_CLR ^= 1u << 11u;
    }

    /**
     * Get CTRL1_CLR's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_CLR_UNDERFLOW_IRQ() volatile
    {
        return CTRL1_CLR & (1u << 10u);
    }

    /**
     * Set CTRL1_CLR's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_CLR_UNDERFLOW_IRQ() volatile
    {
        CTRL1_CLR |= 1u << 10u;
    }

    /**
     * Clear CTRL1_CLR's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_CLR_UNDERFLOW_IRQ() volatile
    {
        CTRL1_CLR &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL1_CLR's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_CLR_UNDERFLOW_IRQ() volatile
    {
        CTRL1_CLR ^= 1u << 10u;
    }

    /**
     * Get CTRL1_CLR's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_CLR_CUR_FRAME_DONE_IRQ() volatile
    {
        return CTRL1_CLR & (1u << 9u);
    }

    /**
     * Set CTRL1_CLR's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_CLR_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_CLR |= 1u << 9u;
    }

    /**
     * Clear CTRL1_CLR's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_CLR_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_CLR &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL1_CLR's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_CLR_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_CLR ^= 1u << 9u;
    }

    /**
     * Get CTRL1_CLR's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_CLR_VSYNC_EDGE_IRQ() volatile
    {
        return CTRL1_CLR & (1u << 8u);
    }

    /**
     * Set CTRL1_CLR's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_CLR_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_CLR |= 1u << 8u;
    }

    /**
     * Clear CTRL1_CLR's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_CLR_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_CLR &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL1_CLR's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_CLR_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_CLR ^= 1u << 8u;
    }

    /**
     * Get all of CTRL1_CLR's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void get_CTRL1_CLR(
        bool &IMAGE_DATA_SELECT, bool &CS_OUT_SELECT, bool &BM_ERROR_IRQ_EN,
        bool &BM_ERROR_IRQ, bool &RECOVER_ON_UNDERFLOW, bool &INTERLACE_FIELDS,
        bool &START_INTERLACE_FROM_SECOND_FIELD, bool &FIFO_CLEAR,
        bool &IRQ_ON_ALTERNATE_FIELDS, uint8_t &BYTE_PACKING_FORMAT,
        bool &OVERFLOW_IRQ_EN, bool &UNDERFLOW_IRQ_EN,
        bool &CUR_FRAME_DONE_IRQ_EN, bool &VSYNC_EDGE_IRQ_EN,
        bool &OVERFLOW_IRQ, bool &UNDERFLOW_IRQ, bool &CUR_FRAME_DONE_IRQ,
        bool &VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1_CLR;

        IMAGE_DATA_SELECT = curr & (1u << 31u);
        CS_OUT_SELECT = curr & (1u << 30u);
        BM_ERROR_IRQ_EN = curr & (1u << 26u);
        BM_ERROR_IRQ = curr & (1u << 25u);
        RECOVER_ON_UNDERFLOW = curr & (1u << 24u);
        INTERLACE_FIELDS = curr & (1u << 23u);
        START_INTERLACE_FROM_SECOND_FIELD = curr & (1u << 22u);
        FIFO_CLEAR = curr & (1u << 21u);
        IRQ_ON_ALTERNATE_FIELDS = curr & (1u << 20u);
        BYTE_PACKING_FORMAT = (curr >> 16u) & 0b1111u;
        OVERFLOW_IRQ_EN = curr & (1u << 15u);
        UNDERFLOW_IRQ_EN = curr & (1u << 14u);
        CUR_FRAME_DONE_IRQ_EN = curr & (1u << 13u);
        VSYNC_EDGE_IRQ_EN = curr & (1u << 12u);
        OVERFLOW_IRQ = curr & (1u << 11u);
        UNDERFLOW_IRQ = curr & (1u << 10u);
        CUR_FRAME_DONE_IRQ = curr & (1u << 9u);
        VSYNC_EDGE_IRQ = curr & (1u << 8u);
    }

    /**
     * Set all of CTRL1_CLR's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void set_CTRL1_CLR(bool IMAGE_DATA_SELECT, bool CS_OUT_SELECT,
                              bool BM_ERROR_IRQ_EN, bool BM_ERROR_IRQ,
                              bool RECOVER_ON_UNDERFLOW, bool INTERLACE_FIELDS,
                              bool START_INTERLACE_FROM_SECOND_FIELD,
                              bool FIFO_CLEAR, bool IRQ_ON_ALTERNATE_FIELDS,
                              uint8_t BYTE_PACKING_FORMAT,
                              bool OVERFLOW_IRQ_EN, bool UNDERFLOW_IRQ_EN,
                              bool CUR_FRAME_DONE_IRQ_EN,
                              bool VSYNC_EDGE_IRQ_EN, bool OVERFLOW_IRQ,
                              bool UNDERFLOW_IRQ, bool CUR_FRAME_DONE_IRQ,
                              bool VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1_CLR;

        curr &= ~(0b1u << 31u);
        curr |= (IMAGE_DATA_SELECT & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CS_OUT_SELECT & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (BM_ERROR_IRQ_EN & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (BM_ERROR_IRQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RECOVER_ON_UNDERFLOW & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (INTERLACE_FIELDS & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (START_INTERLACE_FROM_SECOND_FIELD & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (FIFO_CLEAR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (IRQ_ON_ALTERNATE_FIELDS & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (BYTE_PACKING_FORMAT & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (OVERFLOW_IRQ_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (UNDERFLOW_IRQ_EN & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CUR_FRAME_DONE_IRQ_EN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (VSYNC_EDGE_IRQ_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (OVERFLOW_IRQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (UNDERFLOW_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (CUR_FRAME_DONE_IRQ & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VSYNC_EDGE_IRQ & 0b1u) << 8u;

        CTRL1_CLR = curr;
    }

    /**
     * Get CTRL1_TOG's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline bool get_CTRL1_TOG_IMAGE_DATA_SELECT() volatile
    {
        return CTRL1_TOG & (1u << 31u);
    }

    /**
     * Set CTRL1_TOG's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void set_CTRL1_TOG_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_TOG |= 1u << 31u;
    }

    /**
     * Clear CTRL1_TOG's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void clear_CTRL1_TOG_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_TOG &= ~(1u << 31u);
    }

    /**
     * Toggle CTRL1_TOG's IMAGE_DATA_SELECT bit.
     *
     * Command Mode MIPI image data select bit
     */
    inline void toggle_CTRL1_TOG_IMAGE_DATA_SELECT() volatile
    {
        CTRL1_TOG ^= 1u << 31u;
    }

    /**
     * Get CTRL1_TOG's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline bool get_CTRL1_TOG_CS_OUT_SELECT() volatile
    {
        return CTRL1_TOG & (1u << 30u);
    }

    /**
     * Set CTRL1_TOG's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void set_CTRL1_TOG_CS_OUT_SELECT() volatile
    {
        CTRL1_TOG |= 1u << 30u;
    }

    /**
     * Clear CTRL1_TOG's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void clear_CTRL1_TOG_CS_OUT_SELECT() volatile
    {
        CTRL1_TOG &= ~(1u << 30u);
    }

    /**
     * Toggle CTRL1_TOG's CS_OUT_SELECT bit.
     *
     * This bit is CS0/CS1 valid select signals
     */
    inline void toggle_CTRL1_TOG_CS_OUT_SELECT() volatile
    {
        CTRL1_TOG ^= 1u << 30u;
    }

    /**
     * Get CTRL1_TOG's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline bool get_CTRL1_TOG_BM_ERROR_IRQ_EN() volatile
    {
        return CTRL1_TOG & (1u << 26u);
    }

    /**
     * Set CTRL1_TOG's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void set_CTRL1_TOG_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_TOG |= 1u << 26u;
    }

    /**
     * Clear CTRL1_TOG's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void clear_CTRL1_TOG_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_TOG &= ~(1u << 26u);
    }

    /**
     * Toggle CTRL1_TOG's BM_ERROR_IRQ_EN bit.
     *
     * This bit is set to enable bus master error interrupt in the LCDIF master
     * mode.
     */
    inline void toggle_CTRL1_TOG_BM_ERROR_IRQ_EN() volatile
    {
        CTRL1_TOG ^= 1u << 26u;
    }

    /**
     * Get CTRL1_TOG's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_TOG_BM_ERROR_IRQ() volatile
    {
        return CTRL1_TOG & (1u << 25u);
    }

    /**
     * Set CTRL1_TOG's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_TOG_BM_ERROR_IRQ() volatile
    {
        CTRL1_TOG |= 1u << 25u;
    }

    /**
     * Clear CTRL1_TOG's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_TOG_BM_ERROR_IRQ() volatile
    {
        CTRL1_TOG &= ~(1u << 25u);
    }

    /**
     * Toggle CTRL1_TOG's BM_ERROR_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_TOG_BM_ERROR_IRQ() volatile
    {
        CTRL1_TOG ^= 1u << 25u;
    }

    /**
     * Get CTRL1_TOG's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline bool get_CTRL1_TOG_RECOVER_ON_UNDERFLOW() volatile
    {
        return CTRL1_TOG & (1u << 24u);
    }

    /**
     * Set CTRL1_TOG's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void set_CTRL1_TOG_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_TOG |= 1u << 24u;
    }

    /**
     * Clear CTRL1_TOG's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void clear_CTRL1_TOG_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_TOG &= ~(1u << 24u);
    }

    /**
     * Toggle CTRL1_TOG's RECOVER_ON_UNDERFLOW bit.
     *
     * Set this bit to enable the LCDIF block to recover in the next
     * field/frame if there was an underflow in the current field/frame
     */
    inline void toggle_CTRL1_TOG_RECOVER_ON_UNDERFLOW() volatile
    {
        CTRL1_TOG ^= 1u << 24u;
    }

    /**
     * Get CTRL1_TOG's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline bool get_CTRL1_TOG_INTERLACE_FIELDS() volatile
    {
        return CTRL1_TOG & (1u << 23u);
    }

    /**
     * Set CTRL1_TOG's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void set_CTRL1_TOG_INTERLACE_FIELDS() volatile
    {
        CTRL1_TOG |= 1u << 23u;
    }

    /**
     * Clear CTRL1_TOG's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void clear_CTRL1_TOG_INTERLACE_FIELDS() volatile
    {
        CTRL1_TOG &= ~(1u << 23u);
    }

    /**
     * Toggle CTRL1_TOG's INTERLACE_FIELDS bit.
     *
     * Set this bit if it is required that the LCDIF block fetches odd lines in
     * one field and even lines in the other field
     */
    inline void toggle_CTRL1_TOG_INTERLACE_FIELDS() volatile
    {
        CTRL1_TOG ^= 1u << 23u;
    }

    /**
     * Get CTRL1_TOG's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline bool get_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        return CTRL1_TOG & (1u << 22u);
    }

    /**
     * Set CTRL1_TOG's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void set_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_TOG |= 1u << 22u;
    }

    /**
     * Clear CTRL1_TOG's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void clear_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_TOG &= ~(1u << 22u);
    }

    /**
     * Toggle CTRL1_TOG's START_INTERLACE_FROM_SECOND_FIELD bit.
     *
     * The default is to grab the odd lines first and then the even lines
     */
    inline void toggle_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD() volatile
    {
        CTRL1_TOG ^= 1u << 22u;
    }

    /**
     * Get CTRL1_TOG's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline bool get_CTRL1_TOG_FIFO_CLEAR() volatile
    {
        return CTRL1_TOG & (1u << 21u);
    }

    /**
     * Set CTRL1_TOG's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void set_CTRL1_TOG_FIFO_CLEAR() volatile
    {
        CTRL1_TOG |= 1u << 21u;
    }

    /**
     * Clear CTRL1_TOG's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void clear_CTRL1_TOG_FIFO_CLEAR() volatile
    {
        CTRL1_TOG &= ~(1u << 21u);
    }

    /**
     * Toggle CTRL1_TOG's FIFO_CLEAR bit.
     *
     * Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO
     * and the RXFIFO.
     */
    inline void toggle_CTRL1_TOG_FIFO_CLEAR() volatile
    {
        CTRL1_TOG ^= 1u << 21u;
    }

    /**
     * Get CTRL1_TOG's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline bool get_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        return CTRL1_TOG & (1u << 20u);
    }

    /**
     * Set CTRL1_TOG's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void set_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_TOG |= 1u << 20u;
    }

    /**
     * Clear CTRL1_TOG's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void clear_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL1_TOG's IRQ_ON_ALTERNATE_FIELDS bit.
     *
     * If this bit is set, the LCDIF block will assert the cur_frame_done
     * interrupt only on alternate fields, otherwise it will issue the
     * interrupt on both odd and even field
     */
    inline void toggle_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS() volatile
    {
        CTRL1_TOG ^= 1u << 20u;
    }

    /**
     * Get CTRL1_TOG's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline uint8_t get_CTRL1_TOG_BYTE_PACKING_FORMAT() volatile
    {
        return (CTRL1_TOG >> 16u) & 0b1111u;
    }

    /**
     * Set CTRL1_TOG's BYTE_PACKING_FORMAT field.
     *
     * This bitfield is used to show which data bytes in a 32-bit word are
     * valid
     */
    inline void set_CTRL1_TOG_BYTE_PACKING_FORMAT(uint8_t value) volatile
    {
        uint32_t curr = CTRL1_TOG;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        CTRL1_TOG = curr;
    }

    /**
     * Get CTRL1_TOG's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_TOG_OVERFLOW_IRQ_EN() volatile
    {
        return CTRL1_TOG & (1u << 15u);
    }

    /**
     * Set CTRL1_TOG's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_TOG_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_TOG |= 1u << 15u;
    }

    /**
     * Clear CTRL1_TOG's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_TOG_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_TOG &= ~(1u << 15u);
    }

    /**
     * Toggle CTRL1_TOG's OVERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an overflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_TOG_OVERFLOW_IRQ_EN() volatile
    {
        CTRL1_TOG ^= 1u << 15u;
    }

    /**
     * Get CTRL1_TOG's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline bool get_CTRL1_TOG_UNDERFLOW_IRQ_EN() volatile
    {
        return CTRL1_TOG & (1u << 14u);
    }

    /**
     * Set CTRL1_TOG's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void set_CTRL1_TOG_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_TOG |= 1u << 14u;
    }

    /**
     * Clear CTRL1_TOG's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void clear_CTRL1_TOG_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_TOG &= ~(1u << 14u);
    }

    /**
     * Toggle CTRL1_TOG's UNDERFLOW_IRQ_EN bit.
     *
     * This bit is set to enable an underflow interrupt in the TXFIFO in the
     * write mode.
     */
    inline void toggle_CTRL1_TOG_UNDERFLOW_IRQ_EN() volatile
    {
        CTRL1_TOG ^= 1u << 14u;
    }

    /**
     * Get CTRL1_TOG's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline bool get_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        return CTRL1_TOG & (1u << 13u);
    }

    /**
     * Set CTRL1_TOG's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void set_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_TOG |= 1u << 13u;
    }

    /**
     * Clear CTRL1_TOG's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void clear_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_TOG &= ~(1u << 13u);
    }

    /**
     * Toggle CTRL1_TOG's CUR_FRAME_DONE_IRQ_EN bit.
     *
     * This bit is set to 1 enable an interrupt every time the hardware enters
     * in the vertical blanking state
     */
    inline void toggle_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN() volatile
    {
        CTRL1_TOG ^= 1u << 13u;
    }

    /**
     * Get CTRL1_TOG's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline bool get_CTRL1_TOG_VSYNC_EDGE_IRQ_EN() volatile
    {
        return CTRL1_TOG & (1u << 12u);
    }

    /**
     * Set CTRL1_TOG's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void set_CTRL1_TOG_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_TOG |= 1u << 12u;
    }

    /**
     * Clear CTRL1_TOG's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void clear_CTRL1_TOG_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_TOG &= ~(1u << 12u);
    }

    /**
     * Toggle CTRL1_TOG's VSYNC_EDGE_IRQ_EN bit.
     *
     * This bit is set to enable an interrupt every time the hardware
     * encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the
     * beginning of every field in DVI mode
     */
    inline void toggle_CTRL1_TOG_VSYNC_EDGE_IRQ_EN() volatile
    {
        CTRL1_TOG ^= 1u << 12u;
    }

    /**
     * Get CTRL1_TOG's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_TOG_OVERFLOW_IRQ() volatile
    {
        return CTRL1_TOG & (1u << 11u);
    }

    /**
     * Set CTRL1_TOG's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_TOG_OVERFLOW_IRQ() volatile
    {
        CTRL1_TOG |= 1u << 11u;
    }

    /**
     * Clear CTRL1_TOG's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_TOG_OVERFLOW_IRQ() volatile
    {
        CTRL1_TOG &= ~(1u << 11u);
    }

    /**
     * Toggle CTRL1_TOG's OVERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_TOG_OVERFLOW_IRQ() volatile
    {
        CTRL1_TOG ^= 1u << 11u;
    }

    /**
     * Get CTRL1_TOG's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_TOG_UNDERFLOW_IRQ() volatile
    {
        return CTRL1_TOG & (1u << 10u);
    }

    /**
     * Set CTRL1_TOG's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_TOG_UNDERFLOW_IRQ() volatile
    {
        CTRL1_TOG |= 1u << 10u;
    }

    /**
     * Clear CTRL1_TOG's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_TOG_UNDERFLOW_IRQ() volatile
    {
        CTRL1_TOG &= ~(1u << 10u);
    }

    /**
     * Toggle CTRL1_TOG's UNDERFLOW_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_TOG_UNDERFLOW_IRQ() volatile
    {
        CTRL1_TOG ^= 1u << 10u;
    }

    /**
     * Get CTRL1_TOG's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_TOG_CUR_FRAME_DONE_IRQ() volatile
    {
        return CTRL1_TOG & (1u << 9u);
    }

    /**
     * Set CTRL1_TOG's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_TOG_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_TOG |= 1u << 9u;
    }

    /**
     * Clear CTRL1_TOG's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_TOG_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_TOG &= ~(1u << 9u);
    }

    /**
     * Toggle CTRL1_TOG's CUR_FRAME_DONE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_TOG_CUR_FRAME_DONE_IRQ() volatile
    {
        CTRL1_TOG ^= 1u << 9u;
    }

    /**
     * Get CTRL1_TOG's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline bool get_CTRL1_TOG_VSYNC_EDGE_IRQ() volatile
    {
        return CTRL1_TOG & (1u << 8u);
    }

    /**
     * Set CTRL1_TOG's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void set_CTRL1_TOG_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_TOG |= 1u << 8u;
    }

    /**
     * Clear CTRL1_TOG's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void clear_CTRL1_TOG_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_TOG &= ~(1u << 8u);
    }

    /**
     * Toggle CTRL1_TOG's VSYNC_EDGE_IRQ bit.
     *
     * This bit is set to indicate that an interrupt is requested by the LCDIF
     * block
     */
    inline void toggle_CTRL1_TOG_VSYNC_EDGE_IRQ() volatile
    {
        CTRL1_TOG ^= 1u << 8u;
    }

    /**
     * Get all of CTRL1_TOG's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void get_CTRL1_TOG(
        bool &IMAGE_DATA_SELECT, bool &CS_OUT_SELECT, bool &BM_ERROR_IRQ_EN,
        bool &BM_ERROR_IRQ, bool &RECOVER_ON_UNDERFLOW, bool &INTERLACE_FIELDS,
        bool &START_INTERLACE_FROM_SECOND_FIELD, bool &FIFO_CLEAR,
        bool &IRQ_ON_ALTERNATE_FIELDS, uint8_t &BYTE_PACKING_FORMAT,
        bool &OVERFLOW_IRQ_EN, bool &UNDERFLOW_IRQ_EN,
        bool &CUR_FRAME_DONE_IRQ_EN, bool &VSYNC_EDGE_IRQ_EN,
        bool &OVERFLOW_IRQ, bool &UNDERFLOW_IRQ, bool &CUR_FRAME_DONE_IRQ,
        bool &VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1_TOG;

        IMAGE_DATA_SELECT = curr & (1u << 31u);
        CS_OUT_SELECT = curr & (1u << 30u);
        BM_ERROR_IRQ_EN = curr & (1u << 26u);
        BM_ERROR_IRQ = curr & (1u << 25u);
        RECOVER_ON_UNDERFLOW = curr & (1u << 24u);
        INTERLACE_FIELDS = curr & (1u << 23u);
        START_INTERLACE_FROM_SECOND_FIELD = curr & (1u << 22u);
        FIFO_CLEAR = curr & (1u << 21u);
        IRQ_ON_ALTERNATE_FIELDS = curr & (1u << 20u);
        BYTE_PACKING_FORMAT = (curr >> 16u) & 0b1111u;
        OVERFLOW_IRQ_EN = curr & (1u << 15u);
        UNDERFLOW_IRQ_EN = curr & (1u << 14u);
        CUR_FRAME_DONE_IRQ_EN = curr & (1u << 13u);
        VSYNC_EDGE_IRQ_EN = curr & (1u << 12u);
        OVERFLOW_IRQ = curr & (1u << 11u);
        UNDERFLOW_IRQ = curr & (1u << 10u);
        CUR_FRAME_DONE_IRQ = curr & (1u << 9u);
        VSYNC_EDGE_IRQ = curr & (1u << 8u);
    }

    /**
     * Set all of CTRL1_TOG's bit fields.
     *
     * (read-write) LCDIF General Control1 Register
     */
    inline void set_CTRL1_TOG(bool IMAGE_DATA_SELECT, bool CS_OUT_SELECT,
                              bool BM_ERROR_IRQ_EN, bool BM_ERROR_IRQ,
                              bool RECOVER_ON_UNDERFLOW, bool INTERLACE_FIELDS,
                              bool START_INTERLACE_FROM_SECOND_FIELD,
                              bool FIFO_CLEAR, bool IRQ_ON_ALTERNATE_FIELDS,
                              uint8_t BYTE_PACKING_FORMAT,
                              bool OVERFLOW_IRQ_EN, bool UNDERFLOW_IRQ_EN,
                              bool CUR_FRAME_DONE_IRQ_EN,
                              bool VSYNC_EDGE_IRQ_EN, bool OVERFLOW_IRQ,
                              bool UNDERFLOW_IRQ, bool CUR_FRAME_DONE_IRQ,
                              bool VSYNC_EDGE_IRQ) volatile
    {
        uint32_t curr = CTRL1_TOG;

        curr &= ~(0b1u << 31u);
        curr |= (IMAGE_DATA_SELECT & 0b1u) << 31u;
        curr &= ~(0b1u << 30u);
        curr |= (CS_OUT_SELECT & 0b1u) << 30u;
        curr &= ~(0b1u << 26u);
        curr |= (BM_ERROR_IRQ_EN & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (BM_ERROR_IRQ & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (RECOVER_ON_UNDERFLOW & 0b1u) << 24u;
        curr &= ~(0b1u << 23u);
        curr |= (INTERLACE_FIELDS & 0b1u) << 23u;
        curr &= ~(0b1u << 22u);
        curr |= (START_INTERLACE_FROM_SECOND_FIELD & 0b1u) << 22u;
        curr &= ~(0b1u << 21u);
        curr |= (FIFO_CLEAR & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (IRQ_ON_ALTERNATE_FIELDS & 0b1u) << 20u;
        curr &= ~(0b1111u << 16u);
        curr |= (BYTE_PACKING_FORMAT & 0b1111u) << 16u;
        curr &= ~(0b1u << 15u);
        curr |= (OVERFLOW_IRQ_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (UNDERFLOW_IRQ_EN & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (CUR_FRAME_DONE_IRQ_EN & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (VSYNC_EDGE_IRQ_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (OVERFLOW_IRQ & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (UNDERFLOW_IRQ & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (CUR_FRAME_DONE_IRQ & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (VSYNC_EDGE_IRQ & 0b1u) << 8u;

        CTRL1_TOG = curr;
    }

    /**
     * Get CTRL2's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline LCDIF_CTRL2_OUTSTANDING_REQS get_CTRL2_OUTSTANDING_REQS() volatile
    {
        return LCDIF_CTRL2_OUTSTANDING_REQS((CTRL2 >> 21u) & 0b111u);
    }

    /**
     * Set CTRL2's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline void set_CTRL2_OUTSTANDING_REQS(
        LCDIF_CTRL2_OUTSTANDING_REQS value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(value) & 0b111u) << 21u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline bool get_CTRL2_BURST_LEN_8() volatile
    {
        return CTRL2 & (1u << 20u);
    }

    /**
     * Set CTRL2's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void set_CTRL2_BURST_LEN_8() volatile
    {
        CTRL2 |= 1u << 20u;
    }

    /**
     * Clear CTRL2's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void clear_CTRL2_BURST_LEN_8() volatile
    {
        CTRL2 &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL2's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void toggle_CTRL2_BURST_LEN_8() volatile
    {
        CTRL2 ^= 1u << 20u;
    }

    /**
     * Get CTRL2's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline LCDIF_CTRL2_ODD_LINE_PATTERN get_CTRL2_ODD_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_ODD_LINE_PATTERN((CTRL2 >> 16u) & 0b111u);
    }

    /**
     * Set CTRL2's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline void set_CTRL2_ODD_LINE_PATTERN(
        LCDIF_CTRL2_ODD_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline LCDIF_CTRL2_EVEN_LINE_PATTERN get_CTRL2_EVEN_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_EVEN_LINE_PATTERN((CTRL2 >> 12u) & 0b111u);
    }

    /**
     * Set CTRL2's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline void set_CTRL2_EVEN_LINE_PATTERN(
        LCDIF_CTRL2_EVEN_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CTRL2 = curr;
    }

    /**
     * Get all of CTRL2's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void get_CTRL2(
        LCDIF_CTRL2_OUTSTANDING_REQS &OUTSTANDING_REQS, bool &BURST_LEN_8,
        LCDIF_CTRL2_ODD_LINE_PATTERN &ODD_LINE_PATTERN,
        LCDIF_CTRL2_EVEN_LINE_PATTERN &EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2;

        OUTSTANDING_REQS =
            LCDIF_CTRL2_OUTSTANDING_REQS((curr >> 21u) & 0b111u);
        BURST_LEN_8 = curr & (1u << 20u);
        ODD_LINE_PATTERN =
            LCDIF_CTRL2_ODD_LINE_PATTERN((curr >> 16u) & 0b111u);
        EVEN_LINE_PATTERN =
            LCDIF_CTRL2_EVEN_LINE_PATTERN((curr >> 12u) & 0b111u);
    }

    /**
     * Set all of CTRL2's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void set_CTRL2(
        LCDIF_CTRL2_OUTSTANDING_REQS OUTSTANDING_REQS, bool BURST_LEN_8,
        LCDIF_CTRL2_ODD_LINE_PATTERN ODD_LINE_PATTERN,
        LCDIF_CTRL2_EVEN_LINE_PATTERN EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(OUTSTANDING_REQS) & 0b111u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BURST_LEN_8 & 0b1u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(ODD_LINE_PATTERN) & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(EVEN_LINE_PATTERN) & 0b111u) << 12u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2_SET's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline LCDIF_CTRL2_SET_OUTSTANDING_REQS
    get_CTRL2_SET_OUTSTANDING_REQS() volatile
    {
        return LCDIF_CTRL2_SET_OUTSTANDING_REQS((CTRL2_SET >> 21u) & 0b111u);
    }

    /**
     * Set CTRL2_SET's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline void set_CTRL2_SET_OUTSTANDING_REQS(
        LCDIF_CTRL2_SET_OUTSTANDING_REQS value) volatile
    {
        uint32_t curr = CTRL2_SET;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(value) & 0b111u) << 21u;

        CTRL2_SET = curr;
    }

    /**
     * Get CTRL2_SET's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline bool get_CTRL2_SET_BURST_LEN_8() volatile
    {
        return CTRL2_SET & (1u << 20u);
    }

    /**
     * Set CTRL2_SET's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void set_CTRL2_SET_BURST_LEN_8() volatile
    {
        CTRL2_SET |= 1u << 20u;
    }

    /**
     * Clear CTRL2_SET's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void clear_CTRL2_SET_BURST_LEN_8() volatile
    {
        CTRL2_SET &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL2_SET's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void toggle_CTRL2_SET_BURST_LEN_8() volatile
    {
        CTRL2_SET ^= 1u << 20u;
    }

    /**
     * Get CTRL2_SET's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline LCDIF_CTRL2_SET_ODD_LINE_PATTERN
    get_CTRL2_SET_ODD_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_SET_ODD_LINE_PATTERN((CTRL2_SET >> 16u) & 0b111u);
    }

    /**
     * Set CTRL2_SET's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline void set_CTRL2_SET_ODD_LINE_PATTERN(
        LCDIF_CTRL2_SET_ODD_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2_SET;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        CTRL2_SET = curr;
    }

    /**
     * Get CTRL2_SET's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline LCDIF_CTRL2_SET_EVEN_LINE_PATTERN
    get_CTRL2_SET_EVEN_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_SET_EVEN_LINE_PATTERN((CTRL2_SET >> 12u) & 0b111u);
    }

    /**
     * Set CTRL2_SET's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline void set_CTRL2_SET_EVEN_LINE_PATTERN(
        LCDIF_CTRL2_SET_EVEN_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2_SET;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CTRL2_SET = curr;
    }

    /**
     * Get all of CTRL2_SET's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void get_CTRL2_SET(
        LCDIF_CTRL2_SET_OUTSTANDING_REQS &OUTSTANDING_REQS, bool &BURST_LEN_8,
        LCDIF_CTRL2_SET_ODD_LINE_PATTERN &ODD_LINE_PATTERN,
        LCDIF_CTRL2_SET_EVEN_LINE_PATTERN &EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2_SET;

        OUTSTANDING_REQS =
            LCDIF_CTRL2_SET_OUTSTANDING_REQS((curr >> 21u) & 0b111u);
        BURST_LEN_8 = curr & (1u << 20u);
        ODD_LINE_PATTERN =
            LCDIF_CTRL2_SET_ODD_LINE_PATTERN((curr >> 16u) & 0b111u);
        EVEN_LINE_PATTERN =
            LCDIF_CTRL2_SET_EVEN_LINE_PATTERN((curr >> 12u) & 0b111u);
    }

    /**
     * Set all of CTRL2_SET's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void set_CTRL2_SET(
        LCDIF_CTRL2_SET_OUTSTANDING_REQS OUTSTANDING_REQS, bool BURST_LEN_8,
        LCDIF_CTRL2_SET_ODD_LINE_PATTERN ODD_LINE_PATTERN,
        LCDIF_CTRL2_SET_EVEN_LINE_PATTERN EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2_SET;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(OUTSTANDING_REQS) & 0b111u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BURST_LEN_8 & 0b1u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(ODD_LINE_PATTERN) & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(EVEN_LINE_PATTERN) & 0b111u) << 12u;

        CTRL2_SET = curr;
    }

    /**
     * Get CTRL2_CLR's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline LCDIF_CTRL2_CLR_OUTSTANDING_REQS
    get_CTRL2_CLR_OUTSTANDING_REQS() volatile
    {
        return LCDIF_CTRL2_CLR_OUTSTANDING_REQS((CTRL2_CLR >> 21u) & 0b111u);
    }

    /**
     * Set CTRL2_CLR's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline void set_CTRL2_CLR_OUTSTANDING_REQS(
        LCDIF_CTRL2_CLR_OUTSTANDING_REQS value) volatile
    {
        uint32_t curr = CTRL2_CLR;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(value) & 0b111u) << 21u;

        CTRL2_CLR = curr;
    }

    /**
     * Get CTRL2_CLR's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline bool get_CTRL2_CLR_BURST_LEN_8() volatile
    {
        return CTRL2_CLR & (1u << 20u);
    }

    /**
     * Set CTRL2_CLR's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void set_CTRL2_CLR_BURST_LEN_8() volatile
    {
        CTRL2_CLR |= 1u << 20u;
    }

    /**
     * Clear CTRL2_CLR's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void clear_CTRL2_CLR_BURST_LEN_8() volatile
    {
        CTRL2_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL2_CLR's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void toggle_CTRL2_CLR_BURST_LEN_8() volatile
    {
        CTRL2_CLR ^= 1u << 20u;
    }

    /**
     * Get CTRL2_CLR's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline LCDIF_CTRL2_CLR_ODD_LINE_PATTERN
    get_CTRL2_CLR_ODD_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_CLR_ODD_LINE_PATTERN((CTRL2_CLR >> 16u) & 0b111u);
    }

    /**
     * Set CTRL2_CLR's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline void set_CTRL2_CLR_ODD_LINE_PATTERN(
        LCDIF_CTRL2_CLR_ODD_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2_CLR;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        CTRL2_CLR = curr;
    }

    /**
     * Get CTRL2_CLR's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN
    get_CTRL2_CLR_EVEN_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN((CTRL2_CLR >> 12u) & 0b111u);
    }

    /**
     * Set CTRL2_CLR's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline void set_CTRL2_CLR_EVEN_LINE_PATTERN(
        LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2_CLR;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CTRL2_CLR = curr;
    }

    /**
     * Get all of CTRL2_CLR's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void get_CTRL2_CLR(
        LCDIF_CTRL2_CLR_OUTSTANDING_REQS &OUTSTANDING_REQS, bool &BURST_LEN_8,
        LCDIF_CTRL2_CLR_ODD_LINE_PATTERN &ODD_LINE_PATTERN,
        LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN &EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2_CLR;

        OUTSTANDING_REQS =
            LCDIF_CTRL2_CLR_OUTSTANDING_REQS((curr >> 21u) & 0b111u);
        BURST_LEN_8 = curr & (1u << 20u);
        ODD_LINE_PATTERN =
            LCDIF_CTRL2_CLR_ODD_LINE_PATTERN((curr >> 16u) & 0b111u);
        EVEN_LINE_PATTERN =
            LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN((curr >> 12u) & 0b111u);
    }

    /**
     * Set all of CTRL2_CLR's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void set_CTRL2_CLR(
        LCDIF_CTRL2_CLR_OUTSTANDING_REQS OUTSTANDING_REQS, bool BURST_LEN_8,
        LCDIF_CTRL2_CLR_ODD_LINE_PATTERN ODD_LINE_PATTERN,
        LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2_CLR;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(OUTSTANDING_REQS) & 0b111u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BURST_LEN_8 & 0b1u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(ODD_LINE_PATTERN) & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(EVEN_LINE_PATTERN) & 0b111u) << 12u;

        CTRL2_CLR = curr;
    }

    /**
     * Get CTRL2_TOG's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline LCDIF_CTRL2_TOG_OUTSTANDING_REQS
    get_CTRL2_TOG_OUTSTANDING_REQS() volatile
    {
        return LCDIF_CTRL2_TOG_OUTSTANDING_REQS((CTRL2_TOG >> 21u) & 0b111u);
    }

    /**
     * Set CTRL2_TOG's OUTSTANDING_REQS field.
     *
     * This bitfield indicates the maximum number of outstanding transactions
     * that LCDIF should request when it is acting as a bus master
     */
    inline void set_CTRL2_TOG_OUTSTANDING_REQS(
        LCDIF_CTRL2_TOG_OUTSTANDING_REQS value) volatile
    {
        uint32_t curr = CTRL2_TOG;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(value) & 0b111u) << 21u;

        CTRL2_TOG = curr;
    }

    /**
     * Get CTRL2_TOG's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline bool get_CTRL2_TOG_BURST_LEN_8() volatile
    {
        return CTRL2_TOG & (1u << 20u);
    }

    /**
     * Set CTRL2_TOG's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void set_CTRL2_TOG_BURST_LEN_8() volatile
    {
        CTRL2_TOG |= 1u << 20u;
    }

    /**
     * Clear CTRL2_TOG's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void clear_CTRL2_TOG_BURST_LEN_8() volatile
    {
        CTRL2_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle CTRL2_TOG's BURST_LEN_8 bit.
     *
     * By default, when the LCDIF is in the bus master mode, it will issue AXI
     * bursts of length 16 (except when in packed 24 bpp mode, it will issue
     * bursts of length 15)
     */
    inline void toggle_CTRL2_TOG_BURST_LEN_8() volatile
    {
        CTRL2_TOG ^= 1u << 20u;
    }

    /**
     * Get CTRL2_TOG's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline LCDIF_CTRL2_TOG_ODD_LINE_PATTERN
    get_CTRL2_TOG_ODD_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_TOG_ODD_LINE_PATTERN((CTRL2_TOG >> 16u) & 0b111u);
    }

    /**
     * Set CTRL2_TOG's ODD_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * ODD lines (line numbers 1,3,5,
     */
    inline void set_CTRL2_TOG_ODD_LINE_PATTERN(
        LCDIF_CTRL2_TOG_ODD_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2_TOG;

        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(value) & 0b111u) << 16u;

        CTRL2_TOG = curr;
    }

    /**
     * Get CTRL2_TOG's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN
    get_CTRL2_TOG_EVEN_LINE_PATTERN() volatile
    {
        return LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN((CTRL2_TOG >> 12u) & 0b111u);
    }

    /**
     * Set CTRL2_TOG's EVEN_LINE_PATTERN field.
     *
     * This field determines the order of the RGB components of each pixel in
     * EVEN lines (line numbers 2,4,6,
     */
    inline void set_CTRL2_TOG_EVEN_LINE_PATTERN(
        LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN value) volatile
    {
        uint32_t curr = CTRL2_TOG;

        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(value) & 0b111u) << 12u;

        CTRL2_TOG = curr;
    }

    /**
     * Get all of CTRL2_TOG's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void get_CTRL2_TOG(
        LCDIF_CTRL2_TOG_OUTSTANDING_REQS &OUTSTANDING_REQS, bool &BURST_LEN_8,
        LCDIF_CTRL2_TOG_ODD_LINE_PATTERN &ODD_LINE_PATTERN,
        LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN &EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2_TOG;

        OUTSTANDING_REQS =
            LCDIF_CTRL2_TOG_OUTSTANDING_REQS((curr >> 21u) & 0b111u);
        BURST_LEN_8 = curr & (1u << 20u);
        ODD_LINE_PATTERN =
            LCDIF_CTRL2_TOG_ODD_LINE_PATTERN((curr >> 16u) & 0b111u);
        EVEN_LINE_PATTERN =
            LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN((curr >> 12u) & 0b111u);
    }

    /**
     * Set all of CTRL2_TOG's bit fields.
     *
     * (read-write) LCDIF General Control2 Register
     */
    inline void set_CTRL2_TOG(
        LCDIF_CTRL2_TOG_OUTSTANDING_REQS OUTSTANDING_REQS, bool BURST_LEN_8,
        LCDIF_CTRL2_TOG_ODD_LINE_PATTERN ODD_LINE_PATTERN,
        LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN EVEN_LINE_PATTERN) volatile
    {
        uint32_t curr = CTRL2_TOG;

        curr &= ~(0b111u << 21u);
        curr |= (std::to_underlying(OUTSTANDING_REQS) & 0b111u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (BURST_LEN_8 & 0b1u) << 20u;
        curr &= ~(0b111u << 16u);
        curr |= (std::to_underlying(ODD_LINE_PATTERN) & 0b111u) << 16u;
        curr &= ~(0b111u << 12u);
        curr |= (std::to_underlying(EVEN_LINE_PATTERN) & 0b111u) << 12u;

        CTRL2_TOG = curr;
    }

    /**
     * Get TRANSFER_COUNT's V_COUNT field.
     *
     * Number of horizontal lines per frame which contain valid data
     */
    inline uint16_t get_TRANSFER_COUNT_V_COUNT() volatile
    {
        return (TRANSFER_COUNT >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TRANSFER_COUNT's V_COUNT field.
     *
     * Number of horizontal lines per frame which contain valid data
     */
    inline void set_TRANSFER_COUNT_V_COUNT(uint16_t value) volatile
    {
        uint32_t curr = TRANSFER_COUNT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TRANSFER_COUNT = curr;
    }

    /**
     * Get TRANSFER_COUNT's H_COUNT field.
     *
     * Total valid data (pixels) in each horizontal line
     */
    inline uint16_t get_TRANSFER_COUNT_H_COUNT() volatile
    {
        return (TRANSFER_COUNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TRANSFER_COUNT's H_COUNT field.
     *
     * Total valid data (pixels) in each horizontal line
     */
    inline void set_TRANSFER_COUNT_H_COUNT(uint16_t value) volatile
    {
        uint32_t curr = TRANSFER_COUNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TRANSFER_COUNT = curr;
    }

    /**
     * Get all of TRANSFER_COUNT's bit fields.
     *
     * (read-write) LCDIF Horizontal and Vertical Valid Data Count Register
     */
    inline void get_TRANSFER_COUNT(uint16_t &V_COUNT,
                                   uint16_t &H_COUNT) volatile
    {
        uint32_t curr = TRANSFER_COUNT;

        V_COUNT = (curr >> 16u) & 0b1111111111111111u;
        H_COUNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of TRANSFER_COUNT's bit fields.
     *
     * (read-write) LCDIF Horizontal and Vertical Valid Data Count Register
     */
    inline void set_TRANSFER_COUNT(uint16_t V_COUNT, uint16_t H_COUNT) volatile
    {
        uint32_t curr = TRANSFER_COUNT;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (V_COUNT & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (H_COUNT & 0b1111111111111111u) << 0u;

        TRANSFER_COUNT = curr;
    }

    /**
     * Get CUR_BUF's ADDR field.
     *
     * Address of the current frame being transmitted by LCDIF.
     */
    inline uint32_t get_CUR_BUF_ADDR() volatile
    {
        return (CUR_BUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set CUR_BUF's ADDR field.
     *
     * Address of the current frame being transmitted by LCDIF.
     */
    inline void set_CUR_BUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = CUR_BUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CUR_BUF = curr;
    }

    /**
     * Get NEXT_BUF's ADDR field.
     *
     * Address of the next frame that will be transmitted by LCDIF.
     */
    inline uint32_t get_NEXT_BUF_ADDR() volatile
    {
        return (NEXT_BUF >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NEXT_BUF's ADDR field.
     *
     * Address of the next frame that will be transmitted by LCDIF.
     */
    inline void set_NEXT_BUF_ADDR(uint32_t value) volatile
    {
        uint32_t curr = NEXT_BUF;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NEXT_BUF = curr;
    }

    /**
     * Get VDCTRL0's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline bool get_VDCTRL0_VSYNC_OEB() volatile
    {
        return VDCTRL0 & (1u << 29u);
    }

    /**
     * Set VDCTRL0's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void set_VDCTRL0_VSYNC_OEB() volatile
    {
        VDCTRL0 |= 1u << 29u;
    }

    /**
     * Clear VDCTRL0's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void clear_VDCTRL0_VSYNC_OEB() volatile
    {
        VDCTRL0 &= ~(1u << 29u);
    }

    /**
     * Toggle VDCTRL0's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void toggle_VDCTRL0_VSYNC_OEB() volatile
    {
        VDCTRL0 ^= 1u << 29u;
    }

    /**
     * Get VDCTRL0's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline bool get_VDCTRL0_ENABLE_PRESENT() volatile
    {
        return VDCTRL0 & (1u << 28u);
    }

    /**
     * Set VDCTRL0's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void set_VDCTRL0_ENABLE_PRESENT() volatile
    {
        VDCTRL0 |= 1u << 28u;
    }

    /**
     * Clear VDCTRL0's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void clear_VDCTRL0_ENABLE_PRESENT() volatile
    {
        VDCTRL0 &= ~(1u << 28u);
    }

    /**
     * Toggle VDCTRL0's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void toggle_VDCTRL0_ENABLE_PRESENT() volatile
    {
        VDCTRL0 ^= 1u << 28u;
    }

    /**
     * Get VDCTRL0's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline bool get_VDCTRL0_VSYNC_POL() volatile
    {
        return VDCTRL0 & (1u << 27u);
    }

    /**
     * Set VDCTRL0's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void set_VDCTRL0_VSYNC_POL() volatile
    {
        VDCTRL0 |= 1u << 27u;
    }

    /**
     * Clear VDCTRL0's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void clear_VDCTRL0_VSYNC_POL() volatile
    {
        VDCTRL0 &= ~(1u << 27u);
    }

    /**
     * Toggle VDCTRL0's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void toggle_VDCTRL0_VSYNC_POL() volatile
    {
        VDCTRL0 ^= 1u << 27u;
    }

    /**
     * Get VDCTRL0's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline bool get_VDCTRL0_HSYNC_POL() volatile
    {
        return VDCTRL0 & (1u << 26u);
    }

    /**
     * Set VDCTRL0's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void set_VDCTRL0_HSYNC_POL() volatile
    {
        VDCTRL0 |= 1u << 26u;
    }

    /**
     * Clear VDCTRL0's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void clear_VDCTRL0_HSYNC_POL() volatile
    {
        VDCTRL0 &= ~(1u << 26u);
    }

    /**
     * Toggle VDCTRL0's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void toggle_VDCTRL0_HSYNC_POL() volatile
    {
        VDCTRL0 ^= 1u << 26u;
    }

    /**
     * Get VDCTRL0's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline bool get_VDCTRL0_DOTCLK_POL() volatile
    {
        return VDCTRL0 & (1u << 25u);
    }

    /**
     * Set VDCTRL0's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void set_VDCTRL0_DOTCLK_POL() volatile
    {
        VDCTRL0 |= 1u << 25u;
    }

    /**
     * Clear VDCTRL0's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void clear_VDCTRL0_DOTCLK_POL() volatile
    {
        VDCTRL0 &= ~(1u << 25u);
    }

    /**
     * Toggle VDCTRL0's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void toggle_VDCTRL0_DOTCLK_POL() volatile
    {
        VDCTRL0 ^= 1u << 25u;
    }

    /**
     * Get VDCTRL0's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline bool get_VDCTRL0_ENABLE_POL() volatile
    {
        return VDCTRL0 & (1u << 24u);
    }

    /**
     * Set VDCTRL0's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void set_VDCTRL0_ENABLE_POL() volatile
    {
        VDCTRL0 |= 1u << 24u;
    }

    /**
     * Clear VDCTRL0's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void clear_VDCTRL0_ENABLE_POL() volatile
    {
        VDCTRL0 &= ~(1u << 24u);
    }

    /**
     * Toggle VDCTRL0's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void toggle_VDCTRL0_ENABLE_POL() volatile
    {
        VDCTRL0 ^= 1u << 24u;
    }

    /**
     * Get VDCTRL0's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline bool get_VDCTRL0_VSYNC_PERIOD_UNIT() volatile
    {
        return VDCTRL0 & (1u << 21u);
    }

    /**
     * Set VDCTRL0's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void set_VDCTRL0_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0 |= 1u << 21u;
    }

    /**
     * Clear VDCTRL0's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void clear_VDCTRL0_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0 &= ~(1u << 21u);
    }

    /**
     * Toggle VDCTRL0's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void toggle_VDCTRL0_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0 ^= 1u << 21u;
    }

    /**
     * Get VDCTRL0's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline bool get_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        return VDCTRL0 & (1u << 20u);
    }

    /**
     * Set VDCTRL0's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void set_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0 |= 1u << 20u;
    }

    /**
     * Clear VDCTRL0's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void clear_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0 &= ~(1u << 20u);
    }

    /**
     * Toggle VDCTRL0's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void toggle_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0 ^= 1u << 20u;
    }

    /**
     * Get VDCTRL0's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline bool get_VDCTRL0_HALF_LINE() volatile
    {
        return VDCTRL0 & (1u << 19u);
    }

    /**
     * Set VDCTRL0's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void set_VDCTRL0_HALF_LINE() volatile
    {
        VDCTRL0 |= 1u << 19u;
    }

    /**
     * Clear VDCTRL0's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void clear_VDCTRL0_HALF_LINE() volatile
    {
        VDCTRL0 &= ~(1u << 19u);
    }

    /**
     * Toggle VDCTRL0's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void toggle_VDCTRL0_HALF_LINE() volatile
    {
        VDCTRL0 ^= 1u << 19u;
    }

    /**
     * Get VDCTRL0's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline bool get_VDCTRL0_HALF_LINE_MODE() volatile
    {
        return VDCTRL0 & (1u << 18u);
    }

    /**
     * Set VDCTRL0's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void set_VDCTRL0_HALF_LINE_MODE() volatile
    {
        VDCTRL0 |= 1u << 18u;
    }

    /**
     * Clear VDCTRL0's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void clear_VDCTRL0_HALF_LINE_MODE() volatile
    {
        VDCTRL0 &= ~(1u << 18u);
    }

    /**
     * Toggle VDCTRL0's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void toggle_VDCTRL0_HALF_LINE_MODE() volatile
    {
        VDCTRL0 ^= 1u << 18u;
    }

    /**
     * Get VDCTRL0's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline uint32_t get_VDCTRL0_VSYNC_PULSE_WIDTH() volatile
    {
        return (VDCTRL0 >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set VDCTRL0's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline void set_VDCTRL0_VSYNC_PULSE_WIDTH(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL0;

        curr &= ~(0b111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111u) << 0u;

        VDCTRL0 = curr;
    }

    /**
     * Get all of VDCTRL0's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void get_VDCTRL0(bool &VSYNC_OEB, bool &ENABLE_PRESENT,
                            bool &VSYNC_POL, bool &HSYNC_POL, bool &DOTCLK_POL,
                            bool &ENABLE_POL, bool &VSYNC_PERIOD_UNIT,
                            bool &VSYNC_PULSE_WIDTH_UNIT, bool &HALF_LINE,
                            bool &HALF_LINE_MODE,
                            uint32_t &VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0;

        VSYNC_OEB = curr & (1u << 29u);
        ENABLE_PRESENT = curr & (1u << 28u);
        VSYNC_POL = curr & (1u << 27u);
        HSYNC_POL = curr & (1u << 26u);
        DOTCLK_POL = curr & (1u << 25u);
        ENABLE_POL = curr & (1u << 24u);
        VSYNC_PERIOD_UNIT = curr & (1u << 21u);
        VSYNC_PULSE_WIDTH_UNIT = curr & (1u << 20u);
        HALF_LINE = curr & (1u << 19u);
        HALF_LINE_MODE = curr & (1u << 18u);
        VSYNC_PULSE_WIDTH = (curr >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set all of VDCTRL0's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void set_VDCTRL0(bool VSYNC_OEB, bool ENABLE_PRESENT,
                            bool VSYNC_POL, bool HSYNC_POL, bool DOTCLK_POL,
                            bool ENABLE_POL, bool VSYNC_PERIOD_UNIT,
                            bool VSYNC_PULSE_WIDTH_UNIT, bool HALF_LINE,
                            bool HALF_LINE_MODE,
                            uint32_t VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0;

        curr &= ~(0b1u << 29u);
        curr |= (VSYNC_OEB & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (ENABLE_PRESENT & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (VSYNC_POL & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (HSYNC_POL & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DOTCLK_POL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENABLE_POL & 0b1u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (VSYNC_PERIOD_UNIT & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (VSYNC_PULSE_WIDTH_UNIT & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (HALF_LINE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (HALF_LINE_MODE & 0b1u) << 18u;
        curr &= ~(0b111111111111111111u << 0u);
        curr |= (VSYNC_PULSE_WIDTH & 0b111111111111111111u) << 0u;

        VDCTRL0 = curr;
    }

    /**
     * Get VDCTRL0_SET's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline bool get_VDCTRL0_SET_VSYNC_OEB() volatile
    {
        return VDCTRL0_SET & (1u << 29u);
    }

    /**
     * Set VDCTRL0_SET's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void set_VDCTRL0_SET_VSYNC_OEB() volatile
    {
        VDCTRL0_SET |= 1u << 29u;
    }

    /**
     * Clear VDCTRL0_SET's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void clear_VDCTRL0_SET_VSYNC_OEB() volatile
    {
        VDCTRL0_SET &= ~(1u << 29u);
    }

    /**
     * Toggle VDCTRL0_SET's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void toggle_VDCTRL0_SET_VSYNC_OEB() volatile
    {
        VDCTRL0_SET ^= 1u << 29u;
    }

    /**
     * Get VDCTRL0_SET's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline bool get_VDCTRL0_SET_ENABLE_PRESENT() volatile
    {
        return VDCTRL0_SET & (1u << 28u);
    }

    /**
     * Set VDCTRL0_SET's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void set_VDCTRL0_SET_ENABLE_PRESENT() volatile
    {
        VDCTRL0_SET |= 1u << 28u;
    }

    /**
     * Clear VDCTRL0_SET's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void clear_VDCTRL0_SET_ENABLE_PRESENT() volatile
    {
        VDCTRL0_SET &= ~(1u << 28u);
    }

    /**
     * Toggle VDCTRL0_SET's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void toggle_VDCTRL0_SET_ENABLE_PRESENT() volatile
    {
        VDCTRL0_SET ^= 1u << 28u;
    }

    /**
     * Get VDCTRL0_SET's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline bool get_VDCTRL0_SET_VSYNC_POL() volatile
    {
        return VDCTRL0_SET & (1u << 27u);
    }

    /**
     * Set VDCTRL0_SET's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void set_VDCTRL0_SET_VSYNC_POL() volatile
    {
        VDCTRL0_SET |= 1u << 27u;
    }

    /**
     * Clear VDCTRL0_SET's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void clear_VDCTRL0_SET_VSYNC_POL() volatile
    {
        VDCTRL0_SET &= ~(1u << 27u);
    }

    /**
     * Toggle VDCTRL0_SET's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void toggle_VDCTRL0_SET_VSYNC_POL() volatile
    {
        VDCTRL0_SET ^= 1u << 27u;
    }

    /**
     * Get VDCTRL0_SET's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline bool get_VDCTRL0_SET_HSYNC_POL() volatile
    {
        return VDCTRL0_SET & (1u << 26u);
    }

    /**
     * Set VDCTRL0_SET's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void set_VDCTRL0_SET_HSYNC_POL() volatile
    {
        VDCTRL0_SET |= 1u << 26u;
    }

    /**
     * Clear VDCTRL0_SET's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void clear_VDCTRL0_SET_HSYNC_POL() volatile
    {
        VDCTRL0_SET &= ~(1u << 26u);
    }

    /**
     * Toggle VDCTRL0_SET's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void toggle_VDCTRL0_SET_HSYNC_POL() volatile
    {
        VDCTRL0_SET ^= 1u << 26u;
    }

    /**
     * Get VDCTRL0_SET's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline bool get_VDCTRL0_SET_DOTCLK_POL() volatile
    {
        return VDCTRL0_SET & (1u << 25u);
    }

    /**
     * Set VDCTRL0_SET's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void set_VDCTRL0_SET_DOTCLK_POL() volatile
    {
        VDCTRL0_SET |= 1u << 25u;
    }

    /**
     * Clear VDCTRL0_SET's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void clear_VDCTRL0_SET_DOTCLK_POL() volatile
    {
        VDCTRL0_SET &= ~(1u << 25u);
    }

    /**
     * Toggle VDCTRL0_SET's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void toggle_VDCTRL0_SET_DOTCLK_POL() volatile
    {
        VDCTRL0_SET ^= 1u << 25u;
    }

    /**
     * Get VDCTRL0_SET's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline bool get_VDCTRL0_SET_ENABLE_POL() volatile
    {
        return VDCTRL0_SET & (1u << 24u);
    }

    /**
     * Set VDCTRL0_SET's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void set_VDCTRL0_SET_ENABLE_POL() volatile
    {
        VDCTRL0_SET |= 1u << 24u;
    }

    /**
     * Clear VDCTRL0_SET's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void clear_VDCTRL0_SET_ENABLE_POL() volatile
    {
        VDCTRL0_SET &= ~(1u << 24u);
    }

    /**
     * Toggle VDCTRL0_SET's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void toggle_VDCTRL0_SET_ENABLE_POL() volatile
    {
        VDCTRL0_SET ^= 1u << 24u;
    }

    /**
     * Get VDCTRL0_SET's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline bool get_VDCTRL0_SET_VSYNC_PERIOD_UNIT() volatile
    {
        return VDCTRL0_SET & (1u << 21u);
    }

    /**
     * Set VDCTRL0_SET's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void set_VDCTRL0_SET_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_SET |= 1u << 21u;
    }

    /**
     * Clear VDCTRL0_SET's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void clear_VDCTRL0_SET_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_SET &= ~(1u << 21u);
    }

    /**
     * Toggle VDCTRL0_SET's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void toggle_VDCTRL0_SET_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_SET ^= 1u << 21u;
    }

    /**
     * Get VDCTRL0_SET's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline bool get_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        return VDCTRL0_SET & (1u << 20u);
    }

    /**
     * Set VDCTRL0_SET's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void set_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_SET |= 1u << 20u;
    }

    /**
     * Clear VDCTRL0_SET's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void clear_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_SET &= ~(1u << 20u);
    }

    /**
     * Toggle VDCTRL0_SET's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void toggle_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_SET ^= 1u << 20u;
    }

    /**
     * Get VDCTRL0_SET's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline bool get_VDCTRL0_SET_HALF_LINE() volatile
    {
        return VDCTRL0_SET & (1u << 19u);
    }

    /**
     * Set VDCTRL0_SET's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void set_VDCTRL0_SET_HALF_LINE() volatile
    {
        VDCTRL0_SET |= 1u << 19u;
    }

    /**
     * Clear VDCTRL0_SET's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void clear_VDCTRL0_SET_HALF_LINE() volatile
    {
        VDCTRL0_SET &= ~(1u << 19u);
    }

    /**
     * Toggle VDCTRL0_SET's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void toggle_VDCTRL0_SET_HALF_LINE() volatile
    {
        VDCTRL0_SET ^= 1u << 19u;
    }

    /**
     * Get VDCTRL0_SET's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline bool get_VDCTRL0_SET_HALF_LINE_MODE() volatile
    {
        return VDCTRL0_SET & (1u << 18u);
    }

    /**
     * Set VDCTRL0_SET's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void set_VDCTRL0_SET_HALF_LINE_MODE() volatile
    {
        VDCTRL0_SET |= 1u << 18u;
    }

    /**
     * Clear VDCTRL0_SET's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void clear_VDCTRL0_SET_HALF_LINE_MODE() volatile
    {
        VDCTRL0_SET &= ~(1u << 18u);
    }

    /**
     * Toggle VDCTRL0_SET's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void toggle_VDCTRL0_SET_HALF_LINE_MODE() volatile
    {
        VDCTRL0_SET ^= 1u << 18u;
    }

    /**
     * Get VDCTRL0_SET's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline uint32_t get_VDCTRL0_SET_VSYNC_PULSE_WIDTH() volatile
    {
        return (VDCTRL0_SET >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set VDCTRL0_SET's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline void set_VDCTRL0_SET_VSYNC_PULSE_WIDTH(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL0_SET;

        curr &= ~(0b111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111u) << 0u;

        VDCTRL0_SET = curr;
    }

    /**
     * Get all of VDCTRL0_SET's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void get_VDCTRL0_SET(bool &VSYNC_OEB, bool &ENABLE_PRESENT,
                                bool &VSYNC_POL, bool &HSYNC_POL,
                                bool &DOTCLK_POL, bool &ENABLE_POL,
                                bool &VSYNC_PERIOD_UNIT,
                                bool &VSYNC_PULSE_WIDTH_UNIT, bool &HALF_LINE,
                                bool &HALF_LINE_MODE,
                                uint32_t &VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0_SET;

        VSYNC_OEB = curr & (1u << 29u);
        ENABLE_PRESENT = curr & (1u << 28u);
        VSYNC_POL = curr & (1u << 27u);
        HSYNC_POL = curr & (1u << 26u);
        DOTCLK_POL = curr & (1u << 25u);
        ENABLE_POL = curr & (1u << 24u);
        VSYNC_PERIOD_UNIT = curr & (1u << 21u);
        VSYNC_PULSE_WIDTH_UNIT = curr & (1u << 20u);
        HALF_LINE = curr & (1u << 19u);
        HALF_LINE_MODE = curr & (1u << 18u);
        VSYNC_PULSE_WIDTH = (curr >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set all of VDCTRL0_SET's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void set_VDCTRL0_SET(bool VSYNC_OEB, bool ENABLE_PRESENT,
                                bool VSYNC_POL, bool HSYNC_POL,
                                bool DOTCLK_POL, bool ENABLE_POL,
                                bool VSYNC_PERIOD_UNIT,
                                bool VSYNC_PULSE_WIDTH_UNIT, bool HALF_LINE,
                                bool HALF_LINE_MODE,
                                uint32_t VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0_SET;

        curr &= ~(0b1u << 29u);
        curr |= (VSYNC_OEB & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (ENABLE_PRESENT & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (VSYNC_POL & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (HSYNC_POL & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DOTCLK_POL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENABLE_POL & 0b1u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (VSYNC_PERIOD_UNIT & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (VSYNC_PULSE_WIDTH_UNIT & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (HALF_LINE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (HALF_LINE_MODE & 0b1u) << 18u;
        curr &= ~(0b111111111111111111u << 0u);
        curr |= (VSYNC_PULSE_WIDTH & 0b111111111111111111u) << 0u;

        VDCTRL0_SET = curr;
    }

    /**
     * Get VDCTRL0_CLR's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline bool get_VDCTRL0_CLR_VSYNC_OEB() volatile
    {
        return VDCTRL0_CLR & (1u << 29u);
    }

    /**
     * Set VDCTRL0_CLR's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void set_VDCTRL0_CLR_VSYNC_OEB() volatile
    {
        VDCTRL0_CLR |= 1u << 29u;
    }

    /**
     * Clear VDCTRL0_CLR's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void clear_VDCTRL0_CLR_VSYNC_OEB() volatile
    {
        VDCTRL0_CLR &= ~(1u << 29u);
    }

    /**
     * Toggle VDCTRL0_CLR's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void toggle_VDCTRL0_CLR_VSYNC_OEB() volatile
    {
        VDCTRL0_CLR ^= 1u << 29u;
    }

    /**
     * Get VDCTRL0_CLR's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline bool get_VDCTRL0_CLR_ENABLE_PRESENT() volatile
    {
        return VDCTRL0_CLR & (1u << 28u);
    }

    /**
     * Set VDCTRL0_CLR's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void set_VDCTRL0_CLR_ENABLE_PRESENT() volatile
    {
        VDCTRL0_CLR |= 1u << 28u;
    }

    /**
     * Clear VDCTRL0_CLR's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void clear_VDCTRL0_CLR_ENABLE_PRESENT() volatile
    {
        VDCTRL0_CLR &= ~(1u << 28u);
    }

    /**
     * Toggle VDCTRL0_CLR's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void toggle_VDCTRL0_CLR_ENABLE_PRESENT() volatile
    {
        VDCTRL0_CLR ^= 1u << 28u;
    }

    /**
     * Get VDCTRL0_CLR's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline bool get_VDCTRL0_CLR_VSYNC_POL() volatile
    {
        return VDCTRL0_CLR & (1u << 27u);
    }

    /**
     * Set VDCTRL0_CLR's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void set_VDCTRL0_CLR_VSYNC_POL() volatile
    {
        VDCTRL0_CLR |= 1u << 27u;
    }

    /**
     * Clear VDCTRL0_CLR's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void clear_VDCTRL0_CLR_VSYNC_POL() volatile
    {
        VDCTRL0_CLR &= ~(1u << 27u);
    }

    /**
     * Toggle VDCTRL0_CLR's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void toggle_VDCTRL0_CLR_VSYNC_POL() volatile
    {
        VDCTRL0_CLR ^= 1u << 27u;
    }

    /**
     * Get VDCTRL0_CLR's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline bool get_VDCTRL0_CLR_HSYNC_POL() volatile
    {
        return VDCTRL0_CLR & (1u << 26u);
    }

    /**
     * Set VDCTRL0_CLR's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void set_VDCTRL0_CLR_HSYNC_POL() volatile
    {
        VDCTRL0_CLR |= 1u << 26u;
    }

    /**
     * Clear VDCTRL0_CLR's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void clear_VDCTRL0_CLR_HSYNC_POL() volatile
    {
        VDCTRL0_CLR &= ~(1u << 26u);
    }

    /**
     * Toggle VDCTRL0_CLR's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void toggle_VDCTRL0_CLR_HSYNC_POL() volatile
    {
        VDCTRL0_CLR ^= 1u << 26u;
    }

    /**
     * Get VDCTRL0_CLR's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline bool get_VDCTRL0_CLR_DOTCLK_POL() volatile
    {
        return VDCTRL0_CLR & (1u << 25u);
    }

    /**
     * Set VDCTRL0_CLR's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void set_VDCTRL0_CLR_DOTCLK_POL() volatile
    {
        VDCTRL0_CLR |= 1u << 25u;
    }

    /**
     * Clear VDCTRL0_CLR's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void clear_VDCTRL0_CLR_DOTCLK_POL() volatile
    {
        VDCTRL0_CLR &= ~(1u << 25u);
    }

    /**
     * Toggle VDCTRL0_CLR's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void toggle_VDCTRL0_CLR_DOTCLK_POL() volatile
    {
        VDCTRL0_CLR ^= 1u << 25u;
    }

    /**
     * Get VDCTRL0_CLR's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline bool get_VDCTRL0_CLR_ENABLE_POL() volatile
    {
        return VDCTRL0_CLR & (1u << 24u);
    }

    /**
     * Set VDCTRL0_CLR's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void set_VDCTRL0_CLR_ENABLE_POL() volatile
    {
        VDCTRL0_CLR |= 1u << 24u;
    }

    /**
     * Clear VDCTRL0_CLR's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void clear_VDCTRL0_CLR_ENABLE_POL() volatile
    {
        VDCTRL0_CLR &= ~(1u << 24u);
    }

    /**
     * Toggle VDCTRL0_CLR's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void toggle_VDCTRL0_CLR_ENABLE_POL() volatile
    {
        VDCTRL0_CLR ^= 1u << 24u;
    }

    /**
     * Get VDCTRL0_CLR's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline bool get_VDCTRL0_CLR_VSYNC_PERIOD_UNIT() volatile
    {
        return VDCTRL0_CLR & (1u << 21u);
    }

    /**
     * Set VDCTRL0_CLR's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void set_VDCTRL0_CLR_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_CLR |= 1u << 21u;
    }

    /**
     * Clear VDCTRL0_CLR's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void clear_VDCTRL0_CLR_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_CLR &= ~(1u << 21u);
    }

    /**
     * Toggle VDCTRL0_CLR's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void toggle_VDCTRL0_CLR_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_CLR ^= 1u << 21u;
    }

    /**
     * Get VDCTRL0_CLR's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline bool get_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        return VDCTRL0_CLR & (1u << 20u);
    }

    /**
     * Set VDCTRL0_CLR's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void set_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_CLR |= 1u << 20u;
    }

    /**
     * Clear VDCTRL0_CLR's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void clear_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_CLR &= ~(1u << 20u);
    }

    /**
     * Toggle VDCTRL0_CLR's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void toggle_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_CLR ^= 1u << 20u;
    }

    /**
     * Get VDCTRL0_CLR's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline bool get_VDCTRL0_CLR_HALF_LINE() volatile
    {
        return VDCTRL0_CLR & (1u << 19u);
    }

    /**
     * Set VDCTRL0_CLR's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void set_VDCTRL0_CLR_HALF_LINE() volatile
    {
        VDCTRL0_CLR |= 1u << 19u;
    }

    /**
     * Clear VDCTRL0_CLR's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void clear_VDCTRL0_CLR_HALF_LINE() volatile
    {
        VDCTRL0_CLR &= ~(1u << 19u);
    }

    /**
     * Toggle VDCTRL0_CLR's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void toggle_VDCTRL0_CLR_HALF_LINE() volatile
    {
        VDCTRL0_CLR ^= 1u << 19u;
    }

    /**
     * Get VDCTRL0_CLR's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline bool get_VDCTRL0_CLR_HALF_LINE_MODE() volatile
    {
        return VDCTRL0_CLR & (1u << 18u);
    }

    /**
     * Set VDCTRL0_CLR's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void set_VDCTRL0_CLR_HALF_LINE_MODE() volatile
    {
        VDCTRL0_CLR |= 1u << 18u;
    }

    /**
     * Clear VDCTRL0_CLR's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void clear_VDCTRL0_CLR_HALF_LINE_MODE() volatile
    {
        VDCTRL0_CLR &= ~(1u << 18u);
    }

    /**
     * Toggle VDCTRL0_CLR's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void toggle_VDCTRL0_CLR_HALF_LINE_MODE() volatile
    {
        VDCTRL0_CLR ^= 1u << 18u;
    }

    /**
     * Get VDCTRL0_CLR's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline uint32_t get_VDCTRL0_CLR_VSYNC_PULSE_WIDTH() volatile
    {
        return (VDCTRL0_CLR >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set VDCTRL0_CLR's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline void set_VDCTRL0_CLR_VSYNC_PULSE_WIDTH(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL0_CLR;

        curr &= ~(0b111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111u) << 0u;

        VDCTRL0_CLR = curr;
    }

    /**
     * Get all of VDCTRL0_CLR's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void get_VDCTRL0_CLR(bool &VSYNC_OEB, bool &ENABLE_PRESENT,
                                bool &VSYNC_POL, bool &HSYNC_POL,
                                bool &DOTCLK_POL, bool &ENABLE_POL,
                                bool &VSYNC_PERIOD_UNIT,
                                bool &VSYNC_PULSE_WIDTH_UNIT, bool &HALF_LINE,
                                bool &HALF_LINE_MODE,
                                uint32_t &VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0_CLR;

        VSYNC_OEB = curr & (1u << 29u);
        ENABLE_PRESENT = curr & (1u << 28u);
        VSYNC_POL = curr & (1u << 27u);
        HSYNC_POL = curr & (1u << 26u);
        DOTCLK_POL = curr & (1u << 25u);
        ENABLE_POL = curr & (1u << 24u);
        VSYNC_PERIOD_UNIT = curr & (1u << 21u);
        VSYNC_PULSE_WIDTH_UNIT = curr & (1u << 20u);
        HALF_LINE = curr & (1u << 19u);
        HALF_LINE_MODE = curr & (1u << 18u);
        VSYNC_PULSE_WIDTH = (curr >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set all of VDCTRL0_CLR's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void set_VDCTRL0_CLR(bool VSYNC_OEB, bool ENABLE_PRESENT,
                                bool VSYNC_POL, bool HSYNC_POL,
                                bool DOTCLK_POL, bool ENABLE_POL,
                                bool VSYNC_PERIOD_UNIT,
                                bool VSYNC_PULSE_WIDTH_UNIT, bool HALF_LINE,
                                bool HALF_LINE_MODE,
                                uint32_t VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0_CLR;

        curr &= ~(0b1u << 29u);
        curr |= (VSYNC_OEB & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (ENABLE_PRESENT & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (VSYNC_POL & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (HSYNC_POL & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DOTCLK_POL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENABLE_POL & 0b1u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (VSYNC_PERIOD_UNIT & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (VSYNC_PULSE_WIDTH_UNIT & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (HALF_LINE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (HALF_LINE_MODE & 0b1u) << 18u;
        curr &= ~(0b111111111111111111u << 0u);
        curr |= (VSYNC_PULSE_WIDTH & 0b111111111111111111u) << 0u;

        VDCTRL0_CLR = curr;
    }

    /**
     * Get VDCTRL0_TOG's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline bool get_VDCTRL0_TOG_VSYNC_OEB() volatile
    {
        return VDCTRL0_TOG & (1u << 29u);
    }

    /**
     * Set VDCTRL0_TOG's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void set_VDCTRL0_TOG_VSYNC_OEB() volatile
    {
        VDCTRL0_TOG |= 1u << 29u;
    }

    /**
     * Clear VDCTRL0_TOG's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void clear_VDCTRL0_TOG_VSYNC_OEB() volatile
    {
        VDCTRL0_TOG &= ~(1u << 29u);
    }

    /**
     * Toggle VDCTRL0_TOG's VSYNC_OEB bit.
     *
     * 0 means the VSYNC signal is an output, 1 means it is an input
     */
    inline void toggle_VDCTRL0_TOG_VSYNC_OEB() volatile
    {
        VDCTRL0_TOG ^= 1u << 29u;
    }

    /**
     * Get VDCTRL0_TOG's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline bool get_VDCTRL0_TOG_ENABLE_PRESENT() volatile
    {
        return VDCTRL0_TOG & (1u << 28u);
    }

    /**
     * Set VDCTRL0_TOG's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void set_VDCTRL0_TOG_ENABLE_PRESENT() volatile
    {
        VDCTRL0_TOG |= 1u << 28u;
    }

    /**
     * Clear VDCTRL0_TOG's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void clear_VDCTRL0_TOG_ENABLE_PRESENT() volatile
    {
        VDCTRL0_TOG &= ~(1u << 28u);
    }

    /**
     * Toggle VDCTRL0_TOG's ENABLE_PRESENT bit.
     *
     * Setting this bit to 1 will make the hardware generate the ENABLE signal
     * in the DOTCLK mode, thereby making it the true RGB interface along with
     * the remaining three signals VSYNC, HSYNC and DOTCLK
     */
    inline void toggle_VDCTRL0_TOG_ENABLE_PRESENT() volatile
    {
        VDCTRL0_TOG ^= 1u << 28u;
    }

    /**
     * Get VDCTRL0_TOG's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline bool get_VDCTRL0_TOG_VSYNC_POL() volatile
    {
        return VDCTRL0_TOG & (1u << 27u);
    }

    /**
     * Set VDCTRL0_TOG's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void set_VDCTRL0_TOG_VSYNC_POL() volatile
    {
        VDCTRL0_TOG |= 1u << 27u;
    }

    /**
     * Clear VDCTRL0_TOG's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void clear_VDCTRL0_TOG_VSYNC_POL() volatile
    {
        VDCTRL0_TOG &= ~(1u << 27u);
    }

    /**
     * Toggle VDCTRL0_TOG's VSYNC_POL bit.
     *
     * Default 0 active low during VSYNC_PULSE_WIDTH time and will be high
     * during the rest of the VSYNC period
     */
    inline void toggle_VDCTRL0_TOG_VSYNC_POL() volatile
    {
        VDCTRL0_TOG ^= 1u << 27u;
    }

    /**
     * Get VDCTRL0_TOG's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline bool get_VDCTRL0_TOG_HSYNC_POL() volatile
    {
        return VDCTRL0_TOG & (1u << 26u);
    }

    /**
     * Set VDCTRL0_TOG's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void set_VDCTRL0_TOG_HSYNC_POL() volatile
    {
        VDCTRL0_TOG |= 1u << 26u;
    }

    /**
     * Clear VDCTRL0_TOG's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void clear_VDCTRL0_TOG_HSYNC_POL() volatile
    {
        VDCTRL0_TOG &= ~(1u << 26u);
    }

    /**
     * Toggle VDCTRL0_TOG's HSYNC_POL bit.
     *
     * Default 0 active low during HSYNC_PULSE_WIDTH time and will be high
     * during the rest of the HSYNC period
     */
    inline void toggle_VDCTRL0_TOG_HSYNC_POL() volatile
    {
        VDCTRL0_TOG ^= 1u << 26u;
    }

    /**
     * Get VDCTRL0_TOG's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline bool get_VDCTRL0_TOG_DOTCLK_POL() volatile
    {
        return VDCTRL0_TOG & (1u << 25u);
    }

    /**
     * Set VDCTRL0_TOG's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void set_VDCTRL0_TOG_DOTCLK_POL() volatile
    {
        VDCTRL0_TOG |= 1u << 25u;
    }

    /**
     * Clear VDCTRL0_TOG's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void clear_VDCTRL0_TOG_DOTCLK_POL() volatile
    {
        VDCTRL0_TOG &= ~(1u << 25u);
    }

    /**
     * Toggle VDCTRL0_TOG's DOTCLK_POL bit.
     *
     * Default is data launched at negative edge of DOTCLK and captured at
     * positive edge
     */
    inline void toggle_VDCTRL0_TOG_DOTCLK_POL() volatile
    {
        VDCTRL0_TOG ^= 1u << 25u;
    }

    /**
     * Get VDCTRL0_TOG's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline bool get_VDCTRL0_TOG_ENABLE_POL() volatile
    {
        return VDCTRL0_TOG & (1u << 24u);
    }

    /**
     * Set VDCTRL0_TOG's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void set_VDCTRL0_TOG_ENABLE_POL() volatile
    {
        VDCTRL0_TOG |= 1u << 24u;
    }

    /**
     * Clear VDCTRL0_TOG's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void clear_VDCTRL0_TOG_ENABLE_POL() volatile
    {
        VDCTRL0_TOG &= ~(1u << 24u);
    }

    /**
     * Toggle VDCTRL0_TOG's ENABLE_POL bit.
     *
     * Default 0 active low during valid data transfer on each horizontal line.
     */
    inline void toggle_VDCTRL0_TOG_ENABLE_POL() volatile
    {
        VDCTRL0_TOG ^= 1u << 24u;
    }

    /**
     * Get VDCTRL0_TOG's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline bool get_VDCTRL0_TOG_VSYNC_PERIOD_UNIT() volatile
    {
        return VDCTRL0_TOG & (1u << 21u);
    }

    /**
     * Set VDCTRL0_TOG's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void set_VDCTRL0_TOG_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_TOG |= 1u << 21u;
    }

    /**
     * Clear VDCTRL0_TOG's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void clear_VDCTRL0_TOG_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_TOG &= ~(1u << 21u);
    }

    /**
     * Toggle VDCTRL0_TOG's VSYNC_PERIOD_UNIT bit.
     *
     * Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk)
     * cycles
     */
    inline void toggle_VDCTRL0_TOG_VSYNC_PERIOD_UNIT() volatile
    {
        VDCTRL0_TOG ^= 1u << 21u;
    }

    /**
     * Get VDCTRL0_TOG's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline bool get_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        return VDCTRL0_TOG & (1u << 20u);
    }

    /**
     * Set VDCTRL0_TOG's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void set_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_TOG |= 1u << 20u;
    }

    /**
     * Clear VDCTRL0_TOG's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void clear_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_TOG &= ~(1u << 20u);
    }

    /**
     * Toggle VDCTRL0_TOG's VSYNC_PULSE_WIDTH_UNIT bit.
     *
     * Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK
     * (pix_clk) cycles
     */
    inline void toggle_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT() volatile
    {
        VDCTRL0_TOG ^= 1u << 20u;
    }

    /**
     * Get VDCTRL0_TOG's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline bool get_VDCTRL0_TOG_HALF_LINE() volatile
    {
        return VDCTRL0_TOG & (1u << 19u);
    }

    /**
     * Set VDCTRL0_TOG's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void set_VDCTRL0_TOG_HALF_LINE() volatile
    {
        VDCTRL0_TOG |= 1u << 19u;
    }

    /**
     * Clear VDCTRL0_TOG's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void clear_VDCTRL0_TOG_HALF_LINE() volatile
    {
        VDCTRL0_TOG &= ~(1u << 19u);
    }

    /**
     * Toggle VDCTRL0_TOG's HALF_LINE bit.
     *
     * Setting this bit to 1 will make the total VSYNC period equal to the
     * VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i
     */
    inline void toggle_VDCTRL0_TOG_HALF_LINE() volatile
    {
        VDCTRL0_TOG ^= 1u << 19u;
    }

    /**
     * Get VDCTRL0_TOG's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline bool get_VDCTRL0_TOG_HALF_LINE_MODE() volatile
    {
        return VDCTRL0_TOG & (1u << 18u);
    }

    /**
     * Set VDCTRL0_TOG's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void set_VDCTRL0_TOG_HALF_LINE_MODE() volatile
    {
        VDCTRL0_TOG |= 1u << 18u;
    }

    /**
     * Clear VDCTRL0_TOG's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void clear_VDCTRL0_TOG_HALF_LINE_MODE() volatile
    {
        VDCTRL0_TOG &= ~(1u << 18u);
    }

    /**
     * Toggle VDCTRL0_TOG's HALF_LINE_MODE bit.
     *
     * When this bit is 0, the first field (VSYNC period) will end in half a
     * horizontal line and the second field will begin with half a horizontal
     * line
     */
    inline void toggle_VDCTRL0_TOG_HALF_LINE_MODE() volatile
    {
        VDCTRL0_TOG ^= 1u << 18u;
    }

    /**
     * Get VDCTRL0_TOG's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline uint32_t get_VDCTRL0_TOG_VSYNC_PULSE_WIDTH() volatile
    {
        return (VDCTRL0_TOG >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set VDCTRL0_TOG's VSYNC_PULSE_WIDTH field.
     *
     * Number of units for which VSYNC signal is active
     */
    inline void set_VDCTRL0_TOG_VSYNC_PULSE_WIDTH(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL0_TOG;

        curr &= ~(0b111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111u) << 0u;

        VDCTRL0_TOG = curr;
    }

    /**
     * Get all of VDCTRL0_TOG's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void get_VDCTRL0_TOG(bool &VSYNC_OEB, bool &ENABLE_PRESENT,
                                bool &VSYNC_POL, bool &HSYNC_POL,
                                bool &DOTCLK_POL, bool &ENABLE_POL,
                                bool &VSYNC_PERIOD_UNIT,
                                bool &VSYNC_PULSE_WIDTH_UNIT, bool &HALF_LINE,
                                bool &HALF_LINE_MODE,
                                uint32_t &VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0_TOG;

        VSYNC_OEB = curr & (1u << 29u);
        ENABLE_PRESENT = curr & (1u << 28u);
        VSYNC_POL = curr & (1u << 27u);
        HSYNC_POL = curr & (1u << 26u);
        DOTCLK_POL = curr & (1u << 25u);
        ENABLE_POL = curr & (1u << 24u);
        VSYNC_PERIOD_UNIT = curr & (1u << 21u);
        VSYNC_PULSE_WIDTH_UNIT = curr & (1u << 20u);
        HALF_LINE = curr & (1u << 19u);
        HALF_LINE_MODE = curr & (1u << 18u);
        VSYNC_PULSE_WIDTH = (curr >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set all of VDCTRL0_TOG's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register0
     */
    inline void set_VDCTRL0_TOG(bool VSYNC_OEB, bool ENABLE_PRESENT,
                                bool VSYNC_POL, bool HSYNC_POL,
                                bool DOTCLK_POL, bool ENABLE_POL,
                                bool VSYNC_PERIOD_UNIT,
                                bool VSYNC_PULSE_WIDTH_UNIT, bool HALF_LINE,
                                bool HALF_LINE_MODE,
                                uint32_t VSYNC_PULSE_WIDTH) volatile
    {
        uint32_t curr = VDCTRL0_TOG;

        curr &= ~(0b1u << 29u);
        curr |= (VSYNC_OEB & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (ENABLE_PRESENT & 0b1u) << 28u;
        curr &= ~(0b1u << 27u);
        curr |= (VSYNC_POL & 0b1u) << 27u;
        curr &= ~(0b1u << 26u);
        curr |= (HSYNC_POL & 0b1u) << 26u;
        curr &= ~(0b1u << 25u);
        curr |= (DOTCLK_POL & 0b1u) << 25u;
        curr &= ~(0b1u << 24u);
        curr |= (ENABLE_POL & 0b1u) << 24u;
        curr &= ~(0b1u << 21u);
        curr |= (VSYNC_PERIOD_UNIT & 0b1u) << 21u;
        curr &= ~(0b1u << 20u);
        curr |= (VSYNC_PULSE_WIDTH_UNIT & 0b1u) << 20u;
        curr &= ~(0b1u << 19u);
        curr |= (HALF_LINE & 0b1u) << 19u;
        curr &= ~(0b1u << 18u);
        curr |= (HALF_LINE_MODE & 0b1u) << 18u;
        curr &= ~(0b111111111111111111u << 0u);
        curr |= (VSYNC_PULSE_WIDTH & 0b111111111111111111u) << 0u;

        VDCTRL0_TOG = curr;
    }

    /**
     * Get VDCTRL1's VSYNC_PERIOD field.
     *
     * Total number of units between two positive or two negative edges of the
     * VSYNC signal
     */
    inline uint32_t get_VDCTRL1_VSYNC_PERIOD() volatile
    {
        return (VDCTRL1 >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set VDCTRL1's VSYNC_PERIOD field.
     *
     * Total number of units between two positive or two negative edges of the
     * VSYNC signal
     */
    inline void set_VDCTRL1_VSYNC_PERIOD(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL1;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        VDCTRL1 = curr;
    }

    /**
     * Get VDCTRL2's HSYNC_PULSE_WIDTH field.
     *
     * Number of DISPLAY CLOCK (pix_clk) cycles for which HSYNC signal is
     * active.
     */
    inline uint16_t get_VDCTRL2_HSYNC_PULSE_WIDTH() volatile
    {
        return (VDCTRL2 >> 18u) & 0b11111111111111u;
    }

    /**
     * Set VDCTRL2's HSYNC_PULSE_WIDTH field.
     *
     * Number of DISPLAY CLOCK (pix_clk) cycles for which HSYNC signal is
     * active.
     */
    inline void set_VDCTRL2_HSYNC_PULSE_WIDTH(uint16_t value) volatile
    {
        uint32_t curr = VDCTRL2;

        curr &= ~(0b11111111111111u << 18u);
        curr |= (value & 0b11111111111111u) << 18u;

        VDCTRL2 = curr;
    }

    /**
     * Get VDCTRL2's HSYNC_PERIOD field.
     *
     * Total number of DISPLAY CLOCK (pix_clk) cycles between two positive or
     * two negative edges of the HSYNC signal
     */
    inline uint32_t get_VDCTRL2_HSYNC_PERIOD() volatile
    {
        return (VDCTRL2 >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set VDCTRL2's HSYNC_PERIOD field.
     *
     * Total number of DISPLAY CLOCK (pix_clk) cycles between two positive or
     * two negative edges of the HSYNC signal
     */
    inline void set_VDCTRL2_HSYNC_PERIOD(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL2;

        curr &= ~(0b111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111u) << 0u;

        VDCTRL2 = curr;
    }

    /**
     * Get all of VDCTRL2's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register2
     */
    inline void get_VDCTRL2(uint16_t &HSYNC_PULSE_WIDTH,
                            uint32_t &HSYNC_PERIOD) volatile
    {
        uint32_t curr = VDCTRL2;

        HSYNC_PULSE_WIDTH = (curr >> 18u) & 0b11111111111111u;
        HSYNC_PERIOD = (curr >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set all of VDCTRL2's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register2
     */
    inline void set_VDCTRL2(uint16_t HSYNC_PULSE_WIDTH,
                            uint32_t HSYNC_PERIOD) volatile
    {
        uint32_t curr = VDCTRL2;

        curr &= ~(0b11111111111111u << 18u);
        curr |= (HSYNC_PULSE_WIDTH & 0b11111111111111u) << 18u;
        curr &= ~(0b111111111111111111u << 0u);
        curr |= (HSYNC_PERIOD & 0b111111111111111111u) << 0u;

        VDCTRL2 = curr;
    }

    /**
     * Get VDCTRL3's MUX_SYNC_SIGNALS bit.
     *
     * When this bit is set, the LCDIF block will internally mux HSYNC with
     * LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these
     * signals will go out on separate pins
     */
    inline bool get_VDCTRL3_MUX_SYNC_SIGNALS() volatile
    {
        return VDCTRL3 & (1u << 29u);
    }

    /**
     * Set VDCTRL3's MUX_SYNC_SIGNALS bit.
     *
     * When this bit is set, the LCDIF block will internally mux HSYNC with
     * LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these
     * signals will go out on separate pins
     */
    inline void set_VDCTRL3_MUX_SYNC_SIGNALS() volatile
    {
        VDCTRL3 |= 1u << 29u;
    }

    /**
     * Clear VDCTRL3's MUX_SYNC_SIGNALS bit.
     *
     * When this bit is set, the LCDIF block will internally mux HSYNC with
     * LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these
     * signals will go out on separate pins
     */
    inline void clear_VDCTRL3_MUX_SYNC_SIGNALS() volatile
    {
        VDCTRL3 &= ~(1u << 29u);
    }

    /**
     * Toggle VDCTRL3's MUX_SYNC_SIGNALS bit.
     *
     * When this bit is set, the LCDIF block will internally mux HSYNC with
     * LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these
     * signals will go out on separate pins
     */
    inline void toggle_VDCTRL3_MUX_SYNC_SIGNALS() volatile
    {
        VDCTRL3 ^= 1u << 29u;
    }

    /**
     * Get VDCTRL3's VSYNC_ONLY bit.
     *
     * This bit must be set to 1 in the VSYNC mode of operation, and 0 in the
     * DOTCLK mode of operation.
     */
    inline bool get_VDCTRL3_VSYNC_ONLY() volatile
    {
        return VDCTRL3 & (1u << 28u);
    }

    /**
     * Set VDCTRL3's VSYNC_ONLY bit.
     *
     * This bit must be set to 1 in the VSYNC mode of operation, and 0 in the
     * DOTCLK mode of operation.
     */
    inline void set_VDCTRL3_VSYNC_ONLY() volatile
    {
        VDCTRL3 |= 1u << 28u;
    }

    /**
     * Clear VDCTRL3's VSYNC_ONLY bit.
     *
     * This bit must be set to 1 in the VSYNC mode of operation, and 0 in the
     * DOTCLK mode of operation.
     */
    inline void clear_VDCTRL3_VSYNC_ONLY() volatile
    {
        VDCTRL3 &= ~(1u << 28u);
    }

    /**
     * Toggle VDCTRL3's VSYNC_ONLY bit.
     *
     * This bit must be set to 1 in the VSYNC mode of operation, and 0 in the
     * DOTCLK mode of operation.
     */
    inline void toggle_VDCTRL3_VSYNC_ONLY() volatile
    {
        VDCTRL3 ^= 1u << 28u;
    }

    /**
     * Get VDCTRL3's HORIZONTAL_WAIT_CNT field.
     *
     * In the DOTCLK mode, wait for this number of clocks from falling edge (or
     * rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal back
     * porch plus the number of DOTCLKs before the moving picture information
     * begins
     */
    inline uint16_t get_VDCTRL3_HORIZONTAL_WAIT_CNT() volatile
    {
        return (VDCTRL3 >> 16u) & 0b111111111111u;
    }

    /**
     * Set VDCTRL3's HORIZONTAL_WAIT_CNT field.
     *
     * In the DOTCLK mode, wait for this number of clocks from falling edge (or
     * rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal back
     * porch plus the number of DOTCLKs before the moving picture information
     * begins
     */
    inline void set_VDCTRL3_HORIZONTAL_WAIT_CNT(uint16_t value) volatile
    {
        uint32_t curr = VDCTRL3;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        VDCTRL3 = curr;
    }

    /**
     * Get VDCTRL3's VERTICAL_WAIT_CNT field.
     *
     * In the VSYNC interface mode, wait for this number of DISPLAY CLOCK
     * (pix_clk) cycles from the falling VSYNC edge (or rising if VSYNC_POL is
     * 1) before starting LCD transactions and is applicable only if
     * WAIT_FOR_VSYNC_EDGE is set
     */
    inline uint16_t get_VDCTRL3_VERTICAL_WAIT_CNT() volatile
    {
        return (VDCTRL3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set VDCTRL3's VERTICAL_WAIT_CNT field.
     *
     * In the VSYNC interface mode, wait for this number of DISPLAY CLOCK
     * (pix_clk) cycles from the falling VSYNC edge (or rising if VSYNC_POL is
     * 1) before starting LCD transactions and is applicable only if
     * WAIT_FOR_VSYNC_EDGE is set
     */
    inline void set_VDCTRL3_VERTICAL_WAIT_CNT(uint16_t value) volatile
    {
        uint32_t curr = VDCTRL3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        VDCTRL3 = curr;
    }

    /**
     * Get all of VDCTRL3's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register3
     */
    inline void get_VDCTRL3(bool &MUX_SYNC_SIGNALS, bool &VSYNC_ONLY,
                            uint16_t &HORIZONTAL_WAIT_CNT,
                            uint16_t &VERTICAL_WAIT_CNT) volatile
    {
        uint32_t curr = VDCTRL3;

        MUX_SYNC_SIGNALS = curr & (1u << 29u);
        VSYNC_ONLY = curr & (1u << 28u);
        HORIZONTAL_WAIT_CNT = (curr >> 16u) & 0b111111111111u;
        VERTICAL_WAIT_CNT = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of VDCTRL3's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register3
     */
    inline void set_VDCTRL3(bool MUX_SYNC_SIGNALS, bool VSYNC_ONLY,
                            uint16_t HORIZONTAL_WAIT_CNT,
                            uint16_t VERTICAL_WAIT_CNT) volatile
    {
        uint32_t curr = VDCTRL3;

        curr &= ~(0b1u << 29u);
        curr |= (MUX_SYNC_SIGNALS & 0b1u) << 29u;
        curr &= ~(0b1u << 28u);
        curr |= (VSYNC_ONLY & 0b1u) << 28u;
        curr &= ~(0b111111111111u << 16u);
        curr |= (HORIZONTAL_WAIT_CNT & 0b111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (VERTICAL_WAIT_CNT & 0b1111111111111111u) << 0u;

        VDCTRL3 = curr;
    }

    /**
     * Get VDCTRL4's DOTCLK_DLY_SEL field.
     *
     * This bitfield selects the amount of time by which the DOTCLK signal
     * should be delayed before coming out of the LCD_DOTCK pin
     */
    inline uint8_t get_VDCTRL4_DOTCLK_DLY_SEL() volatile
    {
        return (VDCTRL4 >> 29u) & 0b111u;
    }

    /**
     * Set VDCTRL4's DOTCLK_DLY_SEL field.
     *
     * This bitfield selects the amount of time by which the DOTCLK signal
     * should be delayed before coming out of the LCD_DOTCK pin
     */
    inline void set_VDCTRL4_DOTCLK_DLY_SEL(uint8_t value) volatile
    {
        uint32_t curr = VDCTRL4;

        curr &= ~(0b111u << 29u);
        curr |= (value & 0b111u) << 29u;

        VDCTRL4 = curr;
    }

    /**
     * Get VDCTRL4's SYNC_SIGNALS_ON bit.
     *
     * Set this field to 1 if the LCD controller requires that the VSYNC or
     * VSYNC/HSYNC/DOTCLK control signals should be active at least one frame
     * before the data transfers actually start and remain active at least one
     * frame after the data transfers end
     */
    inline bool get_VDCTRL4_SYNC_SIGNALS_ON() volatile
    {
        return VDCTRL4 & (1u << 18u);
    }

    /**
     * Set VDCTRL4's SYNC_SIGNALS_ON bit.
     *
     * Set this field to 1 if the LCD controller requires that the VSYNC or
     * VSYNC/HSYNC/DOTCLK control signals should be active at least one frame
     * before the data transfers actually start and remain active at least one
     * frame after the data transfers end
     */
    inline void set_VDCTRL4_SYNC_SIGNALS_ON() volatile
    {
        VDCTRL4 |= 1u << 18u;
    }

    /**
     * Clear VDCTRL4's SYNC_SIGNALS_ON bit.
     *
     * Set this field to 1 if the LCD controller requires that the VSYNC or
     * VSYNC/HSYNC/DOTCLK control signals should be active at least one frame
     * before the data transfers actually start and remain active at least one
     * frame after the data transfers end
     */
    inline void clear_VDCTRL4_SYNC_SIGNALS_ON() volatile
    {
        VDCTRL4 &= ~(1u << 18u);
    }

    /**
     * Toggle VDCTRL4's SYNC_SIGNALS_ON bit.
     *
     * Set this field to 1 if the LCD controller requires that the VSYNC or
     * VSYNC/HSYNC/DOTCLK control signals should be active at least one frame
     * before the data transfers actually start and remain active at least one
     * frame after the data transfers end
     */
    inline void toggle_VDCTRL4_SYNC_SIGNALS_ON() volatile
    {
        VDCTRL4 ^= 1u << 18u;
    }

    /**
     * Get VDCTRL4's DOTCLK_H_VALID_DATA_CNT field.
     *
     * Total number of DISPLAY CLOCK (pix_clk) cycles on each horizontal line
     * that carry valid data in DOTCLK mode
     */
    inline uint32_t get_VDCTRL4_DOTCLK_H_VALID_DATA_CNT() volatile
    {
        return (VDCTRL4 >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set VDCTRL4's DOTCLK_H_VALID_DATA_CNT field.
     *
     * Total number of DISPLAY CLOCK (pix_clk) cycles on each horizontal line
     * that carry valid data in DOTCLK mode
     */
    inline void set_VDCTRL4_DOTCLK_H_VALID_DATA_CNT(uint32_t value) volatile
    {
        uint32_t curr = VDCTRL4;

        curr &= ~(0b111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111u) << 0u;

        VDCTRL4 = curr;
    }

    /**
     * Get all of VDCTRL4's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register4
     */
    inline void get_VDCTRL4(uint8_t &DOTCLK_DLY_SEL, bool &SYNC_SIGNALS_ON,
                            uint32_t &DOTCLK_H_VALID_DATA_CNT) volatile
    {
        uint32_t curr = VDCTRL4;

        DOTCLK_DLY_SEL = (curr >> 29u) & 0b111u;
        SYNC_SIGNALS_ON = curr & (1u << 18u);
        DOTCLK_H_VALID_DATA_CNT = (curr >> 0u) & 0b111111111111111111u;
    }

    /**
     * Set all of VDCTRL4's bit fields.
     *
     * (read-write) LCDIF VSYNC Mode and Dotclk Mode Control Register4
     */
    inline void set_VDCTRL4(uint8_t DOTCLK_DLY_SEL, bool SYNC_SIGNALS_ON,
                            uint32_t DOTCLK_H_VALID_DATA_CNT) volatile
    {
        uint32_t curr = VDCTRL4;

        curr &= ~(0b111u << 29u);
        curr |= (DOTCLK_DLY_SEL & 0b111u) << 29u;
        curr &= ~(0b1u << 18u);
        curr |= (SYNC_SIGNALS_ON & 0b1u) << 18u;
        curr &= ~(0b111111111111111111u << 0u);
        curr |= (DOTCLK_H_VALID_DATA_CNT & 0b111111111111111111u) << 0u;

        VDCTRL4 = curr;
    }

    /**
     * Get BM_ERROR_STAT's ADDR field.
     *
     * Virtual address at which bus master error occurred.
     */
    inline uint32_t get_BM_ERROR_STAT_ADDR() volatile
    {
        return (BM_ERROR_STAT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set BM_ERROR_STAT's ADDR field.
     *
     * Virtual address at which bus master error occurred.
     */
    inline void set_BM_ERROR_STAT_ADDR(uint32_t value) volatile
    {
        uint32_t curr = BM_ERROR_STAT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        BM_ERROR_STAT = curr;
    }

    /**
     * Get CRC_STAT's CRC_VALUE field.
     *
     * Calculated CRC value.
     */
    inline uint32_t get_CRC_STAT_CRC_VALUE() volatile
    {
        return (CRC_STAT >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set CRC_STAT's CRC_VALUE field.
     *
     * Calculated CRC value.
     */
    inline void set_CRC_STAT_CRC_VALUE(uint32_t value) volatile
    {
        uint32_t curr = CRC_STAT;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CRC_STAT = curr;
    }

    /**
     * Get STAT's PRESENT bit.
     *
     * 0: LCDIF not present on this product 1: LCDIF is present.
     */
    inline bool get_STAT_PRESENT() volatile
    {
        return STAT & (1u << 31u);
    }

    /**
     * Get STAT's DMA_REQ bit.
     *
     * Reflects the current state of the DMA Request line for the LCDIF
     */
    inline bool get_STAT_DMA_REQ() volatile
    {
        return STAT & (1u << 30u);
    }

    /**
     * Get STAT's LFIFO_FULL bit.
     *
     * Read only view of the signals that indicates LCD LFIFO is full.
     */
    inline bool get_STAT_LFIFO_FULL() volatile
    {
        return STAT & (1u << 29u);
    }

    /**
     * Get STAT's LFIFO_EMPTY bit.
     *
     * Read only view of the signals that indicates LCD LFIFO is empty.
     */
    inline bool get_STAT_LFIFO_EMPTY() volatile
    {
        return STAT & (1u << 28u);
    }

    /**
     * Get STAT's TXFIFO_FULL bit.
     *
     * Read only view of the signals that indicates LCD TXFIFO is full.
     */
    inline bool get_STAT_TXFIFO_FULL() volatile
    {
        return STAT & (1u << 27u);
    }

    /**
     * Get STAT's TXFIFO_EMPTY bit.
     *
     * Read only view of the signals that indicates LCD TXFIFO is empty.
     */
    inline bool get_STAT_TXFIFO_EMPTY() volatile
    {
        return STAT & (1u << 26u);
    }

    /**
     * Get STAT's LFIFO_COUNT field.
     *
     * Read only view of the current count in Latency buffer (LFIFO).
     */
    inline uint16_t get_STAT_LFIFO_COUNT() volatile
    {
        return (STAT >> 0u) & 0b111111111u;
    }

    /**
     * Get all of STAT's bit fields.
     *
     * (read-write) LCD Interface Status Register
     */
    inline void get_STAT(bool &PRESENT, bool &DMA_REQ, bool &LFIFO_FULL,
                         bool &LFIFO_EMPTY, bool &TXFIFO_FULL,
                         bool &TXFIFO_EMPTY, uint16_t &LFIFO_COUNT) volatile
    {
        uint32_t curr = STAT;

        PRESENT = curr & (1u << 31u);
        DMA_REQ = curr & (1u << 30u);
        LFIFO_FULL = curr & (1u << 29u);
        LFIFO_EMPTY = curr & (1u << 28u);
        TXFIFO_FULL = curr & (1u << 27u);
        TXFIFO_EMPTY = curr & (1u << 26u);
        LFIFO_COUNT = (curr >> 0u) & 0b111111111u;
    }

    /**
     * Get THRES's FASTCLOCK field.
     *
     * This value should be set to a value of pixels, from 0 to 511
     */
    inline uint16_t get_THRES_FASTCLOCK() volatile
    {
        return (THRES >> 16u) & 0b111111111u;
    }

    /**
     * Set THRES's FASTCLOCK field.
     *
     * This value should be set to a value of pixels, from 0 to 511
     */
    inline void set_THRES_FASTCLOCK(uint16_t value) volatile
    {
        uint32_t curr = THRES;

        curr &= ~(0b111111111u << 16u);
        curr |= (value & 0b111111111u) << 16u;

        THRES = curr;
    }

    /**
     * Get PIGEONCTRL0's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline uint16_t get_PIGEONCTRL0_LD_PERIOD() volatile
    {
        return (PIGEONCTRL0 >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline void set_PIGEONCTRL0_LD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL0 = curr;
    }

    /**
     * Get PIGEONCTRL0's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline uint16_t get_PIGEONCTRL0_FD_PERIOD() volatile
    {
        return (PIGEONCTRL0 >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline void set_PIGEONCTRL0_FD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL0 = curr;
    }

    /**
     * Get all of PIGEONCTRL0's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void get_PIGEONCTRL0(uint16_t &LD_PERIOD,
                                uint16_t &FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0;

        LD_PERIOD = (curr >> 16u) & 0b111111111111u;
        FD_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL0's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void set_PIGEONCTRL0(uint16_t LD_PERIOD,
                                uint16_t FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0;

        curr &= ~(0b111111111111u << 16u);
        curr |= (LD_PERIOD & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FD_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL0 = curr;
    }

    /**
     * Get PIGEONCTRL0_SET's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline uint16_t get_PIGEONCTRL0_SET_LD_PERIOD() volatile
    {
        return (PIGEONCTRL0_SET >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0_SET's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline void set_PIGEONCTRL0_SET_LD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0_SET;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL0_SET = curr;
    }

    /**
     * Get PIGEONCTRL0_SET's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline uint16_t get_PIGEONCTRL0_SET_FD_PERIOD() volatile
    {
        return (PIGEONCTRL0_SET >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0_SET's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline void set_PIGEONCTRL0_SET_FD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0_SET;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL0_SET = curr;
    }

    /**
     * Get all of PIGEONCTRL0_SET's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void get_PIGEONCTRL0_SET(uint16_t &LD_PERIOD,
                                    uint16_t &FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0_SET;

        LD_PERIOD = (curr >> 16u) & 0b111111111111u;
        FD_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL0_SET's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void set_PIGEONCTRL0_SET(uint16_t LD_PERIOD,
                                    uint16_t FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0_SET;

        curr &= ~(0b111111111111u << 16u);
        curr |= (LD_PERIOD & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FD_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL0_SET = curr;
    }

    /**
     * Get PIGEONCTRL0_CLR's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline uint16_t get_PIGEONCTRL0_CLR_LD_PERIOD() volatile
    {
        return (PIGEONCTRL0_CLR >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0_CLR's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline void set_PIGEONCTRL0_CLR_LD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0_CLR;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL0_CLR = curr;
    }

    /**
     * Get PIGEONCTRL0_CLR's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline uint16_t get_PIGEONCTRL0_CLR_FD_PERIOD() volatile
    {
        return (PIGEONCTRL0_CLR >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0_CLR's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline void set_PIGEONCTRL0_CLR_FD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0_CLR;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL0_CLR = curr;
    }

    /**
     * Get all of PIGEONCTRL0_CLR's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void get_PIGEONCTRL0_CLR(uint16_t &LD_PERIOD,
                                    uint16_t &FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0_CLR;

        LD_PERIOD = (curr >> 16u) & 0b111111111111u;
        FD_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL0_CLR's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void set_PIGEONCTRL0_CLR(uint16_t LD_PERIOD,
                                    uint16_t FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0_CLR;

        curr &= ~(0b111111111111u << 16u);
        curr |= (LD_PERIOD & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FD_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL0_CLR = curr;
    }

    /**
     * Get PIGEONCTRL0_TOG's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline uint16_t get_PIGEONCTRL0_TOG_LD_PERIOD() volatile
    {
        return (PIGEONCTRL0_TOG >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0_TOG's LD_PERIOD field.
     *
     * Period of pclk counter during LD phase
     */
    inline void set_PIGEONCTRL0_TOG_LD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0_TOG;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL0_TOG = curr;
    }

    /**
     * Get PIGEONCTRL0_TOG's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline uint16_t get_PIGEONCTRL0_TOG_FD_PERIOD() volatile
    {
        return (PIGEONCTRL0_TOG >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL0_TOG's FD_PERIOD field.
     *
     * Period of line counter during FD phase
     */
    inline void set_PIGEONCTRL0_TOG_FD_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL0_TOG;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL0_TOG = curr;
    }

    /**
     * Get all of PIGEONCTRL0_TOG's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void get_PIGEONCTRL0_TOG(uint16_t &LD_PERIOD,
                                    uint16_t &FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0_TOG;

        LD_PERIOD = (curr >> 16u) & 0b111111111111u;
        FD_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL0_TOG's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control0 Register
     */
    inline void set_PIGEONCTRL0_TOG(uint16_t LD_PERIOD,
                                    uint16_t FD_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL0_TOG;

        curr &= ~(0b111111111111u << 16u);
        curr |= (LD_PERIOD & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FD_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL0_TOG = curr;
    }

    /**
     * Get PIGEONCTRL1's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_FRAME_CNT_CYCLES() volatile
    {
        return (PIGEONCTRL1 >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline void set_PIGEONCTRL1_FRAME_CNT_CYCLES(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL1 = curr;
    }

    /**
     * Get PIGEONCTRL1's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_FRAME_CNT_PERIOD() volatile
    {
        return (PIGEONCTRL1 >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline void set_PIGEONCTRL1_FRAME_CNT_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL1 = curr;
    }

    /**
     * Get all of PIGEONCTRL1's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void get_PIGEONCTRL1(uint16_t &FRAME_CNT_CYCLES,
                                uint16_t &FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1;

        FRAME_CNT_CYCLES = (curr >> 16u) & 0b111111111111u;
        FRAME_CNT_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL1's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void set_PIGEONCTRL1(uint16_t FRAME_CNT_CYCLES,
                                uint16_t FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1;

        curr &= ~(0b111111111111u << 16u);
        curr |= (FRAME_CNT_CYCLES & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FRAME_CNT_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL1 = curr;
    }

    /**
     * Get PIGEONCTRL1_SET's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_SET_FRAME_CNT_CYCLES() volatile
    {
        return (PIGEONCTRL1_SET >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1_SET's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline void set_PIGEONCTRL1_SET_FRAME_CNT_CYCLES(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1_SET;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL1_SET = curr;
    }

    /**
     * Get PIGEONCTRL1_SET's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_SET_FRAME_CNT_PERIOD() volatile
    {
        return (PIGEONCTRL1_SET >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1_SET's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline void set_PIGEONCTRL1_SET_FRAME_CNT_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1_SET;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL1_SET = curr;
    }

    /**
     * Get all of PIGEONCTRL1_SET's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void get_PIGEONCTRL1_SET(uint16_t &FRAME_CNT_CYCLES,
                                    uint16_t &FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1_SET;

        FRAME_CNT_CYCLES = (curr >> 16u) & 0b111111111111u;
        FRAME_CNT_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL1_SET's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void set_PIGEONCTRL1_SET(uint16_t FRAME_CNT_CYCLES,
                                    uint16_t FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1_SET;

        curr &= ~(0b111111111111u << 16u);
        curr |= (FRAME_CNT_CYCLES & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FRAME_CNT_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL1_SET = curr;
    }

    /**
     * Get PIGEONCTRL1_CLR's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_CLR_FRAME_CNT_CYCLES() volatile
    {
        return (PIGEONCTRL1_CLR >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1_CLR's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline void set_PIGEONCTRL1_CLR_FRAME_CNT_CYCLES(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1_CLR;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL1_CLR = curr;
    }

    /**
     * Get PIGEONCTRL1_CLR's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_CLR_FRAME_CNT_PERIOD() volatile
    {
        return (PIGEONCTRL1_CLR >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1_CLR's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline void set_PIGEONCTRL1_CLR_FRAME_CNT_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1_CLR;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL1_CLR = curr;
    }

    /**
     * Get all of PIGEONCTRL1_CLR's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void get_PIGEONCTRL1_CLR(uint16_t &FRAME_CNT_CYCLES,
                                    uint16_t &FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1_CLR;

        FRAME_CNT_CYCLES = (curr >> 16u) & 0b111111111111u;
        FRAME_CNT_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL1_CLR's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void set_PIGEONCTRL1_CLR(uint16_t FRAME_CNT_CYCLES,
                                    uint16_t FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1_CLR;

        curr &= ~(0b111111111111u << 16u);
        curr |= (FRAME_CNT_CYCLES & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FRAME_CNT_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL1_CLR = curr;
    }

    /**
     * Get PIGEONCTRL1_TOG's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_TOG_FRAME_CNT_CYCLES() volatile
    {
        return (PIGEONCTRL1_TOG >> 16u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1_TOG's FRAME_CNT_CYCLES field.
     *
     * Max cycles of frame counter
     */
    inline void set_PIGEONCTRL1_TOG_FRAME_CNT_CYCLES(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1_TOG;

        curr &= ~(0b111111111111u << 16u);
        curr |= (value & 0b111111111111u) << 16u;

        PIGEONCTRL1_TOG = curr;
    }

    /**
     * Get PIGEONCTRL1_TOG's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline uint16_t get_PIGEONCTRL1_TOG_FRAME_CNT_PERIOD() volatile
    {
        return (PIGEONCTRL1_TOG >> 0u) & 0b111111111111u;
    }

    /**
     * Set PIGEONCTRL1_TOG's FRAME_CNT_PERIOD field.
     *
     * Period of frame counter
     */
    inline void set_PIGEONCTRL1_TOG_FRAME_CNT_PERIOD(uint16_t value) volatile
    {
        uint32_t curr = PIGEONCTRL1_TOG;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        PIGEONCTRL1_TOG = curr;
    }

    /**
     * Get all of PIGEONCTRL1_TOG's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void get_PIGEONCTRL1_TOG(uint16_t &FRAME_CNT_CYCLES,
                                    uint16_t &FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1_TOG;

        FRAME_CNT_CYCLES = (curr >> 16u) & 0b111111111111u;
        FRAME_CNT_PERIOD = (curr >> 0u) & 0b111111111111u;
    }

    /**
     * Set all of PIGEONCTRL1_TOG's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control1 Register
     */
    inline void set_PIGEONCTRL1_TOG(uint16_t FRAME_CNT_CYCLES,
                                    uint16_t FRAME_CNT_PERIOD) volatile
    {
        uint32_t curr = PIGEONCTRL1_TOG;

        curr &= ~(0b111111111111u << 16u);
        curr |= (FRAME_CNT_CYCLES & 0b111111111111u) << 16u;
        curr &= ~(0b111111111111u << 0u);
        curr |= (FRAME_CNT_PERIOD & 0b111111111111u) << 0u;

        PIGEONCTRL1_TOG = curr;
    }

    /**
     * Get PIGEONCTRL2's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline bool get_PIGEONCTRL2_PIGEON_CLK_GATE() volatile
    {
        return PIGEONCTRL2 & (1u << 1u);
    }

    /**
     * Set PIGEONCTRL2's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void set_PIGEONCTRL2_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2 |= 1u << 1u;
    }

    /**
     * Clear PIGEONCTRL2's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void clear_PIGEONCTRL2_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEONCTRL2's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void toggle_PIGEONCTRL2_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2 ^= 1u << 1u;
    }

    /**
     * Get PIGEONCTRL2's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline bool get_PIGEONCTRL2_PIGEON_DATA_EN() volatile
    {
        return PIGEONCTRL2 & (1u << 0u);
    }

    /**
     * Set PIGEONCTRL2's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void set_PIGEONCTRL2_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2 |= 1u << 0u;
    }

    /**
     * Clear PIGEONCTRL2's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void clear_PIGEONCTRL2_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEONCTRL2's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void toggle_PIGEONCTRL2_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEONCTRL2's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void get_PIGEONCTRL2(bool &PIGEON_CLK_GATE,
                                bool &PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2;

        PIGEON_CLK_GATE = curr & (1u << 1u);
        PIGEON_DATA_EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEONCTRL2's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void set_PIGEONCTRL2(bool PIGEON_CLK_GATE,
                                bool PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2;

        curr &= ~(0b1u << 1u);
        curr |= (PIGEON_CLK_GATE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PIGEON_DATA_EN & 0b1u) << 0u;

        PIGEONCTRL2 = curr;
    }

    /**
     * Get PIGEONCTRL2_SET's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline bool get_PIGEONCTRL2_SET_PIGEON_CLK_GATE() volatile
    {
        return PIGEONCTRL2_SET & (1u << 1u);
    }

    /**
     * Set PIGEONCTRL2_SET's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void set_PIGEONCTRL2_SET_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_SET |= 1u << 1u;
    }

    /**
     * Clear PIGEONCTRL2_SET's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void clear_PIGEONCTRL2_SET_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_SET &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEONCTRL2_SET's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void toggle_PIGEONCTRL2_SET_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_SET ^= 1u << 1u;
    }

    /**
     * Get PIGEONCTRL2_SET's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline bool get_PIGEONCTRL2_SET_PIGEON_DATA_EN() volatile
    {
        return PIGEONCTRL2_SET & (1u << 0u);
    }

    /**
     * Set PIGEONCTRL2_SET's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void set_PIGEONCTRL2_SET_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_SET |= 1u << 0u;
    }

    /**
     * Clear PIGEONCTRL2_SET's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void clear_PIGEONCTRL2_SET_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_SET &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEONCTRL2_SET's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void toggle_PIGEONCTRL2_SET_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_SET ^= 1u << 0u;
    }

    /**
     * Get all of PIGEONCTRL2_SET's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void get_PIGEONCTRL2_SET(bool &PIGEON_CLK_GATE,
                                    bool &PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2_SET;

        PIGEON_CLK_GATE = curr & (1u << 1u);
        PIGEON_DATA_EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEONCTRL2_SET's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void set_PIGEONCTRL2_SET(bool PIGEON_CLK_GATE,
                                    bool PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2_SET;

        curr &= ~(0b1u << 1u);
        curr |= (PIGEON_CLK_GATE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PIGEON_DATA_EN & 0b1u) << 0u;

        PIGEONCTRL2_SET = curr;
    }

    /**
     * Get PIGEONCTRL2_CLR's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline bool get_PIGEONCTRL2_CLR_PIGEON_CLK_GATE() volatile
    {
        return PIGEONCTRL2_CLR & (1u << 1u);
    }

    /**
     * Set PIGEONCTRL2_CLR's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void set_PIGEONCTRL2_CLR_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_CLR |= 1u << 1u;
    }

    /**
     * Clear PIGEONCTRL2_CLR's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void clear_PIGEONCTRL2_CLR_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_CLR &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEONCTRL2_CLR's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void toggle_PIGEONCTRL2_CLR_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_CLR ^= 1u << 1u;
    }

    /**
     * Get PIGEONCTRL2_CLR's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline bool get_PIGEONCTRL2_CLR_PIGEON_DATA_EN() volatile
    {
        return PIGEONCTRL2_CLR & (1u << 0u);
    }

    /**
     * Set PIGEONCTRL2_CLR's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void set_PIGEONCTRL2_CLR_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_CLR |= 1u << 0u;
    }

    /**
     * Clear PIGEONCTRL2_CLR's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void clear_PIGEONCTRL2_CLR_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_CLR &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEONCTRL2_CLR's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void toggle_PIGEONCTRL2_CLR_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_CLR ^= 1u << 0u;
    }

    /**
     * Get all of PIGEONCTRL2_CLR's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void get_PIGEONCTRL2_CLR(bool &PIGEON_CLK_GATE,
                                    bool &PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2_CLR;

        PIGEON_CLK_GATE = curr & (1u << 1u);
        PIGEON_DATA_EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEONCTRL2_CLR's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void set_PIGEONCTRL2_CLR(bool PIGEON_CLK_GATE,
                                    bool PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2_CLR;

        curr &= ~(0b1u << 1u);
        curr |= (PIGEON_CLK_GATE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PIGEON_DATA_EN & 0b1u) << 0u;

        PIGEONCTRL2_CLR = curr;
    }

    /**
     * Get PIGEONCTRL2_TOG's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline bool get_PIGEONCTRL2_TOG_PIGEON_CLK_GATE() volatile
    {
        return PIGEONCTRL2_TOG & (1u << 1u);
    }

    /**
     * Set PIGEONCTRL2_TOG's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void set_PIGEONCTRL2_TOG_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_TOG |= 1u << 1u;
    }

    /**
     * Clear PIGEONCTRL2_TOG's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void clear_PIGEONCTRL2_TOG_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_TOG &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEONCTRL2_TOG's PIGEON_CLK_GATE bit.
     *
     * Pigeon mode dot clock gate enable
     */
    inline void toggle_PIGEONCTRL2_TOG_PIGEON_CLK_GATE() volatile
    {
        PIGEONCTRL2_TOG ^= 1u << 1u;
    }

    /**
     * Get PIGEONCTRL2_TOG's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline bool get_PIGEONCTRL2_TOG_PIGEON_DATA_EN() volatile
    {
        return PIGEONCTRL2_TOG & (1u << 0u);
    }

    /**
     * Set PIGEONCTRL2_TOG's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void set_PIGEONCTRL2_TOG_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_TOG |= 1u << 0u;
    }

    /**
     * Clear PIGEONCTRL2_TOG's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void clear_PIGEONCTRL2_TOG_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_TOG &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEONCTRL2_TOG's PIGEON_DATA_EN bit.
     *
     * Pigeon mode data enable
     */
    inline void toggle_PIGEONCTRL2_TOG_PIGEON_DATA_EN() volatile
    {
        PIGEONCTRL2_TOG ^= 1u << 0u;
    }

    /**
     * Get all of PIGEONCTRL2_TOG's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void get_PIGEONCTRL2_TOG(bool &PIGEON_CLK_GATE,
                                    bool &PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2_TOG;

        PIGEON_CLK_GATE = curr & (1u << 1u);
        PIGEON_DATA_EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEONCTRL2_TOG's bit fields.
     *
     * (read-write) LCDIF Pigeon Mode Control2 Register
     */
    inline void set_PIGEONCTRL2_TOG(bool PIGEON_CLK_GATE,
                                    bool PIGEON_DATA_EN) volatile
    {
        uint32_t curr = PIGEONCTRL2_TOG;

        curr &= ~(0b1u << 1u);
        curr |= (PIGEON_CLK_GATE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (PIGEON_DATA_EN & 0b1u) << 0u;

        PIGEONCTRL2_TOG = curr;
    }

    /**
     * Get PIGEON_0_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_0_0_STATE_MASK get_PIGEON_0_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_0_0_STATE_MASK((PIGEON_0_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_0_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_0_0_STATE_MASK(
        LCDIF_PIGEON_0_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_0_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_0_0 = curr;
    }

    /**
     * Get PIGEON_0_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_0_0_MASK_CNT() volatile
    {
        return (PIGEON_0_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_0_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_0_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_0_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_0_0 = curr;
    }

    /**
     * Get PIGEON_0_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_0_0_MASK_CNT_SEL get_PIGEON_0_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_0_0_MASK_CNT_SEL((PIGEON_0_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_0_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_0_0_MASK_CNT_SEL(
        LCDIF_PIGEON_0_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_0_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_0_0 = curr;
    }

    /**
     * Get PIGEON_0_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_0_0_OFFSET() volatile
    {
        return (PIGEON_0_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_0_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_0_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_0_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_0_0 = curr;
    }

    /**
     * Get PIGEON_0_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_0_0_INC_SEL get_PIGEON_0_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_0_0_INC_SEL((PIGEON_0_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_0_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_0_0_INC_SEL(LCDIF_PIGEON_0_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_0_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_0_0 = curr;
    }

    /**
     * Get PIGEON_0_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_0_0_POL() volatile
    {
        return PIGEON_0_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_0_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_0_0_POL() volatile
    {
        PIGEON_0_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_0_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_0_0_POL() volatile
    {
        PIGEON_0_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_0_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_0_0_POL() volatile
    {
        PIGEON_0_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_0_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_0_0_EN() volatile
    {
        return PIGEON_0_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_0_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_0_0_EN() volatile
    {
        PIGEON_0_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_0_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_0_0_EN() volatile
    {
        PIGEON_0_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_0_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_0_0_EN() volatile
    {
        PIGEON_0_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_0_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_0_0(LCDIF_PIGEON_0_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_0_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_0_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_0_0;

        STATE_MASK = LCDIF_PIGEON_0_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_0_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_0_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_0_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_0_0(LCDIF_PIGEON_0_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_0_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_0_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_0_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_0_0 = curr;
    }

    /**
     * Get PIGEON_0_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_0_1_CLR_CNT get_PIGEON_0_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_0_1_CLR_CNT((PIGEON_0_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_0_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_0_1_CLR_CNT(LCDIF_PIGEON_0_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_0_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_0_1 = curr;
    }

    /**
     * Get PIGEON_0_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_0_1_SET_CNT get_PIGEON_0_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_0_1_SET_CNT((PIGEON_0_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_0_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_0_1_SET_CNT(LCDIF_PIGEON_0_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_0_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_0_1 = curr;
    }

    /**
     * Get all of PIGEON_0_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_0_1(LCDIF_PIGEON_0_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_0_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_0_1;

        CLR_CNT =
            LCDIF_PIGEON_0_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_0_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_0_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_0_1(LCDIF_PIGEON_0_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_0_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_0_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_0_1 = curr;
    }

    /**
     * Get PIGEON_0_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_0_2_SIG_ANOTHER get_PIGEON_0_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_0_2_SIG_ANOTHER((PIGEON_0_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_0_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_0_2_SIG_ANOTHER(
        LCDIF_PIGEON_0_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_0_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_0_2 = curr;
    }

    /**
     * Get PIGEON_0_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_0_2_SIG_LOGIC get_PIGEON_0_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_0_2_SIG_LOGIC((PIGEON_0_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_0_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_0_2_SIG_LOGIC(
        LCDIF_PIGEON_0_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_0_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_0_2 = curr;
    }

    /**
     * Get all of PIGEON_0_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_0_2(LCDIF_PIGEON_0_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_0_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_0_2;

        SIG_ANOTHER = LCDIF_PIGEON_0_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_0_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_0_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_0_2(LCDIF_PIGEON_0_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_0_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_0_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_0_2 = curr;
    }

    /**
     * Get PIGEON_1_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_1_0_STATE_MASK get_PIGEON_1_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_1_0_STATE_MASK((PIGEON_1_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_1_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_1_0_STATE_MASK(
        LCDIF_PIGEON_1_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_1_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_1_0 = curr;
    }

    /**
     * Get PIGEON_1_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_1_0_MASK_CNT() volatile
    {
        return (PIGEON_1_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_1_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_1_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_1_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_1_0 = curr;
    }

    /**
     * Get PIGEON_1_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_1_0_MASK_CNT_SEL get_PIGEON_1_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_1_0_MASK_CNT_SEL((PIGEON_1_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_1_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_1_0_MASK_CNT_SEL(
        LCDIF_PIGEON_1_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_1_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_1_0 = curr;
    }

    /**
     * Get PIGEON_1_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_1_0_OFFSET() volatile
    {
        return (PIGEON_1_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_1_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_1_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_1_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_1_0 = curr;
    }

    /**
     * Get PIGEON_1_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_1_0_INC_SEL get_PIGEON_1_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_1_0_INC_SEL((PIGEON_1_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_1_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_1_0_INC_SEL(LCDIF_PIGEON_1_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_1_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_1_0 = curr;
    }

    /**
     * Get PIGEON_1_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_1_0_POL() volatile
    {
        return PIGEON_1_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_1_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_1_0_POL() volatile
    {
        PIGEON_1_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_1_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_1_0_POL() volatile
    {
        PIGEON_1_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_1_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_1_0_POL() volatile
    {
        PIGEON_1_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_1_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_1_0_EN() volatile
    {
        return PIGEON_1_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_1_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_1_0_EN() volatile
    {
        PIGEON_1_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_1_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_1_0_EN() volatile
    {
        PIGEON_1_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_1_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_1_0_EN() volatile
    {
        PIGEON_1_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_1_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_1_0(LCDIF_PIGEON_1_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_1_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_1_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_1_0;

        STATE_MASK = LCDIF_PIGEON_1_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_1_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_1_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_1_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_1_0(LCDIF_PIGEON_1_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_1_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_1_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_1_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_1_0 = curr;
    }

    /**
     * Get PIGEON_1_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_1_1_CLR_CNT get_PIGEON_1_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_1_1_CLR_CNT((PIGEON_1_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_1_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_1_1_CLR_CNT(LCDIF_PIGEON_1_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_1_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_1_1 = curr;
    }

    /**
     * Get PIGEON_1_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_1_1_SET_CNT get_PIGEON_1_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_1_1_SET_CNT((PIGEON_1_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_1_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_1_1_SET_CNT(LCDIF_PIGEON_1_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_1_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_1_1 = curr;
    }

    /**
     * Get all of PIGEON_1_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_1_1(LCDIF_PIGEON_1_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_1_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_1_1;

        CLR_CNT =
            LCDIF_PIGEON_1_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_1_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_1_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_1_1(LCDIF_PIGEON_1_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_1_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_1_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_1_1 = curr;
    }

    /**
     * Get PIGEON_1_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_1_2_SIG_ANOTHER get_PIGEON_1_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_1_2_SIG_ANOTHER((PIGEON_1_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_1_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_1_2_SIG_ANOTHER(
        LCDIF_PIGEON_1_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_1_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_1_2 = curr;
    }

    /**
     * Get PIGEON_1_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_1_2_SIG_LOGIC get_PIGEON_1_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_1_2_SIG_LOGIC((PIGEON_1_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_1_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_1_2_SIG_LOGIC(
        LCDIF_PIGEON_1_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_1_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_1_2 = curr;
    }

    /**
     * Get all of PIGEON_1_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_1_2(LCDIF_PIGEON_1_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_1_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_1_2;

        SIG_ANOTHER = LCDIF_PIGEON_1_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_1_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_1_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_1_2(LCDIF_PIGEON_1_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_1_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_1_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_1_2 = curr;
    }

    /**
     * Get PIGEON_2_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_2_0_STATE_MASK get_PIGEON_2_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_2_0_STATE_MASK((PIGEON_2_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_2_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_2_0_STATE_MASK(
        LCDIF_PIGEON_2_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_2_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_2_0 = curr;
    }

    /**
     * Get PIGEON_2_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_2_0_MASK_CNT() volatile
    {
        return (PIGEON_2_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_2_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_2_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_2_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_2_0 = curr;
    }

    /**
     * Get PIGEON_2_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_2_0_MASK_CNT_SEL get_PIGEON_2_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_2_0_MASK_CNT_SEL((PIGEON_2_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_2_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_2_0_MASK_CNT_SEL(
        LCDIF_PIGEON_2_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_2_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_2_0 = curr;
    }

    /**
     * Get PIGEON_2_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_2_0_OFFSET() volatile
    {
        return (PIGEON_2_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_2_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_2_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_2_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_2_0 = curr;
    }

    /**
     * Get PIGEON_2_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_2_0_INC_SEL get_PIGEON_2_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_2_0_INC_SEL((PIGEON_2_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_2_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_2_0_INC_SEL(LCDIF_PIGEON_2_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_2_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_2_0 = curr;
    }

    /**
     * Get PIGEON_2_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_2_0_POL() volatile
    {
        return PIGEON_2_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_2_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_2_0_POL() volatile
    {
        PIGEON_2_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_2_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_2_0_POL() volatile
    {
        PIGEON_2_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_2_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_2_0_POL() volatile
    {
        PIGEON_2_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_2_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_2_0_EN() volatile
    {
        return PIGEON_2_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_2_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_2_0_EN() volatile
    {
        PIGEON_2_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_2_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_2_0_EN() volatile
    {
        PIGEON_2_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_2_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_2_0_EN() volatile
    {
        PIGEON_2_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_2_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_2_0(LCDIF_PIGEON_2_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_2_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_2_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_2_0;

        STATE_MASK = LCDIF_PIGEON_2_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_2_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_2_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_2_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_2_0(LCDIF_PIGEON_2_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_2_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_2_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_2_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_2_0 = curr;
    }

    /**
     * Get PIGEON_2_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_2_1_CLR_CNT get_PIGEON_2_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_2_1_CLR_CNT((PIGEON_2_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_2_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_2_1_CLR_CNT(LCDIF_PIGEON_2_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_2_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_2_1 = curr;
    }

    /**
     * Get PIGEON_2_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_2_1_SET_CNT get_PIGEON_2_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_2_1_SET_CNT((PIGEON_2_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_2_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_2_1_SET_CNT(LCDIF_PIGEON_2_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_2_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_2_1 = curr;
    }

    /**
     * Get all of PIGEON_2_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_2_1(LCDIF_PIGEON_2_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_2_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_2_1;

        CLR_CNT =
            LCDIF_PIGEON_2_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_2_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_2_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_2_1(LCDIF_PIGEON_2_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_2_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_2_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_2_1 = curr;
    }

    /**
     * Get PIGEON_2_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_2_2_SIG_ANOTHER get_PIGEON_2_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_2_2_SIG_ANOTHER((PIGEON_2_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_2_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_2_2_SIG_ANOTHER(
        LCDIF_PIGEON_2_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_2_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_2_2 = curr;
    }

    /**
     * Get PIGEON_2_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_2_2_SIG_LOGIC get_PIGEON_2_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_2_2_SIG_LOGIC((PIGEON_2_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_2_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_2_2_SIG_LOGIC(
        LCDIF_PIGEON_2_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_2_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_2_2 = curr;
    }

    /**
     * Get all of PIGEON_2_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_2_2(LCDIF_PIGEON_2_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_2_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_2_2;

        SIG_ANOTHER = LCDIF_PIGEON_2_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_2_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_2_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_2_2(LCDIF_PIGEON_2_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_2_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_2_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_2_2 = curr;
    }

    /**
     * Get PIGEON_3_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_3_0_STATE_MASK get_PIGEON_3_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_3_0_STATE_MASK((PIGEON_3_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_3_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_3_0_STATE_MASK(
        LCDIF_PIGEON_3_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_3_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_3_0 = curr;
    }

    /**
     * Get PIGEON_3_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_3_0_MASK_CNT() volatile
    {
        return (PIGEON_3_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_3_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_3_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_3_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_3_0 = curr;
    }

    /**
     * Get PIGEON_3_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_3_0_MASK_CNT_SEL get_PIGEON_3_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_3_0_MASK_CNT_SEL((PIGEON_3_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_3_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_3_0_MASK_CNT_SEL(
        LCDIF_PIGEON_3_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_3_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_3_0 = curr;
    }

    /**
     * Get PIGEON_3_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_3_0_OFFSET() volatile
    {
        return (PIGEON_3_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_3_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_3_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_3_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_3_0 = curr;
    }

    /**
     * Get PIGEON_3_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_3_0_INC_SEL get_PIGEON_3_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_3_0_INC_SEL((PIGEON_3_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_3_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_3_0_INC_SEL(LCDIF_PIGEON_3_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_3_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_3_0 = curr;
    }

    /**
     * Get PIGEON_3_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_3_0_POL() volatile
    {
        return PIGEON_3_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_3_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_3_0_POL() volatile
    {
        PIGEON_3_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_3_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_3_0_POL() volatile
    {
        PIGEON_3_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_3_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_3_0_POL() volatile
    {
        PIGEON_3_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_3_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_3_0_EN() volatile
    {
        return PIGEON_3_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_3_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_3_0_EN() volatile
    {
        PIGEON_3_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_3_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_3_0_EN() volatile
    {
        PIGEON_3_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_3_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_3_0_EN() volatile
    {
        PIGEON_3_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_3_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_3_0(LCDIF_PIGEON_3_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_3_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_3_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_3_0;

        STATE_MASK = LCDIF_PIGEON_3_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_3_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_3_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_3_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_3_0(LCDIF_PIGEON_3_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_3_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_3_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_3_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_3_0 = curr;
    }

    /**
     * Get PIGEON_3_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_3_1_CLR_CNT get_PIGEON_3_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_3_1_CLR_CNT((PIGEON_3_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_3_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_3_1_CLR_CNT(LCDIF_PIGEON_3_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_3_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_3_1 = curr;
    }

    /**
     * Get PIGEON_3_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_3_1_SET_CNT get_PIGEON_3_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_3_1_SET_CNT((PIGEON_3_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_3_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_3_1_SET_CNT(LCDIF_PIGEON_3_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_3_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_3_1 = curr;
    }

    /**
     * Get all of PIGEON_3_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_3_1(LCDIF_PIGEON_3_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_3_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_3_1;

        CLR_CNT =
            LCDIF_PIGEON_3_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_3_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_3_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_3_1(LCDIF_PIGEON_3_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_3_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_3_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_3_1 = curr;
    }

    /**
     * Get PIGEON_3_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_3_2_SIG_ANOTHER get_PIGEON_3_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_3_2_SIG_ANOTHER((PIGEON_3_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_3_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_3_2_SIG_ANOTHER(
        LCDIF_PIGEON_3_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_3_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_3_2 = curr;
    }

    /**
     * Get PIGEON_3_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_3_2_SIG_LOGIC get_PIGEON_3_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_3_2_SIG_LOGIC((PIGEON_3_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_3_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_3_2_SIG_LOGIC(
        LCDIF_PIGEON_3_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_3_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_3_2 = curr;
    }

    /**
     * Get all of PIGEON_3_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_3_2(LCDIF_PIGEON_3_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_3_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_3_2;

        SIG_ANOTHER = LCDIF_PIGEON_3_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_3_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_3_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_3_2(LCDIF_PIGEON_3_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_3_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_3_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_3_2 = curr;
    }

    /**
     * Get PIGEON_4_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_4_0_STATE_MASK get_PIGEON_4_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_4_0_STATE_MASK((PIGEON_4_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_4_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_4_0_STATE_MASK(
        LCDIF_PIGEON_4_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_4_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_4_0 = curr;
    }

    /**
     * Get PIGEON_4_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_4_0_MASK_CNT() volatile
    {
        return (PIGEON_4_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_4_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_4_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_4_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_4_0 = curr;
    }

    /**
     * Get PIGEON_4_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_4_0_MASK_CNT_SEL get_PIGEON_4_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_4_0_MASK_CNT_SEL((PIGEON_4_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_4_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_4_0_MASK_CNT_SEL(
        LCDIF_PIGEON_4_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_4_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_4_0 = curr;
    }

    /**
     * Get PIGEON_4_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_4_0_OFFSET() volatile
    {
        return (PIGEON_4_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_4_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_4_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_4_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_4_0 = curr;
    }

    /**
     * Get PIGEON_4_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_4_0_INC_SEL get_PIGEON_4_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_4_0_INC_SEL((PIGEON_4_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_4_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_4_0_INC_SEL(LCDIF_PIGEON_4_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_4_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_4_0 = curr;
    }

    /**
     * Get PIGEON_4_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_4_0_POL() volatile
    {
        return PIGEON_4_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_4_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_4_0_POL() volatile
    {
        PIGEON_4_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_4_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_4_0_POL() volatile
    {
        PIGEON_4_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_4_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_4_0_POL() volatile
    {
        PIGEON_4_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_4_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_4_0_EN() volatile
    {
        return PIGEON_4_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_4_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_4_0_EN() volatile
    {
        PIGEON_4_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_4_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_4_0_EN() volatile
    {
        PIGEON_4_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_4_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_4_0_EN() volatile
    {
        PIGEON_4_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_4_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_4_0(LCDIF_PIGEON_4_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_4_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_4_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_4_0;

        STATE_MASK = LCDIF_PIGEON_4_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_4_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_4_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_4_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_4_0(LCDIF_PIGEON_4_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_4_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_4_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_4_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_4_0 = curr;
    }

    /**
     * Get PIGEON_4_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_4_1_CLR_CNT get_PIGEON_4_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_4_1_CLR_CNT((PIGEON_4_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_4_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_4_1_CLR_CNT(LCDIF_PIGEON_4_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_4_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_4_1 = curr;
    }

    /**
     * Get PIGEON_4_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_4_1_SET_CNT get_PIGEON_4_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_4_1_SET_CNT((PIGEON_4_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_4_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_4_1_SET_CNT(LCDIF_PIGEON_4_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_4_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_4_1 = curr;
    }

    /**
     * Get all of PIGEON_4_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_4_1(LCDIF_PIGEON_4_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_4_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_4_1;

        CLR_CNT =
            LCDIF_PIGEON_4_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_4_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_4_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_4_1(LCDIF_PIGEON_4_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_4_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_4_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_4_1 = curr;
    }

    /**
     * Get PIGEON_4_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_4_2_SIG_ANOTHER get_PIGEON_4_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_4_2_SIG_ANOTHER((PIGEON_4_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_4_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_4_2_SIG_ANOTHER(
        LCDIF_PIGEON_4_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_4_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_4_2 = curr;
    }

    /**
     * Get PIGEON_4_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_4_2_SIG_LOGIC get_PIGEON_4_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_4_2_SIG_LOGIC((PIGEON_4_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_4_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_4_2_SIG_LOGIC(
        LCDIF_PIGEON_4_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_4_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_4_2 = curr;
    }

    /**
     * Get all of PIGEON_4_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_4_2(LCDIF_PIGEON_4_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_4_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_4_2;

        SIG_ANOTHER = LCDIF_PIGEON_4_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_4_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_4_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_4_2(LCDIF_PIGEON_4_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_4_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_4_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_4_2 = curr;
    }

    /**
     * Get PIGEON_5_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_5_0_STATE_MASK get_PIGEON_5_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_5_0_STATE_MASK((PIGEON_5_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_5_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_5_0_STATE_MASK(
        LCDIF_PIGEON_5_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_5_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_5_0 = curr;
    }

    /**
     * Get PIGEON_5_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_5_0_MASK_CNT() volatile
    {
        return (PIGEON_5_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_5_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_5_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_5_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_5_0 = curr;
    }

    /**
     * Get PIGEON_5_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_5_0_MASK_CNT_SEL get_PIGEON_5_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_5_0_MASK_CNT_SEL((PIGEON_5_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_5_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_5_0_MASK_CNT_SEL(
        LCDIF_PIGEON_5_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_5_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_5_0 = curr;
    }

    /**
     * Get PIGEON_5_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_5_0_OFFSET() volatile
    {
        return (PIGEON_5_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_5_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_5_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_5_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_5_0 = curr;
    }

    /**
     * Get PIGEON_5_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_5_0_INC_SEL get_PIGEON_5_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_5_0_INC_SEL((PIGEON_5_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_5_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_5_0_INC_SEL(LCDIF_PIGEON_5_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_5_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_5_0 = curr;
    }

    /**
     * Get PIGEON_5_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_5_0_POL() volatile
    {
        return PIGEON_5_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_5_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_5_0_POL() volatile
    {
        PIGEON_5_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_5_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_5_0_POL() volatile
    {
        PIGEON_5_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_5_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_5_0_POL() volatile
    {
        PIGEON_5_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_5_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_5_0_EN() volatile
    {
        return PIGEON_5_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_5_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_5_0_EN() volatile
    {
        PIGEON_5_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_5_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_5_0_EN() volatile
    {
        PIGEON_5_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_5_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_5_0_EN() volatile
    {
        PIGEON_5_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_5_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_5_0(LCDIF_PIGEON_5_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_5_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_5_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_5_0;

        STATE_MASK = LCDIF_PIGEON_5_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_5_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_5_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_5_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_5_0(LCDIF_PIGEON_5_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_5_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_5_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_5_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_5_0 = curr;
    }

    /**
     * Get PIGEON_5_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_5_1_CLR_CNT get_PIGEON_5_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_5_1_CLR_CNT((PIGEON_5_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_5_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_5_1_CLR_CNT(LCDIF_PIGEON_5_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_5_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_5_1 = curr;
    }

    /**
     * Get PIGEON_5_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_5_1_SET_CNT get_PIGEON_5_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_5_1_SET_CNT((PIGEON_5_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_5_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_5_1_SET_CNT(LCDIF_PIGEON_5_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_5_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_5_1 = curr;
    }

    /**
     * Get all of PIGEON_5_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_5_1(LCDIF_PIGEON_5_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_5_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_5_1;

        CLR_CNT =
            LCDIF_PIGEON_5_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_5_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_5_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_5_1(LCDIF_PIGEON_5_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_5_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_5_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_5_1 = curr;
    }

    /**
     * Get PIGEON_5_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_5_2_SIG_ANOTHER get_PIGEON_5_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_5_2_SIG_ANOTHER((PIGEON_5_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_5_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_5_2_SIG_ANOTHER(
        LCDIF_PIGEON_5_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_5_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_5_2 = curr;
    }

    /**
     * Get PIGEON_5_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_5_2_SIG_LOGIC get_PIGEON_5_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_5_2_SIG_LOGIC((PIGEON_5_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_5_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_5_2_SIG_LOGIC(
        LCDIF_PIGEON_5_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_5_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_5_2 = curr;
    }

    /**
     * Get all of PIGEON_5_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_5_2(LCDIF_PIGEON_5_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_5_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_5_2;

        SIG_ANOTHER = LCDIF_PIGEON_5_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_5_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_5_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_5_2(LCDIF_PIGEON_5_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_5_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_5_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_5_2 = curr;
    }

    /**
     * Get PIGEON_6_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_6_0_STATE_MASK get_PIGEON_6_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_6_0_STATE_MASK((PIGEON_6_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_6_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_6_0_STATE_MASK(
        LCDIF_PIGEON_6_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_6_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_6_0 = curr;
    }

    /**
     * Get PIGEON_6_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_6_0_MASK_CNT() volatile
    {
        return (PIGEON_6_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_6_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_6_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_6_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_6_0 = curr;
    }

    /**
     * Get PIGEON_6_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_6_0_MASK_CNT_SEL get_PIGEON_6_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_6_0_MASK_CNT_SEL((PIGEON_6_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_6_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_6_0_MASK_CNT_SEL(
        LCDIF_PIGEON_6_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_6_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_6_0 = curr;
    }

    /**
     * Get PIGEON_6_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_6_0_OFFSET() volatile
    {
        return (PIGEON_6_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_6_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_6_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_6_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_6_0 = curr;
    }

    /**
     * Get PIGEON_6_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_6_0_INC_SEL get_PIGEON_6_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_6_0_INC_SEL((PIGEON_6_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_6_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_6_0_INC_SEL(LCDIF_PIGEON_6_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_6_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_6_0 = curr;
    }

    /**
     * Get PIGEON_6_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_6_0_POL() volatile
    {
        return PIGEON_6_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_6_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_6_0_POL() volatile
    {
        PIGEON_6_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_6_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_6_0_POL() volatile
    {
        PIGEON_6_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_6_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_6_0_POL() volatile
    {
        PIGEON_6_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_6_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_6_0_EN() volatile
    {
        return PIGEON_6_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_6_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_6_0_EN() volatile
    {
        PIGEON_6_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_6_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_6_0_EN() volatile
    {
        PIGEON_6_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_6_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_6_0_EN() volatile
    {
        PIGEON_6_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_6_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_6_0(LCDIF_PIGEON_6_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_6_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_6_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_6_0;

        STATE_MASK = LCDIF_PIGEON_6_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_6_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_6_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_6_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_6_0(LCDIF_PIGEON_6_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_6_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_6_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_6_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_6_0 = curr;
    }

    /**
     * Get PIGEON_6_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_6_1_CLR_CNT get_PIGEON_6_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_6_1_CLR_CNT((PIGEON_6_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_6_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_6_1_CLR_CNT(LCDIF_PIGEON_6_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_6_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_6_1 = curr;
    }

    /**
     * Get PIGEON_6_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_6_1_SET_CNT get_PIGEON_6_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_6_1_SET_CNT((PIGEON_6_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_6_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_6_1_SET_CNT(LCDIF_PIGEON_6_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_6_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_6_1 = curr;
    }

    /**
     * Get all of PIGEON_6_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_6_1(LCDIF_PIGEON_6_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_6_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_6_1;

        CLR_CNT =
            LCDIF_PIGEON_6_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_6_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_6_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_6_1(LCDIF_PIGEON_6_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_6_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_6_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_6_1 = curr;
    }

    /**
     * Get PIGEON_6_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_6_2_SIG_ANOTHER get_PIGEON_6_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_6_2_SIG_ANOTHER((PIGEON_6_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_6_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_6_2_SIG_ANOTHER(
        LCDIF_PIGEON_6_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_6_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_6_2 = curr;
    }

    /**
     * Get PIGEON_6_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_6_2_SIG_LOGIC get_PIGEON_6_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_6_2_SIG_LOGIC((PIGEON_6_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_6_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_6_2_SIG_LOGIC(
        LCDIF_PIGEON_6_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_6_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_6_2 = curr;
    }

    /**
     * Get all of PIGEON_6_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_6_2(LCDIF_PIGEON_6_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_6_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_6_2;

        SIG_ANOTHER = LCDIF_PIGEON_6_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_6_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_6_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_6_2(LCDIF_PIGEON_6_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_6_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_6_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_6_2 = curr;
    }

    /**
     * Get PIGEON_7_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_7_0_STATE_MASK get_PIGEON_7_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_7_0_STATE_MASK((PIGEON_7_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_7_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_7_0_STATE_MASK(
        LCDIF_PIGEON_7_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_7_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_7_0 = curr;
    }

    /**
     * Get PIGEON_7_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_7_0_MASK_CNT() volatile
    {
        return (PIGEON_7_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_7_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_7_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_7_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_7_0 = curr;
    }

    /**
     * Get PIGEON_7_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_7_0_MASK_CNT_SEL get_PIGEON_7_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_7_0_MASK_CNT_SEL((PIGEON_7_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_7_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_7_0_MASK_CNT_SEL(
        LCDIF_PIGEON_7_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_7_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_7_0 = curr;
    }

    /**
     * Get PIGEON_7_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_7_0_OFFSET() volatile
    {
        return (PIGEON_7_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_7_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_7_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_7_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_7_0 = curr;
    }

    /**
     * Get PIGEON_7_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_7_0_INC_SEL get_PIGEON_7_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_7_0_INC_SEL((PIGEON_7_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_7_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_7_0_INC_SEL(LCDIF_PIGEON_7_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_7_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_7_0 = curr;
    }

    /**
     * Get PIGEON_7_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_7_0_POL() volatile
    {
        return PIGEON_7_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_7_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_7_0_POL() volatile
    {
        PIGEON_7_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_7_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_7_0_POL() volatile
    {
        PIGEON_7_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_7_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_7_0_POL() volatile
    {
        PIGEON_7_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_7_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_7_0_EN() volatile
    {
        return PIGEON_7_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_7_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_7_0_EN() volatile
    {
        PIGEON_7_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_7_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_7_0_EN() volatile
    {
        PIGEON_7_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_7_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_7_0_EN() volatile
    {
        PIGEON_7_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_7_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_7_0(LCDIF_PIGEON_7_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_7_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_7_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_7_0;

        STATE_MASK = LCDIF_PIGEON_7_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_7_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_7_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_7_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_7_0(LCDIF_PIGEON_7_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_7_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_7_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_7_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_7_0 = curr;
    }

    /**
     * Get PIGEON_7_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_7_1_CLR_CNT get_PIGEON_7_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_7_1_CLR_CNT((PIGEON_7_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_7_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_7_1_CLR_CNT(LCDIF_PIGEON_7_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_7_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_7_1 = curr;
    }

    /**
     * Get PIGEON_7_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_7_1_SET_CNT get_PIGEON_7_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_7_1_SET_CNT((PIGEON_7_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_7_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_7_1_SET_CNT(LCDIF_PIGEON_7_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_7_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_7_1 = curr;
    }

    /**
     * Get all of PIGEON_7_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_7_1(LCDIF_PIGEON_7_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_7_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_7_1;

        CLR_CNT =
            LCDIF_PIGEON_7_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_7_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_7_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_7_1(LCDIF_PIGEON_7_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_7_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_7_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_7_1 = curr;
    }

    /**
     * Get PIGEON_7_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_7_2_SIG_ANOTHER get_PIGEON_7_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_7_2_SIG_ANOTHER((PIGEON_7_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_7_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_7_2_SIG_ANOTHER(
        LCDIF_PIGEON_7_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_7_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_7_2 = curr;
    }

    /**
     * Get PIGEON_7_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_7_2_SIG_LOGIC get_PIGEON_7_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_7_2_SIG_LOGIC((PIGEON_7_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_7_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_7_2_SIG_LOGIC(
        LCDIF_PIGEON_7_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_7_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_7_2 = curr;
    }

    /**
     * Get all of PIGEON_7_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_7_2(LCDIF_PIGEON_7_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_7_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_7_2;

        SIG_ANOTHER = LCDIF_PIGEON_7_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_7_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_7_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_7_2(LCDIF_PIGEON_7_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_7_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_7_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_7_2 = curr;
    }

    /**
     * Get PIGEON_8_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_8_0_STATE_MASK get_PIGEON_8_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_8_0_STATE_MASK((PIGEON_8_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_8_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_8_0_STATE_MASK(
        LCDIF_PIGEON_8_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_8_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_8_0 = curr;
    }

    /**
     * Get PIGEON_8_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_8_0_MASK_CNT() volatile
    {
        return (PIGEON_8_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_8_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_8_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_8_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_8_0 = curr;
    }

    /**
     * Get PIGEON_8_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_8_0_MASK_CNT_SEL get_PIGEON_8_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_8_0_MASK_CNT_SEL((PIGEON_8_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_8_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_8_0_MASK_CNT_SEL(
        LCDIF_PIGEON_8_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_8_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_8_0 = curr;
    }

    /**
     * Get PIGEON_8_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_8_0_OFFSET() volatile
    {
        return (PIGEON_8_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_8_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_8_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_8_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_8_0 = curr;
    }

    /**
     * Get PIGEON_8_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_8_0_INC_SEL get_PIGEON_8_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_8_0_INC_SEL((PIGEON_8_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_8_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_8_0_INC_SEL(LCDIF_PIGEON_8_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_8_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_8_0 = curr;
    }

    /**
     * Get PIGEON_8_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_8_0_POL() volatile
    {
        return PIGEON_8_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_8_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_8_0_POL() volatile
    {
        PIGEON_8_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_8_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_8_0_POL() volatile
    {
        PIGEON_8_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_8_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_8_0_POL() volatile
    {
        PIGEON_8_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_8_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_8_0_EN() volatile
    {
        return PIGEON_8_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_8_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_8_0_EN() volatile
    {
        PIGEON_8_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_8_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_8_0_EN() volatile
    {
        PIGEON_8_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_8_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_8_0_EN() volatile
    {
        PIGEON_8_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_8_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_8_0(LCDIF_PIGEON_8_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_8_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_8_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_8_0;

        STATE_MASK = LCDIF_PIGEON_8_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_8_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_8_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_8_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_8_0(LCDIF_PIGEON_8_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_8_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_8_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_8_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_8_0 = curr;
    }

    /**
     * Get PIGEON_8_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_8_1_CLR_CNT get_PIGEON_8_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_8_1_CLR_CNT((PIGEON_8_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_8_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_8_1_CLR_CNT(LCDIF_PIGEON_8_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_8_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_8_1 = curr;
    }

    /**
     * Get PIGEON_8_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_8_1_SET_CNT get_PIGEON_8_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_8_1_SET_CNT((PIGEON_8_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_8_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_8_1_SET_CNT(LCDIF_PIGEON_8_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_8_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_8_1 = curr;
    }

    /**
     * Get all of PIGEON_8_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_8_1(LCDIF_PIGEON_8_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_8_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_8_1;

        CLR_CNT =
            LCDIF_PIGEON_8_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_8_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_8_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_8_1(LCDIF_PIGEON_8_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_8_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_8_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_8_1 = curr;
    }

    /**
     * Get PIGEON_8_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_8_2_SIG_ANOTHER get_PIGEON_8_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_8_2_SIG_ANOTHER((PIGEON_8_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_8_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_8_2_SIG_ANOTHER(
        LCDIF_PIGEON_8_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_8_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_8_2 = curr;
    }

    /**
     * Get PIGEON_8_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_8_2_SIG_LOGIC get_PIGEON_8_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_8_2_SIG_LOGIC((PIGEON_8_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_8_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_8_2_SIG_LOGIC(
        LCDIF_PIGEON_8_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_8_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_8_2 = curr;
    }

    /**
     * Get all of PIGEON_8_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_8_2(LCDIF_PIGEON_8_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_8_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_8_2;

        SIG_ANOTHER = LCDIF_PIGEON_8_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_8_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_8_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_8_2(LCDIF_PIGEON_8_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_8_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_8_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_8_2 = curr;
    }

    /**
     * Get PIGEON_9_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_9_0_STATE_MASK get_PIGEON_9_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_9_0_STATE_MASK((PIGEON_9_0 >> 24u) & 0b11111111u);
    }

    /**
     * Set PIGEON_9_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_9_0_STATE_MASK(
        LCDIF_PIGEON_9_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_9_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_9_0 = curr;
    }

    /**
     * Get PIGEON_9_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_9_0_MASK_CNT() volatile
    {
        return (PIGEON_9_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_9_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_9_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_9_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_9_0 = curr;
    }

    /**
     * Get PIGEON_9_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_9_0_MASK_CNT_SEL get_PIGEON_9_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_9_0_MASK_CNT_SEL((PIGEON_9_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_9_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_9_0_MASK_CNT_SEL(
        LCDIF_PIGEON_9_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_9_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_9_0 = curr;
    }

    /**
     * Get PIGEON_9_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_9_0_OFFSET() volatile
    {
        return (PIGEON_9_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_9_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_9_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_9_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_9_0 = curr;
    }

    /**
     * Get PIGEON_9_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_9_0_INC_SEL get_PIGEON_9_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_9_0_INC_SEL((PIGEON_9_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_9_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_9_0_INC_SEL(LCDIF_PIGEON_9_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_9_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_9_0 = curr;
    }

    /**
     * Get PIGEON_9_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_9_0_POL() volatile
    {
        return PIGEON_9_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_9_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_9_0_POL() volatile
    {
        PIGEON_9_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_9_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_9_0_POL() volatile
    {
        PIGEON_9_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_9_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_9_0_POL() volatile
    {
        PIGEON_9_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_9_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_9_0_EN() volatile
    {
        return PIGEON_9_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_9_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_9_0_EN() volatile
    {
        PIGEON_9_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_9_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_9_0_EN() volatile
    {
        PIGEON_9_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_9_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_9_0_EN() volatile
    {
        PIGEON_9_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_9_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_9_0(LCDIF_PIGEON_9_0_STATE_MASK &STATE_MASK,
                               uint16_t &MASK_CNT,
                               LCDIF_PIGEON_9_0_MASK_CNT_SEL &MASK_CNT_SEL,
                               uint8_t &OFFSET,
                               LCDIF_PIGEON_9_0_INC_SEL &INC_SEL, bool &POL,
                               bool &EN) volatile
    {
        uint32_t curr = PIGEON_9_0;

        STATE_MASK = LCDIF_PIGEON_9_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_9_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_9_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_9_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_9_0(LCDIF_PIGEON_9_0_STATE_MASK STATE_MASK,
                               uint16_t MASK_CNT,
                               LCDIF_PIGEON_9_0_MASK_CNT_SEL MASK_CNT_SEL,
                               uint8_t OFFSET,
                               LCDIF_PIGEON_9_0_INC_SEL INC_SEL, bool POL,
                               bool EN) volatile
    {
        uint32_t curr = PIGEON_9_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_9_0 = curr;
    }

    /**
     * Get PIGEON_9_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_9_1_CLR_CNT get_PIGEON_9_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_9_1_CLR_CNT((PIGEON_9_1 >> 16u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_9_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_9_1_CLR_CNT(LCDIF_PIGEON_9_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_9_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_9_1 = curr;
    }

    /**
     * Get PIGEON_9_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_9_1_SET_CNT get_PIGEON_9_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_9_1_SET_CNT((PIGEON_9_1 >> 0u) &
                                        0b1111111111111111u);
    }

    /**
     * Set PIGEON_9_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_9_1_SET_CNT(LCDIF_PIGEON_9_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_9_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_9_1 = curr;
    }

    /**
     * Get all of PIGEON_9_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_9_1(LCDIF_PIGEON_9_1_CLR_CNT &CLR_CNT,
                               LCDIF_PIGEON_9_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_9_1;

        CLR_CNT =
            LCDIF_PIGEON_9_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT = LCDIF_PIGEON_9_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_9_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_9_1(LCDIF_PIGEON_9_1_CLR_CNT CLR_CNT,
                               LCDIF_PIGEON_9_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_9_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_9_1 = curr;
    }

    /**
     * Get PIGEON_9_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_9_2_SIG_ANOTHER get_PIGEON_9_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_9_2_SIG_ANOTHER((PIGEON_9_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_9_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_9_2_SIG_ANOTHER(
        LCDIF_PIGEON_9_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_9_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_9_2 = curr;
    }

    /**
     * Get PIGEON_9_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_9_2_SIG_LOGIC get_PIGEON_9_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_9_2_SIG_LOGIC((PIGEON_9_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_9_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_9_2_SIG_LOGIC(
        LCDIF_PIGEON_9_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_9_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_9_2 = curr;
    }

    /**
     * Get all of PIGEON_9_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_9_2(LCDIF_PIGEON_9_2_SIG_ANOTHER &SIG_ANOTHER,
                               LCDIF_PIGEON_9_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_9_2;

        SIG_ANOTHER = LCDIF_PIGEON_9_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_9_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_9_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_9_2(LCDIF_PIGEON_9_2_SIG_ANOTHER SIG_ANOTHER,
                               LCDIF_PIGEON_9_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_9_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_9_2 = curr;
    }

    /**
     * Get PIGEON_10_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_10_0_STATE_MASK get_PIGEON_10_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_10_0_STATE_MASK((PIGEON_10_0 >> 24u) &
                                            0b11111111u);
    }

    /**
     * Set PIGEON_10_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_10_0_STATE_MASK(
        LCDIF_PIGEON_10_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_10_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_10_0 = curr;
    }

    /**
     * Get PIGEON_10_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_10_0_MASK_CNT() volatile
    {
        return (PIGEON_10_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_10_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_10_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_10_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_10_0 = curr;
    }

    /**
     * Get PIGEON_10_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_10_0_MASK_CNT_SEL
    get_PIGEON_10_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_10_0_MASK_CNT_SEL((PIGEON_10_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_10_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_10_0_MASK_CNT_SEL(
        LCDIF_PIGEON_10_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_10_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_10_0 = curr;
    }

    /**
     * Get PIGEON_10_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_10_0_OFFSET() volatile
    {
        return (PIGEON_10_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_10_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_10_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_10_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_10_0 = curr;
    }

    /**
     * Get PIGEON_10_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_10_0_INC_SEL get_PIGEON_10_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_10_0_INC_SEL((PIGEON_10_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_10_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_10_0_INC_SEL(
        LCDIF_PIGEON_10_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_10_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_10_0 = curr;
    }

    /**
     * Get PIGEON_10_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_10_0_POL() volatile
    {
        return PIGEON_10_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_10_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_10_0_POL() volatile
    {
        PIGEON_10_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_10_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_10_0_POL() volatile
    {
        PIGEON_10_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_10_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_10_0_POL() volatile
    {
        PIGEON_10_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_10_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_10_0_EN() volatile
    {
        return PIGEON_10_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_10_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_10_0_EN() volatile
    {
        PIGEON_10_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_10_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_10_0_EN() volatile
    {
        PIGEON_10_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_10_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_10_0_EN() volatile
    {
        PIGEON_10_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_10_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_10_0(LCDIF_PIGEON_10_0_STATE_MASK &STATE_MASK,
                                uint16_t &MASK_CNT,
                                LCDIF_PIGEON_10_0_MASK_CNT_SEL &MASK_CNT_SEL,
                                uint8_t &OFFSET,
                                LCDIF_PIGEON_10_0_INC_SEL &INC_SEL, bool &POL,
                                bool &EN) volatile
    {
        uint32_t curr = PIGEON_10_0;

        STATE_MASK = LCDIF_PIGEON_10_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_10_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_10_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_10_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_10_0(LCDIF_PIGEON_10_0_STATE_MASK STATE_MASK,
                                uint16_t MASK_CNT,
                                LCDIF_PIGEON_10_0_MASK_CNT_SEL MASK_CNT_SEL,
                                uint8_t OFFSET,
                                LCDIF_PIGEON_10_0_INC_SEL INC_SEL, bool POL,
                                bool EN) volatile
    {
        uint32_t curr = PIGEON_10_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_10_0 = curr;
    }

    /**
     * Get PIGEON_10_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_10_1_CLR_CNT get_PIGEON_10_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_10_1_CLR_CNT((PIGEON_10_1 >> 16u) &
                                         0b1111111111111111u);
    }

    /**
     * Set PIGEON_10_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_10_1_CLR_CNT(
        LCDIF_PIGEON_10_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_10_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_10_1 = curr;
    }

    /**
     * Get PIGEON_10_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_10_1_SET_CNT get_PIGEON_10_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_10_1_SET_CNT((PIGEON_10_1 >> 0u) &
                                         0b1111111111111111u);
    }

    /**
     * Set PIGEON_10_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_10_1_SET_CNT(
        LCDIF_PIGEON_10_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_10_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_10_1 = curr;
    }

    /**
     * Get all of PIGEON_10_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_10_1(LCDIF_PIGEON_10_1_CLR_CNT &CLR_CNT,
                                LCDIF_PIGEON_10_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_10_1;

        CLR_CNT =
            LCDIF_PIGEON_10_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT =
            LCDIF_PIGEON_10_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_10_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_10_1(LCDIF_PIGEON_10_1_CLR_CNT CLR_CNT,
                                LCDIF_PIGEON_10_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_10_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_10_1 = curr;
    }

    /**
     * Get PIGEON_10_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_10_2_SIG_ANOTHER get_PIGEON_10_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_10_2_SIG_ANOTHER((PIGEON_10_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_10_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_10_2_SIG_ANOTHER(
        LCDIF_PIGEON_10_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_10_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_10_2 = curr;
    }

    /**
     * Get PIGEON_10_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_10_2_SIG_LOGIC get_PIGEON_10_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_10_2_SIG_LOGIC((PIGEON_10_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_10_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_10_2_SIG_LOGIC(
        LCDIF_PIGEON_10_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_10_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_10_2 = curr;
    }

    /**
     * Get all of PIGEON_10_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_10_2(
        LCDIF_PIGEON_10_2_SIG_ANOTHER &SIG_ANOTHER,
        LCDIF_PIGEON_10_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_10_2;

        SIG_ANOTHER = LCDIF_PIGEON_10_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_10_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_10_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_10_2(LCDIF_PIGEON_10_2_SIG_ANOTHER SIG_ANOTHER,
                                LCDIF_PIGEON_10_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_10_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_10_2 = curr;
    }

    /**
     * Get PIGEON_11_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline LCDIF_PIGEON_11_0_STATE_MASK get_PIGEON_11_0_STATE_MASK() volatile
    {
        return LCDIF_PIGEON_11_0_STATE_MASK((PIGEON_11_0 >> 24u) &
                                            0b11111111u);
    }

    /**
     * Set PIGEON_11_0's STATE_MASK field.
     *
     * state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of
     * scan states as reference point for local counter to start ticking
     */
    inline void set_PIGEON_11_0_STATE_MASK(
        LCDIF_PIGEON_11_0_STATE_MASK value) volatile
    {
        uint32_t curr = PIGEON_11_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 24u;

        PIGEON_11_0 = curr;
    }

    /**
     * Get PIGEON_11_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline uint16_t get_PIGEON_11_0_MASK_CNT() volatile
    {
        return (PIGEON_11_0 >> 12u) & 0b111111111111u;
    }

    /**
     * Set PIGEON_11_0's MASK_CNT field.
     *
     * When the global counter selected through MASK_CNT_SEL matches value in
     * this reg, pigeon local counter start ticking
     */
    inline void set_PIGEON_11_0_MASK_CNT(uint16_t value) volatile
    {
        uint32_t curr = PIGEON_11_0;

        curr &= ~(0b111111111111u << 12u);
        curr |= (value & 0b111111111111u) << 12u;

        PIGEON_11_0 = curr;
    }

    /**
     * Get PIGEON_11_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline LCDIF_PIGEON_11_0_MASK_CNT_SEL
    get_PIGEON_11_0_MASK_CNT_SEL() volatile
    {
        return LCDIF_PIGEON_11_0_MASK_CNT_SEL((PIGEON_11_0 >> 8u) & 0b1111u);
    }

    /**
     * Set PIGEON_11_0's MASK_CNT_SEL field.
     *
     * select global counters as mask condition, use together with MASK_CNT
     */
    inline void set_PIGEON_11_0_MASK_CNT_SEL(
        LCDIF_PIGEON_11_0_MASK_CNT_SEL value) volatile
    {
        uint32_t curr = PIGEON_11_0;

        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(value) & 0b1111u) << 8u;

        PIGEON_11_0 = curr;
    }

    /**
     * Get PIGEON_11_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline uint8_t get_PIGEON_11_0_OFFSET() volatile
    {
        return (PIGEON_11_0 >> 4u) & 0b1111u;
    }

    /**
     * Set PIGEON_11_0's OFFSET field.
     *
     * offset on pclk unit
     */
    inline void set_PIGEON_11_0_OFFSET(uint8_t value) volatile
    {
        uint32_t curr = PIGEON_11_0;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        PIGEON_11_0 = curr;
    }

    /**
     * Get PIGEON_11_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline LCDIF_PIGEON_11_0_INC_SEL get_PIGEON_11_0_INC_SEL() volatile
    {
        return LCDIF_PIGEON_11_0_INC_SEL((PIGEON_11_0 >> 2u) & 0b11u);
    }

    /**
     * Set PIGEON_11_0's INC_SEL field.
     *
     * Event to incrment local counter
     */
    inline void set_PIGEON_11_0_INC_SEL(
        LCDIF_PIGEON_11_0_INC_SEL value) volatile
    {
        uint32_t curr = PIGEON_11_0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        PIGEON_11_0 = curr;
    }

    /**
     * Get PIGEON_11_0's POL bit.
     *
     * Polarity of signal output
     */
    inline bool get_PIGEON_11_0_POL() volatile
    {
        return PIGEON_11_0 & (1u << 1u);
    }

    /**
     * Set PIGEON_11_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void set_PIGEON_11_0_POL() volatile
    {
        PIGEON_11_0 |= 1u << 1u;
    }

    /**
     * Clear PIGEON_11_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void clear_PIGEON_11_0_POL() volatile
    {
        PIGEON_11_0 &= ~(1u << 1u);
    }

    /**
     * Toggle PIGEON_11_0's POL bit.
     *
     * Polarity of signal output
     */
    inline void toggle_PIGEON_11_0_POL() volatile
    {
        PIGEON_11_0 ^= 1u << 1u;
    }

    /**
     * Get PIGEON_11_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline bool get_PIGEON_11_0_EN() volatile
    {
        return PIGEON_11_0 & (1u << 0u);
    }

    /**
     * Set PIGEON_11_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void set_PIGEON_11_0_EN() volatile
    {
        PIGEON_11_0 |= 1u << 0u;
    }

    /**
     * Clear PIGEON_11_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void clear_PIGEON_11_0_EN() volatile
    {
        PIGEON_11_0 &= ~(1u << 0u);
    }

    /**
     * Toggle PIGEON_11_0's EN bit.
     *
     * Enable pigeon Mode on this signal
     */
    inline void toggle_PIGEON_11_0_EN() volatile
    {
        PIGEON_11_0 ^= 1u << 0u;
    }

    /**
     * Get all of PIGEON_11_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_11_0(LCDIF_PIGEON_11_0_STATE_MASK &STATE_MASK,
                                uint16_t &MASK_CNT,
                                LCDIF_PIGEON_11_0_MASK_CNT_SEL &MASK_CNT_SEL,
                                uint8_t &OFFSET,
                                LCDIF_PIGEON_11_0_INC_SEL &INC_SEL, bool &POL,
                                bool &EN) volatile
    {
        uint32_t curr = PIGEON_11_0;

        STATE_MASK = LCDIF_PIGEON_11_0_STATE_MASK((curr >> 24u) & 0b11111111u);
        MASK_CNT = (curr >> 12u) & 0b111111111111u;
        MASK_CNT_SEL = LCDIF_PIGEON_11_0_MASK_CNT_SEL((curr >> 8u) & 0b1111u);
        OFFSET = (curr >> 4u) & 0b1111u;
        INC_SEL = LCDIF_PIGEON_11_0_INC_SEL((curr >> 2u) & 0b11u);
        POL = curr & (1u << 1u);
        EN = curr & (1u << 0u);
    }

    /**
     * Set all of PIGEON_11_0's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_11_0(LCDIF_PIGEON_11_0_STATE_MASK STATE_MASK,
                                uint16_t MASK_CNT,
                                LCDIF_PIGEON_11_0_MASK_CNT_SEL MASK_CNT_SEL,
                                uint8_t OFFSET,
                                LCDIF_PIGEON_11_0_INC_SEL INC_SEL, bool POL,
                                bool EN) volatile
    {
        uint32_t curr = PIGEON_11_0;

        curr &= ~(0b11111111u << 24u);
        curr |= (std::to_underlying(STATE_MASK) & 0b11111111u) << 24u;
        curr &= ~(0b111111111111u << 12u);
        curr |= (MASK_CNT & 0b111111111111u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (std::to_underlying(MASK_CNT_SEL) & 0b1111u) << 8u;
        curr &= ~(0b1111u << 4u);
        curr |= (OFFSET & 0b1111u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(INC_SEL) & 0b11u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (POL & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;

        PIGEON_11_0 = curr;
    }

    /**
     * Get PIGEON_11_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline LCDIF_PIGEON_11_1_CLR_CNT get_PIGEON_11_1_CLR_CNT() volatile
    {
        return LCDIF_PIGEON_11_1_CLR_CNT((PIGEON_11_1 >> 16u) &
                                         0b1111111111111111u);
    }

    /**
     * Set PIGEON_11_1's CLR_CNT field.
     *
     * Deassert signal output when counter match this value
     */
    inline void set_PIGEON_11_1_CLR_CNT(
        LCDIF_PIGEON_11_1_CLR_CNT value) volatile
    {
        uint32_t curr = PIGEON_11_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        PIGEON_11_1 = curr;
    }

    /**
     * Get PIGEON_11_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline LCDIF_PIGEON_11_1_SET_CNT get_PIGEON_11_1_SET_CNT() volatile
    {
        return LCDIF_PIGEON_11_1_SET_CNT((PIGEON_11_1 >> 0u) &
                                         0b1111111111111111u);
    }

    /**
     * Set PIGEON_11_1's SET_CNT field.
     *
     * Assert signal output when counter match this value
     */
    inline void set_PIGEON_11_1_SET_CNT(
        LCDIF_PIGEON_11_1_SET_CNT value) volatile
    {
        uint32_t curr = PIGEON_11_1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 0u;

        PIGEON_11_1 = curr;
    }

    /**
     * Get all of PIGEON_11_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_11_1(LCDIF_PIGEON_11_1_CLR_CNT &CLR_CNT,
                                LCDIF_PIGEON_11_1_SET_CNT &SET_CNT) volatile
    {
        uint32_t curr = PIGEON_11_1;

        CLR_CNT =
            LCDIF_PIGEON_11_1_CLR_CNT((curr >> 16u) & 0b1111111111111111u);
        SET_CNT =
            LCDIF_PIGEON_11_1_SET_CNT((curr >> 0u) & 0b1111111111111111u);
    }

    /**
     * Set all of PIGEON_11_1's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_11_1(LCDIF_PIGEON_11_1_CLR_CNT CLR_CNT,
                                LCDIF_PIGEON_11_1_SET_CNT SET_CNT) volatile
    {
        uint32_t curr = PIGEON_11_1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(CLR_CNT) & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (std::to_underlying(SET_CNT) & 0b1111111111111111u) << 0u;

        PIGEON_11_1 = curr;
    }

    /**
     * Get PIGEON_11_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline LCDIF_PIGEON_11_2_SIG_ANOTHER get_PIGEON_11_2_SIG_ANOTHER() volatile
    {
        return LCDIF_PIGEON_11_2_SIG_ANOTHER((PIGEON_11_2 >> 4u) & 0b11111u);
    }

    /**
     * Set PIGEON_11_2's SIG_ANOTHER field.
     *
     * Select another signal for logic operation or as mask or counter tick
     * event
     */
    inline void set_PIGEON_11_2_SIG_ANOTHER(
        LCDIF_PIGEON_11_2_SIG_ANOTHER value) volatile
    {
        uint32_t curr = PIGEON_11_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(value) & 0b11111u) << 4u;

        PIGEON_11_2 = curr;
    }

    /**
     * Get PIGEON_11_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline LCDIF_PIGEON_11_2_SIG_LOGIC get_PIGEON_11_2_SIG_LOGIC() volatile
    {
        return LCDIF_PIGEON_11_2_SIG_LOGIC((PIGEON_11_2 >> 0u) & 0b1111u);
    }

    /**
     * Set PIGEON_11_2's SIG_LOGIC field.
     *
     * Logic operation with another signal: DIS/AND/OR/COND
     */
    inline void set_PIGEON_11_2_SIG_LOGIC(
        LCDIF_PIGEON_11_2_SIG_LOGIC value) volatile
    {
        uint32_t curr = PIGEON_11_2;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        PIGEON_11_2 = curr;
    }

    /**
     * Get all of PIGEON_11_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void get_PIGEON_11_2(
        LCDIF_PIGEON_11_2_SIG_ANOTHER &SIG_ANOTHER,
        LCDIF_PIGEON_11_2_SIG_LOGIC &SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_11_2;

        SIG_ANOTHER = LCDIF_PIGEON_11_2_SIG_ANOTHER((curr >> 4u) & 0b11111u);
        SIG_LOGIC = LCDIF_PIGEON_11_2_SIG_LOGIC((curr >> 0u) & 0b1111u);
    }

    /**
     * Set all of PIGEON_11_2's bit fields.
     *
     * (read-write) Panel Interface Signal Generator Register
     */
    inline void set_PIGEON_11_2(LCDIF_PIGEON_11_2_SIG_ANOTHER SIG_ANOTHER,
                                LCDIF_PIGEON_11_2_SIG_LOGIC SIG_LOGIC) volatile
    {
        uint32_t curr = PIGEON_11_2;

        curr &= ~(0b11111u << 4u);
        curr |= (std::to_underlying(SIG_ANOTHER) & 0b11111u) << 4u;
        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(SIG_LOGIC) & 0b1111u) << 0u;

        PIGEON_11_2 = curr;
    }

    /**
     * Get LUT_CTRL's LUT_BYPASS bit.
     *
     * Setting this bit will bypass the LUT memory resource completely
     */
    inline bool get_LUT_CTRL_LUT_BYPASS() volatile
    {
        return LUT_CTRL & (1u << 0u);
    }

    /**
     * Set LUT_CTRL's LUT_BYPASS bit.
     *
     * Setting this bit will bypass the LUT memory resource completely
     */
    inline void set_LUT_CTRL_LUT_BYPASS() volatile
    {
        LUT_CTRL |= 1u << 0u;
    }

    /**
     * Clear LUT_CTRL's LUT_BYPASS bit.
     *
     * Setting this bit will bypass the LUT memory resource completely
     */
    inline void clear_LUT_CTRL_LUT_BYPASS() volatile
    {
        LUT_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle LUT_CTRL's LUT_BYPASS bit.
     *
     * Setting this bit will bypass the LUT memory resource completely
     */
    inline void toggle_LUT_CTRL_LUT_BYPASS() volatile
    {
        LUT_CTRL ^= 1u << 0u;
    }

    /**
     * Get LUT0_ADDR's ADDR field.
     *
     * LUT indexed address pointer
     */
    inline uint8_t get_LUT0_ADDR_ADDR() volatile
    {
        return (LUT0_ADDR >> 0u) & 0b11111111u;
    }

    /**
     * Set LUT0_ADDR's ADDR field.
     *
     * LUT indexed address pointer
     */
    inline void set_LUT0_ADDR_ADDR(uint8_t value) volatile
    {
        uint32_t curr = LUT0_ADDR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LUT0_ADDR = curr;
    }

    /**
     * Get LUT0_DATA's DATA field.
     *
     * Writing this field will load 4 bytes, aligned to four byte boundaries,
     * of data indexed by the ADDR field of the REG_LUT_CTRL register
     */
    inline uint32_t get_LUT0_DATA_DATA() volatile
    {
        return (LUT0_DATA >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LUT0_DATA's DATA field.
     *
     * Writing this field will load 4 bytes, aligned to four byte boundaries,
     * of data indexed by the ADDR field of the REG_LUT_CTRL register
     */
    inline void set_LUT0_DATA_DATA(uint32_t value) volatile
    {
        uint32_t curr = LUT0_DATA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LUT0_DATA = curr;
    }

    /**
     * Get LUT1_ADDR's ADDR field.
     *
     * LUT indexed address pointer
     */
    inline uint8_t get_LUT1_ADDR_ADDR() volatile
    {
        return (LUT1_ADDR >> 0u) & 0b11111111u;
    }

    /**
     * Set LUT1_ADDR's ADDR field.
     *
     * LUT indexed address pointer
     */
    inline void set_LUT1_ADDR_ADDR(uint8_t value) volatile
    {
        uint32_t curr = LUT1_ADDR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        LUT1_ADDR = curr;
    }

    /**
     * Get LUT1_DATA's DATA field.
     *
     * Writing this field will load 4 bytes, aligned to four byte boundaries,
     * of data indexed by the ADDR field of the REG_LUT_CTRL register
     */
    inline uint32_t get_LUT1_DATA_DATA() volatile
    {
        return (LUT1_DATA >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set LUT1_DATA's DATA field.
     *
     * Writing this field will load 4 bytes, aligned to four byte boundaries,
     * of data indexed by the ADDR field of the REG_LUT_CTRL register
     */
    inline void set_LUT1_DATA_DATA(uint32_t value) volatile
    {
        uint32_t curr = LUT1_DATA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        LUT1_DATA = curr;
    }
};

static_assert(sizeof(lcdif) == lcdif::size);

static volatile lcdif *const LCDIF = reinterpret_cast<lcdif *>(0x40804000);

}; // namespace MIMXRT1176::CM7
