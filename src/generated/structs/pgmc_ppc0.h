/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/PGMC_PPC0_PPC_MODE_CTRL_MODE.h"
#include "../enums/PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * PGMC_PPC
 */
struct [[gnu::packed]] pgmc_ppc0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 28; /*!< pgmc_ppc0's size in bytes. */

    /* Fields. */
    const uint32_t reserved_padding0 = {};
    uint32_t PPC_AUTHEN_CTRL; /*!< (read-write) PPC Authentication Control */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t PPC_MODE; /*!< (read-write) PPC Mode */
    uint32_t
        PPC_STBY_CM_CTRL; /*!< (read-write) PPC standby CPU mode control */
    uint32_t
        PPC_STBY_SP_CTRL; /*!< (read-write) PPC standby Setpoint control */

    /* Methods. */

    /**
     * Get PPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline bool get_PPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        return PPC_AUTHEN_CTRL & (1u << 20u);
    }

    /**
     * Set PPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void set_PPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        PPC_AUTHEN_CTRL |= 1u << 20u;
    }

    /**
     * Clear PPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void clear_PPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        PPC_AUTHEN_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle PPC_AUTHEN_CTRL's LOCK_CFG bit.
     *
     * Configuration lock
     */
    inline void toggle_PPC_AUTHEN_CTRL_LOCK_CFG() volatile
    {
        PPC_AUTHEN_CTRL ^= 1u << 20u;
    }

    /**
     * Get PPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline bool get_PPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        return PPC_AUTHEN_CTRL & (1u << 12u);
    }

    /**
     * Set PPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void set_PPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        PPC_AUTHEN_CTRL |= 1u << 12u;
    }

    /**
     * Clear PPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void clear_PPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        PPC_AUTHEN_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle PPC_AUTHEN_CTRL's LOCK_LIST bit.
     *
     * White list lock
     */
    inline void toggle_PPC_AUTHEN_CTRL_LOCK_LIST() volatile
    {
        PPC_AUTHEN_CTRL ^= 1u << 12u;
    }

    /**
     * Get PPC_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline uint8_t get_PPC_AUTHEN_CTRL_WHITE_LIST() volatile
    {
        return (PPC_AUTHEN_CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set PPC_AUTHEN_CTRL's WHITE_LIST field.
     *
     * Domain ID white list
     */
    inline void set_PPC_AUTHEN_CTRL_WHITE_LIST(uint8_t value) volatile
    {
        uint32_t curr = PPC_AUTHEN_CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        PPC_AUTHEN_CTRL = curr;
    }

    /**
     * Get PPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline bool get_PPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        return PPC_AUTHEN_CTRL & (1u << 4u);
    }

    /**
     * Set PPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void set_PPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        PPC_AUTHEN_CTRL |= 1u << 4u;
    }

    /**
     * Clear PPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void clear_PPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        PPC_AUTHEN_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle PPC_AUTHEN_CTRL's LOCK_SETTING bit.
     *
     * Lock NONSECURE and USER
     */
    inline void toggle_PPC_AUTHEN_CTRL_LOCK_SETTING() volatile
    {
        PPC_AUTHEN_CTRL ^= 1u << 4u;
    }

    /**
     * Get PPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline bool get_PPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        return PPC_AUTHEN_CTRL & (1u << 1u);
    }

    /**
     * Set PPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void set_PPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        PPC_AUTHEN_CTRL |= 1u << 1u;
    }

    /**
     * Clear PPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void clear_PPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        PPC_AUTHEN_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle PPC_AUTHEN_CTRL's NONSECURE bit.
     *
     * Allow non-secure mode access
     */
    inline void toggle_PPC_AUTHEN_CTRL_NONSECURE() volatile
    {
        PPC_AUTHEN_CTRL ^= 1u << 1u;
    }

    /**
     * Get PPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline bool get_PPC_AUTHEN_CTRL_USER() volatile
    {
        return PPC_AUTHEN_CTRL & (1u << 0u);
    }

    /**
     * Set PPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void set_PPC_AUTHEN_CTRL_USER() volatile
    {
        PPC_AUTHEN_CTRL |= 1u << 0u;
    }

    /**
     * Clear PPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void clear_PPC_AUTHEN_CTRL_USER() volatile
    {
        PPC_AUTHEN_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle PPC_AUTHEN_CTRL's USER bit.
     *
     * Allow user mode access
     */
    inline void toggle_PPC_AUTHEN_CTRL_USER() volatile
    {
        PPC_AUTHEN_CTRL ^= 1u << 0u;
    }

    /**
     * Get all of PPC_AUTHEN_CTRL's bit fields.
     *
     * (read-write) PPC Authentication Control
     */
    inline void get_PPC_AUTHEN_CTRL(bool &LOCK_CFG, bool &LOCK_LIST,
                                    uint8_t &WHITE_LIST, bool &LOCK_SETTING,
                                    bool &NONSECURE, bool &USER) volatile
    {
        uint32_t curr = PPC_AUTHEN_CTRL;

        LOCK_CFG = curr & (1u << 20u);
        LOCK_LIST = curr & (1u << 12u);
        WHITE_LIST = (curr >> 8u) & 0b1111u;
        LOCK_SETTING = curr & (1u << 4u);
        NONSECURE = curr & (1u << 1u);
        USER = curr & (1u << 0u);
    }

    /**
     * Set all of PPC_AUTHEN_CTRL's bit fields.
     *
     * (read-write) PPC Authentication Control
     */
    inline void set_PPC_AUTHEN_CTRL(bool LOCK_CFG, bool LOCK_LIST,
                                    uint8_t WHITE_LIST, bool LOCK_SETTING,
                                    bool NONSECURE, bool USER) volatile
    {
        uint32_t curr = PPC_AUTHEN_CTRL;

        curr &= ~(0b1u << 20u);
        curr |= (LOCK_CFG & 0b1u) << 20u;
        curr &= ~(0b1u << 12u);
        curr |= (LOCK_LIST & 0b1u) << 12u;
        curr &= ~(0b1111u << 8u);
        curr |= (WHITE_LIST & 0b1111u) << 8u;
        curr &= ~(0b1u << 4u);
        curr |= (LOCK_SETTING & 0b1u) << 4u;
        curr &= ~(0b1u << 1u);
        curr |= (NONSECURE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (USER & 0b1u) << 0u;

        PPC_AUTHEN_CTRL = curr;
    }

    /**
     * Get PPC_MODE's DOMAIN_ASSIGN field.
     *
     * Domain assignment of the BPC
     */
    inline PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN
    get_PPC_MODE_DOMAIN_ASSIGN() volatile
    {
        return PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN((PPC_MODE >> 4u) & 0b11u);
    }

    /**
     * Set PPC_MODE's DOMAIN_ASSIGN field.
     *
     * Domain assignment of the BPC
     */
    inline void set_PPC_MODE_DOMAIN_ASSIGN(
        PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN value) volatile
    {
        uint32_t curr = PPC_MODE;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        PPC_MODE = curr;
    }

    /**
     * Get PPC_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline PGMC_PPC0_PPC_MODE_CTRL_MODE get_PPC_MODE_CTRL_MODE() volatile
    {
        return PGMC_PPC0_PPC_MODE_CTRL_MODE((PPC_MODE >> 0u) & 0b11u);
    }

    /**
     * Set PPC_MODE's CTRL_MODE field.
     *
     * Control mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_PPC_MODE_CTRL_MODE(
        PGMC_PPC0_PPC_MODE_CTRL_MODE value) volatile
    {
        uint32_t curr = PPC_MODE;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        PPC_MODE = curr;
    }

    /**
     * Get all of PPC_MODE's bit fields.
     *
     * (read-write) PPC Mode
     */
    inline void get_PPC_MODE(PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN &DOMAIN_ASSIGN,
                             PGMC_PPC0_PPC_MODE_CTRL_MODE &CTRL_MODE) volatile
    {
        uint32_t curr = PPC_MODE;

        DOMAIN_ASSIGN = PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN((curr >> 4u) & 0b11u);
        CTRL_MODE = PGMC_PPC0_PPC_MODE_CTRL_MODE((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of PPC_MODE's bit fields.
     *
     * (read-write) PPC Mode
     */
    inline void set_PPC_MODE(PGMC_PPC0_PPC_MODE_DOMAIN_ASSIGN DOMAIN_ASSIGN,
                             PGMC_PPC0_PPC_MODE_CTRL_MODE CTRL_MODE) volatile
    {
        uint32_t curr = PPC_MODE;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DOMAIN_ASSIGN) & 0b11u) << 4u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CTRL_MODE) & 0b11u) << 0u;

        PPC_MODE = curr;
    }

    /**
     * Get PPC_STBY_CM_CTRL's STBY_OFF_SOFT bit.
     *
     * Software PMIC standby off trigger
     */
    inline bool get_PPC_STBY_CM_CTRL_STBY_OFF_SOFT() volatile
    {
        return PPC_STBY_CM_CTRL & (1u << 9u);
    }

    /**
     * Set PPC_STBY_CM_CTRL's STBY_OFF_SOFT bit.
     *
     * Software PMIC standby off trigger
     */
    inline void set_PPC_STBY_CM_CTRL_STBY_OFF_SOFT() volatile
    {
        PPC_STBY_CM_CTRL |= 1u << 9u;
    }

    /**
     * Clear PPC_STBY_CM_CTRL's STBY_OFF_SOFT bit.
     *
     * Software PMIC standby off trigger
     */
    inline void clear_PPC_STBY_CM_CTRL_STBY_OFF_SOFT() volatile
    {
        PPC_STBY_CM_CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle PPC_STBY_CM_CTRL's STBY_OFF_SOFT bit.
     *
     * Software PMIC standby off trigger
     */
    inline void toggle_PPC_STBY_CM_CTRL_STBY_OFF_SOFT() volatile
    {
        PPC_STBY_CM_CTRL ^= 1u << 9u;
    }

    /**
     * Get PPC_STBY_CM_CTRL's STBY_ON_SOFT bit.
     *
     * Software PMIC standby on trigger
     */
    inline bool get_PPC_STBY_CM_CTRL_STBY_ON_SOFT() volatile
    {
        return PPC_STBY_CM_CTRL & (1u << 8u);
    }

    /**
     * Set PPC_STBY_CM_CTRL's STBY_ON_SOFT bit.
     *
     * Software PMIC standby on trigger
     */
    inline void set_PPC_STBY_CM_CTRL_STBY_ON_SOFT() volatile
    {
        PPC_STBY_CM_CTRL |= 1u << 8u;
    }

    /**
     * Clear PPC_STBY_CM_CTRL's STBY_ON_SOFT bit.
     *
     * Software PMIC standby on trigger
     */
    inline void clear_PPC_STBY_CM_CTRL_STBY_ON_SOFT() volatile
    {
        PPC_STBY_CM_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle PPC_STBY_CM_CTRL's STBY_ON_SOFT bit.
     *
     * Software PMIC standby on trigger
     */
    inline void toggle_PPC_STBY_CM_CTRL_STBY_ON_SOFT() volatile
    {
        PPC_STBY_CM_CTRL ^= 1u << 8u;
    }

    /**
     * Get PPC_STBY_CM_CTRL's STBY_ON_AT_SUSPEND bit.
     *
     * PMIC Standby on when domain enters SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline bool get_PPC_STBY_CM_CTRL_STBY_ON_AT_SUSPEND() volatile
    {
        return PPC_STBY_CM_CTRL & (1u << 3u);
    }

    /**
     * Set PPC_STBY_CM_CTRL's STBY_ON_AT_SUSPEND bit.
     *
     * PMIC Standby on when domain enters SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_PPC_STBY_CM_CTRL_STBY_ON_AT_SUSPEND() volatile
    {
        PPC_STBY_CM_CTRL |= 1u << 3u;
    }

    /**
     * Clear PPC_STBY_CM_CTRL's STBY_ON_AT_SUSPEND bit.
     *
     * PMIC Standby on when domain enters SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void clear_PPC_STBY_CM_CTRL_STBY_ON_AT_SUSPEND() volatile
    {
        PPC_STBY_CM_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle PPC_STBY_CM_CTRL's STBY_ON_AT_SUSPEND bit.
     *
     * PMIC Standby on when domain enters SUSPEND mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void toggle_PPC_STBY_CM_CTRL_STBY_ON_AT_SUSPEND() volatile
    {
        PPC_STBY_CM_CTRL ^= 1u << 3u;
    }

    /**
     * Get PPC_STBY_CM_CTRL's STBY_ON_AT_STOP bit.
     *
     * PMIC Standby on when domain enters STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline bool get_PPC_STBY_CM_CTRL_STBY_ON_AT_STOP() volatile
    {
        return PPC_STBY_CM_CTRL & (1u << 2u);
    }

    /**
     * Set PPC_STBY_CM_CTRL's STBY_ON_AT_STOP bit.
     *
     * PMIC Standby on when domain enters STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_PPC_STBY_CM_CTRL_STBY_ON_AT_STOP() volatile
    {
        PPC_STBY_CM_CTRL |= 1u << 2u;
    }

    /**
     * Clear PPC_STBY_CM_CTRL's STBY_ON_AT_STOP bit.
     *
     * PMIC Standby on when domain enters STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void clear_PPC_STBY_CM_CTRL_STBY_ON_AT_STOP() volatile
    {
        PPC_STBY_CM_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle PPC_STBY_CM_CTRL's STBY_ON_AT_STOP bit.
     *
     * PMIC Standby on when domain enters STOP mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void toggle_PPC_STBY_CM_CTRL_STBY_ON_AT_STOP() volatile
    {
        PPC_STBY_CM_CTRL ^= 1u << 2u;
    }

    /**
     * Get PPC_STBY_CM_CTRL's STBY_ON_AT_WAIT bit.
     *
     * PMIC Standby on when domain enters WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline bool get_PPC_STBY_CM_CTRL_STBY_ON_AT_WAIT() volatile
    {
        return PPC_STBY_CM_CTRL & (1u << 1u);
    }

    /**
     * Set PPC_STBY_CM_CTRL's STBY_ON_AT_WAIT bit.
     *
     * PMIC Standby on when domain enters WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_PPC_STBY_CM_CTRL_STBY_ON_AT_WAIT() volatile
    {
        PPC_STBY_CM_CTRL |= 1u << 1u;
    }

    /**
     * Clear PPC_STBY_CM_CTRL's STBY_ON_AT_WAIT bit.
     *
     * PMIC Standby on when domain enters WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void clear_PPC_STBY_CM_CTRL_STBY_ON_AT_WAIT() volatile
    {
        PPC_STBY_CM_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle PPC_STBY_CM_CTRL's STBY_ON_AT_WAIT bit.
     *
     * PMIC Standby on when domain enters WAIT mode. This field is locked by
     * AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void toggle_PPC_STBY_CM_CTRL_STBY_ON_AT_WAIT() volatile
    {
        PPC_STBY_CM_CTRL ^= 1u << 1u;
    }

    /**
     * Get all of PPC_STBY_CM_CTRL's bit fields.
     *
     * (read-write) PPC standby CPU mode control
     */
    inline void get_PPC_STBY_CM_CTRL(bool &STBY_OFF_SOFT, bool &STBY_ON_SOFT,
                                     bool &STBY_ON_AT_SUSPEND,
                                     bool &STBY_ON_AT_STOP,
                                     bool &STBY_ON_AT_WAIT) volatile
    {
        uint32_t curr = PPC_STBY_CM_CTRL;

        STBY_OFF_SOFT = curr & (1u << 9u);
        STBY_ON_SOFT = curr & (1u << 8u);
        STBY_ON_AT_SUSPEND = curr & (1u << 3u);
        STBY_ON_AT_STOP = curr & (1u << 2u);
        STBY_ON_AT_WAIT = curr & (1u << 1u);
    }

    /**
     * Set all of PPC_STBY_CM_CTRL's bit fields.
     *
     * (read-write) PPC standby CPU mode control
     */
    inline void set_PPC_STBY_CM_CTRL(bool STBY_OFF_SOFT, bool STBY_ON_SOFT,
                                     bool STBY_ON_AT_SUSPEND,
                                     bool STBY_ON_AT_STOP,
                                     bool STBY_ON_AT_WAIT) volatile
    {
        uint32_t curr = PPC_STBY_CM_CTRL;

        curr &= ~(0b1u << 9u);
        curr |= (STBY_OFF_SOFT & 0b1u) << 9u;
        curr &= ~(0b1u << 8u);
        curr |= (STBY_ON_SOFT & 0b1u) << 8u;
        curr &= ~(0b1u << 3u);
        curr |= (STBY_ON_AT_SUSPEND & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (STBY_ON_AT_STOP & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (STBY_ON_AT_WAIT & 0b1u) << 1u;

        PPC_STBY_CM_CTRL = curr;
    }

    /**
     * Get PPC_STBY_SP_CTRL's STBY_ON_AT_SP_SLEEP field.
     *
     * PMIC standby on when system enters Setpoint number and system is in
     * standby mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint16_t get_PPC_STBY_SP_CTRL_STBY_ON_AT_SP_SLEEP() volatile
    {
        return (PPC_STBY_SP_CTRL >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set PPC_STBY_SP_CTRL's STBY_ON_AT_SP_SLEEP field.
     *
     * PMIC standby on when system enters Setpoint number and system is in
     * standby mode. This field is locked by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_PPC_STBY_SP_CTRL_STBY_ON_AT_SP_SLEEP(
        uint16_t value) volatile
    {
        uint32_t curr = PPC_STBY_SP_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        PPC_STBY_SP_CTRL = curr;
    }

    /**
     * Get PPC_STBY_SP_CTRL's STBY_ON_AT_SP_ACTIVE field.
     *
     * PMIC standby on when system enters Setpoint number. This field is locked
     * by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline uint16_t get_PPC_STBY_SP_CTRL_STBY_ON_AT_SP_ACTIVE() volatile
    {
        return (PPC_STBY_SP_CTRL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set PPC_STBY_SP_CTRL's STBY_ON_AT_SP_ACTIVE field.
     *
     * PMIC standby on when system enters Setpoint number. This field is locked
     * by AUTHEN_CTRL[LOCK_CFG] field.
     */
    inline void set_PPC_STBY_SP_CTRL_STBY_ON_AT_SP_ACTIVE(
        uint16_t value) volatile
    {
        uint32_t curr = PPC_STBY_SP_CTRL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        PPC_STBY_SP_CTRL = curr;
    }

    /**
     * Get all of PPC_STBY_SP_CTRL's bit fields.
     *
     * (read-write) PPC standby Setpoint control
     */
    inline void get_PPC_STBY_SP_CTRL(uint16_t &STBY_ON_AT_SP_SLEEP,
                                     uint16_t &STBY_ON_AT_SP_ACTIVE) volatile
    {
        uint32_t curr = PPC_STBY_SP_CTRL;

        STBY_ON_AT_SP_SLEEP = (curr >> 16u) & 0b1111111111111111u;
        STBY_ON_AT_SP_ACTIVE = (curr >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set all of PPC_STBY_SP_CTRL's bit fields.
     *
     * (read-write) PPC standby Setpoint control
     */
    inline void set_PPC_STBY_SP_CTRL(uint16_t STBY_ON_AT_SP_SLEEP,
                                     uint16_t STBY_ON_AT_SP_ACTIVE) volatile
    {
        uint32_t curr = PPC_STBY_SP_CTRL;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (STBY_ON_AT_SP_SLEEP & 0b1111111111111111u) << 16u;
        curr &= ~(0b1111111111111111u << 0u);
        curr |= (STBY_ON_AT_SP_ACTIVE & 0b1111111111111111u) << 0u;

        PPC_STBY_SP_CTRL = curr;
    }
};

static_assert(sizeof(pgmc_ppc0) == pgmc_ppc0::size);

static volatile pgmc_ppc0 *const PGMC_PPC0 =
    reinterpret_cast<pgmc_ppc0 *>(0x40C8B000);

}; // namespace MIMXRT1176::CM7
