/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/TMR1_CSCTRL0_CL1.h"
#include "../enums/TMR1_CSCTRL0_CL2.h"
#include "../enums/TMR1_CSCTRL0_DBG_EN.h"
#include "../enums/TMR1_CSCTRL1_CL1.h"
#include "../enums/TMR1_CSCTRL1_CL2.h"
#include "../enums/TMR1_CSCTRL1_DBG_EN.h"
#include "../enums/TMR1_CSCTRL2_CL1.h"
#include "../enums/TMR1_CSCTRL2_CL2.h"
#include "../enums/TMR1_CSCTRL2_DBG_EN.h"
#include "../enums/TMR1_CSCTRL3_CL1.h"
#include "../enums/TMR1_CSCTRL3_CL2.h"
#include "../enums/TMR1_CSCTRL3_DBG_EN.h"
#include "../enums/TMR1_CTRL0_CM.h"
#include "../enums/TMR1_CTRL0_OUTMODE.h"
#include "../enums/TMR1_CTRL0_PCS.h"
#include "../enums/TMR1_CTRL0_SCS.h"
#include "../enums/TMR1_CTRL1_CM.h"
#include "../enums/TMR1_CTRL1_OUTMODE.h"
#include "../enums/TMR1_CTRL1_PCS.h"
#include "../enums/TMR1_CTRL1_SCS.h"
#include "../enums/TMR1_CTRL2_CM.h"
#include "../enums/TMR1_CTRL2_OUTMODE.h"
#include "../enums/TMR1_CTRL2_PCS.h"
#include "../enums/TMR1_CTRL2_SCS.h"
#include "../enums/TMR1_CTRL3_CM.h"
#include "../enums/TMR1_CTRL3_OUTMODE.h"
#include "../enums/TMR1_CTRL3_PCS.h"
#include "../enums/TMR1_CTRL3_SCS.h"
#include "../enums/TMR1_ENBL_ENBL.h"
#include "../enums/TMR1_SCTRL0_CAPTURE_MODE.h"
#include "../enums/TMR1_SCTRL1_CAPTURE_MODE.h"
#include "../enums/TMR1_SCTRL2_CAPTURE_MODE.h"
#include "../enums/TMR1_SCTRL3_CAPTURE_MODE.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM7
{

/**
 * TMR
 */
struct [[gnu::packed]] tmr1
{
    /* Constant attributes. */
    static constexpr std::size_t size = 122; /*!< tmr1's size in bytes. */

    /* Fields. */
    uint16_t COMP10; /*!< (read-write) Timer Channel Compare Register 1 */
    uint16_t COMP20; /*!< (read-write) Timer Channel Compare Register 2 */
    uint16_t CAPT0;  /*!< (read-write) Timer Channel Capture Register */
    uint16_t LOAD0;  /*!< (read-write) Timer Channel Load Register */
    uint16_t HOLD0;  /*!< (read-write) Timer Channel Hold Register */
    uint16_t CNTR0;  /*!< (read-write) Timer Channel Counter Register */
    uint16_t CTRL0;  /*!< (read-write) Timer Channel Control Register */
    uint16_t
        SCTRL0; /*!< (read-write) Timer Channel Status and Control Register */
    uint16_t
        CMPLD10; /*!< (read-write) Timer Channel Comparator Load Register 1 */
    uint16_t
        CMPLD20; /*!< (read-write) Timer Channel Comparator Load Register 2 */
    uint16_t CSCTRL0; /*!< (read-write) Timer Channel Comparator Status and
                         Control Register */
    uint16_t FILT0;   /*!< (read-write) Timer Channel Input Filter Register */
    uint16_t DMA0;    /*!< (read-write) Timer Channel DMA Enable Register */
    const uint32_t reserved_padding0 = {};
    uint16_t ENBL;   /*!< (read-write) Timer Channel Enable Register */
    uint16_t COMP11; /*!< (read-write) Timer Channel Compare Register 1 */
    uint16_t COMP21; /*!< (read-write) Timer Channel Compare Register 2 */
    uint16_t CAPT1;  /*!< (read-write) Timer Channel Capture Register */
    uint16_t LOAD1;  /*!< (read-write) Timer Channel Load Register */
    uint16_t HOLD1;  /*!< (read-write) Timer Channel Hold Register */
    uint16_t CNTR1;  /*!< (read-write) Timer Channel Counter Register */
    uint16_t CTRL1;  /*!< (read-write) Timer Channel Control Register */
    uint16_t
        SCTRL1; /*!< (read-write) Timer Channel Status and Control Register */
    uint16_t
        CMPLD11; /*!< (read-write) Timer Channel Comparator Load Register 1 */
    uint16_t
        CMPLD21; /*!< (read-write) Timer Channel Comparator Load Register 2 */
    uint16_t CSCTRL1; /*!< (read-write) Timer Channel Comparator Status and
                         Control Register */
    uint16_t FILT1;   /*!< (read-write) Timer Channel Input Filter Register */
    uint16_t DMA1;    /*!< (read-write) Timer Channel DMA Enable Register */
    const uint32_t reserved_padding1 = {};
    static constexpr std::size_t reserved_padding2_length = 2;
    const uint8_t reserved_padding2[reserved_padding2_length] = {};
    uint16_t COMP12; /*!< (read-write) Timer Channel Compare Register 1 */
    uint16_t COMP22; /*!< (read-write) Timer Channel Compare Register 2 */
    uint16_t CAPT2;  /*!< (read-write) Timer Channel Capture Register */
    uint16_t LOAD2;  /*!< (read-write) Timer Channel Load Register */
    uint16_t HOLD2;  /*!< (read-write) Timer Channel Hold Register */
    uint16_t CNTR2;  /*!< (read-write) Timer Channel Counter Register */
    uint16_t CTRL2;  /*!< (read-write) Timer Channel Control Register */
    uint16_t
        SCTRL2; /*!< (read-write) Timer Channel Status and Control Register */
    uint16_t
        CMPLD12; /*!< (read-write) Timer Channel Comparator Load Register 1 */
    uint16_t
        CMPLD22; /*!< (read-write) Timer Channel Comparator Load Register 2 */
    uint16_t CSCTRL2; /*!< (read-write) Timer Channel Comparator Status and
                         Control Register */
    uint16_t FILT2;   /*!< (read-write) Timer Channel Input Filter Register */
    uint16_t DMA2;    /*!< (read-write) Timer Channel DMA Enable Register */
    const uint32_t reserved_padding3 = {};
    static constexpr std::size_t reserved_padding4_length = 2;
    const uint8_t reserved_padding4[reserved_padding4_length] = {};
    uint16_t COMP13; /*!< (read-write) Timer Channel Compare Register 1 */
    uint16_t COMP23; /*!< (read-write) Timer Channel Compare Register 2 */
    uint16_t CAPT3;  /*!< (read-write) Timer Channel Capture Register */
    uint16_t LOAD3;  /*!< (read-write) Timer Channel Load Register */
    uint16_t HOLD3;  /*!< (read-write) Timer Channel Hold Register */
    uint16_t CNTR3;  /*!< (read-write) Timer Channel Counter Register */
    uint16_t CTRL3;  /*!< (read-write) Timer Channel Control Register */
    uint16_t
        SCTRL3; /*!< (read-write) Timer Channel Status and Control Register */
    uint16_t
        CMPLD13; /*!< (read-write) Timer Channel Comparator Load Register 1 */
    uint16_t
        CMPLD23; /*!< (read-write) Timer Channel Comparator Load Register 2 */
    uint16_t CSCTRL3; /*!< (read-write) Timer Channel Comparator Status and
                         Control Register */
    uint16_t FILT3;   /*!< (read-write) Timer Channel Input Filter Register */
    uint16_t DMA3;    /*!< (read-write) Timer Channel DMA Enable Register */

    /* Methods. */

    /**
     * Get COMP10's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline uint16_t get_COMP10_COMPARISON_1() volatile
    {
        return (COMP10 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP10's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline void set_COMP10_COMPARISON_1(uint16_t value) volatile
    {
        uint16_t curr = COMP10;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP10 = curr;
    }

    /**
     * Get COMP20's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline uint16_t get_COMP20_COMPARISON_2() volatile
    {
        return (COMP20 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP20's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline void set_COMP20_COMPARISON_2(uint16_t value) volatile
    {
        uint16_t curr = COMP20;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP20 = curr;
    }

    /**
     * Get CAPT0's CAPTURE field.
     *
     * Capture Value
     */
    inline uint16_t get_CAPT0_CAPTURE() volatile
    {
        return (CAPT0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CAPT0's CAPTURE field.
     *
     * Capture Value
     */
    inline void set_CAPT0_CAPTURE(uint16_t value) volatile
    {
        uint16_t curr = CAPT0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CAPT0 = curr;
    }

    /**
     * Get LOAD0's LOAD field.
     *
     * Timer Load Register
     */
    inline uint16_t get_LOAD0_LOAD() volatile
    {
        return (LOAD0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LOAD0's LOAD field.
     *
     * Timer Load Register
     */
    inline void set_LOAD0_LOAD(uint16_t value) volatile
    {
        uint16_t curr = LOAD0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LOAD0 = curr;
    }

    /**
     * Get HOLD0's HOLD field.
     *
     * HOLD
     */
    inline uint16_t get_HOLD0_HOLD() volatile
    {
        return (HOLD0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set HOLD0's HOLD field.
     *
     * HOLD
     */
    inline void set_HOLD0_HOLD(uint16_t value) volatile
    {
        uint16_t curr = HOLD0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        HOLD0 = curr;
    }

    /**
     * Get CNTR0's COUNTER field.
     *
     * COUNTER
     */
    inline uint16_t get_CNTR0_COUNTER() volatile
    {
        return (CNTR0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CNTR0's COUNTER field.
     *
     * COUNTER
     */
    inline void set_CNTR0_COUNTER(uint16_t value) volatile
    {
        uint16_t curr = CNTR0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CNTR0 = curr;
    }

    /**
     * Get CTRL0's CM field.
     *
     * Count Mode
     */
    inline TMR1_CTRL0_CM get_CTRL0_CM() volatile
    {
        return TMR1_CTRL0_CM((CTRL0 >> 13u) & 0b111u);
    }

    /**
     * Set CTRL0's CM field.
     *
     * Count Mode
     */
    inline void set_CTRL0_CM(TMR1_CTRL0_CM value) volatile
    {
        uint16_t curr = CTRL0;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(value) & 0b111u) << 13u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0's PCS field.
     *
     * Primary Count Source
     */
    inline TMR1_CTRL0_PCS get_CTRL0_PCS() volatile
    {
        return TMR1_CTRL0_PCS((CTRL0 >> 9u) & 0b1111u);
    }

    /**
     * Set CTRL0's PCS field.
     *
     * Primary Count Source
     */
    inline void set_CTRL0_PCS(TMR1_CTRL0_PCS value) volatile
    {
        uint16_t curr = CTRL0;

        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(value) & 0b1111u) << 9u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0's SCS field.
     *
     * Secondary Count Source
     */
    inline TMR1_CTRL0_SCS get_CTRL0_SCS() volatile
    {
        return TMR1_CTRL0_SCS((CTRL0 >> 7u) & 0b11u);
    }

    /**
     * Set CTRL0's SCS field.
     *
     * Secondary Count Source
     */
    inline void set_CTRL0_SCS(TMR1_CTRL0_SCS value) volatile
    {
        uint16_t curr = CTRL0;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTRL0 = curr;
    }

    /**
     * Get CTRL0's ONCE bit.
     *
     * Count Once
     */
    inline bool get_CTRL0_ONCE() volatile
    {
        return CTRL0 & (1u << 6u);
    }

    /**
     * Set CTRL0's ONCE bit.
     *
     * Count Once
     */
    inline void set_CTRL0_ONCE() volatile
    {
        CTRL0 |= 1u << 6u;
    }

    /**
     * Clear CTRL0's ONCE bit.
     *
     * Count Once
     */
    inline void clear_CTRL0_ONCE() volatile
    {
        CTRL0 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL0's ONCE bit.
     *
     * Count Once
     */
    inline void toggle_CTRL0_ONCE() volatile
    {
        CTRL0 ^= 1u << 6u;
    }

    /**
     * Get CTRL0's LENGTH bit.
     *
     * Count Length
     */
    inline bool get_CTRL0_LENGTH() volatile
    {
        return CTRL0 & (1u << 5u);
    }

    /**
     * Set CTRL0's LENGTH bit.
     *
     * Count Length
     */
    inline void set_CTRL0_LENGTH() volatile
    {
        CTRL0 |= 1u << 5u;
    }

    /**
     * Clear CTRL0's LENGTH bit.
     *
     * Count Length
     */
    inline void clear_CTRL0_LENGTH() volatile
    {
        CTRL0 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL0's LENGTH bit.
     *
     * Count Length
     */
    inline void toggle_CTRL0_LENGTH() volatile
    {
        CTRL0 ^= 1u << 5u;
    }

    /**
     * Get CTRL0's DIR bit.
     *
     * Count Direction
     */
    inline bool get_CTRL0_DIR() volatile
    {
        return CTRL0 & (1u << 4u);
    }

    /**
     * Set CTRL0's DIR bit.
     *
     * Count Direction
     */
    inline void set_CTRL0_DIR() volatile
    {
        CTRL0 |= 1u << 4u;
    }

    /**
     * Clear CTRL0's DIR bit.
     *
     * Count Direction
     */
    inline void clear_CTRL0_DIR() volatile
    {
        CTRL0 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL0's DIR bit.
     *
     * Count Direction
     */
    inline void toggle_CTRL0_DIR() volatile
    {
        CTRL0 ^= 1u << 4u;
    }

    /**
     * Get CTRL0's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline bool get_CTRL0_COINIT() volatile
    {
        return CTRL0 & (1u << 3u);
    }

    /**
     * Set CTRL0's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void set_CTRL0_COINIT() volatile
    {
        CTRL0 |= 1u << 3u;
    }

    /**
     * Clear CTRL0's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void clear_CTRL0_COINIT() volatile
    {
        CTRL0 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL0's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void toggle_CTRL0_COINIT() volatile
    {
        CTRL0 ^= 1u << 3u;
    }

    /**
     * Get CTRL0's OUTMODE field.
     *
     * Output Mode
     */
    inline TMR1_CTRL0_OUTMODE get_CTRL0_OUTMODE() volatile
    {
        return TMR1_CTRL0_OUTMODE((CTRL0 >> 0u) & 0b111u);
    }

    /**
     * Set CTRL0's OUTMODE field.
     *
     * Output Mode
     */
    inline void set_CTRL0_OUTMODE(TMR1_CTRL0_OUTMODE value) volatile
    {
        uint16_t curr = CTRL0;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        CTRL0 = curr;
    }

    /**
     * Get all of CTRL0's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void get_CTRL0(TMR1_CTRL0_CM &CM, TMR1_CTRL0_PCS &PCS,
                          TMR1_CTRL0_SCS &SCS, bool &ONCE, bool &LENGTH,
                          bool &DIR, bool &COINIT,
                          TMR1_CTRL0_OUTMODE &OUTMODE) volatile
    {
        uint16_t curr = CTRL0;

        CM = TMR1_CTRL0_CM((curr >> 13u) & 0b111u);
        PCS = TMR1_CTRL0_PCS((curr >> 9u) & 0b1111u);
        SCS = TMR1_CTRL0_SCS((curr >> 7u) & 0b11u);
        ONCE = curr & (1u << 6u);
        LENGTH = curr & (1u << 5u);
        DIR = curr & (1u << 4u);
        COINIT = curr & (1u << 3u);
        OUTMODE = TMR1_CTRL0_OUTMODE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of CTRL0's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void set_CTRL0(TMR1_CTRL0_CM CM, TMR1_CTRL0_PCS PCS,
                          TMR1_CTRL0_SCS SCS, bool ONCE, bool LENGTH, bool DIR,
                          bool COINIT, TMR1_CTRL0_OUTMODE OUTMODE) volatile
    {
        uint16_t curr = CTRL0;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(CM) & 0b111u) << 13u;
        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(PCS) & 0b1111u) << 9u;
        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(SCS) & 0b11u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ONCE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LENGTH & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DIR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (COINIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(OUTMODE) & 0b111u) << 0u;

        CTRL0 = curr;
    }

    /**
     * Get SCTRL0's TCF bit.
     *
     * Timer Compare Flag
     */
    inline bool get_SCTRL0_TCF() volatile
    {
        return SCTRL0 & (1u << 15u);
    }

    /**
     * Set SCTRL0's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void set_SCTRL0_TCF() volatile
    {
        SCTRL0 |= 1u << 15u;
    }

    /**
     * Clear SCTRL0's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void clear_SCTRL0_TCF() volatile
    {
        SCTRL0 &= ~(1u << 15u);
    }

    /**
     * Toggle SCTRL0's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void toggle_SCTRL0_TCF() volatile
    {
        SCTRL0 ^= 1u << 15u;
    }

    /**
     * Get SCTRL0's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline bool get_SCTRL0_TCFIE() volatile
    {
        return SCTRL0 & (1u << 14u);
    }

    /**
     * Set SCTRL0's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void set_SCTRL0_TCFIE() volatile
    {
        SCTRL0 |= 1u << 14u;
    }

    /**
     * Clear SCTRL0's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void clear_SCTRL0_TCFIE() volatile
    {
        SCTRL0 &= ~(1u << 14u);
    }

    /**
     * Toggle SCTRL0's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void toggle_SCTRL0_TCFIE() volatile
    {
        SCTRL0 ^= 1u << 14u;
    }

    /**
     * Get SCTRL0's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline bool get_SCTRL0_TOF() volatile
    {
        return SCTRL0 & (1u << 13u);
    }

    /**
     * Set SCTRL0's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void set_SCTRL0_TOF() volatile
    {
        SCTRL0 |= 1u << 13u;
    }

    /**
     * Clear SCTRL0's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void clear_SCTRL0_TOF() volatile
    {
        SCTRL0 &= ~(1u << 13u);
    }

    /**
     * Toggle SCTRL0's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void toggle_SCTRL0_TOF() volatile
    {
        SCTRL0 ^= 1u << 13u;
    }

    /**
     * Get SCTRL0's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline bool get_SCTRL0_TOFIE() volatile
    {
        return SCTRL0 & (1u << 12u);
    }

    /**
     * Set SCTRL0's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void set_SCTRL0_TOFIE() volatile
    {
        SCTRL0 |= 1u << 12u;
    }

    /**
     * Clear SCTRL0's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void clear_SCTRL0_TOFIE() volatile
    {
        SCTRL0 &= ~(1u << 12u);
    }

    /**
     * Toggle SCTRL0's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void toggle_SCTRL0_TOFIE() volatile
    {
        SCTRL0 ^= 1u << 12u;
    }

    /**
     * Get SCTRL0's IEF bit.
     *
     * Input Edge Flag
     */
    inline bool get_SCTRL0_IEF() volatile
    {
        return SCTRL0 & (1u << 11u);
    }

    /**
     * Set SCTRL0's IEF bit.
     *
     * Input Edge Flag
     */
    inline void set_SCTRL0_IEF() volatile
    {
        SCTRL0 |= 1u << 11u;
    }

    /**
     * Clear SCTRL0's IEF bit.
     *
     * Input Edge Flag
     */
    inline void clear_SCTRL0_IEF() volatile
    {
        SCTRL0 &= ~(1u << 11u);
    }

    /**
     * Toggle SCTRL0's IEF bit.
     *
     * Input Edge Flag
     */
    inline void toggle_SCTRL0_IEF() volatile
    {
        SCTRL0 ^= 1u << 11u;
    }

    /**
     * Get SCTRL0's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline bool get_SCTRL0_IEFIE() volatile
    {
        return SCTRL0 & (1u << 10u);
    }

    /**
     * Set SCTRL0's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void set_SCTRL0_IEFIE() volatile
    {
        SCTRL0 |= 1u << 10u;
    }

    /**
     * Clear SCTRL0's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void clear_SCTRL0_IEFIE() volatile
    {
        SCTRL0 &= ~(1u << 10u);
    }

    /**
     * Toggle SCTRL0's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void toggle_SCTRL0_IEFIE() volatile
    {
        SCTRL0 ^= 1u << 10u;
    }

    /**
     * Get SCTRL0's IPS bit.
     *
     * Input Polarity Select
     */
    inline bool get_SCTRL0_IPS() volatile
    {
        return SCTRL0 & (1u << 9u);
    }

    /**
     * Set SCTRL0's IPS bit.
     *
     * Input Polarity Select
     */
    inline void set_SCTRL0_IPS() volatile
    {
        SCTRL0 |= 1u << 9u;
    }

    /**
     * Clear SCTRL0's IPS bit.
     *
     * Input Polarity Select
     */
    inline void clear_SCTRL0_IPS() volatile
    {
        SCTRL0 &= ~(1u << 9u);
    }

    /**
     * Toggle SCTRL0's IPS bit.
     *
     * Input Polarity Select
     */
    inline void toggle_SCTRL0_IPS() volatile
    {
        SCTRL0 ^= 1u << 9u;
    }

    /**
     * Get SCTRL0's INPUT bit.
     *
     * External Input Signal
     */
    inline bool get_SCTRL0_INPUT() volatile
    {
        return SCTRL0 & (1u << 8u);
    }

    /**
     * Get SCTRL0's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline TMR1_SCTRL0_CAPTURE_MODE get_SCTRL0_CAPTURE_MODE() volatile
    {
        return TMR1_SCTRL0_CAPTURE_MODE((SCTRL0 >> 6u) & 0b11u);
    }

    /**
     * Set SCTRL0's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline void set_SCTRL0_CAPTURE_MODE(
        TMR1_SCTRL0_CAPTURE_MODE value) volatile
    {
        uint16_t curr = SCTRL0;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        SCTRL0 = curr;
    }

    /**
     * Get SCTRL0's MSTR bit.
     *
     * Master Mode
     */
    inline bool get_SCTRL0_MSTR() volatile
    {
        return SCTRL0 & (1u << 5u);
    }

    /**
     * Set SCTRL0's MSTR bit.
     *
     * Master Mode
     */
    inline void set_SCTRL0_MSTR() volatile
    {
        SCTRL0 |= 1u << 5u;
    }

    /**
     * Clear SCTRL0's MSTR bit.
     *
     * Master Mode
     */
    inline void clear_SCTRL0_MSTR() volatile
    {
        SCTRL0 &= ~(1u << 5u);
    }

    /**
     * Toggle SCTRL0's MSTR bit.
     *
     * Master Mode
     */
    inline void toggle_SCTRL0_MSTR() volatile
    {
        SCTRL0 ^= 1u << 5u;
    }

    /**
     * Get SCTRL0's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline bool get_SCTRL0_EEOF() volatile
    {
        return SCTRL0 & (1u << 4u);
    }

    /**
     * Set SCTRL0's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void set_SCTRL0_EEOF() volatile
    {
        SCTRL0 |= 1u << 4u;
    }

    /**
     * Clear SCTRL0's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void clear_SCTRL0_EEOF() volatile
    {
        SCTRL0 &= ~(1u << 4u);
    }

    /**
     * Toggle SCTRL0's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void toggle_SCTRL0_EEOF() volatile
    {
        SCTRL0 ^= 1u << 4u;
    }

    /**
     * Get SCTRL0's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline bool get_SCTRL0_VAL() volatile
    {
        return SCTRL0 & (1u << 3u);
    }

    /**
     * Set SCTRL0's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void set_SCTRL0_VAL() volatile
    {
        SCTRL0 |= 1u << 3u;
    }

    /**
     * Clear SCTRL0's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void clear_SCTRL0_VAL() volatile
    {
        SCTRL0 &= ~(1u << 3u);
    }

    /**
     * Toggle SCTRL0's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void toggle_SCTRL0_VAL() volatile
    {
        SCTRL0 ^= 1u << 3u;
    }

    /**
     * Get SCTRL0's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline bool get_SCTRL0_FORCE() volatile
    {
        return SCTRL0 & (1u << 2u);
    }

    /**
     * Set SCTRL0's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void set_SCTRL0_FORCE() volatile
    {
        SCTRL0 |= 1u << 2u;
    }

    /**
     * Clear SCTRL0's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void clear_SCTRL0_FORCE() volatile
    {
        SCTRL0 &= ~(1u << 2u);
    }

    /**
     * Toggle SCTRL0's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void toggle_SCTRL0_FORCE() volatile
    {
        SCTRL0 ^= 1u << 2u;
    }

    /**
     * Get SCTRL0's OPS bit.
     *
     * Output Polarity Select
     */
    inline bool get_SCTRL0_OPS() volatile
    {
        return SCTRL0 & (1u << 1u);
    }

    /**
     * Set SCTRL0's OPS bit.
     *
     * Output Polarity Select
     */
    inline void set_SCTRL0_OPS() volatile
    {
        SCTRL0 |= 1u << 1u;
    }

    /**
     * Clear SCTRL0's OPS bit.
     *
     * Output Polarity Select
     */
    inline void clear_SCTRL0_OPS() volatile
    {
        SCTRL0 &= ~(1u << 1u);
    }

    /**
     * Toggle SCTRL0's OPS bit.
     *
     * Output Polarity Select
     */
    inline void toggle_SCTRL0_OPS() volatile
    {
        SCTRL0 ^= 1u << 1u;
    }

    /**
     * Get SCTRL0's OEN bit.
     *
     * Output Enable
     */
    inline bool get_SCTRL0_OEN() volatile
    {
        return SCTRL0 & (1u << 0u);
    }

    /**
     * Set SCTRL0's OEN bit.
     *
     * Output Enable
     */
    inline void set_SCTRL0_OEN() volatile
    {
        SCTRL0 |= 1u << 0u;
    }

    /**
     * Clear SCTRL0's OEN bit.
     *
     * Output Enable
     */
    inline void clear_SCTRL0_OEN() volatile
    {
        SCTRL0 &= ~(1u << 0u);
    }

    /**
     * Toggle SCTRL0's OEN bit.
     *
     * Output Enable
     */
    inline void toggle_SCTRL0_OEN() volatile
    {
        SCTRL0 ^= 1u << 0u;
    }

    /**
     * Get all of SCTRL0's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void get_SCTRL0(bool &TCF, bool &TCFIE, bool &TOF, bool &TOFIE,
                           bool &IEF, bool &IEFIE, bool &IPS, bool &INPUT,
                           TMR1_SCTRL0_CAPTURE_MODE &CAPTURE_MODE, bool &MSTR,
                           bool &EEOF, bool &VAL, bool &FORCE, bool &OPS,
                           bool &OEN) volatile
    {
        uint16_t curr = SCTRL0;

        TCF = curr & (1u << 15u);
        TCFIE = curr & (1u << 14u);
        TOF = curr & (1u << 13u);
        TOFIE = curr & (1u << 12u);
        IEF = curr & (1u << 11u);
        IEFIE = curr & (1u << 10u);
        IPS = curr & (1u << 9u);
        INPUT = curr & (1u << 8u);
        CAPTURE_MODE = TMR1_SCTRL0_CAPTURE_MODE((curr >> 6u) & 0b11u);
        MSTR = curr & (1u << 5u);
        EEOF = curr & (1u << 4u);
        VAL = curr & (1u << 3u);
        FORCE = curr & (1u << 2u);
        OPS = curr & (1u << 1u);
        OEN = curr & (1u << 0u);
    }

    /**
     * Set all of SCTRL0's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void set_SCTRL0(bool TCF, bool TCFIE, bool TOF, bool TOFIE,
                           bool IEF, bool IEFIE, bool IPS,
                           TMR1_SCTRL0_CAPTURE_MODE CAPTURE_MODE, bool MSTR,
                           bool EEOF, bool VAL, bool FORCE, bool OPS,
                           bool OEN) volatile
    {
        uint16_t curr = SCTRL0;

        curr &= ~(0b1u << 15u);
        curr |= (TCF & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TCFIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TOF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TOFIE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (IEF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IEFIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IPS & 0b1u) << 9u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CAPTURE_MODE) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MSTR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (EEOF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VAL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FORCE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OEN & 0b1u) << 0u;

        SCTRL0 = curr;
    }

    /**
     * Get CMPLD10's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline uint16_t get_CMPLD10_COMPARATOR_LOAD_1() volatile
    {
        return (CMPLD10 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD10's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline void set_CMPLD10_COMPARATOR_LOAD_1(uint16_t value) volatile
    {
        uint16_t curr = CMPLD10;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD10 = curr;
    }

    /**
     * Get CMPLD20's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline uint16_t get_CMPLD20_COMPARATOR_LOAD_2() volatile
    {
        return (CMPLD20 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD20's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline void set_CMPLD20_COMPARATOR_LOAD_2(uint16_t value) volatile
    {
        uint16_t curr = CMPLD20;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD20 = curr;
    }

    /**
     * Get CSCTRL0's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline TMR1_CSCTRL0_DBG_EN get_CSCTRL0_DBG_EN() volatile
    {
        return TMR1_CSCTRL0_DBG_EN((CSCTRL0 >> 14u) & 0b11u);
    }

    /**
     * Set CSCTRL0's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline void set_CSCTRL0_DBG_EN(TMR1_CSCTRL0_DBG_EN value) volatile
    {
        uint16_t curr = CSCTRL0;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CSCTRL0 = curr;
    }

    /**
     * Get CSCTRL0's FAULT bit.
     *
     * Fault Enable
     */
    inline bool get_CSCTRL0_FAULT() volatile
    {
        return CSCTRL0 & (1u << 13u);
    }

    /**
     * Set CSCTRL0's FAULT bit.
     *
     * Fault Enable
     */
    inline void set_CSCTRL0_FAULT() volatile
    {
        CSCTRL0 |= 1u << 13u;
    }

    /**
     * Clear CSCTRL0's FAULT bit.
     *
     * Fault Enable
     */
    inline void clear_CSCTRL0_FAULT() volatile
    {
        CSCTRL0 &= ~(1u << 13u);
    }

    /**
     * Toggle CSCTRL0's FAULT bit.
     *
     * Fault Enable
     */
    inline void toggle_CSCTRL0_FAULT() volatile
    {
        CSCTRL0 ^= 1u << 13u;
    }

    /**
     * Get CSCTRL0's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline bool get_CSCTRL0_ALT_LOAD() volatile
    {
        return CSCTRL0 & (1u << 12u);
    }

    /**
     * Set CSCTRL0's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void set_CSCTRL0_ALT_LOAD() volatile
    {
        CSCTRL0 |= 1u << 12u;
    }

    /**
     * Clear CSCTRL0's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void clear_CSCTRL0_ALT_LOAD() volatile
    {
        CSCTRL0 &= ~(1u << 12u);
    }

    /**
     * Toggle CSCTRL0's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void toggle_CSCTRL0_ALT_LOAD() volatile
    {
        CSCTRL0 ^= 1u << 12u;
    }

    /**
     * Get CSCTRL0's ROC bit.
     *
     * Reload on Capture
     */
    inline bool get_CSCTRL0_ROC() volatile
    {
        return CSCTRL0 & (1u << 11u);
    }

    /**
     * Set CSCTRL0's ROC bit.
     *
     * Reload on Capture
     */
    inline void set_CSCTRL0_ROC() volatile
    {
        CSCTRL0 |= 1u << 11u;
    }

    /**
     * Clear CSCTRL0's ROC bit.
     *
     * Reload on Capture
     */
    inline void clear_CSCTRL0_ROC() volatile
    {
        CSCTRL0 &= ~(1u << 11u);
    }

    /**
     * Toggle CSCTRL0's ROC bit.
     *
     * Reload on Capture
     */
    inline void toggle_CSCTRL0_ROC() volatile
    {
        CSCTRL0 ^= 1u << 11u;
    }

    /**
     * Get CSCTRL0's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline bool get_CSCTRL0_TCI() volatile
    {
        return CSCTRL0 & (1u << 10u);
    }

    /**
     * Set CSCTRL0's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void set_CSCTRL0_TCI() volatile
    {
        CSCTRL0 |= 1u << 10u;
    }

    /**
     * Clear CSCTRL0's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void clear_CSCTRL0_TCI() volatile
    {
        CSCTRL0 &= ~(1u << 10u);
    }

    /**
     * Toggle CSCTRL0's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void toggle_CSCTRL0_TCI() volatile
    {
        CSCTRL0 ^= 1u << 10u;
    }

    /**
     * Get CSCTRL0's UP bit.
     *
     * Counting Direction Indicator
     */
    inline bool get_CSCTRL0_UP() volatile
    {
        return CSCTRL0 & (1u << 9u);
    }

    /**
     * Get CSCTRL0's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline bool get_CSCTRL0_TCF2EN() volatile
    {
        return CSCTRL0 & (1u << 7u);
    }

    /**
     * Set CSCTRL0's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void set_CSCTRL0_TCF2EN() volatile
    {
        CSCTRL0 |= 1u << 7u;
    }

    /**
     * Clear CSCTRL0's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void clear_CSCTRL0_TCF2EN() volatile
    {
        CSCTRL0 &= ~(1u << 7u);
    }

    /**
     * Toggle CSCTRL0's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void toggle_CSCTRL0_TCF2EN() volatile
    {
        CSCTRL0 ^= 1u << 7u;
    }

    /**
     * Get CSCTRL0's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline bool get_CSCTRL0_TCF1EN() volatile
    {
        return CSCTRL0 & (1u << 6u);
    }

    /**
     * Set CSCTRL0's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void set_CSCTRL0_TCF1EN() volatile
    {
        CSCTRL0 |= 1u << 6u;
    }

    /**
     * Clear CSCTRL0's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void clear_CSCTRL0_TCF1EN() volatile
    {
        CSCTRL0 &= ~(1u << 6u);
    }

    /**
     * Toggle CSCTRL0's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void toggle_CSCTRL0_TCF1EN() volatile
    {
        CSCTRL0 ^= 1u << 6u;
    }

    /**
     * Get CSCTRL0's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline bool get_CSCTRL0_TCF2() volatile
    {
        return CSCTRL0 & (1u << 5u);
    }

    /**
     * Set CSCTRL0's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void set_CSCTRL0_TCF2() volatile
    {
        CSCTRL0 |= 1u << 5u;
    }

    /**
     * Clear CSCTRL0's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void clear_CSCTRL0_TCF2() volatile
    {
        CSCTRL0 &= ~(1u << 5u);
    }

    /**
     * Toggle CSCTRL0's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void toggle_CSCTRL0_TCF2() volatile
    {
        CSCTRL0 ^= 1u << 5u;
    }

    /**
     * Get CSCTRL0's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline bool get_CSCTRL0_TCF1() volatile
    {
        return CSCTRL0 & (1u << 4u);
    }

    /**
     * Set CSCTRL0's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void set_CSCTRL0_TCF1() volatile
    {
        CSCTRL0 |= 1u << 4u;
    }

    /**
     * Clear CSCTRL0's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void clear_CSCTRL0_TCF1() volatile
    {
        CSCTRL0 &= ~(1u << 4u);
    }

    /**
     * Toggle CSCTRL0's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void toggle_CSCTRL0_TCF1() volatile
    {
        CSCTRL0 ^= 1u << 4u;
    }

    /**
     * Get CSCTRL0's CL2 field.
     *
     * Compare Load Control 2
     */
    inline TMR1_CSCTRL0_CL2 get_CSCTRL0_CL2() volatile
    {
        return TMR1_CSCTRL0_CL2((CSCTRL0 >> 2u) & 0b11u);
    }

    /**
     * Set CSCTRL0's CL2 field.
     *
     * Compare Load Control 2
     */
    inline void set_CSCTRL0_CL2(TMR1_CSCTRL0_CL2 value) volatile
    {
        uint16_t curr = CSCTRL0;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CSCTRL0 = curr;
    }

    /**
     * Get CSCTRL0's CL1 field.
     *
     * Compare Load Control 1
     */
    inline TMR1_CSCTRL0_CL1 get_CSCTRL0_CL1() volatile
    {
        return TMR1_CSCTRL0_CL1((CSCTRL0 >> 0u) & 0b11u);
    }

    /**
     * Set CSCTRL0's CL1 field.
     *
     * Compare Load Control 1
     */
    inline void set_CSCTRL0_CL1(TMR1_CSCTRL0_CL1 value) volatile
    {
        uint16_t curr = CSCTRL0;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CSCTRL0 = curr;
    }

    /**
     * Get all of CSCTRL0's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void get_CSCTRL0(TMR1_CSCTRL0_DBG_EN &DBG_EN, bool &FAULT,
                            bool &ALT_LOAD, bool &ROC, bool &TCI, bool &UP,
                            bool &TCF2EN, bool &TCF1EN, bool &TCF2, bool &TCF1,
                            TMR1_CSCTRL0_CL2 &CL2,
                            TMR1_CSCTRL0_CL1 &CL1) volatile
    {
        uint16_t curr = CSCTRL0;

        DBG_EN = TMR1_CSCTRL0_DBG_EN((curr >> 14u) & 0b11u);
        FAULT = curr & (1u << 13u);
        ALT_LOAD = curr & (1u << 12u);
        ROC = curr & (1u << 11u);
        TCI = curr & (1u << 10u);
        UP = curr & (1u << 9u);
        TCF2EN = curr & (1u << 7u);
        TCF1EN = curr & (1u << 6u);
        TCF2 = curr & (1u << 5u);
        TCF1 = curr & (1u << 4u);
        CL2 = TMR1_CSCTRL0_CL2((curr >> 2u) & 0b11u);
        CL1 = TMR1_CSCTRL0_CL1((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CSCTRL0's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void set_CSCTRL0(TMR1_CSCTRL0_DBG_EN DBG_EN, bool FAULT,
                            bool ALT_LOAD, bool ROC, bool TCI, bool TCF2EN,
                            bool TCF1EN, bool TCF2, bool TCF1,
                            TMR1_CSCTRL0_CL2 CL2,
                            TMR1_CSCTRL0_CL1 CL1) volatile
    {
        uint16_t curr = CSCTRL0;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(DBG_EN) & 0b11u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (FAULT & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (ALT_LOAD & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ROC & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TCI & 0b1u) << 10u;
        curr &= ~(0b1u << 7u);
        curr |= (TCF2EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TCF1EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TCF2 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TCF1 & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CL2) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CL1) & 0b11u) << 0u;

        CSCTRL0 = curr;
    }

    /**
     * Get FILT0's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline uint8_t get_FILT0_FILT_CNT() volatile
    {
        return (FILT0 >> 8u) & 0b111u;
    }

    /**
     * Set FILT0's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline void set_FILT0_FILT_CNT(uint8_t value) volatile
    {
        uint16_t curr = FILT0;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FILT0 = curr;
    }

    /**
     * Get FILT0's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline uint8_t get_FILT0_FILT_PER() volatile
    {
        return (FILT0 >> 0u) & 0b11111111u;
    }

    /**
     * Set FILT0's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline void set_FILT0_FILT_PER(uint8_t value) volatile
    {
        uint16_t curr = FILT0;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        FILT0 = curr;
    }

    /**
     * Get all of FILT0's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void get_FILT0(uint8_t &FILT_CNT, uint8_t &FILT_PER) volatile
    {
        uint16_t curr = FILT0;

        FILT_CNT = (curr >> 8u) & 0b111u;
        FILT_PER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of FILT0's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void set_FILT0(uint8_t FILT_CNT, uint8_t FILT_PER) volatile
    {
        uint16_t curr = FILT0;

        curr &= ~(0b111u << 8u);
        curr |= (FILT_CNT & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (FILT_PER & 0b11111111u) << 0u;

        FILT0 = curr;
    }

    /**
     * Get DMA0's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline bool get_DMA0_CMPLD2DE() volatile
    {
        return DMA0 & (1u << 2u);
    }

    /**
     * Set DMA0's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void set_DMA0_CMPLD2DE() volatile
    {
        DMA0 |= 1u << 2u;
    }

    /**
     * Clear DMA0's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void clear_DMA0_CMPLD2DE() volatile
    {
        DMA0 &= ~(1u << 2u);
    }

    /**
     * Toggle DMA0's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void toggle_DMA0_CMPLD2DE() volatile
    {
        DMA0 ^= 1u << 2u;
    }

    /**
     * Get DMA0's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline bool get_DMA0_CMPLD1DE() volatile
    {
        return DMA0 & (1u << 1u);
    }

    /**
     * Set DMA0's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void set_DMA0_CMPLD1DE() volatile
    {
        DMA0 |= 1u << 1u;
    }

    /**
     * Clear DMA0's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void clear_DMA0_CMPLD1DE() volatile
    {
        DMA0 &= ~(1u << 1u);
    }

    /**
     * Toggle DMA0's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void toggle_DMA0_CMPLD1DE() volatile
    {
        DMA0 ^= 1u << 1u;
    }

    /**
     * Get DMA0's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline bool get_DMA0_IEFDE() volatile
    {
        return DMA0 & (1u << 0u);
    }

    /**
     * Set DMA0's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void set_DMA0_IEFDE() volatile
    {
        DMA0 |= 1u << 0u;
    }

    /**
     * Clear DMA0's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void clear_DMA0_IEFDE() volatile
    {
        DMA0 &= ~(1u << 0u);
    }

    /**
     * Toggle DMA0's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void toggle_DMA0_IEFDE() volatile
    {
        DMA0 ^= 1u << 0u;
    }

    /**
     * Get all of DMA0's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void get_DMA0(bool &CMPLD2DE, bool &CMPLD1DE, bool &IEFDE) volatile
    {
        uint16_t curr = DMA0;

        CMPLD2DE = curr & (1u << 2u);
        CMPLD1DE = curr & (1u << 1u);
        IEFDE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA0's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void set_DMA0(bool CMPLD2DE, bool CMPLD1DE, bool IEFDE) volatile
    {
        uint16_t curr = DMA0;

        curr &= ~(0b1u << 2u);
        curr |= (CMPLD2DE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CMPLD1DE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IEFDE & 0b1u) << 0u;

        DMA0 = curr;
    }

    /**
     * Get ENBL's ENBL field.
     *
     * Timer Channel Enable
     */
    inline TMR1_ENBL_ENBL get_ENBL_ENBL() volatile
    {
        return TMR1_ENBL_ENBL((ENBL >> 0u) & 0b1111u);
    }

    /**
     * Set ENBL's ENBL field.
     *
     * Timer Channel Enable
     */
    inline void set_ENBL_ENBL(TMR1_ENBL_ENBL value) volatile
    {
        uint16_t curr = ENBL;

        curr &= ~(0b1111u << 0u);
        curr |= (std::to_underlying(value) & 0b1111u) << 0u;

        ENBL = curr;
    }

    /**
     * Get COMP11's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline uint16_t get_COMP11_COMPARISON_1() volatile
    {
        return (COMP11 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP11's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline void set_COMP11_COMPARISON_1(uint16_t value) volatile
    {
        uint16_t curr = COMP11;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP11 = curr;
    }

    /**
     * Get COMP21's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline uint16_t get_COMP21_COMPARISON_2() volatile
    {
        return (COMP21 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP21's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline void set_COMP21_COMPARISON_2(uint16_t value) volatile
    {
        uint16_t curr = COMP21;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP21 = curr;
    }

    /**
     * Get CAPT1's CAPTURE field.
     *
     * Capture Value
     */
    inline uint16_t get_CAPT1_CAPTURE() volatile
    {
        return (CAPT1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CAPT1's CAPTURE field.
     *
     * Capture Value
     */
    inline void set_CAPT1_CAPTURE(uint16_t value) volatile
    {
        uint16_t curr = CAPT1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CAPT1 = curr;
    }

    /**
     * Get LOAD1's LOAD field.
     *
     * Timer Load Register
     */
    inline uint16_t get_LOAD1_LOAD() volatile
    {
        return (LOAD1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LOAD1's LOAD field.
     *
     * Timer Load Register
     */
    inline void set_LOAD1_LOAD(uint16_t value) volatile
    {
        uint16_t curr = LOAD1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LOAD1 = curr;
    }

    /**
     * Get HOLD1's HOLD field.
     *
     * HOLD
     */
    inline uint16_t get_HOLD1_HOLD() volatile
    {
        return (HOLD1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set HOLD1's HOLD field.
     *
     * HOLD
     */
    inline void set_HOLD1_HOLD(uint16_t value) volatile
    {
        uint16_t curr = HOLD1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        HOLD1 = curr;
    }

    /**
     * Get CNTR1's COUNTER field.
     *
     * COUNTER
     */
    inline uint16_t get_CNTR1_COUNTER() volatile
    {
        return (CNTR1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CNTR1's COUNTER field.
     *
     * COUNTER
     */
    inline void set_CNTR1_COUNTER(uint16_t value) volatile
    {
        uint16_t curr = CNTR1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CNTR1 = curr;
    }

    /**
     * Get CTRL1's CM field.
     *
     * Count Mode
     */
    inline TMR1_CTRL1_CM get_CTRL1_CM() volatile
    {
        return TMR1_CTRL1_CM((CTRL1 >> 13u) & 0b111u);
    }

    /**
     * Set CTRL1's CM field.
     *
     * Count Mode
     */
    inline void set_CTRL1_CM(TMR1_CTRL1_CM value) volatile
    {
        uint16_t curr = CTRL1;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(value) & 0b111u) << 13u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's PCS field.
     *
     * Primary Count Source
     */
    inline TMR1_CTRL1_PCS get_CTRL1_PCS() volatile
    {
        return TMR1_CTRL1_PCS((CTRL1 >> 9u) & 0b1111u);
    }

    /**
     * Set CTRL1's PCS field.
     *
     * Primary Count Source
     */
    inline void set_CTRL1_PCS(TMR1_CTRL1_PCS value) volatile
    {
        uint16_t curr = CTRL1;

        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(value) & 0b1111u) << 9u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's SCS field.
     *
     * Secondary Count Source
     */
    inline TMR1_CTRL1_SCS get_CTRL1_SCS() volatile
    {
        return TMR1_CTRL1_SCS((CTRL1 >> 7u) & 0b11u);
    }

    /**
     * Set CTRL1's SCS field.
     *
     * Secondary Count Source
     */
    inline void set_CTRL1_SCS(TMR1_CTRL1_SCS value) volatile
    {
        uint16_t curr = CTRL1;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTRL1 = curr;
    }

    /**
     * Get CTRL1's ONCE bit.
     *
     * Count Once
     */
    inline bool get_CTRL1_ONCE() volatile
    {
        return CTRL1 & (1u << 6u);
    }

    /**
     * Set CTRL1's ONCE bit.
     *
     * Count Once
     */
    inline void set_CTRL1_ONCE() volatile
    {
        CTRL1 |= 1u << 6u;
    }

    /**
     * Clear CTRL1's ONCE bit.
     *
     * Count Once
     */
    inline void clear_CTRL1_ONCE() volatile
    {
        CTRL1 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL1's ONCE bit.
     *
     * Count Once
     */
    inline void toggle_CTRL1_ONCE() volatile
    {
        CTRL1 ^= 1u << 6u;
    }

    /**
     * Get CTRL1's LENGTH bit.
     *
     * Count Length
     */
    inline bool get_CTRL1_LENGTH() volatile
    {
        return CTRL1 & (1u << 5u);
    }

    /**
     * Set CTRL1's LENGTH bit.
     *
     * Count Length
     */
    inline void set_CTRL1_LENGTH() volatile
    {
        CTRL1 |= 1u << 5u;
    }

    /**
     * Clear CTRL1's LENGTH bit.
     *
     * Count Length
     */
    inline void clear_CTRL1_LENGTH() volatile
    {
        CTRL1 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL1's LENGTH bit.
     *
     * Count Length
     */
    inline void toggle_CTRL1_LENGTH() volatile
    {
        CTRL1 ^= 1u << 5u;
    }

    /**
     * Get CTRL1's DIR bit.
     *
     * Count Direction
     */
    inline bool get_CTRL1_DIR() volatile
    {
        return CTRL1 & (1u << 4u);
    }

    /**
     * Set CTRL1's DIR bit.
     *
     * Count Direction
     */
    inline void set_CTRL1_DIR() volatile
    {
        CTRL1 |= 1u << 4u;
    }

    /**
     * Clear CTRL1's DIR bit.
     *
     * Count Direction
     */
    inline void clear_CTRL1_DIR() volatile
    {
        CTRL1 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL1's DIR bit.
     *
     * Count Direction
     */
    inline void toggle_CTRL1_DIR() volatile
    {
        CTRL1 ^= 1u << 4u;
    }

    /**
     * Get CTRL1's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline bool get_CTRL1_COINIT() volatile
    {
        return CTRL1 & (1u << 3u);
    }

    /**
     * Set CTRL1's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void set_CTRL1_COINIT() volatile
    {
        CTRL1 |= 1u << 3u;
    }

    /**
     * Clear CTRL1's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void clear_CTRL1_COINIT() volatile
    {
        CTRL1 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL1's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void toggle_CTRL1_COINIT() volatile
    {
        CTRL1 ^= 1u << 3u;
    }

    /**
     * Get CTRL1's OUTMODE field.
     *
     * Output Mode
     */
    inline TMR1_CTRL1_OUTMODE get_CTRL1_OUTMODE() volatile
    {
        return TMR1_CTRL1_OUTMODE((CTRL1 >> 0u) & 0b111u);
    }

    /**
     * Set CTRL1's OUTMODE field.
     *
     * Output Mode
     */
    inline void set_CTRL1_OUTMODE(TMR1_CTRL1_OUTMODE value) volatile
    {
        uint16_t curr = CTRL1;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get all of CTRL1's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void get_CTRL1(TMR1_CTRL1_CM &CM, TMR1_CTRL1_PCS &PCS,
                          TMR1_CTRL1_SCS &SCS, bool &ONCE, bool &LENGTH,
                          bool &DIR, bool &COINIT,
                          TMR1_CTRL1_OUTMODE &OUTMODE) volatile
    {
        uint16_t curr = CTRL1;

        CM = TMR1_CTRL1_CM((curr >> 13u) & 0b111u);
        PCS = TMR1_CTRL1_PCS((curr >> 9u) & 0b1111u);
        SCS = TMR1_CTRL1_SCS((curr >> 7u) & 0b11u);
        ONCE = curr & (1u << 6u);
        LENGTH = curr & (1u << 5u);
        DIR = curr & (1u << 4u);
        COINIT = curr & (1u << 3u);
        OUTMODE = TMR1_CTRL1_OUTMODE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of CTRL1's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void set_CTRL1(TMR1_CTRL1_CM CM, TMR1_CTRL1_PCS PCS,
                          TMR1_CTRL1_SCS SCS, bool ONCE, bool LENGTH, bool DIR,
                          bool COINIT, TMR1_CTRL1_OUTMODE OUTMODE) volatile
    {
        uint16_t curr = CTRL1;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(CM) & 0b111u) << 13u;
        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(PCS) & 0b1111u) << 9u;
        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(SCS) & 0b11u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ONCE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LENGTH & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DIR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (COINIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(OUTMODE) & 0b111u) << 0u;

        CTRL1 = curr;
    }

    /**
     * Get SCTRL1's TCF bit.
     *
     * Timer Compare Flag
     */
    inline bool get_SCTRL1_TCF() volatile
    {
        return SCTRL1 & (1u << 15u);
    }

    /**
     * Set SCTRL1's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void set_SCTRL1_TCF() volatile
    {
        SCTRL1 |= 1u << 15u;
    }

    /**
     * Clear SCTRL1's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void clear_SCTRL1_TCF() volatile
    {
        SCTRL1 &= ~(1u << 15u);
    }

    /**
     * Toggle SCTRL1's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void toggle_SCTRL1_TCF() volatile
    {
        SCTRL1 ^= 1u << 15u;
    }

    /**
     * Get SCTRL1's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline bool get_SCTRL1_TCFIE() volatile
    {
        return SCTRL1 & (1u << 14u);
    }

    /**
     * Set SCTRL1's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void set_SCTRL1_TCFIE() volatile
    {
        SCTRL1 |= 1u << 14u;
    }

    /**
     * Clear SCTRL1's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void clear_SCTRL1_TCFIE() volatile
    {
        SCTRL1 &= ~(1u << 14u);
    }

    /**
     * Toggle SCTRL1's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void toggle_SCTRL1_TCFIE() volatile
    {
        SCTRL1 ^= 1u << 14u;
    }

    /**
     * Get SCTRL1's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline bool get_SCTRL1_TOF() volatile
    {
        return SCTRL1 & (1u << 13u);
    }

    /**
     * Set SCTRL1's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void set_SCTRL1_TOF() volatile
    {
        SCTRL1 |= 1u << 13u;
    }

    /**
     * Clear SCTRL1's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void clear_SCTRL1_TOF() volatile
    {
        SCTRL1 &= ~(1u << 13u);
    }

    /**
     * Toggle SCTRL1's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void toggle_SCTRL1_TOF() volatile
    {
        SCTRL1 ^= 1u << 13u;
    }

    /**
     * Get SCTRL1's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline bool get_SCTRL1_TOFIE() volatile
    {
        return SCTRL1 & (1u << 12u);
    }

    /**
     * Set SCTRL1's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void set_SCTRL1_TOFIE() volatile
    {
        SCTRL1 |= 1u << 12u;
    }

    /**
     * Clear SCTRL1's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void clear_SCTRL1_TOFIE() volatile
    {
        SCTRL1 &= ~(1u << 12u);
    }

    /**
     * Toggle SCTRL1's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void toggle_SCTRL1_TOFIE() volatile
    {
        SCTRL1 ^= 1u << 12u;
    }

    /**
     * Get SCTRL1's IEF bit.
     *
     * Input Edge Flag
     */
    inline bool get_SCTRL1_IEF() volatile
    {
        return SCTRL1 & (1u << 11u);
    }

    /**
     * Set SCTRL1's IEF bit.
     *
     * Input Edge Flag
     */
    inline void set_SCTRL1_IEF() volatile
    {
        SCTRL1 |= 1u << 11u;
    }

    /**
     * Clear SCTRL1's IEF bit.
     *
     * Input Edge Flag
     */
    inline void clear_SCTRL1_IEF() volatile
    {
        SCTRL1 &= ~(1u << 11u);
    }

    /**
     * Toggle SCTRL1's IEF bit.
     *
     * Input Edge Flag
     */
    inline void toggle_SCTRL1_IEF() volatile
    {
        SCTRL1 ^= 1u << 11u;
    }

    /**
     * Get SCTRL1's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline bool get_SCTRL1_IEFIE() volatile
    {
        return SCTRL1 & (1u << 10u);
    }

    /**
     * Set SCTRL1's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void set_SCTRL1_IEFIE() volatile
    {
        SCTRL1 |= 1u << 10u;
    }

    /**
     * Clear SCTRL1's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void clear_SCTRL1_IEFIE() volatile
    {
        SCTRL1 &= ~(1u << 10u);
    }

    /**
     * Toggle SCTRL1's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void toggle_SCTRL1_IEFIE() volatile
    {
        SCTRL1 ^= 1u << 10u;
    }

    /**
     * Get SCTRL1's IPS bit.
     *
     * Input Polarity Select
     */
    inline bool get_SCTRL1_IPS() volatile
    {
        return SCTRL1 & (1u << 9u);
    }

    /**
     * Set SCTRL1's IPS bit.
     *
     * Input Polarity Select
     */
    inline void set_SCTRL1_IPS() volatile
    {
        SCTRL1 |= 1u << 9u;
    }

    /**
     * Clear SCTRL1's IPS bit.
     *
     * Input Polarity Select
     */
    inline void clear_SCTRL1_IPS() volatile
    {
        SCTRL1 &= ~(1u << 9u);
    }

    /**
     * Toggle SCTRL1's IPS bit.
     *
     * Input Polarity Select
     */
    inline void toggle_SCTRL1_IPS() volatile
    {
        SCTRL1 ^= 1u << 9u;
    }

    /**
     * Get SCTRL1's INPUT bit.
     *
     * External Input Signal
     */
    inline bool get_SCTRL1_INPUT() volatile
    {
        return SCTRL1 & (1u << 8u);
    }

    /**
     * Get SCTRL1's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline TMR1_SCTRL1_CAPTURE_MODE get_SCTRL1_CAPTURE_MODE() volatile
    {
        return TMR1_SCTRL1_CAPTURE_MODE((SCTRL1 >> 6u) & 0b11u);
    }

    /**
     * Set SCTRL1's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline void set_SCTRL1_CAPTURE_MODE(
        TMR1_SCTRL1_CAPTURE_MODE value) volatile
    {
        uint16_t curr = SCTRL1;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        SCTRL1 = curr;
    }

    /**
     * Get SCTRL1's MSTR bit.
     *
     * Master Mode
     */
    inline bool get_SCTRL1_MSTR() volatile
    {
        return SCTRL1 & (1u << 5u);
    }

    /**
     * Set SCTRL1's MSTR bit.
     *
     * Master Mode
     */
    inline void set_SCTRL1_MSTR() volatile
    {
        SCTRL1 |= 1u << 5u;
    }

    /**
     * Clear SCTRL1's MSTR bit.
     *
     * Master Mode
     */
    inline void clear_SCTRL1_MSTR() volatile
    {
        SCTRL1 &= ~(1u << 5u);
    }

    /**
     * Toggle SCTRL1's MSTR bit.
     *
     * Master Mode
     */
    inline void toggle_SCTRL1_MSTR() volatile
    {
        SCTRL1 ^= 1u << 5u;
    }

    /**
     * Get SCTRL1's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline bool get_SCTRL1_EEOF() volatile
    {
        return SCTRL1 & (1u << 4u);
    }

    /**
     * Set SCTRL1's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void set_SCTRL1_EEOF() volatile
    {
        SCTRL1 |= 1u << 4u;
    }

    /**
     * Clear SCTRL1's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void clear_SCTRL1_EEOF() volatile
    {
        SCTRL1 &= ~(1u << 4u);
    }

    /**
     * Toggle SCTRL1's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void toggle_SCTRL1_EEOF() volatile
    {
        SCTRL1 ^= 1u << 4u;
    }

    /**
     * Get SCTRL1's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline bool get_SCTRL1_VAL() volatile
    {
        return SCTRL1 & (1u << 3u);
    }

    /**
     * Set SCTRL1's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void set_SCTRL1_VAL() volatile
    {
        SCTRL1 |= 1u << 3u;
    }

    /**
     * Clear SCTRL1's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void clear_SCTRL1_VAL() volatile
    {
        SCTRL1 &= ~(1u << 3u);
    }

    /**
     * Toggle SCTRL1's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void toggle_SCTRL1_VAL() volatile
    {
        SCTRL1 ^= 1u << 3u;
    }

    /**
     * Get SCTRL1's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline bool get_SCTRL1_FORCE() volatile
    {
        return SCTRL1 & (1u << 2u);
    }

    /**
     * Set SCTRL1's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void set_SCTRL1_FORCE() volatile
    {
        SCTRL1 |= 1u << 2u;
    }

    /**
     * Clear SCTRL1's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void clear_SCTRL1_FORCE() volatile
    {
        SCTRL1 &= ~(1u << 2u);
    }

    /**
     * Toggle SCTRL1's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void toggle_SCTRL1_FORCE() volatile
    {
        SCTRL1 ^= 1u << 2u;
    }

    /**
     * Get SCTRL1's OPS bit.
     *
     * Output Polarity Select
     */
    inline bool get_SCTRL1_OPS() volatile
    {
        return SCTRL1 & (1u << 1u);
    }

    /**
     * Set SCTRL1's OPS bit.
     *
     * Output Polarity Select
     */
    inline void set_SCTRL1_OPS() volatile
    {
        SCTRL1 |= 1u << 1u;
    }

    /**
     * Clear SCTRL1's OPS bit.
     *
     * Output Polarity Select
     */
    inline void clear_SCTRL1_OPS() volatile
    {
        SCTRL1 &= ~(1u << 1u);
    }

    /**
     * Toggle SCTRL1's OPS bit.
     *
     * Output Polarity Select
     */
    inline void toggle_SCTRL1_OPS() volatile
    {
        SCTRL1 ^= 1u << 1u;
    }

    /**
     * Get SCTRL1's OEN bit.
     *
     * Output Enable
     */
    inline bool get_SCTRL1_OEN() volatile
    {
        return SCTRL1 & (1u << 0u);
    }

    /**
     * Set SCTRL1's OEN bit.
     *
     * Output Enable
     */
    inline void set_SCTRL1_OEN() volatile
    {
        SCTRL1 |= 1u << 0u;
    }

    /**
     * Clear SCTRL1's OEN bit.
     *
     * Output Enable
     */
    inline void clear_SCTRL1_OEN() volatile
    {
        SCTRL1 &= ~(1u << 0u);
    }

    /**
     * Toggle SCTRL1's OEN bit.
     *
     * Output Enable
     */
    inline void toggle_SCTRL1_OEN() volatile
    {
        SCTRL1 ^= 1u << 0u;
    }

    /**
     * Get all of SCTRL1's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void get_SCTRL1(bool &TCF, bool &TCFIE, bool &TOF, bool &TOFIE,
                           bool &IEF, bool &IEFIE, bool &IPS, bool &INPUT,
                           TMR1_SCTRL1_CAPTURE_MODE &CAPTURE_MODE, bool &MSTR,
                           bool &EEOF, bool &VAL, bool &FORCE, bool &OPS,
                           bool &OEN) volatile
    {
        uint16_t curr = SCTRL1;

        TCF = curr & (1u << 15u);
        TCFIE = curr & (1u << 14u);
        TOF = curr & (1u << 13u);
        TOFIE = curr & (1u << 12u);
        IEF = curr & (1u << 11u);
        IEFIE = curr & (1u << 10u);
        IPS = curr & (1u << 9u);
        INPUT = curr & (1u << 8u);
        CAPTURE_MODE = TMR1_SCTRL1_CAPTURE_MODE((curr >> 6u) & 0b11u);
        MSTR = curr & (1u << 5u);
        EEOF = curr & (1u << 4u);
        VAL = curr & (1u << 3u);
        FORCE = curr & (1u << 2u);
        OPS = curr & (1u << 1u);
        OEN = curr & (1u << 0u);
    }

    /**
     * Set all of SCTRL1's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void set_SCTRL1(bool TCF, bool TCFIE, bool TOF, bool TOFIE,
                           bool IEF, bool IEFIE, bool IPS,
                           TMR1_SCTRL1_CAPTURE_MODE CAPTURE_MODE, bool MSTR,
                           bool EEOF, bool VAL, bool FORCE, bool OPS,
                           bool OEN) volatile
    {
        uint16_t curr = SCTRL1;

        curr &= ~(0b1u << 15u);
        curr |= (TCF & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TCFIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TOF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TOFIE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (IEF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IEFIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IPS & 0b1u) << 9u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CAPTURE_MODE) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MSTR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (EEOF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VAL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FORCE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OEN & 0b1u) << 0u;

        SCTRL1 = curr;
    }

    /**
     * Get CMPLD11's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline uint16_t get_CMPLD11_COMPARATOR_LOAD_1() volatile
    {
        return (CMPLD11 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD11's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline void set_CMPLD11_COMPARATOR_LOAD_1(uint16_t value) volatile
    {
        uint16_t curr = CMPLD11;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD11 = curr;
    }

    /**
     * Get CMPLD21's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline uint16_t get_CMPLD21_COMPARATOR_LOAD_2() volatile
    {
        return (CMPLD21 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD21's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline void set_CMPLD21_COMPARATOR_LOAD_2(uint16_t value) volatile
    {
        uint16_t curr = CMPLD21;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD21 = curr;
    }

    /**
     * Get CSCTRL1's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline TMR1_CSCTRL1_DBG_EN get_CSCTRL1_DBG_EN() volatile
    {
        return TMR1_CSCTRL1_DBG_EN((CSCTRL1 >> 14u) & 0b11u);
    }

    /**
     * Set CSCTRL1's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline void set_CSCTRL1_DBG_EN(TMR1_CSCTRL1_DBG_EN value) volatile
    {
        uint16_t curr = CSCTRL1;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CSCTRL1 = curr;
    }

    /**
     * Get CSCTRL1's FAULT bit.
     *
     * Fault Enable
     */
    inline bool get_CSCTRL1_FAULT() volatile
    {
        return CSCTRL1 & (1u << 13u);
    }

    /**
     * Set CSCTRL1's FAULT bit.
     *
     * Fault Enable
     */
    inline void set_CSCTRL1_FAULT() volatile
    {
        CSCTRL1 |= 1u << 13u;
    }

    /**
     * Clear CSCTRL1's FAULT bit.
     *
     * Fault Enable
     */
    inline void clear_CSCTRL1_FAULT() volatile
    {
        CSCTRL1 &= ~(1u << 13u);
    }

    /**
     * Toggle CSCTRL1's FAULT bit.
     *
     * Fault Enable
     */
    inline void toggle_CSCTRL1_FAULT() volatile
    {
        CSCTRL1 ^= 1u << 13u;
    }

    /**
     * Get CSCTRL1's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline bool get_CSCTRL1_ALT_LOAD() volatile
    {
        return CSCTRL1 & (1u << 12u);
    }

    /**
     * Set CSCTRL1's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void set_CSCTRL1_ALT_LOAD() volatile
    {
        CSCTRL1 |= 1u << 12u;
    }

    /**
     * Clear CSCTRL1's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void clear_CSCTRL1_ALT_LOAD() volatile
    {
        CSCTRL1 &= ~(1u << 12u);
    }

    /**
     * Toggle CSCTRL1's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void toggle_CSCTRL1_ALT_LOAD() volatile
    {
        CSCTRL1 ^= 1u << 12u;
    }

    /**
     * Get CSCTRL1's ROC bit.
     *
     * Reload on Capture
     */
    inline bool get_CSCTRL1_ROC() volatile
    {
        return CSCTRL1 & (1u << 11u);
    }

    /**
     * Set CSCTRL1's ROC bit.
     *
     * Reload on Capture
     */
    inline void set_CSCTRL1_ROC() volatile
    {
        CSCTRL1 |= 1u << 11u;
    }

    /**
     * Clear CSCTRL1's ROC bit.
     *
     * Reload on Capture
     */
    inline void clear_CSCTRL1_ROC() volatile
    {
        CSCTRL1 &= ~(1u << 11u);
    }

    /**
     * Toggle CSCTRL1's ROC bit.
     *
     * Reload on Capture
     */
    inline void toggle_CSCTRL1_ROC() volatile
    {
        CSCTRL1 ^= 1u << 11u;
    }

    /**
     * Get CSCTRL1's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline bool get_CSCTRL1_TCI() volatile
    {
        return CSCTRL1 & (1u << 10u);
    }

    /**
     * Set CSCTRL1's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void set_CSCTRL1_TCI() volatile
    {
        CSCTRL1 |= 1u << 10u;
    }

    /**
     * Clear CSCTRL1's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void clear_CSCTRL1_TCI() volatile
    {
        CSCTRL1 &= ~(1u << 10u);
    }

    /**
     * Toggle CSCTRL1's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void toggle_CSCTRL1_TCI() volatile
    {
        CSCTRL1 ^= 1u << 10u;
    }

    /**
     * Get CSCTRL1's UP bit.
     *
     * Counting Direction Indicator
     */
    inline bool get_CSCTRL1_UP() volatile
    {
        return CSCTRL1 & (1u << 9u);
    }

    /**
     * Get CSCTRL1's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline bool get_CSCTRL1_TCF2EN() volatile
    {
        return CSCTRL1 & (1u << 7u);
    }

    /**
     * Set CSCTRL1's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void set_CSCTRL1_TCF2EN() volatile
    {
        CSCTRL1 |= 1u << 7u;
    }

    /**
     * Clear CSCTRL1's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void clear_CSCTRL1_TCF2EN() volatile
    {
        CSCTRL1 &= ~(1u << 7u);
    }

    /**
     * Toggle CSCTRL1's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void toggle_CSCTRL1_TCF2EN() volatile
    {
        CSCTRL1 ^= 1u << 7u;
    }

    /**
     * Get CSCTRL1's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline bool get_CSCTRL1_TCF1EN() volatile
    {
        return CSCTRL1 & (1u << 6u);
    }

    /**
     * Set CSCTRL1's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void set_CSCTRL1_TCF1EN() volatile
    {
        CSCTRL1 |= 1u << 6u;
    }

    /**
     * Clear CSCTRL1's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void clear_CSCTRL1_TCF1EN() volatile
    {
        CSCTRL1 &= ~(1u << 6u);
    }

    /**
     * Toggle CSCTRL1's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void toggle_CSCTRL1_TCF1EN() volatile
    {
        CSCTRL1 ^= 1u << 6u;
    }

    /**
     * Get CSCTRL1's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline bool get_CSCTRL1_TCF2() volatile
    {
        return CSCTRL1 & (1u << 5u);
    }

    /**
     * Set CSCTRL1's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void set_CSCTRL1_TCF2() volatile
    {
        CSCTRL1 |= 1u << 5u;
    }

    /**
     * Clear CSCTRL1's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void clear_CSCTRL1_TCF2() volatile
    {
        CSCTRL1 &= ~(1u << 5u);
    }

    /**
     * Toggle CSCTRL1's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void toggle_CSCTRL1_TCF2() volatile
    {
        CSCTRL1 ^= 1u << 5u;
    }

    /**
     * Get CSCTRL1's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline bool get_CSCTRL1_TCF1() volatile
    {
        return CSCTRL1 & (1u << 4u);
    }

    /**
     * Set CSCTRL1's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void set_CSCTRL1_TCF1() volatile
    {
        CSCTRL1 |= 1u << 4u;
    }

    /**
     * Clear CSCTRL1's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void clear_CSCTRL1_TCF1() volatile
    {
        CSCTRL1 &= ~(1u << 4u);
    }

    /**
     * Toggle CSCTRL1's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void toggle_CSCTRL1_TCF1() volatile
    {
        CSCTRL1 ^= 1u << 4u;
    }

    /**
     * Get CSCTRL1's CL2 field.
     *
     * Compare Load Control 2
     */
    inline TMR1_CSCTRL1_CL2 get_CSCTRL1_CL2() volatile
    {
        return TMR1_CSCTRL1_CL2((CSCTRL1 >> 2u) & 0b11u);
    }

    /**
     * Set CSCTRL1's CL2 field.
     *
     * Compare Load Control 2
     */
    inline void set_CSCTRL1_CL2(TMR1_CSCTRL1_CL2 value) volatile
    {
        uint16_t curr = CSCTRL1;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CSCTRL1 = curr;
    }

    /**
     * Get CSCTRL1's CL1 field.
     *
     * Compare Load Control 1
     */
    inline TMR1_CSCTRL1_CL1 get_CSCTRL1_CL1() volatile
    {
        return TMR1_CSCTRL1_CL1((CSCTRL1 >> 0u) & 0b11u);
    }

    /**
     * Set CSCTRL1's CL1 field.
     *
     * Compare Load Control 1
     */
    inline void set_CSCTRL1_CL1(TMR1_CSCTRL1_CL1 value) volatile
    {
        uint16_t curr = CSCTRL1;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CSCTRL1 = curr;
    }

    /**
     * Get all of CSCTRL1's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void get_CSCTRL1(TMR1_CSCTRL1_DBG_EN &DBG_EN, bool &FAULT,
                            bool &ALT_LOAD, bool &ROC, bool &TCI, bool &UP,
                            bool &TCF2EN, bool &TCF1EN, bool &TCF2, bool &TCF1,
                            TMR1_CSCTRL1_CL2 &CL2,
                            TMR1_CSCTRL1_CL1 &CL1) volatile
    {
        uint16_t curr = CSCTRL1;

        DBG_EN = TMR1_CSCTRL1_DBG_EN((curr >> 14u) & 0b11u);
        FAULT = curr & (1u << 13u);
        ALT_LOAD = curr & (1u << 12u);
        ROC = curr & (1u << 11u);
        TCI = curr & (1u << 10u);
        UP = curr & (1u << 9u);
        TCF2EN = curr & (1u << 7u);
        TCF1EN = curr & (1u << 6u);
        TCF2 = curr & (1u << 5u);
        TCF1 = curr & (1u << 4u);
        CL2 = TMR1_CSCTRL1_CL2((curr >> 2u) & 0b11u);
        CL1 = TMR1_CSCTRL1_CL1((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CSCTRL1's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void set_CSCTRL1(TMR1_CSCTRL1_DBG_EN DBG_EN, bool FAULT,
                            bool ALT_LOAD, bool ROC, bool TCI, bool TCF2EN,
                            bool TCF1EN, bool TCF2, bool TCF1,
                            TMR1_CSCTRL1_CL2 CL2,
                            TMR1_CSCTRL1_CL1 CL1) volatile
    {
        uint16_t curr = CSCTRL1;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(DBG_EN) & 0b11u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (FAULT & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (ALT_LOAD & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ROC & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TCI & 0b1u) << 10u;
        curr &= ~(0b1u << 7u);
        curr |= (TCF2EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TCF1EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TCF2 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TCF1 & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CL2) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CL1) & 0b11u) << 0u;

        CSCTRL1 = curr;
    }

    /**
     * Get FILT1's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline uint8_t get_FILT1_FILT_CNT() volatile
    {
        return (FILT1 >> 8u) & 0b111u;
    }

    /**
     * Set FILT1's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline void set_FILT1_FILT_CNT(uint8_t value) volatile
    {
        uint16_t curr = FILT1;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FILT1 = curr;
    }

    /**
     * Get FILT1's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline uint8_t get_FILT1_FILT_PER() volatile
    {
        return (FILT1 >> 0u) & 0b11111111u;
    }

    /**
     * Set FILT1's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline void set_FILT1_FILT_PER(uint8_t value) volatile
    {
        uint16_t curr = FILT1;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        FILT1 = curr;
    }

    /**
     * Get all of FILT1's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void get_FILT1(uint8_t &FILT_CNT, uint8_t &FILT_PER) volatile
    {
        uint16_t curr = FILT1;

        FILT_CNT = (curr >> 8u) & 0b111u;
        FILT_PER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of FILT1's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void set_FILT1(uint8_t FILT_CNT, uint8_t FILT_PER) volatile
    {
        uint16_t curr = FILT1;

        curr &= ~(0b111u << 8u);
        curr |= (FILT_CNT & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (FILT_PER & 0b11111111u) << 0u;

        FILT1 = curr;
    }

    /**
     * Get DMA1's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline bool get_DMA1_CMPLD2DE() volatile
    {
        return DMA1 & (1u << 2u);
    }

    /**
     * Set DMA1's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void set_DMA1_CMPLD2DE() volatile
    {
        DMA1 |= 1u << 2u;
    }

    /**
     * Clear DMA1's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void clear_DMA1_CMPLD2DE() volatile
    {
        DMA1 &= ~(1u << 2u);
    }

    /**
     * Toggle DMA1's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void toggle_DMA1_CMPLD2DE() volatile
    {
        DMA1 ^= 1u << 2u;
    }

    /**
     * Get DMA1's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline bool get_DMA1_CMPLD1DE() volatile
    {
        return DMA1 & (1u << 1u);
    }

    /**
     * Set DMA1's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void set_DMA1_CMPLD1DE() volatile
    {
        DMA1 |= 1u << 1u;
    }

    /**
     * Clear DMA1's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void clear_DMA1_CMPLD1DE() volatile
    {
        DMA1 &= ~(1u << 1u);
    }

    /**
     * Toggle DMA1's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void toggle_DMA1_CMPLD1DE() volatile
    {
        DMA1 ^= 1u << 1u;
    }

    /**
     * Get DMA1's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline bool get_DMA1_IEFDE() volatile
    {
        return DMA1 & (1u << 0u);
    }

    /**
     * Set DMA1's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void set_DMA1_IEFDE() volatile
    {
        DMA1 |= 1u << 0u;
    }

    /**
     * Clear DMA1's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void clear_DMA1_IEFDE() volatile
    {
        DMA1 &= ~(1u << 0u);
    }

    /**
     * Toggle DMA1's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void toggle_DMA1_IEFDE() volatile
    {
        DMA1 ^= 1u << 0u;
    }

    /**
     * Get all of DMA1's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void get_DMA1(bool &CMPLD2DE, bool &CMPLD1DE, bool &IEFDE) volatile
    {
        uint16_t curr = DMA1;

        CMPLD2DE = curr & (1u << 2u);
        CMPLD1DE = curr & (1u << 1u);
        IEFDE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA1's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void set_DMA1(bool CMPLD2DE, bool CMPLD1DE, bool IEFDE) volatile
    {
        uint16_t curr = DMA1;

        curr &= ~(0b1u << 2u);
        curr |= (CMPLD2DE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CMPLD1DE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IEFDE & 0b1u) << 0u;

        DMA1 = curr;
    }

    /**
     * Get COMP12's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline uint16_t get_COMP12_COMPARISON_1() volatile
    {
        return (COMP12 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP12's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline void set_COMP12_COMPARISON_1(uint16_t value) volatile
    {
        uint16_t curr = COMP12;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP12 = curr;
    }

    /**
     * Get COMP22's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline uint16_t get_COMP22_COMPARISON_2() volatile
    {
        return (COMP22 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP22's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline void set_COMP22_COMPARISON_2(uint16_t value) volatile
    {
        uint16_t curr = COMP22;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP22 = curr;
    }

    /**
     * Get CAPT2's CAPTURE field.
     *
     * Capture Value
     */
    inline uint16_t get_CAPT2_CAPTURE() volatile
    {
        return (CAPT2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CAPT2's CAPTURE field.
     *
     * Capture Value
     */
    inline void set_CAPT2_CAPTURE(uint16_t value) volatile
    {
        uint16_t curr = CAPT2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CAPT2 = curr;
    }

    /**
     * Get LOAD2's LOAD field.
     *
     * Timer Load Register
     */
    inline uint16_t get_LOAD2_LOAD() volatile
    {
        return (LOAD2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LOAD2's LOAD field.
     *
     * Timer Load Register
     */
    inline void set_LOAD2_LOAD(uint16_t value) volatile
    {
        uint16_t curr = LOAD2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LOAD2 = curr;
    }

    /**
     * Get HOLD2's HOLD field.
     *
     * HOLD
     */
    inline uint16_t get_HOLD2_HOLD() volatile
    {
        return (HOLD2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set HOLD2's HOLD field.
     *
     * HOLD
     */
    inline void set_HOLD2_HOLD(uint16_t value) volatile
    {
        uint16_t curr = HOLD2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        HOLD2 = curr;
    }

    /**
     * Get CNTR2's COUNTER field.
     *
     * COUNTER
     */
    inline uint16_t get_CNTR2_COUNTER() volatile
    {
        return (CNTR2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CNTR2's COUNTER field.
     *
     * COUNTER
     */
    inline void set_CNTR2_COUNTER(uint16_t value) volatile
    {
        uint16_t curr = CNTR2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CNTR2 = curr;
    }

    /**
     * Get CTRL2's CM field.
     *
     * Count Mode
     */
    inline TMR1_CTRL2_CM get_CTRL2_CM() volatile
    {
        return TMR1_CTRL2_CM((CTRL2 >> 13u) & 0b111u);
    }

    /**
     * Set CTRL2's CM field.
     *
     * Count Mode
     */
    inline void set_CTRL2_CM(TMR1_CTRL2_CM value) volatile
    {
        uint16_t curr = CTRL2;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(value) & 0b111u) << 13u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's PCS field.
     *
     * Primary Count Source
     */
    inline TMR1_CTRL2_PCS get_CTRL2_PCS() volatile
    {
        return TMR1_CTRL2_PCS((CTRL2 >> 9u) & 0b1111u);
    }

    /**
     * Set CTRL2's PCS field.
     *
     * Primary Count Source
     */
    inline void set_CTRL2_PCS(TMR1_CTRL2_PCS value) volatile
    {
        uint16_t curr = CTRL2;

        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(value) & 0b1111u) << 9u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's SCS field.
     *
     * Secondary Count Source
     */
    inline TMR1_CTRL2_SCS get_CTRL2_SCS() volatile
    {
        return TMR1_CTRL2_SCS((CTRL2 >> 7u) & 0b11u);
    }

    /**
     * Set CTRL2's SCS field.
     *
     * Secondary Count Source
     */
    inline void set_CTRL2_SCS(TMR1_CTRL2_SCS value) volatile
    {
        uint16_t curr = CTRL2;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTRL2 = curr;
    }

    /**
     * Get CTRL2's ONCE bit.
     *
     * Count Once
     */
    inline bool get_CTRL2_ONCE() volatile
    {
        return CTRL2 & (1u << 6u);
    }

    /**
     * Set CTRL2's ONCE bit.
     *
     * Count Once
     */
    inline void set_CTRL2_ONCE() volatile
    {
        CTRL2 |= 1u << 6u;
    }

    /**
     * Clear CTRL2's ONCE bit.
     *
     * Count Once
     */
    inline void clear_CTRL2_ONCE() volatile
    {
        CTRL2 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL2's ONCE bit.
     *
     * Count Once
     */
    inline void toggle_CTRL2_ONCE() volatile
    {
        CTRL2 ^= 1u << 6u;
    }

    /**
     * Get CTRL2's LENGTH bit.
     *
     * Count Length
     */
    inline bool get_CTRL2_LENGTH() volatile
    {
        return CTRL2 & (1u << 5u);
    }

    /**
     * Set CTRL2's LENGTH bit.
     *
     * Count Length
     */
    inline void set_CTRL2_LENGTH() volatile
    {
        CTRL2 |= 1u << 5u;
    }

    /**
     * Clear CTRL2's LENGTH bit.
     *
     * Count Length
     */
    inline void clear_CTRL2_LENGTH() volatile
    {
        CTRL2 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL2's LENGTH bit.
     *
     * Count Length
     */
    inline void toggle_CTRL2_LENGTH() volatile
    {
        CTRL2 ^= 1u << 5u;
    }

    /**
     * Get CTRL2's DIR bit.
     *
     * Count Direction
     */
    inline bool get_CTRL2_DIR() volatile
    {
        return CTRL2 & (1u << 4u);
    }

    /**
     * Set CTRL2's DIR bit.
     *
     * Count Direction
     */
    inline void set_CTRL2_DIR() volatile
    {
        CTRL2 |= 1u << 4u;
    }

    /**
     * Clear CTRL2's DIR bit.
     *
     * Count Direction
     */
    inline void clear_CTRL2_DIR() volatile
    {
        CTRL2 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL2's DIR bit.
     *
     * Count Direction
     */
    inline void toggle_CTRL2_DIR() volatile
    {
        CTRL2 ^= 1u << 4u;
    }

    /**
     * Get CTRL2's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline bool get_CTRL2_COINIT() volatile
    {
        return CTRL2 & (1u << 3u);
    }

    /**
     * Set CTRL2's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void set_CTRL2_COINIT() volatile
    {
        CTRL2 |= 1u << 3u;
    }

    /**
     * Clear CTRL2's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void clear_CTRL2_COINIT() volatile
    {
        CTRL2 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL2's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void toggle_CTRL2_COINIT() volatile
    {
        CTRL2 ^= 1u << 3u;
    }

    /**
     * Get CTRL2's OUTMODE field.
     *
     * Output Mode
     */
    inline TMR1_CTRL2_OUTMODE get_CTRL2_OUTMODE() volatile
    {
        return TMR1_CTRL2_OUTMODE((CTRL2 >> 0u) & 0b111u);
    }

    /**
     * Set CTRL2's OUTMODE field.
     *
     * Output Mode
     */
    inline void set_CTRL2_OUTMODE(TMR1_CTRL2_OUTMODE value) volatile
    {
        uint16_t curr = CTRL2;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        CTRL2 = curr;
    }

    /**
     * Get all of CTRL2's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void get_CTRL2(TMR1_CTRL2_CM &CM, TMR1_CTRL2_PCS &PCS,
                          TMR1_CTRL2_SCS &SCS, bool &ONCE, bool &LENGTH,
                          bool &DIR, bool &COINIT,
                          TMR1_CTRL2_OUTMODE &OUTMODE) volatile
    {
        uint16_t curr = CTRL2;

        CM = TMR1_CTRL2_CM((curr >> 13u) & 0b111u);
        PCS = TMR1_CTRL2_PCS((curr >> 9u) & 0b1111u);
        SCS = TMR1_CTRL2_SCS((curr >> 7u) & 0b11u);
        ONCE = curr & (1u << 6u);
        LENGTH = curr & (1u << 5u);
        DIR = curr & (1u << 4u);
        COINIT = curr & (1u << 3u);
        OUTMODE = TMR1_CTRL2_OUTMODE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of CTRL2's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void set_CTRL2(TMR1_CTRL2_CM CM, TMR1_CTRL2_PCS PCS,
                          TMR1_CTRL2_SCS SCS, bool ONCE, bool LENGTH, bool DIR,
                          bool COINIT, TMR1_CTRL2_OUTMODE OUTMODE) volatile
    {
        uint16_t curr = CTRL2;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(CM) & 0b111u) << 13u;
        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(PCS) & 0b1111u) << 9u;
        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(SCS) & 0b11u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ONCE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LENGTH & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DIR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (COINIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(OUTMODE) & 0b111u) << 0u;

        CTRL2 = curr;
    }

    /**
     * Get SCTRL2's TCF bit.
     *
     * Timer Compare Flag
     */
    inline bool get_SCTRL2_TCF() volatile
    {
        return SCTRL2 & (1u << 15u);
    }

    /**
     * Set SCTRL2's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void set_SCTRL2_TCF() volatile
    {
        SCTRL2 |= 1u << 15u;
    }

    /**
     * Clear SCTRL2's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void clear_SCTRL2_TCF() volatile
    {
        SCTRL2 &= ~(1u << 15u);
    }

    /**
     * Toggle SCTRL2's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void toggle_SCTRL2_TCF() volatile
    {
        SCTRL2 ^= 1u << 15u;
    }

    /**
     * Get SCTRL2's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline bool get_SCTRL2_TCFIE() volatile
    {
        return SCTRL2 & (1u << 14u);
    }

    /**
     * Set SCTRL2's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void set_SCTRL2_TCFIE() volatile
    {
        SCTRL2 |= 1u << 14u;
    }

    /**
     * Clear SCTRL2's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void clear_SCTRL2_TCFIE() volatile
    {
        SCTRL2 &= ~(1u << 14u);
    }

    /**
     * Toggle SCTRL2's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void toggle_SCTRL2_TCFIE() volatile
    {
        SCTRL2 ^= 1u << 14u;
    }

    /**
     * Get SCTRL2's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline bool get_SCTRL2_TOF() volatile
    {
        return SCTRL2 & (1u << 13u);
    }

    /**
     * Set SCTRL2's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void set_SCTRL2_TOF() volatile
    {
        SCTRL2 |= 1u << 13u;
    }

    /**
     * Clear SCTRL2's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void clear_SCTRL2_TOF() volatile
    {
        SCTRL2 &= ~(1u << 13u);
    }

    /**
     * Toggle SCTRL2's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void toggle_SCTRL2_TOF() volatile
    {
        SCTRL2 ^= 1u << 13u;
    }

    /**
     * Get SCTRL2's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline bool get_SCTRL2_TOFIE() volatile
    {
        return SCTRL2 & (1u << 12u);
    }

    /**
     * Set SCTRL2's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void set_SCTRL2_TOFIE() volatile
    {
        SCTRL2 |= 1u << 12u;
    }

    /**
     * Clear SCTRL2's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void clear_SCTRL2_TOFIE() volatile
    {
        SCTRL2 &= ~(1u << 12u);
    }

    /**
     * Toggle SCTRL2's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void toggle_SCTRL2_TOFIE() volatile
    {
        SCTRL2 ^= 1u << 12u;
    }

    /**
     * Get SCTRL2's IEF bit.
     *
     * Input Edge Flag
     */
    inline bool get_SCTRL2_IEF() volatile
    {
        return SCTRL2 & (1u << 11u);
    }

    /**
     * Set SCTRL2's IEF bit.
     *
     * Input Edge Flag
     */
    inline void set_SCTRL2_IEF() volatile
    {
        SCTRL2 |= 1u << 11u;
    }

    /**
     * Clear SCTRL2's IEF bit.
     *
     * Input Edge Flag
     */
    inline void clear_SCTRL2_IEF() volatile
    {
        SCTRL2 &= ~(1u << 11u);
    }

    /**
     * Toggle SCTRL2's IEF bit.
     *
     * Input Edge Flag
     */
    inline void toggle_SCTRL2_IEF() volatile
    {
        SCTRL2 ^= 1u << 11u;
    }

    /**
     * Get SCTRL2's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline bool get_SCTRL2_IEFIE() volatile
    {
        return SCTRL2 & (1u << 10u);
    }

    /**
     * Set SCTRL2's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void set_SCTRL2_IEFIE() volatile
    {
        SCTRL2 |= 1u << 10u;
    }

    /**
     * Clear SCTRL2's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void clear_SCTRL2_IEFIE() volatile
    {
        SCTRL2 &= ~(1u << 10u);
    }

    /**
     * Toggle SCTRL2's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void toggle_SCTRL2_IEFIE() volatile
    {
        SCTRL2 ^= 1u << 10u;
    }

    /**
     * Get SCTRL2's IPS bit.
     *
     * Input Polarity Select
     */
    inline bool get_SCTRL2_IPS() volatile
    {
        return SCTRL2 & (1u << 9u);
    }

    /**
     * Set SCTRL2's IPS bit.
     *
     * Input Polarity Select
     */
    inline void set_SCTRL2_IPS() volatile
    {
        SCTRL2 |= 1u << 9u;
    }

    /**
     * Clear SCTRL2's IPS bit.
     *
     * Input Polarity Select
     */
    inline void clear_SCTRL2_IPS() volatile
    {
        SCTRL2 &= ~(1u << 9u);
    }

    /**
     * Toggle SCTRL2's IPS bit.
     *
     * Input Polarity Select
     */
    inline void toggle_SCTRL2_IPS() volatile
    {
        SCTRL2 ^= 1u << 9u;
    }

    /**
     * Get SCTRL2's INPUT bit.
     *
     * External Input Signal
     */
    inline bool get_SCTRL2_INPUT() volatile
    {
        return SCTRL2 & (1u << 8u);
    }

    /**
     * Get SCTRL2's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline TMR1_SCTRL2_CAPTURE_MODE get_SCTRL2_CAPTURE_MODE() volatile
    {
        return TMR1_SCTRL2_CAPTURE_MODE((SCTRL2 >> 6u) & 0b11u);
    }

    /**
     * Set SCTRL2's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline void set_SCTRL2_CAPTURE_MODE(
        TMR1_SCTRL2_CAPTURE_MODE value) volatile
    {
        uint16_t curr = SCTRL2;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        SCTRL2 = curr;
    }

    /**
     * Get SCTRL2's MSTR bit.
     *
     * Master Mode
     */
    inline bool get_SCTRL2_MSTR() volatile
    {
        return SCTRL2 & (1u << 5u);
    }

    /**
     * Set SCTRL2's MSTR bit.
     *
     * Master Mode
     */
    inline void set_SCTRL2_MSTR() volatile
    {
        SCTRL2 |= 1u << 5u;
    }

    /**
     * Clear SCTRL2's MSTR bit.
     *
     * Master Mode
     */
    inline void clear_SCTRL2_MSTR() volatile
    {
        SCTRL2 &= ~(1u << 5u);
    }

    /**
     * Toggle SCTRL2's MSTR bit.
     *
     * Master Mode
     */
    inline void toggle_SCTRL2_MSTR() volatile
    {
        SCTRL2 ^= 1u << 5u;
    }

    /**
     * Get SCTRL2's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline bool get_SCTRL2_EEOF() volatile
    {
        return SCTRL2 & (1u << 4u);
    }

    /**
     * Set SCTRL2's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void set_SCTRL2_EEOF() volatile
    {
        SCTRL2 |= 1u << 4u;
    }

    /**
     * Clear SCTRL2's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void clear_SCTRL2_EEOF() volatile
    {
        SCTRL2 &= ~(1u << 4u);
    }

    /**
     * Toggle SCTRL2's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void toggle_SCTRL2_EEOF() volatile
    {
        SCTRL2 ^= 1u << 4u;
    }

    /**
     * Get SCTRL2's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline bool get_SCTRL2_VAL() volatile
    {
        return SCTRL2 & (1u << 3u);
    }

    /**
     * Set SCTRL2's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void set_SCTRL2_VAL() volatile
    {
        SCTRL2 |= 1u << 3u;
    }

    /**
     * Clear SCTRL2's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void clear_SCTRL2_VAL() volatile
    {
        SCTRL2 &= ~(1u << 3u);
    }

    /**
     * Toggle SCTRL2's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void toggle_SCTRL2_VAL() volatile
    {
        SCTRL2 ^= 1u << 3u;
    }

    /**
     * Get SCTRL2's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline bool get_SCTRL2_FORCE() volatile
    {
        return SCTRL2 & (1u << 2u);
    }

    /**
     * Set SCTRL2's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void set_SCTRL2_FORCE() volatile
    {
        SCTRL2 |= 1u << 2u;
    }

    /**
     * Clear SCTRL2's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void clear_SCTRL2_FORCE() volatile
    {
        SCTRL2 &= ~(1u << 2u);
    }

    /**
     * Toggle SCTRL2's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void toggle_SCTRL2_FORCE() volatile
    {
        SCTRL2 ^= 1u << 2u;
    }

    /**
     * Get SCTRL2's OPS bit.
     *
     * Output Polarity Select
     */
    inline bool get_SCTRL2_OPS() volatile
    {
        return SCTRL2 & (1u << 1u);
    }

    /**
     * Set SCTRL2's OPS bit.
     *
     * Output Polarity Select
     */
    inline void set_SCTRL2_OPS() volatile
    {
        SCTRL2 |= 1u << 1u;
    }

    /**
     * Clear SCTRL2's OPS bit.
     *
     * Output Polarity Select
     */
    inline void clear_SCTRL2_OPS() volatile
    {
        SCTRL2 &= ~(1u << 1u);
    }

    /**
     * Toggle SCTRL2's OPS bit.
     *
     * Output Polarity Select
     */
    inline void toggle_SCTRL2_OPS() volatile
    {
        SCTRL2 ^= 1u << 1u;
    }

    /**
     * Get SCTRL2's OEN bit.
     *
     * Output Enable
     */
    inline bool get_SCTRL2_OEN() volatile
    {
        return SCTRL2 & (1u << 0u);
    }

    /**
     * Set SCTRL2's OEN bit.
     *
     * Output Enable
     */
    inline void set_SCTRL2_OEN() volatile
    {
        SCTRL2 |= 1u << 0u;
    }

    /**
     * Clear SCTRL2's OEN bit.
     *
     * Output Enable
     */
    inline void clear_SCTRL2_OEN() volatile
    {
        SCTRL2 &= ~(1u << 0u);
    }

    /**
     * Toggle SCTRL2's OEN bit.
     *
     * Output Enable
     */
    inline void toggle_SCTRL2_OEN() volatile
    {
        SCTRL2 ^= 1u << 0u;
    }

    /**
     * Get all of SCTRL2's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void get_SCTRL2(bool &TCF, bool &TCFIE, bool &TOF, bool &TOFIE,
                           bool &IEF, bool &IEFIE, bool &IPS, bool &INPUT,
                           TMR1_SCTRL2_CAPTURE_MODE &CAPTURE_MODE, bool &MSTR,
                           bool &EEOF, bool &VAL, bool &FORCE, bool &OPS,
                           bool &OEN) volatile
    {
        uint16_t curr = SCTRL2;

        TCF = curr & (1u << 15u);
        TCFIE = curr & (1u << 14u);
        TOF = curr & (1u << 13u);
        TOFIE = curr & (1u << 12u);
        IEF = curr & (1u << 11u);
        IEFIE = curr & (1u << 10u);
        IPS = curr & (1u << 9u);
        INPUT = curr & (1u << 8u);
        CAPTURE_MODE = TMR1_SCTRL2_CAPTURE_MODE((curr >> 6u) & 0b11u);
        MSTR = curr & (1u << 5u);
        EEOF = curr & (1u << 4u);
        VAL = curr & (1u << 3u);
        FORCE = curr & (1u << 2u);
        OPS = curr & (1u << 1u);
        OEN = curr & (1u << 0u);
    }

    /**
     * Set all of SCTRL2's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void set_SCTRL2(bool TCF, bool TCFIE, bool TOF, bool TOFIE,
                           bool IEF, bool IEFIE, bool IPS,
                           TMR1_SCTRL2_CAPTURE_MODE CAPTURE_MODE, bool MSTR,
                           bool EEOF, bool VAL, bool FORCE, bool OPS,
                           bool OEN) volatile
    {
        uint16_t curr = SCTRL2;

        curr &= ~(0b1u << 15u);
        curr |= (TCF & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TCFIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TOF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TOFIE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (IEF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IEFIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IPS & 0b1u) << 9u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CAPTURE_MODE) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MSTR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (EEOF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VAL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FORCE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OEN & 0b1u) << 0u;

        SCTRL2 = curr;
    }

    /**
     * Get CMPLD12's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline uint16_t get_CMPLD12_COMPARATOR_LOAD_1() volatile
    {
        return (CMPLD12 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD12's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline void set_CMPLD12_COMPARATOR_LOAD_1(uint16_t value) volatile
    {
        uint16_t curr = CMPLD12;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD12 = curr;
    }

    /**
     * Get CMPLD22's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline uint16_t get_CMPLD22_COMPARATOR_LOAD_2() volatile
    {
        return (CMPLD22 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD22's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline void set_CMPLD22_COMPARATOR_LOAD_2(uint16_t value) volatile
    {
        uint16_t curr = CMPLD22;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD22 = curr;
    }

    /**
     * Get CSCTRL2's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline TMR1_CSCTRL2_DBG_EN get_CSCTRL2_DBG_EN() volatile
    {
        return TMR1_CSCTRL2_DBG_EN((CSCTRL2 >> 14u) & 0b11u);
    }

    /**
     * Set CSCTRL2's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline void set_CSCTRL2_DBG_EN(TMR1_CSCTRL2_DBG_EN value) volatile
    {
        uint16_t curr = CSCTRL2;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CSCTRL2 = curr;
    }

    /**
     * Get CSCTRL2's FAULT bit.
     *
     * Fault Enable
     */
    inline bool get_CSCTRL2_FAULT() volatile
    {
        return CSCTRL2 & (1u << 13u);
    }

    /**
     * Set CSCTRL2's FAULT bit.
     *
     * Fault Enable
     */
    inline void set_CSCTRL2_FAULT() volatile
    {
        CSCTRL2 |= 1u << 13u;
    }

    /**
     * Clear CSCTRL2's FAULT bit.
     *
     * Fault Enable
     */
    inline void clear_CSCTRL2_FAULT() volatile
    {
        CSCTRL2 &= ~(1u << 13u);
    }

    /**
     * Toggle CSCTRL2's FAULT bit.
     *
     * Fault Enable
     */
    inline void toggle_CSCTRL2_FAULT() volatile
    {
        CSCTRL2 ^= 1u << 13u;
    }

    /**
     * Get CSCTRL2's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline bool get_CSCTRL2_ALT_LOAD() volatile
    {
        return CSCTRL2 & (1u << 12u);
    }

    /**
     * Set CSCTRL2's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void set_CSCTRL2_ALT_LOAD() volatile
    {
        CSCTRL2 |= 1u << 12u;
    }

    /**
     * Clear CSCTRL2's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void clear_CSCTRL2_ALT_LOAD() volatile
    {
        CSCTRL2 &= ~(1u << 12u);
    }

    /**
     * Toggle CSCTRL2's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void toggle_CSCTRL2_ALT_LOAD() volatile
    {
        CSCTRL2 ^= 1u << 12u;
    }

    /**
     * Get CSCTRL2's ROC bit.
     *
     * Reload on Capture
     */
    inline bool get_CSCTRL2_ROC() volatile
    {
        return CSCTRL2 & (1u << 11u);
    }

    /**
     * Set CSCTRL2's ROC bit.
     *
     * Reload on Capture
     */
    inline void set_CSCTRL2_ROC() volatile
    {
        CSCTRL2 |= 1u << 11u;
    }

    /**
     * Clear CSCTRL2's ROC bit.
     *
     * Reload on Capture
     */
    inline void clear_CSCTRL2_ROC() volatile
    {
        CSCTRL2 &= ~(1u << 11u);
    }

    /**
     * Toggle CSCTRL2's ROC bit.
     *
     * Reload on Capture
     */
    inline void toggle_CSCTRL2_ROC() volatile
    {
        CSCTRL2 ^= 1u << 11u;
    }

    /**
     * Get CSCTRL2's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline bool get_CSCTRL2_TCI() volatile
    {
        return CSCTRL2 & (1u << 10u);
    }

    /**
     * Set CSCTRL2's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void set_CSCTRL2_TCI() volatile
    {
        CSCTRL2 |= 1u << 10u;
    }

    /**
     * Clear CSCTRL2's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void clear_CSCTRL2_TCI() volatile
    {
        CSCTRL2 &= ~(1u << 10u);
    }

    /**
     * Toggle CSCTRL2's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void toggle_CSCTRL2_TCI() volatile
    {
        CSCTRL2 ^= 1u << 10u;
    }

    /**
     * Get CSCTRL2's UP bit.
     *
     * Counting Direction Indicator
     */
    inline bool get_CSCTRL2_UP() volatile
    {
        return CSCTRL2 & (1u << 9u);
    }

    /**
     * Get CSCTRL2's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline bool get_CSCTRL2_TCF2EN() volatile
    {
        return CSCTRL2 & (1u << 7u);
    }

    /**
     * Set CSCTRL2's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void set_CSCTRL2_TCF2EN() volatile
    {
        CSCTRL2 |= 1u << 7u;
    }

    /**
     * Clear CSCTRL2's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void clear_CSCTRL2_TCF2EN() volatile
    {
        CSCTRL2 &= ~(1u << 7u);
    }

    /**
     * Toggle CSCTRL2's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void toggle_CSCTRL2_TCF2EN() volatile
    {
        CSCTRL2 ^= 1u << 7u;
    }

    /**
     * Get CSCTRL2's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline bool get_CSCTRL2_TCF1EN() volatile
    {
        return CSCTRL2 & (1u << 6u);
    }

    /**
     * Set CSCTRL2's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void set_CSCTRL2_TCF1EN() volatile
    {
        CSCTRL2 |= 1u << 6u;
    }

    /**
     * Clear CSCTRL2's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void clear_CSCTRL2_TCF1EN() volatile
    {
        CSCTRL2 &= ~(1u << 6u);
    }

    /**
     * Toggle CSCTRL2's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void toggle_CSCTRL2_TCF1EN() volatile
    {
        CSCTRL2 ^= 1u << 6u;
    }

    /**
     * Get CSCTRL2's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline bool get_CSCTRL2_TCF2() volatile
    {
        return CSCTRL2 & (1u << 5u);
    }

    /**
     * Set CSCTRL2's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void set_CSCTRL2_TCF2() volatile
    {
        CSCTRL2 |= 1u << 5u;
    }

    /**
     * Clear CSCTRL2's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void clear_CSCTRL2_TCF2() volatile
    {
        CSCTRL2 &= ~(1u << 5u);
    }

    /**
     * Toggle CSCTRL2's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void toggle_CSCTRL2_TCF2() volatile
    {
        CSCTRL2 ^= 1u << 5u;
    }

    /**
     * Get CSCTRL2's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline bool get_CSCTRL2_TCF1() volatile
    {
        return CSCTRL2 & (1u << 4u);
    }

    /**
     * Set CSCTRL2's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void set_CSCTRL2_TCF1() volatile
    {
        CSCTRL2 |= 1u << 4u;
    }

    /**
     * Clear CSCTRL2's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void clear_CSCTRL2_TCF1() volatile
    {
        CSCTRL2 &= ~(1u << 4u);
    }

    /**
     * Toggle CSCTRL2's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void toggle_CSCTRL2_TCF1() volatile
    {
        CSCTRL2 ^= 1u << 4u;
    }

    /**
     * Get CSCTRL2's CL2 field.
     *
     * Compare Load Control 2
     */
    inline TMR1_CSCTRL2_CL2 get_CSCTRL2_CL2() volatile
    {
        return TMR1_CSCTRL2_CL2((CSCTRL2 >> 2u) & 0b11u);
    }

    /**
     * Set CSCTRL2's CL2 field.
     *
     * Compare Load Control 2
     */
    inline void set_CSCTRL2_CL2(TMR1_CSCTRL2_CL2 value) volatile
    {
        uint16_t curr = CSCTRL2;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CSCTRL2 = curr;
    }

    /**
     * Get CSCTRL2's CL1 field.
     *
     * Compare Load Control 1
     */
    inline TMR1_CSCTRL2_CL1 get_CSCTRL2_CL1() volatile
    {
        return TMR1_CSCTRL2_CL1((CSCTRL2 >> 0u) & 0b11u);
    }

    /**
     * Set CSCTRL2's CL1 field.
     *
     * Compare Load Control 1
     */
    inline void set_CSCTRL2_CL1(TMR1_CSCTRL2_CL1 value) volatile
    {
        uint16_t curr = CSCTRL2;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CSCTRL2 = curr;
    }

    /**
     * Get all of CSCTRL2's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void get_CSCTRL2(TMR1_CSCTRL2_DBG_EN &DBG_EN, bool &FAULT,
                            bool &ALT_LOAD, bool &ROC, bool &TCI, bool &UP,
                            bool &TCF2EN, bool &TCF1EN, bool &TCF2, bool &TCF1,
                            TMR1_CSCTRL2_CL2 &CL2,
                            TMR1_CSCTRL2_CL1 &CL1) volatile
    {
        uint16_t curr = CSCTRL2;

        DBG_EN = TMR1_CSCTRL2_DBG_EN((curr >> 14u) & 0b11u);
        FAULT = curr & (1u << 13u);
        ALT_LOAD = curr & (1u << 12u);
        ROC = curr & (1u << 11u);
        TCI = curr & (1u << 10u);
        UP = curr & (1u << 9u);
        TCF2EN = curr & (1u << 7u);
        TCF1EN = curr & (1u << 6u);
        TCF2 = curr & (1u << 5u);
        TCF1 = curr & (1u << 4u);
        CL2 = TMR1_CSCTRL2_CL2((curr >> 2u) & 0b11u);
        CL1 = TMR1_CSCTRL2_CL1((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CSCTRL2's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void set_CSCTRL2(TMR1_CSCTRL2_DBG_EN DBG_EN, bool FAULT,
                            bool ALT_LOAD, bool ROC, bool TCI, bool TCF2EN,
                            bool TCF1EN, bool TCF2, bool TCF1,
                            TMR1_CSCTRL2_CL2 CL2,
                            TMR1_CSCTRL2_CL1 CL1) volatile
    {
        uint16_t curr = CSCTRL2;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(DBG_EN) & 0b11u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (FAULT & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (ALT_LOAD & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ROC & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TCI & 0b1u) << 10u;
        curr &= ~(0b1u << 7u);
        curr |= (TCF2EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TCF1EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TCF2 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TCF1 & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CL2) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CL1) & 0b11u) << 0u;

        CSCTRL2 = curr;
    }

    /**
     * Get FILT2's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline uint8_t get_FILT2_FILT_CNT() volatile
    {
        return (FILT2 >> 8u) & 0b111u;
    }

    /**
     * Set FILT2's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline void set_FILT2_FILT_CNT(uint8_t value) volatile
    {
        uint16_t curr = FILT2;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FILT2 = curr;
    }

    /**
     * Get FILT2's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline uint8_t get_FILT2_FILT_PER() volatile
    {
        return (FILT2 >> 0u) & 0b11111111u;
    }

    /**
     * Set FILT2's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline void set_FILT2_FILT_PER(uint8_t value) volatile
    {
        uint16_t curr = FILT2;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        FILT2 = curr;
    }

    /**
     * Get all of FILT2's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void get_FILT2(uint8_t &FILT_CNT, uint8_t &FILT_PER) volatile
    {
        uint16_t curr = FILT2;

        FILT_CNT = (curr >> 8u) & 0b111u;
        FILT_PER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of FILT2's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void set_FILT2(uint8_t FILT_CNT, uint8_t FILT_PER) volatile
    {
        uint16_t curr = FILT2;

        curr &= ~(0b111u << 8u);
        curr |= (FILT_CNT & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (FILT_PER & 0b11111111u) << 0u;

        FILT2 = curr;
    }

    /**
     * Get DMA2's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline bool get_DMA2_CMPLD2DE() volatile
    {
        return DMA2 & (1u << 2u);
    }

    /**
     * Set DMA2's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void set_DMA2_CMPLD2DE() volatile
    {
        DMA2 |= 1u << 2u;
    }

    /**
     * Clear DMA2's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void clear_DMA2_CMPLD2DE() volatile
    {
        DMA2 &= ~(1u << 2u);
    }

    /**
     * Toggle DMA2's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void toggle_DMA2_CMPLD2DE() volatile
    {
        DMA2 ^= 1u << 2u;
    }

    /**
     * Get DMA2's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline bool get_DMA2_CMPLD1DE() volatile
    {
        return DMA2 & (1u << 1u);
    }

    /**
     * Set DMA2's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void set_DMA2_CMPLD1DE() volatile
    {
        DMA2 |= 1u << 1u;
    }

    /**
     * Clear DMA2's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void clear_DMA2_CMPLD1DE() volatile
    {
        DMA2 &= ~(1u << 1u);
    }

    /**
     * Toggle DMA2's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void toggle_DMA2_CMPLD1DE() volatile
    {
        DMA2 ^= 1u << 1u;
    }

    /**
     * Get DMA2's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline bool get_DMA2_IEFDE() volatile
    {
        return DMA2 & (1u << 0u);
    }

    /**
     * Set DMA2's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void set_DMA2_IEFDE() volatile
    {
        DMA2 |= 1u << 0u;
    }

    /**
     * Clear DMA2's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void clear_DMA2_IEFDE() volatile
    {
        DMA2 &= ~(1u << 0u);
    }

    /**
     * Toggle DMA2's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void toggle_DMA2_IEFDE() volatile
    {
        DMA2 ^= 1u << 0u;
    }

    /**
     * Get all of DMA2's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void get_DMA2(bool &CMPLD2DE, bool &CMPLD1DE, bool &IEFDE) volatile
    {
        uint16_t curr = DMA2;

        CMPLD2DE = curr & (1u << 2u);
        CMPLD1DE = curr & (1u << 1u);
        IEFDE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA2's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void set_DMA2(bool CMPLD2DE, bool CMPLD1DE, bool IEFDE) volatile
    {
        uint16_t curr = DMA2;

        curr &= ~(0b1u << 2u);
        curr |= (CMPLD2DE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CMPLD1DE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IEFDE & 0b1u) << 0u;

        DMA2 = curr;
    }

    /**
     * Get COMP13's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline uint16_t get_COMP13_COMPARISON_1() volatile
    {
        return (COMP13 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP13's COMPARISON_1 field.
     *
     * Comparison Value 1
     */
    inline void set_COMP13_COMPARISON_1(uint16_t value) volatile
    {
        uint16_t curr = COMP13;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP13 = curr;
    }

    /**
     * Get COMP23's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline uint16_t get_COMP23_COMPARISON_2() volatile
    {
        return (COMP23 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set COMP23's COMPARISON_2 field.
     *
     * Comparison Value 2
     */
    inline void set_COMP23_COMPARISON_2(uint16_t value) volatile
    {
        uint16_t curr = COMP23;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        COMP23 = curr;
    }

    /**
     * Get CAPT3's CAPTURE field.
     *
     * Capture Value
     */
    inline uint16_t get_CAPT3_CAPTURE() volatile
    {
        return (CAPT3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CAPT3's CAPTURE field.
     *
     * Capture Value
     */
    inline void set_CAPT3_CAPTURE(uint16_t value) volatile
    {
        uint16_t curr = CAPT3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CAPT3 = curr;
    }

    /**
     * Get LOAD3's LOAD field.
     *
     * Timer Load Register
     */
    inline uint16_t get_LOAD3_LOAD() volatile
    {
        return (LOAD3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set LOAD3's LOAD field.
     *
     * Timer Load Register
     */
    inline void set_LOAD3_LOAD(uint16_t value) volatile
    {
        uint16_t curr = LOAD3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        LOAD3 = curr;
    }

    /**
     * Get HOLD3's HOLD field.
     *
     * HOLD
     */
    inline uint16_t get_HOLD3_HOLD() volatile
    {
        return (HOLD3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set HOLD3's HOLD field.
     *
     * HOLD
     */
    inline void set_HOLD3_HOLD(uint16_t value) volatile
    {
        uint16_t curr = HOLD3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        HOLD3 = curr;
    }

    /**
     * Get CNTR3's COUNTER field.
     *
     * COUNTER
     */
    inline uint16_t get_CNTR3_COUNTER() volatile
    {
        return (CNTR3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CNTR3's COUNTER field.
     *
     * COUNTER
     */
    inline void set_CNTR3_COUNTER(uint16_t value) volatile
    {
        uint16_t curr = CNTR3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CNTR3 = curr;
    }

    /**
     * Get CTRL3's CM field.
     *
     * Count Mode
     */
    inline TMR1_CTRL3_CM get_CTRL3_CM() volatile
    {
        return TMR1_CTRL3_CM((CTRL3 >> 13u) & 0b111u);
    }

    /**
     * Set CTRL3's CM field.
     *
     * Count Mode
     */
    inline void set_CTRL3_CM(TMR1_CTRL3_CM value) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(value) & 0b111u) << 13u;

        CTRL3 = curr;
    }

    /**
     * Get CTRL3's PCS field.
     *
     * Primary Count Source
     */
    inline TMR1_CTRL3_PCS get_CTRL3_PCS() volatile
    {
        return TMR1_CTRL3_PCS((CTRL3 >> 9u) & 0b1111u);
    }

    /**
     * Set CTRL3's PCS field.
     *
     * Primary Count Source
     */
    inline void set_CTRL3_PCS(TMR1_CTRL3_PCS value) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(value) & 0b1111u) << 9u;

        CTRL3 = curr;
    }

    /**
     * Get CTRL3's SCS field.
     *
     * Secondary Count Source
     */
    inline TMR1_CTRL3_SCS get_CTRL3_SCS() volatile
    {
        return TMR1_CTRL3_SCS((CTRL3 >> 7u) & 0b11u);
    }

    /**
     * Set CTRL3's SCS field.
     *
     * Secondary Count Source
     */
    inline void set_CTRL3_SCS(TMR1_CTRL3_SCS value) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(value) & 0b11u) << 7u;

        CTRL3 = curr;
    }

    /**
     * Get CTRL3's ONCE bit.
     *
     * Count Once
     */
    inline bool get_CTRL3_ONCE() volatile
    {
        return CTRL3 & (1u << 6u);
    }

    /**
     * Set CTRL3's ONCE bit.
     *
     * Count Once
     */
    inline void set_CTRL3_ONCE() volatile
    {
        CTRL3 |= 1u << 6u;
    }

    /**
     * Clear CTRL3's ONCE bit.
     *
     * Count Once
     */
    inline void clear_CTRL3_ONCE() volatile
    {
        CTRL3 &= ~(1u << 6u);
    }

    /**
     * Toggle CTRL3's ONCE bit.
     *
     * Count Once
     */
    inline void toggle_CTRL3_ONCE() volatile
    {
        CTRL3 ^= 1u << 6u;
    }

    /**
     * Get CTRL3's LENGTH bit.
     *
     * Count Length
     */
    inline bool get_CTRL3_LENGTH() volatile
    {
        return CTRL3 & (1u << 5u);
    }

    /**
     * Set CTRL3's LENGTH bit.
     *
     * Count Length
     */
    inline void set_CTRL3_LENGTH() volatile
    {
        CTRL3 |= 1u << 5u;
    }

    /**
     * Clear CTRL3's LENGTH bit.
     *
     * Count Length
     */
    inline void clear_CTRL3_LENGTH() volatile
    {
        CTRL3 &= ~(1u << 5u);
    }

    /**
     * Toggle CTRL3's LENGTH bit.
     *
     * Count Length
     */
    inline void toggle_CTRL3_LENGTH() volatile
    {
        CTRL3 ^= 1u << 5u;
    }

    /**
     * Get CTRL3's DIR bit.
     *
     * Count Direction
     */
    inline bool get_CTRL3_DIR() volatile
    {
        return CTRL3 & (1u << 4u);
    }

    /**
     * Set CTRL3's DIR bit.
     *
     * Count Direction
     */
    inline void set_CTRL3_DIR() volatile
    {
        CTRL3 |= 1u << 4u;
    }

    /**
     * Clear CTRL3's DIR bit.
     *
     * Count Direction
     */
    inline void clear_CTRL3_DIR() volatile
    {
        CTRL3 &= ~(1u << 4u);
    }

    /**
     * Toggle CTRL3's DIR bit.
     *
     * Count Direction
     */
    inline void toggle_CTRL3_DIR() volatile
    {
        CTRL3 ^= 1u << 4u;
    }

    /**
     * Get CTRL3's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline bool get_CTRL3_COINIT() volatile
    {
        return CTRL3 & (1u << 3u);
    }

    /**
     * Set CTRL3's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void set_CTRL3_COINIT() volatile
    {
        CTRL3 |= 1u << 3u;
    }

    /**
     * Clear CTRL3's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void clear_CTRL3_COINIT() volatile
    {
        CTRL3 &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL3's COINIT bit.
     *
     * Co-Channel Initialization
     */
    inline void toggle_CTRL3_COINIT() volatile
    {
        CTRL3 ^= 1u << 3u;
    }

    /**
     * Get CTRL3's OUTMODE field.
     *
     * Output Mode
     */
    inline TMR1_CTRL3_OUTMODE get_CTRL3_OUTMODE() volatile
    {
        return TMR1_CTRL3_OUTMODE((CTRL3 >> 0u) & 0b111u);
    }

    /**
     * Set CTRL3's OUTMODE field.
     *
     * Output Mode
     */
    inline void set_CTRL3_OUTMODE(TMR1_CTRL3_OUTMODE value) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(value) & 0b111u) << 0u;

        CTRL3 = curr;
    }

    /**
     * Get all of CTRL3's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void get_CTRL3(TMR1_CTRL3_CM &CM, TMR1_CTRL3_PCS &PCS,
                          TMR1_CTRL3_SCS &SCS, bool &ONCE, bool &LENGTH,
                          bool &DIR, bool &COINIT,
                          TMR1_CTRL3_OUTMODE &OUTMODE) volatile
    {
        uint16_t curr = CTRL3;

        CM = TMR1_CTRL3_CM((curr >> 13u) & 0b111u);
        PCS = TMR1_CTRL3_PCS((curr >> 9u) & 0b1111u);
        SCS = TMR1_CTRL3_SCS((curr >> 7u) & 0b11u);
        ONCE = curr & (1u << 6u);
        LENGTH = curr & (1u << 5u);
        DIR = curr & (1u << 4u);
        COINIT = curr & (1u << 3u);
        OUTMODE = TMR1_CTRL3_OUTMODE((curr >> 0u) & 0b111u);
    }

    /**
     * Set all of CTRL3's bit fields.
     *
     * (read-write) Timer Channel Control Register
     */
    inline void set_CTRL3(TMR1_CTRL3_CM CM, TMR1_CTRL3_PCS PCS,
                          TMR1_CTRL3_SCS SCS, bool ONCE, bool LENGTH, bool DIR,
                          bool COINIT, TMR1_CTRL3_OUTMODE OUTMODE) volatile
    {
        uint16_t curr = CTRL3;

        curr &= ~(0b111u << 13u);
        curr |= (std::to_underlying(CM) & 0b111u) << 13u;
        curr &= ~(0b1111u << 9u);
        curr |= (std::to_underlying(PCS) & 0b1111u) << 9u;
        curr &= ~(0b11u << 7u);
        curr |= (std::to_underlying(SCS) & 0b11u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (ONCE & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (LENGTH & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (DIR & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (COINIT & 0b1u) << 3u;
        curr &= ~(0b111u << 0u);
        curr |= (std::to_underlying(OUTMODE) & 0b111u) << 0u;

        CTRL3 = curr;
    }

    /**
     * Get SCTRL3's TCF bit.
     *
     * Timer Compare Flag
     */
    inline bool get_SCTRL3_TCF() volatile
    {
        return SCTRL3 & (1u << 15u);
    }

    /**
     * Set SCTRL3's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void set_SCTRL3_TCF() volatile
    {
        SCTRL3 |= 1u << 15u;
    }

    /**
     * Clear SCTRL3's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void clear_SCTRL3_TCF() volatile
    {
        SCTRL3 &= ~(1u << 15u);
    }

    /**
     * Toggle SCTRL3's TCF bit.
     *
     * Timer Compare Flag
     */
    inline void toggle_SCTRL3_TCF() volatile
    {
        SCTRL3 ^= 1u << 15u;
    }

    /**
     * Get SCTRL3's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline bool get_SCTRL3_TCFIE() volatile
    {
        return SCTRL3 & (1u << 14u);
    }

    /**
     * Set SCTRL3's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void set_SCTRL3_TCFIE() volatile
    {
        SCTRL3 |= 1u << 14u;
    }

    /**
     * Clear SCTRL3's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void clear_SCTRL3_TCFIE() volatile
    {
        SCTRL3 &= ~(1u << 14u);
    }

    /**
     * Toggle SCTRL3's TCFIE bit.
     *
     * Timer Compare Flag Interrupt Enable
     */
    inline void toggle_SCTRL3_TCFIE() volatile
    {
        SCTRL3 ^= 1u << 14u;
    }

    /**
     * Get SCTRL3's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline bool get_SCTRL3_TOF() volatile
    {
        return SCTRL3 & (1u << 13u);
    }

    /**
     * Set SCTRL3's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void set_SCTRL3_TOF() volatile
    {
        SCTRL3 |= 1u << 13u;
    }

    /**
     * Clear SCTRL3's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void clear_SCTRL3_TOF() volatile
    {
        SCTRL3 &= ~(1u << 13u);
    }

    /**
     * Toggle SCTRL3's TOF bit.
     *
     * Timer Overflow Flag
     */
    inline void toggle_SCTRL3_TOF() volatile
    {
        SCTRL3 ^= 1u << 13u;
    }

    /**
     * Get SCTRL3's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline bool get_SCTRL3_TOFIE() volatile
    {
        return SCTRL3 & (1u << 12u);
    }

    /**
     * Set SCTRL3's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void set_SCTRL3_TOFIE() volatile
    {
        SCTRL3 |= 1u << 12u;
    }

    /**
     * Clear SCTRL3's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void clear_SCTRL3_TOFIE() volatile
    {
        SCTRL3 &= ~(1u << 12u);
    }

    /**
     * Toggle SCTRL3's TOFIE bit.
     *
     * Timer Overflow Flag Interrupt Enable
     */
    inline void toggle_SCTRL3_TOFIE() volatile
    {
        SCTRL3 ^= 1u << 12u;
    }

    /**
     * Get SCTRL3's IEF bit.
     *
     * Input Edge Flag
     */
    inline bool get_SCTRL3_IEF() volatile
    {
        return SCTRL3 & (1u << 11u);
    }

    /**
     * Set SCTRL3's IEF bit.
     *
     * Input Edge Flag
     */
    inline void set_SCTRL3_IEF() volatile
    {
        SCTRL3 |= 1u << 11u;
    }

    /**
     * Clear SCTRL3's IEF bit.
     *
     * Input Edge Flag
     */
    inline void clear_SCTRL3_IEF() volatile
    {
        SCTRL3 &= ~(1u << 11u);
    }

    /**
     * Toggle SCTRL3's IEF bit.
     *
     * Input Edge Flag
     */
    inline void toggle_SCTRL3_IEF() volatile
    {
        SCTRL3 ^= 1u << 11u;
    }

    /**
     * Get SCTRL3's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline bool get_SCTRL3_IEFIE() volatile
    {
        return SCTRL3 & (1u << 10u);
    }

    /**
     * Set SCTRL3's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void set_SCTRL3_IEFIE() volatile
    {
        SCTRL3 |= 1u << 10u;
    }

    /**
     * Clear SCTRL3's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void clear_SCTRL3_IEFIE() volatile
    {
        SCTRL3 &= ~(1u << 10u);
    }

    /**
     * Toggle SCTRL3's IEFIE bit.
     *
     * Input Edge Flag Interrupt Enable
     */
    inline void toggle_SCTRL3_IEFIE() volatile
    {
        SCTRL3 ^= 1u << 10u;
    }

    /**
     * Get SCTRL3's IPS bit.
     *
     * Input Polarity Select
     */
    inline bool get_SCTRL3_IPS() volatile
    {
        return SCTRL3 & (1u << 9u);
    }

    /**
     * Set SCTRL3's IPS bit.
     *
     * Input Polarity Select
     */
    inline void set_SCTRL3_IPS() volatile
    {
        SCTRL3 |= 1u << 9u;
    }

    /**
     * Clear SCTRL3's IPS bit.
     *
     * Input Polarity Select
     */
    inline void clear_SCTRL3_IPS() volatile
    {
        SCTRL3 &= ~(1u << 9u);
    }

    /**
     * Toggle SCTRL3's IPS bit.
     *
     * Input Polarity Select
     */
    inline void toggle_SCTRL3_IPS() volatile
    {
        SCTRL3 ^= 1u << 9u;
    }

    /**
     * Get SCTRL3's INPUT bit.
     *
     * External Input Signal
     */
    inline bool get_SCTRL3_INPUT() volatile
    {
        return SCTRL3 & (1u << 8u);
    }

    /**
     * Get SCTRL3's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline TMR1_SCTRL3_CAPTURE_MODE get_SCTRL3_CAPTURE_MODE() volatile
    {
        return TMR1_SCTRL3_CAPTURE_MODE((SCTRL3 >> 6u) & 0b11u);
    }

    /**
     * Set SCTRL3's CAPTURE_MODE field.
     *
     * Input Capture Mode
     */
    inline void set_SCTRL3_CAPTURE_MODE(
        TMR1_SCTRL3_CAPTURE_MODE value) volatile
    {
        uint16_t curr = SCTRL3;

        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(value) & 0b11u) << 6u;

        SCTRL3 = curr;
    }

    /**
     * Get SCTRL3's MSTR bit.
     *
     * Master Mode
     */
    inline bool get_SCTRL3_MSTR() volatile
    {
        return SCTRL3 & (1u << 5u);
    }

    /**
     * Set SCTRL3's MSTR bit.
     *
     * Master Mode
     */
    inline void set_SCTRL3_MSTR() volatile
    {
        SCTRL3 |= 1u << 5u;
    }

    /**
     * Clear SCTRL3's MSTR bit.
     *
     * Master Mode
     */
    inline void clear_SCTRL3_MSTR() volatile
    {
        SCTRL3 &= ~(1u << 5u);
    }

    /**
     * Toggle SCTRL3's MSTR bit.
     *
     * Master Mode
     */
    inline void toggle_SCTRL3_MSTR() volatile
    {
        SCTRL3 ^= 1u << 5u;
    }

    /**
     * Get SCTRL3's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline bool get_SCTRL3_EEOF() volatile
    {
        return SCTRL3 & (1u << 4u);
    }

    /**
     * Set SCTRL3's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void set_SCTRL3_EEOF() volatile
    {
        SCTRL3 |= 1u << 4u;
    }

    /**
     * Clear SCTRL3's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void clear_SCTRL3_EEOF() volatile
    {
        SCTRL3 &= ~(1u << 4u);
    }

    /**
     * Toggle SCTRL3's EEOF bit.
     *
     * Enable External OFLAG Force
     */
    inline void toggle_SCTRL3_EEOF() volatile
    {
        SCTRL3 ^= 1u << 4u;
    }

    /**
     * Get SCTRL3's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline bool get_SCTRL3_VAL() volatile
    {
        return SCTRL3 & (1u << 3u);
    }

    /**
     * Set SCTRL3's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void set_SCTRL3_VAL() volatile
    {
        SCTRL3 |= 1u << 3u;
    }

    /**
     * Clear SCTRL3's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void clear_SCTRL3_VAL() volatile
    {
        SCTRL3 &= ~(1u << 3u);
    }

    /**
     * Toggle SCTRL3's VAL bit.
     *
     * Forced OFLAG Value
     */
    inline void toggle_SCTRL3_VAL() volatile
    {
        SCTRL3 ^= 1u << 3u;
    }

    /**
     * Get SCTRL3's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline bool get_SCTRL3_FORCE() volatile
    {
        return SCTRL3 & (1u << 2u);
    }

    /**
     * Set SCTRL3's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void set_SCTRL3_FORCE() volatile
    {
        SCTRL3 |= 1u << 2u;
    }

    /**
     * Clear SCTRL3's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void clear_SCTRL3_FORCE() volatile
    {
        SCTRL3 &= ~(1u << 2u);
    }

    /**
     * Toggle SCTRL3's FORCE bit.
     *
     * Force OFLAG Output
     */
    inline void toggle_SCTRL3_FORCE() volatile
    {
        SCTRL3 ^= 1u << 2u;
    }

    /**
     * Get SCTRL3's OPS bit.
     *
     * Output Polarity Select
     */
    inline bool get_SCTRL3_OPS() volatile
    {
        return SCTRL3 & (1u << 1u);
    }

    /**
     * Set SCTRL3's OPS bit.
     *
     * Output Polarity Select
     */
    inline void set_SCTRL3_OPS() volatile
    {
        SCTRL3 |= 1u << 1u;
    }

    /**
     * Clear SCTRL3's OPS bit.
     *
     * Output Polarity Select
     */
    inline void clear_SCTRL3_OPS() volatile
    {
        SCTRL3 &= ~(1u << 1u);
    }

    /**
     * Toggle SCTRL3's OPS bit.
     *
     * Output Polarity Select
     */
    inline void toggle_SCTRL3_OPS() volatile
    {
        SCTRL3 ^= 1u << 1u;
    }

    /**
     * Get SCTRL3's OEN bit.
     *
     * Output Enable
     */
    inline bool get_SCTRL3_OEN() volatile
    {
        return SCTRL3 & (1u << 0u);
    }

    /**
     * Set SCTRL3's OEN bit.
     *
     * Output Enable
     */
    inline void set_SCTRL3_OEN() volatile
    {
        SCTRL3 |= 1u << 0u;
    }

    /**
     * Clear SCTRL3's OEN bit.
     *
     * Output Enable
     */
    inline void clear_SCTRL3_OEN() volatile
    {
        SCTRL3 &= ~(1u << 0u);
    }

    /**
     * Toggle SCTRL3's OEN bit.
     *
     * Output Enable
     */
    inline void toggle_SCTRL3_OEN() volatile
    {
        SCTRL3 ^= 1u << 0u;
    }

    /**
     * Get all of SCTRL3's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void get_SCTRL3(bool &TCF, bool &TCFIE, bool &TOF, bool &TOFIE,
                           bool &IEF, bool &IEFIE, bool &IPS, bool &INPUT,
                           TMR1_SCTRL3_CAPTURE_MODE &CAPTURE_MODE, bool &MSTR,
                           bool &EEOF, bool &VAL, bool &FORCE, bool &OPS,
                           bool &OEN) volatile
    {
        uint16_t curr = SCTRL3;

        TCF = curr & (1u << 15u);
        TCFIE = curr & (1u << 14u);
        TOF = curr & (1u << 13u);
        TOFIE = curr & (1u << 12u);
        IEF = curr & (1u << 11u);
        IEFIE = curr & (1u << 10u);
        IPS = curr & (1u << 9u);
        INPUT = curr & (1u << 8u);
        CAPTURE_MODE = TMR1_SCTRL3_CAPTURE_MODE((curr >> 6u) & 0b11u);
        MSTR = curr & (1u << 5u);
        EEOF = curr & (1u << 4u);
        VAL = curr & (1u << 3u);
        FORCE = curr & (1u << 2u);
        OPS = curr & (1u << 1u);
        OEN = curr & (1u << 0u);
    }

    /**
     * Set all of SCTRL3's bit fields.
     *
     * (read-write) Timer Channel Status and Control Register
     */
    inline void set_SCTRL3(bool TCF, bool TCFIE, bool TOF, bool TOFIE,
                           bool IEF, bool IEFIE, bool IPS,
                           TMR1_SCTRL3_CAPTURE_MODE CAPTURE_MODE, bool MSTR,
                           bool EEOF, bool VAL, bool FORCE, bool OPS,
                           bool OEN) volatile
    {
        uint16_t curr = SCTRL3;

        curr &= ~(0b1u << 15u);
        curr |= (TCF & 0b1u) << 15u;
        curr &= ~(0b1u << 14u);
        curr |= (TCFIE & 0b1u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (TOF & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (TOFIE & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (IEF & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (IEFIE & 0b1u) << 10u;
        curr &= ~(0b1u << 9u);
        curr |= (IPS & 0b1u) << 9u;
        curr &= ~(0b11u << 6u);
        curr |= (std::to_underlying(CAPTURE_MODE) & 0b11u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (MSTR & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (EEOF & 0b1u) << 4u;
        curr &= ~(0b1u << 3u);
        curr |= (VAL & 0b1u) << 3u;
        curr &= ~(0b1u << 2u);
        curr |= (FORCE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (OPS & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (OEN & 0b1u) << 0u;

        SCTRL3 = curr;
    }

    /**
     * Get CMPLD13's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline uint16_t get_CMPLD13_COMPARATOR_LOAD_1() volatile
    {
        return (CMPLD13 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD13's COMPARATOR_LOAD_1 field.
     *
     * COMPARATOR_LOAD_1
     */
    inline void set_CMPLD13_COMPARATOR_LOAD_1(uint16_t value) volatile
    {
        uint16_t curr = CMPLD13;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD13 = curr;
    }

    /**
     * Get CMPLD23's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline uint16_t get_CMPLD23_COMPARATOR_LOAD_2() volatile
    {
        return (CMPLD23 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CMPLD23's COMPARATOR_LOAD_2 field.
     *
     * COMPARATOR_LOAD_2
     */
    inline void set_CMPLD23_COMPARATOR_LOAD_2(uint16_t value) volatile
    {
        uint16_t curr = CMPLD23;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CMPLD23 = curr;
    }

    /**
     * Get CSCTRL3's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline TMR1_CSCTRL3_DBG_EN get_CSCTRL3_DBG_EN() volatile
    {
        return TMR1_CSCTRL3_DBG_EN((CSCTRL3 >> 14u) & 0b11u);
    }

    /**
     * Set CSCTRL3's DBG_EN field.
     *
     * Debug Actions Enable
     */
    inline void set_CSCTRL3_DBG_EN(TMR1_CSCTRL3_DBG_EN value) volatile
    {
        uint16_t curr = CSCTRL3;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(value) & 0b11u) << 14u;

        CSCTRL3 = curr;
    }

    /**
     * Get CSCTRL3's FAULT bit.
     *
     * Fault Enable
     */
    inline bool get_CSCTRL3_FAULT() volatile
    {
        return CSCTRL3 & (1u << 13u);
    }

    /**
     * Set CSCTRL3's FAULT bit.
     *
     * Fault Enable
     */
    inline void set_CSCTRL3_FAULT() volatile
    {
        CSCTRL3 |= 1u << 13u;
    }

    /**
     * Clear CSCTRL3's FAULT bit.
     *
     * Fault Enable
     */
    inline void clear_CSCTRL3_FAULT() volatile
    {
        CSCTRL3 &= ~(1u << 13u);
    }

    /**
     * Toggle CSCTRL3's FAULT bit.
     *
     * Fault Enable
     */
    inline void toggle_CSCTRL3_FAULT() volatile
    {
        CSCTRL3 ^= 1u << 13u;
    }

    /**
     * Get CSCTRL3's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline bool get_CSCTRL3_ALT_LOAD() volatile
    {
        return CSCTRL3 & (1u << 12u);
    }

    /**
     * Set CSCTRL3's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void set_CSCTRL3_ALT_LOAD() volatile
    {
        CSCTRL3 |= 1u << 12u;
    }

    /**
     * Clear CSCTRL3's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void clear_CSCTRL3_ALT_LOAD() volatile
    {
        CSCTRL3 &= ~(1u << 12u);
    }

    /**
     * Toggle CSCTRL3's ALT_LOAD bit.
     *
     * Alternative Load Enable
     */
    inline void toggle_CSCTRL3_ALT_LOAD() volatile
    {
        CSCTRL3 ^= 1u << 12u;
    }

    /**
     * Get CSCTRL3's ROC bit.
     *
     * Reload on Capture
     */
    inline bool get_CSCTRL3_ROC() volatile
    {
        return CSCTRL3 & (1u << 11u);
    }

    /**
     * Set CSCTRL3's ROC bit.
     *
     * Reload on Capture
     */
    inline void set_CSCTRL3_ROC() volatile
    {
        CSCTRL3 |= 1u << 11u;
    }

    /**
     * Clear CSCTRL3's ROC bit.
     *
     * Reload on Capture
     */
    inline void clear_CSCTRL3_ROC() volatile
    {
        CSCTRL3 &= ~(1u << 11u);
    }

    /**
     * Toggle CSCTRL3's ROC bit.
     *
     * Reload on Capture
     */
    inline void toggle_CSCTRL3_ROC() volatile
    {
        CSCTRL3 ^= 1u << 11u;
    }

    /**
     * Get CSCTRL3's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline bool get_CSCTRL3_TCI() volatile
    {
        return CSCTRL3 & (1u << 10u);
    }

    /**
     * Set CSCTRL3's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void set_CSCTRL3_TCI() volatile
    {
        CSCTRL3 |= 1u << 10u;
    }

    /**
     * Clear CSCTRL3's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void clear_CSCTRL3_TCI() volatile
    {
        CSCTRL3 &= ~(1u << 10u);
    }

    /**
     * Toggle CSCTRL3's TCI bit.
     *
     * Triggered Count Initialization Control
     */
    inline void toggle_CSCTRL3_TCI() volatile
    {
        CSCTRL3 ^= 1u << 10u;
    }

    /**
     * Get CSCTRL3's UP bit.
     *
     * Counting Direction Indicator
     */
    inline bool get_CSCTRL3_UP() volatile
    {
        return CSCTRL3 & (1u << 9u);
    }

    /**
     * Get CSCTRL3's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline bool get_CSCTRL3_TCF2EN() volatile
    {
        return CSCTRL3 & (1u << 7u);
    }

    /**
     * Set CSCTRL3's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void set_CSCTRL3_TCF2EN() volatile
    {
        CSCTRL3 |= 1u << 7u;
    }

    /**
     * Clear CSCTRL3's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void clear_CSCTRL3_TCF2EN() volatile
    {
        CSCTRL3 &= ~(1u << 7u);
    }

    /**
     * Toggle CSCTRL3's TCF2EN bit.
     *
     * Timer Compare 2 Interrupt Enable
     */
    inline void toggle_CSCTRL3_TCF2EN() volatile
    {
        CSCTRL3 ^= 1u << 7u;
    }

    /**
     * Get CSCTRL3's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline bool get_CSCTRL3_TCF1EN() volatile
    {
        return CSCTRL3 & (1u << 6u);
    }

    /**
     * Set CSCTRL3's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void set_CSCTRL3_TCF1EN() volatile
    {
        CSCTRL3 |= 1u << 6u;
    }

    /**
     * Clear CSCTRL3's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void clear_CSCTRL3_TCF1EN() volatile
    {
        CSCTRL3 &= ~(1u << 6u);
    }

    /**
     * Toggle CSCTRL3's TCF1EN bit.
     *
     * Timer Compare 1 Interrupt Enable
     */
    inline void toggle_CSCTRL3_TCF1EN() volatile
    {
        CSCTRL3 ^= 1u << 6u;
    }

    /**
     * Get CSCTRL3's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline bool get_CSCTRL3_TCF2() volatile
    {
        return CSCTRL3 & (1u << 5u);
    }

    /**
     * Set CSCTRL3's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void set_CSCTRL3_TCF2() volatile
    {
        CSCTRL3 |= 1u << 5u;
    }

    /**
     * Clear CSCTRL3's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void clear_CSCTRL3_TCF2() volatile
    {
        CSCTRL3 &= ~(1u << 5u);
    }

    /**
     * Toggle CSCTRL3's TCF2 bit.
     *
     * Timer Compare 2 Interrupt Flag
     */
    inline void toggle_CSCTRL3_TCF2() volatile
    {
        CSCTRL3 ^= 1u << 5u;
    }

    /**
     * Get CSCTRL3's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline bool get_CSCTRL3_TCF1() volatile
    {
        return CSCTRL3 & (1u << 4u);
    }

    /**
     * Set CSCTRL3's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void set_CSCTRL3_TCF1() volatile
    {
        CSCTRL3 |= 1u << 4u;
    }

    /**
     * Clear CSCTRL3's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void clear_CSCTRL3_TCF1() volatile
    {
        CSCTRL3 &= ~(1u << 4u);
    }

    /**
     * Toggle CSCTRL3's TCF1 bit.
     *
     * Timer Compare 1 Interrupt Flag
     */
    inline void toggle_CSCTRL3_TCF1() volatile
    {
        CSCTRL3 ^= 1u << 4u;
    }

    /**
     * Get CSCTRL3's CL2 field.
     *
     * Compare Load Control 2
     */
    inline TMR1_CSCTRL3_CL2 get_CSCTRL3_CL2() volatile
    {
        return TMR1_CSCTRL3_CL2((CSCTRL3 >> 2u) & 0b11u);
    }

    /**
     * Set CSCTRL3's CL2 field.
     *
     * Compare Load Control 2
     */
    inline void set_CSCTRL3_CL2(TMR1_CSCTRL3_CL2 value) volatile
    {
        uint16_t curr = CSCTRL3;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CSCTRL3 = curr;
    }

    /**
     * Get CSCTRL3's CL1 field.
     *
     * Compare Load Control 1
     */
    inline TMR1_CSCTRL3_CL1 get_CSCTRL3_CL1() volatile
    {
        return TMR1_CSCTRL3_CL1((CSCTRL3 >> 0u) & 0b11u);
    }

    /**
     * Set CSCTRL3's CL1 field.
     *
     * Compare Load Control 1
     */
    inline void set_CSCTRL3_CL1(TMR1_CSCTRL3_CL1 value) volatile
    {
        uint16_t curr = CSCTRL3;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CSCTRL3 = curr;
    }

    /**
     * Get all of CSCTRL3's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void get_CSCTRL3(TMR1_CSCTRL3_DBG_EN &DBG_EN, bool &FAULT,
                            bool &ALT_LOAD, bool &ROC, bool &TCI, bool &UP,
                            bool &TCF2EN, bool &TCF1EN, bool &TCF2, bool &TCF1,
                            TMR1_CSCTRL3_CL2 &CL2,
                            TMR1_CSCTRL3_CL1 &CL1) volatile
    {
        uint16_t curr = CSCTRL3;

        DBG_EN = TMR1_CSCTRL3_DBG_EN((curr >> 14u) & 0b11u);
        FAULT = curr & (1u << 13u);
        ALT_LOAD = curr & (1u << 12u);
        ROC = curr & (1u << 11u);
        TCI = curr & (1u << 10u);
        UP = curr & (1u << 9u);
        TCF2EN = curr & (1u << 7u);
        TCF1EN = curr & (1u << 6u);
        TCF2 = curr & (1u << 5u);
        TCF1 = curr & (1u << 4u);
        CL2 = TMR1_CSCTRL3_CL2((curr >> 2u) & 0b11u);
        CL1 = TMR1_CSCTRL3_CL1((curr >> 0u) & 0b11u);
    }

    /**
     * Set all of CSCTRL3's bit fields.
     *
     * (read-write) Timer Channel Comparator Status and Control Register
     */
    inline void set_CSCTRL3(TMR1_CSCTRL3_DBG_EN DBG_EN, bool FAULT,
                            bool ALT_LOAD, bool ROC, bool TCI, bool TCF2EN,
                            bool TCF1EN, bool TCF2, bool TCF1,
                            TMR1_CSCTRL3_CL2 CL2,
                            TMR1_CSCTRL3_CL1 CL1) volatile
    {
        uint16_t curr = CSCTRL3;

        curr &= ~(0b11u << 14u);
        curr |= (std::to_underlying(DBG_EN) & 0b11u) << 14u;
        curr &= ~(0b1u << 13u);
        curr |= (FAULT & 0b1u) << 13u;
        curr &= ~(0b1u << 12u);
        curr |= (ALT_LOAD & 0b1u) << 12u;
        curr &= ~(0b1u << 11u);
        curr |= (ROC & 0b1u) << 11u;
        curr &= ~(0b1u << 10u);
        curr |= (TCI & 0b1u) << 10u;
        curr &= ~(0b1u << 7u);
        curr |= (TCF2EN & 0b1u) << 7u;
        curr &= ~(0b1u << 6u);
        curr |= (TCF1EN & 0b1u) << 6u;
        curr &= ~(0b1u << 5u);
        curr |= (TCF2 & 0b1u) << 5u;
        curr &= ~(0b1u << 4u);
        curr |= (TCF1 & 0b1u) << 4u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(CL2) & 0b11u) << 2u;
        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(CL1) & 0b11u) << 0u;

        CSCTRL3 = curr;
    }

    /**
     * Get FILT3's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline uint8_t get_FILT3_FILT_CNT() volatile
    {
        return (FILT3 >> 8u) & 0b111u;
    }

    /**
     * Set FILT3's FILT_CNT field.
     *
     * Input Filter Sample Count
     */
    inline void set_FILT3_FILT_CNT(uint8_t value) volatile
    {
        uint16_t curr = FILT3;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FILT3 = curr;
    }

    /**
     * Get FILT3's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline uint8_t get_FILT3_FILT_PER() volatile
    {
        return (FILT3 >> 0u) & 0b11111111u;
    }

    /**
     * Set FILT3's FILT_PER field.
     *
     * Input Filter Sample Period
     */
    inline void set_FILT3_FILT_PER(uint8_t value) volatile
    {
        uint16_t curr = FILT3;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        FILT3 = curr;
    }

    /**
     * Get all of FILT3's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void get_FILT3(uint8_t &FILT_CNT, uint8_t &FILT_PER) volatile
    {
        uint16_t curr = FILT3;

        FILT_CNT = (curr >> 8u) & 0b111u;
        FILT_PER = (curr >> 0u) & 0b11111111u;
    }

    /**
     * Set all of FILT3's bit fields.
     *
     * (read-write) Timer Channel Input Filter Register
     */
    inline void set_FILT3(uint8_t FILT_CNT, uint8_t FILT_PER) volatile
    {
        uint16_t curr = FILT3;

        curr &= ~(0b111u << 8u);
        curr |= (FILT_CNT & 0b111u) << 8u;
        curr &= ~(0b11111111u << 0u);
        curr |= (FILT_PER & 0b11111111u) << 0u;

        FILT3 = curr;
    }

    /**
     * Get DMA3's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline bool get_DMA3_CMPLD2DE() volatile
    {
        return DMA3 & (1u << 2u);
    }

    /**
     * Set DMA3's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void set_DMA3_CMPLD2DE() volatile
    {
        DMA3 |= 1u << 2u;
    }

    /**
     * Clear DMA3's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void clear_DMA3_CMPLD2DE() volatile
    {
        DMA3 &= ~(1u << 2u);
    }

    /**
     * Toggle DMA3's CMPLD2DE bit.
     *
     * Comparator Preload Register 2 DMA Enable
     */
    inline void toggle_DMA3_CMPLD2DE() volatile
    {
        DMA3 ^= 1u << 2u;
    }

    /**
     * Get DMA3's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline bool get_DMA3_CMPLD1DE() volatile
    {
        return DMA3 & (1u << 1u);
    }

    /**
     * Set DMA3's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void set_DMA3_CMPLD1DE() volatile
    {
        DMA3 |= 1u << 1u;
    }

    /**
     * Clear DMA3's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void clear_DMA3_CMPLD1DE() volatile
    {
        DMA3 &= ~(1u << 1u);
    }

    /**
     * Toggle DMA3's CMPLD1DE bit.
     *
     * Comparator Preload Register 1 DMA Enable
     */
    inline void toggle_DMA3_CMPLD1DE() volatile
    {
        DMA3 ^= 1u << 1u;
    }

    /**
     * Get DMA3's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline bool get_DMA3_IEFDE() volatile
    {
        return DMA3 & (1u << 0u);
    }

    /**
     * Set DMA3's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void set_DMA3_IEFDE() volatile
    {
        DMA3 |= 1u << 0u;
    }

    /**
     * Clear DMA3's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void clear_DMA3_IEFDE() volatile
    {
        DMA3 &= ~(1u << 0u);
    }

    /**
     * Toggle DMA3's IEFDE bit.
     *
     * Input Edge Flag DMA Enable
     */
    inline void toggle_DMA3_IEFDE() volatile
    {
        DMA3 ^= 1u << 0u;
    }

    /**
     * Get all of DMA3's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void get_DMA3(bool &CMPLD2DE, bool &CMPLD1DE, bool &IEFDE) volatile
    {
        uint16_t curr = DMA3;

        CMPLD2DE = curr & (1u << 2u);
        CMPLD1DE = curr & (1u << 1u);
        IEFDE = curr & (1u << 0u);
    }

    /**
     * Set all of DMA3's bit fields.
     *
     * (read-write) Timer Channel DMA Enable Register
     */
    inline void set_DMA3(bool CMPLD2DE, bool CMPLD1DE, bool IEFDE) volatile
    {
        uint16_t curr = DMA3;

        curr &= ~(0b1u << 2u);
        curr |= (CMPLD2DE & 0b1u) << 2u;
        curr &= ~(0b1u << 1u);
        curr |= (CMPLD1DE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IEFDE & 0b1u) << 0u;

        DMA3 = curr;
    }
};

static_assert(sizeof(tmr1) == tmr1::size);

static volatile tmr1 *const TMR1 = reinterpret_cast<tmr1 *>(0x4015C000);

static volatile tmr1 *const TMR2 = reinterpret_cast<tmr1 *>(0x40160000);

static volatile tmr1 *const TMR3 = reinterpret_cast<tmr1 *>(0x40164000);

static volatile tmr1 *const TMR4 = reinterpret_cast<tmr1 *>(0x40168000);

}; // namespace MIMXRT1176::CM7
